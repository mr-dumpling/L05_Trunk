Index: vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java
===================================================================
--- vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java	(revision 0)
+++ vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java	(revision 12965)
@@ -0,0 +1,4271 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.uicc;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Message;
+// MTK-START
+import android.os.SystemProperties;
+import android.telephony.TelephonyManager;
+// MTK-END
+import android.telephony.CarrierConfigManager;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.text.TextUtils;
+import android.telephony.Rlog;
+import android.content.res.Resources;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.MccTable;
+// MTK-START
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.ServiceStateTracker;
+// MTK-END
+import com.android.internal.telephony.SmsConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.gsm.SimTlv;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
+
+// MTK-START
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_DEFAULT_NAME;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneFactory;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.telephony.SubscriptionManager;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
+import android.app.ActivityManagerNative;
+import android.os.UserHandle;
+import static android.Manifest.permission.READ_PHONE_STATE;
+// MTK-END
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+// MTK-START
+import android.content.BroadcastReceiver;
+import com.mediatek.common.telephony.ITelephonyExt;
+import com.mediatek.common.MPlugin;
+import android.app.AlertDialog;
+import android.os.PowerManager;
+import android.view.WindowManager;
+import android.content.DialogInterface;
+
+// MTK-END
+
+/**
+ * {@hide}
+ */
+public class SIMRecords extends IccRecords {
+    protected static final String LOG_TAG = "SIMRecords";
+
+    private static final boolean CRASH_RIL = false;
+
+    // ***** Instance Variables
+
+    VoiceMailConstants mVmConfig;
+
+
+    SpnOverride mSpnOverride;
+
+    // ***** Cached SIM State; cleared on channel close
+
+    private int mCallForwardingStatus;
+
+
+    /**
+     * States only used by getSpnFsm FSM
+     */
+    private GetSpnFsmState mSpnState;
+
+    /** CPHS service information (See CPHS 4.2 B.3.1.1)
+     *  It will be set in onSimReady if reading GET_CPHS_INFO successfully
+     *  mCphsInfo[0] is CPHS Phase
+     *  mCphsInfo[1] and mCphsInfo[2] is CPHS Service Table
+     */
+    private byte[] mCphsInfo = null;
+    boolean mCspPlmnEnabled = true;
+
+    byte[] mEfMWIS = null;
+    byte[] mEfCPHS_MWI =null;
+    byte[] mEfCff = null;
+    byte[] mEfCfis = null;
+
+    byte[] mEfLi = null;
+    byte[] mEfPl = null;
+
+    int mSpnDisplayCondition;
+    // Numeric network codes listed in TS 51.011 EF[SPDI]
+    ArrayList<String> mSpdiNetworks = null;
+
+    String mPnnHomeName = null;
+
+    UsimServiceTable mUsimServiceTable;
+
+    @Override
+    public String toString() {
+        return "SimRecords: " + super.toString()
+                + " mVmConfig" + mVmConfig
+                + " mSpnOverride=" + "mSpnOverride"
+                + " callForwardingEnabled=" + mCallForwardingStatus
+                + " spnState=" + mSpnState
+                + " mCphsInfo=" + mCphsInfo
+                + " mCspPlmnEnabled=" + mCspPlmnEnabled
+                + " efMWIS=" + mEfMWIS
+                + " efCPHS_MWI=" + mEfCPHS_MWI
+                + " mEfCff=" + mEfCff
+                + " mEfCfis=" + mEfCfis
+                + " getOperatorNumeric=" + getOperatorNumeric();
+    }
+
+    // ***** Constants
+
+    // From TS 51.011 EF[SPDI] section
+    static final int TAG_SPDI = 0xA3;
+    static final int TAG_SPDI_PLMN_LIST = 0x80;
+
+    // Full Name IEI from TS 24.008
+    static final int TAG_FULL_NETWORK_NAME = 0x43;
+
+    // Short Name IEI from TS 24.008
+    static final int TAG_SHORT_NETWORK_NAME = 0x45;
+
+    // active CFF from CPHS 4.2 B.4.5
+    static final int CFF_UNCONDITIONAL_ACTIVE = 0x0a;
+    static final int CFF_UNCONDITIONAL_DEACTIVE = 0x05;
+    static final int CFF_LINE1_MASK = 0x0f;
+    static final int CFF_LINE1_RESET = 0xf0;
+
+    // CPHS Service Table (See CPHS 4.2 B.3.1)
+    private static final int CPHS_SST_MBN_MASK = 0x30;
+    private static final int CPHS_SST_MBN_ENABLED = 0x30;
+
+    // EF_CFIS related constants
+    // Spec reference TS 51.011 section 10.3.46.
+    private static final int CFIS_BCD_NUMBER_LENGTH_OFFSET = 2;
+    private static final int CFIS_TON_NPI_OFFSET = 3;
+    private static final int CFIS_ADN_CAPABILITY_ID_OFFSET = 14;
+    private static final int CFIS_ADN_EXTENSION_ID_OFFSET = 15;
+
+    // ***** Event Constants
+    private static final int EVENT_GET_IMSI_DONE = 3;
+    private static final int EVENT_GET_ICCID_DONE = 4;
+    private static final int EVENT_GET_MBI_DONE = 5;
+    private static final int EVENT_GET_MBDN_DONE = 6;
+    private static final int EVENT_GET_MWIS_DONE = 7;
+    private static final int EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE = 8;
+    protected static final int EVENT_GET_AD_DONE = 9; // Admin data on SIM
+    protected static final int EVENT_GET_MSISDN_DONE = 10;
+    private static final int EVENT_GET_CPHS_MAILBOX_DONE = 11;
+    private static final int EVENT_GET_SPN_DONE = 12;
+    private static final int EVENT_GET_SPDI_DONE = 13;
+    private static final int EVENT_UPDATE_DONE = 14;
+    private static final int EVENT_GET_PNN_DONE = 15;
+    protected static final int EVENT_GET_SST_DONE = 17;
+    private static final int EVENT_GET_ALL_SMS_DONE = 18;
+    private static final int EVENT_MARK_SMS_READ_DONE = 19;
+    private static final int EVENT_SET_MBDN_DONE = 20;
+    private static final int EVENT_SMS_ON_SIM = 21;
+    private static final int EVENT_GET_SMS_DONE = 22;
+    private static final int EVENT_GET_CFF_DONE = 24;
+    private static final int EVENT_SET_CPHS_MAILBOX_DONE = 25;
+    private static final int EVENT_GET_INFO_CPHS_DONE = 26;
+    // private static final int EVENT_SET_MSISDN_DONE = 30; Defined in IccRecords as 30
+    private static final int EVENT_SIM_REFRESH = 31;
+    private static final int EVENT_GET_CFIS_DONE = 32;
+    private static final int EVENT_GET_CSP_CPHS_DONE = 33;
+    private static final int EVENT_GET_GID1_DONE = 34;
+    private static final int EVENT_APP_LOCKED = 35;
+    private static final int EVENT_GET_GID2_DONE = 36;
+    private static final int EVENT_CARRIER_CONFIG_CHANGED = 37;
+
+    // MTK-START
+    private static final int EVENT_RADIO_AVAILABLE = 41;
+    private static final int EVENT_GET_LI_DONE = 42;
+    private static final int EVENT_GET_ELP_DONE = 43;
+    private static final int EVENT_DUAL_IMSI_READY = 44;
+
+    private static final int EVENT_QUERY_MENU_TITLE_DONE = 53;
+
+    private static final int EVENT_GET_SIM_ECC_DONE = 102;
+    private static final int EVENT_GET_USIM_ECC_DONE = 103;
+    private static final int EVENT_GET_ALL_OPL_DONE = 104;
+    private static final int EVENT_GET_CPHSONS_DONE = 105;
+    private static final int EVENT_GET_SHORT_CPHSONS_DONE = 106;
+    private static final int EVENT_QUERY_ICCID_DONE = 107;
+    private static final int EVENT_DELAYED_SEND_PHB_CHANGE = 200;
+    private static final int EVENT_RADIO_STATE_CHANGED = 201;
+    private static final int EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED = 203; // ALPS00302698 ENS
+    private static final int EVENT_GET_RAT_DONE = 204; // ALPS00302702 RAT balancing
+    private static final int EVENT_QUERY_ICCID_DONE_FOR_HOT_SWAP = 205;
+    private static final int EVENT_GET_NEW_MSISDN_DONE = 206;
+    private static final int EVENT_GET_PSISMSC_DONE = 207; // USim authentication
+    private static final int EVENT_GET_SMSP_DONE = 208; // USim authentication
+    private static final int EVENT_GET_GBABP_DONE = 209;
+    private static final int EVENT_GET_GBANL_DONE = 210;
+    private static final int EVENT_CFU_IND = 211;
+    private static final int EVENT_IMSI_REFRESH_QUERY = 212;
+    private static final int EVENT_IMSI_REFRESH_QUERY_DONE = 213;
+    private static final int EVENT_GET_EF_ICCID_DONE = 300;
+
+    /* Remote SIM ME lock */
+    private static final int EVENT_MELOCK_CHANGED = 400;
+    // MTK-END
+
+    // Lookup table for carriers known to produce SIMs which incorrectly indicate MNC length.
+
+    private static final String[] MCCMNC_CODES_HAVING_3DIGITS_MNC = {
+        "302370", "302720", "310260",
+        "405025", "405026", "405027", "405028", "405029", "405030", "405031", "405032",
+        "405033", "405034", "405035", "405036", "405037", "405038", "405039", "405040",
+        "405041", "405042", "405043", "405044", "405045", "405046", "405047", "405750",
+        "405751", "405752", "405753", "405754", "405755", "405756", "405799", "405800",
+        "405801", "405802", "405803", "405804", "405805", "405806", "405807", "405808",
+        "405809", "405810", "405811", "405812", "405813", "405814", "405815", "405816",
+        "405817", "405818", "405819", "405820", "405821", "405822", "405823", "405824",
+        "405825", "405826", "405827", "405828", "405829", "405830", "405831", "405832",
+        "405833", "405834", "405835", "405836", "405837", "405838", "405839", "405840",
+        "405841", "405842", "405843", "405844", "405845", "405846", "405847", "405848",
+        "405849", "405850", "405851", "405852", "405853", "405875", "405876", "405877",
+        "405878", "405879", "405880", "405881", "405882", "405883", "405884", "405885",
+        "405886", "405908", "405909", "405910", "405911", "405912", "405913", "405914",
+        "405915", "405916", "405917", "405918", "405919", "405920", "405921", "405922",
+        "405923", "405924", "405925", "405926", "405927", "405928", "405929", "405930",
+        "405931", "405932", "502142", "502143", "502145", "502146", "502147", "502148"
+    };
+    // MTK-START
+    private static final String KEY_SIM_ID = "SIM_ID";
+
+    private boolean isValidMBI = false;
+
+    // ALPS00302702 RAT balancing
+    private boolean mEfRatLoaded = false;
+    private byte[] mEfRat = null;
+
+    private static final String[] LANGUAGE_CODE_FOR_LP = {
+        "de", "en", "it", "fr", "es", "nl", "sv", "da", "pt", "fi",
+        "no", "el", "tr", "hu", "pl", "",
+        "cs", "he", "ar", "ru", "is", "", "", "", "", "",
+        "", "", "", "", "", ""
+    };
+
+    int mSlotId;
+
+    private ITelephonyExt mTelephonyExt;
+    private BroadcastReceiver mSimReceiver;
+    private BroadcastReceiver mSubReceiver;
+    private RadioTechnologyChangedReceiver mRTC;
+    String cphsOnsl;
+    String cphsOnss;
+    private int iccIdQueryState = -1; // -1: init, 0: query error, 1: query successful
+    private boolean hasQueryIccId;
+
+    private int efLanguageToLoad = 0;
+    private boolean mIsPhbEfResetDone = false;
+
+    private String mSimImsi = null;
+    private byte[] mEfSST = null;
+    private byte[] mEfELP = null;
+    private byte[] mEfPsismsc = null;
+    private byte[] mEfSmsp = null;
+
+    static final String[] SIMRECORD_PROPERTY_RIL_PHB_READY  = {
+        "gsm.sim.ril.phbready",
+        "gsm.sim.ril.phbready.2",
+        "gsm.sim.ril.phbready.3",
+        "gsm.sim.ril.phbready.4"
+    };
+
+    static final String[] SIMRECORD_PROPERTY_RIL_PUK1  = {
+        "gsm.sim.retry.puk1",
+        "gsm.sim.retry.puk1.2",
+        "gsm.sim.retry.puk1.3",
+        "gsm.sim.retry.puk1.4",
+    };
+
+    private String[] SIM_RECORDS_PROPERTY_ECC_LIST = {
+        "ril.ecclist",
+        "ril.ecclist1",
+        "ril.ecclist2",
+        "ril.ecclist3",
+    };
+
+    private boolean mPhbReady = false;
+    private boolean mPhbWaitSub = false;
+    private boolean mSIMInfoReady = false;
+
+    public static class OperatorName {
+        public String sFullName;
+        public String sShortName;
+    }
+
+    /*Operator list recode
+    * include numeric mcc mnc code
+    * and a range of LAC, the operator name index in PNN
+    */
+    public static class OplRecord {
+        public String sPlmn;
+        public int nMinLAC;
+        public int nMaxLAC;
+        public int nPnnIndex;
+    }
+
+    //Operator name listed in TS 51.011 EF[PNN] for plmn in operator list(EF[OPL])
+    private ArrayList<OperatorName> mPnnNetworkNames = null;
+    //Operator list in TS 51.011 EF[OPL]
+    private ArrayList<OplRecord> mOperatorList = null;
+
+    private String mSpNameInEfSpn = null; // MVNO-API
+
+    private String mMenuTitleFromEf = null;
+
+    //3g dongle
+    private boolean isDispose = false;
+    private static final int[] simServiceNumber = {
+        1, 17, 51, 52, 54, 55, 56, 0, 12, 3, 7, 0, 0
+    };
+
+    private static final int[] usimServiceNumber = {
+        0, 19, 45, 46, 48, 49, 51, 71, 12, 2, 0, 42, 0
+    };
+
+    private UiccCard mUiccCard;
+    private UiccController mUiccController;
+    private String mGbabp;
+    private ArrayList<byte[]> mEfGbanlList;
+    private String[] mGbanl;
+
+    private Phone mPhone;
+
+    String mEfEcc = "";
+    // MTK-END
+
+    // ***** Constructor
+
+    public SIMRecords(UiccCardApplication app, Context c, CommandsInterface ci) {
+        super(app, c, ci);
+
+        // MTK-START
+        mSlotId = app.getSlotId();
+        mUiccController = UiccController.getInstance();
+        mUiccCard = mUiccController.getUiccCard(mSlotId);
+        log("mUiccCard Instance = " + mUiccCard);
+
+        mPhone = PhoneFactory.getPhone(app.getPhoneId());
+
+        //mAdnCache = new AdnRecordCache(mFh);
+        mAdnCache = new AdnRecordCache(mFh, ci, app);
+        ///M: Move UPBM code to here for phone restart event to contacts app.begin
+        Intent intent = new Intent();
+        intent.setAction("android.intent.action.ACTION_PHONE_RESTART");
+        intent.putExtra("SimId", mSlotId);
+        mContext.sendBroadcast(intent);
+        // MTK-END
+
+        mVmConfig = new VoiceMailConstants();
+        // MTK-START
+        //mSpnOverride = new SpnOverride();
+        mSpnOverride = SpnOverride.getInstance();
+        // MTK-END
+
+        mRecordsRequested = false;  // No load request is made till SIM ready
+
+        // recordsToLoad is set to 0 because no requests are made yet
+        mRecordsToLoad = 0;
+
+        // MTK-START
+        cphsOnsl = null;
+        cphsOnss = null;
+        hasQueryIccId = false;
+        // MTK-END
+        mCi.setOnSmsOnSim(this, EVENT_SMS_ON_SIM, null);
+        mCi.registerForIccRefresh(this, EVENT_SIM_REFRESH, null);
+        // MTK-START
+        mCi.registerForPhbReady(this, EVENT_PHB_READY, null);
+        /* register for CFU info flag notification */
+        mCi.registerForCallForwardingInfo(this, EVENT_CFU_IND, null);
+        mCi.registerForRadioStateChanged(this, EVENT_RADIO_STATE_CHANGED, null);
+        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
+        mCi.registerForEfCspPlmnModeBitChanged(this, EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED, null);
+        mCi.registerForMelockChanged(this, EVENT_MELOCK_CHANGED, null);
+
+        mCi.registerForImsiRefreshDone(this, EVENT_IMSI_REFRESH_QUERY, null);
+        // MTK-END
+
+        // Start off by setting empty state
+        resetRecords();
+        mParentApp.registerForReady(this, EVENT_APP_READY, null);
+        mParentApp.registerForLocked(this, EVENT_APP_LOCKED, null);
+
+        // MTK-START
+        mSimReceiver = new SIMBroadCastReceiver();
+        IntentFilter filter = new IntentFilter();
+        filter.addAction("com.mediatek.dm.LAWMO_WIPE");
+        filter.addAction("action_pin_dismiss");
+        filter.addAction("action_melock_dismiss");
+        filter.addAction("android.intent.action.ACTION_SHUTDOWN_IPO");
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        mContext.registerReceiver(mSimReceiver, filter);
+
+        mSubReceiver = new SubBroadCastReceiver();
+        IntentFilter subFilter = new IntentFilter();
+        subFilter.addAction(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        mContext.registerReceiver(mSubReceiver, subFilter);
+        /** M: Bug Fix for ALPS02189616 */
+        // register new receiver for RADIO_TECHNOLOGY_CHANGED
+        mRTC = new RadioTechnologyChangedReceiver();
+        IntentFilter rtcFilter = new IntentFilter();
+        // M: PHB Revise
+        rtcFilter.addAction(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
+        mContext.registerReceiver(mRTC, rtcFilter);
+
+        // ALPS01099419, mAdnCache is needed before onUpdateIccAvailability.
+        if (DBG) log("SIMRecords updateIccRecords");
+        if (mPhone.getIccPhoneBookInterfaceManager() != null) {
+            mPhone.getIccPhoneBookInterfaceManager().updateIccRecords(this);
+        }
+
+        //ALPS00566446: Check if phb is ready or not, if phb was already ready,
+        //we won't wait for phb ready.
+        if (isPhbReady()) {
+            if (DBG) log("Phonebook is ready.");
+            mPhbReady = true;
+            broadcastPhbStateChangedIntent(mPhbReady);
+        }
+        try {
+            mTelephonyExt = MPlugin.createInstance(ITelephonyExt.class.getName(), mContext);
+        } catch (Exception e) {
+            loge("Fail to create plug-in");
+            e.printStackTrace();
+        }
+        // MTK-END
+
+        if (DBG) log("SIMRecords X ctor this=" + this);
+
+        IntentFilter intentfilter = new IntentFilter();
+        intentfilter.addAction(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
+        c.registerReceiver(mReceiver, intentfilter);
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
+                sendMessage(obtainMessage(EVENT_CARRIER_CONFIG_CHANGED));
+            }
+        }
+    };
+
+    @Override
+    public void dispose() {
+        if (DBG) log("Disposing SIMRecords this=" + this);
+        //Unregister for all events
+        // MTK-START
+        //3g dongle
+        isDispose = true;
+        // MTK-END
+        mCi.unregisterForIccRefresh(this);
+        mCi.unSetOnSmsOnSim(this);
+        // MTK-START
+
+        mCi.unregisterForCallForwardingInfo(this);
+        mCi.unregisterForPhbReady(this);
+        mCi.unregisterForRadioStateChanged(this);
+        mCi.unregisterForEfCspPlmnModeBitChanged(this);
+        mCi.unregisterForMelockChanged(this);
+        // MTK-END
+        mParentApp.unregisterForReady(this);
+        mParentApp.unregisterForLocked(this);
+        // MTK-START
+        mContext.unregisterReceiver(mSimReceiver);
+        mContext.unregisterReceiver(mSubReceiver);
+        mContext.unregisterReceiver(mReceiver);
+        // M: PHB Revise
+        mContext.unregisterReceiver(mRTC);
+        mPhbWaitSub = false;
+        // MTK-END
+        resetRecords();
+        // MTK-START
+        mAdnCache.reset();
+        setPhbReady(false);
+        mIccId = null;
+        mImsi = null;
+        // MTK-END
+
+        // MTK-START
+        log("dispose(), clean CFU icon");
+        mCallForwardingStatus = CALL_FORWARDING_STATUS_DISABLED;
+        mPhone.clearCallForwardingIndicatorFromSharedPref();
+        mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
+        // MTK-END
+        super.dispose();
+    }
+
+    @Override
+    protected void finalize() {
+        if(DBG) log("finalized");
+    }
+
+    protected void resetRecords() {
+        mImsi = null;
+        mMsisdn = null;
+        mVoiceMailNum = null;
+        mMncLength = UNINITIALIZED;
+        log("setting0 mMncLength" + mMncLength);
+        mIccId = null;
+        mFullIccId = null;
+        // -1 means no EF_SPN found; treat accordingly.
+        mSpnDisplayCondition = -1;
+        mEfMWIS = null;
+        mEfCPHS_MWI = null;
+        mSpdiNetworks = null;
+        mPnnHomeName = null;
+        mGid1 = null;
+        mGid2 = null;
+
+        mAdnCache.reset();
+
+        log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
+        log("update icc_operator_numeric=" + null);
+        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), "");
+        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), "");
+        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), "");
+        // MTK-START
+        setSystemProperty(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, null);
+        // MTK-END
+
+        // recordsRequested is set to false indicating that the SIM
+        // read requests made so far are not valid. This is set to
+        // true only when fresh set of read requests are made.
+        mRecordsRequested = false;
+    }
+
+
+    //***** Public Methods
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String getIMSI() {
+        return mImsi;
+    }
+
+    @Override
+    public String getMsisdnNumber() {
+        return mMsisdn;
+    }
+
+    @Override
+    public String getGid1() {
+        return mGid1;
+    }
+
+    @Override
+    public String getGid2() {
+        return mGid2;
+    }
+
+    @Override
+    public UsimServiceTable getUsimServiceTable() {
+        return mUsimServiceTable;
+    }
+
+    private int getExtFromEf(int ef) {
+        int ext;
+        switch (ef) {
+            case EF_MSISDN:
+                /* For USIM apps use EXT5. (TS 31.102 Section 4.2.37) */
+                if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                    ext = EF_EXT5;
+                } else {
+                    ext = EF_EXT1;
+                }
+                break;
+            default:
+                ext = EF_EXT1;
+        }
+        return ext;
+    }
+
+    /**
+     * Set subscriber number to SIM record
+     *
+     * The subscriber number is stored in EF_MSISDN (TS 51.011)
+     *
+     * When the operation is complete, onComplete will be sent to its handler
+     *
+     * @param alphaTag alpha-tagging of the dailing nubmer (up to 10 characters)
+     * @param number dailing nubmer (up to 20 digits)
+     *        if the number starts with '+', then set to international TOA
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    @Override
+    public void setMsisdnNumber(String alphaTag, String number,
+            Message onComplete) {
+
+        // If the SIM card is locked by PIN, we will set EF_MSISDN fail.
+        // In that case, msisdn and msisdnTag should not be update.
+        mNewMsisdn = number;
+        mNewMsisdnTag = alphaTag;
+
+        if(DBG) log("Set MSISDN: " + mNewMsisdnTag + " " + /*mNewMsisdn*/
+                Rlog.pii(LOG_TAG, mNewMsisdn));
+
+        AdnRecord adn = new AdnRecord(mNewMsisdnTag, mNewMsisdn);
+
+        new AdnRecordLoader(mFh).updateEF(adn, EF_MSISDN, getExtFromEf(EF_MSISDN), 1, null,
+                obtainMessage(EVENT_SET_MSISDN_DONE, onComplete));
+    }
+
+    @Override
+    public String getMsisdnAlphaTag() {
+        return mMsisdnTag;
+    }
+
+    @Override
+    public String getVoiceMailNumber() {
+        // MTK-START
+        log("getVoiceMailNumber " + mVoiceMailNum);
+        // MTK-END
+        return mVoiceMailNum;
+    }
+
+    /**
+     * Set voice mail number to SIM record
+     *
+     * The voice mail number can be stored either in EF_MBDN (TS 51.011) or
+     * EF_MAILBOX_CPHS (CPHS 4.2)
+     *
+     * If EF_MBDN is available, store the voice mail number to EF_MBDN
+     *
+     * If EF_MAILBOX_CPHS is enabled, store the voice mail number to EF_CHPS
+     *
+     * So the voice mail number will be stored in both EFs if both are available
+     *
+     * Return error only if both EF_MBDN and EF_MAILBOX_CPHS fail.
+     *
+     * When the operation is complete, onComplete will be sent to its handler
+     *
+     * @param alphaTag alpha-tagging of the dailing nubmer (upto 10 characters)
+     * @param voiceNumber dailing nubmer (upto 20 digits)
+     *        if the number is start with '+', then set to international TOA
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    @Override
+    public void setVoiceMailNumber(String alphaTag, String voiceNumber,
+            Message onComplete) {
+        // MTK-START
+        log("setVoiceMailNumber, mIsVoiceMailFixed " + mIsVoiceMailFixed +
+            ", mMailboxIndex " + mMailboxIndex + ", mMailboxIndex " + mMailboxIndex);
+        // MTK-END
+        if (mIsVoiceMailFixed) {
+            AsyncResult.forMessage((onComplete)).exception =
+                    new IccVmFixedException("Voicemail number is fixed by operator");
+            onComplete.sendToTarget();
+            return;
+        }
+
+        mNewVoiceMailNum = voiceNumber;
+        mNewVoiceMailTag = alphaTag;
+
+        AdnRecord adn = new AdnRecord(mNewVoiceMailTag, mNewVoiceMailNum);
+
+        if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
+
+            new AdnRecordLoader(mFh).updateEF(adn, EF_MBDN, EF_EXT6,
+                    mMailboxIndex, null,
+                    obtainMessage(EVENT_SET_MBDN_DONE, onComplete));
+
+        } else if (isCphsMailboxEnabled()) {
+            // MTK-START
+            log("setVoiceMailNumber,load EF_MAILBOX_CPHS");
+            // MTK-END
+            new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS,
+                    EF_EXT1, 1, null,
+                    obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onComplete));
+
+        } else {
+            // MTK-START
+            log("setVoiceMailNumber,Update SIM voice mailbox error");
+            // MTK-END
+            AsyncResult.forMessage((onComplete)).exception =
+                    new IccVmNotSupportedException("Update SIM voice mailbox error");
+            onComplete.sendToTarget();
+        }
+    }
+
+    @Override
+    public String getVoiceMailAlphaTag()
+    {
+        return mVoiceMailTag;
+    }
+
+    /**
+     * Sets the SIM voice message waiting indicator records
+     * @param line GSM Subscriber Profile Number, one-based. Only '1' is supported
+     * @param countWaiting The number of messages waiting, if known. Use
+     *                     -1 to indicate that an unknown number of
+     *                      messages are waiting
+     */
+    @Override
+    public void
+    setVoiceMessageWaiting(int line, int countWaiting) {
+        if (line != 1) {
+            // only profile 1 is supported
+            return;
+        }
+
+        try {
+            if (mEfMWIS != null) {
+                // TS 51.011 10.3.45
+
+                // lsb of byte 0 is 'voicemail' status
+                mEfMWIS[0] = (byte)((mEfMWIS[0] & 0xfe)
+                                    | (countWaiting == 0 ? 0 : 1));
+
+                // byte 1 is the number of voice messages waiting
+                if (countWaiting < 0) {
+                    // The spec does not define what this should be
+                    // if we don't know the count
+                    mEfMWIS[1] = 0;
+                } else {
+                    mEfMWIS[1] = (byte) countWaiting;
+                }
+
+                mFh.updateEFLinearFixed(
+                    EF_MWIS, 1, mEfMWIS, null,
+                    obtainMessage (EVENT_UPDATE_DONE, EF_MWIS, 0));
+            }
+
+            // MTK-START
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                log("[setVoiceMessageWaiting] It is USIM card, skip write CPHS file");
+            } else {
+            // MTK-END
+                if (mEfCPHS_MWI != null) {
+                        // Refer CPHS4_2.WW6 B4.2.3
+                    mEfCPHS_MWI[0] = (byte)((mEfCPHS_MWI[0] & 0xf0)
+                                | (countWaiting == 0 ? 0x5 : 0xa));
+                    mFh.updateEFTransparent(
+                        EF_VOICE_MAIL_INDICATOR_CPHS, mEfCPHS_MWI,
+                        obtainMessage (EVENT_UPDATE_DONE, EF_VOICE_MAIL_INDICATOR_CPHS));
+            // MTK-START
+                }
+            // MTK-END
+            }
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            logw("Error saving voice mail state to SIM. Probably malformed SIM record", ex);
+        }
+    }
+
+    // MTK-START
+    /* Provide a API to GsmCdmaPhone to check EfCfis. However, we don't use AOSP method to
+     * distinguish EF_CFIS. Because MD does't check the MSP, we need to align MD's way.
+     */
+    public boolean checkEfCfis() {
+        boolean isValid = (mEfCfis != null) && (mEfCfis.length == 16);
+        log("mEfCfis is null? = " + (mEfCfis == null));
+        return isValid;
+    }
+    // MTK-END
+
+    // Validate data is !null and the MSP (Multiple Subscriber Profile)
+    // byte is between 1 and 4. See ETSI TS 131 102 v11.3.0 section 4.2.64.
+    private boolean validEfCfis(byte[] data) {
+        return ((data != null) && (data[0] >= 1) && (data[0] <= 4));
+    }
+
+    public int getVoiceMessageCount() {
+        boolean voiceMailWaiting = false;
+        int countVoiceMessages = 0;
+        if (mEfMWIS != null) {
+            // Use this data if the EF[MWIS] exists and
+            // has been loaded
+            // Refer TS 51.011 Section 10.3.45 for the content description
+            voiceMailWaiting = ((mEfMWIS[0] & 0x01) != 0);
+            countVoiceMessages = mEfMWIS[1] & 0xff;
+
+            if (voiceMailWaiting && countVoiceMessages == 0) {
+                // Unknown count = -1
+                countVoiceMessages = -1;
+            }
+            if(DBG) log(" VoiceMessageCount from SIM MWIS = " + countVoiceMessages);
+        } else if (mEfCPHS_MWI != null) {
+            // use voice mail count from CPHS
+            int indicator = (int) (mEfCPHS_MWI[0] & 0xf);
+
+            // Refer CPHS4_2.WW6 B4.2.3
+            if (indicator == 0xA) {
+                // Unknown count = -1
+                countVoiceMessages = -1;
+            } else if (indicator == 0x5) {
+                countVoiceMessages = 0;
+            }
+            if(DBG) log(" VoiceMessageCount from SIM CPHS = " + countVoiceMessages);
+        }
+        return countVoiceMessages;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getVoiceCallForwardingFlag() {
+        return mCallForwardingStatus;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
+        Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag: " + enable);
+
+        if (line != 1) return; // only line 1 is supported
+
+        mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED :
+                CALL_FORWARDING_STATUS_DISABLED;
+
+        Rlog.d(LOG_TAG, " mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
+        mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
+
+        try {
+            // if (validEfCfis(mEfCfis)) {
+            // MTK-START
+            if (checkEfCfis()) {
+            // MTK-END
+                // lsb is of byte f1 is voice status
+                if (enable) {
+                    mEfCfis[1] |= 1;
+                } else {
+                    mEfCfis[1] &= 0xfe;
+                }
+
+                log("setVoiceCallForwardingFlag: enable=" + enable
+                        + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
+
+                // Update dialNumber if not empty and CFU is enabled.
+                // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
+                if (enable && !TextUtils.isEmpty(dialNumber)) {
+                    logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
+
+                    // MTK-START
+                    // Fix ALPS03414399
+                    // If the dial number contains prefix like "tel:", "sip:" or "sips:",
+                    // it have to be truncated before passed to numberToCalledPartyBCD().
+                    String tmpDialNumber = convertNumberIfContainsPrefix(dialNumber);
+                    byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(tmpDialNumber);
+                    // MTK-END
+
+                    System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
+
+                    mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
+                    mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
+                    mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
+                }
+
+                // MTK-START
+                if (mFh != null) {
+                    mFh.updateEFLinearFixed(
+                            EF_CFIS, 1, mEfCfis, null,
+                            obtainMessage (EVENT_UPDATE_DONE, EF_CFIS));
+                } else {
+                    log("setVoiceCallForwardingFlag: mFh is null, skip update EF_CFIS");
+                }
+                // MTK-END
+            } else {
+                log("setVoiceCallForwardingFlag: ignoring enable=" + enable
+                        + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
+            }
+
+            if (mEfCff != null) {
+                if (enable) {
+                    mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET)
+                            | CFF_UNCONDITIONAL_ACTIVE);
+                } else {
+                    mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET)
+                            | CFF_UNCONDITIONAL_DEACTIVE);
+                }
+
+                // MTK-START
+                if (mFh != null) {
+                    mFh.updateEFTransparent(
+                            EF_CFF_CPHS, mEfCff,
+                            obtainMessage (EVENT_UPDATE_DONE, EF_CFF_CPHS));
+                } else {
+                    log("setVoiceCallForwardingFlag: mFh is null, skip update EF_CFF_CPHS");
+                }
+                // MTK-END
+            }
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            logw("Error saving call forwarding flag to SIM. "
+                            + "Probably malformed SIM record", ex);
+
+        }
+    }
+
+    /**
+     * Called by STK Service when REFRESH is received.
+     * @param fileChanged indicates whether any files changed
+     * @param fileList if non-null, a list of EF files that changed
+     */
+    @Override
+    public void onRefresh(boolean fileChanged, int[] fileList) {
+        if (fileChanged) {
+            // A future optimization would be to inspect fileList and
+            // only reload those files that we care about.  For now,
+            // just re-fetch all SIM records that we cache.
+            fetchSimRecords();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String getOperatorNumeric() {
+        if (mImsi == null) {
+            // MTK-START
+            if (getRecordsLoaded()) {
+                log("getOperatorNumeric: IMSI == null when record loaded.");
+            }
+            // MTK-END
+            //log("getOperatorNumeric: IMSI == null");
+            return null;
+        }
+        if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
+            log("getSIMOperatorNumeric: bad mncLength");
+            return null;
+        }
+
+        // Length = length of MCC + length of MNC
+        // length of mcc = 3 (TS 23.003 Section 2.2)
+        return mImsi.substring(0, 3 + mMncLength);
+    }
+
+    // MTK-START
+    @Override
+    public String getSIMCPHSOns() {
+        if (cphsOnsl != null) {
+            return cphsOnsl;
+        } else {
+            return cphsOnss;
+        }
+    }
+    // MTK-END
+
+    // ***** Overridden from Handler
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        AdnRecord adn;
+
+        byte data[];
+
+        boolean isRecordLoadResponse = false;
+
+        if (mDestroyed.get()) {
+            loge("Received message " + msg + "[" + msg.what + "] " +
+                    " while being destroyed. Ignoring.");
+            return;
+        }
+
+        try { switch (msg.what) {
+            case EVENT_APP_READY:
+                onReady();
+                // MTK-START
+                fetchEccList();
+                // MTK-END
+                break;
+
+            case EVENT_APP_LOCKED:
+                onLocked();
+                // MTK-START
+                fetchEccList();
+                // MTK-END
+                break;
+
+            /* IO events */
+            case EVENT_GET_IMSI_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Exception querying IMSI, Exception:" + ar.exception);
+                    break;
+                }
+
+                mImsi = (String) ar.result;
+
+                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
+                // than 15 (and usually 15).
+                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
+                    loge("invalid IMSI " + mImsi);
+                    mImsi = null;
+                }
+
+                log("IMSI: mMncLength=" + mMncLength);
+                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
+
+                // MTK-START
+                //if (((mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                if (((mMncLength == UNINITIALIZED) ||
+                        (mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                // MTK-END
+                        ((mImsi != null) && (mImsi.length() >= 6))) {
+                    String mccmncCode = mImsi.substring(0, 6);
+                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                        if (mccmnc.equals(mccmncCode)) {
+                            mMncLength = 3;
+                            log("IMSI: setting1 mMncLength=" + mMncLength);
+                            break;
+                        }
+                    }
+                }
+
+                // MTK-START
+                //if (mMncLength == UNKNOWN) {
+                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                // MTK-END
+                    // the SIM has told us all it knows, but it didn't know the mnc length.
+                    // guess using the mcc
+                    try {
+                        int mcc = Integer.parseInt(mImsi.substring(0,3));
+                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
+                        log("setting2 mMncLength=" + mMncLength);
+                    } catch (NumberFormatException e) {
+                        mMncLength = UNKNOWN;
+                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
+                    }
+                }
+
+                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
+                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                    // finally have both the imsi and the mncLength and can parse the imsi properly
+                    // MTK-START
+                    //MccTable.updateMccMncConfiguration(mContext,
+                            //mImsi.substring(0, 3 + mMncLength), false);
+                    updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                    // MTK-END
+                }
+                mImsiReadyRegistrants.notifyRegistrants();
+            break;
+
+            case EVENT_GET_MBI_DONE:
+                boolean isValidMbdn;
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[]) ar.result;
+
+                isValidMbdn = false;
+                if (ar.exception == null) {
+                    // Refer TS 51.011 Section 10.3.44 for content details
+                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
+
+                    // Voice mail record number stored first
+                    mMailboxIndex = data[0] & 0xff;
+
+                    // check if dailing numbe id valid
+                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
+                        log("Got valid mailbox number for MBDN");
+                        isValidMbdn = true;
+                        // MTK-START
+                        this.isValidMBI = true; // ALPS00301018
+                        // MTK-END
+                    }
+                }
+
+                // one more record to load
+                mRecordsToLoad += 1;
+
+                if (isValidMbdn) {
+                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
+                    // MTK-START
+                    log("EVENT_GET_MBI_DONE, to load EF_MBDN");
+                    // MTK-END
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6,
+                            mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
+                // MTK-START
+                } else if (isCphsMailboxEnabled()) {
+                // MTK-END
+                    // If this EF not present, try mailbox as in CPHS standard
+                    // CPHS (CPHS4_2.WW6) is a european standard.
+                    // MTK-START
+                    log("EVENT_GET_MBI_DONE, to load EF_MAILBOX_CPHS");
+                    // MTK-END
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS,
+                            EF_EXT1, 1,
+                            obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                // MTK-START
+                } else {
+                    log("EVENT_GET_MBI_DONE, do nothing");
+                    mRecordsToLoad -= 1;
+                // MTK-END
+                }
+
+                break;
+            case EVENT_GET_CPHS_MAILBOX_DONE:
+            case EVENT_GET_MBDN_DONE:
+                //Resetting the voice mail number and voice mail tag to null
+                //as these should be updated from the data read from EF_MBDN.
+                //If they are not reset, incase of invalid data/exception these
+                //variables are retaining their previous values and are
+                //causing invalid voice mailbox info display to user.
+                mVoiceMailNum = null;
+                mVoiceMailTag = null;
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+
+                    loge("Invalid or missing EF"
+                        + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
+
+                    // Bug #645770 fall back to CPHS
+                    // FIXME should use SST to decide
+
+                    if (msg.what == EVENT_GET_MBDN_DONE) {
+                        //load CPHS on fail...
+                        // FIXME right now, only load line1's CPHS voice mail entry
+
+                        mRecordsToLoad += 1;
+                        new AdnRecordLoader(mFh).loadFromEF(
+                                EF_MAILBOX_CPHS, EF_EXT1, 1,
+                                obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                    }
+                    break;
+                }
+
+                adn = (AdnRecord)ar.result;
+
+                log("VM: " + adn +
+                        ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
+
+                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
+                    // Bug #645770 fall back to CPHS
+                    // FIXME should use SST to decide
+                    // FIXME right now, only load line1's CPHS voice mail entry
+                    mRecordsToLoad += 1;
+                    new AdnRecordLoader(mFh).loadFromEF(
+                            EF_MAILBOX_CPHS, EF_EXT1, 1,
+                            obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+
+                    break;
+                }
+
+                mVoiceMailNum = adn.getNumber();
+                mVoiceMailTag = adn.getAlphaTag();
+            break;
+
+            case EVENT_GET_MSISDN_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Invalid or missing EF[MSISDN]");
+                    break;
+                }
+
+                adn = (AdnRecord)ar.result;
+
+                mMsisdn = adn.getNumber();
+                mMsisdnTag = adn.getAlphaTag();
+
+                // MTK-START
+                mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                // MTK-END
+                log("MSISDN: " + /*mMsisdn*/ Rlog.pii(LOG_TAG, mMsisdn));
+            break;
+
+            case EVENT_SET_MSISDN_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception == null) {
+                    mMsisdn = mNewMsisdn;
+                    mMsisdnTag = mNewMsisdnTag;
+                    // MTK-START
+                    mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                    // MTK-END
+                    log("Success to update EF[MSISDN]");
+                }
+
+                if (ar.userObj != null) {
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                            = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_MWIS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if(DBG) log("EF_MWIS : " + IccUtils.bytesToHexString(data));
+
+                if (ar.exception != null) {
+                    if(DBG) loge("EVENT_GET_MWIS_DONE exception = "
+                            + ar.exception);
+                    break;
+                }
+
+                if ((data[0] & 0xff) == 0xff) {
+                    if(DBG) log("SIMRecords: Uninitialized record MWIS");
+                    break;
+                }
+
+                mEfMWIS = data;
+
+                break;
+
+            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if(DBG) log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
+
+                if (ar.exception != null) {
+                    if(DBG) loge("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = "
+                            + ar.exception);
+                    break;
+                }
+
+                mEfCPHS_MWI = data;
+                break;
+
+            case EVENT_GET_ICCID_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mIccId = IccUtils.bcdToString(data, 0, data.length);
+                mFullIccId = IccUtils.bchToString(data, 0, data.length);
+
+                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
+
+            break;
+
+
+            case EVENT_GET_AD_DONE:
+                try {
+                    isRecordLoadResponse = true;
+
+                    ar = (AsyncResult)msg.obj;
+                    data = (byte[])ar.result;
+
+                    if (ar.exception != null) {
+                        break;
+                    }
+
+                    log("EF_AD: " + IccUtils.bytesToHexString(data));
+
+                    if (data.length < 3) {
+                        log("Corrupt AD data on SIM");
+                        break;
+                    }
+
+                    // MTK-START
+                    if ((data[0] & 1) == 1 && (data[2] & 1) == 1) {
+                        //TS31.102: EF_AD. If the bit1 of byte 1 is 1
+                        //,then bit 1 of byte 3 is for ciphering.
+                        log("SIMRecords: Cipher is enable");
+                    }
+                    // MTK-END
+
+                    if (data.length == 3) {
+                        log("MNC length not present in EF_AD");
+                        break;
+                    }
+
+                    mMncLength = data[3] & 0xf;
+                    log("setting4 mMncLength=" + mMncLength);
+
+                    if (mMncLength == 0xf) {
+                        mMncLength = UNKNOWN;
+                        log("setting5 mMncLength=" + mMncLength);
+                    } else if (mMncLength != 2 && mMncLength != 3) {
+                        mMncLength = UNINITIALIZED;
+                        log("setting5 mMncLength=" + mMncLength);
+                    }
+                } finally {
+                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) ||
+                            (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
+                        String mccmncCode = mImsi.substring(0, 6);
+                        log("mccmncCode=" + mccmncCode);
+                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                            if (mccmnc.equals(mccmncCode)) {
+                                mMncLength = 3;
+                                log("setting6 mMncLength=" + mMncLength);
+                                break;
+                            }
+                        }
+                    }
+
+                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                        if (mImsi != null) {
+                            try {
+                                int mcc = Integer.parseInt(mImsi.substring(0,3));
+
+                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
+                                log("setting7 mMncLength=" + mMncLength);
+                            } catch (NumberFormatException e) {
+                                mMncLength = UNKNOWN;
+                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
+                            }
+                        } else {
+                            // Indicate we got this info, but it didn't contain the length.
+                            mMncLength = UNKNOWN;
+                            log("MNC length not present in EF_AD setting9 mMncLength=" + mMncLength);
+                        }
+                    }
+                    if (mImsi != null && mMncLength != UNKNOWN) {
+                        // finally have both imsi and the length of the mnc and can parse
+                        // the imsi properly
+                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                        // MTK-START
+                        //MccTable.updateMccMncConfiguration(mContext,
+                                //mImsi.substring(0, 3 + mMncLength), false);
+                        updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                        // MTK-END
+                    }
+                }
+            break;
+
+            case EVENT_GET_SPN_DONE:
+                // MTK-START
+                if (DBG) log("EF_SPN loaded and try to extract: ");
+                // MTK-END
+                isRecordLoadResponse = true;
+                ar = (AsyncResult) msg.obj;
+                // MTK-START
+                //getSpnFsm(false, ar);
+                if (ar != null && ar.exception == null) {
+                    if (DBG) log("getSpnFsm, Got data from EF_SPN");
+                    data = (byte[]) ar.result;
+                    mSpnDisplayCondition = 0xff & data[0];
+
+                    // [ALPS00121176], 255 means invalid SPN file
+                    if (mSpnDisplayCondition == 255) {
+                        mSpnDisplayCondition = -1;
+                    }
+
+                    setServiceProviderName(
+                            IccUtils.adnStringFieldToString(data, 1, data.length - 1));
+                    mSpNameInEfSpn = getServiceProviderName(); // MVNO-API
+                    if (mSpNameInEfSpn != null && mSpNameInEfSpn.equals("")) {
+                        if (DBG) log("set spNameInEfSpn to null because parsing result is empty");
+                        mSpNameInEfSpn = null;
+                    }
+
+                    if (DBG) log("Load EF_SPN: " + getServiceProviderName()
+                            + " spnDisplayCondition: " + mSpnDisplayCondition);
+                    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(),
+                            getServiceProviderName());
+                } else {
+                    if (DBG) loge(": read spn fail!");
+                    // See TS 51.011 10.3.11.  Basically, default to
+                    // show PLMN always, and SPN also if roaming.
+                    mSpnDisplayCondition = -1;
+                }
+                // MTK-END
+            break;
+
+            case EVENT_GET_CFF_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    mEfCff = null;
+                } else {
+                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
+                    mEfCff = data;
+                }
+
+                break;
+
+            case EVENT_GET_SPDI_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                parseEfSpdi(data);
+            break;
+
+            case EVENT_UPDATE_DONE:
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception != null) {
+                    logw("update failed. ", ar.exception);
+                }
+            break;
+
+            case EVENT_GET_PNN_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                // MTK-START
+                //data = (byte[])ar.result;
+                // MTK-END
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                // MTK-START
+                parseEFpnn((ArrayList) ar.result);
+               /*
+                SimTlv tlv = new SimTlv(data, 0, data.length);
+
+                for ( ; tlv.isValidObject() ; tlv.nextObject()) {
+                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
+                        mPnnHomeName
+                            = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                        break;
+                    }
+                }
+                */
+                // MTK-END
+            break;
+
+            case EVENT_GET_ALL_SMS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception != null)
+                    break;
+
+                handleSmses((ArrayList<byte []>) ar.result);
+                break;
+
+            case EVENT_MARK_SMS_READ_DONE:
+                Rlog.i("ENF", "marked read: sms " + msg.arg1);
+                break;
+
+
+            case EVENT_SMS_ON_SIM:
+                isRecordLoadResponse = false;
+
+                ar = (AsyncResult)msg.obj;
+
+                int[] index = (int[])ar.result;
+
+                if (ar.exception != null || index.length != 1) {
+                    loge("Error on SMS_ON_SIM with exp "
+                            + ar.exception + " length " + index.length);
+                } else {
+                    log("READ EF_SMS RECORD index=" + index[0]);
+                    mFh.loadEFLinearFixed(EF_SMS,index[0],
+                            obtainMessage(EVENT_GET_SMS_DONE));
+                }
+                break;
+
+            case EVENT_GET_SMS_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    handleSms((byte[])ar.result);
+                } else {
+                    loge("Error on GET_SMS with exp " + ar.exception);
+                }
+                break;
+            case EVENT_GET_SST_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mUsimServiceTable = new UsimServiceTable(data);
+                if (DBG) log("SST: " + mUsimServiceTable);
+                // MTK-START
+                mEfSST = data;
+
+                if ((mParentApp != null) &&
+                        (mParentApp.getState() == AppState.APPSTATE_READY)) {
+                    mParentApp.queryFdn();
+                }
+
+                fetchMbiRecords();
+                fetchMwisRecords();
+                fetchPnn();
+                fetchSpn();
+                fetchSmsp();
+                fetchGbaRecords();
+                // MTK-END
+                break;
+
+            case EVENT_GET_INFO_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mCphsInfo = (byte[])ar.result;
+
+                if (DBG) log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
+                // MTK-START
+                // ALPS00301018
+                if (this.isValidMBI == false && isCphsMailboxEnabled()) {
+                    mRecordsToLoad += 1;
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS,
+                                EF_EXT1, 1,
+                                obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                }
+                // MTK-END
+            break;
+
+            case EVENT_SET_MBDN_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+
+                if (DBG) log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
+                if (ar.exception == null) {
+                    mVoiceMailNum = mNewVoiceMailNum;
+                    mVoiceMailTag = mNewVoiceMailTag;
+                }
+
+                if (isCphsMailboxEnabled()) {
+                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
+                    Message onCphsCompleted = (Message) ar.userObj;
+
+                    /* write to cphs mailbox whenever it is available but
+                    * we only need notify caller once if both updating are
+                    * successful.
+                    *
+                    * so if set_mbdn successful, notify caller here and set
+                    * onCphsCompleted to null
+                    */
+                    if (ar.exception == null && ar.userObj != null) {
+                        AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = null;
+                        ((Message) ar.userObj).sendToTarget();
+
+                        if (DBG) log("Callback with MBDN successful.");
+
+                        onCphsCompleted = null;
+                    }
+
+                    new AdnRecordLoader(mFh).
+                            updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null,
+                            obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE,
+                                    onCphsCompleted));
+                } else {
+                    if (ar.userObj != null) {
+                        Resources resource = Resources.getSystem();
+                        if (ar.exception != null && resource.getBoolean(com.android.internal.
+                                    R.bool.editable_voicemailnumber)) {
+                            // GsmCdmaPhone will store vm number on device
+                            // when IccVmNotSupportedException occurred
+                            AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = new IccVmNotSupportedException(
+                                        "Update SIM voice mailbox error");
+                        } else {
+                            AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = ar.exception;
+                        }
+                        ((Message) ar.userObj).sendToTarget();
+                    }
+                }
+                break;
+            case EVENT_SET_CPHS_MAILBOX_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if(ar.exception == null) {
+                    mVoiceMailNum = mNewVoiceMailNum;
+                    mVoiceMailTag = mNewVoiceMailTag;
+                } else {
+                    if (DBG) loge("Set CPHS MailBox with exception: "
+                            + ar.exception);
+                }
+                if (ar.userObj != null) {
+                    if (DBG) log("Callback with CPHS MB successful.");
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                            = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                }
+                break;
+            case EVENT_SIM_REFRESH:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if (DBG) log("Sim REFRESH with exception: " + ar.exception);
+                if (ar.exception == null) {
+                    handleSimRefresh((IccRefreshResponse)ar.result);
+                }
+                break;
+            case EVENT_GET_CFIS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    mEfCfis = null;
+                } else {
+                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
+                    mEfCfis = data;
+                }
+
+                break;
+
+            // MTK-START
+            case EVENT_GET_SIM_ECC_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_SIM_ECC_DONE)");
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    if (DBG) loge("Get SIM ecc with exception: " + ar.exception);
+                    break;
+                }
+
+                mEfEcc = "";
+
+                data = (byte[]) ar.result;
+                for (int i = 0 ; i + 2 < data.length ; i += 3) {
+                    String eccNum;
+                    eccNum = IccUtils.bcdToString(data, i, 3);
+                    if (eccNum != null && !eccNum.equals("") && !mEfEcc.equals("")) {
+                        mEfEcc = mEfEcc + ";";
+                    }
+                    // Add service category
+                    mEfEcc += eccNum + ",0" ;
+                }
+                mEfEcc += ";112,0;911,0";
+
+                if (DBG) log("SIM mEfEcc is " + mEfEcc);
+                SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], mEfEcc);
+            break;
+
+            case EVENT_GET_USIM_ECC_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_USIM_ECC_DONE)");
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    if (DBG) loge("Get USIM ecc with exception: " + ar.exception);
+                    break;
+                }
+
+                ArrayList eccRecords = (ArrayList) ar.result;
+                int count = eccRecords.size();
+
+                mEfEcc = "";
+
+                for (int i = 0; i < count; i++) {
+                    data = (byte[]) eccRecords.get(i);
+                    if (DBG) {
+                        log("USIM EF_ECC record " + i + ": "+ IccUtils.bytesToHexString(data));
+                    }
+                    String eccNum;
+                    eccNum = IccUtils.bcdToString(data, 0, 3);
+                    if (eccNum != null && !eccNum.equals("")) {
+                        if (!mEfEcc.equals("")) {
+                            mEfEcc = mEfEcc + ";";
+                        }
+                        mEfEcc = mEfEcc + eccNum ;
+
+                        //Add service category
+                        int category = (data[data.length - 1] & 0x000000FF);
+                        mEfEcc += "," + String.valueOf(category);
+                    }
+                }
+                mEfEcc += ";112,0;911,0";
+
+                if (DBG) log("USIM mEfEcc is " + mEfEcc);
+                SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], mEfEcc);
+            break;
+
+            case EVENT_GET_CSP_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Exception in fetching EF_CSP data " + ar.exception);
+                    break;
+                }
+
+                data = (byte[])ar.result;
+
+                log("EF_CSP: " + IccUtils.bytesToHexString(data));
+                handleEfCspData(data);
+                break;
+
+            case EVENT_GET_GID1_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data =(byte[])ar.result;
+
+                if (ar.exception != null) {
+                    loge("Exception in get GID1 " + ar.exception);
+                    mGid1 = null;
+                    break;
+                }
+                mGid1 = IccUtils.bytesToHexString(data);
+                log("GID1: " + mGid1);
+
+                break;
+
+            case EVENT_GET_GID2_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data =(byte[])ar.result;
+
+                if (ar.exception != null) {
+                    loge("Exception in get GID2 " + ar.exception);
+                    mGid2 = null;
+                    break;
+                }
+                mGid2 = IccUtils.bytesToHexString(data);
+                log("GID2: " + mGid2);
+
+                break;
+
+            case EVENT_CARRIER_CONFIG_CHANGED:
+                handleCarrierNameOverride();
+                break;
+
+            // MTK-START
+            case EVENT_GET_ALL_OPL_DONE:
+                isRecordLoadResponse = false;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    break;
+                }
+                parseEFopl((ArrayList) ar.result);
+
+                mRecordsEventsRegistrants.notifyResult(EVENT_OPL);
+                break;
+
+            case EVENT_GET_CPHSONS_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_CPHSONS_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    cphsOnsl = IccUtils.adnStringFieldToString(
+                            data, 0, data.length);
+                    if (DBG) log("Load EF_SPN_CPHS: " + cphsOnsl);
+                }
+                break;
+
+            case EVENT_GET_SHORT_CPHSONS_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_SHORT_CPHSONS_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    cphsOnss = IccUtils.adnStringFieldToString(
+                            data, 0, data.length);
+
+                    if (DBG) log("Load EF_SPN_SHORT_CPHS: " + cphsOnss);
+                }
+                break;
+            case EVENT_MELOCK_CHANGED:
+                if (DBG) log("handleMessage (EVENT_MELOCK_CHANGED)");
+                ar = (AsyncResult) msg.obj;
+
+                if (ar != null && ar.exception == null && ar.result != null) {
+                    int[] simMelockEvent = (int []) ar.result;
+
+                    if (DBG) log("sim melock event = " + simMelockEvent[0]);
+
+                    RebootClickListener listener = new RebootClickListener();
+
+                    if (simMelockEvent[0] == 0) {
+                        AlertDialog alertDialog = new AlertDialog.Builder(mContext)
+                            .setTitle("Unlock Phone")
+                            .setMessage(
+                                "Please restart the phone now since unlock setting has changed.")
+                            .setPositiveButton("OK", listener)
+                            .create();
+
+                        alertDialog.setCancelable(false);
+                        alertDialog.setCanceledOnTouchOutside(false);
+
+                        alertDialog.getWindow().setType(
+                                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+                        alertDialog.show();
+                    }
+                }
+                break;
+
+            case EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED:
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null)  {
+                    processEfCspPlmnModeBitUrc(((int[]) ar.result)[0]);
+                }
+                break;
+
+            // ALPS00302702 RAT balancing
+            case EVENT_GET_RAT_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_RAT_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                mEfRatLoaded = true;
+                if (ar != null && ar.exception == null) {
+                    mEfRat = ((byte[]) ar.result);
+                    log("load EF_RAT complete: " + mEfRat[0]);
+                    boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+                } else {
+                    log("load EF_RAT fail");
+                    mEfRat = null;
+                    if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                        boradcastEfRatContentNotify(EF_RAT_NOT_EXIST_IN_USIM);
+                    } else {
+                        boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+                    }
+                }
+                break;
+
+            /*
+              Detail description:
+              This feature provides a interface to get menu title string from EF_SUME
+            */
+            case EVENT_QUERY_MENU_TITLE_DONE:
+                log("[sume receive response message");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    if (data != null && data.length >= 2) {
+                        int tag = data[0] & 0xff;
+                        int len = data[1] & 0xff;
+                        log("[sume tag = " + tag + ", len = " + len);
+                        mMenuTitleFromEf = IccUtils.adnStringFieldToString(data, 2, len);
+                        log("[sume menu title is " + mMenuTitleFromEf);
+                    }
+                } else {
+                    if (ar.exception != null) {
+                        loge("[sume exception in AsyncResult: " +
+                                ar.exception.getClass().getName());
+                    } else {
+                        log("[sume null AsyncResult");
+                    }
+                    mMenuTitleFromEf = null;
+                }
+
+                break;
+            case EVENT_RADIO_AVAILABLE:
+                // TODO: Wait for isSetLanguageBySIM ready
+                if (mTelephonyExt.isSetLanguageBySIM()) {
+                    fetchLanguageIndicator();
+                }
+                mMsisdn = "";
+                //setNumberToSimInfo();
+                mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                break;
+            case EVENT_GET_LI_DONE:
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception == null) {
+                   log("EF_LI: " +
+                   IccUtils.bytesToHexString(data));
+                   mEfLi = data;
+                }
+                onLanguageFileLoaded();
+                break;
+            case EVENT_GET_ELP_DONE:
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception == null) {
+                    log("EF_ELP: " +
+                       IccUtils.bytesToHexString(data));
+                    mEfELP = data;
+                }
+                onLanguageFileLoaded();
+                break;
+
+            case EVENT_GET_PSISMSC_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                log("EF_PSISMSC: " + IccUtils.bytesToHexString(data));
+
+                if (data != null) {
+                    mEfPsismsc = data;
+                }
+                break;
+
+            case EVENT_GET_SMSP_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                log("EF_SMSP: " + IccUtils.bytesToHexString(data));
+
+                if (data != null) {
+                    mEfSmsp = data;
+                }
+                break;
+
+            case EVENT_GET_GBABP_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                   data = ((byte[]) ar.result);
+                   mGbabp = IccUtils.bytesToHexString(data);
+
+                   if (DBG) log("EF_GBABP=" + mGbabp);
+                } else {
+                    loge("Error on GET_GBABP with exp " + ar.exception);
+                }
+                break;
+
+            case EVENT_GET_GBANL_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                    mEfGbanlList = ((ArrayList<byte[]>) ar.result);
+                    if (DBG) log("GET_GBANL record count: " + mEfGbanlList.size());
+                } else {
+                    loge("Error on GET_GBANL with exp " + ar.exception);
+                }
+                break;
+            // MTK-START
+            case EVENT_CFU_IND:
+                ar = (AsyncResult) msg.obj;
+                /* Line1 is enabled or disabled while reveiving this EVENT */
+                if (ar != null && ar.exception == null && ar.result != null) {
+                   int[] cfuResult = (int[]) ar.result;
+                   log("handle EVENT_CFU_IND, setVoiceCallForwardingFlag:" + cfuResult[0]);
+                   mPhone.setVoiceCallForwardingFlag(1, (cfuResult[0] == 1), null);
+                }
+                break;
+            // MTK-END
+            case EVENT_IMSI_REFRESH_QUERY:
+                log("handleMessage (EVENT_IMSI_REFRESH_QUERY) mImsi= " + mImsi);
+                mCi.getIMSIForApp(mParentApp.getAid(),
+                    obtainMessage(EVENT_IMSI_REFRESH_QUERY_DONE));
+                break;
+            case EVENT_IMSI_REFRESH_QUERY_DONE:
+                log("handleMessage (EVENT_IMSI_REFRESH_QUERY_DONE)");
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    loge("Exception querying IMSI, Exception:" + ar.exception);
+                    break;
+                }
+
+                mImsi = (String) ar.result;
+                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
+                // than 15 (and usually 15).
+                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
+                    loge("invalid IMSI " + mImsi);
+                    mImsi = null;
+                }
+                log("IMSI: mMncLength=" + mMncLength);
+                log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxx");
+
+                if (((mMncLength == UNINITIALIZED) ||
+                        (mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                        ((mImsi != null) && (mImsi.length() >= 6))) {
+                    String mccmncRefresh = mImsi.substring(0, 6);
+                    for (String mccmncR: MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                        if (mccmncR.equals(mccmncRefresh)) {
+                            mMncLength = 3;
+                            log("IMSI: setting1 mMncLength=" + mMncLength);
+                            break;
+                        }
+                    }
+                }
+                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                    // the SIM has told us all it knows, but it didn't know the mnc length.
+                    // guess using the mcc
+                    try {
+                        int mccR = Integer.parseInt(mImsi.substring(0, 3));
+                        mMncLength = MccTable.smallestDigitsMccForMnc(mccR);
+                        log("setting2 mMncLength=" + mMncLength);
+                    } catch (NumberFormatException e) {
+                        mMncLength = UNKNOWN;
+                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
+                    }
+                }
+
+                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
+                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                    // finally have both the imsi and the mncLength and can parse the imsi properly
+                    //MccTable.updateMccMncConfiguration(mContext,
+                            //mImsi.substring(0, 3 + mMncLength), false);
+                    updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                }
+                if (!mImsi.equals(mSimImsi)) {
+                    mSimImsi = mImsi;
+                    mImsiReadyRegistrants.notifyRegistrants();
+                    log("SimRecords: mImsiReadyRegistrants.notifyRegistrants");
+                }
+
+                if (mRecordsToLoad == 0 && mRecordsRequested == true) {
+                    onAllRecordsLoaded();
+                }
+                break;
+            // MTK-START
+            /** M: Bug Fix for ALPS02189616 */
+            // handle new event
+            case EVENT_DELAYED_SEND_PHB_CHANGE:
+                mPhbReady = isPhbReady();
+                log("[EVENT_DELAYED_SEND_PHB_CHANGE] isReady : " + mPhbReady);
+                broadcastPhbStateChangedIntent(mPhbReady);
+                break;
+            // MTK-END
+
+            default:
+                super.handleMessage(msg);   // IccRecords handles generic record load responses
+
+        }}catch (RuntimeException exc) {
+            // I don't want these exceptions to be fatal
+            logw("Exception parsing SIM record", exc);
+        } finally {
+            // Count up record load responses even if they are fails
+            if (isRecordLoadResponse) {
+                onRecordLoaded();
+            }
+        }
+    }
+
+    private class EfPlLoaded implements IccRecordLoaded {
+        public String getEfName() {
+            return "EF_PL";
+        }
+
+        public void onRecordLoaded(AsyncResult ar) {
+            mEfPl = (byte[]) ar.result;
+            if (DBG) log("EF_PL=" + IccUtils.bytesToHexString(mEfPl));
+        }
+    }
+
+    private class EfUsimLiLoaded implements IccRecordLoaded {
+        public String getEfName() {
+            return "EF_LI";
+        }
+
+        public void onRecordLoaded(AsyncResult ar) {
+            mEfLi = (byte[]) ar.result;
+            if (DBG) log("EF_LI=" + IccUtils.bytesToHexString(mEfLi));
+        }
+    }
+
+    private void handleFileUpdate(int efid) {
+        switch(efid) {
+            case EF_MBDN:
+                mRecordsToLoad++;
+                new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6,
+                        mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
+                break;
+            case EF_MAILBOX_CPHS:
+                mRecordsToLoad++;
+                new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1,
+                        1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                break;
+            case EF_CSP_CPHS:
+                mRecordsToLoad++;
+                log("[CSP] SIM Refresh for EF_CSP_CPHS");
+                mFh.loadEFTransparent(EF_CSP_CPHS,
+                        obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+                break;
+            case EF_FDN:
+                if (DBG) log("SIM Refresh called for EF_FDN");
+                mParentApp.queryFdn();
+            // MTK-START
+                //break;
+            case EF_ADN:
+            case EF_SDN:
+            case EF_PBR:
+                // ALPS00523253: If the file update is related to PHB efid, set phb ready to false
+                if (false == mIsPhbEfResetDone) {
+                    mIsPhbEfResetDone = true;
+                    mAdnCache.reset();
+                    log("handleFileUpdate ADN like");
+                    setPhbReady(false);
+                }
+                break;
+            // MTK-END
+            case EF_MSISDN:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_MSISDN");
+                new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1,
+                        obtainMessage(EVENT_GET_MSISDN_DONE));
+                break;
+            case EF_CFIS:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_CFIS");
+                mFh.loadEFLinearFixed(EF_CFIS,
+                        1, obtainMessage(EVENT_GET_CFIS_DONE));
+                break;
+            case EF_CFF_CPHS:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_CFF_CPHS");
+                mFh.loadEFTransparent(EF_CFF_CPHS,
+                        obtainMessage(EVENT_GET_CFF_DONE));
+                break;
+            default:
+                // MTK-START
+                log("handleFileUpdate default");
+                // For now, fetch all records if this is not a
+                // voicemail number.
+                // TODO: Handle other cases, instead of fetching all.
+                //mAdnCache.reset();
+                if (mAdnCache.isUsimPhbEfAndNeedReset(efid) == true) {
+                    if (false == mIsPhbEfResetDone) {
+                        mIsPhbEfResetDone = true;
+                        mAdnCache.reset();
+                        setPhbReady(false);
+                    }
+                }
+                // MTK-END
+                fetchSimRecords();
+                break;
+        }
+    }
+
+    private void handleSimRefresh(IccRefreshResponse refreshResponse){
+        if (refreshResponse == null) {
+            if (DBG) log("handleSimRefresh received without input");
+            return;
+        }
+
+        // MTK-START
+        //if (refreshResponse.aid != null &&
+        if (refreshResponse.aid != null && !TextUtils.isEmpty(refreshResponse.aid) &&
+        // MTK-START
+                !refreshResponse.aid.equals(mParentApp.getAid())) {
+            // This is for different app. Ignore.
+            // MTK-START
+            if (DBG) {
+                log("handleSimRefresh, refreshResponse.aid = " + refreshResponse.aid
+                        + ", mParentApp.getAid() = " + mParentApp.getAid());
+            }
+            // MTK-END
+            return;
+        }
+
+        switch (refreshResponse.refreshResult) {
+            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
+                // MTK-START
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_FILE_UPDATED");
+
+                handleFileUpdate(refreshResponse.efId);
+
+                mIsPhbEfResetDone = false;
+                // MTK-END
+                break;
+            case IccRefreshResponse.REFRESH_RESULT_INIT:
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_INIT");
+                // need to reload all files (that we care about)
+                // MTK-START
+                setPhbReady(false);
+                // MTK-END
+                onIccRefreshInit();
+                break;
+            case IccRefreshResponse.REFRESH_RESULT_RESET:
+                // Refresh reset is handled by the UiccCard object.
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_RESET");
+                // MTK-START
+                //if (requirePowerOffOnSimRefreshReset()) {
+                    //mCi.setRadioPower(false, null);
+                    /* Note: no need to call setRadioPower(true).  Assuming the desired
+                    * radio power state is still ON (as tracked by ServiceStateTracker),
+                    * ServiceStateTracker will call setRadioPower when it receives the
+                    * RADIO_STATE_CHANGED notification for the power off.  And if the
+                    * desired power state has changed in the interim, we don't want to
+                    * override it with an unconditional power on.
+                    */
+                    TelephonyManager.MultiSimVariants mSimVar =
+                            TelephonyManager.getDefault().getMultiSimConfiguration();
+                    log("mSimVar : " + mSimVar);
+                    if (SystemProperties.get("ro.sim_refresh_reset_by_modem").equals("1") != true) {
+                        log("sim_refresh_reset_by_modem false");
+                        mCi.resetRadio(null);
+                    } else {
+                        log("Sim reset by modem!");
+                    }
+                //}
+                //mAdnCache.reset();
+                setPhbReady(false);
+                onIccRefreshInit();
+                // MTK-END
+                break;
+            case IccRefreshResponse.REFRESH_INIT_FULL_FILE_UPDATED:
+                //ALPS00848917: Add refresh type
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_INIT_FULL_FILE_UPDATED");
+                }
+                setPhbReady(false);
+                onIccRefreshInit();
+                break;
+            case IccRefreshResponse.REFRESH_INIT_FILE_UPDATED:
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_INIT_FILE_UPDATED, EFID = "
+                            +  refreshResponse.efId);
+                }
+                handleFileUpdate(refreshResponse.efId);
+
+                mIsPhbEfResetDone = false;
+                if (mParentApp.getState() == AppState.APPSTATE_READY) {
+                    // This will cause files to be reread
+                    sendMessage(obtainMessage(EVENT_APP_READY));
+                }
+                break;
+            case IccRefreshResponse.REFRESH_SESSION_RESET:
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_SESSION_RESET");
+                }
+                // need to reload all files (that we care about)
+                onIccRefreshInit();
+                break;
+            default:
+                // unknown refresh operation
+                if (DBG) log("handleSimRefresh with unknown operation");
+                break;
+        }
+        // MTK-START
+        // notify stk app to clear the idle text
+        if (refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_INIT ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET ||
+                refreshResponse.refreshResult ==
+                IccRefreshResponse.REFRESH_INIT_FULL_FILE_UPDATED ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_INIT_FILE_UPDATED ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_APP_INIT) {
+            // impl
+            log("notify stk app to remove the idle text");
+            Intent intent;
+            intent = new Intent(TelephonyIntents.ACTION_REMOVE_IDLE_TEXT);
+            intent.putExtra(KEY_SIM_ID, mSlotId);
+            mContext.sendBroadcast(intent);
+        }
+        // MTK-END
+    }
+
+    /**
+     * Dispatch 3GPP format message to registrant ({@code GsmCdmaPhone}) to pass to the 3GPP SMS
+     * dispatcher for delivery.
+     */
+    private int dispatchGsmMessage(SmsMessage message) {
+        mNewSmsRegistrants.notifyResult(message);
+        return 0;
+    }
+
+    private void handleSms(byte[] ba) {
+        if (ba[0] != 0)
+            Rlog.d("ENF", "status : " + ba[0]);
+
+        // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+        // 3 == "received by MS from network; message to be read"
+        if (ba[0] == 3) {
+            int n = ba.length;
+
+            // Note: Data may include trailing FF's.  That's OK; message
+            // should still parse correctly.
+            byte[] pdu = new byte[n - 1];
+            System.arraycopy(ba, 1, pdu, 0, n - 1);
+            SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+
+            dispatchGsmMessage(message);
+        }
+    }
+
+
+    private void handleSmses(ArrayList<byte[]> messages) {
+        int count = messages.size();
+
+        for (int i = 0; i < count; i++) {
+            byte[] ba = messages.get(i);
+
+            if (ba[0] != 0)
+                Rlog.i("ENF", "status " + i + ": " + ba[0]);
+
+            // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+            // 3 == "received by MS from network; message to be read"
+
+            if (ba[0] == 3) {
+                int n = ba.length;
+
+                // Note: Data may include trailing FF's.  That's OK; message
+                // should still parse correctly.
+                byte[] pdu = new byte[n - 1];
+                System.arraycopy(ba, 1, pdu, 0, n - 1);
+                SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+
+                dispatchGsmMessage(message);
+
+                // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+                // 1 == "received by MS from network; message read"
+
+                ba[0] = 1;
+
+                if (false) { // FIXME: writing seems to crash RdoServD
+                    mFh.updateEFLinearFixed(EF_SMS,
+                            i, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, i));
+                }
+            }
+        }
+    }
+
+    // MTK-START
+    private String findBestLanguage(byte[] languages) {
+        String bestMatch = null;
+        String[] locales = mContext.getAssets().getLocales();
+
+        if ((languages == null) || (locales == null)) return null;
+
+        // Each 2-bytes consists of one language
+        for (int i = 0; (i + 1) < languages.length; i += 2) {
+            try {
+                String lang = new String(languages, i, 2, "ISO-8859-1");
+                if (DBG) log ("languages from sim = " + lang);
+                for (int j = 0; j < locales.length; j++) {
+                    if (locales[j] != null && locales[j].length() >= 2 &&
+                            locales[j].substring(0, 2).equalsIgnoreCase(lang)) {
+                        return lang;
+                    }
+                }
+                if (bestMatch != null) break;
+            } catch(java.io.UnsupportedEncodingException e) {
+                log ("Failed to parse USIM language records" + e);
+            }
+        }
+        // no match found. return null
+        return null;
+    }
+
+    // MTK-END
+
+    @Override
+    protected void onRecordLoaded() {
+        // One record loaded successfully or failed, In either case
+        // we need to update the recordsToLoad count
+        mRecordsToLoad -= 1;
+        if (DBG) log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
+
+        if (mRecordsToLoad == 0 && mRecordsRequested == true) {
+            onAllRecordsLoaded();
+        } else if (mRecordsToLoad < 0) {
+            loge("recordsToLoad <0, programmer error suspected");
+            mRecordsToLoad = 0;
+        }
+    }
+
+    private void setVoiceCallForwardingFlagFromSimRecords() {
+        // if (validEfCfis(mEfCfis)) {
+        // MTK-START
+        if (checkEfCfis()) {
+        // MTK-END
+            // Refer TS 51.011 Section 10.3.46 for the content description
+            mCallForwardingStatus = (mEfCfis[1] & 0x01);
+            // MTK-START
+            mPhone.setVoiceCallForwardingFlag(1,
+                    mCallForwardingStatus == CALL_FORWARDING_STATUS_ENABLED, null);
+            // MTK-END
+            log("EF_CFIS: callForwardingEnabled=" + mCallForwardingStatus);
+        } else if (mEfCff != null) {
+            mCallForwardingStatus =
+                    ((mEfCff[0] & CFF_LINE1_MASK) == CFF_UNCONDITIONAL_ACTIVE) ?
+                            CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
+            log("EF_CFF: callForwardingEnabled=" + mCallForwardingStatus);
+        } else {
+            mCallForwardingStatus = CALL_FORWARDING_STATUS_UNKNOWN;
+            log("EF_CFIS and EF_CFF not valid. callForwardingEnabled=" + mCallForwardingStatus);
+        }
+    }
+
+    @Override
+    protected void onAllRecordsLoaded() {
+        if (DBG) log("record load complete");
+
+        Resources resource = Resources.getSystem();
+        if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
+            setSimLanguage(mEfLi, mEfPl);
+        } else {
+            if (DBG) log ("Not using EF LI/EF PL");
+        }
+
+        setVoiceCallForwardingFlagFromSimRecords();
+
+        if (mParentApp.getState() == AppState.APPSTATE_PIN ||
+               mParentApp.getState() == AppState.APPSTATE_PUK ||
+               // MTK-START
+               mParentApp.getState() == AppState.APPSTATE_SUBSCRIPTION_PERSO) {
+               // MTK-END
+            // reset recordsRequested, since sim is not loaded really
+            mRecordsRequested = false;
+            // lock state, only update language
+            return ;
+        }
+
+        // Some fields require more than one SIM record to set
+
+        String operator = getOperatorNumeric();
+        if (!TextUtils.isEmpty(operator)) {
+            log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" +
+                    operator + "'");
+            log("update icc_operator_numeric=" + operator);
+            mTelephonyManager.setSimOperatorNumericForPhone(
+                    mParentApp.getPhoneId(), operator);
+            final SubscriptionController subController = SubscriptionController.getInstance();
+            subController.setMccMnc(operator, subController.getDefaultSubId());
+        } else {
+            log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
+        }
+
+        if (!TextUtils.isEmpty(mImsi)) {
+            log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + mImsi) : ""));
+            // MTK-START
+            //mTelephonyManager.setSimCountryIsoForPhone(
+            //        mParentApp.getPhoneId(), MccTable.countryCodeForMcc(
+            //        Integer.parseInt(mImsi.substring(0,3))));
+            String countryCode;
+            try {
+                countryCode =
+                    MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3)));
+            } catch (NumberFormatException e) {
+                countryCode = null;
+                loge("SIMRecords: Corrupt IMSI!");
+            }
+            mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), countryCode);
+            // MTK-END
+        } else {
+            log("onAllRecordsLoaded empty imsi skipping setting mcc");
+        }
+
+        setVoiceMailByCountry(operator);
+
+        // MTK-START
+        setSpnFromConfig(getOperatorNumeric());
+        // MTK-END
+
+        mRecordsLoadedRegistrants.notifyRegistrants(
+            new AsyncResult(null, null, null));
+
+        // MTK-START
+        fetchOpl();
+
+        log("imsi = " + mImsi + " operator = " + operator);
+
+        if (operator != null) {
+            String newName = null;
+            if (operator.equals("46002") || operator.equals("46007")) {
+                operator = "46000";
+            }
+            newName = SpnOverride.getInstance().lookupOperatorName(
+                    SubscriptionManager.getSubIdUsingPhoneId(mParentApp.getPhoneId()),
+                    operator, true, mContext);
+
+            setSystemProperty(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, newName);
+
+        }
+        // MTK-END
+    }
+
+    //***** Private methods
+
+    private void handleCarrierNameOverride() {
+        CarrierConfigManager configLoader = (CarrierConfigManager)
+                mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        if (configLoader != null && configLoader.getConfig().getBoolean(
+                CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
+            String carrierName = configLoader.getConfig().getString(
+                    CarrierConfigManager.KEY_CARRIER_NAME_STRING);
+            setServiceProviderName(carrierName);
+            mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(),
+                    carrierName);
+        } else {
+            // MTK-START
+            if (getRecordsLoaded()) {
+            // MTK-END
+                setSpnFromConfig(getOperatorNumeric());
+            // MTK-START
+            }
+            // MTK-END
+        }
+    }
+
+    private void setSpnFromConfig(String carrier) {
+        // MTK-START
+        // If EF_SPN has value, use it directly to avoid wrong spn-conf.xml to
+        // override the EF_SPN value.
+        //if (mSpnOverride.containsCarrier(carrier)) {
+        //    setServiceProviderName(mSpnOverride.getSpn(carrier));
+        //    mTelephonyManager.setSimOperatorNameForPhone(
+        //            mParentApp.getPhoneId(), getServiceProviderName());
+        //}
+        if (TextUtils.isEmpty(getServiceProviderName()) && mSpnOverride.containsCarrier(carrier)) {
+            mTelephonyManager.setSimOperatorNameForPhone(
+                    mParentApp.getPhoneId(), mSpnOverride.getSpn(carrier));
+        }
+    }
+
+
+    private void setVoiceMailByCountry (String spn) {
+        if (mVmConfig.containsCarrier(spn)) {
+            // MTK-START
+            log("setVoiceMailByCountry");
+            // MTK-END
+            mIsVoiceMailFixed = true;
+            mVoiceMailNum = mVmConfig.getVoiceMailNumber(spn);
+            mVoiceMailTag = mVmConfig.getVoiceMailTag(spn);
+        }
+    }
+
+    @Override
+    public void onReady() {
+        fetchSimRecords();
+    }
+
+    private void onLocked() {
+        if (DBG) log("only fetch EF_LI and EF_PL in lock state");
+        loadEfLiAndEfPl();
+    }
+
+    private void loadEfLiAndEfPl() {
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            mRecordsRequested = true;
+            mFh.loadEFTransparent(EF_LI,
+                    obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfUsimLiLoaded()));
+            mRecordsToLoad++;
+
+            mFh.loadEFTransparent(EF_PL,
+                    obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
+            mRecordsToLoad++;
+        }
+    }
+
+    private void loadCallForwardingRecords() {
+        mRecordsRequested = true;
+        mFh.loadEFLinearFixed(EF_CFIS, 1, obtainMessage(EVENT_GET_CFIS_DONE));
+        mRecordsToLoad++;
+        mFh.loadEFTransparent(EF_CFF_CPHS, obtainMessage(EVENT_GET_CFF_DONE));
+        mRecordsToLoad++;
+    }
+
+    protected void fetchSimRecords() {
+        mRecordsRequested = true;
+
+        if (DBG) log("fetchSimRecords " + mRecordsToLoad);
+
+        mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
+        mRecordsToLoad++;
+
+        // FIXME should examine EF[MSISDN]'s capability configuration
+        // to determine which is the voice/data/fax line
+        new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1,
+                    obtainMessage(EVENT_GET_MSISDN_DONE));
+        mRecordsToLoad++;
+
+        // Record number is subscriber profile
+        // MTK-START
+        // We should check the SST table before read EF_MBI.
+        //mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
+        //mRecordsToLoad++;
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
+        mRecordsToLoad++;
+
+        // Record number is subscriber profile
+        // MTK-START
+        // [ALPS01888298] should check service before access MWIS EF
+        //mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
+        //mRecordsToLoad++;
+        // MTK-END
+
+        // Also load CPHS-style voice mail indicator, which stores
+        // the same info as EF[MWIS]. If both exist, both are updated
+        // but the EF[MWIS] data is preferred
+        // Please note this must be loaded after EF[MWIS]
+        mFh.loadEFTransparent(
+                EF_VOICE_MAIL_INDICATOR_CPHS,
+                obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
+        mRecordsToLoad++;
+
+        // Same goes for Call Forward Status indicator: fetch both
+        // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
+        loadCallForwardingRecords();
+
+        // MTK-START
+        //getSpnFsm(true, null);
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
+        mRecordsToLoad++;
+
+        // MTK-START
+        //mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
+        //recordsToLoad++;
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_CSP_CPHS,obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_GID2, obtainMessage(EVENT_GET_GID2_DONE));
+        mRecordsToLoad++;
+
+        loadEfLiAndEfPl();
+
+        // MTK-START
+        // TODO: Wait for isSetLanguageBySIM ready
+        /*
+                Detail description:
+                This feature provides a interface to get menu title string from EF_SUME
+                */
+        if (mTelephonyExt != null) {
+            if (mTelephonyExt.isSetLanguageBySIM()) {
+                mFh.loadEFTransparent(EF_SUME, obtainMessage(EVENT_QUERY_MENU_TITLE_DONE));
+                mRecordsToLoad++;
+            }
+        } else {
+           loge("fetchSimRecords(): mTelephonyExt is null!!!");
+        }
+
+        fetchCPHSOns();
+        // MTK-END
+
+
+        // XXX should seek instead of examining them all
+        if (false) { // XXX
+            mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
+            mRecordsToLoad++;
+        }
+
+        if (CRASH_RIL) {
+            String sms = "0107912160130310f20404d0110041007030208054832b0120"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "ffffffffffffffffffffffffffffff";
+            byte[] ba = IccUtils.hexStringToBytes(sms);
+
+            mFh.updateEFLinearFixed(EF_SMS, 1, ba, null,
+                            obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
+        }
+        if (DBG) log("fetchSimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
+        // MTK-START
+        fetchRatBalancing();
+        // MTK-END
+    }
+
+    /**
+     * Returns the SpnDisplayRule based on settings on the SIM and the
+     * specified plmn (currently-registered PLMN).  See TS 22.101 Annex A
+     * and TS 51.011 10.3.11 for details.
+     *
+     * If the SPN is not found on the SIM or is empty, the rule is
+     * always PLMN_ONLY.
+     */
+    @Override
+    public int getDisplayRule(String plmn) {
+        int rule;
+        // MTK-START
+        boolean bSpnActive = false;
+        String spn = getServiceProviderName();
+
+        if (mEfSST != null && mParentApp != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                if (mEfSST.length >= 3 && (mEfSST[2] & 0x04) == 4) {
+                    bSpnActive = true;
+                    log("getDisplayRule USIM mEfSST is " +
+                     IccUtils.bytesToHexString(mEfSST) + " set bSpnActive to true");
+                }
+            } else if ((mEfSST.length >= 5) && (mEfSST[4] & 0x02) == 2) {
+                bSpnActive = true;
+                log("getDisplayRule SIM mEfSST is " +
+                    IccUtils.bytesToHexString(mEfSST) + " set bSpnActive to true");
+            }
+        }
+
+        log("getDisplayRule mParentApp is " +
+            ((mParentApp != null) ? mParentApp : "null"));
+        // MTK-END
+        if (mParentApp != null && mParentApp.getUiccCard() != null &&
+            mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
+        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
+            // MTK-START
+            log("getDisplayRule, getOperatorBrandOverride is not null");
+            // MTK-END
+            rule = SPN_RULE_SHOW_PLMN;
+            // MTK-START
+        //} else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
+        } else if (!bSpnActive || TextUtils.isEmpty(spn) ||
+                spn.equals("") || mSpnDisplayCondition == -1) {
+            // MTK-END
+            // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
+            // MTK-START
+            log("getDisplayRule, no EF_SPN");
+            // MTK-END
+            rule = SPN_RULE_SHOW_PLMN;
+        } else if (isOnMatchingPlmn(plmn)) {
+            rule = SPN_RULE_SHOW_SPN;
+            if ((mSpnDisplayCondition & 0x01) == 0x01) {
+                // ONS required when registered to HPLMN or PLMN in EF_SPDI
+                rule |= SPN_RULE_SHOW_PLMN;
+            }
+        } else {
+            rule = SPN_RULE_SHOW_PLMN;
+            if ((mSpnDisplayCondition & 0x02) == 0x00) {
+                // SPN required if not registered to HPLMN or PLMN in EF_SPDI
+                rule |= SPN_RULE_SHOW_SPN;
+            }
+        }
+        return rule;
+    }
+
+    /**
+     * Checks if plmn is HPLMN or on the spdiNetworks list.
+     */
+    private boolean isOnMatchingPlmn(String plmn) {
+        if (plmn == null) return false;
+
+        // MTK-START
+        //if (plmn.equals(getOperatorNumeric())) {
+        if (isHPlmn(plmn)) {
+        // MTK-END
+            return true;
+        }
+
+        if (mSpdiNetworks != null) {
+            for (String spdiNet : mSpdiNetworks) {
+                if (plmn.equals(spdiNet)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * States of Get SPN Finite State Machine which only used by getSpnFsm()
+     */
+    private enum GetSpnFsmState {
+        IDLE,               // No initialized
+        INIT,               // Start FSM
+        READ_SPN_3GPP,      // Load EF_SPN firstly
+        READ_SPN_CPHS,      // Load EF_SPN_CPHS secondly
+        READ_SPN_SHORT_CPHS // Load EF_SPN_SHORT_CPHS last
+    }
+
+    /**
+     * Finite State Machine to load Service Provider Name , which can be stored
+     * in either EF_SPN (3GPP), EF_SPN_CPHS, or EF_SPN_SHORT_CPHS (CPHS4.2)
+     *
+     * After starting, FSM will search SPN EFs in order and stop after finding
+     * the first valid SPN
+     *
+     * If the FSM gets restart while waiting for one of
+     * SPN EFs results (i.e. a SIM refresh occurs after issuing
+     * read EF_CPHS_SPN), it will re-initialize only after
+     * receiving and discarding the unfinished SPN EF result.
+     *
+     * @param start set true only for initialize loading
+     * @param ar the AsyncResult from loadEFTransparent
+     *        ar.exception holds exception in error
+     *        ar.result is byte[] for data in success
+     */
+    private void getSpnFsm(boolean start, AsyncResult ar) {
+        byte[] data;
+
+        if (start) {
+            // Check previous state to see if there is outstanding
+            // SPN read
+            if(mSpnState == GetSpnFsmState.READ_SPN_3GPP ||
+               mSpnState == GetSpnFsmState.READ_SPN_CPHS ||
+               mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS ||
+               mSpnState == GetSpnFsmState.INIT) {
+                // Set INIT then return so the INIT code
+                // will run when the outstanding read done.
+                mSpnState = GetSpnFsmState.INIT;
+                return;
+            } else {
+                mSpnState = GetSpnFsmState.INIT;
+            }
+        }
+
+        switch(mSpnState){
+            case INIT:
+                // MTK-START
+                //setServiceProviderName(null);
+                // MTK-END
+
+                mFh.loadEFTransparent(EF_SPN,
+                        obtainMessage(EVENT_GET_SPN_DONE));
+                mRecordsToLoad++;
+
+                mSpnState = GetSpnFsmState.READ_SPN_3GPP;
+                break;
+            case READ_SPN_3GPP:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    mSpnDisplayCondition = 0xff & data[0];
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 1, data.length - 1));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        mSpnState = GetSpnFsmState.READ_SPN_CPHS;
+                    } else {
+                        if (DBG) log("Load EF_SPN: " + spn
+                                + " spnDisplayCondition: " + mSpnDisplayCondition);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+
+                        mSpnState = GetSpnFsmState.IDLE;
+                    }
+                } else {
+                    mSpnState = GetSpnFsmState.READ_SPN_CPHS;
+                }
+
+                if (mSpnState == GetSpnFsmState.READ_SPN_CPHS) {
+                    mFh.loadEFTransparent( EF_SPN_CPHS,
+                            obtainMessage(EVENT_GET_SPN_DONE));
+                    mRecordsToLoad++;
+
+                    // See TS 51.011 10.3.11.  Basically, default to
+                    // show PLMN always, and SPN also if roaming.
+                    mSpnDisplayCondition = -1;
+                }
+                break;
+            case READ_SPN_CPHS:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 0, data.length));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
+                    } else {
+                        // Display CPHS Operator Name only when not roaming
+                        mSpnDisplayCondition = 2;
+
+                        if (DBG) log("Load EF_SPN_CPHS: " + spn);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+
+                        mSpnState = GetSpnFsmState.IDLE;
+                    }
+                } else {
+                    mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
+                }
+
+                if (mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS) {
+                    mFh.loadEFTransparent(
+                            EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
+                    mRecordsToLoad++;
+                }
+                break;
+            case READ_SPN_SHORT_CPHS:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 0, data.length));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        if (DBG) log("No SPN loaded in either CHPS or 3GPP");
+                    } else {
+                        // Display CPHS Operator Name only when not roaming
+                        mSpnDisplayCondition = 2;
+
+                        if (DBG) log("Load EF_SPN_SHORT_CPHS: " + spn);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+                    }
+                } else {
+                    setServiceProviderName(null);
+                    if (DBG) log("No SPN loaded in either CHPS or 3GPP");
+                }
+
+                mSpnState = GetSpnFsmState.IDLE;
+                break;
+            default:
+                mSpnState = GetSpnFsmState.IDLE;
+        }
+    }
+
+    /**
+     * Parse TS 51.011 EF[SPDI] record
+     * This record contains the list of numeric network IDs that
+     * are treated specially when determining SPN display
+     */
+    private void
+    parseEfSpdi(byte[] data) {
+        SimTlv tlv = new SimTlv(data, 0, data.length);
+
+        byte[] plmnEntries = null;
+
+        for ( ; tlv.isValidObject() ; tlv.nextObject()) {
+            // Skip SPDI tag, if existant
+            if (tlv.getTag() == TAG_SPDI) {
+              tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
+            }
+            // There should only be one TAG_SPDI_PLMN_LIST
+            if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
+                plmnEntries = tlv.getData();
+                break;
+            }
+        }
+
+        if (plmnEntries == null) {
+            return;
+        }
+
+        mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
+
+        for (int i = 0 ; i + 2 < plmnEntries.length ; i += 3) {
+            String plmnCode;
+            // MTK-START
+            //plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
+            plmnCode = IccUtils.parsePlmnToString(plmnEntries, i, 3);
+            // MTK-END
+
+            // Valid operator codes are 5 or 6 digits
+            if (plmnCode.length() >= 5) {
+                log("EF_SPDI network: " + plmnCode);
+                mSpdiNetworks.add(plmnCode);
+            }
+        }
+    }
+
+    /**
+     * check to see if Mailbox Number is allocated and activated in CPHS SST
+     */
+    private boolean isCphsMailboxEnabled() {
+        if (mCphsInfo == null)  return false;
+        return ((mCphsInfo[1] & CPHS_SST_MBN_MASK) == CPHS_SST_MBN_ENABLED );
+    }
+
+    @Override
+    protected void log(String s) {
+        // MTK-START
+        //Rlog.d(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.d(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    @Override
+    protected void loge(String s) {
+        // MTK-START
+        //Rlog.e(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.e(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    protected void logw(String s, Throwable tr) {
+        // MTK-START
+        //Rlog.w(LOG_TAG, "[SIMRecords] " + s, tr);
+        Rlog.w(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")", tr);
+        // MTK-END
+    }
+
+    protected void logv(String s) {
+        // MTK-START
+        //Rlog.v(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.v(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    /**
+     * Return true if "Restriction of menu options for manual PLMN selection"
+     * bit is set or EF_CSP data is unavailable, return false otherwise.
+     */
+    @Override
+    public boolean isCspPlmnEnabled() {
+        return mCspPlmnEnabled;
+    }
+
+    /**
+     * Parse EF_CSP data and check if
+     * "Restriction of menu options for manual PLMN selection" is
+     * Enabled/Disabled
+     *
+     * @param data EF_CSP hex data.
+     */
+    private void handleEfCspData(byte[] data) {
+        // As per spec CPHS4_2.WW6, CPHS B.4.7.1, EF_CSP contains CPHS defined
+        // 18 bytes (i.e 9 service groups info) and additional data specific to
+        // operator. The valueAddedServicesGroup is not part of standard
+        // services. This is operator specific and can be programmed any where.
+        // Normally this is programmed as 10th service after the standard
+        // services.
+        int usedCspGroups = data.length / 2;
+        // This is the "Service Group Number" of "Value Added Services Group".
+        byte valueAddedServicesGroup = (byte)0xC0;
+
+        mCspPlmnEnabled = true;
+        for (int i = 0; i < usedCspGroups; i++) {
+             if (data[2 * i] == valueAddedServicesGroup) {
+                 log("[CSP] found ValueAddedServicesGroup, value " + data[(2 * i) + 1]);
+                 if ((data[(2 * i) + 1] & 0x80) == 0x80) {
+                     // Bit 8 is for
+                     // "Restriction of menu options for manual PLMN selection".
+                     // Operator Selection menu should be enabled.
+                     mCspPlmnEnabled = true;
+                 } else {
+                     mCspPlmnEnabled = false;
+                     // Operator Selection menu should be disabled.
+                     // Operator Selection Mode should be set to Automatic.
+                     log("[CSP] Set Automatic Network Selection");
+                     mNetworkSelectionModeAutomaticRegistrants.notifyRegistrants();
+                 }
+                 return;
+             }
+        }
+
+        log("[CSP] Value Added Service Group (0xC0), not found!");
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("SIMRecords: " + this);
+        pw.println(" extends:");
+        super.dump(fd, pw, args);
+        pw.println(" mVmConfig=" + mVmConfig);
+        pw.println(" mSpnOverride=" + mSpnOverride);
+        pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
+        pw.println(" mSpnState=" + mSpnState);
+        pw.println(" mCphsInfo=" + mCphsInfo);
+        pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
+        pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
+        pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
+        pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
+        pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
+        pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
+        pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
+        pw.println(" mPnnHomeName=" + mPnnHomeName);
+        pw.println(" mUsimServiceTable=" + mUsimServiceTable);
+        pw.println(" mGid1=" + mGid1);
+        pw.println(" mGid2=" + mGid2);
+        pw.flush();
+    }
+
+    // MTK-START
+    // MVNO-API START
+    public String getSpNameInEfSpn() {
+        if (DBG) log("getSpNameInEfSpn(): " + mSpNameInEfSpn);
+        return mSpNameInEfSpn;
+    }
+
+    public String isOperatorMvnoForImsi() {
+        SpnOverride spnOverride = SpnOverride.getInstance();
+        String imsiPattern = spnOverride.isOperatorMvnoForImsi(getOperatorNumeric(),
+                getIMSI());
+        String mccmnc = getOperatorNumeric();
+        if (DBG) {
+            log("isOperatorMvnoForImsi(), imsiPattern: " + imsiPattern
+                + ", mccmnc: " + mccmnc);
+        }
+        if (imsiPattern == null || mccmnc == null) {
+            return null;
+        }
+        String result = imsiPattern.substring(mccmnc.length(), imsiPattern.length());
+        if (DBG) {
+            log("isOperatorMvnoForImsi(): " + result);
+        }
+        return result;
+    }
+
+
+    public String getFirstFullNameInEfPnn() {
+        if (mPnnNetworkNames == null || mPnnNetworkNames.size() == 0) {
+            if (DBG) log("getFirstFullNameInEfPnn(): empty");
+            return null;
+        }
+
+        OperatorName opName = mPnnNetworkNames.get(0);
+        if (DBG) log("getFirstFullNameInEfPnn(): first fullname: " + opName.sFullName);
+        if (opName.sFullName != null)
+            return new String(opName.sFullName);
+        return null;
+    }
+
+    public String isOperatorMvnoForEfPnn() {
+        String MCCMNC = getOperatorNumeric();
+        String PNN = getFirstFullNameInEfPnn();
+        if (DBG) log("isOperatorMvnoForEfPnn(): mccmnc = " + MCCMNC + ", pnn = " + PNN);
+        if (SpnOverride.getInstance().getSpnByEfPnn(MCCMNC, PNN) != null)
+            return PNN;
+        return null;
+    }
+
+    public String getMvnoMatchType() {
+        String IMSI = getIMSI();
+        String SPN = getSpNameInEfSpn();
+        String PNN = getFirstFullNameInEfPnn();
+        String GID1 = getGid1();
+        String MCCMNC = getOperatorNumeric();
+        if (DBG) {
+            log("getMvnoMatchType(): imsi = " + IMSI + ", mccmnc = " + MCCMNC + ", spn = " + SPN);
+        }
+
+        if (SpnOverride.getInstance().getSpnByEfSpn(MCCMNC, SPN) != null)
+            return PhoneConstants.MVNO_TYPE_SPN;
+
+        if (SpnOverride.getInstance().getSpnByImsi(MCCMNC, IMSI) != null)
+            return PhoneConstants.MVNO_TYPE_IMSI;
+
+        if (SpnOverride.getInstance().getSpnByEfPnn(MCCMNC, PNN) != null)
+            return PhoneConstants.MVNO_TYPE_PNN;
+
+        if (SpnOverride.getInstance().getSpnByEfGid1(MCCMNC, GID1) != null)
+            return PhoneConstants.MVNO_TYPE_GID;
+
+        return PhoneConstants.MVNO_TYPE_NONE;
+    }
+    // MVNO-API END
+
+    private class SIMBroadCastReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals("com.mediatek.dm.LAWMO_WIPE")) {
+               wipeAllSIMContacts();
+            } else {
+                if (action.equals("android.intent.action.ACTION_SHUTDOWN_IPO")) {
+                   processShutdownIPO();
+                   // ALPS00293301
+                   //SystemProperties.set(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, null);
+                   //if(FeatureOption.MTK_GEMINI_SUPPORT)
+                   //    SystemProperties.set(PROPERTY_ICC_OPERATOR_DEFAULT_NAME_2, null);
+
+                   //ALPS01213113
+                   SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], null);
+
+                   // ALPS00302698 ENS
+                   log("wipeAllSIMContacts ACTION_SHUTDOWN_IPO: reset mCspPlmnEnabled");
+                   mCspPlmnEnabled = true;
+
+                   // TODO: Wait for isSetLanguageBySIM ready
+                   // ALPS00302702 RAT balancing
+                   if (mTelephonyExt.isSetLanguageBySIM()) {
+                       mEfRatLoaded = false;
+                       mEfRat = null;
+                   }
+
+                   mAdnCache.reset();
+                   log("wipeAllSIMContacts ACTION_SHUTDOWN_IPO");
+                } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                    String reasonExtra = intent.getStringExtra(
+                            IccCardConstants.INTENT_KEY_LOCKED_REASON);
+                    int slot = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                    String simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                    log("SIM_STATE_CHANGED: slot = " + slot + ",reason = " + reasonExtra +
+                            ",simState = " + simState);
+                    if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(reasonExtra)) {
+                        if (slot == mSlotId) {
+                            String strPuk1Count = null;
+                            strPuk1Count = SystemProperties.get(
+                                    SIMRECORD_PROPERTY_RIL_PUK1[mSlotId], "0");
+                            log("SIM_STATE_CHANGED: strPuk1Count = " + strPuk1Count);
+                            //if (strPuk1Count.equals("0")){
+                            //    setPhbReady(false);
+                            //}
+
+                            mMsisdn = "";
+                            //setNumberToSimInfo();
+                            mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                        }
+                    }
+                    if (slot == mSlotId) {
+                        String strPhbReady = null;
+                        strPhbReady = SystemProperties.get(
+                                SIMRECORD_PROPERTY_RIL_PHB_READY[mSlotId], "false");
+                        //Update phb ready by sim state.
+                        log("sim state: " + simState + ", mPhbReady: " + mPhbReady +
+                                ",strPhbReady: " + strPhbReady.equals("true"));
+                        if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simState)) {
+                            if (false == mPhbReady && strPhbReady.equals("true")) {
+                                mPhbReady = true;
+                                broadcastPhbStateChangedIntent(mPhbReady);
+
+                            } else if (true == mPhbWaitSub && strPhbReady.equals("true")) {
+                                log("mPhbWaitSub is " + mPhbWaitSub + ", broadcast if need");
+                                mPhbWaitSub = false;
+                                broadcastPhbStateChangedIntent(mPhbReady);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private class SubBroadCastReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+            if ((mPhbWaitSub == true) &&
+                    (action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED))) {
+                log("SubBroadCastReceiver receive ACTION_SUBINFO_RECORD_UPDATED");
+                mPhbWaitSub = false;
+                broadcastPhbStateChangedIntent(mPhbReady);
+            }
+        }
+    }
+
+    private void wipeAllSIMContacts() {
+        if (DBG) log("wipeAllSIMContacts");
+        mAdnCache.reset();
+        if (DBG) log("wipeAllSIMContacts after reset");
+    }
+
+    private void processShutdownIPO() {
+        // reset icc id variable when ipo shutdown
+        // ipo shutdown will make radio turn off,
+        // only needs to reset the variable which will not be reset in onRadioOffOrNotAvailable()
+        hasQueryIccId = false;
+        iccIdQueryState = -1;
+        mIccId = null;
+        mImsi = null;
+        mSpNameInEfSpn = null;
+
+    }
+
+    private void fetchEccList() {
+        // [Backward compatible]
+        // If "ril.ef.ecc.support" is "1", means modem will send URC to notify
+        // EF_ECC's value and phone number utility module will take over the
+        // system properties.
+
+        int eccFromModemUrc = SystemProperties.getInt("ril.ef.ecc.support", 0);
+
+        if (DBG) log("fetchEccList(), eccFromModemUrc:" + eccFromModemUrc);
+
+        if (eccFromModemUrc == 0) {
+            mEfEcc = "";
+
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                mFh.loadEFLinearFixedAll(EF_ECC, obtainMessage(EVENT_GET_USIM_ECC_DONE));
+            } else {
+                mFh.loadEFTransparent(EF_ECC, obtainMessage(EVENT_GET_SIM_ECC_DONE));
+            }
+        }
+    }
+
+    //ALPS00784072: We don't need to update configure if mnc & mnc not changed.
+    private void updateConfiguration(String numeric) {
+        if (!TextUtils.isEmpty(numeric) && !mOldMccMnc.equals(numeric)) {
+            mOldMccMnc = numeric;
+            MccTable.updateMccMncConfiguration(mContext, mOldMccMnc, false);
+        } else {
+            log("Do not update configuration if mcc mnc no change.");
+        }
+    }
+
+    /**
+    *parse pnn list
+    */
+    private void parseEFpnn(ArrayList messages) {
+        int count = messages.size();
+        if (DBG) log("parseEFpnn(): pnn has " + count + " records");
+
+        mPnnNetworkNames = new ArrayList<OperatorName>(count);
+        for (int i = 0; i < count; i++) {
+            byte[] data = (byte[]) messages.get(i);
+            if (DBG) {
+                log("parseEFpnn(): pnn record " + i + " content is " +
+                        IccUtils.bytesToHexString(data));
+            }
+
+            SimTlv tlv = new SimTlv(data, 0, data.length);
+            OperatorName opName = new OperatorName();
+            for (; tlv.isValidObject(); tlv.nextObject()) {
+                if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
+                    opName.sFullName = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                    if (DBG) log("parseEFpnn(): pnn sFullName is "  + opName.sFullName);
+                } else if (tlv.getTag() == TAG_SHORT_NETWORK_NAME) {
+                    opName.sShortName = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                    if (DBG) log("parseEFpnn(): pnn sShortName is "  + opName.sShortName);
+                }
+            }
+
+            mPnnNetworkNames.add(opName);
+        }
+    }
+
+    // ALPS00267605 : PNN/OPL revision
+    private void fetchPnn() {
+        if (DBG) log("fetchPnn()");
+        //boolean bPnnOplActive = false;
+        boolean bPnnActive = false;
+        boolean bOplActive = false;
+
+        if (mEfSST != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                if (mEfSST.length >= 6) {
+                    bPnnActive = ((mEfSST[5] & 0x10) == 0x10);
+                    if (bPnnActive) {
+                        bOplActive = ((mEfSST[5] & 0x20) == 0x20);
+                    }
+                }
+            } else if (mEfSST.length >= 13) {
+                bPnnActive = ((mEfSST[12] & 0x30) == 0x30);
+                if (bPnnActive) {
+                    bOplActive = ((mEfSST[12] & 0xC0) == 0xC0);
+                }
+            }
+        }
+        if (DBG) log("bPnnActive = " + bPnnActive + ", bOplActive = " + bOplActive);
+
+        if (bPnnActive) {
+            mFh.loadEFLinearFixedAll(EF_PNN, obtainMessage(EVENT_GET_PNN_DONE));
+            mRecordsToLoad++;
+        }
+    }
+
+    private void fetchOpl() {
+        if (DBG) log("fetchOpl()");
+        //boolean bPnnOplActive = false;
+        boolean bPnnActive = false;
+        boolean bOplActive = false;
+
+        if (mEfSST != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                if (mEfSST.length >= 6) {
+                    bPnnActive = ((mEfSST[5] & 0x10) == 0x10);
+                    if (bPnnActive) {
+                        bOplActive = ((mEfSST[5] & 0x20) == 0x20);
+                    }
+                }
+            } else if (mEfSST.length >= 13) {
+                bPnnActive = ((mEfSST[12] & 0x30) == 0x30);
+                if (bPnnActive) {
+                    bOplActive = ((mEfSST[12] & 0xC0) == 0xC0);
+                }
+            }
+        }
+        if (DBG) log("bPnnActive = " + bPnnActive + ", bOplActive = " + bOplActive);
+
+        if (bPnnActive) {
+            if (bOplActive) {
+                mFh.loadEFLinearFixedAll(EF_OPL, obtainMessage(EVENT_GET_ALL_OPL_DONE));
+            }
+        }
+    }
+
+    private void fetchSpn() {
+        if (DBG) log("fetchSpn()");
+        boolean bSpnActive = false;
+
+        IccConstants.IccServiceStatus iccSerStatus = getSIMServiceStatus(
+                IccConstants.IccService.SPN);
+        if (iccSerStatus == IccConstants.IccServiceStatus.ACTIVATED) {
+            setServiceProviderName(null);
+            mFh.loadEFTransparent(EF_SPN,
+                    obtainMessage(EVENT_GET_SPN_DONE));
+            mRecordsToLoad++;
+        } else {
+            if (DBG) log("[SIMRecords] SPN service is not activated  ");
+        }
+    }
+
+    public IccConstants.IccServiceStatus getSIMServiceStatus(
+            IccConstants.IccService enService) {
+        int nServiceNum = enService.getIndex();
+        IccConstants.IccServiceStatus simServiceStatus = IccConstants.IccServiceStatus.UNKNOWN;
+        if (DBG) {
+            log("getSIMServiceStatus enService is " + enService +
+                    " Service Index is " + nServiceNum);
+        }
+
+        if (nServiceNum >= 0 &&
+                nServiceNum < IccConstants.IccService.UNSUPPORTED_SERVICE.getIndex() &&
+                mEfSST != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                int nUSTIndex = usimServiceNumber[nServiceNum];
+                if (nUSTIndex <= 0) {
+                    simServiceStatus = IccConstants.IccServiceStatus.NOT_EXIST_IN_USIM;
+                } else {
+                    int nbyte = nUSTIndex / 8;
+                    int nbit = nUSTIndex % 8 ;
+                    if (nbit == 0) {
+                        nbit = 7;
+                        nbyte--;
+                    } else {
+                        nbit--;
+                    }
+                    if (DBG) log("getSIMServiceStatus USIM nbyte: " + nbyte + " nbit: " + nbit);
+
+                    if (mEfSST.length > nbyte && ((mEfSST[nbyte] & (0x1 << nbit)) > 0)) {
+                        simServiceStatus = IccConstants.IccServiceStatus.ACTIVATED;
+                    } else {
+                        simServiceStatus = IccConstants.IccServiceStatus.INACTIVATED;
+                    }
+                }
+            } else {
+                int nSSTIndex = simServiceNumber[nServiceNum];
+                if (nSSTIndex <= 0) {
+                    simServiceStatus = IccConstants.IccServiceStatus.NOT_EXIST_IN_SIM;
+                } else {
+                    int nbyte = nSSTIndex / 4;
+                    int nbit = nSSTIndex % 4;
+                    if (nbit == 0) {
+                        nbit = 3;
+                        nbyte--;
+                    } else {
+                        nbit--;
+                    }
+
+                    int nMask = (0x2 << (nbit * 2));
+                    log("getSIMServiceStatus SIM nbyte: " + nbyte +
+                            " nbit: " + nbit + " nMask: " + nMask);
+                    if (mEfSST.length > nbyte && ((mEfSST[nbyte] & nMask) == nMask)) {
+                        simServiceStatus = IccConstants.IccServiceStatus.ACTIVATED;
+                    } else {
+                        simServiceStatus = IccConstants.IccServiceStatus.INACTIVATED;
+                    }
+                }
+            }
+        }
+
+        log("getSIMServiceStatus simServiceStatus: " + simServiceStatus);
+        return simServiceStatus;
+    }
+
+    private void fetchSmsp() {
+        if (DBG) log("fetchSmsp()");
+
+        //For USim authentication.
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.SM_SERVICE_PARAMS)) {
+                if (DBG) log("SMSP support.");
+                mFh.loadEFLinearFixed(EF_SMSP, 1, obtainMessage(EVENT_GET_SMSP_DONE));
+                mRecordsToLoad++;
+
+                if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.SM_OVER_IP)) {
+                    if (DBG) log("PSISMSP support.");
+                    mFh.loadEFLinearFixed(EF_PSISMSC, 1, obtainMessage(EVENT_GET_PSISMSC_DONE));
+                    mRecordsToLoad++;
+                }
+
+            }
+        }
+    }
+
+    private void fetchGbaRecords() {
+        if (DBG) log("fetchGbaRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.GBA)) {
+                if (DBG) log("GBA support.");
+                mFh.loadEFTransparent(EF_ISIM_GBABP, obtainMessage(EVENT_GET_GBABP_DONE));
+                mRecordsToLoad++;
+
+                mFh.loadEFLinearFixedAll(EF_ISIM_GBANL, obtainMessage(EVENT_GET_GBANL_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    private void fetchMbiRecords() {
+        if (DBG) log("fetchMbiRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.MBDN)) {
+                if (DBG) log("MBI/MBDN support.");
+                mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    private void fetchMwisRecords() {
+        if (DBG) log("fetchMwisRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.MWI_STATUS)) {
+                if (DBG) log("MWIS support.");
+                mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    /**
+    *parse opl list
+    */
+    private void parseEFopl(ArrayList messages) {
+        int count = messages.size();
+        if (DBG) log("parseEFopl(): opl has " + count + " records");
+
+        mOperatorList = new ArrayList<OplRecord>(count);
+        for (int i = 0; i < count; i++) {
+            byte[] data = (byte[]) messages.get(i);
+
+            OplRecord oplRec = new OplRecord();
+
+            oplRec.sPlmn = IccUtils.parsePlmnToStringForEfOpl(data, 0, 3); // ALPS00316057
+
+            byte[] minLac = new byte[2];
+            minLac[0] = data[3];
+            minLac[1] = data[4];
+            oplRec.nMinLAC = Integer.parseInt(IccUtils.bytesToHexString(minLac), 16);
+
+            byte[] maxLAC = new byte[2];
+            maxLAC[0] = data[5];
+            maxLAC[1] = data[6];
+            oplRec.nMaxLAC = Integer.parseInt(IccUtils.bytesToHexString(maxLAC), 16);
+
+            byte[] pnnRecordIndex = new byte[1];
+            pnnRecordIndex[0] = data[7];
+            oplRec.nPnnIndex = Integer.parseInt(IccUtils.bytesToHexString(pnnRecordIndex), 16);
+            if (DBG) {
+                log("parseEFopl(): record=" + i + " content=" + IccUtils.bytesToHexString(data) +
+                        " sPlmn=" + oplRec.sPlmn + " nMinLAC=" + oplRec.nMinLAC +
+                        " nMaxLAC=" + oplRec.nMaxLAC + " nPnnIndex=" + oplRec.nPnnIndex);
+            }
+
+            mOperatorList.add(oplRec);
+        }
+    }
+
+    private void boradcastEfRatContentNotify(int item) {
+        Intent intent = new Intent(TelephonyIntents.ACTION_EF_RAT_CONTENT_NOTIFY);
+        intent.putExtra(TelephonyIntents.EXTRA_EF_RAT_STATUS, item);
+        intent.putExtra(PhoneConstants.SLOT_KEY, mSlotId);
+        log("broadCast intent ACTION_EF_RAT_CONTENT_NOTIFY: item: " + item + ", simId: " + mSlotId);
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+    }
+
+    // ALPS00302698 ENS
+    private void processEfCspPlmnModeBitUrc(int bit) {
+        log("processEfCspPlmnModeBitUrc: bit = " + bit);
+        if (bit == 0) {
+            mCspPlmnEnabled = false;
+        } else {
+            mCspPlmnEnabled = true;
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_EF_CSP_CONTENT_NOTIFY);
+        intent.putExtra(TelephonyIntents.EXTRA_PLMN_MODE_BIT, bit);
+        intent.putExtra(PhoneConstants.SLOT_KEY, mSlotId);
+        log("broadCast intent ACTION_EF_CSP_CONTENT_NOTIFY, EXTRA_PLMN_MODE_BIT: " +  bit);
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+
+    }
+
+    private void fetchLanguageIndicator() {
+        log("fetchLanguageIndicator ");
+        String l = SystemProperties.get("persist.sys.language");
+        String c = SystemProperties.get("persist.sys.country");
+        String oldSimLang = SystemProperties.get("persist.sys.simlanguage");
+        if ((null == l || 0 == l.length()) && (null == c || 0 == c.length())
+                         && (null == oldSimLang || 0 == oldSimLang.length())) {
+            if (mEfLi == null) {
+                mFh.loadEFTransparent(EF_LI,
+                       obtainMessage(EVENT_GET_LI_DONE));
+                efLanguageToLoad++;
+            }
+            mFh.loadEFTransparent(EF_ELP,
+                   obtainMessage(EVENT_GET_ELP_DONE));
+            efLanguageToLoad++;
+        }
+    }
+
+    private void onLanguageFileLoaded() {
+        efLanguageToLoad--;
+        log("onLanguageFileLoaded efLanguageToLoad is " + efLanguageToLoad);
+        if (efLanguageToLoad == 0) {
+            log("onLanguageFileLoaded all language file loaded");
+            if (mEfLi != null || mEfELP != null) {
+                setLanguageFromSIM();
+            } else {
+                log("onLanguageFileLoaded all language file are not exist!");
+            }
+        }
+    }
+
+    private void setLanguageFromSIM() {
+        log("setLanguageFromSIM ");
+        boolean bMatched = false;
+
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            bMatched = getMatchedLocaleByLI(mEfLi);
+        } else {
+            bMatched = getMatchedLocaleByLP(mEfLi);
+        }
+        if (!bMatched && mEfELP != null) {
+            bMatched = getMatchedLocaleByLI(mEfELP);
+        }
+        log("setLanguageFromSIM End");
+    }
+
+    private boolean getMatchedLocaleByLI(byte[] data) {
+        boolean ret = false;
+        if (data == null) {
+            return ret;
+        }
+        int lenOfLI = data.length;
+        String lang = null;
+        for (int i = 0; i + 2 <= lenOfLI; i += 2) {
+            lang = IccUtils.parseLanguageIndicator(data, i, 2);
+            log("USIM language in language indicator: i is " + i + " language is " + lang);
+            if (lang == null || lang.equals("")) {
+                log("USIM language in language indicator: i is " + i + " language is empty");
+                break;
+            }
+            lang = lang.toLowerCase();
+            ret = matchLangToLocale(lang);
+
+            if (ret) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    private boolean getMatchedLocaleByLP(byte[] data) {
+        boolean ret = false;
+        if (data == null) {
+            return ret;
+        }
+        int lenOfLP = data.length;
+        String lang = null;
+        for (int i = 0; i < lenOfLP; i++) {
+            int index = (int) mEfLi[0] & 0xff;
+            if (0x00 <= index && index <= 0x0f) {
+                lang = LANGUAGE_CODE_FOR_LP[index];
+            } else if (0x20 <= index && index <= 0x2f) {
+                lang = LANGUAGE_CODE_FOR_LP[index - 0x10];
+            }
+
+            log("SIM language in language preference: i is " + i + " language is " + lang);
+            if (lang == null || lang.equals("")) {
+                log("SIM language in language preference: i is " + i + " language is empty");
+                break;
+            }
+
+            ret = matchLangToLocale(lang);
+
+            if (ret) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    private boolean matchLangToLocale(String lang) {
+        boolean ret = false;
+        String[] locals = mContext.getAssets().getLocales();
+        int localsSize = locals.length;
+        for (int i = 0 ; i < localsSize; i++) {
+            String s = locals[i];
+            int len = s.length();
+            if (len == 5) {
+                String language = s.substring(0, 2);
+                log("Supported languages: the i" + i + " th is " + language);
+                if (lang.equals(language)) {
+                    ret = true;
+                    //MccTable.setSystemLocale(mContext, lang, s.substring(3, 5));
+                    log("Matched! lang: " + lang + ", country is " + s.substring(3, 5));
+                    break;
+                }
+            }
+        }
+        return ret;
+    }
+
+    /*
+      Detail description:
+      This feature provides a interface to get menu title string from EF_SUME
+    */
+    public String getMenuTitleFromEf() {
+        return mMenuTitleFromEf;
+    }
+
+    private void fetchCPHSOns() {
+        if (DBG) log("fetchCPHSOns()");
+        cphsOnsl = null;
+        cphsOnss = null;
+        mFh.loadEFTransparent(EF_SPN_CPHS,
+               obtainMessage(EVENT_GET_CPHSONS_DONE));
+        mRecordsToLoad++;
+        mFh.loadEFTransparent(
+               EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SHORT_CPHSONS_DONE));
+        mRecordsToLoad++;
+    }
+
+    // ALPS00302702 RAT balancing START
+    private void fetchRatBalancing() {
+        // TODO: wait for isSetLanguageBySIM ready
+        if (mTelephonyExt.isSetLanguageBySIM())
+            return;
+        log("support MTK_RAT_BALANCING");
+
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            log("start loading EF_RAT");
+            mFh.loadEFTransparent(EF_RAT, obtainMessage(EVENT_GET_RAT_DONE));
+            mRecordsToLoad++;
+        }
+        else if (mParentApp.getType() == AppType.APPTYPE_SIM) {
+            // broadcast & set no file
+            log("loading EF_RAT fail, because of SIM");
+            mEfRatLoaded = false;
+            mEfRat = null;
+            boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+        }
+        else {
+            log("loading EF_RAT fail, because of +EUSIM");
+        }
+    }
+
+    public int getEfRatBalancing() {
+        log("getEfRatBalancing: iccCardType = " + mParentApp.getType()
+                + ", mEfRatLoaded = " + mEfRatLoaded + ", mEfRat is null = " + (mEfRat == null));
+
+        if ((mParentApp.getType() == AppType.APPTYPE_USIM) && mEfRatLoaded && mEfRat == null) {
+            return EF_RAT_NOT_EXIST_IN_USIM;
+        }
+        return EF_RAT_FOR_OTHER_CASE;
+    }
+    // ALPS00302702 RAT balancing END
+
+    public boolean isHPlmn(String plmn) {
+        ServiceStateTracker sst = null;
+
+        sst = mPhone.getServiceStateTracker();
+
+        if (sst != null) {
+            return sst.isHPlmn(plmn);
+        } else {
+            if (DBG) log("can't get sst");
+            return false;
+        }
+    }
+
+    // ALPS00359372 for at&t testcase, mnc 2 should match 3 digits
+    private boolean isMatchingPlmnForEfOpl(String simPlmn, String bcchPlmn) {
+        if (simPlmn == null || simPlmn.equals("") || bcchPlmn == null || bcchPlmn.equals(""))
+            return false;
+
+        if (DBG) log("isMatchingPlmnForEfOpl(): simPlmn = " + simPlmn + ", bcchPlmn = " + bcchPlmn);
+
+        /*  3GPP TS 23.122 Annex A (normative): HPLMN Matching Criteria
+            For PCS1900 for North America, regulations mandate that a 3-digit MNC shall be used;
+            however during a transition period, a 2 digit MNC may be broadcast by the Network and,
+            in this case, the 3rd digit of the SIM is stored as 0 (this is the 0 suffix rule). */
+        int simPlmnLen = simPlmn.length();
+        int bcchPlmnLen = bcchPlmn.length();
+        if (simPlmnLen < 5 || bcchPlmnLen < 5)
+            return false;
+
+        int i = 0;
+        for (i = 0; i < 5; i++) {
+            if (simPlmn.charAt(i) == 'd')
+                continue;
+            if (simPlmn.charAt(i) != bcchPlmn.charAt(i))
+                return false;
+        }
+
+        if (simPlmnLen == 6 && bcchPlmnLen == 6) {
+            if (simPlmn.charAt(5) == 'd' || simPlmn.charAt(5) == bcchPlmn.charAt(5)) {
+                return true;
+            } else {
+                return false;
+            }
+        } else if (bcchPlmnLen == 6 && bcchPlmn.charAt(5) != '0' && bcchPlmn.charAt(5) != 'd') {
+            return false;
+        } else if (simPlmnLen == 6 && simPlmn.charAt(5) != '0' && simPlmn.charAt(5) != 'd') {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean isPlmnEqualsSimNumeric(String plmn) {
+        String mccmnc = getOperatorNumeric();
+        if (plmn == null) return false;
+
+        if (mccmnc == null || mccmnc.equals("")) {
+            log("isPlmnEqualsSimNumeric: getOperatorNumeric error: " + mccmnc);
+            return false;
+        }
+
+        if (plmn.equals(mccmnc)) {
+            return true;
+        } else {
+            if (plmn.length() == 5 && mccmnc.length() == 6
+                && plmn.equals(mccmnc.substring(0, 5))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+
+    // ALPS00267605 : PNN/OPL revision
+    public String getEonsIfExist(String plmn, int nLac, boolean bLongNameRequired) {
+        if (DBG) {
+            log("EONS getEonsIfExist: plmn is " + plmn + " nLac is " +
+                    nLac + " bLongNameRequired: " + bLongNameRequired);
+        }
+        if (plmn == null || mPnnNetworkNames == null || mPnnNetworkNames.size() == 0) {
+            return null;
+        }
+
+        int nPnnIndex = -1;
+        boolean isHPLMN = isPlmnEqualsSimNumeric(plmn);
+
+        if (mOperatorList == null) {
+            // case for EF_PNN only
+            if (isHPLMN) {
+                if (DBG) log("getEonsIfExist: Plmn is HPLMN, return PNN's first record");
+                nPnnIndex = 1;
+            } else {
+                if (DBG) log("getEonsIfExist: Plmn is not HPLMN and no mOperatorList, return null");
+                return null;
+            }
+        } else {
+            //search EF_OPL using plmn & nLac
+            for (int i = 0; i < mOperatorList.size(); i++) {
+                OplRecord oplRec = mOperatorList.get(i);
+
+                // ALPS00316057
+                //if((plmn.equals(oplRec.sPlmn) ||(!oplRec.sPlmn.equals("") &&
+                //      plmn.startsWith(oplRec.sPlmn))) &&
+                if (isMatchingPlmnForEfOpl(oplRec.sPlmn, plmn) &&
+                        ((oplRec.nMinLAC == 0 && oplRec.nMaxLAC == 0xfffe) ||
+                        (oplRec.nMinLAC <= nLac && oplRec.nMaxLAC >= nLac))) {
+                    if (DBG) log("getEonsIfExist: find it in EF_OPL");
+                    if (oplRec.nPnnIndex == 0) {
+                        if (DBG) log("getEonsIfExist: oplRec.nPnnIndex is 0, from other sources");
+                        return null;
+                    }
+                    nPnnIndex = oplRec.nPnnIndex;
+                    break;
+                }
+            }
+        }
+
+        //ALPS00312727, 11603, add check (mOperatorList.size() == 1
+        if (nPnnIndex == -1 && isHPLMN && (mOperatorList.size() == 1)) {
+            if (DBG) {
+                log("getEonsIfExist: not find it in EF_OPL, but Plmn is HPLMN," +
+                        " return PNN's first record");
+            }
+            nPnnIndex = 1;
+        }
+        else if (nPnnIndex > 1 && nPnnIndex > mPnnNetworkNames.size() && isHPLMN) {
+            if (DBG) {
+                log("getEonsIfExist: find it in EF_OPL, but index in EF_OPL > EF_PNN list" +
+                        " length & Plmn is HPLMN, return PNN's first record");
+            }
+            nPnnIndex = 1;
+        }
+        else if (nPnnIndex > 1 && nPnnIndex > mPnnNetworkNames.size() && !isHPLMN) {
+            if (DBG) {
+                log("getEonsIfExist: find it in EF_OPL, but index in EF_OPL > EF_PNN list" +
+                        " length & Plmn is not HPLMN, return PNN's first record");
+            }
+            nPnnIndex = -1;
+        }
+
+        String sEons = null;
+        if (nPnnIndex >= 1) {
+            OperatorName opName = mPnnNetworkNames.get(nPnnIndex - 1);
+            if (bLongNameRequired) {
+                if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                } else if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                }
+            } else if (!bLongNameRequired) {
+                if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                } else if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                }
+            }
+        }
+        if (DBG) log("getEonsIfExist: sEons is " + sEons);
+
+        return sEons;
+
+        /*int nPnnIndex = -1;
+        //check if the plmn is Hplmn, return the first record of pnn
+        if (isHPlmn(plmn)) {
+            nPnnIndex = 1;
+            if (DBG) log("EONS getEonsIfExist Plmn is hplmn");
+        } else {
+            //search the plmn from opl and if the LAC in the range of opl
+            for (int i = 0; i < mOperatorList.size(); i++) {
+                OplRecord oplRec = mOperatorList.get(i);
+                //check if the plmn equals with the plmn in the operator list
+                //or starts with the plmn in the operator list(which include wild char 'D')
+                if((plmn.equals(oplRec.sPlmn) ||(!oplRec.sPlmn.equals("") &&
+                        plmn.startsWith(oplRec.sPlmn))) &&
+                        ((oplRec.nMinLAC == 0 && oplRec.nMaxLAC == 0xfffe) ||
+                        (oplRec.nMinLAC <= nLac && oplRec.nMaxLAC >= nLac))) {
+                    nPnnIndex = oplRec.nPnnIndex;
+                    break;
+                }
+                if (DBG) log("EONS getEonsIfExist record number is " + i + " sPlmn: " +
+                        oplRec.sPlmn + " nMinLAC: " + oplRec.nMinLAC + " nMaxLAC: " +
+                        oplRec.nMaxLAC + " PnnIndex " + oplRec.nPnnIndex);
+            }
+            if (nPnnIndex == 0) {
+                // not HPLMN and the index is 0 indicates that the
+                // name is to be taken from other sources
+                return null;
+            }
+        }
+        if (DBG) log("EONS getEonsIfExist Index of pnn is  " + nPnnIndex);
+
+        String sEons = null;
+        if (nPnnIndex >= 1) {
+            OperatorName opName = mPnnNetworkNames.get(nPnnIndex - 1);
+            if (bLongNameRequired) {
+                if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                } else if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                }
+            } else if (!bLongNameRequired ) {
+                if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                } else if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                }
+            }
+        }
+        if (DBG) log("EONS getEonsIfExist sEons is " + sEons);
+        return sEons;*/
+    }
+
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     */
+    public String getEfGbabp() {
+        log("GBABP = " + mGbabp);
+        return mGbabp;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    public void setEfGbabp(String gbabp, Message onComplete) {
+        byte[] data = IccUtils.hexStringToBytes(gbabp);
+
+        log("setEfGbabp data = " + data);
+        mFh.updateEFTransparent(EF_GBABP, data, onComplete);
+    }
+
+    /**
+     * Returns the Public Service Identity of the SM-SC (PSISMSC) that was loaded from the USIM.
+     * @return PSISMSC or null if not present or not loaded
+     */
+    public byte[] getEfPsismsc() {
+        log("PSISMSC = " + mEfPsismsc);
+        return mEfPsismsc;
+    }
+
+    /**
+     * Returns the Short message parameter (SMSP) that was loaded from the USIM.
+     * @return PSISMSC or null if not present or not loaded
+     */
+    public byte[] getEfSmsp() {
+        log("mEfSmsp = " + mEfPsismsc);
+        return mEfSmsp;
+    }
+
+    /**
+     * Returns the MCC+MNC length that was loaded from the USIM.
+     * @return MCC+MNC length or 0 if not present or not loaded
+     */
+    public int getMncLength() {
+        log("mncLength = " + mMncLength);
+        return mMncLength;
+    }
+
+    private class RebootClickListener
+            implements DialogInterface.OnClickListener {
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            log("Unlock Phone onClick");
+            PowerManager pm = (PowerManager) mContext
+                    .getSystemService(Context.POWER_SERVICE);
+            pm.reboot("Unlock state changed");
+        }
+    }
+    public void broadcastPhbStateChangedIntent(boolean isReady) {
+        // M: for avoid repeate intent from GSMPhone and CDMAPhone
+        if (mPhone.getPhoneType() != PhoneConstants.PHONE_TYPE_GSM) {
+            log("broadcastPhbStateChangedIntent, Not active Phone.");
+            return;
+        }
+
+        log("broadcastPhbStateChangedIntent, mPhbReady " + mPhbReady);
+        if (isReady == true) {
+            int phoneId = mParentApp.getPhoneId();
+            mSubId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+
+            String strAllSimState = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+            String strCurSimState = "";
+
+            if ((strAllSimState != null) && (strAllSimState.length() > 0)) {
+                String values[] = strAllSimState.split(",");
+                if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
+                    strCurSimState = values[phoneId];
+                }
+            }
+
+            if (mSubId <= 0 || strCurSimState.equals("NOT_READY")) {
+                log("broadcastPhbStateChangedIntent, mSubId " + mSubId
+                    + ", sim state " + strAllSimState);
+                mPhbWaitSub = true;
+                return;
+            }
+        } else {
+            if (mSubId <= 0) {
+                log("broadcastPhbStateChangedIntent, isReady == false and mSubId <= 0");
+                return;
+            }
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_PHB_STATE_CHANGED);
+        intent.putExtra("ready", isReady);
+        intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mSubId);
+        if (DBG) log("Broadcasting intent ACTION_PHB_STATE_CHANGED " + isReady
+                    + " sub id " + mSubId + " phoneId " + mParentApp.getPhoneId());
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+
+        if (isReady == false) {
+            mSubId = -1;
+        }
+    }
+
+    public boolean isPhbReady() {
+        if (DBG) log("isPhbReady(): cached mPhbReady = " + (mPhbReady ? "true" : "false"));
+        String strPhbReady = "false";
+        String strAllSimState = "";
+        String strCurSimState = "";
+        boolean isSimLocked = false;
+        int phoneId = mParentApp.getPhoneId();
+
+        strPhbReady = SystemProperties.get(
+                SIMRECORD_PROPERTY_RIL_PHB_READY[mParentApp.getSlotId()], "false");
+        strAllSimState = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+
+        if ((strAllSimState != null) && (strAllSimState.length() > 0)) {
+            String values[] = strAllSimState.split(",");
+            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
+                strCurSimState = values[phoneId];
+            }
+        }
+
+        isSimLocked = (strCurSimState.equals("NETWORK_LOCKED") ||
+                       strCurSimState.equals("PIN_REQUIRED"));
+                        //In PUK_REQUIRED state, phb can be accessed.
+
+        if (DBG) log("isPhbReady(): mPhbReady = " + (mPhbReady ? "true" : "false") +
+                     ", strCurSimState = " + strCurSimState);
+        return (strPhbReady.equals("true") && !isSimLocked);
+    }
+
+    public void setPhbReady(boolean isReady) {
+        if (DBG) log("setPhbReady(): isReady = " + (isReady ? "true" : "false"));
+        if (mPhbReady != isReady) {
+            String strPhbReady = isReady ? "true" : "false";
+            mPhbReady = isReady;
+            SystemProperties.set(
+                    SIMRECORD_PROPERTY_RIL_PHB_READY[mParentApp.getSlotId()], strPhbReady);
+            broadcastPhbStateChangedIntent(mPhbReady);
+        }
+    }
+    // add for alps01947090
+    public boolean isRadioAvailable() {
+        if (mCi != null) {
+          return mCi.getRadioState().isAvailable();
+        }
+        return false;
+    }
+
+    /** M: Bug Fix for ALPS02189616. */
+    // add new code for svlte romaing case.
+
+    /**
+     * Inner private class for revice broad cast ACTION_RADIO_TECHNOLOGY_CHANGED.
+     */
+    private class RadioTechnologyChangedReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+             if (action.equals(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED)) {
+                 // listener radio technology changed. If it not own object phone
+                 // broadcast false.
+                 // if it own object, send delay message to broadcast PHB_CHANGE
+                 // event. APP will receive PHB_CHANGE broadcast and init phonebook.
+                 int phoneid = intent.getIntExtra(PhoneConstants.PHONE_KEY, -1);
+                 log("[ACTION_RADIO_TECHNOLOGY_CHANGED] phoneid : " + phoneid);
+                 if (null != mParentApp && mParentApp.getPhoneId() == phoneid) {
+                     String cdmaPhoneName = "CDMA";
+                     int delayedTime = 500;
+                     String activePhoneName = intent.getStringExtra(PhoneConstants.PHONE_NAME_KEY);
+                     int subid = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1);
+                     log("[ACTION_RADIO_TECHNOLOGY_CHANGED] activePhoneName : " + activePhoneName
+                             + " | subid : " + subid);
+                     if (!cdmaPhoneName.equals(activePhoneName)) {
+                         sendMessageDelayed(obtainMessage(EVENT_DELAYED_SEND_PHB_CHANGE),
+                                 delayedTime);
+                         mAdnCache.reset();
+                     }
+                 }
+             }
+        }
+    }
+    // PHB Refactoring ++++
+    @Override
+    protected int getChildPhoneId() {
+        int phoneId = mParentApp.getPhoneId();
+        log("[getChildPhoneId] phoneId = " + phoneId);
+        return phoneId;
+    }
+
+    @Override
+    protected void updatePHBStatus(int status, boolean isSimLocked) {
+        log("[updatePHBStatus] status : " + status + " | isSimLocked : " + isSimLocked
+                + " | mPhbReady : " + mPhbReady);
+
+        // M: PHB Revise
+        if (status == GSM_PHB_READY) {
+            if (false == isSimLocked) {
+                if (mPhbReady == false) {
+                    mPhbReady = true;
+                    broadcastPhbStateChangedIntent(mPhbReady);
+                }
+            } else {
+                log("phb ready but sim is not ready.");
+            }
+        } else if (status == GSM_PHB_NOT_READY) {
+            if (mPhbReady == true) {
+                mAdnCache.reset();
+                mPhbReady = false;
+                broadcastPhbStateChangedIntent(mPhbReady);
+            }
+        }
+    }
+    // PHB Refactoring ----
+    // MTK-END
+
+    // MTK-START
+    private String convertNumberIfContainsPrefix(String dialNumber) {
+        String r = dialNumber;
+        if (dialNumber != null &&
+            (dialNumber.startsWith("tel:") ||
+             dialNumber.startsWith("sip:") ||
+             dialNumber.startsWith("sips:"))) {
+            r = dialNumber.substring(dialNumber.indexOf(":") + 1);
+            Rlog.d(LOG_TAG, "convertNumberIfContainsPrefix: dialNumber = " + dialNumber);
+        }
+        return r;
+    }
+    // MTK-END
+}
Index: vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaPhone.java
===================================================================
--- vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaPhone.java	(revision 0)
+++ vendor/branch/5058A_Etecsa_Cuba/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaPhone.java	(revision 12965)
@@ -0,0 +1,7328 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.app.ActivityManagerNative;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.database.SQLException;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.PersistableBundle;
+import android.os.PowerManager;
+import android.os.Registrant;
+import android.os.RegistrantList;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.preference.PreferenceManager;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.telecom.VideoProfile;
+import android.telephony.CarrierConfigManager;
+import android.telephony.CellLocation;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+
+import android.telephony.cdma.CdmaCellLocation;
+import android.text.TextUtils;
+import android.telephony.Rlog;
+import android.util.Log;
+
+import com.android.ims.ImsManager;
+import static com.android.internal.telephony.CommandsInterface.CF_ACTION_DISABLE;
+import static com.android.internal.telephony.CommandsInterface.CF_ACTION_ENABLE;
+import static com.android.internal.telephony.CommandsInterface.CF_ACTION_ERASURE;
+import static com.android.internal.telephony.CommandsInterface.CF_ACTION_REGISTRATION;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_ALL;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_ALL_CONDITIONAL;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_NO_REPLY;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_NOT_REACHABLE;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_BUSY;
+import static com.android.internal.telephony.CommandsInterface.CF_REASON_UNCONDITIONAL;
+import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_VOICE;
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE;
+import static com.android.internal.telephony.TelephonyProperties.TERMINAL_BASED_CALL_WAITING_DISABLED;
+import static com.android.internal.telephony.TelephonyProperties.TERMINAL_BASED_CALL_WAITING_ENABLED_OFF;
+import static com.android.internal.telephony.TelephonyProperties.TERMINAL_BASED_CALL_WAITING_ENABLED_ON;
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_UT_CFU_NOTIFICATION_MODE;
+import static com.android.internal.telephony.TelephonyProperties.UT_CFU_NOTIFICATION_MODE_DISABLED;
+import static com.android.internal.telephony.TelephonyProperties.UT_CFU_NOTIFICATION_MODE_ON;
+import static com.android.internal.telephony.TelephonyProperties.UT_CFU_NOTIFICATION_MODE_OFF;
+
+import com.android.ims.ImsException;
+import com.android.ims.ImsReasonInfo;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.cdma.CdmaMmiCode;
+import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
+import com.android.internal.telephony.cdma.EriManager;
+import com.android.internal.telephony.dataconnection.DcTracker;
+import com.android.internal.telephony.gsm.GsmMmiCode;
+/// M: CC: Proprietary CRSS handling
+import com.android.internal.telephony.gsm.SuppCrssNotification;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.imsphone.ImsPhone;
+import com.android.internal.telephony.imsphone.ImsPhoneMmiCode;
+import com.android.internal.telephony.test.SimulatedRadioControl;
+import com.android.internal.telephony.TelephonyDevController;
+
+// MTK-START
+import com.android.internal.telephony.uicc.CsimFileHandler;
+// MTK-END
+import com.android.internal.telephony.uicc.IccCardProxy;
+import com.android.internal.telephony.uicc.IccException;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccVmNotSupportedException;
+import com.android.internal.telephony.uicc.RuimRecords;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.UiccController;
+// MTK-START
+import com.android.internal.telephony.uicc.IccFileHandler;
+// MTK-END
+import com.android.internal.telephony.uicc.IsimRecords;
+import com.android.internal.telephony.uicc.IsimUiccRecords;
+
+/// M: SS Ut part @{
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.telephony.ISupplementaryServiceExt;
+import com.mediatek.internal.telephony.OperatorUtils;
+import com.mediatek.internal.telephony.OperatorUtils.OPID;
+/// @}
+
+// MTK-START
+import com.mediatek.internal.telephony.uicc.CsimPhbStorageInfo;
+// MTK-END
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * {@hide}
+ */
+public class GsmCdmaPhone extends Phone {
+    // NOTE that LOG_TAG here is "GsmCdma", which means that log messages
+    // from this file will go into the radio log rather than the main
+    // log.  (Use "adb logcat -b radio" to see them.)
+    public static final String LOG_TAG = "GsmCdmaPhone";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = false; /* STOPSHIP if true */
+    static private final boolean SDBG = SystemProperties.get("ro.build.type").equals("user")
+            ? false : true;
+
+    //GSM
+    // Key used to read/write voice mail number
+    private static final String VM_NUMBER = "vm_number_key";
+    // Key used to read/write the SIM IMSI used for storing the voice mail
+    private static final String VM_SIM_IMSI = "vm_sim_imsi_key";
+    /** List of Registrants to receive Supplementary Service Notifications. */
+    private RegistrantList mSsnRegistrants = new RegistrantList();
+
+    //CDMA
+    // Default Emergency Callback Mode exit timer
+    private static final int DEFAULT_ECM_EXIT_TIMER_VALUE = 300000;
+    private static final String VM_NUMBER_CDMA = "vm_number_key_cdma";
+    public static final int RESTART_ECM_TIMER = 0; // restart Ecm timer
+    public static final int CANCEL_ECM_TIMER = 1; // cancel Ecm timer
+    private CdmaSubscriptionSourceManager mCdmaSSM;
+    public int mCdmaSubscriptionSource = CdmaSubscriptionSourceManager.SUBSCRIPTION_SOURCE_UNKNOWN;
+    public EriManager mEriManager;
+    private PowerManager.WakeLock mWakeLock;
+    // mEriFileLoadedRegistrants are informed after the ERI text has been loaded
+    private final RegistrantList mEriFileLoadedRegistrants = new RegistrantList();
+    // mEcmExitRespRegistrant is informed after the phone has been exited
+    //the emergency callback mode
+    //keep track of if phone is in emergency callback mode
+    private boolean mIsPhoneInEcmState;
+    private Registrant mEcmExitRespRegistrant;
+    private String mEsn;
+    private String mMeid;
+    // string to define how the carrier specifies its own ota sp number
+    private String mCarrierOtaSpNumSchema;
+
+    /* M: SS for 93
+     * Define the mapping between CME error and
+     * OEM ERROR CODE in CommandException
+     *
+     * CME_403_FORBIDDEN                CommandException.Error.OEM_ERROR_2
+     * CME_NETWORK_TIMEOUT              CommandException.Error.OEM_ERROR_3
+     * CME_404_NOT_FOUND                CommandException.Error.OEM_ERROR_4
+     * CME_409_CONFLICT                 CommandException.Error.OEM_ERROR_5
+     * CME_412_PRECONDITION_FAILED      CommandException.Error.OEM_ERROR_6
+     * CME_832_TERMINAL_BASE_SOLUTION   CommandException.Error.OEM_ERROR_7
+     */
+
+    /* M: SS part */
+    /* A flag to provide a kind of retry mechansim for CFU Query */
+    private boolean needQueryCfu = false;
+
+    /* For solving ALPS01023811
+       To determine if CFU query is for power-on query.
+    */
+    private int mCfuQueryRetryCount = 0;
+    private static final String CFU_QUERY_PROPERTY_NAME = "gsm.poweron.cfu.query.";
+    private static final int cfuQueryWaitTime = 1000;
+    private static final int CFU_QUERY_MAX_COUNT = 60;
+
+    private static final String CFU_QUERY_ICCID_PROP = "persist.radio.cfu.iccid.";
+    private static final String CFU_QUERY_SIM_CHANGED_PROP = "persist.radio.cfu.change.";
+    public static final String IMS_DEREG_PROP = "gsm.radio.ss.imsdereg";
+    public static final String SS_CW_TBCW_EVER_ENABLE_PROP = "gsm.radio.ss.tbcweverenable";
+
+    private static final String SS_SERVICE_CLASS_PROP = "gsm.radio.ss.sc";
+    static private final boolean mIsMimsSupported =
+            SystemProperties.getInt("ro.mtk_multiple_ims_support", 1) > 1;
+
+    public static final String IMS_DEREG_ON = "1";
+    public static final String IMS_DEREG_OFF = "0";
+    public static final int MESSAGE_SET_CF = 1;
+    /* M: SS part end */
+
+    /// M: SS Ut part @{
+    SSRequestDecisionMaker mSSReqDecisionMaker;
+    ISupplementaryServiceExt mSupplementaryServiceExt;
+    public static final int TBCW_UNKNOWN = 0;
+    public static final int TBCW_NOT_OPTBCW = 1;
+    public static final int TBCW_OPTBCW_VOLTE_USER = 2;
+    public static final int TBCW_OPTBCW_NOT_VOLTE_USER = 3;
+    public static final int TBCW_OPTBCW_WITH_CS = 4;
+    private static final String[] PROPERTY_RIL_FULL_UICC_TYPE  = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+    private int mTbcwMode = TBCW_UNKNOWN;
+
+    public boolean mIsNetworkInitiatedUssr = false;
+    private boolean mSSInit = true;    // This paramater is only for supplementary service
+                                       // parameter initial when sim changed.
+    /// @}
+
+    /// M: CDMA LTE mode system property
+    private static final String PROP_MTK_CDMA_LTE_MODE = "ro.boot.opt_c2k_lte_mode";
+    private static final boolean MTK_SVLTE_SUPPORT = (SystemProperties.getInt(
+            PROP_MTK_CDMA_LTE_MODE, 0) == 1);
+
+    // A runnable which is used to automatically exit from Ecm after a period of time.
+    private Runnable mExitEcmRunnable = new Runnable() {
+        @Override
+        public void run() {
+            exitEmergencyCallbackMode();
+        }
+    };
+    public static final String PROPERTY_CDMA_HOME_OPERATOR_NUMERIC =
+            "ro.cdma.home.operator.numeric";
+
+    //CDMALTE
+    /** PHONE_TYPE_CDMA_LTE in addition to RuimRecords needs access to SIMRecords and
+     * IsimUiccRecords
+     */
+    private SIMRecords mSimRecords;
+
+    //Common
+    // Instance Variables
+    private IsimUiccRecords mIsimUiccRecords;
+    public GsmCdmaCallTracker mCT;
+    public ServiceStateTracker mSST;
+    private ArrayList <MmiCode> mPendingMMIs = new ArrayList<MmiCode>();
+    private IccPhoneBookInterfaceManager mIccPhoneBookIntManager;
+
+    private int mPrecisePhoneType;
+
+    // mEcmTimerResetRegistrants are informed after Ecm timer is canceled or re-started
+    private final RegistrantList mEcmTimerResetRegistrants = new RegistrantList();
+
+    private String mImei;
+    private String mImeiSv;
+    private String mVmNumber;
+
+    /**
+     * mDeviceIdAbnormal=0, Valid IMEI
+     * mDeviceIdAbnormal=1, IMEI is null or not valid format
+     * mDeviceIdAbnormal=2, Phone1/Phone2 have same IMEI
+     */
+    private int mDeviceIdAbnormal = 0;
+
+    // Create Cfu (Call forward unconditional) so that dialing number &
+    // mOnComplete (Message object passed by client) can be packed &
+    // given as a single Cfu object as user data to RIL.
+    private static class Cfu {
+        final String mSetCfNumber;
+        final Message mOnComplete;
+
+        Cfu(String cfNumber, Message onComplete) {
+            mSetCfNumber = cfNumber;
+            mOnComplete = onComplete;
+        }
+    }
+
+    private IccSmsInterfaceManager mIccSmsInterfaceManager;
+    private IccCardProxy mIccCardProxy;
+
+    private boolean mResetModemOnRadioTechnologyChange = false;
+
+    private int mRilVersion;
+    private boolean mBroadcastEmergencyCallStateChanges = false;
+
+
+    /// M: CC: Proprietary CRSS handling @{
+    RegistrantList mCallRelatedSuppSvcRegistrants = new RegistrantList();
+    private AsyncResult mCachedSsn = null;
+    private AsyncResult mCachedCrssn = null;
+    /// @}
+
+    // MTK-START
+    private int mNewVoiceTech = -1;
+    // MTK-END
+
+    /// M: CC: Vzw/CTVolte ECC @{
+    TelephonyDevController mTelDevController = TelephonyDevController.getInstance();
+    private boolean hasC2kOverImsModem() {
+        if (mTelDevController != null && mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasC2kOverImsModem() == true) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+
+    // Constructors
+
+    public GsmCdmaPhone(Context context, CommandsInterface ci, PhoneNotifier notifier, int phoneId,
+                        int precisePhoneType, TelephonyComponentFactory telephonyComponentFactory) {
+        this(context, ci, notifier, false, phoneId, precisePhoneType, telephonyComponentFactory);
+    }
+
+    public GsmCdmaPhone(Context context, CommandsInterface ci, PhoneNotifier notifier,
+                        boolean unitTestMode, int phoneId, int precisePhoneType,
+                        TelephonyComponentFactory telephonyComponentFactory) {
+        super(precisePhoneType == PhoneConstants.PHONE_TYPE_GSM ? "GSM" : "CDMA",
+                notifier, context, ci, unitTestMode, phoneId, telephonyComponentFactory);
+
+        // phone type needs to be set before other initialization as other objects rely on it
+        mPrecisePhoneType = precisePhoneType;
+        initOnce(ci);
+        initRatSpecific(precisePhoneType);
+        mSST = mTelephonyComponentFactory.makeServiceStateTracker(this, this.mCi);
+        // DcTracker uses SST so needs to be created after it is instantiated
+        mDcTracker = mTelephonyComponentFactory.makeDcTracker(this);
+        mSST.registerForNetworkAttached(this, EVENT_REGISTERED_TO_NETWORK, null);
+        logd("GsmCdmaPhone: constructor: sub = " + mPhoneId);
+    }
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+
+            if (intent.getAction().equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
+                sendMessage(obtainMessage(EVENT_CARRIER_CONFIG_CHANGED));
+            }
+            /* M: SS part */
+            else if (TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED.equals(action)) {
+                handleSubInfoChange();
+            } else if (action.equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+                int reg = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY , -1);
+                int slotId = intent.getIntExtra(ImsManager.EXTRA_PHONE_ID, -1);
+                Rlog.d(LOG_TAG, "onReceive ACTION_IMS_STATE_CHANGED: reg=" + reg
+                        + ", SimID=" + slotId);
+                if (slotId == getPhoneId() && (reg == ServiceState.STATE_IN_SERVICE)) {
+                    if (isOpTbcwWithCS(getPhoneId())) {
+                        setTbcwMode(TBCW_OPTBCW_WITH_CS);
+                        setTbcwToEnabledOnIfDisabled();
+                    } else {
+                        // TBCW for VoLTE user
+                        setTbcwMode(TBCW_OPTBCW_VOLTE_USER);
+                        setTbcwToEnabledOnIfDisabled();
+                    }
+
+                    Rlog.d(LOG_TAG, "set needQueryCfu true, due to ACTION_IMS_STATE_CHANGED" +
+                            ", phoneId = " + getPhoneId());
+                    needQueryCfu = true;
+                    sendMessage(obtainMessage(EVENT_QUERY_CFU));
+                }
+
+                /// M: Service State should be notified when ims state has changed @{
+                if (mSST == null ||
+                        (mSST.mSS.getState() != ServiceState.STATE_IN_SERVICE &&
+                        mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+                    notifyServiceStateChanged(mSST.mSS);
+                }
+                /// @}
+            } else if (action.equals(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE)) {
+                Rlog.d(LOG_TAG, "set needQueryCfu true, due to ACTION_SET_RADIO_CAPABILITY_DONE");
+                needQueryCfu = true;
+            } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                boolean bAirplaneModeOn = intent.getBooleanExtra("state", false);
+
+                Rlog.d(LOG_TAG, "ACTION_AIRPLANE_MODE_CHANGED, bAirplaneModeOn = " +
+                       bAirplaneModeOn);
+                if (bAirplaneModeOn) {
+                    Rlog.d(LOG_TAG, "Set needQueryCfu true, due to ACTION_AIRPLANE_MODE_CHANGED");
+                    needQueryCfu = true;
+                    /// M: add for CU VOLTE SS:AIRPLANE_MODE restore to PS domain @{
+                    if (isOp(OPID.OP02)) {
+                        Rlog.d(LOG_TAG, "isOp02IccCard, setCsFallbackStatus 0");
+                        setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+                    }
+                    /// @}
+                }
+            }
+            /* M: SS part end */
+        }
+    };
+
+    private void initOnce(CommandsInterface ci) {
+        if (ci instanceof SimulatedRadioControl) {
+            mSimulatedRadioControl = (SimulatedRadioControl) ci;
+        }
+
+        mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
+        mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
+        PowerManager pm
+                = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+        mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
+        mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
+
+        /// M: SS Ut part @{
+        mSSReqDecisionMaker = new SSRequestDecisionMaker(mContext, this);
+
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            try {
+                mSupplementaryServiceExt = MPlugin.createInstance(
+                        ISupplementaryServiceExt.class.getName(), mContext);
+                if (mSupplementaryServiceExt != null) {
+                    mSupplementaryServiceExt.registerReceiver(mContext, mPhoneId);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+        /// @}
+
+        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
+        mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
+        mCi.registerForOn(this, EVENT_RADIO_ON, null);
+        mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
+
+        //GSM
+        mCi.setOnUSSD(this, EVENT_USSD, null);
+        mCi.setOnSs(this, EVENT_SS, null);
+
+        /// M: CC: Proprietary CRSS handling
+        mCi.setOnCallRelatedSuppSvc(this, EVENT_CRSS_IND, null);
+
+        //CDMA
+        mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext,
+                mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
+        mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext,
+                EriManager.ERI_FROM_XML);
+        mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
+        mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE,
+                null);
+        // get the string that specifies the carrier OTA Sp number
+        mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(
+                getPhoneId(), "");
+
+        mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(
+                TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
+
+        mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
+        mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
+        mTelDevController.registerRIL(mCi);
+        // mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(
+        //         CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        filter.addAction(ImsManager.ACTION_IMS_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE);
+        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+
+    }
+
+    private void initRatSpecific(int precisePhoneType) {
+        mPendingMMIs.clear();
+        // mIccPhoneBookIntManager.updateIccRecords(null); // ALPS02819064
+        //todo: maybe not needed?? should the count also be updated on sim_state_absent?
+        mVmCount = 0;
+        mEsn = null;
+        mMeid = null;
+
+        mPrecisePhoneType = precisePhoneType;
+
+        TelephonyManager tm = TelephonyManager.from(mContext);
+        if (isPhoneTypeGsm()) {
+            mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
+            tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
+            mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
+        } else {
+            mCdmaSubscriptionSource = CdmaSubscriptionSourceManager.SUBSCRIPTION_SOURCE_UNKNOWN;
+            // This is needed to handle phone process crashes
+            /// M: Get the property by phoneId @{
+            //String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE, "false");
+            String inEcm = TelephonyManager.getTelephonyProperty(
+                    mPhoneId, TelephonyProperties.PROPERTY_INECM_MODE, "false");
+            /// @}
+            mIsPhoneInEcmState = inEcm.equals("true");
+            if (mIsPhoneInEcmState) {
+                // Send a message which will invoke handleExitEmergencyCallbackMode
+                mCi.exitEmergencyCallbackMode(
+                        obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
+            }
+
+            mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
+            tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
+            mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
+            // Sets operator properties by retrieving from build-time system property
+            String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
+            String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
+            logd("init: operatorAlpha='" + operatorAlpha
+                    + "' operatorNumeric='" + operatorNumeric + "'");
+            if (mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP) ==
+                    null || isPhoneTypeCdmaLte()) {
+                if (!TextUtils.isEmpty(operatorAlpha)) {
+                    logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
+                    tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
+                }
+                if (!TextUtils.isEmpty(operatorNumeric)) {
+                    logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric +
+                            "'");
+                    logd("update icc_operator_numeric=" + operatorNumeric);
+                    tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
+
+                    SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
+                    // Sets iso country property by retrieving from build-time system property
+                    setIsoCountryProperty(operatorNumeric);
+                    // Updates MCC MNC device configuration information
+                    logd("update mccmnc=" + operatorNumeric);
+                    MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
+                }
+            }
+
+            // Sets current entry in the telephony carrier table
+            updateCurrentCarrierInProvider(operatorNumeric);
+        }
+    }
+
+    //CDMA
+    /**
+     * Sets PROPERTY_ICC_OPERATOR_ISO_COUNTRY property
+     *
+     */
+    private void setIsoCountryProperty(String operatorNumeric) {
+        TelephonyManager tm = TelephonyManager.from(mContext);
+        if (TextUtils.isEmpty(operatorNumeric)) {
+            logd("setIsoCountryProperty: clear 'gsm.sim.operator.iso-country'");
+            tm.setSimCountryIsoForPhone(mPhoneId, "");
+        } else {
+            String iso = "";
+            try {
+                iso = MccTable.countryCodeForMcc(Integer.parseInt(
+                        operatorNumeric.substring(0,3)));
+            } catch (NumberFormatException ex) {
+                Rlog.e(LOG_TAG, "setIsoCountryProperty: countryCodeForMcc error", ex);
+            } catch (StringIndexOutOfBoundsException ex) {
+                Rlog.e(LOG_TAG, "setIsoCountryProperty: countryCodeForMcc error", ex);
+            }
+
+            logd("setIsoCountryProperty: set 'gsm.sim.operator.iso-country' to iso=" + iso);
+            tm.setSimCountryIsoForPhone(mPhoneId, iso);
+        }
+    }
+
+    public boolean isPhoneTypeGsm() {
+        return mPrecisePhoneType == PhoneConstants.PHONE_TYPE_GSM;
+    }
+
+    public boolean isPhoneTypeCdma() {
+        return mPrecisePhoneType == PhoneConstants.PHONE_TYPE_CDMA;
+    }
+
+    public boolean isPhoneTypeCdmaLte() {
+        return mPrecisePhoneType == PhoneConstants.PHONE_TYPE_CDMA_LTE;
+    }
+
+    private void switchPhoneType(int precisePhoneType) {
+        removeCallbacks(mExitEcmRunnable);
+
+        initRatSpecific(precisePhoneType);
+
+        mSST.updatePhoneType();
+        setPhoneName(precisePhoneType == PhoneConstants.PHONE_TYPE_GSM ? "GSM" : "CDMA");
+        onUpdateIccAvailability();
+        mCT.updatePhoneType();
+
+        CommandsInterface.RadioState radioState = mCi.getRadioState();
+        if (radioState.isAvailable()) {
+            handleRadioAvailable();
+            if (radioState.isOn()) {
+                handleRadioOn();
+            }
+        }
+        if (!radioState.isAvailable() || !radioState.isOn()) {
+            handleRadioOffOrNotAvailable();
+        }
+    }
+
+    @Override
+    protected void finalize() {
+        if(DBG) logd("GsmCdmaPhone finalized");
+        if (mWakeLock.isHeld()) {
+            Rlog.e(LOG_TAG, "UNEXPECTED; mWakeLock is held when finalizing.");
+            mWakeLock.release();
+        }
+    }
+
+    @Override
+    public ServiceState getServiceState() {
+        /// M: For IMS @{
+        /// IMS service state is reliable only when data registration state is in service
+        // if (mSST == null || mSST.mSS.getState() != ServiceState.STATE_IN_SERVICE) {
+        if (mSST == null
+                || (mSST.mSS.getState() != ServiceState.STATE_IN_SERVICE && mSST.mSS
+                        .getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+            /// ALPS02500449, Fix timing issue.
+            /// Keep reference for mImsPhone to avoid null pointer exception
+            /// if mImsPhone sets to null by other thread. @{
+            Phone phone = mImsPhone;
+            if (phone != null) {
+                return ServiceState.mergeServiceStates(
+                        (mSST == null) ? new ServiceState() : mSST.mSS,
+                        phone.getServiceState());
+            }
+            /// @}
+        }
+
+        if (mSST != null) {
+            return mSST.mSS;
+        } else {
+            // avoid potential NPE in EmergencyCallHelper during Phone switch
+            return new ServiceState();
+        }
+    }
+
+    @Override
+    public CellLocation getCellLocation() {
+        if (isPhoneTypeGsm()) {
+            return mSST.getCellLocation();
+        } else {
+            CdmaCellLocation loc = (CdmaCellLocation)mSST.mCellLoc;
+
+            int mode = Settings.Secure.getInt(getContext().getContentResolver(),
+                    Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
+            if (mode == Settings.Secure.LOCATION_MODE_OFF) {
+                // clear lat/long values for location privacy
+                CdmaCellLocation privateLoc = new CdmaCellLocation();
+                privateLoc.setCellLocationData(loc.getBaseStationId(),
+                        CdmaCellLocation.INVALID_LAT_LONG,
+                        CdmaCellLocation.INVALID_LAT_LONG,
+                        loc.getSystemId(), loc.getNetworkId());
+                loc = privateLoc;
+            }
+            return loc;
+        }
+    }
+
+    @Override
+    public PhoneConstants.State getState() {
+        if (mImsPhone != null) {
+            PhoneConstants.State imsState = mImsPhone.getState();
+            if (imsState != PhoneConstants.State.IDLE) {
+                return imsState;
+            }
+        }
+
+        return mCT.mState;
+    }
+
+    @Override
+    public int getPhoneType() {
+        if (mPrecisePhoneType == PhoneConstants.PHONE_TYPE_GSM) {
+            return PhoneConstants.PHONE_TYPE_GSM;
+        } else {
+            return PhoneConstants.PHONE_TYPE_CDMA;
+        }
+    }
+
+    @Override
+    public ServiceStateTracker getServiceStateTracker() {
+        return mSST;
+    }
+
+    @Override
+    public CallTracker getCallTracker() {
+        return mCT;
+    }
+
+    @Override
+    public void updateVoiceMail() {
+        if (isPhoneTypeGsm()) {
+            int countVoiceMessages = 0;
+            IccRecords r = mIccRecords.get();
+            if (r != null) {
+                // get voice mail count from SIM
+                countVoiceMessages = r.getVoiceMessageCount();
+            }
+            int countVoiceMessagesStored = getStoredVoiceMessageCount();
+            if (countVoiceMessages == -1 && countVoiceMessagesStored != 0) {
+                countVoiceMessages = countVoiceMessagesStored;
+            }
+            logd("updateVoiceMail countVoiceMessages = " + countVoiceMessages
+                    + " subId " + getSubId());
+            setVoiceMessageCount(countVoiceMessages);
+        } else {
+            setVoiceMessageCount(getStoredVoiceMessageCount());
+        }
+    }
+
+    @Override
+    public List<? extends MmiCode>
+    getPendingMmiCodes() {
+        /// M: @{
+        Rlog.d(LOG_TAG, "getPendingMmiCodes");
+        dumpPendingMmi();
+
+        ImsPhone imsPhone = (ImsPhone)mImsPhone;
+        ArrayList<MmiCode> imsphonePendingMMIs = new ArrayList<MmiCode>();
+        if (imsPhone != null
+                && imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) {
+            List<ImsPhoneMmiCode> imsMMIs
+                    = (List<ImsPhoneMmiCode>) imsPhone.getPendingMmiCodes();
+            for(ImsPhoneMmiCode mmi : imsMMIs) {
+                imsphonePendingMMIs.add((MmiCode) mmi);
+            }
+        }
+        ArrayList<MmiCode> allPendingMMIs = new ArrayList<MmiCode>(mPendingMMIs);
+        allPendingMMIs.addAll(imsphonePendingMMIs);
+        Rlog.d(LOG_TAG, "allPendingMMIs.size() = " + allPendingMMIs.size());
+
+        for (int i=0, s=allPendingMMIs.size(); i<s; i++) {
+            Rlog.d(LOG_TAG, "dump allPendingMMIs: " + allPendingMMIs.get(i));
+        }
+
+        return allPendingMMIs;
+        // return mPendingMMIs;
+        /// @}
+    }
+
+    @Override
+    public PhoneConstants.DataState getDataConnectionState(String apnType) {
+        PhoneConstants.DataState ret = PhoneConstants.DataState.DISCONNECTED;
+
+        if (mSST == null) {
+            // Radio Technology Change is ongoning, dispose() and removeReferences() have
+            // already been called
+
+            ret = PhoneConstants.DataState.DISCONNECTED;
+        } else if (mSST.getCurrentDataConnectionState() != ServiceState.STATE_IN_SERVICE
+                && (isPhoneTypeCdma() ||
+                (isPhoneTypeGsm() && !apnType.equals(PhoneConstants.APN_TYPE_EMERGENCY)))) {
+            // If we're out of service, open TCP sockets may still work
+            // but no data will flow
+
+            // Emergency APN is available even in Out Of Service
+            // Pass the actual State of EPDN
+
+            logd("getDataConnectionState: dataConnectionState is not in service");
+            if (SystemProperties.get("persist.mtk_ims_support").equals("1") &&
+                    apnType.equals(PhoneConstants.APN_TYPE_IMS)) {
+                switch (mDcTracker.getState(apnType)) {
+                case RETRYING:
+                   logd("getDataConnectionState: apnType: " + apnType
+                           + " is in retrying state!! return connecting state");
+                   ret = PhoneConstants.DataState.CONNECTING;
+                   break;
+                case CONNECTED:
+                   ret = PhoneConstants.DataState.CONNECTED;
+                   break;
+                case CONNECTING:
+                case SCANNING:
+                   ret = PhoneConstants.DataState.CONNECTING;
+                   break;
+                case FAILED:
+                case IDLE:
+                default:
+                   ret = PhoneConstants.DataState.DISCONNECTED;
+                   break;
+                };
+            } else {
+               ret = PhoneConstants.DataState.DISCONNECTED;
+            }
+        } else { /* mSST.gprsState == ServiceState.STATE_IN_SERVICE */
+            switch (mDcTracker.getState(apnType)) {
+                case RETRYING:
+                case FAILED:
+                case IDLE:
+                    ret = PhoneConstants.DataState.DISCONNECTED;
+                break;
+
+                case CONNECTED:
+                case DISCONNECTING:
+                    if ( mCT.mState != PhoneConstants.State.IDLE
+                            && !mSST.isConcurrentVoiceAndDataAllowed()) {
+                        ret = PhoneConstants.DataState.SUSPENDED;
+                    } else {
+                        ret = PhoneConstants.DataState.CONNECTED;
+                    }
+
+                    // M: check peer phone is in call also
+                    int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+                    if (TelephonyManager.getDefault().isMultiSimEnabled()) {
+                        for (int i = 0; i < phoneCount; i++) {
+                            Phone pf = PhoneFactory.getPhone(i);
+
+                            if (pf != null && i != getPhoneId() &&
+                                    pf.getState() != PhoneConstants.State.IDLE) {
+                                logd("getDataConnectionState: Phone[" + getPhoneId() + "] Phone"
+                                        + i + " is in call.");
+                                if (MTK_SVLTE_SUPPORT) {
+                                    int phoneType = pf.getPhoneType();
+                                    int rilRat = getServiceState().getRilDataRadioTechnology();
+                                    logd("getDataConnectionState: SVLTE, phoneType: " + phoneType
+                                            + " rilRat: " + rilRat);
+
+                                    /// M: Data setup on GSM and Peer phone calling also on GSM.
+                                    ///    Need to suspend for this case although these codes may
+                                    ///    never be executed. (Ex: CT 4G + CMCC, call on CMCC and
+                                    ///    then enable data on CT SIM.)
+                                    if (phoneType == PhoneConstants.PHONE_TYPE_GSM
+                                            && ServiceState.isGsm(rilRat)) {
+                                        ret = PhoneConstants.DataState.SUSPENDED;
+                                    }
+                                } else {
+                                    logd("getDataConnectionState: set Data state as SUSPENDED");
+                                    ret = PhoneConstants.DataState.SUSPENDED;
+                                }
+                                break;
+                            }
+                        }
+                    }
+
+                    //ALPS01454896: If default data is disable, and current state is disconnecting
+                    //we don't have to show the data icon.
+                    if (ret == PhoneConstants.DataState.CONNECTED &&
+                                apnType == PhoneConstants.APN_TYPE_DEFAULT &&
+                                mDcTracker.getState(apnType) == DctConstants.State.DISCONNECTING &&
+                                !mDcTracker.getDataEnabled()) {
+                        logd("getDataConnectionState: Connected but default data is not open.");
+                        ret = PhoneConstants.DataState.DISCONNECTED;
+                    }
+                break;
+
+                case CONNECTING:
+                case SCANNING:
+                    ret = PhoneConstants.DataState.CONNECTING;
+                break;
+            }
+        }
+
+        logd("getDataConnectionState apnType=" + apnType + " ret=" + ret);
+        return ret;
+    }
+
+    @Override
+    public DataActivityState getDataActivityState() {
+        DataActivityState ret = DataActivityState.NONE;
+
+        if (mSST.getCurrentDataConnectionState() == ServiceState.STATE_IN_SERVICE) {
+            switch (mDcTracker.getActivity()) {
+                case DATAIN:
+                    ret = DataActivityState.DATAIN;
+                break;
+
+                case DATAOUT:
+                    ret = DataActivityState.DATAOUT;
+                break;
+
+                case DATAINANDOUT:
+                    ret = DataActivityState.DATAINANDOUT;
+                break;
+
+                case DORMANT:
+                    ret = DataActivityState.DORMANT;
+                break;
+
+                default:
+                    ret = DataActivityState.NONE;
+                break;
+            }
+        }
+
+        return ret;
+    }
+
+    /**
+     * Notify any interested party of a Phone state change
+     * {@link com.android.internal.telephony.PhoneConstants.State}
+     */
+    public void notifyPhoneStateChanged() {
+        mNotifier.notifyPhoneState(this);
+    }
+
+    /**
+     * Notify registrants of a change in the call state. This notifies changes in
+     * {@link com.android.internal.telephony.Call.State}. Use this when changes
+     * in the precise call state are needed, else use notifyPhoneStateChanged.
+     */
+    public void notifyPreciseCallStateChanged() {
+        /* we'd love it if this was package-scoped*/
+        super.notifyPreciseCallStateChangedP();
+    }
+
+    public void notifyNewRingingConnection(Connection c) {
+        super.notifyNewRingingConnectionP(c);
+    }
+
+    public void notifyDisconnect(Connection cn) {
+        mDisconnectRegistrants.notifyResult(cn);
+
+        mNotifier.notifyDisconnectCause(cn.getDisconnectCause(), cn.getPreciseDisconnectCause());
+    }
+
+    public void notifyUnknownConnection(Connection cn) {
+        super.notifyUnknownConnectionP(cn);
+    }
+
+    @Override
+    public boolean isInEmergencyCall() {
+        if (isPhoneTypeGsm()) {
+            return false;
+        } else {
+            return mCT.isInEmergencyCall();
+        }
+    }
+
+    @Override
+    protected void setIsInEmergencyCall() {
+        if (!isPhoneTypeGsm()) {
+            mCT.setIsInEmergencyCall();
+        }
+    }
+
+    @Override
+    public boolean isInEcm() {
+        if (isPhoneTypeGsm()) {
+            return false;
+        } else {
+            return mIsPhoneInEcmState;
+        }
+    }
+
+    // MTK-START
+    @Override
+    public void queryPhbStorageInfo(int type, Message response) {
+        if (isPhoneTypeGsm()) {
+            mCi.queryPhbStorageInfo(type, response);
+        } else {
+            // M: SIM PHB for C2K
+            IccFileHandler fh;
+            fh = getIccFileHandler();
+            if (!CsimPhbStorageInfo.hasModemPhbEnhanceCapability(fh)) {
+                CsimPhbStorageInfo.checkPhbRecordInfo(response);
+            } else {
+                mCi.queryPhbStorageInfo(type, response);
+            }
+            Rlog.d(LOG_TAG, "queryPhbStorageInfo IccFileHandler" + fh);
+        }
+    }
+    // MTK-END
+
+    //CDMA
+    private void sendEmergencyCallbackModeChange(){
+        //Send an Intent
+        Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
+        intent.putExtra(PhoneConstants.PHONE_IN_ECM_STATE, mIsPhoneInEcmState);
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
+        ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
+        if (DBG) logd("sendEmergencyCallbackModeChange");
+    }
+
+    @Override
+    public void sendEmergencyCallStateChange(boolean callActive) {
+        if (mBroadcastEmergencyCallStateChanges) {
+            Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALL_STATE_CHANGED);
+            intent.putExtra(PhoneConstants.PHONE_IN_EMERGENCY_CALL, callActive);
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
+            ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
+            if (DBG) Rlog.d(LOG_TAG, "sendEmergencyCallStateChange: callActive " + callActive);
+        }
+    }
+
+    @Override
+    public void setBroadcastEmergencyCallStateChanges(boolean broadcast) {
+        mBroadcastEmergencyCallStateChanges = broadcast;
+    }
+
+    public void notifySuppServiceFailed(SuppService code) {
+        mSuppServiceFailedRegistrants.notifyResult(code);
+    }
+
+    public void notifyServiceStateChanged(ServiceState ss) {
+        super.notifyServiceStateChangedP(ss);
+    }
+
+    public void notifyLocationChanged() {
+        mNotifier.notifyCellLocation(this);
+    }
+
+    @Override
+    public void notifyCallForwardingIndicator() {
+        TelephonyManager tm = TelephonyManager.from(mContext);
+        int simState = tm.getSimState(mPhoneId);
+        Rlog.d(LOG_TAG, "notifyCallForwardingIndicator: " + simState);
+        if (simState == TelephonyManager.SIM_STATE_READY) {
+            mNotifier.notifyCallForwardingChanged(this);
+        }
+    }
+
+    // override for allowing access from other classes of this package
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setSystemProperty(String property, String value) {
+        if (getUnitTestMode()) {
+            return;
+        }
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
+        } else {
+            super.setSystemProperty(property, value);
+        }
+    }
+
+    @Override
+    public void registerForSuppServiceNotification(
+            Handler h, int what, Object obj) {
+        mSsnRegistrants.addUnique(h, what, obj);
+
+        /// M: CC: Proprietary CRSS handling @{
+        // Do not enable or disable CSSN since it is already enabled in RIL initial callback.
+        //if (mSsnRegistrants.size() == 1) mCi.setSuppServiceNotifications(true, null);
+        if (mCachedSsn != null) {
+            mSsnRegistrants.notifyRegistrants(mCachedSsn);
+            mCachedSsn = null;
+        }
+        /// @}
+    }
+
+    @Override
+    public void unregisterForSuppServiceNotification(Handler h) {
+        mSsnRegistrants.remove(h);
+        /// M: CC: Proprietary CRSS handling @{
+        // Do not enable or disable CSSN since it is already enabled in RIL initial callback.
+        //if (mSsnRegistrants.size() == 0) mCi.setSuppServiceNotifications(false, null);
+        mCachedSsn = null;
+        /// @}
+    }
+
+    @Override
+    public void registerForSimRecordsLoaded(Handler h, int what, Object obj) {
+        mSimRecordsLoadedRegistrants.addUnique(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForSimRecordsLoaded(Handler h) {
+        mSimRecordsLoadedRegistrants.remove(h);
+    }
+
+    @Override
+    public void acceptCall(int videoState) throws CallStateException {
+        Phone imsPhone = mImsPhone;
+        if ( imsPhone != null && imsPhone.getRingingCall().isRinging() ) {
+            imsPhone.acceptCall(videoState);
+        } else {
+            /// M: CC: For 3G VT only @{
+            //mCT.acceptCall();
+            mCT.acceptCall(videoState);
+            /// @}
+        }
+    }
+
+    @Override
+    public void rejectCall() throws CallStateException {
+        mCT.rejectCall();
+    }
+
+    @Override
+    public void switchHoldingAndActive() throws CallStateException {
+        mCT.switchWaitingOrHoldingAndActive();
+    }
+
+    @Override
+    public String getIccSerialNumber() {
+        IccRecords r = mIccRecords.get();
+        if (!isPhoneTypeGsm() && r == null) {
+            // to get ICCID form SIMRecords because it is on MF.
+            r = mUiccController.getIccRecords(mPhoneId, UiccController.APP_FAM_3GPP);
+        }
+        return (r != null) ? r.getIccId() : null;
+    }
+
+    @Override
+    public String getFullIccSerialNumber() {
+        IccRecords r = mIccRecords.get();
+        if (!isPhoneTypeGsm() && r == null) {
+            // to get ICCID form SIMRecords because it is on MF.
+            r = mUiccController.getIccRecords(mPhoneId, UiccController.APP_FAM_3GPP);
+        }
+        return (r != null) ? r.getFullIccId() : null;
+    }
+
+    @Override
+    public boolean canConference() {
+        if (mImsPhone != null && mImsPhone.canConference()) {
+            return true;
+        }
+        if (isPhoneTypeGsm()) {
+            return mCT.canConference();
+        } else {
+            loge("canConference: not possible in CDMA");
+            return false;
+        }
+    }
+
+    @Override
+    public void conference() {
+        if (mImsPhone != null && mImsPhone.canConference()) {
+            logd("conference() - delegated to IMS phone");
+            try {
+                mImsPhone.conference();
+            } catch (CallStateException e) {
+                loge(e.toString());
+            }
+            return;
+        }
+        if (isPhoneTypeGsm()) {
+            mCT.conference();
+        } else {
+            // three way calls in CDMA will be handled by feature codes
+            loge("conference: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void enableEnhancedVoicePrivacy(boolean enable, Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            loge("enableEnhancedVoicePrivacy: not expected on GSM");
+        } else {
+            mCi.setPreferredVoicePrivacy(enable, onComplete);
+        }
+    }
+
+    @Override
+    public void getEnhancedVoicePrivacy(Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            loge("getEnhancedVoicePrivacy: not expected on GSM");
+        } else {
+            mCi.getPreferredVoicePrivacy(onComplete);
+        }
+    }
+
+    @Override
+    public void clearDisconnected() {
+        mCT.clearDisconnected();
+    }
+
+    @Override
+    public boolean canTransfer() {
+        if (isPhoneTypeGsm()) {
+            return mCT.canTransfer();
+        } else {
+            loge("canTransfer: not possible in CDMA");
+            return false;
+        }
+    }
+
+    @Override
+    public void explicitCallTransfer() {
+        if (isPhoneTypeGsm()) {
+            mCT.explicitCallTransfer();
+        } else {
+            loge("explicitCallTransfer: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public GsmCdmaCall getForegroundCall() {
+        return mCT.mForegroundCall;
+    }
+
+    @Override
+    public GsmCdmaCall getBackgroundCall() {
+        return mCT.mBackgroundCall;
+    }
+
+    @Override
+    public Call getRingingCall() {
+        Phone imsPhone = mImsPhone;
+        // It returns the ringing call of ImsPhone if the ringing call of GSMPhone isn't ringing.
+        // In CallManager.registerPhone(), it always registers ringing call of ImsPhone, because
+        // the ringing call of GSMPhone isn't ringing. Consequently, it can't answer GSM call
+        // successfully by invoking TelephonyManager.answerRingingCall() since the implementation
+        // in PhoneInterfaceManager.answerRingingCallInternal() could not get the correct ringing
+        // call from CallManager. So we check the ringing call state of imsPhone first as
+        // accpetCall() does.
+        if ( imsPhone != null && imsPhone.getRingingCall().isRinging()) {
+            return imsPhone.getRingingCall();
+        }
+        return mCT.mRingingCall;
+    }
+
+    /// M: CC: Use 0+SEND MMI to release held calls or sets UDUB
+    // (User Determined User Busy) for a waiting call. @{
+    // 3GPP 22.030 6.5.5
+    private boolean handleUdubIncallSupplementaryService(
+            String dialString) {
+        if (dialString.length() > 1) {
+            return false;
+        }
+
+        if (getRingingCall().getState() != GsmCdmaCall.State.IDLE ||
+                getBackgroundCall().getState() != GsmCdmaCall.State.IDLE) {
+            if (DBG) Rlog.d(LOG_TAG,
+                    "MmiCode 0: hangupWaitingOrBackground");
+            mCT.hangupWaitingOrBackground();
+        }
+
+        return true;
+    }
+    /// @}
+
+    private boolean handleCallDeflectionIncallSupplementaryService(
+            String dialString) {
+        if (dialString.length() > 1) {
+            return false;
+        }
+
+        if (getRingingCall().getState() != GsmCdmaCall.State.IDLE) {
+            if (DBG) logd("MmiCode 0: rejectCall");
+            try {
+                mCT.rejectCall();
+            } catch (CallStateException e) {
+                if (DBG) Rlog.d(LOG_TAG,
+                        "reject failed", e);
+                notifySuppServiceFailed(Phone.SuppService.REJECT);
+            }
+        } else if (getBackgroundCall().getState() != GsmCdmaCall.State.IDLE) {
+            if (DBG) logd("MmiCode 0: hangupWaitingOrBackground");
+            mCT.hangupWaitingOrBackground();
+        }
+
+        return true;
+    }
+
+    //GSM
+    private boolean handleCallWaitingIncallSupplementaryService(String dialString) {
+        int len = dialString.length();
+
+        if (len > 2) {
+            return false;
+        }
+
+        GsmCdmaCall call = getForegroundCall();
+
+        try {
+            if (len > 1) {
+                char ch = dialString.charAt(1);
+                int callIndex = ch - '0';
+
+                if (callIndex >= 1 && callIndex <= GsmCdmaCallTracker.MAX_CONNECTIONS_GSM) {
+                    if (DBG) logd("MmiCode 1: hangupConnectionByIndex " + callIndex);
+                    mCT.hangupConnectionByIndex(call, callIndex);
+                }
+            } else {
+                if (call.getState() != GsmCdmaCall.State.IDLE) {
+                    if (DBG) logd("MmiCode 1: hangup foreground");
+                    //mCT.hangupForegroundResumeBackground();
+                    mCT.hangup(call);
+                } else {
+                    if (DBG) logd("MmiCode 1: switchWaitingOrHoldingAndActive");
+                    mCT.switchWaitingOrHoldingAndActive();
+                }
+            }
+        } catch (CallStateException e) {
+            if (DBG) Rlog.d(LOG_TAG,
+                    "hangup failed", e);
+            notifySuppServiceFailed(Phone.SuppService.HANGUP);
+        }
+
+        return true;
+    }
+
+    private boolean handleCallHoldIncallSupplementaryService(String dialString) {
+        int len = dialString.length();
+
+        if (len > 2) {
+            return false;
+        }
+
+        GsmCdmaCall call = getForegroundCall();
+
+        if (len > 1) {
+            try {
+                char ch = dialString.charAt(1);
+                int callIndex = ch - '0';
+                GsmCdmaConnection conn = mCT.getConnectionByIndex(call, callIndex);
+
+                // GsmCdma index starts at 1, up to 5 connections in a call,
+                if (conn != null && callIndex >= 1 && callIndex <= GsmCdmaCallTracker.MAX_CONNECTIONS_GSM) {
+                    if (DBG) logd("MmiCode 2: separate call " + callIndex);
+                    mCT.separate(conn);
+                } else {
+                    if (DBG) logd("separate: invalid call index " + callIndex);
+                    notifySuppServiceFailed(Phone.SuppService.SEPARATE);
+                }
+            } catch (CallStateException e) {
+                if (DBG) Rlog.d(LOG_TAG, "separate failed", e);
+                notifySuppServiceFailed(Phone.SuppService.SEPARATE);
+            }
+        } else {
+            try {
+                if (getRingingCall().getState() != GsmCdmaCall.State.IDLE) {
+                    if (DBG) logd("MmiCode 2: accept ringing call");
+                    mCT.acceptCall();
+                } else {
+                    if (DBG) logd("MmiCode 2: switchWaitingOrHoldingAndActive");
+                    mCT.switchWaitingOrHoldingAndActive();
+                }
+            } catch (CallStateException e) {
+                if (DBG) Rlog.d(LOG_TAG, "switch failed", e);
+                notifySuppServiceFailed(Phone.SuppService.SWITCH);
+            }
+        }
+
+        return true;
+    }
+
+    private boolean handleMultipartyIncallSupplementaryService(String dialString) {
+        if (dialString.length() > 1) {
+            return false;
+        }
+
+        if (DBG) logd("MmiCode 3: merge calls");
+        conference();
+        return true;
+    }
+
+    private boolean handleEctIncallSupplementaryService(String dialString) {
+
+        int len = dialString.length();
+
+        if (len != 1) {
+            return false;
+        }
+
+        if (DBG) logd("MmiCode 4: explicit call transfer");
+        explicitCallTransfer();
+        return true;
+    }
+
+    private boolean handleCcbsIncallSupplementaryService(String dialString) {
+        if (dialString.length() > 1) {
+            return false;
+        }
+
+        Rlog.i(LOG_TAG, "MmiCode 5: CCBS not supported!");
+        // Treat it as an "unknown" service.
+        notifySuppServiceFailed(Phone.SuppService.UNKNOWN);
+        return true;
+    }
+
+    /// M: CC: Check GSM call state to avoid InCallMMI dispatching to IMS @{
+    // [ALPS02516173],[ALPS02615800]
+    public Call getCSRingingCall() {
+        return mCT.mRingingCall;
+    }
+
+    boolean isInCSCall() {
+        GsmCdmaCall.State foregroundCallState = getForegroundCall().getState();
+        GsmCdmaCall.State backgroundCallState = getBackgroundCall().getState();
+        GsmCdmaCall.State ringingCallState = getCSRingingCall().getState();
+
+       return (foregroundCallState.isAlive() ||
+                backgroundCallState.isAlive() ||
+                ringingCallState.isAlive());
+    }
+    /// @}
+
+    @Override
+    public boolean handleInCallMmiCommands(String dialString) throws CallStateException {
+        if (!isPhoneTypeGsm()) {
+            loge("method handleInCallMmiCommands is NOT supported in CDMA!");
+            return false;
+        }
+
+        Phone imsPhone = mImsPhone;
+        if (imsPhone != null
+                && imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) {
+            /// M: CC: Check GSM call state to avoid InCallMMI dispatching to IMS @{
+            // [ALPS02516173],[ALPS02615800]
+            //return imsPhone.handleInCallMmiCommands(dialString);
+            if (!isInCSCall()) {
+                return imsPhone.handleInCallMmiCommands(dialString);
+            }
+            /// @}
+        }
+
+        if (!isInCall()) {
+            return false;
+        }
+
+        if (TextUtils.isEmpty(dialString)) {
+            return false;
+        }
+
+        boolean result = false;
+        char ch = dialString.charAt(0);
+        switch (ch) {
+            case '0':
+                /// M: CC: Use 0+SEND MMI to release held calls or sets UDUB
+                // (User Determined User Busy) for a waiting call. @{
+                // 3GPP 22.030 6.5.5
+                //result = handleCallDeflectionIncallSupplementaryService(dialString);
+                result = handleUdubIncallSupplementaryService(dialString);
+                ///@}
+                break;
+            case '1':
+                result = handleCallWaitingIncallSupplementaryService(dialString);
+                break;
+            case '2':
+                result = handleCallHoldIncallSupplementaryService(dialString);
+                break;
+            case '3':
+                result = handleMultipartyIncallSupplementaryService(dialString);
+                break;
+            case '4':
+                result = handleEctIncallSupplementaryService(dialString);
+                break;
+            case '5':
+                result = handleCcbsIncallSupplementaryService(dialString);
+                break;
+            default:
+                break;
+        }
+
+        return result;
+    }
+
+    public boolean isInCall() {
+        GsmCdmaCall.State foregroundCallState = getForegroundCall().getState();
+        GsmCdmaCall.State backgroundCallState = getBackgroundCall().getState();
+        GsmCdmaCall.State ringingCallState = getRingingCall().getState();
+
+       return (foregroundCallState.isAlive() ||
+                backgroundCallState.isAlive() ||
+                ringingCallState.isAlive());
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        return dial(dialString, null, videoState, null);
+    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras)
+            throws CallStateException {
+        if (!isPhoneTypeGsm() && uusInfo != null) {
+            throw new CallStateException("Sending UUS information NOT supported in CDMA!");
+        }
+
+        boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(dialString);
+        Phone imsPhone = mImsPhone;
+
+        CarrierConfigManager configManager =
+                (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId())
+                .getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
+
+        boolean imsUseEnabled = isImsUseEnabled()
+                 && imsPhone != null
+                 && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() ||
+                 (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState)))
+                 && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
+
+        boolean useImsForEmergency = imsPhone != null
+                && isEmergency
+                && alwaysTryImsForEmergencyCarrierConfig
+                && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext)
+                && (imsPhone.getServiceState().getState() != ServiceState.STATE_POWER_OFF);
+
+        /// M: CC: Workaround for separate C2K not on IMS modem@{
+        if (hasC2kOverImsModem()) {
+            if (DBG) Rlog.d(LOG_TAG, "keep AOSP");
+        } else {
+            /// M: CC: Vzw ECC/hVoLTE redial @{
+            if (!useVzwLogic()) {
+                if (!isPhoneTypeGsm()) {
+                    useImsForEmergency = false;
+                }
+            }
+            /// @}
+        }
+
+        // ALPS03042143, IMS ECC should be dialed via the phone with main capability
+        // TODO: remove this workaround for dule VoLTE project
+        if (mPhoneId != getMainCapabilityPhoneId() && mIsMimsSupported == false) {
+            useImsForEmergency = false;
+        }
+        /// @}
+
+        String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.
+                stripSeparators(dialString));
+        boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#"))
+                && dialPart.endsWith("#");
+
+        boolean useImsForUt = false;
+        if (is93MDSupport()) {
+            useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
+        } else {
+            /// M: @{
+            useImsForUt = imsPhone != null && imsPhone.isUtEnabled()
+                    && !(OperatorUtils.isNotSupportXcap(getOperatorNumeric()));
+            /// @}
+        }
+
+        if (DBG) {
+            logd("PhoneId = " + mPhoneId
+                    + ", imsUseEnabled=" + imsUseEnabled
+                    + ", useImsForEmergency=" + useImsForEmergency
+                    + ", useImsForUt=" + useImsForUt
+                    + ", isUt=" + isUt
+                    + ", imsPhone=" + imsPhone
+                    + ", imsPhone.isVolteEnabled()="
+                    + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A")
+                    + ", imsPhone.isVowifiEnabled()="
+                    + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A")
+                    + ", imsPhone.isVideoEnabled()="
+                    + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A")
+                    + ", imsPhone.getServiceState().getState()="
+                    + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
+        }
+
+        Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mContext);
+
+        /// M: should be removed later, just for debug @{
+        Rlog.w(LOG_TAG, "IMS: imsphone = " + imsPhone + "isEmergencyNumber = " + isEmergency);
+        if (imsPhone != null) {
+            Rlog.w(LOG_TAG, "service state = " + imsPhone.getServiceState().getState());
+        }
+        /// @}
+
+        if ((imsUseEnabled && (!isUt || useImsForUt)) || useImsForEmergency) {
+            /// M: CC: Check GSM call state to avoid InCallMMI dispatching to IMS @{
+            // [ALPS02516173],[ALPS02615800]
+            if (isInCSCall()) {
+                if (DBG) Rlog.d(LOG_TAG, "has CS Call. Don't try IMS PS Call!");
+            } else {
+            /// @}
+                try {
+                    /// M: ALPS02137073 3G VT Refactory
+                    if (videoState == VideoProfile.STATE_AUDIO_ONLY) {
+                        if (DBG) Rlog.d(LOG_TAG, "Trying IMS PS call");
+                        return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
+                    } else {
+                        if (SystemProperties.get("persist.mtk_vilte_support").equals("1")) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "Trying IMS PS video call");
+                            }
+                            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
+                        } else {
+                            /// M: CC: For 3G VT only @{
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "Trying (non-IMS) CS video call");
+                            }
+                            return dialInternal(dialString, uusInfo, videoState, intentExtras);
+                            /// @}
+                        }
+                    }
+                } catch (CallStateException e) {
+                    if (DBG) logd("IMS PS call exception " + e +
+                            "imsUseEnabled =" + imsUseEnabled + ", imsPhone =" + imsPhone);
+                    if (!Phone.CS_FALLBACK.equals(e.getMessage())) {
+                        CallStateException ce = new CallStateException(e.getMessage());
+                        ce.setStackTrace(e.getStackTrace());
+                        throw ce;
+                    }
+                }
+            /// M: CC: Check GSM call state to avoid InCallMMI dispatching to IMS @{
+            }
+            /// @}
+        }
+
+        /// M: CC: FTA requires call should be dialed out even out of service @{
+        if (SystemProperties.getInt("gsm.gcf.testmode", 0) != 2) {
+            if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE
+                    && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE
+                    && !isEmergency) {
+                throw new CallStateException("cannot dial in current state");
+            }
+        }
+        /// @}
+        if (DBG) logd("Trying (non-IMS) CS call");
+
+        if (isPhoneTypeGsm()) {
+            /// M: CC: For 3G VT only @{
+            //return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
+            return dialInternal(dialString, null, videoState, intentExtras);
+            /// @}
+        } else {
+            return dialInternal(dialString, null, videoState, intentExtras);
+        }
+    }
+
+    @Override
+    protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState,
+                                      Bundle intentExtras)
+            throws CallStateException {
+
+        // Need to make sure dialString gets parsed properly
+        /// M: Ignore stripping for VoLTE SIP uri. @{
+        // String newDialString = PhoneNumberUtils.stripSeparators(dialString);
+        String newDialString = dialString;
+        if (!PhoneNumberUtils.isUriNumber(dialString)) {
+            // Need to make sure dialString gets parsed properly
+            newDialString = PhoneNumberUtils.stripSeparators(dialString);
+        }
+        /// @}
+
+        if (isPhoneTypeGsm()) {
+            // handle in-call MMI first if applicable
+            if (handleInCallMmiCommands(newDialString)) {
+                return null;
+            }
+
+            // Only look at the Network portion for mmi
+            String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
+            GsmMmiCode mmi =
+                    GsmMmiCode.newFromDialString(networkPortion, this, mUiccApplication.get());
+            if (DBG) logd("dialing w/ mmi '" + mmi + "'...");
+
+            if (mmi == null) {
+
+                /// M: CC: For 3G VT only @{
+                //return mCT.dial(newDialString, uusInfo, intentExtras);
+                if (videoState == VideoProfile.STATE_AUDIO_ONLY) {
+                    return mCT.dial(newDialString, uusInfo, intentExtras);
+                } else {
+                    if (!is3GVTEnabled()) {
+                        throw new CallStateException("cannot vtDial for non-3GVT-capable device");
+                    }
+                    return mCT.vtDial(newDialString, uusInfo, intentExtras);
+                }
+                /// @}
+            } else if (mmi.isTemporaryModeCLIR()) {
+                /// M: CC: For 3G VT only @{
+                //return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
+                if (videoState == VideoProfile.STATE_AUDIO_ONLY) {
+                    return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
+                } else {
+                    if (!is3GVTEnabled()) {
+                        throw new CallStateException("cannot vtDial for non-3GVT-capable device");
+                    }
+                    return mCT.vtDial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
+                }
+                /// @}
+            } else {
+                /// M: @{
+                if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                    Rlog.d(LOG_TAG, "Stop CS MMI during IMS Ecc Call or VoLTE call");
+                    throw new CallStateException("Stop CS MMI during IMS Ecc Call or VoLTE call");
+                }
+                /// @}
+
+                mPendingMMIs.add(mmi);
+                /// M: @{
+                Rlog.d(LOG_TAG, "dialInternal: " + dialString + ", mmi=" + mmi);
+                dumpPendingMmi();
+                /// @}
+                mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
+                try {
+                    mmi.processCode();
+                } catch (CallStateException e) {
+                    //do nothing
+                }
+
+                // FIXME should this return null or something else?
+                return null;
+            }
+        } else {
+            return mCT.dial(newDialString);
+        }
+    }
+
+    @Override
+    public boolean handlePinMmi(String dialString) {
+        MmiCode mmi;
+        if (isPhoneTypeGsm()) {
+            mmi = GsmMmiCode.newFromDialString(dialString, this, mUiccApplication.get());
+        } else {
+            mmi = CdmaMmiCode.newFromDialString(dialString, this, mUiccApplication.get());
+        }
+
+        if (mmi != null && mmi.isPinPukCommand()) {
+            mPendingMMIs.add(mmi);
+            /// M: @{
+            Rlog.d(LOG_TAG, "handlePinMmi: " + dialString + ", mmi=" + mmi);
+            dumpPendingMmi();
+            /// @}
+            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
+            try {
+                mmi.processCode();
+            } catch (CallStateException e) {
+                //do nothing
+            }
+            return true;
+        }
+
+        loge("Mmi is null or unrecognized!");
+        return false;
+    }
+
+    @Override
+    public void sendUssdResponse(String ussdMessge) {
+        if (isPhoneTypeGsm()) {
+            GsmMmiCode mmi = GsmMmiCode.newFromUssdUserInput(ussdMessge, this, mUiccApplication.get());
+            mPendingMMIs.add(mmi);
+            /// M: @{
+            Rlog.d(LOG_TAG, "sendUssdResponse: " + ussdMessge + ", mmi=" + mmi);
+            dumpPendingMmi();
+            /// @}
+            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
+            mmi.sendUssd(ussdMessge);
+        } else {
+            loge("sendUssdResponse: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void sendDtmf(char c) {
+        if (!PhoneNumberUtils.is12Key(c)) {
+            loge("sendDtmf called with invalid character '" + c + "'");
+        } else {
+            if (mCT.mState ==  PhoneConstants.State.OFFHOOK) {
+                mCi.sendDtmf(c, null);
+            }
+        }
+    }
+
+    @Override
+    public void startDtmf(char c) {
+        if (!PhoneNumberUtils.is12Key(c)) {
+            loge("startDtmf called with invalid character '" + c + "'");
+        } else {
+            mCi.startDtmf(c, null);
+        }
+    }
+
+    @Override
+    public void stopDtmf() {
+        mCi.stopDtmf(null);
+    }
+
+    @Override
+    public void sendBurstDtmf(String dtmfString, int on, int off, Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            loge("[GsmCdmaPhone] sendBurstDtmf() is a CDMA method");
+        } else {
+            boolean check = true;
+            for (int itr = 0;itr < dtmfString.length(); itr++) {
+                if (!PhoneNumberUtils.is12Key(dtmfString.charAt(itr))) {
+                    Rlog.e(LOG_TAG,
+                            "sendDtmf called with invalid character '" + dtmfString.charAt(itr)+ "'");
+                    check = false;
+                    break;
+                }
+            }
+            if (mCT.mState == PhoneConstants.State.OFFHOOK && check) {
+                mCi.sendBurstDtmf(dtmfString, on, off, onComplete);
+            }
+        }
+    }
+
+    @Override
+    public void setRadioPower(boolean power) {
+        mSST.setRadioPower(power);
+    }
+
+    private void storeVoiceMailNumber(String number) {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        SharedPreferences.Editor editor = sp.edit();
+        if (isPhoneTypeGsm()) {
+            editor.putString(VM_NUMBER + getPhoneId(), number);
+            editor.apply();
+            setVmSimImsi(getSubscriberId());
+        } else {
+            editor.putString(VM_NUMBER_CDMA + getPhoneId(), number);
+            editor.apply();
+        }
+    }
+
+    @Override
+    public String getVoiceMailNumber() {
+        String number = null;
+        if (isPhoneTypeGsm()) {
+            // Read from the SIM. If its null, try reading from the shared preference area.
+            IccRecords r = mIccRecords.get();
+            number = (r != null) ? r.getVoiceMailNumber() : "";
+            if (TextUtils.isEmpty(number)) {
+                SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+                number = sp.getString(VM_NUMBER + getPhoneId(), null);
+            }
+        } else {
+            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+            number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
+        }
+
+        if (TextUtils.isEmpty(number)) {
+            String[] listArray = getContext().getResources()
+                .getStringArray(com.android.internal.R.array.config_default_vm_number);
+            if (listArray != null && listArray.length > 0) {
+                for (int i=0; i<listArray.length; i++) {
+                    if (!TextUtils.isEmpty(listArray[i])) {
+                        String[] defaultVMNumberArray = listArray[i].split(";");
+                        if (defaultVMNumberArray != null && defaultVMNumberArray.length > 0) {
+                            if (defaultVMNumberArray.length == 1) {
+                                number = defaultVMNumberArray[0];
+                            } else if (defaultVMNumberArray.length == 2 &&
+                                    !TextUtils.isEmpty(defaultVMNumberArray[1]) &&
+                                    isMatchGid(defaultVMNumberArray[1])) {
+                                number = defaultVMNumberArray[0];
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
+            // Read platform settings for dynamic voicemail number
+            if (getContext().getResources().getBoolean(com.android.internal
+                    .R.bool.config_telephony_use_own_number_for_voicemail)) {
+                number = getLine1Number();
+            } else {
+                number = "*86";
+            }
+        }
+
+        return number;
+    }
+
+    private String getVmSimImsi() {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        return sp.getString(VM_SIM_IMSI + getPhoneId(), null);
+    }
+
+    private void setVmSimImsi(String imsi) {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(VM_SIM_IMSI + getPhoneId(), imsi);
+        editor.apply();
+    }
+
+    @Override
+    public String getVoiceMailAlphaTag() {
+        String ret = "";
+
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+
+            ret = (r != null) ? r.getVoiceMailAlphaTag() : "";
+        }
+
+        if (ret == null || ret.length() == 0) {
+            return mContext.getText(
+                com.android.internal.R.string.defaultVoiceMailAlphaTag).toString();
+        }
+
+        return ret;
+    }
+
+    @Override
+    public String getDeviceId() {
+        if (isPhoneTypeGsm()) {
+            return mImei;
+        } else {
+            CarrierConfigManager configManager = (CarrierConfigManager)
+                    mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            boolean force_imei = configManager.getConfigForSubId(getSubId())
+                    .getBoolean(CarrierConfigManager.KEY_FORCE_IMEI_BOOL);
+            if (force_imei) return mImei;
+
+            if (getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
+                ///M: google CTS need return IMEI
+                Rlog.d(LOG_TAG, "getDeviceId() in LTE_ON_CDMA_TRUE : return Imei");
+                return getImei();
+            } else {
+                String id = getMeid();
+                if ((id == null) || id.matches("^0*$")) {
+                    loge("getDeviceId(): MEID is not initialized use ESN");
+                    id = getEsn();
+                }
+                return id;
+            }
+        }
+    }
+
+    public int isDeviceIdAbnormal() {
+        return mDeviceIdAbnormal;
+    }
+
+    public void setDeviceIdAbnormal(int abnormal) {
+        mDeviceIdAbnormal = abnormal;
+    }
+
+    @Override
+    public String getDeviceSvn() {
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            return mImeiSv;
+        } else {
+            loge("getDeviceSvn(): return 0");
+            return "0";
+        }
+    }
+
+    @Override
+    public IsimRecords getIsimRecords() {
+        return mIsimUiccRecords;
+    }
+
+    @Override
+    public String getImei() {
+        return mImei;
+    }
+
+    @Override
+    public String getEsn() {
+        if (isPhoneTypeGsm()) {
+            loge("[GsmCdmaPhone] getEsn() is a CDMA method");
+            return "0";
+        } else {
+            return mEsn;
+        }
+    }
+
+    @Override
+    public String getMeid() {
+        if (isPhoneTypeGsm()) {
+            loge("[GsmCdmaPhone] getMeid() is a CDMA method");
+            return "0";
+        } else {
+            return mMeid;
+        }
+    }
+
+    @Override
+    public String getNai() {
+        IccRecords r = mUiccController.getIccRecords(mPhoneId, UiccController.APP_FAM_3GPP2);
+        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {
+            Rlog.v(LOG_TAG, "IccRecords is " + r);
+        }
+        return (r != null) ? r.getNAI() : null;
+    }
+
+    @Override
+    public String getSubscriberId() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getIMSI() : null;
+        } else if (isPhoneTypeCdma()) {
+            logd("getSubscriberId, phone type is CDMA Imsi = " + mSST.getImsi());
+            return mSST.getImsi();
+        } else { //isPhoneTypeCdmaLte()
+            IccRecords r = mIccRecords.get();
+            return (mSimRecords != null) ? mSimRecords.getIMSI()
+                    : ((r != null) ? r.getIMSI() : null);
+        }
+    }
+
+    @Override
+    public String getGroupIdLevel1() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getGid1() : null;
+        } else if (isPhoneTypeCdma()) {
+            loge("GID1 is not available in CDMA");
+            return null;
+        } else { //isPhoneTypeCdmaLte()
+            return (mSimRecords != null) ? mSimRecords.getGid1() : "";
+        }
+    }
+
+    @Override
+    public String getGroupIdLevel2() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getGid2() : null;
+        } else if (isPhoneTypeCdma()) {
+            loge("GID2 is not available in CDMA");
+            return null;
+        } else { //isPhoneTypeCdmaLte()
+            return (mSimRecords != null) ? mSimRecords.getGid2() : "";
+        }
+    }
+
+    @Override
+    public String getLine1Number() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getMsisdnNumber() : null;
+        } else {
+            return mSST.getMdnNumber();
+        }
+    }
+
+    @Override
+    public String getCdmaPrlVersion() {
+        return mSST.getPrlVersion();
+    }
+
+    @Override
+    public String getCdmaMin() {
+        return mSST.getCdmaMin();
+    }
+
+    @Override
+    public boolean isMinInfoReady() {
+        return mSST.isMinInfoReady();
+    }
+
+    @Override
+    public String getMsisdn() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getMsisdnNumber() : null;
+        } else if (isPhoneTypeCdmaLte()) {
+            return (mSimRecords != null) ? mSimRecords.getMsisdnNumber() : null;
+        } else {
+            loge("getMsisdn: not expected on CDMA");
+            return null;
+        }
+    }
+
+    @Override
+    public String getLine1AlphaTag() {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            return (r != null) ? r.getMsisdnAlphaTag() : null;
+        } else {
+            loge("getLine1AlphaTag: not possible in CDMA");
+            return null;
+        }
+    }
+
+    @Override
+    public boolean setLine1Number(String alphaTag, String number, Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            if (r != null) {
+                r.setMsisdnNumber(alphaTag, number, onComplete);
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            loge("setLine1Number: not possible in CDMA");
+            return false;
+        }
+    }
+
+    @Override
+    public void setVoiceMailNumber(String alphaTag, String voiceMailNumber, Message onComplete) {
+        Message resp;
+        mVmNumber = voiceMailNumber;
+        resp = obtainMessage(EVENT_SET_VM_NUMBER_DONE, 0, 0, onComplete);
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            r.setVoiceMailNumber(alphaTag, mVmNumber, resp);
+        }
+    }
+
+    private boolean isValidCommandInterfaceCFReason (int commandInterfaceCFReason) {
+        switch (commandInterfaceCFReason) {
+            case CF_REASON_UNCONDITIONAL:
+            case CF_REASON_BUSY:
+            case CF_REASON_NO_REPLY:
+            case CF_REASON_NOT_REACHABLE:
+            case CF_REASON_ALL:
+            case CF_REASON_ALL_CONDITIONAL:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public String getSystemProperty(String property, String defValue) {
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            if (getUnitTestMode()) {
+                return null;
+            }
+            return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
+        } else {
+            return super.getSystemProperty(property, defValue);
+        }
+    }
+
+    private boolean isValidCommandInterfaceCFAction (int commandInterfaceCFAction) {
+        switch (commandInterfaceCFAction) {
+            case CF_ACTION_DISABLE:
+            case CF_ACTION_ENABLE:
+            case CF_ACTION_REGISTRATION:
+            case CF_ACTION_ERASURE:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    private boolean isCfEnable(int action) {
+        return (action == CF_ACTION_ENABLE) || (action == CF_ACTION_REGISTRATION);
+    }
+
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason, Message onComplete) {
+        /// M: Support ut ss for ct card @{
+        // if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+        /// @}
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getCallForwardingOption enter, CFReason:" + commandInterfaceCFReason);
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+
+                    // MTK added - start
+                    if (isOpReregisterForCF()) {
+                        // Check the arg2 is MESSAGE_SET_CF
+                        if (onComplete.arg2 == MESSAGE_SET_CF) {
+                            Rlog.d(LOG_TAG, "Set ims dereg to ON.");
+                            SystemProperties.set(IMS_DEREG_PROP, IMS_DEREG_ON);
+                        }
+                    }
+                    // MTK added - end
+
+                    imsPhone.getCallForwardingOption(commandInterfaceCFReason, onComplete);
+                    return;
+                }
+
+                if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+                    if (DBG) {
+                        logd("requesting call forwarding query.");
+                    }
+                    Message resp;
+                    if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                        resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+                    } else {
+                        resp = onComplete;
+                    }
+                    mCi.queryCallForwardStatus(commandInterfaceCFReason, 0, null, resp);
+                }
+
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    || imsPhone.isUtEnabled())
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CF,
+                    onComplete);
+                ss.mParcel.writeInt(commandInterfaceCFReason);
+                ss.mParcel.writeInt(CommandsInterface.SERVICE_CLASS_VOICE);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+
+                if (isOpReregisterForCF()) {
+                    // Check the arg2 is MESSAGE_SET_CF
+                    if (onComplete.arg2 == MESSAGE_SET_CF) {
+                        Rlog.d(LOG_TAG, "Set ims dereg to ON.");
+                        SystemProperties.set(IMS_DEREG_PROP, IMS_DEREG_ON);
+                    }
+                }
+
+                imsPhone.getCallForwardingOption(commandInterfaceCFReason, imsUtResult);
+                return;
+            }
+
+            if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+                if (DBG) logd("requesting call forwarding query.");
+                Message resp;
+                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                    resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+                } else {
+                    resp = onComplete;
+                }
+
+                /// M: SS Ut part @{
+                if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && isGsmUtSupport()) {
+                    mSSReqDecisionMaker.queryCallForwardStatus(commandInterfaceCFReason,
+                            0, null, resp);
+                    return;
+                }
+                /// @}
+
+                if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                    setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+                }
+
+                if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                    if (onComplete != null) {
+                        sendErrorResponse(onComplete,
+                                CommandException.Error.GENERIC_FAILURE);
+                        return;
+                    }
+                }
+                /// M: Not support from Ut to cs domain part @{
+                if (isNotSupportUtToCS()) {
+                    sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                } else {
+                    Rlog.d(LOG_TAG, "mCi.queryCallForwardStatus.");
+                    mCi.queryCallForwardStatus(commandInterfaceCFReason, 0, null, resp);
+                }
+                /// @}
+                //  mCi.queryCallForwardStatus(commandInterfaceCFReason, 0, null, resp);
+            }
+        } else {
+            loge("getCallForwardingOption: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void getCallForwardingOptionForServiceClass(int commandInterfaceCFReason,
+                                  int serviceClass,
+                                  Message onComplete) {
+        ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+        /// M: 93 Ims SS native solution @{
+        if (is93MDSupport()) {
+            Rlog.d(LOG_TAG, "getCallForwardingOptionForServiceClass enter, " +
+                    "CFReason:" + commandInterfaceCFReason + ", serviceClass:" + serviceClass);
+            // MTK design part, always send with CS (same AT cmd for both PS/CS)
+            if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+                if (DBG) {
+                    logd("requesting call forwarding query for service class.");
+                }
+                Message resp;
+                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                    resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+                } else {
+                    resp = onComplete;
+                }
+                mCi.queryCallForwardStatus(commandInterfaceCFReason, serviceClass, null, resp);
+            }
+
+            return;
+        }
+        /// @}
+
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+            SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CF,
+                    onComplete);
+            ss.mParcel.writeInt(commandInterfaceCFReason);
+            ss.mParcel.writeInt(serviceClass);
+            Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+            setServiceClass(serviceClass);
+            imsPhone.getCallForwardingOption(commandInterfaceCFReason, imsUtResult);
+            return;
+        }
+
+        if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+            Rlog.d(LOG_TAG, "requesting call forwarding query.");
+            Message resp;
+            if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+            } else {
+                resp = onComplete;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                mSSReqDecisionMaker.queryCallForwardStatus(commandInterfaceCFReason,
+                        serviceClass, null, resp);
+                return;
+            }
+            /// @}
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+            mCi.queryCallForwardStatus(commandInterfaceCFReason,serviceClass,null,resp);
+        }
+    }
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFAction,
+            int commandInterfaceCFReason,
+            String dialingNumber,
+            int timerSeconds,
+            Message onComplete) {
+        /// M: Support ut ss for ct card @{
+        // if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+        /// @}
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "setCallForwardingOption enter, CFAction:" + commandInterfaceCFAction +
+                        ", CFReason:" + commandInterfaceCFReason + ", dialingNumber:" + dialingNumber +
+                        ", timerSeconds:" + timerSeconds);
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+                    imsPhone.setCallForwardingOption(commandInterfaceCFAction,
+                            commandInterfaceCFReason, dialingNumber, timerSeconds, onComplete);
+                    return;
+                }
+
+                if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                        (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
+
+                    Message resp;
+                    if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                        // MTK added - start
+                        int origUtCfuMode = 0;
+                        String utCfuMode = getSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_DISABLED);
+                        if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                            origUtCfuMode = 1;
+                        } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                            origUtCfuMode = 2;
+                        }
+                        // MTK added - end
+
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                        Cfu cfu = new Cfu(dialingNumber, onComplete);
+                        resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+                                isCfEnable(commandInterfaceCFAction) ? 1 : 0, origUtCfuMode, cfu);
+//                      resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+//                              isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cfu);
+                    } else {
+                        resp = onComplete;
+                    }
+                    mCi.setCallForward(commandInterfaceCFAction,
+                            commandInterfaceCFReason,
+                            CommandsInterface.SERVICE_CLASS_VOICE,
+                            dialingNumber,
+                            timerSeconds,
+                            resp);
+                }
+
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    || imsPhone.isUtEnabled())
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CF,
+                    onComplete);
+                ss.mParcel.writeInt(commandInterfaceCFAction);
+                ss.mParcel.writeInt(commandInterfaceCFReason);
+                ss.mParcel.writeString(dialingNumber);
+                ss.mParcel.writeInt(timerSeconds);
+                ss.mParcel.writeInt(CommandsInterface.SERVICE_CLASS_VOICE);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                imsPhone.setCallForwardingOption(commandInterfaceCFAction,
+                        commandInterfaceCFReason, dialingNumber, timerSeconds, imsUtResult);
+                return;
+            }
+
+            if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                    (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
+
+                Message resp;
+                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                    int origUtCfuMode = 0;
+                    String utCfuMode = getSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                            UT_CFU_NOTIFICATION_MODE_DISABLED);
+                    if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                        origUtCfuMode = 1;
+                    } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                        origUtCfuMode = 2;
+                    }
+
+                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                            UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                    Cfu cfu = new Cfu(dialingNumber, onComplete);
+                    resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+                            isCfEnable(commandInterfaceCFAction) ? 1 : 0, origUtCfuMode, cfu);
+                } else {
+                    resp = onComplete;
+                }
+
+                /// M: SS Ut part @{
+                if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && isGsmUtSupport()) {
+                    mSSReqDecisionMaker.setCallForward(commandInterfaceCFAction,
+                            commandInterfaceCFReason, CommandsInterface.SERVICE_CLASS_VOICE,
+                            dialingNumber, timerSeconds, resp);
+                    return;
+                }
+                /// @}
+
+                if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                    setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+                }
+
+                /// M: Not support from Ut to cs domain part @{
+                if (isNotSupportUtToCS()) {
+                    sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                    return;
+                }
+                /// @}
+
+                if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                    if (onComplete != null) {
+                        sendErrorResponse(onComplete,
+                                CommandException.Error.GENERIC_FAILURE);
+                        return;
+                    }
+                }
+
+                mCi.setCallForward(commandInterfaceCFAction,
+                        commandInterfaceCFReason,
+                        CommandsInterface.SERVICE_CLASS_VOICE,
+                        dialingNumber,
+                        timerSeconds,
+                        resp);
+            }
+        } else {
+            loge("setCallForwardingOption: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void setCallForwardingOptionForServiceClass(int commandInterfaceCFReason,
+                                 int commandInterfaceCFAction,
+                                 String dialingNumber,
+                                 int timerSeconds,
+                                 int serviceClass,
+                                 Message onComplete) {
+        ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+        /// M: 93 Ims SS native solution @{
+        if (is93MDSupport()) {
+            Rlog.d(LOG_TAG, "setCallForwardingOptionForServiceClass enter, CFAction:" + commandInterfaceCFAction +
+                    ", CFReason:" + commandInterfaceCFReason + ", dialingNumber:" + dialingNumber +
+                    ", timerSeconds:" + timerSeconds + ", serviceClass:" + serviceClass);
+            // MTK design part, always send with CS (same AT cmd for both PS/CS)
+            if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                    (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
+
+                Message resp;
+                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                    // MTK added - start
+                    int origUtCfuMode = 0;
+                    String utCfuMode = getSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                            UT_CFU_NOTIFICATION_MODE_DISABLED);
+                    if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                        origUtCfuMode = 1;
+                    } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                        origUtCfuMode = 2;
+                    }
+
+                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                            UT_CFU_NOTIFICATION_MODE_DISABLED);
+                    // MTK added - end
+
+                    Cfu cfu = new Cfu(dialingNumber, onComplete);
+                    resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+                            isCfEnable(commandInterfaceCFAction) ? 1 : 0, origUtCfuMode, cfu);
+//                  resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+//                          isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cfu);
+                } else {
+                    resp = onComplete;
+                }
+                mCi.setCallForward(commandInterfaceCFAction,
+                        commandInterfaceCFReason,
+                        serviceClass,
+                        dialingNumber,
+                        timerSeconds,
+                        resp);
+            }
+
+            return;
+        }
+        /// @}
+
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+            SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CF,
+                    onComplete);
+            ss.mParcel.writeInt(commandInterfaceCFAction);
+            ss.mParcel.writeInt(commandInterfaceCFReason);
+            ss.mParcel.writeString(dialingNumber);
+            ss.mParcel.writeInt(timerSeconds);
+            ss.mParcel.writeInt(serviceClass);
+            Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+            imsPhone.setCallForwardingOption(commandInterfaceCFAction, commandInterfaceCFReason,
+                    dialingNumber, serviceClass, timerSeconds, imsUtResult);
+            return;
+        }
+
+        if (    (isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
+
+            Message resp;
+            if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                int origUtCfuMode = 0;
+                String utCfuMode = getSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                        UT_CFU_NOTIFICATION_MODE_DISABLED);
+                if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                    origUtCfuMode = 1;
+                } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                    origUtCfuMode = 2;
+                }
+
+                setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                        UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                Cfu cfu = new Cfu(dialingNumber, onComplete);
+                resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
+                        isCfEnable(commandInterfaceCFAction) ? 1 : 0, origUtCfuMode, cfu);
+            } else {
+                resp = onComplete;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                mSSReqDecisionMaker.setCallForward(commandInterfaceCFAction,
+                        commandInterfaceCFReason, serviceClass,
+                        dialingNumber, timerSeconds, resp);
+                return;
+            }
+            /// @}
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+            mCi.setCallForward(commandInterfaceCFAction,
+                    commandInterfaceCFReason,
+                    serviceClass,
+                    dialingNumber,
+                    timerSeconds,
+                    resp);
+        }
+    }
+
+    /**
+     * Get Terminal-based CLIR.
+     * @return Response array by 27.007.
+     */
+    public int[] getSavedClirSetting() {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        int clirSetting = sp.getInt(CLIR_KEY + getPhoneId(), -1);
+        int presentationMode;
+        int getClirResult;
+        if ((clirSetting == 0) || (clirSetting == -1)) {
+            //allow CLI presentation
+            presentationMode = 4;
+            getClirResult = CommandsInterface.CLIR_DEFAULT;
+        } else if (clirSetting == 1) {
+            //restrict CLI presentation
+            presentationMode = 3;
+            getClirResult = CommandsInterface.CLIR_INVOCATION;
+        } else {
+            //allow CLI presentation
+            presentationMode = 4;
+            getClirResult = CommandsInterface.CLIR_SUPPRESSION;
+        }
+
+        int getClirResponse [] = new int[2];
+        getClirResponse[0] = getClirResult;
+        getClirResponse[1] = presentationMode;
+
+        Rlog.d(LOG_TAG, "getClirResult: " + getClirResult);
+        Rlog.d(LOG_TAG, "presentationMode: " + presentationMode);
+
+        return getClirResponse;
+    }
+
+    @Override
+    public void getOutgoingCallerIdDisplay(Message onComplete) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getOutgoingCallerIdDisplay enter");
+
+                Message resp = obtainMessage(EVENT_GET_CLIR_COMPLETE, onComplete);
+                if ((imsPhone != null) &&
+                        (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+                    imsPhone.getOutgoingCallerIdDisplay(resp);
+                    return;
+                }
+                mCi.getCLIR(resp);
+
+                return;
+            }
+            /// @}
+
+            /// M: SS @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                && (imsPhone.isVolteEnabled()
+                || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))
+                ) {
+                if (isOpNotSupportCallIdentity()) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+
+                if (isOpTbClir()) {
+                    if (onComplete != null) {
+                        int[] result = getSavedClirSetting();
+                        AsyncResult.forMessage(onComplete, result, null);
+                        onComplete.sendToTarget();
+                    }
+                    return;
+                }
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CLIR,
+                        onComplete);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                imsPhone.getOutgoingCallerIdDisplay(imsUtResult);
+                return;
+            }
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                if (isOpTbClir()) {
+                    if (onComplete != null) {
+                        int[] result = getSavedClirSetting();
+                        AsyncResult.forMessage(onComplete, result, null);
+                        onComplete.sendToTarget();
+                    }
+                    return;
+                }
+                mSSReqDecisionMaker.getCLIR(onComplete);
+                return;
+            }
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+            /// @}
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                return;
+            }
+            /// @}
+
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+
+            mCi.getCLIR(onComplete);
+        } else {
+            loge("getOutgoingCallerIdDisplay: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "setOutgoingCallerIdDisplay enter, CLIRmode:" +
+                        commandInterfaceCLIRMode);
+
+                Message resp = obtainMessage(EVENT_SET_CLIR_COMPLETE,
+                        commandInterfaceCLIRMode, 0, onComplete);
+                if ((imsPhone != null) &&
+                        (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+                    imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, resp);
+                    return;
+                }
+                // Packing CLIR value in the message. This will be required for
+                // SharedPreference caching, if the message comes back as part of
+                // a success response.
+                mCi.setCLIR(commandInterfaceCLIRMode, resp);
+
+                return;
+            }
+            /// @}
+
+            /// M: SS @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                if (isOpNotSupportCallIdentity()) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+
+                if (isOpTbClir()) {
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+
+                    mCi.setCLIR(commandInterfaceCLIRMode,
+                        obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode,
+                        0, onComplete));
+                    return;
+                }
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CLIR,
+                        onComplete);
+                ss.mParcel.writeInt(commandInterfaceCLIRMode);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, imsUtResult);
+                return;
+            }
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                if (isOpTbClir()) {
+
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+
+                    mCi.setCLIR(commandInterfaceCLIRMode,
+                        obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode,
+                        0, onComplete));
+                    return;
+                }
+                mSSReqDecisionMaker.setCLIR(commandInterfaceCLIRMode,
+                        obtainMessage(EVENT_SET_CLIR_COMPLETE,
+                                commandInterfaceCLIRMode, 0, onComplete));
+                return;
+            }
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+            /// @}
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                return;
+            }
+            /// @}
+
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+
+            mCi.setCLIR(commandInterfaceCLIRMode,
+                    obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
+        } else {
+            loge("setOutgoingCallerIdDisplay: not possible in CDMA");
+        }
+    }
+
+    private void initTbcwMode() {
+        if (mTbcwMode == TBCW_UNKNOWN) {
+            if (isOpTbcwWithCS(getPhoneId())) {
+                setTbcwMode(TBCW_OPTBCW_WITH_CS);
+                setTbcwToEnabledOnIfDisabled();
+            } else if (!isUsimCard()) {
+                setTbcwMode(TBCW_OPTBCW_NOT_VOLTE_USER);
+                setSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                                TERMINAL_BASED_CALL_WAITING_DISABLED);
+            }
+        }
+        Rlog.d(LOG_TAG, "initTbcwMode: " + mTbcwMode);
+    }
+
+    public int getTbcwMode() {
+        if (mTbcwMode == TBCW_UNKNOWN) {
+            initTbcwMode();
+        }
+        return mTbcwMode;
+    }
+
+    public void setTbcwMode(int newMode) {
+        Rlog.d(LOG_TAG, "Set tbcwmode: " + newMode);
+        mTbcwMode = newMode;
+    }
+
+    /**
+     * Set the system property PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE
+     * to TERMINAL_BASED_CALL_WAITING_ENABLED_ON if it is TERMINAL_BASED_CALL_WAITING_DISABLED.
+     */
+    public void setTbcwToEnabledOnIfDisabled() {
+        String tbcwMode = getSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                TERMINAL_BASED_CALL_WAITING_DISABLED);
+        if (TERMINAL_BASED_CALL_WAITING_DISABLED.equals(tbcwMode)) {
+            setSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                    TERMINAL_BASED_CALL_WAITING_ENABLED_ON);
+        }
+    }
+
+    /**
+     * Return Terminal-based Call Waiting configuration.
+     * @param onComplete Message callback
+     */
+    public void getTerminalBasedCallWaiting(Message onComplete) {
+        String tbcwMode = getSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                TERMINAL_BASED_CALL_WAITING_DISABLED);
+        if (DBG) {
+            Rlog.d(LOG_TAG, "getTerminalBasedCallWaiting(): tbcwMode = " + tbcwMode
+                    + ", onComplete = " + onComplete);
+        }
+        if (TERMINAL_BASED_CALL_WAITING_ENABLED_ON.equals(tbcwMode)) {
+            if (onComplete != null) {
+                int[] cwInfos = new int[2];
+                cwInfos[0] = 1;
+                cwInfos[1] = SERVICE_CLASS_VOICE;
+                AsyncResult.forMessage(onComplete, cwInfos, null);
+                onComplete.sendToTarget();
+            }
+            return;
+        } else if (TERMINAL_BASED_CALL_WAITING_ENABLED_OFF.equals(tbcwMode)) {
+            if (onComplete != null) {
+                int[] cwInfos = new int[2];
+                cwInfos[0] = 0;
+                AsyncResult.forMessage(onComplete, cwInfos, null);
+                onComplete.sendToTarget();
+            }
+            return;
+        }
+
+        Rlog.e(LOG_TAG, "getTerminalBasedCallWaiting(): ERROR: tbcwMode = " + tbcwMode);
+        return;
+    }
+
+    @Override
+    public void getCallWaiting(Message onComplete) {
+        /// M: Support ut ss for ct card @{
+        // if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+        /// @}
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getCallWaiting enter");
+
+                /// M: If CW terminal based set and MD ever return 832, the flag will be eabled @{
+                if (getSystemProperty(SS_CW_TBCW_EVER_ENABLE_PROP, "0").equals("1")) {
+                    getTerminalBasedCallWaiting(onComplete);
+                    return;
+                }
+                /// @}
+
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+                    imsPhone.getCallWaiting(onComplete);
+                    return;
+                }
+
+                //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+                //class parameter in call waiting interrogation  to network
+                mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+
+                return;
+            }
+            /// @}
+
+            //isOpNwCW:Call Waiting is configured by Ut interface.
+            if (!isOpNwCW()) {
+                if (mTbcwMode == TBCW_UNKNOWN) {
+                    initTbcwMode();
+                }
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "getCallWaiting(): mTbcwMode = " + mTbcwMode
+                            + ", onComplete = " + onComplete);
+                }
+                if (mTbcwMode == TBCW_OPTBCW_VOLTE_USER) {
+                    getTerminalBasedCallWaiting(onComplete);
+                    return;
+                } else if (mTbcwMode == TBCW_OPTBCW_NOT_VOLTE_USER) {
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+                    /// M: Not support from Ut to cs domain part @{
+                    if (isNotSupportUtToCS()) {
+                        sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                    } else {
+                        Rlog.d(LOG_TAG, "mCi.queryCallForwardStatus.");
+                        mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+                    }
+                    /// @}
+                    //mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+                    return;
+                } else if (mTbcwMode == TBCW_OPTBCW_WITH_CS) {
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+                    Message resp = obtainMessage(EVENT_GET_CALL_WAITING_DONE, onComplete);
+                    mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, resp);
+                    return;
+                }
+            }
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    || imsPhone.isUtEnabled())
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                if (isOpNwCW()) {
+                    Rlog.d(LOG_TAG, "isOpNwCW(), getCallWaiting() by Ut interface");
+                    SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CW,
+                        onComplete);
+                    Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                    imsPhone.getCallWaiting(imsUtResult);
+                } else {
+                    Rlog.d(LOG_TAG, "isOpTbCW(), getTerminalBasedCallWaiting");
+                    setTbcwMode(TBCW_OPTBCW_VOLTE_USER);
+                    setTbcwToEnabledOnIfDisabled();
+                    getTerminalBasedCallWaiting(onComplete);
+                }
+                return;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                Rlog.d(LOG_TAG, "mSSReqDecisionMaker.queryCallWaiting");
+                mSSReqDecisionMaker.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE,
+                    onComplete);
+                return;
+            }
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+            /// @}
+
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+
+            //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+            //class parameter in call waiting interrogation  to network
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+            } else {
+                Rlog.d(LOG_TAG, "mCi.queryCallForwardStatus.");
+                mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+            }
+            /// @}
+            //  mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+        } else {
+            mCi.queryCallWaiting(CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+        }
+    }
+
+    /**
+     * Set Terminal-based Call Waiting configuration.
+     * @param enable true if activate Call Waiting. false if deactivate Call Waiting.
+     * @param onComplete Message callback
+     */
+    public void setTerminalBasedCallWaiting(boolean enable, Message onComplete) {
+        String tbcwMode = getSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                TERMINAL_BASED_CALL_WAITING_DISABLED);
+        if (DBG) {
+            Rlog.d(LOG_TAG, "setTerminalBasedCallWaiting(): tbcwMode = " + tbcwMode
+                    + ", enable = " + enable);
+        }
+        if (TERMINAL_BASED_CALL_WAITING_ENABLED_ON.equals(tbcwMode)) {
+            if (!enable) {
+                setSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                        TERMINAL_BASED_CALL_WAITING_ENABLED_OFF);
+            }
+            if (onComplete != null) {
+                AsyncResult.forMessage(onComplete, null, null);
+                onComplete.sendToTarget();
+            }
+            return;
+        } else if (TERMINAL_BASED_CALL_WAITING_ENABLED_OFF.equals(tbcwMode)) {
+            if (enable) {
+                setSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                        TERMINAL_BASED_CALL_WAITING_ENABLED_ON);
+            }
+            if (onComplete != null) {
+                AsyncResult.forMessage(onComplete, null, null);
+                onComplete.sendToTarget();
+            }
+            return;
+        }
+
+        Rlog.e(LOG_TAG, "setTerminalBasedCallWaiting(): ERROR: tbcwMode = " + tbcwMode);
+        return;
+    }
+
+    @Override
+    public void setCallWaiting(boolean enable, Message onComplete) {
+        /// M: Support ut ss for ct card @{
+        // if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+        /// @}
+            Phone imsPhone = mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "setCallWaiting enter, enable:" + enable);
+
+                /// M: If CW terminal based set and MD ever return 832, the flag will be eabled @{
+                if (getSystemProperty(SS_CW_TBCW_EVER_ENABLE_PROP, "0").equals("1")) {
+                    setTerminalBasedCallWaiting(enable, onComplete);
+                    return;
+                }
+                /// @}
+
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+                    imsPhone.setCallWaiting(enable, onComplete);
+                    return;
+                }
+
+                mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+
+                return;
+            }
+            /// @}
+
+            //isOpNwCW():Call Waiting is configured by Ut interface.
+            if (!isOpNwCW()) {
+                if (mTbcwMode == TBCW_UNKNOWN) {
+                    initTbcwMode();
+                }
+
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "setCallWaiting(): mTbcwMode = " + mTbcwMode
+                            + ", onComplete = " + onComplete);
+                }
+
+                if (mTbcwMode == TBCW_OPTBCW_VOLTE_USER) {
+                    setTerminalBasedCallWaiting(enable, onComplete);
+                    return;
+                } else if (mTbcwMode == TBCW_OPTBCW_NOT_VOLTE_USER) {
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+
+                    /// M: Not support from Ut to cs domain part @{
+                    if (isNotSupportUtToCS()) {
+                        sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                    } else {
+                        mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+                    }
+                    /// @}
+                    //mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+                    return;
+                } else if (mTbcwMode == TBCW_OPTBCW_WITH_CS) {
+                    if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                        if (onComplete != null) {
+                            sendErrorResponse(onComplete,
+                                    CommandException.Error.GENERIC_FAILURE);
+                            return;
+                        }
+                    }
+
+                    Message resp = obtainMessage(EVENT_SET_CALL_WAITING_DONE,
+                        enable == true ? 1 : 0, 0, onComplete);
+                    mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, resp);
+                    return;
+                }
+            }
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                && (imsPhone != null)
+                && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                || imsPhone.isUtEnabled())
+                && (imsPhone.isVolteEnabled()
+                || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                if (isOpNwCW()) {
+                    Rlog.d(LOG_TAG, "isOpNwCW(), setCallWaiting(): IMS in service");
+                    SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CW,
+                            onComplete);
+                    int enableState = enable ? 1 : 0;
+                    ss.mParcel.writeInt(enableState);
+                    Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                    imsPhone.setCallWaiting(enable, imsUtResult);
+                } else {
+                    Rlog.d(LOG_TAG, "isOpTbCW(), setTerminalBasedCallWaiting(): IMS in service");
+                    setTbcwMode(TBCW_OPTBCW_VOLTE_USER);
+                    setTbcwToEnabledOnIfDisabled();
+                    setTerminalBasedCallWaiting(enable, onComplete);
+                }
+                return;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                Rlog.d(LOG_TAG, "mSSReqDecisionMaker.setCallWaiting");
+                mSSReqDecisionMaker.setCallWaiting(enable,
+                        CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+                return;
+            }
+            /// @}
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+            } else {
+                mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+            }
+            /// @}
+            //  mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+        } else {
+            loge("method setCallWaiting is NOT supported in CDMA!");
+        }
+    }
+
+    /// M: @{
+    /**
+     * Get Call Barring State
+     */
+    public void getFacilityLock(String facility, String password, Message onComplete) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+            ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getFacilityLock enter, facility:" + facility +
+                        ", password:" + password);
+
+                Message resp = obtainMessage(EVENT_GET_FACILITY_LOCK_COMPLETE, onComplete);
+                // MTK added part
+                if ((imsPhone != null) &&
+                        (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+                    imsPhone.getCallBarring(facility, resp);
+                    return;
+                }
+
+                mCi.queryFacilityLockForApp(facility, password,
+                        CommandsInterface.SERVICE_CLASS_VOICE,
+                        mUiccApplication.get() != null ? mUiccApplication.get().getAid() : null,
+                        resp);
+
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                /// M: SS Ut part @{
+                if (isOpNotSupportOCB(facility)) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+                /// @}
+
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CB,
+                        onComplete);
+                ss.mParcel.writeString(facility);
+                ss.mParcel.writeString(password);
+                ss.mParcel.writeInt(CommandsInterface.SERVICE_CLASS_VOICE);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+
+                imsPhone.getCallBarring(facility, imsUtResult);
+                return;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                mSSReqDecisionMaker.queryFacilityLock(facility,
+                        password, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+                return;
+            }
+            /// @}
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                return;
+            }
+            /// @}
+
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+
+            mCi.queryFacilityLockForApp(facility, password, CommandsInterface.SERVICE_CLASS_VOICE,
+                    mUiccApplication.get() != null ? mUiccApplication.get().getAid() : null,
+                    onComplete);
+        } else {
+            loge("method getFacilityLock is NOT supported in CDMA!");
+        }
+    }
+
+    /**
+     * Set Call Barring State
+     */
+
+    public void setFacilityLock(String facility, boolean enable,
+        String password, Message onComplete) {
+        if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+            ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "setFacilityLock enter, facility:" + facility +
+                        ", enable:" + enable + ", password:" + password);
+
+                Message resp = obtainMessage(EVENT_SET_FACILITY_LOCK_COMPLETE, onComplete);
+                // MTK added part
+                if ((imsPhone != null) &&
+                        (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+
+                    imsPhone.setCallBarring(facility, enable, password, resp);
+                    return;
+                }
+
+                mCi.setFacilityLockForApp(facility, enable, password,
+                        CommandsInterface.SERVICE_CLASS_VOICE,
+                        mUiccApplication.get() != null ? mUiccApplication.get().getAid() : null,
+                        resp);
+
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                /// M: SS Ut part @{
+                if (isOpNotSupportOCB(facility)) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+                /// @}
+
+                SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CB,
+                        onComplete);
+                ss.mParcel.writeString(facility);
+                int enableState = enable ? 1 : 0;
+                ss.mParcel.writeInt(enableState);
+                ss.mParcel.writeString(password);
+                ss.mParcel.writeInt(CommandsInterface.SERVICE_CLASS_VOICE);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+
+                imsPhone.setCallBarring(facility, enable, password, imsUtResult);
+                return;
+            }
+
+            /// M: SS Ut part @{
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isGsmUtSupport()) {
+                mSSReqDecisionMaker.setFacilityLock(facility,
+                        enable, password, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+                return;
+            }
+            /// @}
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+
+            /// M: Not support from Ut to cs domain part @{
+            if (isNotSupportUtToCS()) {
+                sendErrorResponse(onComplete, CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                return;
+            }
+            /// @}
+            if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                if (onComplete != null) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.GENERIC_FAILURE);
+                    return;
+                }
+            }
+            mCi.setFacilityLockForApp(facility, enable, password,
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                mUiccApplication.get() != null ? mUiccApplication.get().getAid() : null,
+                onComplete);
+        } else {
+            loge("method setFacilityLock is NOT supported in CDMA!");
+        }
+    }
+
+    public void getFacilityLockForServiceClass(String facility, String password, int serviceClass,
+            Message onComplete) {
+        ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+        /// M: 93 Ims SS native solution @{
+        if (is93MDSupport()) {
+            Rlog.d(LOG_TAG, "getFacilityLockForServiceClass enter, facility:" + facility +
+                    ", serviceClass:" + serviceClass + ", password:" + password);
+
+            Message resp = obtainMessage(EVENT_GET_FACILITY_LOCK_COMPLETE, onComplete);
+            // MTK added part
+            if ((imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+                setServiceClass(serviceClass);
+                imsPhone.getCallBarring(facility, resp);
+                // TODO: how passward/ServiceClass pass to PS?
+                return;
+            }
+
+            //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+            //class parameter in call waiting interrogation  to network
+            mCi.queryFacilityLock(facility, password, serviceClass, resp);
+
+            return;
+        }
+        /// @}
+
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+
+            // / M: SS Ut part @{
+            if (isOpNotSupportOCB(facility)) {
+                sendErrorResponse(onComplete,
+                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                return;
+            }
+            // / @}
+
+            SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_GET_CB,
+                    onComplete);
+            ss.mParcel.writeString(facility);
+            ss.mParcel.writeString(password);
+            ss.mParcel.writeInt(serviceClass);
+            Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+            setServiceClass(serviceClass);
+            imsPhone.getCallBarring(facility, imsUtResult);
+            return;
+        }
+
+        // / M: SS Ut part @{
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && isGsmUtSupport()) {
+            setServiceClass(serviceClass);
+            mSSReqDecisionMaker.queryFacilityLock(facility, password, serviceClass, onComplete);
+            return;
+        }
+        // / @}
+
+        if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+            setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+        }
+        mCi.queryFacilityLock(facility, password, serviceClass, onComplete);
+    }
+
+    public void setFacilityLockForServiceClass(String facility, boolean enable, String password,
+            int serviceClass, Message onComplete) {
+        ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+        /// M: 93 Ims SS native solution @{
+        if (is93MDSupport()) {
+            Rlog.d(LOG_TAG, "setFacilityLockForServiceClass enter, facility:" + facility +
+                    ", serviceClass:" + serviceClass + ", password:" + password +
+                    ", enable:" + enable);
+
+            Message resp = obtainMessage(EVENT_SET_FACILITY_LOCK_COMPLETE, onComplete);
+            // MTK added part
+            if ((imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+                setServiceClass(serviceClass);
+                imsPhone.setCallBarring(facility, enable, password, resp);
+                return;
+            }
+
+            mCi.setFacilityLock(facility, enable, password, serviceClass, resp);
+
+            return;
+        }
+        /// @}
+
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && (imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+
+            // / M: SS Ut part @{
+            if (isOpNotSupportOCB(facility)) {
+                sendErrorResponse(onComplete,
+                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                return;
+            }
+            // / @}
+
+            SuppSrvRequest ss = SuppSrvRequest.obtain(SuppSrvRequest.SUPP_SRV_REQ_SET_CB,
+                    onComplete);
+            ss.mParcel.writeString(facility);
+            int enableState = enable ? 1 : 0;
+            ss.mParcel.writeInt(enableState);
+            ss.mParcel.writeString(password);
+            ss.mParcel.writeInt(serviceClass);
+            Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+            setServiceClass(serviceClass);
+            imsPhone.setCallBarring(facility, enable, password, imsUtResult);
+            return;
+        }
+
+        // / M: SS Ut part @{
+        if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED) && isGsmUtSupport()) {
+            setServiceClass(serviceClass);
+            mSSReqDecisionMaker.setFacilityLock(facility, enable, password, serviceClass,
+                    onComplete);
+            return;
+        }
+        // / @}
+
+        if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+            setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+        }
+        mCi.setFacilityLock(facility, enable, password, serviceClass, onComplete);
+    }
+
+    /**
+     * Change Call Barring Password
+     */
+    public void changeBarringPassword(String facility, String oldPwd,
+        String newPwd, Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            if (isDuringImsCall()) {
+                // Prevent CS domain SS request during IMS call
+                if (onComplete != null) {
+                    CommandException ce = new CommandException(
+                            CommandException.Error.GENERIC_FAILURE);
+                    AsyncResult.forMessage(onComplete, null, ce);
+                    onComplete.sendToTarget();
+                }
+            } else {
+                mCi.changeBarringPassword(facility, oldPwd, newPwd, onComplete);
+            }
+        } else {
+            loge("method setFacilityLock is NOT supported in CDMA!");
+        }
+    }
+
+    /// M: SS OP01 Ut @{
+    private static class CfuEx {
+        final String mSetCfNumber;
+        final long[] mSetTimeSlot;
+        final Message mOnComplete;
+
+        CfuEx(String cfNumber, long[] cfTimeSlot, Message onComplete) {
+            mSetCfNumber = cfNumber;
+            mSetTimeSlot = cfTimeSlot;
+            mOnComplete = onComplete;
+        }
+    }
+
+    @Override
+    public void getCallForwardInTimeSlot(int commandInterfaceCFReason, Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getCallForwardInTimeSlot enter, CFReason:" + commandInterfaceCFReason);
+                if (!isOp(OPID.OP01)) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+                    imsPhone.getCallForwardInTimeSlot(commandInterfaceCFReason, onComplete);
+                    return;
+                }
+
+                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "requesting call forwarding in time slot query.");
+                    }
+                    Message resp;
+                    resp = obtainMessage(EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE, onComplete);
+                    mCi.queryCallForwardInTimeSlotStatus(commandInterfaceCFReason, 0, resp);
+                }
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isOp(OPID.OP01) && (imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                imsPhone.getCallForwardInTimeSlot(commandInterfaceCFReason, onComplete);
+                return;
+            }
+
+            if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "requesting call forwarding in time slot query.");
+                }
+                Message resp;
+                resp = obtainMessage(EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE, onComplete);
+
+                if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && isGsmUtSupport()) {
+                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                        UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                    mSSReqDecisionMaker.queryCallForwardInTimeSlotStatus(
+                            commandInterfaceCFReason,
+                            CommandsInterface.SERVICE_CLASS_VOICE, resp);
+                } else {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                }
+            } else if (onComplete != null) {
+                sendErrorResponse(onComplete, CommandException.Error.GENERIC_FAILURE);
+            }
+        } else {
+            loge("method getCallForwardInTimeSlot is NOT supported in CDMA!");
+        }
+    }
+
+    @Override
+    public void setCallForwardInTimeSlot(int commandInterfaceCFAction,
+            int commandInterfaceCFReason,
+            String dialingNumber,
+            int timerSeconds,
+            long[] timeSlot,
+            Message onComplete) {
+        if (isPhoneTypeGsm()) {
+            ImsPhone imsPhone = (ImsPhone) mImsPhone;
+
+            /// M: 93 Ims SS native solution @{
+            if (is93MDSupport()) {
+                Rlog.d(LOG_TAG, "getCallForwardInTimeSlot enter, CFReason:" + commandInterfaceCFReason +
+                        ", CFAction:" + commandInterfaceCFAction + ", dialingNumber:" + dialingNumber +
+                        ", timerSeconds:" + timerSeconds);
+                if (!isOp(OPID.OP01)) {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                    return;
+                }
+
+                if ((imsPhone != null)
+                        && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        || imsPhone.isUtEnabled())) {
+                    imsPhone.setCallForwardInTimeSlot(commandInterfaceCFAction,
+                            commandInterfaceCFReason, dialingNumber, timerSeconds,
+                            timeSlot, onComplete);
+                    return;
+                }
+
+                if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                        (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL)) {
+                    Message resp;
+                    CfuEx cfuEx = new CfuEx(dialingNumber, timeSlot, onComplete);
+                    resp = obtainMessage(EVENT_SET_CALL_FORWARD_TIME_SLOT_DONE,
+                            isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cfuEx);
+
+                    mCi.setCallForwardInTimeSlot(commandInterfaceCFAction,
+                            commandInterfaceCFReason,
+                            CommandsInterface.SERVICE_CLASS_VOICE,
+                            dialingNumber,
+                            timerSeconds,
+                            timeSlot,
+                            resp);
+                }
+                return;
+            }
+            /// @}
+
+            if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                    && isOp(OPID.OP01) && (imsPhone != null)
+                    && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                    && (imsPhone.isVolteEnabled()
+                    || (imsPhone.isWifiCallingEnabled() && isWFCUtSupport()))) {
+                SuppSrvRequest ss = SuppSrvRequest.obtain(
+                        SuppSrvRequest.SUPP_SRV_REQ_SET_CF_IN_TIME_SLOT, onComplete);
+                ss.mParcel.writeInt(commandInterfaceCFAction);
+                ss.mParcel.writeInt(commandInterfaceCFReason);
+                ss.mParcel.writeString(dialingNumber);
+                ss.mParcel.writeInt(timerSeconds);
+                Message imsUtResult = obtainMessage(EVENT_IMS_UT_DONE, ss);
+                imsPhone.setCallForwardInTimeSlot(commandInterfaceCFAction,
+                        commandInterfaceCFReason, dialingNumber,
+                        timerSeconds, timeSlot, imsUtResult);
+                return;
+            }
+
+            if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) &&
+                    (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL)) {
+                Message resp;
+                CfuEx cfuEx = new CfuEx(dialingNumber, timeSlot, onComplete);
+                resp = obtainMessage(EVENT_SET_CALL_FORWARD_TIME_SLOT_DONE,
+                        isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cfuEx);
+
+                if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && isGsmUtSupport()) {
+                    mSSReqDecisionMaker.setCallForwardInTimeSlot(commandInterfaceCFAction,
+                            commandInterfaceCFReason, CommandsInterface.SERVICE_CLASS_VOICE,
+                            dialingNumber, timerSeconds, timeSlot, resp);
+                } else {
+                    sendErrorResponse(onComplete,
+                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                }
+            } else {
+                sendErrorResponse(onComplete, CommandException.Error.GENERIC_FAILURE);
+            }
+        } else {
+            loge("method setCallForwardInTimeSlot is NOT supported in CDMA!");
+        }
+    }
+
+    private void handleCfuInTimeSlotQueryResult(CallForwardInfoEx[] infos) {
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            if (infos == null || infos.length == 0) {
+                // Assume the default is not active
+                // Set unconditional CFF in SIM to false
+                setVoiceCallForwardingFlag(1, false, null);
+                setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,UT_CFU_NOTIFICATION_MODE_OFF);
+            } else {
+                for (int i = 0, s = infos.length; i < s; i++) {
+                    if ((infos[i].serviceClass & SERVICE_CLASS_VOICE) != 0) {
+                        setVoiceCallForwardingFlag(1, (infos[i].status == 1),
+                                infos[i].number);
+                        String mode = infos[i].status == 1 ?
+                            UT_CFU_NOTIFICATION_MODE_ON : UT_CFU_NOTIFICATION_MODE_OFF;
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE, mode);
+                        saveTimeSlot(infos[i].timeSlot);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    void sendErrorResponse(Message onComplete, CommandException.Error error) {
+        Rlog.d(LOG_TAG, "sendErrorResponse" + error);
+        if (onComplete != null) {
+            AsyncResult.forMessage(onComplete, null, new CommandException(error));
+            onComplete.sendToTarget();
+        }
+    }
+
+    public boolean queryCfuOrWait() {
+        int sid1 = 99, sid2 = 99;
+        /* M: SS part */ //TODO need to check if there any new implementation
+        //int slotId = SubscriptionManager.getSlotId(getSubId());//reference code
+
+        /*
+        if (mySimId == PhoneConstants.GEMINI_SIM_1) {
+           sid1 = PhoneConstants.GEMINI_SIM_2;
+           sid2 = PhoneConstants.GEMINI_SIM_3;
+        } else if (mySimId == PhoneConstants.GEMINI_SIM_2) {
+           sid1 = PhoneConstants.GEMINI_SIM_1;
+           sid2 = PhoneConstants.GEMINI_SIM_3;
+        } else if (mySimId == PhoneConstants.GEMINI_SIM_3) {
+           sid1 = PhoneConstants.GEMINI_SIM_1;
+           sid2 = PhoneConstants.GEMINI_SIM_2;
+        }*/
+        String oppositePropertyValue1 = SystemProperties.get(CFU_QUERY_PROPERTY_NAME + sid1);
+        String oppositePropertyValue2 = SystemProperties.get(CFU_QUERY_PROPERTY_NAME + sid2);
+        if ((oppositePropertyValue1.equals("1")) ||
+            (oppositePropertyValue2.equals("1"))) { /* The opposite phone is querying CFU status */
+            Message message = obtainMessage(EVENT_CFU_QUERY_TIMEOUT);
+            sendMessageDelayed(message, cfuQueryWaitTime);
+            return false;
+        } else {
+            boolean bDataEnable = getDataEnabled();
+            Rlog.d(LOG_TAG, "bDataEnable: " + bDataEnable);
+            /// M: Support ut ss for ct card @{
+            // if (isPhoneTypeGsm()) {
+            if (isPhoneTypeGsm() || isGsmSsPrefer()) {
+            /// @}
+                /// M: 93 Ims SS native solution @{
+                if (is93MDSupport()) {
+                    Phone imsPhone = mImsPhone;
+                    // MTK added part
+                    if ((imsPhone != null) && (
+                            (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                            || imsPhone.isUtEnabled())) {
+                        // TODO: is it need to check isUtEnabled() ?
+                        // TODO: need to check more logic in here!! how OP01 do ? bDataEnable??
+                        if(isOp(OPID.OP01)) {
+                            imsPhone.getCallForwardInTimeSlot(CF_REASON_UNCONDITIONAL,
+                                    obtainMessage(EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE,
+                                    1, 0, null));
+                        } else {
+                            imsPhone.getCallForwardingOption(CF_REASON_UNCONDITIONAL,
+                                    obtainMessage(EVENT_GET_CALL_FORWARD_DONE, null));
+                        }
+                        return true;
+                    }
+
+                    if (isValidCommandInterfaceCFReason(CF_REASON_UNCONDITIONAL)) {
+                        if (DBG) {
+                            logd("requesting call forwarding query, queryCfuOrWait().");
+                        }
+                        if (isOp(OPID.OP01)) {
+                            mCi.queryCallForwardInTimeSlotStatus(CF_REASON_UNCONDITIONAL,
+                                    CommandsInterface.SERVICE_CLASS_VOICE,
+                                    obtainMessage(EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE,
+                                    1, 0, null));
+                        } else {
+                            mCi.queryCallForwardStatus(CF_REASON_UNCONDITIONAL,
+                                    CommandsInterface.SERVICE_CLASS_VOICE, null,
+                                    obtainMessage(EVENT_GET_CALL_FORWARD_DONE));
+                        }
+                    }
+
+                    return true;
+                }
+                /// @}
+
+                /* If MCCMNC is not ready, just return directly*/
+                if (!isIccCardMncMccAvailable(getPhoneId())) {
+                    return false;
+                }
+
+                //setSystemProperty(CFU_QUERY_PROPERTY_NAME + mySimId, "1");//* M: SS part */TODO
+                if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && isGsmUtSupport() && bDataEnable) {
+                    if(isOp(OPID.OP01)) {
+                        mSSReqDecisionMaker.queryCallForwardInTimeSlotStatus(
+                                CF_REASON_UNCONDITIONAL,
+                                SERVICE_CLASS_VOICE,
+                                obtainMessage(EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE, 1, 0, null));
+                    } else {
+                        mSSReqDecisionMaker.queryCallForwardStatus(CF_REASON_UNCONDITIONAL,
+                                SERVICE_CLASS_VOICE, null,
+                                obtainMessage(EVENT_GET_CALL_FORWARD_DONE,null));
+                    }
+                } else {
+                    Phone imsPhone = mImsPhone;
+                    if ((getCsFallbackStatus() == PhoneConstants.UT_CSFB_PS_PREFERRED)
+                        && (imsPhone != null)
+                        && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                        && !bDataEnable
+                        && isOp(OPID.OP01) && isOp(OPID.OP02)) {
+                       Rlog.d(LOG_TAG, "No need query CFU in CS domain!");
+                   } else if (!isNotSupportUtToCS()) {
+                       if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                           setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+                       }
+
+                       if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+                           Rlog.i(LOG_TAG, "No need query CFU in CS domain!");
+                       } else {
+                           mCi.queryCallForwardStatus(CF_REASON_UNCONDITIONAL, SERVICE_CLASS_VOICE,
+                                   null,obtainMessage(EVENT_GET_CALL_FORWARD_DONE));
+                       }
+                   }
+                }
+           }
+           return true;
+        }
+    }
+
+    public SSRequestDecisionMaker getSSRequestDecisionMaker() {
+        return mSSReqDecisionMaker;
+    }
+    /// @}
+
+    public boolean isDuringImsCall() {
+        if (mImsPhone != null) {
+            Call.State foregroundCallState = mImsPhone.getForegroundCall().getState();
+            Call.State backgroundCallState = mImsPhone.getBackgroundCall().getState();
+            Call.State ringingCallState = mImsPhone.getRingingCall().getState();
+            boolean isDuringImsCall = (foregroundCallState.isAlive() ||
+                    backgroundCallState.isAlive() || ringingCallState.isAlive());
+            if (isDuringImsCall) {
+                Rlog.d(LOG_TAG, "During IMS call.");
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isDuringVoLteCall() {
+        boolean isOnLtePdn = (mImsPhone != null && mImsPhone.isVolteEnabled());
+        boolean r = isDuringImsCall() && isOnLtePdn;
+        Rlog.d(LOG_TAG, "isDuringVoLteCall: " + r);
+        return r;
+    }
+
+    public boolean isDuringImsEccCall() {
+        boolean isInImsEccCall = (mImsPhone != null && mImsPhone.isInEmergencyCall());
+        Rlog.d(LOG_TAG, "isInImsEccCall: " + isInImsEccCall);
+        return isInImsEccCall;
+    }
+
+    private void handleImsUtCsfb(Message msg) {
+        SuppSrvRequest ss = (SuppSrvRequest) msg.obj;
+        if (ss == null) {
+            Rlog.e(LOG_TAG, "handleImsUtCsfb: Error SuppSrvRequest null!");
+            return;
+        }
+
+        if (isDuringVoLteCall()|| isDuringImsEccCall()) {
+            // Prevent CS domain SS request during IMS Ecc call or VOLTE call
+            Message resultCallback = ss.getResultCallback();
+            if (resultCallback != null) {
+                CommandException ce = new CommandException(
+                        CommandException.Error.GENERIC_FAILURE);
+                AsyncResult.forMessage(resultCallback, null, ce);
+                resultCallback.sendToTarget();
+            }
+
+            if (getCsFallbackStatus() == PhoneConstants.UT_CSFB_ONCE) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+            }
+
+            ss.setResultCallback(null);
+            ss.mParcel.recycle();
+            return;
+        }
+
+        final int requestCode = ss.getRequestCode();
+        ss.mParcel.setDataPosition(0);
+        switch(requestCode) {
+            case SuppSrvRequest.SUPP_SRV_REQ_GET_CF:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_GET_CF");
+                int commandInterfaceCFReason = ss.mParcel.readInt();
+                int serviceClass = ss.mParcel.readInt();
+                getCallForwardingOptionForServiceClass(commandInterfaceCFReason,
+                        serviceClass, ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_SET_CF:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_SET_CF");
+                int commandInterfaceCFAction = ss.mParcel.readInt();
+                int commandInterfaceCFReason = ss.mParcel.readInt();
+                String dialingNumber = ss.mParcel.readString();
+                int timerSeconds = ss.mParcel.readInt();
+                int serviceClass = ss.mParcel.readInt();
+                setCallForwardingOptionForServiceClass(commandInterfaceCFReason,
+                        commandInterfaceCFAction, dialingNumber, timerSeconds,
+                        serviceClass, ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_GET_CLIR:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_GET_CLIR");
+                getOutgoingCallerIdDisplay(ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_SET_CLIR:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_SET_CLIR");
+                int commandInterfaceCLIRMode = ss.mParcel.readInt();
+                setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_GET_CW:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_GET_CW");
+                getCallWaiting(ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_SET_CW:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_SET_CW");
+                int enableState = ss.mParcel.readInt();
+                boolean enable = (enableState != 0);
+                setCallWaiting(enable, ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_GET_CB:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_GET_CB");
+                String facility = ss.mParcel.readString();
+                String password = ss.mParcel.readString();
+                int serviceClass = ss.mParcel.readInt();
+                getFacilityLockForServiceClass(facility, password, serviceClass,
+                        ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_SET_CB:
+            {
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_SET_CB");
+                String facility = ss.mParcel.readString();
+                int enableState = ss.mParcel.readInt();
+                boolean enable = (enableState != 0);
+                String password = ss.mParcel.readString();
+                int serviceClass = ss.mParcel.readInt();
+                setFacilityLockForServiceClass(facility, enable, password, serviceClass,
+                        ss.getResultCallback());
+                break;
+            }
+            case SuppSrvRequest.SUPP_SRV_REQ_MMI_CODE:
+            {
+                String dialString = ss.mParcel.readString();
+                Rlog.d(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_MMI_CODE: dialString = "
+                        + dialString);
+                try {
+                    dial(dialString, VideoProfile.STATE_AUDIO_ONLY);
+                } catch (CallStateException ex) {
+                    Rlog.e(LOG_TAG, "handleImsUtCsfb: SUPP_SRV_REQ_MMI_CODE: CallStateException!");
+                    ex.printStackTrace();
+                }
+                break;
+            }
+            default:
+                Rlog.e(LOG_TAG, "handleImsUtCsfb: invalid requestCode = " + requestCode);
+                break;
+        }
+
+        ss.setResultCallback(null);
+        ss.mParcel.recycle();
+    }
+
+    private void handleUssiCsfb(String dialString) {
+        Rlog.d(LOG_TAG, "handleUssiCsfb: dialString=" + dialString);
+        try {
+            dial(dialString, VideoProfile.STATE_AUDIO_ONLY);
+        } catch (CallStateException ex) {
+            Rlog.e(LOG_TAG, "handleUssiCsfb: CallStateException!");
+            ex.printStackTrace();
+        }
+    }
+
+    /* M: SS part end */
+
+    @Override
+    public void getAvailableNetworks(Message response) {
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            mCi.getAvailableNetworks(response);
+        } else {
+            loge("getAvailableNetworks: not possible in CDMA");
+        }
+    }
+
+    @Override
+    public void getNeighboringCids(Message response) {
+        if (isPhoneTypeGsm()) {
+            mCi.getNeighboringCids(response);
+        } else {
+            /*
+             * This is currently not implemented.  At least as of June
+             * 2009, there is no neighbor cell information available for
+             * CDMA because some party is resisting making this
+             * information readily available.  Consequently, calling this
+             * function can have no useful effect.  This situation may
+             * (and hopefully will) change in the future.
+             */
+            if (response != null) {
+                CommandException ce = new CommandException(
+                        CommandException.Error.REQUEST_NOT_SUPPORTED);
+                AsyncResult.forMessage(response).exception = ce;
+                response.sendToTarget();
+            }
+        }
+    }
+
+    @Override
+    public void setUiTTYMode(int uiTtyMode, Message onComplete) {
+       if (mImsPhone != null) {
+           mImsPhone.setUiTTYMode(uiTtyMode, onComplete);
+       }
+    }
+
+    @Override
+    public void setMute(boolean muted) {
+        mCT.setMute(muted);
+    }
+
+    @Override
+    public boolean getMute() {
+        return mCT.getMute();
+    }
+
+    @Override
+    public void getDataCallList(Message response) {
+        mCi.getDataCallList(response);
+    }
+
+    @Override
+    public void updateServiceLocation() {
+        mSST.enableSingleLocationUpdate();
+    }
+
+    @Override
+    public void enableLocationUpdates() {
+        mSST.enableLocationUpdates();
+    }
+
+    @Override
+    public void disableLocationUpdates() {
+        mSST.disableLocationUpdates();
+    }
+
+    @Override
+    public boolean getDataRoamingEnabled() {
+        return mDcTracker.getDataOnRoamingEnabled();
+    }
+
+    @Override
+    public void setDataRoamingEnabled(boolean enable) {
+        mDcTracker.setDataOnRoamingEnabled(enable);
+    }
+
+    @Override
+    public void registerForCdmaOtaStatusChange(Handler h, int what, Object obj) {
+        mCi.registerForCdmaOtaProvision(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForCdmaOtaStatusChange(Handler h) {
+        mCi.unregisterForCdmaOtaProvision(h);
+    }
+
+    @Override
+    public void registerForSubscriptionInfoReady(Handler h, int what, Object obj) {
+        mSST.registerForSubscriptionInfoReady(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForSubscriptionInfoReady(Handler h) {
+        mSST.unregisterForSubscriptionInfoReady(h);
+    }
+
+    @Override
+    public void setOnEcbModeExitResponse(Handler h, int what, Object obj) {
+        mEcmExitRespRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unsetOnEcbModeExitResponse(Handler h) {
+        mEcmExitRespRegistrant.clear();
+    }
+
+    @Override
+    public void registerForCallWaiting(Handler h, int what, Object obj) {
+        mCT.registerForCallWaiting(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForCallWaiting(Handler h) {
+        mCT.unregisterForCallWaiting(h);
+    }
+
+    @Override
+    public boolean getDataEnabled() {
+        return mDcTracker.getDataEnabled();
+    }
+
+    @Override
+    public void setDataEnabled(boolean enable) {
+        mDcTracker.setDataEnabled(enable);
+    }
+
+    /**
+     * Removes the given MMI from the pending list and notifies
+     * registrants that it is complete.
+     * @param mmi MMI that is done
+     */
+    public void onMMIDone(MmiCode mmi) {
+        /* Only notify complete if it's on the pending list.
+         * Otherwise, it's already been handled (eg, previously canceled).
+         * The exception is cancellation of an incoming USSD-REQUEST, which is
+         * not on the list.
+         */
+        /// M: @{
+        Rlog.d(LOG_TAG, "onMMIDone: " + mmi);
+        dumpPendingMmi();
+        /// @}
+        if (mPendingMMIs.remove(mmi) || (isPhoneTypeGsm() && (mmi.isUssdRequest() ||
+                ((GsmMmiCode)mmi).isSsInfo()))) {
+            mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
+        }
+    }
+
+    /**
+     * Removes the given MMI from the pending list and notifies
+     * registrants that it is complete.
+     * @param mmi MMI that is done
+     * @param obj User object to deliver to application
+     */
+    public void onMMIDone(GsmMmiCode mmi, Object obj) {
+        /* Only notify complete if it's on the pending list.
+         * Otherwise, it's already been handled (eg, previously canceled).
+         * The exception is cancellation of an incoming USSD-REQUEST, which is
+         * not on the list.
+         */
+        /// M: @{
+        Rlog.d(LOG_TAG, "onMMIDone: " + mmi + ", obj=" + obj);
+        dumpPendingMmi();
+        /// @}
+        if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest() || mmi.isSsInfo()) {
+            mMmiCompleteRegistrants.notifyRegistrants(
+                    new AsyncResult(obj, mmi, null));
+        }
+    }
+    /// M: @{
+    public  void dumpPendingMmi() {
+        int size = mPendingMMIs.size();
+        if (size == 0) {
+            Rlog.d(LOG_TAG, "dumpPendingMmi: none");
+            return;
+        }
+        for (int i=0; i<size; i++) {
+            Rlog.d(LOG_TAG, "dumpPendingMmi: " + mPendingMMIs.get(i));
+        }
+    }
+    /// @}
+    private void onNetworkInitiatedUssd(MmiCode mmi) {
+        mMmiCompleteRegistrants.notifyRegistrants(
+            new AsyncResult(null, mmi, null));
+    }
+
+    /** ussdMode is one of CommandsInterface.USSD_MODE_* */
+    private void onIncomingUSSD (int ussdMode, String ussdMessage) {
+        if (!isPhoneTypeGsm()) {
+            loge("onIncomingUSSD: not expected on GSM");
+        }
+        boolean isUssdError;
+        boolean isUssdRequest;
+        boolean isUssdRelease;
+        boolean isUssdhandleByStk;
+
+        isUssdRequest
+            = (ussdMode == CommandsInterface.USSD_MODE_REQUEST);
+
+        // isUssdError
+        //     = (ussdMode != CommandsInterface.USSD_MODE_NOTIFY
+        //         && ussdMode != CommandsInterface.USSD_MODE_REQUEST);
+
+        /* M: SS part */
+        //MTK-START [mtk04070][111118][ALPS00093395]MTK modified
+        isUssdError
+            = ((ussdMode == CommandsInterface.USSD_OPERATION_NOT_SUPPORTED)
+               || (ussdMode == CommandsInterface.USSD_NETWORK_TIMEOUT));
+        //MTK-END [mtk04070][111118][ALPS00093395]MTK modified
+
+        isUssdhandleByStk
+            = (ussdMode == CommandsInterface.USSD_HANDLED_BY_STK);
+        /* M: SS part end */
+
+        isUssdRelease = (ussdMode == CommandsInterface.USSD_MODE_NW_RELEASE);
+
+
+        // See comments in GsmMmiCode.java
+        // USSD requests aren't finished until one
+        // of these two events happen
+        GsmMmiCode found = null;
+        Rlog.d(LOG_TAG, "USSD:mPendingMMIs= " + mPendingMMIs + " size=" + mPendingMMIs.size());
+        for (int i = 0, s = mPendingMMIs.size() ; i < s; i++) {
+            Rlog.d(LOG_TAG, "i= " + i + " isPending="
+                + ((GsmMmiCode)mPendingMMIs.get(i)).isPendingUSSD());
+            if(((GsmMmiCode)mPendingMMIs.get(i)).isPendingUSSD()) {
+                found = (GsmMmiCode)mPendingMMIs.get(i);
+                Rlog.d(LOG_TAG, "found = " + found);
+                break;
+            }
+        }
+
+        if (found != null) {
+            // Complete pending USSD
+            /* M: SS part */
+            //For ALPS01471897
+            Rlog.d(LOG_TAG, "setUserInitiatedMMI  TRUE");
+            found.setUserInitiatedMMI(true);
+            /* M: SS part end */
+            if (isUssdRelease && mIsNetworkInitiatedUssr) {
+                Rlog.d(LOG_TAG, "onIncomingUSSD(): USSD_MODE_NW_RELEASE.");
+                found.onUssdRelease();
+            } else if (isUssdError) {
+                found.onUssdFinishedError();
+            } else if (isUssdhandleByStk) {
+                found.onUssdStkHandling(ussdMessage, isUssdRequest);
+            } else {
+                found.onUssdFinished(ussdMessage, isUssdRequest);
+            }
+        } else { // pending USSD not found
+            // The network may initiate its own USSD request
+
+            // ignore everything that isnt a Notify or a Request
+            // also, discard if there is no message to present
+
+            /* M: SS part */
+            //For ALPS01471897
+            if (isUssdRequest) {
+                Rlog.d(LOG_TAG, "The default value of UserInitiatedMMI is FALSE");
+                mIsNetworkInitiatedUssr = true;
+                Rlog.d(LOG_TAG, "onIncomingUSSD(): Network Initialized USSD");
+            }
+
+            if (!isUssdError && ussdMessage != null) {
+                GsmMmiCode mmi;
+                mmi = GsmMmiCode.newNetworkInitiatedUssd(ussdMessage,
+                                                   isUssdRequest,
+                                                   GsmCdmaPhone.this,
+                                                   mUiccApplication.get());
+                onNetworkInitiatedUssd(mmi);
+
+            //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+            } else if (isUssdError) {
+                GsmMmiCode mmi;
+                mmi = GsmMmiCode.newNetworkInitiatedUssdError(ussdMessage,
+                                                   isUssdRequest,
+                                                   GsmCdmaPhone.this,
+                                                   mUiccApplication.get());
+                onNetworkInitiatedUssd(mmi);
+            //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+            }
+            /* M: SS part end */
+        }
+
+        /* M: SS part */
+        if (isUssdRelease || isUssdError) {
+            mIsNetworkInitiatedUssr = false;
+        }
+        /* M: SS part end */
+
+        // if (found != null) {
+        //     // Complete pending USSD
+
+        //     if (isUssdRelease) {
+        //         found.onUssdRelease();
+        //     } else if (isUssdError) {
+        //         found.onUssdFinishedError();
+        //     } else {
+        //         found.onUssdFinished(ussdMessage, isUssdRequest);
+        //     }
+        // } else { // pending USSD not found
+        //     // The network may initiate its own USSD request
+
+        //     // ignore everything that isnt a Notify or a Request
+        //     // also, discard if there is no message to present
+        //     if (!isUssdError && ussdMessage != null) {
+        //         GsmMmiCode mmi;
+        //         mmi = GsmMmiCode.newNetworkInitiatedUssd(ussdMessage,
+        //                                            isUssdRequest,
+        //                                            GsmCdmaPhone.this,
+        //                                            mUiccApplication.get());
+        //         onNetworkInitiatedUssd(mmi);
+        //     }
+        // }
+    }
+
+    /**
+     * Make sure the network knows our preferred setting.
+     */
+    private void syncClirSetting() {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        int clirSetting = sp.getInt(CLIR_KEY + getPhoneId(), -1);
+        if (clirSetting >= 0) {
+            mCi.setCLIR(clirSetting, null);
+        }
+    }
+
+    private void handleRadioAvailable() {
+        mCi.getBasebandVersion(obtainMessage(EVENT_GET_BASEBAND_VERSION_DONE));
+
+        if (isPhoneTypeGsm()) {
+            mCi.getIMEI(obtainMessage(EVENT_GET_IMEI_DONE));
+            mCi.getIMEISV(obtainMessage(EVENT_GET_IMEISV_DONE));
+        } else {
+            mCi.getDeviceIdentity(obtainMessage(EVENT_GET_DEVICE_IDENTITY_DONE));
+        }
+        mCi.getRadioCapability(obtainMessage(EVENT_GET_RADIO_CAPABILITY));
+        startLceAfterRadioIsAvailable();
+    }
+
+    private void handleRadioOn() {
+        /* Proactively query voice radio technologies */
+        mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
+
+        if (!isPhoneTypeGsm()) {
+            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
+        }
+
+        // If this is on APM off, SIM may already be loaded. Send setPreferredNetworkType
+        // request to RIL to preserve user setting across APM toggling
+        setPreferredNetworkTypeIfSimLoaded();
+    }
+
+    private void handleRadioOffOrNotAvailable() {
+        if (isPhoneTypeGsm()) {
+            // Some MMI requests (eg USSD) are not completed
+            // within the course of a CommandsInterface request
+            // If the radio shuts off or resets while one of these
+            // is pending, we need to clean up.
+
+            for (int i = mPendingMMIs.size() - 1; i >= 0; i--) {
+                if (((GsmMmiCode) mPendingMMIs.get(i)).isPendingUSSD()) {
+                    ((GsmMmiCode) mPendingMMIs.get(i)).onUssdFinishedError();
+                }
+            }
+        }
+        Phone imsPhone = mImsPhone;
+        if (imsPhone != null) {
+            /// M: Set service state when WFC is not enabled @{
+            // imsPhone.getServiceState().setStateOff();
+            if (imsPhone.isWifiCallingEnabled() == false) {
+                /// M: ALPS01973935.
+                imsPhone.getServiceState().setState(ServiceState.STATE_OUT_OF_SERVICE);
+            }
+            /// @}
+        }
+        mRadioOffOrNotAvailableRegistrants.notifyRegistrants();
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        Message onComplete;
+
+        switch (msg.what) {
+            case EVENT_RADIO_AVAILABLE: {
+                handleRadioAvailable();
+            }
+            break;
+
+            case EVENT_GET_DEVICE_IDENTITY_DONE:{
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    setDeviceIdAbnormal(1);
+                    Rlog.e(LOG_TAG, "Invalid Device Id");
+                    break;
+                }
+                String[] respId = (String[])ar.result;
+                mImei = respId[0];
+                mImeiSv = respId[1];
+                mEsn  =  respId[2];
+                mMeid =  respId[3];
+                setDeviceIdAbnormal(0);
+            }
+            break;
+
+            case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:{
+                handleEnterEmergencyCallbackMode(msg);
+            }
+            break;
+
+            case  EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:{
+                handleExitEmergencyCallbackMode(msg);
+            }
+            break;
+
+            case EVENT_RUIM_RECORDS_LOADED:
+                logd("Event EVENT_RUIM_RECORDS_LOADED Received");
+                updateCurrentCarrierInProvider();
+                break;
+
+            case EVENT_RADIO_ON:
+                logd("Event EVENT_RADIO_ON Received");
+                handleRadioOn();
+                break;
+
+            case EVENT_RIL_CONNECTED:
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception == null && ar.result != null) {
+                    mRilVersion = (Integer) ar.result;
+                } else {
+                    logd("Unexpected exception on EVENT_RIL_CONNECTED");
+                    mRilVersion = -1;
+                }
+                break;
+
+            case EVENT_VOICE_RADIO_TECH_CHANGED:
+            case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
+                String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ?
+                        "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception == null) {
+                    if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
+                        int newVoiceTech = ((int[]) ar.result)[0];
+                        logd(what + ": newVoiceTech=" + newVoiceTech);
+                        phoneObjectUpdater(newVoiceTech);
+                    } else {
+                        loge(what + ": has no tech!");
+                    }
+                } else {
+                    loge(what + ": exception=" + ar.exception);
+                }
+                break;
+
+            case EVENT_UPDATE_PHONE_OBJECT:
+                phoneObjectUpdater(msg.arg1);
+                break;
+
+            case EVENT_CARRIER_CONFIG_CHANGED:
+                // Only check for the voice radio tech if it not going to be updated by the voice
+                // registration changes.
+                if (!mContext.getResources().getBoolean(com.android.internal.R.bool.
+                        config_switch_phone_on_voice_reg_state_change)) {
+                    mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
+                }
+                // Force update IMS service
+                ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
+
+                // Update broadcastEmergencyCallStateChanges
+                CarrierConfigManager configMgr = (CarrierConfigManager)
+                        getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+                PersistableBundle b = configMgr.getConfigForSubId(getSubId());
+                if (b != null) {
+                    boolean broadcastEmergencyCallStateChanges = b.getBoolean(
+                            CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
+                    logd("broadcastEmergencyCallStateChanges = " +
+                            broadcastEmergencyCallStateChanges);
+                    setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
+                } else {
+                    loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
+                }
+
+                // Changing the cdma roaming settings based carrier config.
+                if (b != null) {
+                    int config_cdma_roaming_mode = b.getInt(
+                            CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
+                    int current_cdma_roaming_mode =
+                            Settings.Global.getInt(getContext().getContentResolver(),
+                            Settings.Global.CDMA_ROAMING_MODE,
+                            CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
+                    switch (config_cdma_roaming_mode) {
+                        // Carrier's cdma_roaming_mode will overwrite the user's previous settings
+                        // Keep the user's previous setting in global variable which will be used
+                        // when carrier's setting is turn off.
+                        case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
+                        case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
+                        case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
+                            logd("cdma_roaming_mode is going to changed to "
+                                    + config_cdma_roaming_mode);
+                            setCdmaRoamingPreference(config_cdma_roaming_mode,
+                                    obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
+                            break;
+
+                        // When carrier's setting is turn off, change the cdma_roaming_mode to the
+                        // previous user's setting
+                        case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
+                            if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
+                                logd("cdma_roaming_mode is going to changed to "
+                                        + current_cdma_roaming_mode);
+                                setCdmaRoamingPreference(current_cdma_roaming_mode,
+                                        obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
+                            }
+
+                        default:
+                            loge("Invalid cdma_roaming_mode settings: "
+                                    + config_cdma_roaming_mode);
+                    }
+                } else {
+                    loge("didn't get the cdma_roaming_mode changes from the carrier config.");
+                }
+
+                // Load the ERI based on carrier config. Carrier might have their specific ERI.
+                prepareEri();
+                if (!isPhoneTypeGsm()) {
+                    mSST.pollState();
+                }
+
+                break;
+
+            case EVENT_SET_ROAMING_PREFERENCE_DONE:
+                logd("cdma_roaming_mode change is done");
+                break;
+
+            case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
+                logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
+                mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
+                break;
+
+            case EVENT_REGISTERED_TO_NETWORK:
+                logd("Event EVENT_REGISTERED_TO_NETWORK Received");
+                if (isPhoneTypeGsm()) {
+                    syncClirSetting();
+                }
+                /// M: To query CFU @{
+                if (isNotSupportUtToCS()) {
+                     /* Delay to wait CT USIM becoming ready and loaded, about 10s */
+                    sendMessageDelayed(obtainMessage(EVENT_QUERY_CFU), 10000);
+                } else {
+                    sendMessage(obtainMessage(EVENT_QUERY_CFU));
+                }
+                /// @}
+                break;
+
+            /* M: SS part */
+            case EVENT_QUERY_CFU: // fallback from EVENT_REGISTERED_TO_NETWORK
+                boolean checkEQC = checkEventQueryCfuReady();
+                Rlog.d(LOG_TAG, "Receive EVENT_QUERY_CFU phoneid: " + getPhoneId() +
+                    " , needQueryCfu: " + needQueryCfu +
+                    " , checkEventQueryCfuReady: " + checkEQC);
+                if (needQueryCfu && checkEQC) {
+                    String defaultQueryCfuMode = PhoneConstants.CFU_QUERY_TYPE_DEF_VALUE;
+                    if (mSupplementaryServiceExt != null) {
+                        defaultQueryCfuMode =
+                            mSupplementaryServiceExt.getOpDefaultQueryCfuMode();
+                        Rlog.d(LOG_TAG, "defaultQueryCfuMode = " + defaultQueryCfuMode);
+                    }
+                    String cfuSetting;
+                    if (!TelephonyManager.from(mContext).isVoiceCapable()) {
+                        // disable CFU query for non voice capable devices (i.e. tablet devices)
+                        cfuSetting = SystemProperties.get(PhoneConstants.CFU_QUERY_TYPE_PROP, "1");
+                    } else {
+                        cfuSetting = SystemProperties.get(PhoneConstants.CFU_QUERY_TYPE_PROP,
+                                defaultQueryCfuMode);
+                    }
+                    String isTestSim = "0";
+                    /// M: Add for CMCC RRM test. @{
+                    boolean isRRMEnv = false;
+                    String operatorNumeric = null;
+                    /// @}
+                    if (mPhoneId == PhoneConstants.SIM_ID_1) {
+                        isTestSim = SystemProperties.get("gsm.sim.ril.testsim", "0");
+                    }
+                    else if (mPhoneId == PhoneConstants.SIM_ID_2) {
+                        isTestSim = SystemProperties.get("gsm.sim.ril.testsim.2", "0");
+                    }
+
+                    /// M: Add for CMCC RRM test. @{
+                    // RRM test use 46602 as PLMN, which will not appear in the actual network
+                    // Note that this should be modified when the PLMN for RRM test is changed
+                    operatorNumeric = getServiceState().getOperatorNumeric();
+                    if (operatorNumeric != null && operatorNumeric.equals("46602")) {
+                        isRRMEnv = true;
+                    }
+                    /// @}
+                    Rlog.d(LOG_TAG, "[GSMPhone] CFU_KEY = " + cfuSetting + " isTestSIM : " +
+                        isTestSim + " isRRMEnv : " + isRRMEnv + " phoneid: " + getPhoneId());
+
+                    if (isTestSim.equals("0") && isRRMEnv == false) { /// M: Add for CMCC RRM test.
+                        String isChangedProp = CFU_QUERY_SIM_CHANGED_PROP + getPhoneId();
+                        String isChanged = SystemProperties.get(isChangedProp, "0");
+
+                        Rlog.d(LOG_TAG, "[GSMPhone] isChanged " + isChanged);
+                        // 0 : default
+                        // 1 : OFF
+                        // 2 : ON
+                        if (cfuSetting.equals("2")
+                            || (cfuSetting.equals("0") && isChanged.equals("1"))) {
+                            /* For solving ALPS01023811 */
+                            mCfuQueryRetryCount = 0;
+                            queryCfuOrWait();
+                            needQueryCfu = false;
+                            SystemProperties.set(isChangedProp, "0");
+                        } else {
+                            needQueryCfu = false;
+
+                            IccRecords record = mIccRecords.get();
+                            /* Only when EfCfis is not valid, we refer the system property*/
+                            if ((record != null && (record instanceof SIMRecords) &&
+                                    !((SIMRecords)record).checkEfCfis()) ||
+                                    (isNotSupportUtToCS() && getPhoneType() ==
+                                    PhoneConstants.PHONE_TYPE_CDMA)) {
+                                String utCfuMode = getSystemProperty(
+                                        PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                        UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                                Rlog.d(LOG_TAG, "utCfuMode: " + utCfuMode);
+                                if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                                    setVoiceCallForwardingFlag(1, true, "");
+                                } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                                    setVoiceCallForwardingFlag(1, false, "");
+                                }
+                            }
+                        }
+                    } else {
+                        needQueryCfu = false;
+
+                        IccRecords record = mIccRecords.get();
+                        /* Only when EfCfis is not valid, we refer the system property*/
+                        if ((record != null && (record instanceof SIMRecords) &&
+                                !((SIMRecords)record).checkEfCfis()) ||
+                                (isNotSupportUtToCS() && getPhoneType() ==
+                                PhoneConstants.PHONE_TYPE_CDMA)) {
+                            String utCfuMode = getSystemProperty(
+                                    PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                    UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                            Rlog.d(LOG_TAG, "utCfuMode: " + utCfuMode);
+                            if (UT_CFU_NOTIFICATION_MODE_ON.equals(utCfuMode)) {
+                                setVoiceCallForwardingFlag(1, true, "");
+                            } else if (UT_CFU_NOTIFICATION_MODE_OFF.equals(utCfuMode)) {
+                                setVoiceCallForwardingFlag(1, false, "");
+                            }
+                        }
+                    }
+                }
+                /* M: SS part end */
+                break;
+
+            case EVENT_SIM_RECORDS_LOADED:
+                if (isPhoneTypeGsm()) {
+                    updateCurrentCarrierInProvider();
+
+                    // Check if this is a different SIM than the previous one. If so unset the
+                    // voice mail number.
+                    String imsi = getVmSimImsi();
+                    String imsiFromSIM = getSubscriberId();
+                    if (imsi != null && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
+                        storeVoiceMailNumber(null);
+                        setVmSimImsi(null);
+                    }
+                    Log.d(LOG_TAG,"EVENT_SIM_RECORDS_LOADED");
+                    updateVoiceMail();
+                }
+
+                mSimRecordsLoadedRegistrants.notifyRegistrants();
+                break;
+
+            case EVENT_GET_BASEBAND_VERSION_DONE:
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                if (DBG) logd("Baseband version: " + ar.result);
+                TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(),
+                        (String)ar.result);
+            break;
+
+            case EVENT_GET_IMEI_DONE:
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    Rlog.e(LOG_TAG, "Invalid DeviceId (IMEI)");
+                    setDeviceIdAbnormal(1);
+                    break;
+                }
+
+                mImei = (String)ar.result;
+                Rlog.d(LOG_TAG, "IMEI: ****" + mImei.substring(10));
+
+                try {
+                    Long.parseLong(mImei);
+                    setDeviceIdAbnormal(0);
+                } catch (NumberFormatException e) {
+                    setDeviceIdAbnormal(1);
+                    Rlog.e(LOG_TAG, "Invalid DeviceId (IMEI) Format: " + e.toString() + ")");
+                }
+            break;
+
+            case EVENT_GET_IMEISV_DONE:
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mImeiSv = (String)ar.result;
+            break;
+
+            case EVENT_USSD:
+                ar = (AsyncResult)msg.obj;
+
+                String[] ussdResult = (String[]) ar.result;
+
+                if (ussdResult.length > 1) {
+                    try {
+                        onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
+                    } catch (NumberFormatException e) {
+                        Rlog.w(LOG_TAG, "error parsing USSD");
+                    }
+                }
+            break;
+
+            case EVENT_RADIO_OFF_OR_NOT_AVAILABLE: {
+                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
+                handleRadioOffOrNotAvailable();
+                break;
+            }
+
+            case EVENT_SSN:
+                logd("Event EVENT_SSN Received");
+                if (isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    SuppServiceNotification not = (SuppServiceNotification) ar.result;
+                   /// M: CC: Proprietary CRSS handling @{
+                    if (mSsnRegistrants.size() == 0) {
+                        mCachedSsn = ar;
+                    }
+                    /// @}
+                    mSsnRegistrants.notifyRegistrants(ar);
+                }
+                break;
+
+            case EVENT_SET_CALL_FORWARD_DONE:
+                /// M: 93 Ims SS native solution @{
+                if (is93MDSupport()) {
+                    ar = (AsyncResult)msg.obj;
+                    IccRecords r = mIccRecords.get();
+                    Cfu cfu = (Cfu) ar.userObj;
+                    if (ar.exception == null && r != null) {
+                        setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE, msg.arg1 == 1 ?
+                                 UT_CFU_NOTIFICATION_MODE_ON : UT_CFU_NOTIFICATION_MODE_OFF);
+                    }
+                    if (cfu.mOnComplete != null) {
+                        AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
+                        cfu.mOnComplete.sendToTarget();
+                    }
+                    break;
+                }
+                /// @}
+
+                ar = (AsyncResult)msg.obj;
+                IccRecords r = mIccRecords.get();
+                Cfu cfu = (Cfu) ar.userObj;
+                if (ar.exception == null && r != null) {
+                    //only CFU would go in this case.
+                    //because only CFU use EVENT_SET_CALL_FORWARD_DONE.
+                    //So no need to check it is for CFU.
+                    if (queryCFUAgainAfterSet()) {
+                        if (ar.result != null) {
+                            CallForwardInfo[] cfinfo = (CallForwardInfo[]) ar.result;
+                            if (cfinfo == null || cfinfo.length == 0) {
+                                Rlog.d(LOG_TAG, "cfinfo is null or length is 0.");
+                            } else {
+                                Rlog.d(LOG_TAG, "[EVENT_SET_CALL_FORWARD_DONE check cfinfo");
+                                for (int i = 0 ; i < cfinfo.length ; i++) {
+                                    if ((cfinfo[i].serviceClass & SERVICE_CLASS_VOICE) != 0) {
+                                        setVoiceCallForwardingFlag(1, (cfinfo[i].status == 1),
+                                            cfinfo[i].number);
+                                        break;
+                                    }
+                                }
+                            }
+                        } else {
+                            Rlog.e(LOG_TAG, "EVENT_SET_CALL_FORWARD_DONE: ar.result is null.");
+                        }
+                    } else {
+                        setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
+                    }
+                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE, msg.arg1 == 1 ?
+                            UT_CFU_NOTIFICATION_MODE_ON : UT_CFU_NOTIFICATION_MODE_OFF);
+                }
+                if ((ar.exception != null) && (msg.arg2 != 0)) {
+                    if (msg.arg2 == 1) {
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_ON);
+                    } else {
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_OFF);
+                    }
+                }
+                if (cfu.mOnComplete != null) {
+                    AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
+                    cfu.mOnComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_CALL_WAITING_DONE:
+                ar = (AsyncResult) msg.obj;
+                Rlog.d(LOG_TAG, "[EVENT_GET_CALL_WAITING_]ar.exception = " + ar.exception);
+
+                onComplete = (Message) ar.userObj;
+                if (ar.exception == null) {
+                    int[] cwArray = (int[]) ar.result;
+                    // If cwArray[0] is = 1, then cwArray[1] must follow,
+                    // with the TS 27.007 service class bit vector of services
+                    // for which call waiting is enabled.
+                    try {
+                        Rlog.d(LOG_TAG, "EVENT_GET_CALL_WAITING_DONE cwArray[0]:cwArray[1] = "
+                                + cwArray[0] + ":" + cwArray[1]);
+
+                        boolean csEnable = ((cwArray[0] == 1) &&
+                            ((cwArray[1] & 0x01) == SERVICE_CLASS_VOICE));
+
+                        setTerminalBasedCallWaiting(csEnable, null);
+
+                        if (onComplete != null) {
+                            AsyncResult.forMessage(onComplete, ar.result, null);
+                            onComplete.sendToTarget();
+                            break;
+                        }
+                    } catch (ArrayIndexOutOfBoundsException e) {
+                        Rlog.e(LOG_TAG, "EVENT_GET_CALL_WAITING_DONE: improper result: err ="
+                                + e.getMessage());
+                        if (onComplete != null) {
+                            AsyncResult.forMessage(onComplete, ar.result, null);
+                            onComplete.sendToTarget();
+                            break;
+                        }
+                    }
+                } else {
+                    if (onComplete != null) {
+                        AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                        onComplete.sendToTarget();
+                        break;
+                    }
+                }
+                break;
+
+            case EVENT_SET_CALL_WAITING_DONE:
+                ar = (AsyncResult) msg.obj;
+                onComplete = (Message) ar.userObj;
+
+                if (ar.exception != null) {
+                    Rlog.d(LOG_TAG, "EVENT_SET_CALL_WAITING_DONE: ar.exception=" + ar.exception);
+
+                    if (onComplete != null) {
+                        AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                        onComplete.sendToTarget();
+                        break;
+                    }
+                } else {
+                    boolean enable = msg.arg1 == 1 ? true : false;
+                    setTerminalBasedCallWaiting(enable, onComplete);
+                }
+                break;
+
+            case EVENT_SET_VM_NUMBER_DONE:
+                ar = (AsyncResult)msg.obj;
+                if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) ||
+                        (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))){
+                    storeVoiceMailNumber(mVmNumber);
+                    ar.exception = null;
+                }
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+
+            case EVENT_GET_CALL_FORWARD_DONE:
+                /* M: SS part */ //TODO need check mPhoneID
+                /* For solving ALPS00997715 */
+                Rlog.d(LOG_TAG, "mPhoneId= " + mPhoneId + "subId=" + getSubId());
+                setSystemProperty(CFU_QUERY_PROPERTY_NAME + mPhoneId, "0");
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    if((ar.result == null) || (ar.result instanceof CallForwardInfo[])) {
+                        handleCfuQueryResult((CallForwardInfo[])ar.result);
+                    }
+                }
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_SET_NETWORK_AUTOMATIC:
+                // Automatic network selection from EF_CSP SIM record
+                ar = (AsyncResult) msg.obj;
+                if (mSST.mSS.getIsManualSelection()) {
+                    setNetworkSelectionModeAutomatic((Message) ar.result);
+                    logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
+                } else {
+                    // prevent duplicate request which will push current PLMN to low priority
+                    logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
+                }
+                break;
+
+            case EVENT_ICC_RECORD_EVENTS:
+                Rlog.d(LOG_TAG, "EVENT_ICC_RECORD_EVENTS");
+                ar = (AsyncResult)msg.obj;
+                processIccRecordEvents((Integer)ar.result);
+                break;
+
+            case EVENT_SET_CLIR_COMPLETE:
+                Rlog.d(LOG_TAG, "EVENT_SET_CLIR_COMPLETE");
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    saveClirSetting(msg.arg1);
+                }
+
+                if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                    CommandException cmdException = (CommandException) ar.exception;
+                    Rlog.d(LOG_TAG, "EVENT_SET_CLIR_COMPLETE: cmdException error:" +
+                            cmdException.getCommandError());
+
+                    if (is93MDSupport() && (isOp(OPID.OP01) || isOp(OPID.OP02))) {
+                        if (cmdException != null) {
+                            if (isUtError(cmdException.getCommandError())) {
+                                Rlog.d(LOG_TAG, "return SPECAIL_UT_COMMAND_NOT_SUPPORTED");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                            } else {
+                                Rlog.d(LOG_TAG, "return Original Error");
+                            }
+                        }
+                    }
+                }
+
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_CLIR_COMPLETE:
+                Rlog.d(LOG_TAG, "EVENT_GET_CLIR_COMPLETE");
+                ar = (AsyncResult)msg.obj;
+
+                if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                    CommandException cmdException = (CommandException) ar.exception;
+                    Rlog.d(LOG_TAG, "EVENT_GET_CLIR_COMPLETE: cmdException error:" +
+                            cmdException.getCommandError());
+
+                    if (is93MDSupport()) {
+
+                        // OP01, OP02 specific grey out logic
+                        if ((isOp(OPID.OP01) || isOp(OPID.OP02))) {
+                            if (cmdException != null) {
+                                if (isUtError(cmdException.getCommandError())) {
+                                    Rlog.d(LOG_TAG, "return SPECAIL_UT_COMMAND_NOT_SUPPORTED");
+                                    ar.exception = new CommandException(
+                                            CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                                } else {
+                                    Rlog.d(LOG_TAG, "return Original Error");
+                                }
+                            }
+                        }
+
+                        // Terminal based will return 832 error cause in 93
+                        if (cmdException.getCommandError() == CommandException.Error.OEM_ERROR_7) {
+                            // Directly query share preference to decide display status
+                            int[] result = getSavedClirSetting();
+                            Rlog.d(LOG_TAG, "Terminal based and getSavedClirSetting:" +
+                                    Arrays.toString(result));
+
+                            onComplete = (Message) ar.userObj;
+                            if (onComplete != null) {
+                                AsyncResult.forMessage(onComplete, result, null);
+                                onComplete.sendToTarget();
+                            }
+                            break;
+                        }
+                    }
+                }
+
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_SET_FACILITY_LOCK_COMPLETE:
+                Rlog.d(LOG_TAG, "EVENT_SET_FACILITY_LOCK_COMPLETE");
+                ar = (AsyncResult)msg.obj;
+
+                if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                    CommandException cmdException = (CommandException) ar.exception;
+                    Rlog.d(LOG_TAG, "EVENT_SET_FACILITY_LOCK_COMPLETE: cmdException error:" +
+                            cmdException.getCommandError());
+
+                    if (is93MDSupport() && isOp(OPID.OP01)) {
+                        if (cmdException != null) {
+                            if (isUtError(cmdException.getCommandError())) {
+                                Rlog.d(LOG_TAG, "return SPECAIL_UT_COMMAND_NOT_SUPPORTED");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                            } else {
+                                Rlog.d(LOG_TAG, "return Original Error");
+                            }
+                        }
+                    }
+                }
+
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_FACILITY_LOCK_COMPLETE:
+                Rlog.d(LOG_TAG, "EVENT_GET_FACILITY_LOCK_COMPLETE");
+                ar = (AsyncResult)msg.obj;
+
+                if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                    CommandException cmdException = (CommandException) ar.exception;
+                    Rlog.d(LOG_TAG, "EVENT_GET_FACILITY_LOCK_COMPLETE: cmdException error:" +
+                            cmdException.getCommandError());
+
+                    if (is93MDSupport() && (isOp(OPID.OP01) || isOp(OPID.OP09))) {
+                        if (cmdException != null) {
+                            if (isUtError(cmdException.getCommandError())) {
+                                Rlog.d(LOG_TAG, "return SPECAIL_UT_COMMAND_NOT_SUPPORTED");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                            } else {
+                                Rlog.d(LOG_TAG, "return Original Error");
+                            }
+                        }
+                    }
+                }
+
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_SS:
+                ar = (AsyncResult)msg.obj;
+                logd("Event EVENT_SS received");
+                if (isPhoneTypeGsm()) {
+                    // SS data is already being handled through MMI codes.
+                    // So, this result if processed as MMI response would help
+                    // in re-using the existing functionality.
+                    GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
+                    mmi.processSsData(ar);
+                }
+                break;
+
+            case EVENT_GET_RADIO_CAPABILITY:
+                ar = (AsyncResult) msg.obj;
+                RadioCapability rc = (RadioCapability) ar.result;
+                if (ar.exception != null) {
+                    Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " +
+                            "mRadioCapability");
+                } else {
+                    radioCapabilityUpdated(rc);
+                }
+                Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
+                break;
+
+            /// M:
+            case EVENT_IMS_UT_DONE:
+                Rlog.d(LOG_TAG, "EVENT_IMS_UT_DONE: Enter");
+                ar = (AsyncResult) msg.obj;
+                if (ar == null) {
+                    Rlog.e(LOG_TAG, "EVENT_IMS_UT_DONE: Error AsyncResult null!");
+                } else {
+                    SuppSrvRequest ss = (SuppSrvRequest) ar.userObj;
+                    if (ss == null) {
+                        Rlog.e(LOG_TAG, "EVENT_IMS_UT_DONE: Error SuppSrvRequest null!");
+                    } else if (SuppSrvRequest.SUPP_SRV_REQ_SET_CF_IN_TIME_SLOT
+                            == ss.getRequestCode()) {
+                        if (ar.exception == null) {
+                            ss.mParcel.setDataPosition(0);
+                            Rlog.d(LOG_TAG, "EVENT_IMS_UT_DONE: SUPP_SRV_REQ_SET_CF_IN_TIME_SLOT");
+                            int commandInterfaceCFAction = ss.mParcel.readInt();
+                            int commandInterfaceCFReason = ss.mParcel.readInt();
+                            String dialingNumber = ss.mParcel.readString();
+                            if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                                if (isCfEnable(commandInterfaceCFAction)) {
+                                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                            UT_CFU_NOTIFICATION_MODE_ON);
+                                } else {
+                                    setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                            UT_CFU_NOTIFICATION_MODE_OFF);
+                                }
+                            }
+                        }
+                        onComplete = ss.getResultCallback();
+                        if (onComplete != null) {
+                            AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                            onComplete.sendToTarget();
+                        }
+                        ss.mParcel.recycle();
+                    } else {
+                        CommandException cmdException = null;
+                        ImsException imsException = null;
+                        if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                            cmdException = (CommandException) ar.exception;
+                            Rlog.d(LOG_TAG, "EVENT_IMS_UT_DONE: cmdException error:" +
+                                    cmdException.getCommandError());
+                        }
+                        if ((ar.exception != null) && (ar.exception instanceof ImsException)) {
+                            imsException = (ImsException) ar.exception;
+                            Rlog.d(LOG_TAG, "EVENT_IMS_UT_DONE: ImsException code:" +
+                                    imsException.getCode());
+                        }
+                        if ((cmdException != null) && (cmdException.getCommandError()
+                                == CommandException.Error.UT_XCAP_403_FORBIDDEN)) {
+                            setCsFallbackStatus(PhoneConstants.UT_CSFB_UNTIL_NEXT_BOOT);
+                            if (isNotSupportUtToCS()) {
+                                Rlog.d(LOG_TAG, "UT_XCAP_403_FORBIDDEN.");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                                onComplete = ss.getResultCallback();
+                                if (onComplete != null) {
+                                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                                    onComplete.sendToTarget();
+                                }
+                                ss.mParcel.recycle();
+                            } else {
+                                Rlog.d(LOG_TAG, "Csfallback next_reboot.");
+                                Message msgCSFB = obtainMessage(EVENT_IMS_UT_CSFB, ss);
+                                sendMessage(msgCSFB);
+                            }
+                        } else if ((cmdException != null) && (cmdException.getCommandError()
+                                == CommandException.Error.UT_UNKNOWN_HOST)) {
+                            if (isNotSupportUtToCS()) {
+                                Rlog.d(LOG_TAG, "CommandException.Error.UT_UNKNOWN_HOST.");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                                onComplete = ss.getResultCallback();
+                                if (onComplete != null) {
+                                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                                    onComplete.sendToTarget();
+                                }
+                                ss.mParcel.recycle();
+                            } else {
+                                Rlog.d(LOG_TAG, "Csfallback once.");
+                                setCsFallbackStatus(PhoneConstants.UT_CSFB_ONCE);
+                                Message msgCSFB = obtainMessage(EVENT_IMS_UT_CSFB, ss);
+                                sendMessage(msgCSFB);
+                            }
+                        } else if ((imsException != null) && (imsException.getCode()
+                                == ImsReasonInfo.CODE_UT_XCAP_403_FORBIDDEN)) {
+                            setCsFallbackStatus(PhoneConstants.UT_CSFB_UNTIL_NEXT_BOOT);
+                            if (isNotSupportUtToCS()) {
+                                Rlog.d(LOG_TAG, "ImsReasonInfo.CODE_UT_XCAP_403_FORBIDDEN.");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                                onComplete = ss.getResultCallback();
+                                if (onComplete != null) {
+                                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                                    onComplete.sendToTarget();
+                                }
+                                ss.mParcel.recycle();
+                            }  else {
+                                Rlog.d(LOG_TAG, "Csfallback next_reboot.");
+                                Message msgCSFB = obtainMessage(EVENT_IMS_UT_CSFB, ss);
+                                sendMessage(msgCSFB);
+                            }
+                        } else if ((imsException != null) && (imsException.getCode()
+                                == ImsReasonInfo.CODE_UT_UNKNOWN_HOST)) {
+                            if (isNotSupportUtToCS()) {
+                                Rlog.d(LOG_TAG, "CommandException.Error.UT_UNKNOWN_HOST.");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_403_FORBIDDEN);
+                                onComplete = ss.getResultCallback();
+                                if (onComplete != null) {
+                                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                                    onComplete.sendToTarget();
+                                }
+                                ss.mParcel.recycle();
+                            } else {
+                                Rlog.d(LOG_TAG, "Csfallback once.");
+                                setCsFallbackStatus(PhoneConstants.UT_CSFB_ONCE);
+                                Message msgCSFB = obtainMessage(EVENT_IMS_UT_CSFB, ss);
+                                sendMessage(msgCSFB);
+                            }
+                        } else {
+                            if ((ar.exception == null) &&
+                                    (SuppSrvRequest.SUPP_SRV_REQ_SET_CF == ss.getRequestCode())) {
+                                ss.mParcel.setDataPosition(0);
+                                Rlog.d(LOG_TAG, "EVENT_IMS_UT_DONE: SUPP_SRV_REQ_SET_CF");
+                                int commandInterfaceCFAction = ss.mParcel.readInt();
+                                int commandInterfaceCFReason = ss.mParcel.readInt();
+                                String dialingNumber = ss.mParcel.readString();
+                                if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                                    if (queryCFUAgainAfterSet()) {
+                                        if (ar.result != null) {
+                                            CallForwardInfo[] cfinfo =
+                                                (CallForwardInfo[]) ar.result;
+
+                                            if (cfinfo == null || cfinfo.length == 0) {
+                                                Rlog.d(LOG_TAG, "cfinfo is null or 0.");
+                                            } else {
+                                                for (int i = 0 ; i < cfinfo.length ; i++) {
+                                                    if ((cfinfo[i].serviceClass
+                                                        & SERVICE_CLASS_VOICE) != 0) {
+                                                        if (cfinfo[i].status == 1) {
+                                                            Rlog.d(LOG_TAG,
+                                                                "Set enable, serviceClass: "
+                                                                + cfinfo[i].serviceClass);
+                                                            setSystemProperty(
+                                                                PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                                                UT_CFU_NOTIFICATION_MODE_ON);
+                                                        } else {
+                                                            Rlog.d(LOG_TAG,
+                                                                "Set disable, serviceClass: "
+                                                                + cfinfo[i].serviceClass);
+                                                            setSystemProperty(
+                                                                PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                                                UT_CFU_NOTIFICATION_MODE_OFF);
+                                                        }
+                                                        break;
+                                                    }
+                                                }
+                                            }
+                                        } else {
+                                            Rlog.d(LOG_TAG, "ar.result is null.");
+                                        }
+                                    } else {
+                                        if (isCfEnable(commandInterfaceCFAction)) {
+                                            setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                                    UT_CFU_NOTIFICATION_MODE_ON);
+                                        } else {
+                                            setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                                    UT_CFU_NOTIFICATION_MODE_OFF);
+                                        }
+                                    }
+                                }
+                            } else if ((imsException != null) && (imsException.getCode()
+                                    == ImsReasonInfo.CODE_UT_XCAP_404_NOT_FOUND)) {
+                                // Only consider CB && op05 and response 404 status.
+                                // Get it from ImsPhone.java
+                                // if not CB && op05, then transfer to GENERIC_FAILURE
+                                if (isOpTransferXcap404()
+                                    && (ss.getRequestCode() == SuppSrvRequest.SUPP_SRV_REQ_GET_CB
+                                    || ss.getRequestCode() == SuppSrvRequest.SUPP_SRV_REQ_SET_CB)) {
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_404_NOT_FOUND);
+                                } else {
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.GENERIC_FAILURE);
+                                }
+                            } else if ((cmdException != null) && (cmdException.getCommandError()
+                                == CommandException.Error.UT_XCAP_404_NOT_FOUND)) {
+                                // Only consider CB && op05 and response 404 status.
+                                // Get it from ImsPhone.java
+                                // if not CB && op05, then transfer to GENERIC_FAILURE
+                                if (isOpTransferXcap404()
+                                    && (ss.getRequestCode() == SuppSrvRequest.SUPP_SRV_REQ_GET_CB
+                                    || ss.getRequestCode() == SuppSrvRequest.SUPP_SRV_REQ_SET_CB)) {
+                                    Rlog.d(LOG_TAG, "GSMPhone get UT_XCAP_404_NOT_FOUND.");
+                                } else {
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.GENERIC_FAILURE);
+                                }
+                            } else if ((imsException != null) && (imsException.getCode()
+                                    == ImsReasonInfo.CODE_UT_XCAP_409_CONFLICT)) {
+                                if (!isEnableXcapHttpResponse409()) {
+                                    // Transfer back to gereric failure.
+                                    Rlog.d(LOG_TAG, "GSMPhone get UT_XCAP_409_CONFLICT, " +
+                                        "return GENERIC_FAILURE");
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.GENERIC_FAILURE);
+                                } else {
+                                    Rlog.d(LOG_TAG, "GSMPhone get UT_XCAP_409_CONFLICT.");
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.UT_XCAP_409_CONFLICT);
+                                }
+                            } else if ((cmdException != null) && (cmdException.getCommandError()
+                                == CommandException.Error.UT_XCAP_409_CONFLICT)) {
+                                if (!isEnableXcapHttpResponse409()) {
+                                    // Transfer back to gereric failure.
+                                    Rlog.d(LOG_TAG, "GSMPhone get UT_XCAP_409_CONFLICT, " +
+                                        "return GENERIC_FAILURE");
+                                    ar.exception = new CommandException(
+                                        CommandException.Error.GENERIC_FAILURE);
+                                } else {
+                                    Rlog.d(LOG_TAG, "GSMPhone get UT_XCAP_409_CONFLICT.");
+                                }
+                            }
+
+                            onComplete = ss.getResultCallback();
+                            if (onComplete != null) {
+                                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                                onComplete.sendToTarget();
+                            }
+                            ss.mParcel.recycle();
+                        }
+                    }
+                }
+                break;
+
+            case EVENT_IMS_UT_CSFB:
+                handleImsUtCsfb(msg);
+                break;
+            case EVENT_USSI_CSFB:
+                handleUssiCsfb((String)msg.obj);
+                break;
+            ///@}
+
+            /// M: SS OP01 Ut @{
+            case EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE:
+                Rlog.d(LOG_TAG, "mPhoneId = " + mPhoneId + ", subId = " + getSubId());
+                setSystemProperty(CFU_QUERY_PROPERTY_NAME + mPhoneId, "0");
+                ar = (AsyncResult) msg.obj;
+                Rlog.d(LOG_TAG, "[EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE]ar.exception = "
+                        + ar.exception);
+                if (ar.exception == null) {
+                    handleCfuInTimeSlotQueryResult((CallForwardInfoEx[]) ar.result);
+                }
+                Rlog.d(LOG_TAG, "[EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE]msg.arg1 = "
+                        + msg.arg1);
+                if ((ar.exception != null) && (ar.exception instanceof CommandException)) {
+                    CommandException cmdException = (CommandException) ar.exception;
+                    Rlog.d(LOG_TAG, "[EVENT_GET_CALL_FORWARD_TIME_SLOT_DONE] cmdException error:" +
+                            cmdException.getCommandError());
+
+                    if ((msg.arg1 == 1) && (cmdException != null) &&
+                            (cmdException.getCommandError() ==
+                                    CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED ||
+                            cmdException.getCommandError() ==
+                                    CommandException.Error.OEM_ERROR_2 ||
+                            cmdException.getCommandError() ==
+                                    CommandException.Error.OEM_ERROR_3)) {
+                        if (mSST != null && mSST.mSS != null
+                                && (mSST.mSS.getState() == ServiceState.STATE_IN_SERVICE)) {
+                            getCallForwardingOption(CF_REASON_UNCONDITIONAL,
+                                    obtainMessage(EVENT_GET_CALL_FORWARD_DONE));
+                        }
+                    }
+
+                    if (is93MDSupport()) {
+                        if (cmdException != null) {
+                            if (cmdException.getCommandError() == CommandException.Error.OEM_ERROR_2 ||
+                                    cmdException.getCommandError() == CommandException.Error.OEM_ERROR_3) {
+                                Rlog.d(LOG_TAG, "return SPECAIL_UT_COMMAND_NOT_SUPPORTED");
+                                ar.exception = new CommandException(
+                                        CommandException.Error.SPECAIL_UT_COMMAND_NOT_SUPPORTED);
+                            }
+                        }
+                    }
+                }
+                onComplete = (Message) ar.userObj;
+                if (onComplete != null) {
+                    AsyncResult.forMessage(onComplete, ar.result, ar.exception);
+                    onComplete.sendToTarget();
+                }
+                break;
+
+            case EVENT_SET_CALL_FORWARD_TIME_SLOT_DONE:
+                ar = (AsyncResult) msg.obj;
+                IccRecords records = mIccRecords.get();
+                CfuEx cfuEx = (CfuEx) ar.userObj;
+                if (ar.exception == null && records != null) {
+                    records.setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfuEx.mSetCfNumber);
+                    saveTimeSlot(cfuEx.mSetTimeSlot);
+                    if (msg.arg1 == 1) {
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_ON);
+                    } else {
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                                UT_CFU_NOTIFICATION_MODE_OFF);
+                    }
+                }
+                if (cfuEx.mOnComplete != null) {
+                    AsyncResult.forMessage(cfuEx.mOnComplete, ar.result, ar.exception);
+                    cfuEx.mOnComplete.sendToTarget();
+                }
+                break;
+            /// @}
+
+            /// M: CC: Proprietary CRSS handling @{
+            case EVENT_CRSS_IND:
+                ar = (AsyncResult) msg.obj;
+                SuppCrssNotification noti = (SuppCrssNotification) ar.result;
+
+                /// M: CC: number presentation via CLIP @{
+                if (noti.code == SuppCrssNotification.CRSS_CALLING_LINE_ID_PREST) {
+                    // update numberPresentation in gsmconnection
+                    if (getRingingCall().getState() != GsmCdmaCall.State.IDLE) {
+                        Connection cn = (Connection) (getRingingCall().getConnections().get(0));
+                        /* CLI validity value,
+                          0: PRESENTATION_ALLOWED,
+                          1: PRESENTATION_RESTRICTED,
+                          2: PRESENTATION_UNKNOWN
+                          3: PRESENTATION_PAYPHONE
+                        */
+                        Rlog.d(LOG_TAG, "set number presentation to connection : "
+                                + noti.cli_validity);
+                        switch (noti.cli_validity) {
+                            case 1:
+                                cn.setNumberPresentation(PhoneConstants.PRESENTATION_RESTRICTED);
+                                break;
+
+                            case 2:
+                                cn.setNumberPresentation(PhoneConstants.PRESENTATION_UNKNOWN);
+                                break;
+
+                            case 3:
+                                cn.setNumberPresentation(PhoneConstants.PRESENTATION_PAYPHONE);
+                                break;
+
+                            case 0:
+                            default:
+                                cn.setNumberPresentation(PhoneConstants.PRESENTATION_ALLOWED);
+                                break;
+                        }
+                    }
+                /// @}
+                /// M: CC: Redirecting number via COLP @{
+                } else if (noti.code == SuppCrssNotification.CRSS_CONNECTED_LINE_ID_PREST) {
+                /* If the phone number in +COLP is different from the address of connection,
+                       store it to connection as redirecting address.
+                    */
+                    Rlog.d(LOG_TAG, "[COLP]noti.number = " + Rlog.pii(SDBG, noti.number));
+                    if (getForegroundCall().getState() != GsmCdmaCall.State.IDLE) {
+                        Connection cn = (Connection) (getForegroundCall().getConnections().get(0));
+                        if ((cn != null) &&
+                            (cn.getAddress() != null) &&
+                            !cn.getAddress().equals(noti.number)) {
+                           cn.setRedirectingAddress(noti.number);
+                           Rlog.d(LOG_TAG, "[COLP]Redirecting address = " +
+                                   Rlog.pii(SDBG, cn.getRedirectingAddress()));
+                        }
+                    }
+                }
+                /// @}
+
+                if (mCallRelatedSuppSvcRegistrants.size() == 0) {
+                    mCachedCrssn = ar;
+                }
+                mCallRelatedSuppSvcRegistrants.notifyRegistrants(ar);
+                break;
+                /// @}
+            default:
+                super.handleMessage(msg);
+        }
+    }
+
+    public UiccCardApplication getUiccCardApplication() {
+        if (isPhoneTypeGsm()) {
+            return mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
+        } else {
+            return mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP2);
+        }
+    }
+
+    @Override
+    protected void onUpdateIccAvailability() {
+        if (mUiccController == null ) {
+            return;
+        }
+
+        UiccCardApplication newUiccApplication = null;
+
+        // Update mIsimUiccRecords
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            newUiccApplication =
+                    mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
+            IsimUiccRecords newIsimUiccRecords = null;
+
+            if (newUiccApplication != null) {
+                newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
+                if (DBG) logd("New ISIM application found");
+            }
+            mIsimUiccRecords = newIsimUiccRecords;
+        }
+
+        // Update mSimRecords
+        if (mSimRecords != null) {
+            mSimRecords.unregisterForRecordsLoaded(this);
+        }
+        if (isPhoneTypeCdmaLte()) {
+            newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId,
+                    UiccController.APP_FAM_3GPP);
+            SIMRecords newSimRecords = null;
+            if (newUiccApplication != null) {
+                newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
+            }
+            mSimRecords = newSimRecords;
+            if (mSimRecords != null) {
+                mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
+            }
+        } else {
+            mSimRecords = null;
+        }
+
+        // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
+        newUiccApplication = getUiccCardApplication();
+        if (!isPhoneTypeGsm() && newUiccApplication == null) {
+            logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
+            newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId,
+                    UiccController.APP_FAM_3GPP);
+        }
+
+        UiccCardApplication app = mUiccApplication.get();
+        // MTK-START
+        IccRecords newIccRecord =
+                (newUiccApplication != null)? newUiccApplication.getIccRecords() : null;
+        if ((app != newUiccApplication) || (mIccRecords.get() != newIccRecord)) {
+        //if (app != newUiccApplication) {
+        // MTK-END
+            if (app != null) {
+                if (DBG) logd("Removing stale icc objects.");
+                if (mIccRecords.get() != null) {
+                    unregisterForIccRecordEvents();
+                    mIccPhoneBookIntManager.updateIccRecords(null);
+                }
+                mIccRecords.set(null);
+                mUiccApplication.set(null);
+            }
+            if (newUiccApplication != null) {
+                if (DBG) {
+                    logd("New Uicc application found. type = " + newUiccApplication.getType());
+                }
+                mUiccApplication.set(newUiccApplication);
+                mIccRecords.set(newUiccApplication.getIccRecords());
+                registerForIccRecordEvents();
+                mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
+
+                handleSuppServInitIfSimChanged();
+            }
+        }
+
+        // MTK-START
+        // If phoneType is CDMALTE and card is CDMA only, change the phoneType to CDMA;
+        // If phoneType is CDMA and card is not CDMA only, change the phoneType to CDMALTE
+        Rlog.d(LOG_TAG, "isPhoneTypeCdmaLte:" + isPhoneTypeCdmaLte()
+                + " isCdmaOnlyCard: " + isCdmaOnlyCard() + " mNewVoiceTech: " + mNewVoiceTech);
+        if (mNewVoiceTech != -1 &&
+                ((isPhoneTypeCdmaLte() && isCdmaOnlyCard()) ||
+                (isPhoneTypeCdma() && !isCdmaOnlyCard()))) {
+            updatePhoneObject(mNewVoiceTech);
+        }
+        // MTK-END
+    }
+
+    private void processIccRecordEvents(int eventCode) {
+        switch (eventCode) {
+            case IccRecords.EVENT_CFI:
+                Rlog.d(LOG_TAG, "processIccRecordEvents");
+                notifyCallForwardingIndicator();
+                break;
+        }
+    }
+
+    /**
+     * Sets the "current" field in the telephony provider according to the SIM's operator
+     *
+     * @return true for success; false otherwise.
+     */
+    @Override
+    public boolean updateCurrentCarrierInProvider() {
+        if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
+            long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
+            String operatorNumeric = getOperatorNumeric();
+
+            logd("updateCurrentCarrierInProvider: mSubId = " + getSubId()
+                    + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
+
+            if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
+                try {
+                    Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
+                    ContentValues map = new ContentValues();
+                    map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
+                    mContext.getContentResolver().insert(uri, map);
+                    return true;
+                } catch (SQLException e) {
+                    Rlog.e(LOG_TAG, "Can't store current operator", e);
+                }
+            }
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    //CDMA
+    /**
+     * Sets the "current" field in the telephony provider according to the
+     * build-time operator numeric property
+     *
+     * @return true for success; false otherwise.
+     */
+    private boolean updateCurrentCarrierInProvider(String operatorNumeric) {
+        if (isPhoneTypeCdma()
+                || (isPhoneTypeCdmaLte() && mUiccController.getUiccCardApplication(mPhoneId,
+                        UiccController.APP_FAM_3GPP) == null)) {
+            logd("CDMAPhone: updateCurrentCarrierInProvider called");
+            if (!TextUtils.isEmpty(operatorNumeric)) {
+                try {
+                    Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
+                    ContentValues map = new ContentValues();
+                    map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
+                    logd("updateCurrentCarrierInProvider from system: numeric=" + operatorNumeric);
+                    getContext().getContentResolver().insert(uri, map);
+
+                    // Updates MCC MNC device configuration information
+                    logd("update mccmnc=" + operatorNumeric);
+                    MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
+
+                    return true;
+                } catch (SQLException e) {
+                    Rlog.e(LOG_TAG, "Can't store current operator", e);
+                }
+            }
+            return false;
+        } else { // isPhoneTypeCdmaLte()
+            if (DBG) logd("updateCurrentCarrierInProvider not updated X retVal=" + true);
+            return true;
+        }
+    }
+
+    private void handleCfuQueryResult(CallForwardInfo[] infos) {
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            if (infos == null || infos.length == 0) {
+                // Assume the default is not active
+                // Set unconditional CFF in SIM to false
+                setVoiceCallForwardingFlag(1, false, null);
+                setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,UT_CFU_NOTIFICATION_MODE_OFF);
+            } else {
+                for (int i = 0, s = infos.length; i < s; i++) {
+                    if ((infos[i].serviceClass & SERVICE_CLASS_VOICE) != 0) {
+                        setVoiceCallForwardingFlag(1, (infos[i].status == 1),
+                            infos[i].number);
+                        String mode = infos[i].status == 1 ?
+                            UT_CFU_NOTIFICATION_MODE_ON : UT_CFU_NOTIFICATION_MODE_OFF;
+                        setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE, mode);
+                        // should only have the one
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Retrieves the IccPhoneBookInterfaceManager of the GsmCdmaPhone
+     */
+    @Override
+    public IccPhoneBookInterfaceManager getIccPhoneBookInterfaceManager(){
+        return mIccPhoneBookIntManager;
+    }
+
+    //CDMA
+    public void registerForEriFileLoaded(Handler h, int what, Object obj) {
+        Registrant r = new Registrant (h, what, obj);
+        mEriFileLoadedRegistrants.add(r);
+    }
+
+    //CDMA
+    public void unregisterForEriFileLoaded(Handler h) {
+        mEriFileLoadedRegistrants.remove(h);
+    }
+
+    //CDMA
+    public void prepareEri() {
+        if (mEriManager == null) {
+            Rlog.e(LOG_TAG, "PrepareEri: Trying to access stale objects");
+            return;
+        }
+        mEriManager.loadEriFile();
+        if(mEriManager.isEriFileLoaded()) {
+            // when the ERI file is loaded
+            logd("ERI read, notify registrants");
+            mEriFileLoadedRegistrants.notifyRegistrants();
+        }
+    }
+
+    //CDMA
+    public boolean isEriFileLoaded() {
+        return mEriManager.isEriFileLoaded();
+    }
+
+
+    /**
+     * Activate or deactivate cell broadcast SMS.
+     *
+     * @param activate 0 = activate, 1 = deactivate
+     * @param response Callback message is empty on completion
+     */
+    @Override
+    public void activateCellBroadcastSms(int activate, Message response) {
+        loge("[GsmCdmaPhone] activateCellBroadcastSms() is obsolete; use SmsManager");
+        response.sendToTarget();
+    }
+
+    /**
+     * Query the current configuration of cdma cell broadcast SMS.
+     *
+     * @param response Callback message is empty on completion
+     */
+    @Override
+    public void getCellBroadcastSmsConfig(Message response) {
+        loge("[GsmCdmaPhone] getCellBroadcastSmsConfig() is obsolete; use SmsManager");
+        response.sendToTarget();
+    }
+
+    /**
+     * Configure cdma cell broadcast SMS.
+     *
+     * @param response Callback message is empty on completion
+     */
+    @Override
+    public void setCellBroadcastSmsConfig(int[] configValuesArray, Message response) {
+        loge("[GsmCdmaPhone] setCellBroadcastSmsConfig() is obsolete; use SmsManager");
+        response.sendToTarget();
+    }
+
+    /**
+     * Returns true if OTA Service Provisioning needs to be performed.
+     */
+    @Override
+    public boolean needsOtaServiceProvisioning() {
+        if (isPhoneTypeGsm()) {
+            return false;
+        } else {
+            return mSST.getOtasp() != ServiceStateTracker.OTASP_NOT_NEEDED;
+        }
+    }
+
+    @Override
+    public boolean isCspPlmnEnabled() {
+        IccRecords r = mIccRecords.get();
+        return (r != null) ? r.isCspPlmnEnabled() : false;
+    }
+
+    public boolean isManualNetSelAllowed() {
+
+        int nwMode = Phone.PREFERRED_NT_MODE;
+        int subId = getSubId();
+
+        nwMode = android.provider.Settings.Global.getInt(mContext.getContentResolver(),
+                    android.provider.Settings.Global.PREFERRED_NETWORK_MODE + subId, nwMode);
+
+        logd("isManualNetSelAllowed in mode = " + nwMode);
+        /*
+         *  For multimode targets in global mode manual network
+         *  selection is disallowed
+         */
+        if (isManualSelProhibitedInGlobalMode()
+                && ((nwMode == Phone.NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA)
+                        || (nwMode == Phone.NT_MODE_GLOBAL)) ){
+            logd("Manual selection not supported in mode = " + nwMode);
+            return false;
+        } else {
+            logd("Manual selection is supported in mode = " + nwMode);
+        }
+
+        /*
+         *  Single mode phone with - GSM network modes/global mode
+         *  LTE only for 3GPP
+         *  LTE centric + 3GPP Legacy
+         *  Note: the actual enabling/disabling manual selection for these
+         *  cases will be controlled by csp
+         */
+        return true;
+    }
+
+    private boolean isManualSelProhibitedInGlobalMode() {
+        boolean isProhibited = false;
+        final String configString = getContext().getResources().getString(com.android.internal.
+                R.string.prohibit_manual_network_selection_in_gobal_mode);
+
+        if (!TextUtils.isEmpty(configString)) {
+            String[] configArray = configString.split(";");
+
+            if (configArray != null &&
+                    ((configArray.length == 1 && configArray[0].equalsIgnoreCase("true")) ||
+                        (configArray.length == 2 && !TextUtils.isEmpty(configArray[1]) &&
+                            configArray[0].equalsIgnoreCase("true") &&
+                            isMatchGid(configArray[1])))) {
+                            isProhibited = true;
+            }
+        }
+        logd("isManualNetSelAllowedInGlobal in current carrier is " + isProhibited);
+        return isProhibited;
+    }
+
+    private void registerForIccRecordEvents() {
+        Rlog.d(LOG_TAG, "registerForIccRecordEvents, phonetype: " + isPhoneTypeGsm());
+        IccRecords r = mIccRecords.get();
+        if (r == null) {
+            return;
+        }
+        /// M: Get uicc application is 3GPP family before switch phoneType from CDMA to GSM @{
+        if (r instanceof SIMRecords) {
+        //if (isPhoneTypeGsm()) {
+        /// @}
+            r.registerForNetworkSelectionModeAutomatic(
+                    this, EVENT_SET_NETWORK_AUTOMATIC, null);
+            r.registerForRecordsEvents(this, EVENT_ICC_RECORD_EVENTS, null);
+            r.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
+        } else {
+            r.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
+        }
+    }
+
+    private void unregisterForIccRecordEvents() {
+        Rlog.d(LOG_TAG, "unregisterForIccRecordEvents");
+        IccRecords r = mIccRecords.get();
+        if (r == null) {
+            return;
+        }
+        r.unregisterForNetworkSelectionModeAutomatic(this);
+        r.unregisterForRecordsEvents(this);
+        r.unregisterForRecordsLoaded(this);
+    }
+
+    @Override
+    public void exitEmergencyCallbackMode() {
+        if (isPhoneTypeGsm()) {
+            if (mImsPhone != null) {
+                mImsPhone.exitEmergencyCallbackMode();
+            }
+        } else {
+            if (mWakeLock.isHeld()) {
+                mWakeLock.release();
+            }
+            // Send a message which will invoke handleExitEmergencyCallbackMode
+            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
+        }
+    }
+
+    //CDMA
+    private void handleEnterEmergencyCallbackMode(Message msg) {
+        if (DBG) {
+            Rlog.d(LOG_TAG, "handleEnterEmergencyCallbackMode,mIsPhoneInEcmState= "
+                    + mIsPhoneInEcmState);
+        }
+        // if phone is not in Ecm mode, and it's changed to Ecm mode
+        if (mIsPhoneInEcmState == false) {
+            /// M: Set the property by phoneId @{
+            //setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "true");
+            TelephonyManager.setTelephonyProperty(
+                    mPhoneId, TelephonyProperties.PROPERTY_INECM_MODE, "true");
+            /// @}
+            mIsPhoneInEcmState = true;
+            // notify change
+            sendEmergencyCallbackModeChange();
+
+            /// M: Timing issue for ECC ended but not in ECM. @{
+            /**
+             * When hanging up ECC call, the call may be ended immediately
+             * but not enter ECM at the same time,
+             * the data will be enabled again in this case.
+             * So, disable data again when entering ECM.
+             */
+            mDcTracker.setInternalDataEnabled(false);
+            notifyEmergencyCallRegistrants(true);
+            /// @}
+
+            // Post this runnable so we will automatically exit
+            // if no one invokes exitEmergencyCallbackMode() directly.
+            long delayInMillis = SystemProperties.getLong(
+                    TelephonyProperties.PROPERTY_ECM_EXIT_TIMER, DEFAULT_ECM_EXIT_TIMER_VALUE);
+            postDelayed(mExitEcmRunnable, delayInMillis);
+            // We don't want to go to sleep while in Ecm
+            mWakeLock.acquire();
+        }
+    }
+
+    //CDMA
+    private void handleExitEmergencyCallbackMode(Message msg) {
+        AsyncResult ar = (AsyncResult)msg.obj;
+        if (DBG) {
+            Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode,ar.exception , mIsPhoneInEcmState "
+                    + ar.exception + mIsPhoneInEcmState);
+        }
+        // Remove pending exit Ecm runnable, if any
+        removeCallbacks(mExitEcmRunnable);
+
+        if (mEcmExitRespRegistrant != null) {
+            mEcmExitRespRegistrant.notifyRegistrant(ar);
+        }
+        // if exiting ecm success
+        if (ar.exception == null
+                || (ar.exception instanceof CommandException
+                    && ((CommandException)ar.exception).getCommandError()
+                        == CommandException.Error.RADIO_NOT_AVAILABLE)) {
+
+            if (mIsPhoneInEcmState) {
+                /// M: Set the property by phoneId @{
+                //setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "false");
+                TelephonyManager.setTelephonyProperty(
+                        mPhoneId, TelephonyProperties.PROPERTY_INECM_MODE, "false");
+                /// @}
+                mIsPhoneInEcmState = false;
+            }
+
+            // release wakeLock
+            if (mWakeLock.isHeld()) {
+                mWakeLock.release();
+            }
+
+            // send an Intent
+            sendEmergencyCallbackModeChange();
+            // Re-initiate data connection
+            mDcTracker.setInternalDataEnabled(true);
+            notifyEmergencyCallRegistrants(false);
+        }
+    }
+
+    //CDMA
+    public void notifyEmergencyCallRegistrants(boolean started) {
+        mEmergencyCallToggledRegistrants.notifyResult(started ? 1 : 0);
+    }
+
+    //CDMA
+    /**
+     * Handle to cancel or restart Ecm timer in emergency call back mode
+     * if action is CANCEL_ECM_TIMER, cancel Ecm timer and notify apps the timer is canceled;
+     * otherwise, restart Ecm timer and notify apps the timer is restarted.
+     */
+    public void handleTimerInEmergencyCallbackMode(int action) {
+        switch(action) {
+            case CANCEL_ECM_TIMER:
+                removeCallbacks(mExitEcmRunnable);
+                mEcmTimerResetRegistrants.notifyResult(Boolean.TRUE);
+                break;
+            case RESTART_ECM_TIMER:
+                long delayInMillis = SystemProperties.getLong(
+                        TelephonyProperties.PROPERTY_ECM_EXIT_TIMER, DEFAULT_ECM_EXIT_TIMER_VALUE);
+                postDelayed(mExitEcmRunnable, delayInMillis);
+                mEcmTimerResetRegistrants.notifyResult(Boolean.FALSE);
+                break;
+            default:
+                Rlog.e(LOG_TAG, "handleTimerInEmergencyCallbackMode, unsupported action " + action);
+        }
+    }
+
+    //CDMA
+    private static final String IS683A_FEATURE_CODE = "*228";
+    private static final int IS683A_FEATURE_CODE_NUM_DIGITS = 4;
+    private static final int IS683A_SYS_SEL_CODE_NUM_DIGITS = 2;
+    private static final int IS683A_SYS_SEL_CODE_OFFSET = 4;
+
+    private static final int IS683_CONST_800MHZ_A_BAND = 0;
+    private static final int IS683_CONST_800MHZ_B_BAND = 1;
+    private static final int IS683_CONST_1900MHZ_A_BLOCK = 2;
+    private static final int IS683_CONST_1900MHZ_B_BLOCK = 3;
+    private static final int IS683_CONST_1900MHZ_C_BLOCK = 4;
+    private static final int IS683_CONST_1900MHZ_D_BLOCK = 5;
+    private static final int IS683_CONST_1900MHZ_E_BLOCK = 6;
+    private static final int IS683_CONST_1900MHZ_F_BLOCK = 7;
+    private static final int INVALID_SYSTEM_SELECTION_CODE = -1;
+
+    // Define the pattern/format for carrier specified OTASP number schema.
+    // It separates by comma and/or whitespace.
+    private static Pattern pOtaSpNumSchema = Pattern.compile("[,\\s]+");
+
+    //CDMA
+    private static boolean isIs683OtaSpDialStr(String dialStr) {
+        int sysSelCodeInt;
+        boolean isOtaspDialString = false;
+        int dialStrLen = dialStr.length();
+
+        if (dialStrLen == IS683A_FEATURE_CODE_NUM_DIGITS) {
+            if (dialStr.equals(IS683A_FEATURE_CODE)) {
+                isOtaspDialString = true;
+            }
+        } else {
+            sysSelCodeInt = extractSelCodeFromOtaSpNum(dialStr);
+            switch (sysSelCodeInt) {
+                case IS683_CONST_800MHZ_A_BAND:
+                case IS683_CONST_800MHZ_B_BAND:
+                case IS683_CONST_1900MHZ_A_BLOCK:
+                case IS683_CONST_1900MHZ_B_BLOCK:
+                case IS683_CONST_1900MHZ_C_BLOCK:
+                case IS683_CONST_1900MHZ_D_BLOCK:
+                case IS683_CONST_1900MHZ_E_BLOCK:
+                case IS683_CONST_1900MHZ_F_BLOCK:
+                    isOtaspDialString = true;
+                    break;
+                default:
+                    break;
+            }
+        }
+        return isOtaspDialString;
+    }
+
+    //CDMA
+    /**
+     * This function extracts the system selection code from the dial string.
+     */
+    private static int extractSelCodeFromOtaSpNum(String dialStr) {
+        int dialStrLen = dialStr.length();
+        int sysSelCodeInt = INVALID_SYSTEM_SELECTION_CODE;
+
+        if ((dialStr.regionMatches(0, IS683A_FEATURE_CODE,
+                0, IS683A_FEATURE_CODE_NUM_DIGITS)) &&
+                (dialStrLen >= (IS683A_FEATURE_CODE_NUM_DIGITS +
+                        IS683A_SYS_SEL_CODE_NUM_DIGITS))) {
+            // Since we checked the condition above, the system selection code
+            // extracted from dialStr will not cause any exception
+            sysSelCodeInt = Integer.parseInt (
+                    dialStr.substring (IS683A_FEATURE_CODE_NUM_DIGITS,
+                            IS683A_FEATURE_CODE_NUM_DIGITS + IS683A_SYS_SEL_CODE_NUM_DIGITS));
+        }
+        if (DBG) Rlog.d(LOG_TAG, "extractSelCodeFromOtaSpNum " + sysSelCodeInt);
+        return sysSelCodeInt;
+    }
+
+    //CDMA
+    /**
+     * This function checks if the system selection code extracted from
+     * the dial string "sysSelCodeInt' is the system selection code specified
+     * in the carrier ota sp number schema "sch".
+     */
+    private static boolean checkOtaSpNumBasedOnSysSelCode(int sysSelCodeInt, String sch[]) {
+        boolean isOtaSpNum = false;
+        try {
+            // Get how many number of system selection code ranges
+            int selRc = Integer.parseInt(sch[1]);
+            for (int i = 0; i < selRc; i++) {
+                if (!TextUtils.isEmpty(sch[i+2]) && !TextUtils.isEmpty(sch[i+3])) {
+                    int selMin = Integer.parseInt(sch[i+2]);
+                    int selMax = Integer.parseInt(sch[i+3]);
+                    // Check if the selection code extracted from the dial string falls
+                    // within any of the range pairs specified in the schema.
+                    if ((sysSelCodeInt >= selMin) && (sysSelCodeInt <= selMax)) {
+                        isOtaSpNum = true;
+                        break;
+                    }
+                }
+            }
+        } catch (NumberFormatException ex) {
+            // If the carrier ota sp number schema is not correct, we still allow dial
+            // and only log the error:
+            Rlog.e(LOG_TAG, "checkOtaSpNumBasedOnSysSelCode, error", ex);
+        }
+        return isOtaSpNum;
+    }
+
+    //CDMA
+    /**
+     * The following function checks if a dial string is a carrier specified
+     * OTASP number or not by checking against the OTASP number schema stored
+     * in PROPERTY_OTASP_NUM_SCHEMA.
+     *
+     * Currently, there are 2 schemas for carriers to specify the OTASP number:
+     * 1) Use system selection code:
+     *    The schema is:
+     *    SELC,the # of code pairs,min1,max1,min2,max2,...
+     *    e.g "SELC,3,10,20,30,40,60,70" indicates that there are 3 pairs of
+     *    selection codes, and they are {10,20}, {30,40} and {60,70} respectively.
+     *
+     * 2) Use feature code:
+     *    The schema is:
+     *    "FC,length of feature code,feature code".
+     *     e.g "FC,2,*2" indicates that the length of the feature code is 2,
+     *     and the code itself is "*2".
+     */
+    private boolean isCarrierOtaSpNum(String dialStr) {
+        boolean isOtaSpNum = false;
+        int sysSelCodeInt = extractSelCodeFromOtaSpNum(dialStr);
+        if (sysSelCodeInt == INVALID_SYSTEM_SELECTION_CODE) {
+            return isOtaSpNum;
+        }
+        // mCarrierOtaSpNumSchema is retrieved from PROPERTY_OTASP_NUM_SCHEMA:
+        if (!TextUtils.isEmpty(mCarrierOtaSpNumSchema)) {
+            Matcher m = pOtaSpNumSchema.matcher(mCarrierOtaSpNumSchema);
+            if (DBG) {
+                Rlog.d(LOG_TAG, "isCarrierOtaSpNum,schema" + mCarrierOtaSpNumSchema);
+            }
+
+            if (m.find()) {
+                String sch[] = pOtaSpNumSchema.split(mCarrierOtaSpNumSchema);
+                // If carrier uses system selection code mechanism
+                if (!TextUtils.isEmpty(sch[0]) && sch[0].equals("SELC")) {
+                    if (sysSelCodeInt!=INVALID_SYSTEM_SELECTION_CODE) {
+                        isOtaSpNum=checkOtaSpNumBasedOnSysSelCode(sysSelCodeInt,sch);
+                    } else {
+                        if (DBG) {
+                            Rlog.d(LOG_TAG, "isCarrierOtaSpNum,sysSelCodeInt is invalid");
+                        }
+                    }
+                } else if (!TextUtils.isEmpty(sch[0]) && sch[0].equals("FC")) {
+                    int fcLen =  Integer.parseInt(sch[1]);
+                    String fc = sch[2];
+                    if (dialStr.regionMatches(0,fc,0,fcLen)) {
+                        isOtaSpNum = true;
+                    } else {
+                        if (DBG) Rlog.d(LOG_TAG, "isCarrierOtaSpNum,not otasp number");
+                    }
+                } else {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "isCarrierOtaSpNum,ota schema not supported" + sch[0]);
+                    }
+                }
+            } else {
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "isCarrierOtaSpNum,ota schema pattern not right" +
+                            mCarrierOtaSpNumSchema);
+                }
+            }
+        } else {
+            if (DBG) Rlog.d(LOG_TAG, "isCarrierOtaSpNum,ota schema pattern empty");
+        }
+        return isOtaSpNum;
+    }
+
+    /**
+     * isOTASPNumber: checks a given number against the IS-683A OTASP dial string and carrier
+     * OTASP dial string.
+     *
+     * @param dialStr the number to look up.
+     * @return true if the number is in IS-683A OTASP dial string or carrier OTASP dial string
+     */
+    @Override
+    public  boolean isOtaSpNumber(String dialStr) {
+        if (isPhoneTypeGsm()) {
+            return super.isOtaSpNumber(dialStr);
+        } else {
+            boolean isOtaSpNum = false;
+            String dialableStr = PhoneNumberUtils.extractNetworkPortionAlt(dialStr);
+            if (dialableStr != null) {
+                isOtaSpNum = isIs683OtaSpDialStr(dialableStr);
+                if (isOtaSpNum == false) {
+                    isOtaSpNum = isCarrierOtaSpNum(dialableStr);
+                }
+            }
+            if (DBG) Rlog.d(LOG_TAG, "isOtaSpNumber " + isOtaSpNum);
+            return isOtaSpNum;
+        }
+    }
+
+    @Override
+    public int getCdmaEriIconIndex() {
+        if (isPhoneTypeGsm()) {
+            return super.getCdmaEriIconIndex();
+        } else {
+            return getServiceState().getCdmaEriIconIndex();
+        }
+    }
+
+    /**
+     * Returns the CDMA ERI icon mode,
+     * 0 - ON
+     * 1 - FLASHING
+     */
+    @Override
+    public int getCdmaEriIconMode() {
+        if (isPhoneTypeGsm()) {
+            return super.getCdmaEriIconMode();
+        } else {
+            return getServiceState().getCdmaEriIconMode();
+        }
+    }
+
+    /**
+     * Returns the CDMA ERI text,
+     */
+    @Override
+    public String getCdmaEriText() {
+        if (isPhoneTypeGsm()) {
+            return super.getCdmaEriText();
+        } else {
+            int roamInd = getServiceState().getCdmaRoamingIndicator();
+            int defRoamInd = getServiceState().getCdmaDefaultRoamingIndicator();
+            return mEriManager.getCdmaEriText(roamInd, defRoamInd);
+        }
+    }
+
+    private void phoneObjectUpdater(int newVoiceRadioTech) {
+        logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
+        mNewVoiceTech = newVoiceRadioTech;
+
+        // Check for a voice over lte replacement
+        if (ServiceState.isLte(newVoiceRadioTech)
+                || (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
+            CarrierConfigManager configMgr = (CarrierConfigManager)
+                    getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
+            if (b != null) {
+                int volteReplacementRat =
+                        b.getInt(CarrierConfigManager.KEY_VOLTE_REPLACEMENT_RAT_INT);
+                logd("phoneObjectUpdater: volteReplacementRat=" + volteReplacementRat);
+                if (volteReplacementRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                    newVoiceRadioTech = volteReplacementRat;
+                }
+            } else {
+                loge("phoneObjectUpdater: didn't get volteReplacementRat from carrier config");
+            }
+        }
+
+        if(mRilVersion == 6 && getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
+            /*
+             * On v6 RIL, when LTE_ON_CDMA is TRUE, always create CDMALTEPhone
+             * irrespective of the voice radio tech reported.
+             */
+            if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                logd("phoneObjectUpdater: LTE ON CDMA property is set. Use CDMA Phone" +
+                        " newVoiceRadioTech=" + newVoiceRadioTech +
+                        " mActivePhone=" + getPhoneName());
+                return;
+            } else {
+                logd("phoneObjectUpdater: LTE ON CDMA property is set. Switch to CDMALTEPhone" +
+                        " newVoiceRadioTech=" + newVoiceRadioTech +
+                        " mActivePhone=" + getPhoneName());
+                newVoiceRadioTech = ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT;
+            }
+        } else {
+
+            // If the device is shutting down, then there is no need to switch to the new phone
+            // which might send unnecessary attach request to the modem.
+            if (isShuttingDown()) {
+                logd("Device is shutting down. No need to switch phone now.");
+                return;
+            }
+
+            boolean matchCdma = ServiceState.isCdma(newVoiceRadioTech);
+            boolean matchGsm = ServiceState.isGsm(newVoiceRadioTech);
+            if ((matchCdma && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) ||
+                    (matchGsm && getPhoneType() == PhoneConstants.PHONE_TYPE_GSM)) {
+                // MTK-START
+                if (matchCdma  &&
+                        getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                    // Update IccCardProxy app type and it is different for cdma 4G and 3G card.
+                    mIccCardProxy.setVoiceRadioTech(newVoiceRadioTech);
+                }
+                // If phoneType is CDMALTE and card is CDMA only, change the phoneType to CDMA;
+                // If phoneType is CDMA and card is not CDMA only, change the phoneType to CDMALTE
+                if (!((isPhoneTypeCdmaLte() && isCdmaOnlyCard()) ||
+                        (isPhoneTypeCdma() && !isCdmaOnlyCard()))) {
+                    // Nothing changed. Keep phone as it is.
+                    logd("phoneObjectUpdater: No change ignore," +
+                            " newVoiceRadioTech=" + newVoiceRadioTech +
+                            " mActivePhone=" + getPhoneName());
+                    return;
+                }
+                // MTK-END
+            }
+            if (!matchCdma && !matchGsm) {
+                loge("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech +
+                        " doesn't match either CDMA or GSM - error! No phone change");
+                return;
+            }
+        }
+
+        if (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+            // We need some voice phone object to be active always, so never
+            // delete the phone without anything to replace it with!
+            logd("phoneObjectUpdater: Unknown rat ignore, "
+                    + " newVoiceRadioTech=Unknown. mActivePhone=" + getPhoneName());
+            return;
+        }
+
+        boolean oldPowerState = false; // old power state to off
+        if (mResetModemOnRadioTechnologyChange) {
+            if (mCi.getRadioState().isOn()) {
+                oldPowerState = true;
+                logd("phoneObjectUpdater: Setting Radio Power to Off");
+                mCi.setRadioPower(false, null);
+            }
+        }
+
+        switchVoiceRadioTech(newVoiceRadioTech);
+
+        if (mResetModemOnRadioTechnologyChange && oldPowerState) { // restore power state
+            logd("phoneObjectUpdater: Resetting Radio");
+            mCi.setRadioPower(oldPowerState, null);
+        }
+
+        // update voice radio tech in icc card proxy
+        mIccCardProxy.setVoiceRadioTech(newVoiceRadioTech);
+
+        // Send an Intent to the PhoneApp that we had a radio technology change
+        Intent intent = new Intent(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
+        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(PhoneConstants.PHONE_NAME_KEY, getPhoneName());
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhoneId);
+        ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
+    }
+
+    private void switchVoiceRadioTech(int newVoiceRadioTech) {
+
+        String outgoingPhoneName = getPhoneName();
+
+        logd("Switching Voice Phone : " + outgoingPhoneName + " >>> "
+                + (ServiceState.isGsm(newVoiceRadioTech) ? "GSM" : "CDMA"));
+
+        if (ServiceState.isCdma(newVoiceRadioTech)) {
+            if (isCdmaOnlyCard()) {
+                // MTK-START: add CDMA type.
+                switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
+                // MTK-END: add CDMA type.
+            } else {
+                switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA_LTE);
+            }
+        } else if (ServiceState.isGsm(newVoiceRadioTech)) {
+            switchPhoneType(PhoneConstants.PHONE_TYPE_GSM);
+        } else {
+            loge("deleteAndCreatePhone: newVoiceRadioTech=" + newVoiceRadioTech +
+                    " is not CDMA or GSM (error) - aborting!");
+            return;
+        }
+    }
+
+    @Override
+    public IccSmsInterfaceManager getIccSmsInterfaceManager(){
+        return mIccSmsInterfaceManager;
+    }
+
+    @Override
+    public void updatePhoneObject(int voiceRadioTech) {
+        logd("updatePhoneObject: radioTechnology=" + voiceRadioTech);
+        sendMessage(obtainMessage(EVENT_UPDATE_PHONE_OBJECT, voiceRadioTech, 0, null));
+    }
+
+    @Override
+    public void setImsRegistrationState(boolean registered) {
+        mSST.setImsRegistrationState(registered);
+    }
+
+    @Override
+    public boolean getIccRecordsLoaded() {
+        return mIccCardProxy.getIccRecordsLoaded();
+    }
+
+    @Override
+    public IccCard getIccCard() {
+        return mIccCardProxy;
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("GsmCdmaPhone extends:");
+        super.dump(fd, pw, args);
+        pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
+        pw.println(" mCT=" + mCT);
+        pw.println(" mSST=" + mSST);
+        pw.println(" mPendingMMIs=" + mPendingMMIs);
+        pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
+        if (VDBG) pw.println(" mImei=" + mImei);
+        if (VDBG) pw.println(" mImeiSv=" + mImeiSv);
+        if (VDBG) pw.println(" mVmNumber=" + mVmNumber);
+        pw.println(" mCdmaSSM=" + mCdmaSSM);
+        pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
+        pw.println(" mEriManager=" + mEriManager);
+        pw.println(" mWakeLock=" + mWakeLock);
+        pw.println(" mIsPhoneInEcmState=" + mIsPhoneInEcmState);
+        if (VDBG) pw.println(" mEsn=" + mEsn);
+        if (VDBG) pw.println(" mMeid=" + mMeid);
+        pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
+        if (!isPhoneTypeGsm()) {
+            pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
+            pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
+            pw.println(" getCdmaEriText()=" + getCdmaEriText());
+            pw.println(" isMinInfoReady()=" + isMinInfoReady());
+        }
+        pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
+        pw.flush();
+        pw.println("++++++++++++++++++++++++++++++++");
+
+        try {
+            mIccCardProxy.dump(fd, pw, args);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        pw.flush();
+        pw.println("++++++++++++++++++++++++++++++++");
+    }
+
+    @Override
+    public boolean setOperatorBrandOverride(String brand) {
+        if (mUiccController == null) {
+            return false;
+        }
+
+        UiccCard card = mUiccController.getUiccCard(getPhoneId());
+        if (card == null) {
+            return false;
+        }
+
+        boolean status = card.setOperatorBrandOverride(brand);
+
+        // Refresh.
+        if (status) {
+            IccRecords iccRecords = mIccRecords.get();
+            if (iccRecords != null) {
+                TelephonyManager.from(mContext).setSimOperatorNameForPhone(
+                        getPhoneId(), iccRecords.getServiceProviderName());
+            }
+            if (mSST != null) {
+                mSST.pollState();
+            }
+        }
+        return status;
+    }
+
+    /**
+     * @return operator numeric.
+     */
+    private String getOperatorNumeric() {
+        String operatorNumeric = null;
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            if (r != null) {
+                operatorNumeric = r.getOperatorNumeric();
+            }
+        } else { //isPhoneTypeCdmaLte()
+            IccRecords curIccRecords = null;
+            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
+            if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
+                operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
+            } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
+                curIccRecords = mSimRecords;
+                if (curIccRecords != null) {
+                    operatorNumeric = curIccRecords.getOperatorNumeric();
+                } else {
+                    curIccRecords = mIccRecords.get();
+                    if (curIccRecords != null && (curIccRecords instanceof RuimRecords)) {
+                        RuimRecords csim = (RuimRecords) curIccRecords;
+                        operatorNumeric = csim.getRUIMOperatorNumeric();
+                    }
+                }
+            }
+            if (operatorNumeric == null) {
+                loge("getOperatorNumeric: Cannot retrieve operatorNumeric:"
+                        + " mCdmaSubscriptionSource = " + mCdmaSubscriptionSource +
+                        " mIccRecords = " + ((curIccRecords != null) ?
+                        curIccRecords.getRecordsLoaded() : null));
+            }
+
+            logd("getOperatorNumeric: mCdmaSubscriptionSource = " + mCdmaSubscriptionSource
+                    + " operatorNumeric = " + operatorNumeric);
+
+        }
+        return operatorNumeric;
+    }
+
+    public void notifyEcbmTimerReset(Boolean flag) {
+        mEcmTimerResetRegistrants.notifyResult(flag);
+    }
+
+    /**
+     * Registration point for Ecm timer reset
+     *
+     * @param h handler to notify
+     * @param what User-defined message code
+     * @param obj placed in Message.obj
+     */
+    @Override
+    public void registerForEcmTimerReset(Handler h, int what, Object obj) {
+        mEcmTimerResetRegistrants.addUnique(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForEcmTimerReset(Handler h) {
+        mEcmTimerResetRegistrants.remove(h);
+    }
+
+    /**
+     * Sets the SIM voice message waiting indicator records.
+     * @param line GSM Subscriber Profile Number, one-based. Only '1' is supported
+     * @param countWaiting The number of messages waiting, if known. Use
+     *                     -1 to indicate that an unknown number of
+     *                      messages are waiting
+     */
+    @Override
+    public void setVoiceMessageWaiting(int line, int countWaiting) {
+        if (isPhoneTypeGsm()) {
+            IccRecords r = mIccRecords.get();
+            if (r != null) {
+                r.setVoiceMessageWaiting(line, countWaiting);
+            } else {
+                logd("SIM Records not found, MWI not updated");
+            }
+        } else {
+            setVoiceMessageCount(countWaiting);
+        }
+    }
+
+    private void logd(String s) {
+        Rlog.d(LOG_TAG, "[GsmCdmaPhone] " + s);
+    }
+
+    private void loge(String s) {
+        Rlog.e(LOG_TAG, "[GsmCdmaPhone] " + s);
+    }
+
+    @Override
+    public boolean isUtEnabled() {
+        Phone imsPhone = mImsPhone;
+        if (imsPhone != null) {
+            return imsPhone.isUtEnabled();
+        } else {
+            logd("isUtEnabled: called for GsmCdma");
+            return false;
+        }
+    }
+
+    public String getDtmfToneDelayKey() {
+        return isPhoneTypeGsm() ?
+                CarrierConfigManager.KEY_GSM_DTMF_TONE_DELAY_INT :
+                CarrierConfigManager.KEY_CDMA_DTMF_TONE_DELAY_INT;
+    }
+
+    @VisibleForTesting
+    public PowerManager.WakeLock getWakeLock() {
+        return mWakeLock;
+    }
+
+    /// M: CC: HangupAll for FTA 31.4.4.2 @{
+    @Override
+    public void hangupAll() throws CallStateException {
+        mCT.hangupAll();
+    }
+    /// @}
+
+    /// M: CC: Proprietary CRSS handling @{
+    public void registerForCrssSuppServiceNotification(
+            Handler h, int what, Object obj) {
+        mCallRelatedSuppSvcRegistrants.addUnique(h, what, obj);
+        if (mCachedCrssn != null) {
+            mCallRelatedSuppSvcRegistrants.notifyRegistrants(mCachedCrssn);
+            mCachedCrssn = null;
+        }
+    }
+
+    public void unregisterForCrssSuppServiceNotification(Handler h) {
+        mCallRelatedSuppSvcRegistrants.remove(h);
+        mCachedCrssn = null;
+    }
+    /// @}
+
+    /// M: IMS feature @{
+    // For VoLTE enhanced conference call
+    @Override
+    public Connection
+    dial(List<String> numbers, int videoState) throws CallStateException {
+        Phone imsPhone = mImsPhone;
+        boolean imsUseEnabled = isImsUseEnabled();
+
+        if (!imsUseEnabled) {
+            Rlog.w(LOG_TAG, "IMS is disabled and can not dial conference call directly.");
+            return null;
+        }
+
+        if (imsPhone != null) {
+            Rlog.w(LOG_TAG, "service state = " + imsPhone.getServiceState().getState());
+        }
+
+        if (imsUseEnabled && imsPhone != null
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
+            try {
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "Trying IMS PS conference call");
+                }
+                return imsPhone.dial(numbers, videoState);
+            } catch (CallStateException e) {
+                if (DBG) {
+                    Rlog.d(LOG_TAG, "IMS PS conference call exception " + e);
+                }
+                if (!Phone.CS_FALLBACK.equals(e.getMessage())) {
+                    CallStateException ce = new CallStateException(e.getMessage());
+                    ce.setStackTrace(e.getStackTrace());
+                    throw ce;
+                }
+            }
+        }
+        return null;
+    }
+    /// @}
+
+    /// M: ALPS03008063, IMS ECC should be dialed via the phone with main capability. @{
+    /**
+     * To get main capability phone id.
+     *
+     * @return The phone id with main capability.
+     */
+    private int getMainCapabilityPhoneId() {
+        int phoneId = SystemProperties.getInt(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, 1) - 1;
+        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
+            phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+        }
+        return phoneId;
+    }
+    /// @}
+
+    // MTK-START, SIM framework
+    /**
+     * Request security context authentication for USIM/SIM/ISIM
+     */
+    public void doGeneralSimAuthentication(int sessionId, int mode, int tag,
+            String param1, String param2, Message result) {
+        if (isPhoneTypeGsm()) {
+            mCi.doGeneralSimAuthentication(sessionId, mode, tag, param1, param2, result);
+        }
+    }
+
+    // MVNO API
+    public String getMvnoMatchType() {
+        String type = PhoneConstants.MVNO_TYPE_NONE;
+        if (isPhoneTypeGsm()) {
+            if (mIccRecords.get() != null) {
+                type = mIccRecords.get().getMvnoMatchType();
+            }
+            logd("getMvnoMatchType: Type = " + type);
+        }
+        return type;
+    }
+
+    public String getMvnoPattern(String type) {
+        String pattern = "";
+        if (isPhoneTypeGsm()) {
+            if (mIccRecords.get() != null) {
+                if (type.equals(PhoneConstants.MVNO_TYPE_SPN)) {
+                    pattern = mIccRecords.get().getSpNameInEfSpn();
+                } else if (type.equals(PhoneConstants.MVNO_TYPE_IMSI)) {
+                    pattern = mIccRecords.get().isOperatorMvnoForImsi();
+                } else if (type.equals(PhoneConstants.MVNO_TYPE_PNN)) {
+                    pattern = mIccRecords.get().isOperatorMvnoForEfPnn();
+                } else if (type.equals(PhoneConstants.MVNO_TYPE_GID)) {
+                    pattern = mIccRecords.get().getGid1();
+                } else {
+                    logd("getMvnoPattern: Wrong type = " + type);
+                }
+            }
+        }
+        return pattern;
+    }
+
+    public int getCdmaSubscriptionActStatus() {
+        return (mCdmaSSM != null) ? mCdmaSSM.getActStatus() : 0;
+    }
+    // MTK-END, SIM framework
+
+    /// M: SS @{
+    /**
+     * Check whether GSM support UT interface for the
+     * supplementary service configuration or not.
+     *
+     * @return true if support UT interface in GSMPhone
+     */
+    public boolean isGsmUtSupport() {
+        if (SystemProperties.get("persist.mtk_ims_support").equals("1")
+                && SystemProperties.get("persist.mtk_volte_support").equals("1")
+                && OperatorUtils.isGsmUtSupport(getOperatorNumeric()) && isUsimCard()) {
+            boolean isWfcEnable = (mImsPhone != null) && (mImsPhone.isWifiCallingEnabled());
+            boolean isWfcUtSupport = isWFCUtSupport();
+            if (DBG) logd("in isGsmUtSupport isWfcEnable -->"+isWfcEnable + "isWfcUtSupport-->"
+                    + isWfcUtSupport);
+            if (isWfcEnable && !isWfcUtSupport) {
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Check whether WifiCalling support UT interface for the
+     * supplementary service configuration or not.
+     *
+     * @return true if support UT interface in GSMPhone
+     */
+    public boolean isWFCUtSupport() {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        if (SystemProperties.get("persist.mtk_ims_support").equals("1") &&
+                SystemProperties.get("persist.mtk_wfc_support").equals("1")) {
+            if (OperatorUtils.isNotSupportWFCUt(getOperatorNumeric())) {
+                return false;
+            } else {
+                return true;
+            }
+        }
+        return false;
+
+    }
+
+    private boolean isUsimCard() {
+        if (isPhoneTypeGsm()) {
+            boolean r = false;
+            String iccCardType = PhoneFactory.getPhone(getPhoneId()).
+                    getIccCard().getIccCardType();
+            if (iccCardType != null && iccCardType.equals("USIM")) {
+                r = true;
+            }
+            Rlog.d(LOG_TAG, "isUsimCard: " + r + ", " + iccCardType);
+            return r;
+        } else {
+            String prop = null;
+            String values[] = null;
+            int subId = SubscriptionManager.getSubIdUsingPhoneId(getPhoneId());
+            int slotId = SubscriptionManager.getSlotId(subId);
+            if (slotId < 0 || slotId >= PROPERTY_RIL_FULL_UICC_TYPE.length) {
+                return false;
+            }
+            prop = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[slotId], "");
+            if ((!prop.equals("")) && (prop.length() > 0)) {
+                values = prop.split(",");
+            }
+            Rlog.d(LOG_TAG, "isUsimCard PhoneId = " + getPhoneId() +
+                    " cardType = " + Arrays.toString(values));
+            if (values == null) {
+                return false;
+            }
+            for (String s : values) {
+                if (s.equals("USIM")) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    public boolean isOpNotSupportOCB(String facility) {
+        boolean r = false;
+        boolean isOcb = false;
+        if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)
+                || facility.equals(CommandsInterface.CB_FACILITY_BAOIC)
+                || facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+            isOcb = true;
+        }
+        if (isOcb && OperatorUtils.isNotSupportOCB(getOperatorNumeric())) {
+            r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpNotSupportOCB: " + r + ", facility=" + facility);
+        return r;
+    }
+
+    private boolean isOp(OPID id) {
+        return OperatorUtils.isOperator(getOperatorNumeric(), id);
+    }
+
+    private boolean isOpTbcwWithCS(int phoneId) {
+        boolean r = false;
+        if (OperatorUtils.isNotSupportXcap(getOperatorNumeric())) {
+            /* For those operators which do not use CS network based CW */
+            if (!OperatorUtils.isNotSupportXcapButUseTBCW(getOperatorNumeric())) {
+                r = true;
+            }
+        }
+        Rlog.d(LOG_TAG, "isOpTbcwWithCS: " + r);
+        return r;
+    }
+
+    /**
+     * Check whether Operator support TBCLIR.
+     *
+     * @param phoneId input current phone id.
+     * @return true if Operator support TBCLIR.
+     */
+    public boolean isOpTbClir() {
+        boolean r = false;
+        if (OperatorUtils.isTbClir(getOperatorNumeric())) {
+            r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpTbClir: " + r);
+        return r;
+    }
+
+    public void setServiceClass(int serviceClass) {
+        Rlog.d(LOG_TAG, "setServiceClass: " + serviceClass);
+        SystemProperties.set(SS_SERVICE_CLASS_PROP, String.valueOf(serviceClass));
+    }
+
+    /**
+     * Check whether Operator support NwCW.
+     *
+     * @return true if Operator support NwCW.
+     */
+    public boolean isOpNwCW() {
+        boolean r = false;
+        if (OperatorUtils.isNwCW(getOperatorNumeric())) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpNwCW():" + r);
+        return r;
+    }
+
+    /**
+     * Get the enable/disable for 409 conflict response.
+     * @return Operator support 409 response.
+     */
+    public boolean isEnableXcapHttpResponse409() {
+        boolean r = false;
+        if (OperatorUtils.isEnableXcapHttpResponse409(getOperatorNumeric())) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isEnableXcapHttpResponse409: " + r);
+        return r;
+    }
+
+    public boolean isOpTransferXcap404() {
+        boolean r = false;
+        if (OperatorUtils.isTransferXcap404(getOperatorNumeric())) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpTransferXcap404: " + r);
+        return r;
+    }
+
+    public boolean isOpNotSupportCallIdentity() {
+        boolean r = false;
+        if (OperatorUtils.isNotSupportCallIdentity(getOperatorNumeric())) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpNotSupportCallIdentity: " + r);
+        return r;
+    }
+
+    public boolean isOpReregisterForCF() {
+        boolean r = false;
+        if (OperatorUtils.isReregisterForCF(getOperatorNumeric())) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isOpReregisterForCF: " + r);
+        return r;
+    }
+
+    private boolean isIccCardMncMccAvailable(int phoneId) {
+        UiccController uiccCtl = UiccController.getInstance();
+        IccRecords iccRecords = uiccCtl.getIccRecords(phoneId, UiccController.APP_FAM_3GPP);
+        if (iccRecords != null) {
+            String mccMnc = iccRecords.getOperatorNumeric();
+            Rlog.d(LOG_TAG, "isIccCardMncMccAvailable(): phone id : " + phoneId + ", mccMnc: "
+                    + mccMnc);
+            return (mccMnc != null);
+        }
+        Rlog.d(LOG_TAG, "isIccCardMncMccAvailable(): phone id : " + phoneId + ", false");
+        return false;
+    }
+
+    // + [ALPS02301009]
+    /**
+     * Check whether Operator support save the cf number to sharedpref.
+     * @return true if Operator support save the cf number to sharedpref.
+     */
+    public boolean isSupportSaveCFNumber() {
+        boolean r = false;
+        if (OperatorUtils.isSupportSaveCFNumber(getOperatorNumeric())) {
+            r = true;
+        }
+        Rlog.d(LOG_TAG, "isSupportSaveCFNumber: " + r);
+        return r;
+    }
+
+    /**
+     * Clear CF number in sharedpref.
+     * @param cfReason input call forwarding reason.
+     */
+    public void clearCFSharePreference(int cfReason) {
+        String key = null;
+        switch (cfReason) {
+            case CF_REASON_BUSY:
+                key = CFB_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NO_REPLY:
+                key = CFNR_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NOT_REACHABLE:
+                key = CFNRC_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            default:
+                Rlog.e(LOG_TAG, "No need to store cfreason: " + cfReason);
+                return;
+        }
+
+        Rlog.e(LOG_TAG, "Read to clear the key: " + key);
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        SharedPreferences.Editor editor = sp.edit();
+        editor.remove(key);
+        if (!editor.commit()) {
+            Rlog.e(LOG_TAG, "failed to commit the removal of CF preference: " + key);
+        } else {
+            Rlog.e(LOG_TAG, "Commit the removal of CF preference: " + key);
+        }
+    }
+
+    /**
+     * Store the CF number in sharedpref.
+     *
+     * @param cfReason input cf reason.
+     * @param setNumber is numebr.
+     * @return true if save success.
+     */
+    public boolean applyCFSharePreference(int cfReason, String setNumber) {
+        String key = null;
+        switch (cfReason) {
+            case CF_REASON_BUSY:
+                key = CFB_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NO_REPLY:
+                key = CFNR_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NOT_REACHABLE:
+                key = CFNRC_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            default:
+                Rlog.d(LOG_TAG, "No need to store cfreason: " + cfReason);
+                return false;
+        }
+
+        IccRecords r = mIccRecords.get();
+        if (r == null) {
+            Rlog.d(LOG_TAG, "No iccRecords");
+            return false;
+        }
+
+        String currentImsi = r.getIMSI();
+
+        if (currentImsi == null || currentImsi.isEmpty()) {
+            Rlog.d(LOG_TAG, "currentImsi is empty");
+            return false;
+        }
+
+        if (setNumber == null || setNumber.isEmpty()) {
+            Rlog.d(LOG_TAG, "setNumber is empty");
+            return false;
+        }
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        SharedPreferences.Editor editor = sp.edit();
+
+        String content = currentImsi + ";" + setNumber;
+
+        if (content == null || content.isEmpty()) {
+            Rlog.e(LOG_TAG, "imsi or content are empty or null.");
+            return false;
+        }
+
+        Rlog.e(LOG_TAG, "key: " + key);
+        Rlog.e(LOG_TAG, "content: " + content);
+
+        editor.putString(key, content);
+        editor.apply();
+
+        return true;
+    }
+
+    /**
+     * Get previous CF number.
+     *
+     * @param cfReason input cf reason.
+     * @return cf numebr from previous setting.
+     */
+    public String getCFPreviousDialNumber(int cfReason) {
+        String key = null;
+        switch (cfReason) {
+            case CF_REASON_BUSY:
+                key = CFB_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NO_REPLY:
+                key = CFNR_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            case CF_REASON_NOT_REACHABLE:
+                key = CFNRC_KEY + "_" + String.valueOf(mPhoneId);
+                break;
+            default:
+                Rlog.d(LOG_TAG, "No need to do the reason: " + cfReason);
+                return null;
+        }
+
+        Rlog.d(LOG_TAG, "key: " + key);
+
+        IccRecords r = mIccRecords.get();
+        if (r == null) {
+            Rlog.d(LOG_TAG, "No iccRecords");
+            return null;
+        }
+
+        String currentImsi = r.getIMSI();
+
+        if (currentImsi == null || currentImsi.isEmpty()) {
+            Rlog.d(LOG_TAG, "currentImsi is empty");
+            return null;
+        }
+
+        Rlog.d(LOG_TAG, "currentImsi: " + currentImsi);
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+        String info = sp.getString(key, null);
+
+        if (info == null) {
+            Rlog.d(LOG_TAG, "Sharedpref not with: " + key);
+            return null;
+        }
+
+        String[] infoAry = info.split(";");
+
+        if (infoAry == null || infoAry.length < 2) {
+            Rlog.d(LOG_TAG, "infoAry.length < 2");
+            return null;
+        }
+
+        String imsi = infoAry[0];
+        String number = infoAry[1];
+
+        if (imsi == null || imsi.isEmpty()) {
+            Rlog.d(LOG_TAG, "Sharedpref imsi is empty.");
+            return null;
+        }
+
+        if (number == null || number.isEmpty()) {
+            Rlog.d(LOG_TAG, "Sharedpref number is empty.");
+            return null;
+        }
+
+        Rlog.d(LOG_TAG, "Sharedpref imsi: " + imsi);
+        Rlog.d(LOG_TAG, "Sharedpref number: " + number);
+
+        if (currentImsi.equals(imsi)) {
+            Rlog.d(LOG_TAG, "Get dial number from sharepref: " + number);
+            return number;
+        } else {
+            SharedPreferences.Editor editor = sp.edit();
+            editor.remove(key);
+            if (!editor.commit()) {
+                Rlog.e(LOG_TAG, "failed to commit the removal of CF preference: " + key);
+            }
+        }
+
+        return null;
+    }
+
+    private static final String CFB_KEY = "CFB";
+    private static final String CFNR_KEY = "CFNR";
+    private static final String CFNRC_KEY = "CFNRC";
+    // - [ALPS02301009]
+
+    public boolean queryCFUAgainAfterSet() {
+        boolean r = false;
+        if (OperatorUtils.isQueryCFUAgainAfterSet(getOperatorNumeric())) {
+            r = true;
+        }
+        Rlog.d(LOG_TAG, "queryCFUAgainAfterSet: " + r);
+        return r;
+    }
+    /// @}
+
+    // M: nw START
+
+    @Override
+    public void refreshSpnDisplay(){
+        mSST.refreshSpnDisplay();
+    }
+
+    @Override
+    public int getNetworkHideState(){
+        if (mSST.dontUpdateNetworkStateFlag == true) {
+            return ServiceState.STATE_OUT_OF_SERVICE;
+        } else {
+            return mSST.mSS.getState();
+        }
+    }
+
+    @Override
+    public String getLocatedPlmn(){
+        return mSST.getLocatedPlmn();
+    }
+    // M: nw END
+
+    // MTK-START
+    /**
+     * Check if card type is cdma only card.
+     * @return true: cdma only card; false: not cdma only card
+     */
+    private boolean isCdmaOnlyCard() {
+        UiccCardApplication uiccApplication3gpp = mUiccController.getUiccCardApplication(
+                mPhoneId, UiccController.APP_FAM_3GPP);
+        UiccCardApplication uiccApplication3gpp2 = mUiccController.getUiccCardApplication(
+                mPhoneId, UiccController.APP_FAM_3GPP2);
+        return (uiccApplication3gpp == null && uiccApplication3gpp2 != null);
+    }
+    // MTK-END
+    // @}
+
+    public boolean isNotSupportUtToCS() {
+        boolean r = false;
+        if (((SystemProperties.get("persist.mtk_ct_volte_support").equals("1") &&
+                isOp(OPID.OP09) && isUsimCard()) || isOp(OPID.OP117))
+                && !getServiceState().getRoaming()) {
+           r = true;
+        }
+        Rlog.d(LOG_TAG, "isNotSupportUtToCS: " + r);
+        return r;
+    }
+
+    private boolean is93MDSupport() {
+        boolean r = false;
+        if (SystemProperties.get("ro.md_auto_setup_ims").equals("1")) {
+            r = true;
+        }
+        return r;
+    }
+
+    /// M: 93 Ims SS native solution @{
+    private boolean isUtError(CommandException.Error error) {
+       /*
+        * CME_NETWORK_TIMEOUT              CommandException.Error.OEM_ERROR_3
+        * CME_404_NOT_FOUND                CommandException.Error.OEM_ERROR_4
+        * CME_409_CONFLICT                 CommandException.Error.OEM_ERROR_5
+        * CME_412_PRECONDITION_FAILED      CommandException.Error.OEM_ERROR_6
+       */
+       if (error == CommandException.Error.OEM_ERROR_3 ||
+            error == CommandException.Error.OEM_ERROR_4 ||
+            error == CommandException.Error.OEM_ERROR_5 ||
+            error == CommandException.Error.OEM_ERROR_6 ||
+            error == CommandException.Error.UT_XCAP_409_CONFLICT ||
+            error == CommandException.Error.UT_UNKNOWN_HOST) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+
+    /// M: Support ut ss for ct card @{
+    private boolean isGsmSsPrefer() {
+        if ((SystemProperties.get("persist.mtk_ct_volte_support").equals("1") &&
+                isOp(OPID.OP09)) || isOp(OPID.OP117)) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+
+    /* Must Make sure the following four things are ready : "ICCID, MCCMNC,
+     * IccRecord, CS Service" before query CS/PS CFU or update utCfuMode.
+     */
+    synchronized private boolean checkEventQueryCfuReady() {
+        boolean checkEQC = true;
+        SubscriptionManager subMgr = SubscriptionManager.from(mContext);
+        SubscriptionInfo mySubInfo = null;
+        if (subMgr != null) {
+            mySubInfo = subMgr.getActiveSubscriptionInfo(getSubId());
+        }
+
+        if (!isIccCardMncMccAvailable(getPhoneId())) {
+            Rlog.d(LOG_TAG, "checkEventQueryCfu, MCCMNC is not ready");
+            checkEQC = false;
+        }
+        if (!((mySubInfo != null) && (mySubInfo.getIccId() != null))) {
+            Rlog.d(LOG_TAG, "checkEventQueryCfu, IccId is not ready");
+            checkEQC = false;
+        }
+        if (mIccRecords.get() == null) {
+            Rlog.d(LOG_TAG, "checkEventQueryCfu, IccRecord is not ready");
+            checkEQC = false;
+        }
+        if (!(mSST != null && mSST.mSS != null
+                && (mSST.mSS.getState() == ServiceState.STATE_IN_SERVICE))){
+            Rlog.d(LOG_TAG, "checkEventQueryCfu, CS Service is not ready");
+            checkEQC = false;
+        }
+
+        return checkEQC;
+    }
+
+    synchronized private void handleSubInfoChange() {
+        SubscriptionManager subMgr = SubscriptionManager.from(mContext);
+        SubscriptionInfo mySubInfo = null;
+        if (subMgr != null) {
+            mySubInfo = subMgr.getActiveSubscriptionInfo(getSubId());
+        }
+
+        String mySettingName = CFU_QUERY_ICCID_PROP + getPhoneId();
+        String oldIccId = SystemProperties.get(mySettingName, "");
+
+        String defaultQueryCfuMode = PhoneConstants.CFU_QUERY_TYPE_DEF_VALUE;
+        if (mSupplementaryServiceExt != null) {
+            defaultQueryCfuMode = mSupplementaryServiceExt.getOpDefaultQueryCfuMode();
+            Rlog.d(LOG_TAG, "defaultQueryCfuMode = " + defaultQueryCfuMode);
+        }
+        String cfuSetting = SystemProperties.get(PhoneConstants.CFU_QUERY_TYPE_PROP,
+                        defaultQueryCfuMode);
+
+        /* Only when MCCMNC is ready, All of the SS functions
+         * in the following can be exceuted
+         */
+        if (!isIccCardMncMccAvailable(getPhoneId())) {
+            return;
+        }
+
+        if ((mySubInfo != null) && (mySubInfo.getIccId() != null)) {
+            if (cfuSetting.equals("2")) {
+                Rlog.d(LOG_TAG, "Always query CFU.");
+                if (mSST != null && mSST.mSS != null
+                        && (mSST.mSS.getState() == ServiceState.STATE_IN_SERVICE)) {
+                    needQueryCfu = true;
+                    sendMessage(obtainMessage(EVENT_QUERY_CFU));
+                }
+            } else if (!mySubInfo.getIccId().equals(oldIccId)) {
+                /* If the SIM card has been changed (be detected first time), set the flag
+                 * "isChanged" to 1, then initialize some SS varibles and query CFU status.
+                 */
+                Rlog.d(LOG_TAG, " mySubId " + getSubId() + " mySettingName "
+                        + Rlog.pii(SDBG, mySettingName) + " old iccid : "
+                        + Rlog.pii(SDBG, oldIccId) + " new iccid : "
+                        + Rlog.pii(SDBG, mySubInfo.getIccId()) + " phoneId : "
+                        + getPhoneId());
+                SystemProperties.set(mySettingName, mySubInfo.getIccId());
+                String isChanged = CFU_QUERY_SIM_CHANGED_PROP + getPhoneId();
+                SystemProperties.set(isChanged, "1");
+                mSSInit = false;
+                handleSuppServInitIfSimChanged();
+            } else if (mySubInfo.getIccId().equals(oldIccId)) {
+                Rlog.d(LOG_TAG, "oldIccId = " + oldIccId + " , phoneId : " + getPhoneId());
+                /* If the SIM card is the same, need to query utCfuMode to update the CFU Icon */
+                if (mIccRecords.get() == null) {
+                    Rlog.d(LOG_TAG, "skip sending EVENT_QUERY_CFU due to IccRecords null.");
+                } else {
+                    // Before we send EVENT_QUERR_CFU, need to make sure the state is in service
+                    if (mSST != null && mSST.mSS != null
+                            && (mSST.mSS.getState() == ServiceState.STATE_IN_SERVICE)) {
+                        needQueryCfu = true;
+                        Rlog.d(LOG_TAG, "handleSubInfoChange, Send EVENT_QUERY_CFU" +
+                                ", phoneId = " + getPhoneId());
+                        sendMessage(obtainMessage(EVENT_QUERY_CFU));
+                    }
+                }
+            }
+
+            Rlog.d(LOG_TAG, "handleSubInfoChange: mTbcwMode = " + mTbcwMode);
+            if (mTbcwMode == TBCW_UNKNOWN) {
+                if (isOpTbcwWithCS(getPhoneId())) {
+                    setTbcwMode(TBCW_OPTBCW_WITH_CS);
+                    setTbcwToEnabledOnIfDisabled();
+                }
+            }
+        }
+    }
+
+    // If mIccRecords.get() is null, then return.
+    // After mIccRecords is ready from SIMRecords, this function would be called again.
+    synchronized private void handleSuppServInitIfSimChanged() {
+        if (mIccRecords.get() == null) {
+            Rlog.d(LOG_TAG, "skip handleSuppServInitIfSimChanged due to IccRecords null.");
+            return;
+        }
+
+        String isChangedProp = CFU_QUERY_SIM_CHANGED_PROP + getPhoneId();
+        String isChanged = SystemProperties.get(isChangedProp, "0");
+        Rlog.d(LOG_TAG, "handleSuppServInitIfSimChanged: isChanged = " + isChanged +
+                ", mSSInit = " + mSSInit);
+
+        if (isChanged.equals("1")) {
+            if (!mSSInit) {
+                setCsFallbackStatus(PhoneConstants.UT_CSFB_PS_PREFERRED);
+                setTbcwMode(TBCW_UNKNOWN);  //reset to unknow due to sim change.
+                setSystemProperty(SS_CW_TBCW_EVER_ENABLE_PROP, "0");
+                setSystemProperty(PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE,
+                        TERMINAL_BASED_CALL_WAITING_DISABLED);
+                /// M: SS OP01 Ut
+                saveTimeSlot(null);
+
+                // Remove the CLIR setting for new SIM
+                SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
+                int clirSetting = sp.getInt(CLIR_KEY + getPhoneId(), -1);
+                if (clirSetting != -1) {
+                    SharedPreferences.Editor editor = sp.edit();
+                    editor.remove(CLIR_KEY + getPhoneId());
+                    if (!editor.commit()) {
+                        Rlog.e(LOG_TAG, "failed to commit the removal of CLIR preference");
+                    }
+                }
+
+                setSystemProperty(PROPERTY_UT_CFU_NOTIFICATION_MODE,
+                        UT_CFU_NOTIFICATION_MODE_DISABLED);
+
+                mSSInit = true;
+            }
+
+            needQueryCfu = true;
+
+            // Before we send EVENT_QUERR_CFU, need to make sure the state is in service
+            Phone imsPhone = mImsPhone;
+            if ((mSST != null && mSST.mSS != null
+                    && (mSST.mSS.getState() == ServiceState.STATE_IN_SERVICE)) ||
+                    ((imsPhone != null) && (
+                            (imsPhone.getServiceState().getState() ==
+                                    ServiceState.STATE_IN_SERVICE)))) {
+                Rlog.d(LOG_TAG, "handleSuppServInitIfSimChanged, Send EVENT_QUERY_CFU" +
+                        ", phoneId = " + getPhoneId());
+                sendMessage(obtainMessage(EVENT_QUERY_CFU));
+            }
+        }
+    }
+
+    @Override
+    public void setVoiceCallForwardingFlag(int line, boolean enable, String number) {
+        super.setVoiceCallForwardingFlag(line, enable, number);
+        if (isNotSupportUtToCS() && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+            notifyCallForwardingIndicator();
+        }
+    }
+
+    @Override
+    public boolean getCallForwardingIndicator() {
+        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA && !isNotSupportUtToCS()) {
+            Rlog.e(LOG_TAG, "getCallForwardingIndicator: not possible in CDMA");
+            return false;
+        }
+        return super.getCallForwardingIndicator();
+    }
+}
