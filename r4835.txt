Index: packages/apps/Dialer/res/drawable/remove_icon_selector.xml
===================================================================
--- packages/apps/Dialer/res/drawable/remove_icon_selector.xml	(revision 0)
+++ packages/apps/Dialer/res/drawable/remove_icon_selector.xml	(revision 4835)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:exitFadeDuration="@android:integer/config_mediumAnimTime">
+   <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
+   <item android:state_focused="false" android:state_pressed="true" android:drawable="@drawable/list_selector_background_transition_holo_light" />
+</selector>
Index: packages/apps/Dialer/res/drawable/list_selector_background_transition_holo_light.xml
===================================================================
--- packages/apps/Dialer/res/drawable/list_selector_background_transition_holo_light.xml	(revision 0)
+++ packages/apps/Dialer/res/drawable/list_selector_background_transition_holo_light.xml	(revision 4835)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<transition xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/list_pressed_holo_light"  />
+    <item android:drawable="@drawable/list_longpressed_holo"  />
+</transition>
Index: packages/apps/Dialer/res/values/dimens.xml
===================================================================
--- packages/apps/Dialer/res/values/dimens.xml	(revision 4834)
+++ packages/apps/Dialer/res/values/dimens.xml	(revision 4835)
@@ -173,4 +173,7 @@
     <dimen name="call_type_icon_size">12dp</dimen>
 
     <dimen name="tab_unread_count_margin_left">0dp</dimen>
+	<!-- SpeedDial -->
+	<dimen name="actionbar_contentInsetStart">72dp</dimen>
+	<dimen name="action_bar_height">64dp</dimen>
 </resources>
Index: packages/apps/Dialer/res/values/colors.xml
===================================================================
--- packages/apps/Dialer/res/values/colors.xml	(revision 4834)
+++ packages/apps/Dialer/res/values/colors.xml	(revision 4835)
@@ -138,5 +138,10 @@
     <!-- Grey 700 -->
     <color name="call_detail_footer_text_color">#616161</color>
     <color name="call_detail_footer_icon_tint">@color/call_detail_footer_text_color</color>
+	<!-- SpeedDial -->
+	<color name="actionbar_background_color">#0288d1</color>
+	<color name="phone_settings_actionbar_text_color">#FFFFFF</color>
+	<color name="actionbar_background_color_dark">#0277bd</color>
+    <color name="phone_settings_background_color">#f5f5f5</color>
 
 </resources>
Index: packages/apps/Dialer/res/values/styles.xml
===================================================================
--- packages/apps/Dialer/res/values/styles.xml	(revision 4834)
+++ packages/apps/Dialer/res/values/styles.xml	(revision 4835)
@@ -343,4 +343,32 @@
         <item name="android:layout_height">1dp</item>
         <item name="android:background">?android:attr/listDivider</item>
     </style>
+	<!-- SpeedDial -->
+	<style name="SettingsLight" parent="android:Theme.Material.Light">
+        <item name="android:windowBackground">@color/phone_settings_background_color</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:actionBarStyle">@style/DialtactsActionBarStyle</item>
+        <item name="android:actionMenuTextColor">@color/phone_settings_actionbar_text_color</item>
+        <item name="android:actionOverflowButtonStyle">@style/DialtactsActionBarOverflow</item>
+        <item name="android:homeAsUpIndicator">@drawable/ic_back_arrow</item>
+        <item name="android:windowActionBarOverlay">false</item>
+        <item name="android:colorPrimaryDark">@color/actionbar_background_color_dark</item>
+        <!-- Setting text. -->
+        <item name="android:textColorPrimary">@color/settings_text_color_primary</item>
+        <!-- Setting description. -->
+        <item name="android:textColorSecondary">@color/settings_text_color_secondary</item>
+    </style>
+	<style name="DialtactsActionBarStyle" parent="android:Widget.Material.ActionBar">
+        <item name="android:background">@color/actionbar_background_color</item>
+        <item name="android:titleTextStyle">@style/DialtactsActionBarTitleText</item>
+        <item name="android:height">@dimen/action_bar_height</item>
+        <!-- Empty icon -->
+        <item name="android:icon">@android:color/transparent</item>
+        <!-- Shift the title text to the right -->
+        <item name="android:contentInsetStart">@dimen/actionbar_contentInsetStart</item>
+    </style>
+	<style name="DialtactsActionBarTitleText"
+           parent="@android:style/TextAppearance.Holo.Widget.ActionBar.Title">
+        <item name="android:textColor">@color/phone_settings_actionbar_text_color</item>
+    </style>
 </resources>
Index: packages/apps/Dialer/res/values/strings.xml
===================================================================
--- packages/apps/Dialer/res/values/strings.xml	(revision 4834)
+++ packages/apps/Dialer/res/values/strings.xml	(revision 4835)
@@ -999,4 +999,16 @@
     <string name="search_sw_version">SW Version</string>
     <string name="search_hw_version">HW Version</string>
     <string name="search_customer_ver_external_title">Version Info</string>
+	<!--  SpeedDial   -->
+	<string name="start_video_dial">Make video call</string>
+	<string name="call_speed_dial">Numeric key speed dial</string>
+	<string name="call_log_auto_rejected_label">Auto rejected calls</string>
+	<string name="remove_black_list">Remove from black list</string>
+	<string name="type_missed_video">Missed video call</string>
+	<string name="sd_add">Add</string>
+	<string name="cancel">Cancel</string>
+    <string name="invalid_number">The number format is not support, please select another nubmer.</string>
+
+
+	
 </resources>
\ No newline at end of file
Index: packages/apps/Dialer/res/drawable-hdpi/ic_add_person_dk.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Dialer/res/drawable-hdpi/ic_add_person_dk.png
===================================================================
--- packages/apps/Dialer/res/drawable-hdpi/ic_add_person_dk.png	(revision 0)
+++ packages/apps/Dialer/res/drawable-hdpi/ic_add_person_dk.png	(revision 4835)

Property changes on: packages/apps/Dialer/res/drawable-hdpi/ic_add_person_dk.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Dialer/res/drawable-hdpi/ic_arrow_back_24dp.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Dialer/res/drawable-hdpi/ic_arrow_back_24dp.png
===================================================================
--- packages/apps/Dialer/res/drawable-hdpi/ic_arrow_back_24dp.png	(revision 0)
+++ packages/apps/Dialer/res/drawable-hdpi/ic_arrow_back_24dp.png	(revision 4835)

Property changes on: packages/apps/Dialer/res/drawable-hdpi/ic_arrow_back_24dp.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Dialer/res/drawable-hdpi/list_longpressed_holo.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Dialer/res/drawable-hdpi/list_longpressed_holo.9.png
===================================================================
--- packages/apps/Dialer/res/drawable-hdpi/list_longpressed_holo.9.png	(revision 0)
+++ packages/apps/Dialer/res/drawable-hdpi/list_longpressed_holo.9.png	(revision 4835)

Property changes on: packages/apps/Dialer/res/drawable-hdpi/list_longpressed_holo.9.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Dialer/res/drawable-hdpi/list_pressed_holo_light.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Dialer/res/drawable-hdpi/list_pressed_holo_light.9.png
===================================================================
--- packages/apps/Dialer/res/drawable-hdpi/list_pressed_holo_light.9.png	(revision 0)
+++ packages/apps/Dialer/res/drawable-hdpi/list_pressed_holo_light.9.png	(revision 4835)

Property changes on: packages/apps/Dialer/res/drawable-hdpi/list_pressed_holo_light.9.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Dialer/res/drawable-hdpi/ic_call_autoreject_arrow.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Dialer/res/drawable-hdpi/ic_call_autoreject_arrow.png
===================================================================
--- packages/apps/Dialer/res/drawable-hdpi/ic_call_autoreject_arrow.png	(revision 0)
+++ packages/apps/Dialer/res/drawable-hdpi/ic_call_autoreject_arrow.png	(revision 4835)

Property changes on: packages/apps/Dialer/res/drawable-hdpi/ic_call_autoreject_arrow.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Dialer/res/layout/mtk_speed_dial_list_item.xml
===================================================================
--- packages/apps/Dialer/res/layout/mtk_speed_dial_list_item.xml	(revision 0)
+++ packages/apps/Dialer/res/layout/mtk_speed_dial_list_item.xml	(revision 4835)
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="60dip"
+    android:focusable="false" >
+
+    <TextView android:id="@+id/sd_index"
+        android:layout_width="48dip"
+        android:layout_height="48dip"
+        android:paddingLeft="2dip"
+        android:paddingTop="2dip"
+        android:paddingBottom="2dip"
+        android:textStyle="normal"
+        android:textSize="30sp"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:layout_alignParentBottom="true"
+        android:gravity="center"
+    />
+
+ 	<ImageView
+        android:id="@+id/sd_photo"
+        android:layout_width="50dip"
+        android:layout_height="50dip"
+        android:layout_marginTop="5dip"
+        android:layout_marginRight="3dip"
+        android:layout_toRightOf="@id/sd_index"
+        style="@*android:style/Widget.QuickContactBadge.WindowMedium"
+        android:gravity="center"
+    />
+
+    <TextView android:id="@+id/sd_label"
+        android:textStyle="bold"
+        android:textSize="13sp"
+        android:singleLine="true"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:paddingBottom="4dip"
+        android:paddingRight="2dip"
+        android:layout_toRightOf="@id/sd_photo"
+        android:layout_alignWithParentIfMissing="true"
+        android:layout_alignParentBottom="true"
+        android:ellipsize="end"
+        android:maxWidth="100dip"
+        android:visibility="gone" />
+
+    <com.mediatek.dialer.speeddial.DontPressWithParentImageView
+        android:id="@+id/sd_remove"
+        android:src="@drawable/ic_remove"
+        android:layout_width="@android:dimen/app_icon_size"
+        android:layout_height="match_parent"
+        android:minHeight="?android:attr/listPreferredItemHeight"
+        android:background="@drawable/remove_icon_selector"        
+        android:layout_alignParentRight="true"
+        android:layout_marginLeft="3dip"
+        android:layout_marginRight="14dip"
+        android:layout_marginTop="8dip"
+        android:visibility="gone" />
+
+    <TextView android:id="@+id/sd_number"
+        android:textStyle="normal"
+        android:textSize="13sp"
+        android:singleLine="true"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:paddingBottom="4dip"
+        android:paddingRight="2dip"
+        android:layout_toRightOf="@id/sd_label"
+        android:layout_toLeftOf="@id/sd_remove"
+        android:layout_alignWithParentIfMissing="true"
+        android:layout_alignParentBottom="true"
+        android:ellipsize="marquee"
+        android:visibility="gone" />
+
+    <TextView android:id="@+id/sd_name"
+        android:textStyle="normal"
+        android:textSize="20sp"
+        android:textAlignment="viewStart"
+        android:gravity="left"
+        android:textDirection="ltr"
+        android:singleLine="true"
+        android:paddingRight="2dip"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_toRightOf="@id/sd_photo"
+        android:layout_toLeftOf="@id/sd_remove"
+        android:layout_above="@id/sd_number" 
+        android:ellipsize="marquee"/>
+
+</RelativeLayout>
\ No newline at end of file
Index: packages/apps/Dialer/res/layout/mtk_speed_dial_input_dialog.xml
===================================================================
--- packages/apps/Dialer/res/layout/mtk_speed_dial_input_dialog.xml	(revision 0)
+++ packages/apps/Dialer/res/layout/mtk_speed_dial_input_dialog.xml	(revision 4835)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingLeft="15dip"
+    android:paddingRight="15dip"
+    android:orientation="horizontal">
+
+    <EditText
+        android:id="@+id/number"
+        android:layout_width="0dip"
+        android:layout_height="48dip"
+        android:layout_weight="0.8"
+        android:layout_marginTop="16dip"
+        android:inputType="phone"/>
+
+    <ImageView
+        android:id="@+id/contacts"
+        android:layout_width="0dip"
+        android:layout_height="48dip"
+        android:layout_weight="0.2"
+        android:layout_gravity="center_vertical"
+        style="?android:attr/buttonBarButtonStyle"
+        android:src="@drawable/ic_add_person_dk"/>
+
+</LinearLayout>
\ No newline at end of file
Index: packages/apps/Dialer/AndroidManifest.xml
===================================================================
--- packages/apps/Dialer/AndroidManifest.xml	(revision 4834)
+++ packages/apps/Dialer/AndroidManifest.xml	(revision 4835)
@@ -85,6 +85,9 @@
     <uses-permission android:name="android.permission.REBOOT" />
    <!--for Conference call-->
    <uses-permission android:name="com.mediatek.permission.CTA_CONFERENCE_CALL" />
+   
+   <permission android:name="android.permission.READ_SPEED_DIAL" />
+   <permission android:name="android.permission.WRITE_SPEED_DIAL" />    
 
 
     <application
@@ -414,6 +417,21 @@
                 <action android:name="android.intent.action.MAIN" />
             </intent-filter>
         </activity>
+		<activity android:name="com.mediatek.dialer.speeddial.SpeedDialActivity"
+            android:label="@string/call_speed_dial"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:theme="@style/SettingsLight">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+		 <provider android:name="com.mediatek.dialer.speeddial.SpeedDialProvider" 
+            android:authorities="speed_dial"
+            android:exported="true"
+            android:multiprocess="true"
+            android:readPermission="android.permission.READ_SPEED_DIAL"
+            android:writePermission="android.permission.WRITE_SPEED_DIAL"/>
 		
 		<receiver
             android:name="com.mediatek.dialer.mmi.AccessCallReceiver"
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallLogExtension.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallLogExtension.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallLogExtension.java	(revision 4835)
@@ -0,0 +1,533 @@
+package com.mediatek.dialer.speeddial;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.v13.app.FragmentPagerAdapter;
+import android.provider.CallLog.Calls;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MenuItem.OnMenuItemClickListener;
+import android.widget.HorizontalScrollView;
+import android.widget.TextView;
+import android.widget.TableLayout.LayoutParams;
+import android.text.TextUtils;
+import android.view.View;
+import android.graphics.drawable.Drawable;
+
+import com.android.dialer.calllog.CallLogListItemViewHolder;
+import com.android.dialer.R;
+
+
+import com.mediatek.common.PluginImpl;
+import com.mediatek.dialer.ext.DefaultCallLogExtension;
+import com.mediatek.dialer.ext.ICallLogAction;
+import com.mediatek.dialer.ext.ICallLogExtension;
+
+import java.lang.ref.WeakReference;
+
+import java.util.HashMap;
+import java.util.List;
+
+public class CallLogExtension extends DefaultCallLogExtension
+        implements PhoneStateUtils.OnChangedListener {
+    private static final String TAG = "Op01CallLogExtension";
+
+    public static final int CALL_TYPE_ALL = -1;
+    private boolean mAutoRejectedFilterMode = false;
+    private OnMenuItemClickListener mAutoRejectMenuClickListener ;
+    private int mAutoRejectMenuId = -1;
+    //private Activity mCallLogActivity;
+    public static String AUTO_REJECTION_KEY = "AUTO_REJECTION";
+    private int mPosition = 0;
+    //map the host activity instance and the mAutoRejectedFilterMode
+    private HashMap<Activity, Boolean> mRefMap = new HashMap<Activity, Boolean>();
+    private WeakReference<CallLogListItemViewHolder> mCallLogListItemViewHolder;
+
+    private PhoneStateUtils mPhoneStateUtils;
+    private Context mPluginContext = null;
+
+    /**
+     * constructor
+     * @param context the current context
+     */
+    public CallLogExtension(Context context) {
+        mPluginContext = context;
+        mPhoneStateUtils = PhoneStateUtils.getInstance(context);
+        mPhoneStateUtils.addPhoneStateListener(this);
+    }
+
+    @Override
+    public void onCallStatusChange(int state) {
+        updateActions(state);
+    }
+
+    @Override
+    public void showActions(Object obj, boolean show) {
+        Log.d(TAG, "showActions, show = " + show);
+        if (obj instanceof CallLogListItemViewHolder) {
+            CallLogListItemViewHolder holder = (CallLogListItemViewHolder) obj;
+            if (holder != null && holder.confCallNumbers != null) {
+                Log.d(TAG, "showActions, conference calllog.");
+                return;
+            }
+
+            if (show) {
+                mCallLogListItemViewHolder =
+                        new WeakReference<CallLogListItemViewHolder> (holder);
+            } else {
+                if (mCallLogListItemViewHolder != null) {
+                    CallLogListItemViewHolder preHolder = mCallLogListItemViewHolder.get();
+                    if (preHolder != null && preHolder == holder) {
+                        mCallLogListItemViewHolder = null;
+                    }
+                }
+            }
+        }
+    }
+
+    private void updateActions(int state) {
+        if (mCallLogListItemViewHolder == null) {
+            return;
+        }
+
+        CallLogListItemViewHolder holder = mCallLogListItemViewHolder.get();
+        if (holder == null || holder.actionsView == null ||
+            holder.videoCallButtonView == null) {
+            return;
+        }
+
+        if (state != TelephonyManager.CALL_STATE_IDLE) {
+            Log.d(TAG, "updateActions, set visibility as GONE.");
+            holder.videoCallButtonView.setVisibility(View.GONE);
+        } else {
+            if (mPhoneStateUtils.hasVideoCapability()) {
+                Log.d(TAG, "updateActions, set visibility as VISIBLE.");
+                holder.videoCallButtonView.setVisibility(View.VISIBLE);
+            }
+        }
+    }
+
+
+    /**
+     * for op01
+     * @param context the current context
+     * @param pagerAdapter the view pager adapter used in activity
+     * @param tabs the ViewPagerTabs used in activity
+     */
+    public void restoreFragments(Context context,
+            FragmentPagerAdapter pagerAdapter, HorizontalScrollView tabs) {
+        boolean bRejected = false;
+        if (mRefMap.containsKey(context)) {
+            bRejected = mRefMap.get(context);
+        }
+
+        if (pagerAdapter != null) {
+            pagerAdapter.notifyDataSetChanged();
+            Log.d(TAG, "restoreFragments(), notifyDataSetChanged");
+        }
+        Log.d(TAG, "restoreFragments() mAutoRejectedFilterMode : " + mAutoRejectedFilterMode);
+        if (bRejected) {
+            try {
+                final Context cont = context.createPackageContext("com.mediatek.op01.plugin",
+                        Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
+                tabs.removeAllViews();
+                Resources resources = cont.getResources();
+                int backgroundColor = resources.getColor(R.color.actionbar_background_color);
+                tabs.setBackgroundColor(backgroundColor);
+                TextView textView = new TextView(cont);
+                textView.setBackgroundColor(backgroundColor);
+                final String autoRejectTitle = cont.getString(R.string.call_log_auto_rejected_label);
+                textView.setText(autoRejectTitle);
+                textView.setGravity(Gravity.CENTER);
+                textView.setTextColor(Color.WHITE);
+                tabs.addView(textView, new LayoutParams(LayoutParams.MATCH_PARENT,
+                        LayoutParams.MATCH_PARENT));
+            } catch (NameNotFoundException e) {
+                Log.d(TAG, "no com.mediatek.op01.plugin packages");
+            }
+        }
+    }
+
+    /**
+     * for op01
+     * @param activity the current activity
+     * @param outState save state
+     */
+    @Override
+    public void onSaveInstanceState(Activity activity, Bundle outState) {
+        Log.d(TAG, "onSaveInstanceState mAutoRejectedFilterMode = " + mAutoRejectedFilterMode);
+        if (mRefMap.containsKey(activity)) {
+            mRefMap.put(activity, mAutoRejectedFilterMode);
+        }
+        outState.putBoolean(AUTO_REJECTION_KEY, mAutoRejectedFilterMode);
+    }
+
+    /**
+     * for op01
+     * called when host create menu, to add plug-in own menu here
+     * @param activity the current activity
+     * @param menu menu
+     * @param viewPagerTabs the ViewPagerTabs used in activity
+     * @param callLogAction callback plug-in need if things need to be done by host
+     */
+    @Override
+    public void createCallLogMenu(Activity activity, Menu menu,
+            HorizontalScrollView viewPagerTabs, ICallLogAction callLogAction) {
+        Log.d(TAG, "createCallLogMenu");
+        //mCallLogActivity = activity;
+        final Activity fCallLogActivity = activity;
+        final ICallLogAction fCallLogAction = callLogAction;
+        final HorizontalScrollView fViewPagerTabs = viewPagerTabs;
+        try {
+            final Context cont = fCallLogActivity.getApplicationContext().createPackageContext(
+                    "com.mediatek.op01.plugin",
+                    Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
+
+            int index = menu.size();
+            MenuItem autoRejectMenu = menu.add(Menu.NONE, index, index, cont.getText(
+                    R.string.call_log_auto_rejected_label));
+            mAutoRejectMenuId = autoRejectMenu.getItemId();
+            autoRejectMenu.setOnMenuItemClickListener(mAutoRejectMenuClickListener =
+                new OnMenuItemClickListener() {
+                @Override
+                public boolean onMenuItemClick(MenuItem item) {
+                    Log.d(TAG, "Auto reject onMenuItemClick");
+                    if (fCallLogAction != null) {
+                        mAutoRejectedFilterMode = true;
+                        Log.d(TAG, "OnMenuItemClickListener() mRefMap.put mAutoRejectedFilterMode"
+                            + mAutoRejectedFilterMode);
+                        mRefMap.put(fCallLogActivity, mAutoRejectedFilterMode);
+                        fCallLogAction.updateCallLogScreen();
+                    }
+                    fViewPagerTabs.removeAllViews();
+                    Resources resources = cont.getResources();
+                    int backgroundColor = resources.getColor(R.color.actionbar_background_color);
+                    fViewPagerTabs.setBackgroundColor(backgroundColor);
+                    TextView textView = new TextView(cont);
+                    textView.setBackgroundColor(backgroundColor);
+                    final String autoRejectTitle = cont.getString(
+                            R.string.call_log_auto_rejected_label);
+                    textView.setText(autoRejectTitle);
+                    textView.setGravity(Gravity.CENTER);
+                    textView.setTextColor(Color.WHITE);
+                    fViewPagerTabs.addView(textView, new LayoutParams(LayoutParams.MATCH_PARENT,
+                            LayoutParams.MATCH_PARENT));
+                    return true;
+                }
+            });
+        } catch (NameNotFoundException e) {
+            Log.d(TAG, "no com.mediatek.op01.plugin packages");
+        }
+    }
+
+    /**
+     * for op01
+     * called when host prepare menu, prepare plug-in own menu here
+     * @param activity the current activity
+     * @param menu the Menu Created
+     * @param fragment the current fragment
+     * @param itemDeleteAll the optionsmenu delete all item
+     * @param adapterCount adapterCount
+     */
+    public void prepareCallLogMenu(Activity activity, Menu menu,
+            Fragment fragment, MenuItem itemDeleteAll, int adapterCount) {
+        if (activity == null) {
+            mAutoRejectedFilterMode = false;
+        }
+        Log.d(TAG, "prepareCallLogMenu isAutoRejectedFilterMode: " + mAutoRejectedFilterMode);
+        if (mAutoRejectMenuId >= 0) {
+            menu.findItem(mAutoRejectMenuId).setVisible(!mAutoRejectedFilterMode);
+        }
+
+        if (mAutoRejectedFilterMode) {
+            if (fragment != null && itemDeleteAll != null) {
+                Log.d(TAG, "prepareCallLogMenu() adapter account: " + adapterCount);
+                itemDeleteAll.setVisible(adapterCount > 0);
+            }
+        }
+
+    }
+
+    /**
+     * for op01
+     * @param activity the current activity
+     * @param pagerAdapter the view pager adapter used in activity
+     * @param item item
+     * @return true if do not need further operation in host
+     */
+    public boolean onHomeButtonClick(Activity activity, FragmentPagerAdapter pagerAdapter,
+            MenuItem item) {
+        Log.d(TAG, "onHomeButtonClick");
+        if (activity != null) {
+
+            if (mRefMap.containsKey(activity)) {
+                mAutoRejectedFilterMode = mRefMap.get(activity);
+                Log.d(TAG, "onHomeButtonClick() mRefMap.put mAutoRejectedFilterMode"
+                        + mAutoRejectedFilterMode);
+            }
+            if (mAutoRejectedFilterMode && (item.getItemId() == android.R.id.home)) {
+                mAutoRejectedFilterMode = false;
+                mRefMap.remove(activity);
+                if (pagerAdapter != null) {
+                    pagerAdapter.notifyDataSetChanged();
+                    Log.d(TAG, "onHomeButtonClick(), notifyDataSetChanged");
+                }
+
+                final Intent intent = new Intent();
+                intent.setClassName("com.android.dialer",
+                        "com.android.dialer.calllog.CallLogActivity");
+                activity.startActivity(intent);
+                activity.finish();
+                return true;
+            }
+        } else {
+            mAutoRejectedFilterMode = false;
+            mRefMap.put(activity, mAutoRejectedFilterMode);
+        }
+        return false;
+    }
+
+    /**
+     * for op01
+     * called when host press back key
+     * @param activity the current activity
+     * @param pagerAdapter the view pager adapter used in activity
+     * @param callLogAction call back function
+     */
+    @Override
+    public void onBackPressed(Activity activity, FragmentPagerAdapter pagerAdapter,
+            ICallLogAction callLogAction) {
+        Log.d(TAG, "onBackPressed mRefMap = " + mRefMap + " activity = " + activity);
+        if (activity != null) {
+            if (mRefMap.containsKey(activity)) {
+                mAutoRejectedFilterMode = mRefMap.get(activity);
+            }
+
+            if (mAutoRejectedFilterMode) {
+                mAutoRejectedFilterMode = false;
+                mRefMap.put(activity, mAutoRejectedFilterMode);
+                //mRefMap.remove(activity);
+                Log.d(TAG, "onBackPressed mRefMap.remove(activity) successful");
+                if (pagerAdapter != null) {
+                    pagerAdapter.notifyDataSetChanged();
+                    Log.d(TAG, "onBackPressed(), notifyDataSetChanged");
+                }
+
+                final Intent intent = new Intent();
+                intent.setClassName("com.android.dialer",
+                        "com.android.dialer.calllog.CallLogActivity");
+                Log.d(TAG, "onBackPressed activity.startActivity(intent)");
+                activity.startActivity(intent);
+                activity.finish();
+            } else {
+                callLogAction.processBackPressed();
+            }
+        } else {
+            mAutoRejectedFilterMode = false;
+            callLogAction.processBackPressed();
+            mRefMap.put(activity, mAutoRejectedFilterMode);
+        }
+    }
+
+    /**
+     * for op01
+     * @param typeFiler current query type
+     * @param builder the query selection Stringbuilder
+     * @param selectionArgs the query selection args, modify to change query selection
+     */
+    @Override
+    public void appendQuerySelection(int typeFiler, StringBuilder builder,
+            List<String> selectionArgs) {
+        Log.d(TAG, "appendQuerySelection mAutoRejectedFilterMode = " +
+            mAutoRejectedFilterMode);
+
+        String strbuilder = null;
+        if (CALL_TYPE_ALL == typeFiler && !mAutoRejectedFilterMode) {
+            if (builder.length() > 0) {
+                builder.append(" AND ");
+            }
+            strbuilder = Calls.TYPE + "!=" + Calls.AUTO_REJECT_TYPE;
+            builder.append(strbuilder);
+        }
+        if (mAutoRejectedFilterMode) {
+            Log.d(TAG, "selectionArgs1: " + selectionArgs);
+            if (typeFiler > CALL_TYPE_ALL) {
+                if (!selectionArgs.isEmpty()) {
+                    selectionArgs.set(1, Integer.toString(Calls.AUTO_REJECT_TYPE));
+                }
+            } else if (typeFiler == CALL_TYPE_ALL) {
+                selectionArgs.add(0, Integer.toString(Calls.AUTO_REJECT_TYPE));
+            }
+            Log.d(TAG, "selectionArgs2: " + selectionArgs);
+            if (builder.length() > 0 && (builder.indexOf("(type = ?)") == -1)) {
+                String strbuild = "(type = ?) AND ";
+                builder.insert(0, strbuild);
+            } else if (builder.length() == 0) {
+                builder.append("(type = ?)");
+            }
+        }
+
+        Log.d(TAG, "builder: " + builder);
+    }
+
+    /**
+     * for op01
+     * called when updating tab count
+     * @param activity the current activity
+     * @param count count
+     * @return tab count
+     */
+    @Override
+    public int getTabCount(Activity activity, int count) {
+        Log.d(TAG, "getTabCount, mRefMap: " + mRefMap);
+        boolean bRejected = false;
+        if (!mRefMap.isEmpty() && mRefMap.containsKey(activity)) {
+            bRejected = (Boolean) mRefMap.get(activity);
+        }
+        if (bRejected) {
+            count = 1;
+        }
+        Log.d(TAG, "getTabCount, count: " + count);
+        return count;
+    }
+
+    /**.
+     * for op01
+     * plug-in set position
+     * @param position to set
+     */
+    @Override
+    public void setPosition(int position) {
+        Log.d(TAG, "setPosition()-->position " + position);
+        mPosition = position;
+    }
+
+    /**.
+     * for op01
+     * plug-in get current position
+     * @param position position
+     * @return get the position
+     */
+    @Override
+    public int getPosition(int position) {
+        if (mAutoRejectedFilterMode) {
+            return mPosition;
+        }
+        return position;
+    }
+
+    /**.
+     * for op01
+     * plug-in manage the state and unregister receiver
+     * @param activity the current activity
+     */
+    public void onDestroy(Activity activity) {
+        if (!mRefMap.isEmpty() && mRefMap.containsKey(activity)) {
+            mRefMap.remove(activity);
+        }
+        mAutoRejectedFilterMode = false;
+        Log.d(TAG, "onDestroy()-->mAutoRejectedFilterMode " + mAutoRejectedFilterMode);
+    }
+
+    /**.
+     * for op01
+     * plug-in reset the reject mode in the host
+     * @param activity the current activity
+     * @param bundle bundle
+     */
+    public void onCreate(Activity activity, Bundle bundle) {
+        if(bundle != null) {
+            mAutoRejectedFilterMode = bundle.getBoolean(AUTO_REJECTION_KEY, false);
+        } else {
+            mAutoRejectedFilterMode = false;
+        }
+        mRefMap.put(activity, mAutoRejectedFilterMode);
+    }
+
+    /**.
+     * for op01
+     * plug-in reset the reject mode in the host
+     * @param activity the current activity
+     */
+    @Override
+    public void resetRejectMode(Activity activity) {
+        if (!mRefMap.isEmpty() && mRefMap.containsKey(activity)) {
+            mAutoRejectedFilterMode = (Boolean) mRefMap.get(activity);
+            return;
+        }
+        mAutoRejectedFilterMode = false;
+    }
+
+    /**.
+     * for op01
+     * plug-in get the auto reject icon
+     * @return return the auto reject icon
+     */
+    public Drawable getAutoRejectDrawable() {
+        Resources res = mPluginContext.getResources();
+        return res.getDrawable(R.drawable.ic_call_autoreject_arrow);
+    }
+
+    /**
+     * for op01.
+     * plug-in whether is auto reject mode
+     * @return call log show state
+     */
+    public boolean isAutoRejectMode() {
+        return mAutoRejectedFilterMode;
+    }
+
+    /**
+     * for op01.
+     * plug-in insert auto reject icon resource for dialer search
+     * @param callTypeDrawable callTypeDrawable
+     */
+    public void addResourceForDialerSearch(HashMap<Integer, Drawable>
+            callTypeDrawable) {
+        if (callTypeDrawable != null) {
+            Resources res = mPluginContext.getResources();
+            Drawable drawable = res.getDrawable(R.drawable.ic_call_autoreject_arrow);
+            callTypeDrawable.put(Calls.AUTO_REJECT_TYPE, drawable);
+        }
+    }
+
+    /**
+     * for op01.
+     * plug-in always show video call back button
+     * @return true in op01
+     */
+    public boolean showVideoForAllCallLog() {
+        return true;
+    }
+
+    /**
+     * for op01.
+     * plug-in we do not use google default blocked number features
+     * @return false in op01
+     */
+    public boolean shouldUseBlockedNumberFeature() {
+        return false;
+    }
+
+    /**
+     * for op01
+     * @param hostVideoEnabled host video enabled
+     * @param Object other params
+     */
+    @Override
+    public boolean isVideoButtonEnabled(boolean hostVideoEnabled, Object...params) {
+        Boolean canPlaceCall =
+            (Boolean)params[ICallLogExtension.VIDEO_BUTTON_PARAMS_INDEX_PLACE_CALL];
+        return (hostVideoEnabled && canPlaceCall && mPhoneStateUtils.canStartVideoCall());
+    }
+
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDial.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDial.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDial.java	(revision 4835)
@@ -0,0 +1,19 @@
+package com.mediatek.dialer.speeddial;
+
+import android.net.Uri;
+
+import android.provider.BaseColumns;
+
+class SpeedDial {
+
+    public static final String AUTHORITY = "speed_dial";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY);
+
+
+    public static class Numbers implements BaseColumns {
+        public static final Uri CONTENT_URI = Uri.parse("content://speed_dial/numbers");
+        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/numbers";
+        public static final String NUMBER = "number";
+        public static final String TYPE = "type";
+    }
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallDetailExtension.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallDetailExtension.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/CallDetailExtension.java	(revision 4835)
@@ -0,0 +1,277 @@
+package com.mediatek.dialer.speeddial;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.SystemProperties;
+import android.provider.CallLog.Calls;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.MenuItem.OnMenuItemClickListener;
+import android.widget.TextView;
+import com.android.dialer.R;
+
+
+import com.mediatek.common.PluginImpl;
+import com.mediatek.dialer.ext.DefaultCallDetailExtension;
+
+
+
+public class CallDetailExtension extends DefaultCallDetailExtension {
+    private static final String TAG = "Op01CallDetailExtension";
+
+    private static final int BLACK_LIST_MENU_ID = 10002;
+    private static final Uri CONTENT_URI = Uri.parse("content://com.cmcc.ccs.black_list");
+    public static final String PHONE_NUMBER = "BLACKLIST_PHONE_NUMBER";
+    public static final String NAME = "BLACKLIST_NAME";
+    private static final String[] BLACK_LIST_PROJECTION = {
+        PHONE_NUMBER
+    };
+
+    /**
+     * for op01
+     * @param durationView the duration text
+     */
+    @Override
+    public void setDurationViewVisibility(TextView durationView) {
+        Log.d(TAG, "setDurationViewVisibility : GONE");
+        durationView.setVisibility(View.GONE);
+    }
+
+    /**
+     * for op01,add for "blacklist" in call detail.
+     * @param menu blacklist menu.
+     * @param number phone number.
+     * @param name contact name.
+     */
+    @Override
+    public void onPrepareOptionsMenu(Context context, Menu menu, CharSequence number,
+            CharSequence name) {
+        /* feature options    
+        if (!SystemProperties.get("ro.mtk_op01_rcs").equals("1") ) {
+            return;
+        }*/
+
+        Log.d(TAG, "onPrepareOptionsMenu, number: " + number + " name: " + name);
+        if (name == null || name.length() == 0) {
+            return;
+        }
+
+        String strNumber = "";
+        String strName = name.toString();
+        if (number != null && number.length() > 0) {
+            strNumber = number.toString();
+        }
+        int index = strNumber.indexOf(" ");
+        if (index >= 0) {
+            strNumber = strNumber.substring(index + 1);
+            strNumber = strNumber.replace(",", "");
+            strNumber = strNumber.replace(";", "");
+        }
+        String strCopyName = new String(strName);
+        strCopyName = strCopyName.replace(",", "");
+        strCopyName = strCopyName.replace(";", "");
+
+        boolean isNumber = isNumberString(strNumber);
+        boolean isNameNumber = isNumberString(strCopyName);
+        Log.d(TAG, "onPrepareOptionsMenu, isNameNumber: " + isNameNumber + " isNumber: " + isNumber);
+
+        if (isNumber) {
+            Log.d(TAG, "onPrepareOptionsMenu, strName: " + strName);
+        } else if (isNameNumber){
+            strNumber = strCopyName;
+            strName = "";
+        } else if (!isNumber && !isNameNumber) {
+            return;
+        }
+
+        final String phoneName = strName;
+        final String phoneNumber = strNumber;
+        Log.d(TAG, "onPrepareOptionsMenu, phoneNumber: " + phoneNumber + " phoneName: " + phoneName);
+        if (phoneNumber == null || phoneNumber.length() == 0) {
+            return;
+        }
+
+        MenuItem blackListMenu = menu.findItem(BLACK_LIST_MENU_ID);
+        boolean isAutoRejectNumber = autoReject(context, phoneNumber);
+        if (blackListMenu != null) {
+            menu.removeItem(BLACK_LIST_MENU_ID);
+        }
+
+        int menuIndex = menu.size();
+        final Context fnContext = context;
+        try {
+            final Context pluginContext = context.createPackageContext("com.mediatek.op01.plugin",
+                    Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
+            if (isAutoRejectNumber) {
+                blackListMenu = menu.add(Menu.NONE, BLACK_LIST_MENU_ID, menuIndex,
+                        context.getText(R.string.remove_black_list));
+                blackListMenu.setOnMenuItemClickListener(new OnMenuItemClickListener() {
+                    @Override
+                    public boolean onMenuItemClick(MenuItem item) {
+                        removeblackNumber(fnContext, phoneNumber);
+                        return true;
+                    }
+                });
+            } else {
+                //blackListMenu = menu.add(Menu.NONE, BLACK_LIST_MENU_ID, menuIndex,
+                        //pluginContext.getText(R.string.add_black_list));
+                blackListMenu.setOnMenuItemClickListener(new OnMenuItemClickListener() {
+                    @Override
+                    public boolean onMenuItemClick(MenuItem item) {
+                        addblackNumber(fnContext, phoneNumber, phoneName);
+                        return true;
+                    }
+                });
+            }
+        }  catch (NameNotFoundException e) {
+            Log.d(TAG, "no com.mediatek.op01.plugin packages");
+        }
+    }
+
+    /**
+     * check if the call should be rejected.
+     * @param number the incoming call number.
+     * @return the result that the current number should be auto reject.
+     */
+    public boolean autoReject(Context context, String number) {
+        Log.d(TAG, "auto Reject");
+        boolean result = false;
+        try {
+            Cursor cursor = context.getContentResolver().query(CONTENT_URI,
+                    BLACK_LIST_PROJECTION, null, null, null);
+            if (cursor == null) {
+                Log.d(TAG, "cursor is null...");
+                return false;
+            }
+            try {
+                String blockNumber;
+                cursor.moveToFirst();
+                while (!cursor.isAfterLast()) {
+                    blockNumber = cursor.getString(0);
+                    if (PhoneNumberUtils.compare(number, blockNumber)) {
+                        result = true;
+                        break;
+                    }
+                    cursor.moveToNext();
+                }
+            }
+            finally {
+                cursor.close();
+            }
+        } catch (Exception e) {
+            Log.d(TAG, "autoReject cursor exception");
+        }
+        return result;
+    }
+
+    /**
+     * Add a pair of number and name to device's blacklist.
+     * @param number the phone number, it's mandatory.
+     * @param name the display name, it's optional.
+     * @return ture if the data was added successfully, otherwise false.
+     */
+    public boolean addblackNumber(Context context, String number, String name) {
+        try {
+            Log.d(TAG, "add black Number");
+
+            ContentValues values = new ContentValues();
+            values.put(PHONE_NUMBER, number);
+            values.put(NAME, name);
+
+            Uri resultUri = context.getContentResolver().insert(CONTENT_URI, values);
+
+            if (resultUri == null) {
+                return false;
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Remove a number from device's blacklist.
+     * @param number the phone number, it's mandatory.
+     * @return ture if the data was removed successfully, otherwise false.
+     */
+    public boolean removeblackNumber(Context context, String number) {
+        try {
+            Log.d(TAG, "remove black Number");
+            Uri uri = Uri.withAppendedPath(CONTENT_URI, Uri.encode(number));
+            int retCount = context.getContentResolver().delete(uri, null, null);
+            if (retCount <= 0) {
+                return false;
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * @param string.
+     * @return true if string is number string.
+     */
+    public boolean isNumberString(String string) {
+        boolean isNumber = false;
+        String strCopy = removeSpaces(string);
+        /*char firstChar = strCopy.charAt(0);
+        if (firstChar == '+') {
+            strCopy = strCopy.substring(1);
+        }*/
+        int index = strCopy.indexOf('+');
+        Log.d(TAG, "isNumberString index: " + index);
+        if(index == 0) {
+            strCopy = strCopy.substring(index+1);
+        }
+        if (strCopy.length() > 0) {
+            isNumber = strCopy.matches("[0-9]+");
+        }
+        Log.d(TAG, "isNumberString strCopy: " + strCopy);
+        return isNumber;
+    }
+
+    /**
+     * for OP01, change call type text.
+     * @param context context
+     * @param callTypeTextView callTypeTextView
+     * @param isVideoCall isVideoCall
+     * @param callType callType
+     */
+    public void changeVideoTypeText(Context context, TextView callTypeTextView,
+            boolean isVideoCall, int callType) {
+        Log.d(TAG, "changeVideoTypeText isVideoCall: " + isVideoCall + " callType = " + callType);
+        if (Calls.AUTO_REJECT_TYPE != callType) {
+            return;
+        }
+
+        try {
+            final Context pluginContext = context.createPackageContext("com.mediatek.op01.plugin",
+                        Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
+            if (callTypeTextView != null && context != null && isVideoCall) {
+                callTypeTextView.setText(pluginContext.getText(R.string.type_missed_video));
+            }
+        }  catch (NameNotFoundException e) {
+            Log.d(TAG, "no com.mediatek.op01.plugin packages");
+        }
+    }
+
+    /**
+     * remove all spaces in string.
+     * @param strValue string passed in
+     */
+    private String removeSpaces(String strValue) {
+        String strCopy = new String(strValue);
+        strCopy = strCopy.trim();
+        strCopy = strCopy.replaceAll(" ", "");
+        return strCopy;
+    }
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DialPadExtension.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DialPadExtension.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DialPadExtension.java	(revision 4835)
@@ -0,0 +1,371 @@
+package com.mediatek.dialer.speeddial;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telecom.VideoProfile;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.ContextThemeWrapper;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MenuItem.OnMenuItemClickListener;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.PopupMenu;
+
+import com.android.contacts.common.list.ContactListItemView;
+
+import com.mediatek.common.PluginImpl;
+import com.mediatek.dialer.ext.DefaultDialPadExtension;
+import com.mediatek.dialer.ext.IDialPadExtension;
+import com.mediatek.telephony.TelephonyManagerEx;
+import com.android.dialer.R;
+
+import java.lang.ref.WeakReference;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class DialPadExtension extends DefaultDialPadExtension
+    implements View.OnLongClickListener, PhoneStateUtils.OnChangedListener {
+
+    private static final String TAG = "DialPadExtension";
+
+    private static final boolean DEBUG = ("eng".equals(Build.TYPE) ||
+                                        "userdebug".equals(Build.TYPE));
+
+    private Activity mHostActivity;
+    private String mHostPackage;
+    private Resources mHostResources;
+    private EditText mEditText;
+    private Context mContext;
+    private int mMenuId = 0x1000;
+
+    private PhoneStateUtils mPhoneStateUtils;
+    WeakReference<ContactListItemView> mContactListItemView;
+    WeakReference<Menu> mMenu;
+
+    public final static int SHORTCUT_DIRECT_CALL = 0;
+    public final static int SHORTCUT_CREATE_NEW_CONTACT = 1;
+    public final static int SHORTCUT_ADD_TO_EXISTING_CONTACT = 2;
+    public final static int SHORTCUT_SEND_SMS_MESSAGE = 3;
+    public final static int SHORTCUT_MAKE_VIDEO_CALL = 4;
+    public final static int SHORTCUT_BLOCK_NUMBER = 5;
+
+    /**
+     * for op01
+     * @param durationView the duration text
+     */
+
+    public DialPadExtension (Context context) {
+        super();
+		Log.d("yujunjie", "DialPadExtension:DialPadExtension()...");
+        mContext = context;
+        mPhoneStateUtils = PhoneStateUtils.getInstance(context);
+        mPhoneStateUtils.addPhoneStateListener(this);
+    }
+
+    @Override
+    public void buildOptionsMenu(final Activity activity, Menu menu){
+        mPhoneStateUtils.setCurrentActiviy(activity);
+        int index = menu.size();
+        MenuItem speedDialMenu = menu.add(Menu.NONE,
+                index, 0, mContext.getText(R.string.call_speed_dial));
+        speedDialMenu.setOnMenuItemClickListener(new OnMenuItemClickListener() {
+            public boolean onMenuItemClick(MenuItem item) {
+                Log.d(TAG, "SpeedDial onMenuItemClick");
+                SpeedDialController.getInstance().enterSpeedDial(activity);
+                return true;
+            }
+        });
+    }
+
+    @Override
+    public void onViewCreated(Activity activity, View view) {
+        Log.d(TAG, "onViewCreated.");
+		Log.d("yujunjie", "DialPadExtension:onViewCreated()...");
+        mHostActivity = activity;
+
+        mHostPackage = activity.getPackageName();
+        mHostResources = activity.getResources();
+
+        View two = (View) view.findViewById(mHostResources.getIdentifier("two",
+                                "id", mHostPackage));
+        two.setOnLongClickListener(this);
+
+        View three = (View) view.findViewById(mHostResources.getIdentifier("three",
+                                "id", mHostPackage));
+        three.setOnLongClickListener(this);
+
+        View four = (View) view.findViewById(mHostResources.getIdentifier("four",
+                                "id", mHostPackage));
+        four.setOnLongClickListener(this);
+
+        View five = (View) view.findViewById(mHostResources.getIdentifier("five",
+                                "id", mHostPackage));
+        five.setOnLongClickListener(this);
+
+        View six = (View) view.findViewById(mHostResources.getIdentifier("six",
+                                "id", mHostPackage));
+        six.setOnLongClickListener(this);
+
+        View seven = (View) view.findViewById(mHostResources.getIdentifier("seven",
+                                "id", mHostPackage));
+        seven.setOnLongClickListener(this);
+
+        View eight = (View) view.findViewById(mHostResources.getIdentifier("eight",
+                                "id", mHostPackage));
+        eight.setOnLongClickListener(this);
+
+        View nine = (View) view.findViewById(mHostResources.getIdentifier("nine",
+                                "id", mHostPackage));
+        nine.setOnLongClickListener(this);
+
+        mEditText = (EditText) view.findViewById(mHostResources.getIdentifier("digits",
+                                "id", mHostPackage));
+    }
+
+    @Override
+    public boolean onLongClick(View view) {
+    	Log.d("yujunjie", "DialPadExtension:onLongClick()...");
+        int id = view.getId();
+
+        int key = 0;
+        if (id == mHostResources.getIdentifier("two","id", mHostPackage)) {
+            key = 2;
+        }
+        else if (id == mHostResources.getIdentifier("three","id", mHostPackage)) {
+            key = 3;
+        }
+        else if (id == mHostResources.getIdentifier("four","id", mHostPackage)) {
+            key = 4;
+        }
+        else if (id == mHostResources.getIdentifier("five","id", mHostPackage)) {
+            key = 5;
+        }
+        else if (id == mHostResources.getIdentifier("six","id", mHostPackage)) {
+            key = 6;
+        }
+        else if (id == mHostResources.getIdentifier("seven","id", mHostPackage)) {
+            key = 7;
+        }
+        else if (id == mHostResources.getIdentifier("eight","id", mHostPackage)) {
+            key = 8;
+        }
+        else if (id == mHostResources.getIdentifier("nine","id", mHostPackage)) {
+            key = 9;
+        }
+
+        if (key > 0 && key < 10 && mEditText.getText().length() <= 1) {
+            SpeedDialController.getInstance().handleKeyLongProcess(mHostActivity, mContext, key);
+            mEditText.getText().clear();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public List<String> getSingleIMEI(List<String> list) {
+        Log.d(TAG, "getSingleIMEI");
+        if (list == null) {
+            return null;
+        }
+
+        if (isC2KSupport()) {
+            list.clear();
+            String meid = "";
+            int count = TelephonyManager.getDefault().getPhoneCount();
+            for (int i = 0; i < count; i++) {
+                String imei = TelephonyManager.getDefault().getImei(i);
+                if (DEBUG) {
+                    Log.d(TAG, "getSingleIMEI, imei = " + imei);
+                }
+                if (!TextUtils.isEmpty(imei)) {
+                    list.add("IMEI: " + imei);
+                }
+
+                if (TextUtils.isEmpty(meid)) {
+                    meid = TelephonyManagerEx.getDefault().getMeid(i);
+                    if (DEBUG) {
+                        Log.d(TAG, "getSingleIMEI, meid = " + meid);
+                    }
+                }
+            }
+            meid = "MEID:" + meid;
+            list.add(meid);
+        } else if (isSigleImeiEnabled()){
+            if (list.size() > 1) {
+                for (int i = list.size() - 1; i < list.size(); i++) {
+                    list.remove(i);
+                }
+            }
+        }
+        return list;
+    }
+
+    private boolean isSigleImeiEnabled() {
+        return SystemProperties.get("ro.mtk_single_imei").equals("1");
+    }
+
+    private boolean isC2KSupport() {
+         return "1".equals(SystemProperties.get("ro.boot.opt_c2k_support"));
+    }
+
+    @Override
+    public void constructPopupMenu(PopupMenu popupMenu, View anchorView, Menu menu) {
+        mMenu = new WeakReference<Menu> (menu);
+        MenuItem item = menu.findItem(mMenuId);
+        boolean canStart = mPhoneStateUtils.canStartVideoCall();
+        String number = mEditText.getText().toString();
+        if (DEBUG) {
+            Log.d(TAG, "constructPopupMenu, canStartVideoCall = "
+                                + canStart + ", number = " + number);
+        }
+
+        if ((!canStart) || TextUtils.isEmpty(number)) {
+            //Can not start video call, remove video call item
+            menu.removeItem(mMenuId);
+            return;
+        } else {
+            //Meaning already have video call item, just return
+            if (item != null) {
+                return;
+            }
+        }
+
+        MenuItem videoMenu = menu.add(Menu.NONE,
+                mMenuId, 0, mContext.getText(R.string.start_video_dial));
+        videoMenu.setOnMenuItemClickListener(new OnMenuItemClickListener() {
+            public boolean onMenuItemClick(MenuItem item) {
+                Log.d(TAG, "video onMenuItemClick");
+                placeOutgoingVideoCall();
+                return true;
+            }
+        });
+    }
+
+    private Uri getCallUri(String number) {
+        if (DEBUG) {
+            Log.d(TAG, "getCallUri, number = " + number);
+        }
+
+        if (PhoneNumberUtils.isUriNumber(number)) {
+             return Uri.fromParts(PhoneAccount.SCHEME_SIP, number, null);
+        }
+        return Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
+     }
+
+    private void placeOutgoingVideoCall() {
+        TelecomManager telecommMgr = (TelecomManager)
+                mContext.getSystemService(Context.TELECOM_SERVICE);
+        if (telecommMgr == null) {
+            return;
+        }
+
+        if (mHostActivity == null || mEditText == null) {
+            return;
+        }
+
+        final Intent intent = new Intent(Intent.ACTION_CALL,
+                        getCallUri(mEditText.getText().toString()));
+        intent.putExtra(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE,
+                VideoProfile.STATE_BIDIRECTIONAL);
+
+        telecommMgr.placeCall(intent.getData(), intent.getExtras());
+        mEditText.getText().clear();
+    }
+
+    @Override
+    public void onCallStatusChange(int state) {
+        Log.d(TAG, "onCallStatusChange");
+        updateShortcutView(state);
+        updateVideoMenuItem(state);
+    }
+
+    @Override
+    public void customizeDialerOptions(View view, int type, String number) {
+        Log.d(TAG, "customizeDialerOptions, type = " + type);
+        if (SHORTCUT_MAKE_VIDEO_CALL != type) {
+            return;
+        }
+        if (view instanceof ContactListItemView) {
+            ContactListItemView viewItem = (ContactListItemView) view;
+            mContactListItemView = new WeakReference<ContactListItemView> (viewItem);
+        }
+        updateShortcutView(mPhoneStateUtils.getPhoneState());
+    }
+
+    private void updateVideoMenuItem(int state) {
+        if (mMenu == null) {
+            return;
+        }
+
+        Menu menu = mMenu.get();
+        if (menu == null) {
+            return;
+        }
+
+        if (state != TelephonyManager.CALL_STATE_IDLE) {
+            MenuItem item = menu.findItem(mMenuId);
+            if (item != null) {
+                menu.removeItem(mMenuId);
+            }
+        } else {
+            MenuItem item = menu.findItem(mMenuId);
+            if (item != null) {
+                return;
+            }
+
+            if (mPhoneStateUtils.hasVideoCapability()) {
+                MenuItem videoMenu = menu.add(Menu.NONE,
+                        mMenuId, 0, mContext.getText(R.string.start_video_dial));
+                videoMenu.setOnMenuItemClickListener(new OnMenuItemClickListener() {
+                    public boolean onMenuItemClick(MenuItem item) {
+                        Log.d(TAG, "video onMenuItemClick");
+                        placeOutgoingVideoCall();
+                        return true;
+                    }
+                });
+            }
+        }
+    }
+
+    private void updateShortcutView(int state) {
+        if (mContactListItemView == null) {
+            return;
+        }
+
+        ContactListItemView view = mContactListItemView.get();
+        if (view == null) {
+            return;
+        }
+
+        if (state != TelephonyManager.CALL_STATE_IDLE) {
+            Log.d(TAG, "updateShortcutView set view as GONE.");
+            view.setVisibility(View.GONE);
+        } else {
+            if (mPhoneStateUtils.hasVideoCapability()) {
+                Log.d(TAG, "updateShortcutView set view as VISIBLE.");
+                view.setVisibility(View.VISIBLE);
+                view.invalidate();
+            }
+        }
+    }
+}
+
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/PhoneStateUtils.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/PhoneStateUtils.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/PhoneStateUtils.java	(revision 4835)
@@ -0,0 +1,194 @@
+package com.mediatek.dialer.speeddial;
+
+import android.app.Activity;
+import android.content.Context;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telephony.TelephonyManager;
+import android.telephony.PhoneStateListener;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+
+import java.lang.ref.WeakReference;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class PhoneStateUtils {
+    private static final String TAG = "PhoneStateUtils";
+
+    private TelephonyManager               mTelephonyManager;
+    //Listen for subinfo change, like sim hot plugin-out
+    private SubscriptionManager            mSubscriptionManager;
+    private OnSubscriptionsChangedListener mSubscriptionsChangedListener;
+
+    private final Set<OnChangedListener> mListeners = Collections.newSetFromMap(
+            new ConcurrentHashMap<OnChangedListener, Boolean>(5, 0.9f, 1));
+
+    private HashMap<Integer, OP01PhoneStateListener> mPhoneStateListeners =
+            new HashMap<Integer, OP01PhoneStateListener>();
+
+    private static TelecomManager mTelecommManager;
+
+    private static PhoneStateUtils mPhoneStateUtils;
+
+    private WeakReference<Activity> mDialtactsActivity;
+    private static Context mContext;
+
+    public static PhoneStateUtils getInstance(Context cnx) {
+        if (mPhoneStateUtils == null) {
+            mPhoneStateUtils = new PhoneStateUtils(cnx);
+        }
+        return mPhoneStateUtils;
+    }
+
+    private PhoneStateUtils(Context cnx) {
+        mContext = cnx;
+        init(cnx);
+        registerStateListener();
+        mTelecommManager = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
+    }
+
+    //Interface for CallStatusServicePresenter
+    public interface OnChangedListener {
+        public void onCallStatusChange(int state);
+    }
+
+    public void setCurrentActiviy(Activity activity) {
+        mDialtactsActivity = new WeakReference<Activity> (activity);
+    }
+
+    public void addPhoneStateListener(OnChangedListener listener) {
+        mListeners.add(listener);
+    }
+
+    private void updateState(int state) {
+        if (mDialtactsActivity == null ||
+            mDialtactsActivity.get() == null) {
+            return;
+        }
+
+        Activity activity = mDialtactsActivity.get();
+        activity.runOnUiThread( new Runnable() {
+                public void run() {
+                    for (OnChangedListener listener : mListeners) {
+                        listener.onCallStatusChange(state);
+                    }
+                }
+            });
+    }
+
+    private void init(Context cnx) {
+        mTelephonyManager = TelephonyManager.from(cnx);
+        mSubscriptionManager = SubscriptionManager.from(cnx);
+
+        mSubscriptionsChangedListener = new OnSubscriptionsChangedListener() {
+                                                @Override
+                                                public void onSubscriptionsChanged() {
+                                                    updateStateListener();
+                                                }
+                                            };
+    }
+
+    private void registerStateListener() {
+        android.util.Log.d(TAG, "registerStateListener");
+        List<SubscriptionInfo> infos =
+                mSubscriptionManager.getActiveSubscriptionInfoList();
+        if (infos == null) {
+            return;
+        }
+
+        for (SubscriptionInfo info : infos) {
+            int subId = info.getSubscriptionId();
+            if (!mPhoneStateListeners.containsKey(subId)) {
+                OP01PhoneStateListener listener = new OP01PhoneStateListener(subId);
+                mPhoneStateListeners.put(subId, listener);
+            }
+        }
+
+        //Listen for phone state changed
+        for (OP01PhoneStateListener listener : mPhoneStateListeners.values()) {
+            mTelephonyManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE);
+        }
+
+        //Listen for sim changed.
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionsChangedListener);
+    }
+
+    private void updateStateListener() {
+        android.util.Log.d(TAG, "updateStateListener");
+        List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
+        if (subInfos == null) {
+            return;
+        }
+
+        //We should remove all the item in mRichCallStateListener, and then add the listener again.
+        for (Integer id : mPhoneStateListeners.keySet()) {
+            int subId = id.intValue();
+            OP01PhoneStateListener listener = mPhoneStateListeners.get(id);
+            mTelephonyManager.listen(listener, PhoneStateListener.LISTEN_NONE);
+        }
+        mPhoneStateListeners.clear();
+
+        for (int i = 0; i < subInfos.size(); i++) {
+            int subId = subInfos.get(i).getSubscriptionId();
+            if (!mPhoneStateListeners.containsKey(subId)) {
+                OP01PhoneStateListener listener = new OP01PhoneStateListener(subId);
+                mPhoneStateListeners.put(subId, listener);
+                mTelephonyManager.listen(listener,
+                        PhoneStateListener.LISTEN_CALL_STATE);
+            }
+        }
+    }
+    public static boolean canStartVideoCall() {
+        return hasVideoCapability() && (getPhoneState() == TelephonyManager.CALL_STATE_IDLE);
+    }
+
+    public static boolean hasVideoCapability() {
+        if (mTelecommManager == null) {
+            return false;
+        }
+
+        List<PhoneAccountHandle> accountHandles =
+                mTelecommManager.getVideoCallCapablePhoneAccounts();
+        if (accountHandles != null && accountHandles.size() > 0) {
+            return true;
+        }
+
+        return false;
+    }
+
+    public static int getPhoneState() {
+        int state = TelephonyManager.CALL_STATE_IDLE;
+        final TelecomManager telecomManager = (TelecomManager) mContext
+                .getSystemService(Context.TELECOM_SERVICE);
+
+        if (telecomManager != null) {
+            state = telecomManager.getCallState();
+        }
+        return state;
+    }
+
+
+    private class OP01PhoneStateListener extends PhoneStateListener {
+        public OP01PhoneStateListener(int subId) {
+            super(subId);
+        }
+
+        @Override
+        public void onCallStateChanged(int state, String number) {
+            android.util.Log.d(TAG, "onCallStateChanged, state = " + state);
+            if (hasVideoCapability()) {
+                updateState(state);
+            }
+            android.util.Log.d(TAG, "onCallStateChanged exit");
+        }
+    }
+
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialController.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialController.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialController.java	(revision 4835)
@@ -0,0 +1,115 @@
+package com.mediatek.dialer.speeddial;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.ComponentName;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.text.TextUtils;
+import android.util.Log;
+import com.android.dialer.R;
+
+public class SpeedDialController {
+    private static final String TAG = "SpeedDialController";
+    private static SpeedDialController sMe;
+    private Context mfContext;
+    private Context mContext;
+    Uri uri = Uri.parse("content://speed_dial/numbers");
+
+    public static final int TYPE_NUMBER_NORMAL = 7;
+    public static final int TYPE_NUMBER_IMS = 9;
+    public static final String EXTRA_IS_IMS_CALL = "com.mediatek.phone.extra.ims";
+
+    private static final boolean DEBUG = ("eng".equals(Build.TYPE) ||
+                                        "userdebug".equals(Build.TYPE));
+
+
+    private void SpeedDialController() {
+    }
+
+    public static SpeedDialController getInstance() {
+        if (sMe == null) {
+            sMe = new SpeedDialController();
+        }
+        return sMe;
+    }
+
+    public void handleKeyLongProcess(Activity activity, Context cnx, int key) {
+		Log.d("yujunjie", "SpeedDialController:handleKeyLongProcess()...");
+        mfContext = activity;
+        mContext = cnx;
+        Cursor cursor = mContext.getContentResolver().query(uri,
+                new String[] {"_id", "number", "type"}, "_id" + " = " + key, null, null);
+
+        String number = "";
+        int type = TYPE_NUMBER_NORMAL;
+        if (cursor!= null) {
+            if (cursor.moveToFirst()) {
+                int numberColumnId = cursor.getColumnIndex("number");
+                if (numberColumnId != -1) {
+                    number = cursor.getString(numberColumnId);
+                }
+
+                int typeColumnId = cursor.getColumnIndex("type");
+                if (typeColumnId != -1) {
+                    type = cursor.getInt(typeColumnId);
+                }
+            }
+            cursor.close();
+        }
+        if (DEBUG) {
+            Log.i(TAG, "handleKeyLongProcess, key = " + key);
+            Log.i(TAG, "handleKeyLongProcess, number = " + number);
+            Log.i(TAG, "handleKeyLongProcess, type = " + type);
+        }
+        if (TextUtils.isEmpty(number)) {
+            showSpeedDialConfirmDialog();
+        } else {
+            final Intent intent = new Intent(Intent.ACTION_CALL, Uri.fromParts("tel",
+                        number, null));
+            if (type == TYPE_NUMBER_IMS) {
+                intent.putExtra(EXTRA_IS_IMS_CALL, true);
+            }
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            mfContext.startActivity(intent);
+        }
+    }
+
+    public void enterSpeedDial(Context fcnx) {
+        Log.i(TAG, "enterSpeedDial");
+		Log.d("yujunjie", "SpeedDialController:enterSpeedDial()...");
+        final Intent intent = new Intent("android.intent.action.MAIN");
+		ComponentName componentName=new ComponentName("com.android.dialer", "com.mediatek.dialer.speeddial.SpeedDialActivity");
+		intent.setComponent(componentName);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        fcnx.startActivity(intent);
+    }
+
+    public void showSpeedDialConfirmDialog() {
+		Log.d("yujunjie", "SpeedDialController:showSpeedDialConfirmDialog()...");
+        Log.i(TAG, "showSpeedDialConfirmDialog");
+        AlertDialog confirmDialog = new AlertDialog.Builder(mfContext)
+            .setTitle(mContext.getString(R.string.call_speed_dial))
+            .setMessage(mContext.getString(R.string.dialog_no_speed_dial_number_message))
+            .setPositiveButton(android.R.string.ok,
+                new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            enterSpeedDial(mfContext);
+                        }
+                }).setNegativeButton(android.R.string.cancel,
+                new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                        }
+            }).create();
+        confirmDialog.show();
+        
+    }
+}
+
+
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialDatabaseHelper.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialDatabaseHelper.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialDatabaseHelper.java	(revision 4835)
@@ -0,0 +1,56 @@
+package com.mediatek.dialer.speeddial;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+class SpeedDialDatabaseHelper extends SQLiteOpenHelper{
+
+    private final static String TAG = "SpeedDialDatabaseHelper";
+    private static final int DATABASE_VERSION = 1;
+    private static final String DATABASE_NAME = "speeddial.db";
+    private static SpeedDialDatabaseHelper sMe;
+    private static final int TYPE_NUMBER_NORMAL = 7;
+    public interface Tables {
+        static final String SPEEDDIAL = "speeddials";
+    }
+
+
+    public static synchronized SpeedDialDatabaseHelper getInstance(Context context) {
+        if (sMe == null) {
+            sMe = new SpeedDialDatabaseHelper(context, DATABASE_NAME, true);
+        }
+        return sMe;
+    }
+
+    protected SpeedDialDatabaseHelper(Context context, String databaseName,
+                                            boolean optimizationEnabled) {
+        super(context, databaseName, null, DATABASE_VERSION);
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE " + Tables.SPEEDDIAL + " (" +
+            SpeedDial.Numbers._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+            SpeedDial.Numbers.NUMBER + " TEXT," +
+            SpeedDial.Numbers.TYPE + " INTEGER NOT NULL" +
+            ");");
+        initSpeedDialTable(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+
+    }
+
+    private void initSpeedDialTable(SQLiteDatabase db) {
+        for (int i = 0; i < 10; i++) {
+            db.execSQL("INSERT INTO " + Tables.SPEEDDIAL + " (" +
+                SpeedDial.Numbers.NUMBER + ", " + SpeedDial.Numbers.TYPE + ") " +
+                "VALUES('" + "" + "'" + ", '" + TYPE_NUMBER_NORMAL + "'" +");");
+        }
+    }
+
+}
+
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DontPressWithParentImageView.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DontPressWithParentImageView.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/DontPressWithParentImageView.java	(revision 4835)
@@ -0,0 +1,28 @@
+package com.mediatek.dialer.speeddial;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ImageView;
+
+
+/**
+ * Special class to to allow the parent to be pressed without being pressed itself.
+ * This way the line of a tab can be pressed, but the image itself is not.
+ */
+public class DontPressWithParentImageView extends ImageView {
+
+    public DontPressWithParentImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public void setPressed(boolean pressed) {
+        // If the parent is pressed, do not set to pressed.
+        if (pressed && ((View) getParent()).isPressed()) {
+            super.setPressed(false);
+            return;
+        }
+        super.setPressed(pressed);
+    }
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialProvider.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialProvider.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialProvider.java	(revision 4835)
@@ -0,0 +1,125 @@
+package com.mediatek.dialer.speeddial;
+
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.util.Log;
+
+import com.mediatek.dialer.speeddial.SpeedDialDatabaseHelper.Tables;
+
+
+public class SpeedDialProvider extends ContentProvider{
+
+    private static final String TAG = "SpeedDialProvider";
+    private static final int SPEEDDIAL = 1;
+    private SpeedDialDatabaseHelper mDbHelper;
+
+    private static final UriMatcher URIMATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    static {
+        URIMATCHER.addURI(SpeedDial.AUTHORITY, "numbers", SPEEDDIAL);
+    }
+
+    protected SpeedDialDatabaseHelper getDatabaseHelper(Context context) {
+        SpeedDialDatabaseHelper dbHelper = SpeedDialDatabaseHelper.getInstance(context);
+        return dbHelper;
+    }
+
+    @Override
+    public boolean onCreate() {
+        Log.i(TAG, "onCreate");
+        mDbHelper = getDatabaseHelper(getContext());
+        //initSpeedDialTable(mDbHelper.getWritableDatabase());
+        return true;
+    }
+
+    private void initSpeedDialTable(SQLiteDatabase db) {
+        Log.i(TAG, "initSpeedDialTable");
+        ContentValues[] valueArray = new ContentValues[10];
+        for (int i = 0; i < 10; i++) {
+            valueArray[i] = new ContentValues();
+            valueArray[i].put(SpeedDial.Numbers.NUMBER, "");
+        }
+
+        int numValue = 0;
+        db.beginTransaction();
+        try {
+            numValue = valueArray.length;
+            for (int i = 0; i < numValue; i++) {
+                insert(SpeedDial.Numbers.CONTENT_URI,valueArray[i]);
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        int match = URIMATCHER.match(uri);
+        switch (match) {
+            case SPEEDDIAL:
+                return SpeedDial.Numbers.CONTENT_TYPE;
+            default:
+                throw new IllegalArgumentException("Unknown URL " + uri);
+        }
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+                            String[] selectionArgs, String sortOrder) {
+        Log.i(TAG, "query");
+        int match = URIMATCHER.match(uri);
+        switch (match) {
+            case SPEEDDIAL:
+                break;
+            default:
+                break;
+        }
+        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
+        Cursor cursor = db.query(Tables.SPEEDDIAL, projection, selection, selectionArgs, null, null, sortOrder, null);
+        return cursor;
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        Log.i(TAG, "insert");
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+        long id = db.insert(Tables.SPEEDDIAL, null, values);
+        return ContentUris.withAppendedId(uri, id);
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+        Log.i(TAG, "update");
+        int match = URIMATCHER.match(uri);
+        switch(match) {
+            case SPEEDDIAL:
+                break;
+            default:
+                break;
+        }
+        int result = db.update(Tables.SPEEDDIAL, values, selection, selectionArgs);
+        return result;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+
+        int match = URIMATCHER.match(uri);
+        switch(match) {
+            case SPEEDDIAL:
+                break;
+            default:
+                break;
+        }
+        int result = db.delete(Tables.SPEEDDIAL, selection, selectionArgs);
+        return result;
+    }
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialActivity.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialActivity.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/speeddial/SpeedDialActivity.java	(revision 4835)
@@ -0,0 +1,916 @@
+package com.mediatek.dialer.speeddial;
+
+import android.app.ActionBar;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.ListActivity;
+import android.app.ProgressDialog;
+import android.content.AsyncQueryHandler;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.ContactsContract.CommonDataKinds;
+import android.provider.ContactsContract.CommonDataKinds.ImsCall;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.PhoneLookup;
+import android.telephony.PhoneNumberUtils;
+import android.text.method.DialerKeyListener;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.MenuItem;
+import android.view.TouchDelegate;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.SimpleCursorAdapter;
+import android.widget.Toast;
+
+import com.android.contacts.common.ContactPhotoManager;
+import com.mediatek.contacts.util.SimContactPhotoUtils;
+import com.android.dialer.R;
+
+
+import java.util.ArrayList;
+
+public class SpeedDialActivity extends ListActivity
+        implements View.OnClickListener, DialogInterface.OnClickListener,
+        DialogInterface.OnShowListener, DialogInterface.OnDismissListener {
+	
+
+    public static final String PREF_NAME = "speed_dial";
+    private static final int QUERY_TOKEN = 47;
+    private static final int VIEW_EDGE = 30;
+    private static final int SPEED_DIAL_DIALOG_ADD = 1;
+
+    private String TAG = "SpeedDialActivity";
+
+    private SharedPreferences       mPref;
+    private int                     mIndex;
+    private int                     mQueryTimes;
+    private ListView                mListView;
+    private SpeedDialQueryHandler   mQueryHandler;
+    private MatrixCursor            mMatrixCursor;
+    private SimpleCursorAdapter     mSimpleCursorAdapter;
+    private AlertDialog             mRemoveConfirmDialog = null;
+
+    //private ContactPhotoManager     mContactPhotoManager;
+    private boolean                 mIsWaitingActivityResult;
+    public Uri mUri = Uri.parse("content://speed_dial/numbers");
+
+    private int mAddPosition = -1;
+    private int mRemovePosition = -1;
+
+    static final int SPEED_DIAL_MIN = 2;
+    static final int SPEED_DIAL_MAX = 9;
+    private static final int LIST_CAPACITY = 9;
+
+    private ProgressDialog mProgressDialog = null;
+    private static final int WAIT_CURSOR_START = 1000;
+    private static final long WAIT_CURSOR_DELAY_TIME = 500;
+
+    private boolean mActivityDestroyed = false;
+
+    private SimReceiver mSimReceiver;
+    public static final String ACTION_PHB_LOAD_FINISHED = "com.android.contacts.ACTION_PHB_LOAD_FINISHED";
+
+    // For SharePreference
+    private String[] mPrefNumState = {
+        "", "", "", "", "", "", "", "", "", ""
+    };
+
+    //For adapter
+    public static final String[] DATA_FROM = {
+        PhoneLookup._ID,
+        PhoneLookup.DISPLAY_NAME,
+        PhoneLookup.TYPE,
+        PhoneLookup.NUMBER,
+        PhoneLookup.PHOTO_ID,
+        PhoneLookup.INDICATE_PHONE_SIM
+    };
+
+    public static final int[] ID_TO = {
+		
+        R.id.sd_index,
+        R.id.sd_name,
+        R.id.sd_label,
+        R.id.sd_number,
+        R.id.sd_photo,
+        R.id.sd_remove,
+    };
+
+    //For query
+    static final String[] QUERY_PROJECTION = {
+            PhoneLookup._ID, // 0
+            PhoneLookup.DISPLAY_NAME, // 1
+            PhoneLookup.TYPE, // 2
+            PhoneLookup.NUMBER, // 3
+            PhoneLookup.INDICATE_PHONE_SIM, // 4
+            PhoneLookup.PHOTO_ID, // 5
+            PhoneLookup.LABEL, // 6
+    };
+
+    private static final int QUERY_DISPLAY_NAME_INDEX = 1;
+    private static final int QUERY_LABEL_INDEX = 2;
+    private static final int QUERY_NUMBER_INDEX = 3;
+    private static final int QUERY_INDICATE_PHONE_SIM_INDEX = 4;
+    private static final int QUERY_PHOTO_ID_INDEX = 5;
+    private static final int QUERY_CUSTOM_LABEL_INDEX = 6;
+
+    private static final int BIND_ID_INDEX = 0;
+    private static final int BIND_DISPLAY_NAME_INDEX = 1;
+    private static final int BIND_LABEL_INDEX = 2;
+    private static final int BIND_NUMBER_INDEX = 3;
+    private static final int BIND_PHOTO_ID_INDEX = 4;
+    private static final int BIND_INDICATE_PHONE_SIM_INDEX = 5;
+
+    public static final int TYPE_NUMBER_NORMAL = 7;
+    public static final int TYPE_NUMBER_IMS    = 9;
+
+    private static int REQUEST_CODE_PICK_CONTACT = 1;
+
+    private ArrayList<QueueItem> mToastQueue = new ArrayList<QueueItem>();
+
+    private static final boolean DEBUG = ("eng".equals(Build.TYPE) ||
+                                        "userdebug".equals(Build.TYPE));
+
+    public void onListItemClick(ListView l, View v, int position, long id) {
+        if (position == 0 || !TextUtils.isEmpty(mPrefNumState[position + 1])) {
+            return;
+        }
+
+        mAddPosition = position;
+        showDialog(SPEED_DIAL_DIALOG_ADD);
+        return;
+    }
+
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Log.d(TAG, "onActivityResult() mAddPosition:" + mAddPosition);
+        mIsWaitingActivityResult = false;
+        if (requestCode != REQUEST_CODE_PICK_CONTACT || RESULT_OK != resultCode || data == null) {
+            return;
+        }
+
+        String index = data.getData().getLastPathSegment();
+        String number = "";
+        int type = TYPE_NUMBER_NORMAL;
+        String numberType;
+        Cursor cursor = this.getContentResolver().query(Data.CONTENT_URI, new String[] {
+                Data._ID, Data.DATA1, Data.MIMETYPE
+            }, "Data._ID" + " = " + index, null, null);
+
+        Log.i(TAG, "onActivityResult: index = " + index);
+        if (cursor != null && cursor.getCount() > 0) {
+            cursor.moveToFirst();
+            number = cursor.getString(1);
+            numberType = cursor.getString(2);
+            Log.d(TAG, "onActivityResult: numberType = " + numberType);
+            if (ImsCall.CONTENT_ITEM_TYPE.equals(numberType)) {
+                type = TYPE_NUMBER_IMS;
+            }
+        } else {
+            if (cursor != null) {
+                cursor.close();
+            }
+            return;
+        }
+        cursor.close();
+
+        if (DEBUG) {
+            Log.i(TAG, "onActivityResult: number = " + number +
+                    ", type = " + type);
+        }
+        if (PhoneNumberUtils.isUriNumber(number)) {
+            mMatrixCursor.moveToPosition(-1);
+            Toast.makeText(this, getString(R.string.invalid_number), Toast.LENGTH_LONG).show();
+            return;
+        } else if (findKeyByNumber(number) > -1) {
+            mMatrixCursor.moveToPosition(-1);
+            Toast.makeText(this, getString(R.string.reselect_number), Toast.LENGTH_LONG).show();
+            return;
+        } else {
+            getPrefStatus();
+            mPrefNumState[mAddPosition + 1] = number;
+            SharedPreferences.Editor editor = mPref.edit();
+            editor.putString(String.valueOf(mAddPosition + 1), mPrefNumState[mAddPosition + 1]);
+            editor.apply();
+
+            updateSpeedDial(mAddPosition + 1, number, type);
+
+            enQueueItem(mAddPosition);
+        }
+    }
+
+    private int findKeyByNumber(String number) {
+        for (int i = SPEED_DIAL_MIN; i < SPEED_DIAL_MAX + 1; i++) {
+            if (shouldCollapse(this, number, mPrefNumState[i])) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    public static final boolean shouldCollapse(Context context, CharSequence data1, CharSequence data2) {
+        if (data1 == data2) {
+            return true;
+        }
+
+        if (data1 == null || data2 == null) {
+            return false;
+        }
+
+        if (TextUtils.equals(data1, data2)) {
+            return true;
+        }
+
+        String[] dataParts1 = data1.toString().split(String.valueOf(PhoneNumberUtils.WAIT));
+        String[] dataParts2 = data2.toString().split(String.valueOf(PhoneNumberUtils.WAIT));
+        if (dataParts1.length != dataParts2.length) {
+            return false;
+        }
+
+        for (int i = 0; i < dataParts1.length; i++) {
+            if (!PhoneNumberUtils.compare(context, dataParts1[i], dataParts2[i])) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Log.d(TAG, "onCreate() , begin");
+
+        //mContactPhotoManager = ContactPhotoManager.getInstance(this);
+
+        mListView = getListView();
+        mSimpleCursorAdapter = new SimpleCursorAdapter(this, R.layout.mtk_speed_dial_list_item, null,
+                DATA_FROM, ID_TO);
+        mSimpleCursorAdapter.setViewBinder(new SimpleCursorAdapter.ViewBinder() {
+            public boolean setViewValue(final View view, Cursor cursor, int columnIndex) {
+                boolean isEmpty = TextUtils.isEmpty(cursor.getString(BIND_NUMBER_INDEX));
+                int viewId = view.getId();
+                if (viewId == R.id.sd_photo) {
+                    view.setVisibility(View.GONE);
+                    view.setClickable(false);
+                    if (!isEmpty) {
+                        //view.setBackgroundDrawable(null);
+                        //mContactPhotoManager.loadThumbnail((ImageView) view, Long.valueOf(
+                                //cursor.getString(BIND_PHOTO_ID_INDEX)).longValue(), true);
+                    }
+                    return true;
+                } else if (viewId == R.id.sd_label) {
+                    view.setVisibility(isEmpty ? View.GONE : View.VISIBLE);
+                } else if (viewId == R.id.sd_number) {
+                    view.setVisibility(isEmpty ? View.GONE : View.VISIBLE);
+                } else if (viewId == R.id.sd_name) {
+                    view.setEnabled(!isEmpty
+                            || TextUtils.equals(cursor.getString(BIND_ID_INDEX), "1"));
+
+                } else if (viewId == R.id.sd_remove) {
+                    view.setVisibility(isEmpty ? View.GONE : View.VISIBLE);
+                    view.setOnClickListener(SpeedDialActivity.this);
+                    if (!isEmpty) {
+                       final View parent = (View) view.getParent();
+                       parent.post(new Runnable() {
+                           public void run() {
+                               final Rect r = new Rect();
+                               view.getHitRect(r);
+                               r.top -= VIEW_EDGE;
+                               r.bottom += VIEW_EDGE;
+                               r.left -= VIEW_EDGE;
+                               r.right += VIEW_EDGE;
+                               parent.setTouchDelegate(new TouchDelegate(r, view));
+                           }
+                       });
+                    } else {
+                        final View parent = (View) view.getParent();
+                        parent.post(new Runnable() {
+                            public void run() {
+                                parent.setTouchDelegate(null);
+                            }
+                        });
+                    }
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        mQueryHandler = new SpeedDialQueryHandler(this);
+        mListView.setAdapter(mSimpleCursorAdapter);
+
+        mSimReceiver = new SimReceiver(this);
+        mSimReceiver.register();
+
+        ActionBar actionBar = getActionBar();
+        if (actionBar != null) {
+            // android.R.id.home will be triggered in onOptionsItemSelected()
+            actionBar.setDisplayHomeAsUpEnabled(true);
+        }
+        Log.d(TAG, "onCreate() , end");
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        Log.d(TAG, "onStart end");
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        getPrefStatus();
+
+        startQuery();
+        Log.d(TAG, "onResume end");
+    }
+
+    @Override
+    protected void onPause() {
+        Log.d(TAG, "onPause");
+        super.onPause();
+    }
+
+    @Override
+    public void onStop() {
+        Log.d(TAG, "onStop");
+        super.onStop();
+
+        dismissProgressIndication();
+    }
+
+    @Override
+    protected void onDestroy() {
+        Log.d(TAG, "onDestroy");
+        super.onDestroy();
+
+        mSimReceiver.unregister();
+        if (mMatrixCursor != null) {
+            mMatrixCursor.close();
+        }
+        mActivityDestroyed = true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+        case android.R.id.home:
+            finish();
+            return true;
+        default:
+            break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    protected Dialog onCreateDialog(int id) {
+        if (SPEED_DIAL_DIALOG_ADD ==  id) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setTitle(R.string.call_speed_dial);
+            builder.setPositiveButton(R.string.sd_add, this);
+            builder.setNegativeButton(android.R.string.cancel, this);
+            builder.setView(View.inflate(this, R.layout.mtk_speed_dial_input_dialog, null));
+            Dialog dialog = builder.create();
+            dialog.setOnShowListener(this);
+            dialog.setOnDismissListener(this);
+            return dialog;
+        }
+        return null;
+    }
+
+    private void getPrefStatus() {
+        Log.i(TAG, "getPrefStatus()");
+        mPref = getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
+        for (int i = SPEED_DIAL_MIN; i < SPEED_DIAL_MAX + 1; ++i) {
+            mPrefNumState[i] = mPref.getString(String.valueOf(i), "");
+        }
+    }
+
+    private void initMatrixCursor() {
+        // if (mMatrixCursor != null) mMatrixCursor.close();
+        mMatrixCursor = new MatrixCursor(DATA_FROM, LIST_CAPACITY);
+        mMatrixCursor.addRow(new String[] {
+                "1", getResources().getString(R.string.voicemail), "", "", "", ""
+        });
+        mQueryTimes = SPEED_DIAL_MIN;
+    }
+
+    private void startQuery() {
+        Log.i(TAG, "startQuery");
+        mDialogHandler.sendMessageDelayed(mDialogHandler.obtainMessage(WAIT_CURSOR_START),
+                WAIT_CURSOR_DELAY_TIME);
+
+        initMatrixCursor();
+        goOnQuery();
+    }
+
+    private void goOnQuery() {
+        Log.i(TAG, "goOnQuery");
+
+        int end;
+        for (end = mQueryTimes;  end < SPEED_DIAL_MAX + 1 && TextUtils.isEmpty(mPrefNumState[end]); ++end) {
+            Log.v(TAG, "log for empry block, index = " + end);
+            populateMatrixCursorEmpty(this, mMatrixCursor, end, "");
+        }
+
+        Log.i(TAG, "goOnQuery, end = " + end);
+        if (end > SPEED_DIAL_MAX) {
+            mSimpleCursorAdapter.changeCursor(mMatrixCursor);
+            mSimpleCursorAdapter.notifyDataSetChanged();
+
+            processQueue();
+            updatePreferences();
+
+            mDialogHandler.removeMessages(WAIT_CURSOR_START);
+            dismissProgressIndication();
+        } else {
+
+            QueryInfo info = new QueryInfo();
+            mQueryTimes = end;
+            info.mQueryIndex = mQueryTimes;
+
+            Log.i(TAG, "goOnQuery(), startQuery at mQueryTimes = " + mQueryTimes);
+            if (DEBUG) {
+                Log.i(TAG, "goOnQuery(), number = " + mPrefNumState[mQueryTimes]);
+            }
+            Uri uri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri
+                    .encode(mPrefNumState[mQueryTimes]));
+            mQueryHandler.startQuery(QUERY_TOKEN, info, uri, QUERY_PROJECTION, null, null, null);
+        }
+
+    }
+
+    private void populateMatrixCursorEmpty(Context cnx, MatrixCursor cursor, int id, String number) {
+        Log.i(TAG, "populateMatrixCursorEmpty, id = " + id);
+        if (TextUtils.isEmpty(number)) {
+            cursor.addRow(new String[]{
+                String.valueOf(id),
+                cnx.getResources().getString(R.string.add_speed_dial), "", "", "0", "-1"});
+        } else {
+            cursor.addRow(new String[]{
+                String.valueOf(id),
+                number, "", number, "0", "-1"});
+        }
+    }
+
+    //Need update lable && simcard icon
+    private void populateMatrixCursorRow(int row, Cursor cursor) {
+        cursor.moveToFirst();
+        String name = cursor.getString(QUERY_DISPLAY_NAME_INDEX);
+        int type = cursor.getInt(QUERY_LABEL_INDEX);
+        String label = "";
+        if (type == 0) {
+            label = cursor.getString(QUERY_CUSTOM_LABEL_INDEX);
+        } else {
+            label = (String) CommonDataKinds.Phone.getTypeLabel(getResources(), type, null);
+        }
+        String number = cursor.getString(QUERY_NUMBER_INDEX);
+        long photoId = cursor.getLong(QUERY_PHOTO_ID_INDEX);
+        int simId = -1;
+        if (!cursor.isNull(QUERY_INDICATE_PHONE_SIM_INDEX)) {
+            simId = cursor.getInt(QUERY_INDICATE_PHONE_SIM_INDEX);
+        }
+
+        if (DEBUG) {
+            Log.i(TAG, "populateMatrixCursorRow(), name = " + name + ", label = " + label
+                    + ", number = " + number + " photoId:" + photoId + "simId: " + simId);
+        }
+
+        if (simId > 0) {
+            //photoId = SimContactPhotoUtils.getSimContactPhotoId(simId, false);
+        }
+
+        if (TextUtils.isEmpty(number)) {
+            populateMatrixCursorEmpty(this, mMatrixCursor, row, "");
+            mPrefNumState[row] = mPref.getString(String.valueOf(row), "");
+            updateSpeedDial(row, "", TYPE_NUMBER_NORMAL);
+            return;
+        }
+        mMatrixCursor.addRow(new String[] {
+                String.valueOf(row), name, label,
+                number, String.valueOf(photoId), String.valueOf(simId)});
+    }
+
+
+    public void onClick(View v) {
+        if (v.getId() == R.id.sd_remove) {
+            for(int i = 0;  i < mListView.getCount(); i++) {
+                if (mListView.getChildAt(i) == v.getParent()) {
+                    confirmRemovePosition(i + mListView.getFirstVisiblePosition());
+                    return;
+                }
+            }
+        } else if (v.getId() == R.id.contacts) {
+            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
+
+            ComponentName component = new ComponentName("com.android.contacts",
+                                                "com.android.contacts.activities.ContactSelectionActivity");
+            intent.setComponent(component);
+            intent.setType(Phone.CONTENT_ITEM_TYPE);
+            intent.putExtra("isCallableUri", true);
+            startActivityForResult(intent, REQUEST_CODE_PICK_CONTACT);
+
+            dismissDialog(SPEED_DIAL_DIALOG_ADD);
+            Log.d(TAG, "[startActivityForResult], mAddPosition = " + mAddPosition);
+        }
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        if (which == DialogInterface.BUTTON_POSITIVE) {
+            EditText editText = (EditText) ((AlertDialog) dialog).findViewById(R.id.number);
+            final String number = editText.getText().toString();
+            if (TextUtils.isEmpty(number)) {
+                return;
+            }
+
+            if (-1 == findKeyByNumber(number)) {
+                mPrefNumState[mAddPosition + 1] = number;
+
+                SharedPreferences.Editor editor = mPref.edit();
+                editor.putString(String.valueOf(mAddPosition + 1), number);
+                editor.commit();
+
+                updateSpeedDial(mAddPosition + 1, number, TYPE_NUMBER_NORMAL);
+
+                startQuery();
+
+                enQueueItem(mAddPosition);
+                Log.i(TAG, "[onClick], mAddPosition =" + mAddPosition);
+            } else {
+                Toast.makeText(this, getString(R.string.reselect_number), Toast.LENGTH_LONG).show();
+            }
+        }
+    }
+
+    public void onShow(DialogInterface dialog) {
+        EditText editText = (EditText) ((AlertDialog) dialog).findViewById(R.id.number);
+        if (!TextUtils.isEmpty(mPrefNumState[mAddPosition + 1])) {
+            editText.setText(mPrefNumState[mAddPosition + 1]);
+            editText.setSelection(mPrefNumState[mAddPosition + 1].length());
+        }
+
+        editText.setKeyListener(InputKeyListener.getInstance());
+        ImageView imageView = (ImageView) ((AlertDialog) dialog).findViewById(R.id.contacts);
+        imageView.setOnClickListener(this);
+    }
+
+    public void onDismiss(DialogInterface dialog) {
+        Log.i(TAG, "[onDismiss]");
+        EditText editText = (EditText) ((AlertDialog) dialog).findViewById(R.id.number);
+        if (editText!= null) {
+            editText.setText("");
+        }
+    }
+
+    public void confirmRemovePosition(int position) {
+        if (position < 1 || position > 9) {
+            Log.i(TAG, "position out of bound, do nothing");
+            return;
+        }
+
+        Cursor c = (Cursor) mSimpleCursorAdapter.getItem(position);
+        if (c == null) {
+            Log.d(TAG, "[confirmRemovePosition] the cursor for the position is null");
+            return;
+        }
+
+        mRemovePosition =  position;
+        String name = c.getString(BIND_DISPLAY_NAME_INDEX);
+        String label = c.getString(BIND_LABEL_INDEX);
+        String message;
+        if (TextUtils.isEmpty(label)) {
+            message = getString(R.string.remove_sd_confirm_2, name, String.valueOf(position + 1));
+        } else {
+            message = getString(R.string.remove_sd_confirm_1, name, label, String
+                    .valueOf(position + 1));
+        }
+        Log.d(TAG, "confirmRemovePosition(), message= " + message);
+        if (mRemoveConfirmDialog == null) {
+            mRemoveConfirmDialog = new AlertDialog.Builder(this).setCancelable(true)
+                    .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        public void onCancel(DialogInterface arg0) {
+                            // TODO Auto-generated method stub
+                            mRemovePosition = -1;
+                            mRemoveConfirmDialog = null;
+                        }
+                    }).setTitle(R.string.remove_speed_dial).setIcon(
+                            android.R.drawable.ic_dialog_alert).setMessage(message)
+                    .setPositiveButton(R.string.remove_speed_dial,
+                            new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    actuallyRemove();
+                                    mRemovePosition = -1;
+                                    mRemoveConfirmDialog = null;
+                                }
+                            }).setNegativeButton(android.R.string.cancel,
+                            new DialogInterface.OnClickListener() {
+
+                                public void onClick(DialogInterface dialog, int which) {
+                                    mRemovePosition = -1;
+                                    mRemoveConfirmDialog = null;
+                                }
+                            }).create();
+        }
+        mRemoveConfirmDialog.show();
+    }
+
+    private void updatePreferences() {
+        SharedPreferences.Editor editor = mPref.edit();
+        for (int i = SPEED_DIAL_MIN; i < SPEED_DIAL_MAX + 1; ++i) {
+            editor.putString(String.valueOf(i), mPrefNumState[i]);
+        }
+        editor.apply();
+    }
+
+    private void actuallyRemove() {
+        mPrefNumState[mRemovePosition + 1] = "";
+        SharedPreferences.Editor editor = mPref.edit();
+        editor.putString(String.valueOf(mRemovePosition + 1), mPrefNumState[mRemovePosition + 1]);
+        editor.apply();
+
+        startQuery();
+
+        updateSpeedDial(mRemovePosition + 1, "", TYPE_NUMBER_NORMAL);
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Bundle state) {
+        Log.i(TAG, "onRestoreInstanceState");
+        super.onRestoreInstanceState(state);
+        mAddPosition = state.getInt("add_position", -1);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        Log.i(TAG, "onSaveInstanceState");
+        if (mAddPosition != -1) {
+            outState.putInt("add_position", mAddPosition);
+        }
+        super.onSaveInstanceState(outState);
+    }
+
+    private void enQueueItem(int index) {
+        Log.i(TAG, "enQueueItem(), index = " + index);
+        mToastQueue.add(new QueueItem(index));
+    }
+
+    private void processQueue() {
+        if (mToastQueue != null) {
+            for (QueueItem item : mToastQueue) {
+                Log.i(TAG, "processQueue, item index = " + item.index);
+                item.run();
+            }
+            mToastQueue.clear();
+        }
+    }
+
+    private Handler mDialogHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            Log.i(TAG, "handleMessage msg==== " + msg.what);
+
+            switch (msg.what) {
+
+                case WAIT_CURSOR_START:
+                    Log.i(TAG, "start WAIT_CURSOR_START showProgressIndication.");
+                    showProgressIndication();
+                    break;
+
+                default:
+                    break;
+            }
+        }
+    };
+
+    private void showProgressIndication() {
+        Log.i(TAG, "loading contacts... ");
+        if (mActivityDestroyed) {
+            Log.i(TAG, "showProgressIndication(),the master Activity is destroyed!");
+            return;
+        }
+
+        dismissProgressIndication(); // Clean up any prior progress indication
+
+        mProgressDialog = new ProgressDialog(this);
+        mProgressDialog.setMessage(this.getResources().getString(R.string.contact_list_loading));
+        mProgressDialog.setIndeterminate(true);
+        mProgressDialog.setCancelable(false);
+        mProgressDialog.show();
+    }
+
+    private void dismissProgressIndication() {
+        if (mProgressDialog != null && mProgressDialog.isShowing()) {
+            try {
+                mProgressDialog.dismiss(); // safe even if already dismissed
+            } catch (Exception e) {
+                Log.i(TAG, "dismiss exception: " + e);
+            }
+            mProgressDialog = null;
+        }
+    }
+
+
+    private class SpeedDialQueryHandler extends AsyncQueryHandler{
+        SpeedDialQueryHandler(Context context) {
+            super(context.getContentResolver());
+        }
+
+        @Override
+        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+            Log.d(TAG, "onQueryComplete(), cursor = " + cursor);
+
+            if (cookie instanceof QueryInfo) {
+                int index = ((QueryInfo) cookie).mQueryIndex;
+                Log.d(TAG, "onQueryComplete(), index = " + index + ", mQueryTimes = " + mQueryTimes);
+                if (index != mQueryTimes) {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                    return;
+                }
+            }
+
+
+            if (mQueryTimes < SPEED_DIAL_MAX + 1 && cursor != null && cursor.getCount() > 0) {
+                populateMatrixCursorRow(mQueryTimes, cursor);
+            } else if (mQueryTimes < SPEED_DIAL_MAX + 1){
+                populateMatrixCursorEmpty(SpeedDialActivity.this, mMatrixCursor, mQueryTimes, mPrefNumState[mQueryTimes]);
+            }
+
+            if (cursor != null) {
+                cursor.close();
+            }
+
+            if (mQueryTimes < SPEED_DIAL_MAX) {
+                mQueryTimes++;
+                goOnQuery();
+            } else {
+                mSimpleCursorAdapter.changeCursor(mMatrixCursor);
+                mSimpleCursorAdapter.notifyDataSetChanged();
+
+                processQueue();
+                updatePreferences();
+
+                mDialogHandler.removeMessages(WAIT_CURSOR_START);
+                dismissProgressIndication();
+            }
+        }
+    }
+
+    private void updateSpeedDial(int id, String number, int type) {
+        SpeedDialArgs args = new SpeedDialArgs(SpeedDialActivity.this, id, number, type, mUri);
+        new UpdateSpeedDialTask().execute(args);
+    }
+
+    private class SpeedDialArgs {
+        public SpeedDialArgs(Context context, int id, String number, int type, Uri uri) {
+            this.mContext = context;
+            this.mIndex = id;
+            this.mNumber = number;
+            this.mUri = uri;
+            this.mNumberType = type;
+        }
+        public Uri mUri;
+        public Context mContext;
+        public int mIndex;
+        public String mNumber;
+        public int mNumberType;
+    }
+
+    private class UpdateSpeedDialTask extends AsyncTask<SpeedDialArgs, Void, Void> {
+        @Override
+        protected Void doInBackground(SpeedDialArgs... argList) {
+            int count = argList.length;
+            for (int i = 0; i < count; i ++) {
+                SpeedDialArgs arg = argList[i];
+                Context context = arg.mContext;
+                ContentValues value = new ContentValues();
+                value.put("number", arg.mNumber);
+                value.put("type", arg.mNumberType);
+                context.getContentResolver().update(arg.mUri, value, "_id" + " = " + arg.mIndex, null);
+                Log.i(TAG, "UpdateSpeedDialTask(), doInBackground");
+            }
+            return null;
+        }
+    }
+
+    private static class InputKeyListener extends DialerKeyListener {
+        private static InputKeyListener sKeyListener;
+        public static final char[] CHARACTERS = new char[] { '0', '1', '2',
+            '3', '4', '5', '6', '7', '8', '9', '+', '*', '#',',',';'};
+
+        @Override
+        protected char[] getAcceptedChars() {
+            return CHARACTERS;
+        }
+        public static InputKeyListener getInstance() {
+            if (sKeyListener == null) {
+                sKeyListener = new InputKeyListener();
+            }
+            return sKeyListener;
+        }
+    }
+
+    private class QueueItem {
+        private int index;
+        private Runnable runnable;
+        QueueItem(int id) {
+            this.index = id;
+            this.initialize();
+        }
+
+        private void initialize() {
+            this.runnable = new Runnable() {
+                @Override
+                public void run() {
+
+                    mMatrixCursor.moveToPosition(QueueItem.this.index);
+                    if (QueueItem.this.index < SPEED_DIAL_MIN - 1) {
+                        Log.i(TAG, "Toast index is invalid, just return");
+                        return;
+                    }
+
+                    CharSequence name = mMatrixCursor.getString(BIND_DISPLAY_NAME_INDEX);
+                    CharSequence label = mMatrixCursor.getString(BIND_LABEL_INDEX);
+
+                    CharSequence fullInfo;
+                    if (TextUtils.isEmpty(label)) {
+                        fullInfo = getString(R.string.speed_dial_added2, name, String.valueOf(QueueItem.this.index + 1));
+                    } else {
+                        fullInfo = getString(R.string.speed_dial_added, name, label, String.valueOf(QueueItem.this.index + 1));
+                    }
+                    Toast.makeText(SpeedDialActivity.this, fullInfo, Toast.LENGTH_LONG).show();
+                }
+            };
+        }
+
+        public void run() {
+            this.runnable.run();
+        }
+    }
+
+    private class QueryInfo {
+        int mQueryIndex;
+    }
+
+    private class SimReceiver extends BroadcastReceiver {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            Log.i(TAG, "[SimReceiver.onReceive]action is " + action);
+            refreshUi();
+        }
+
+        private void refreshUi() {
+            mRefreshHandler.sendEmptyMessage(0);
+        }
+
+        public void register() {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ACTION_PHB_LOAD_FINISHED);
+            mContext.registerReceiver(this, filter);
+        }
+
+        public void unregister() {
+            mContext.unregisterReceiver(this);
+        }
+
+        public SimReceiver(Context context) {
+            mContext = context;
+        }
+
+        private Context mContext;
+        private Handler mRefreshHandler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                Log.d(TAG, "[SimReceiver.handleMessage] update UI due to SIMService finished");
+                initMatrixCursor();
+                goOnQuery();
+            }
+        };
+    }
+	
+
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/ext/ExtensionManager.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/ext/ExtensionManager.java	(revision 4834)
+++ packages/apps/Dialer/src/com/mediatek/dialer/ext/ExtensionManager.java	(revision 4835)
@@ -40,6 +40,7 @@
 
 import com.mediatek.common.telephony.ICallerInfoExt;
 import com.mediatek.dialer.compat.DialerCompatExUtils;
+import com.mediatek.dialer.speeddial.DialPadExtension;
 
 public class ExtensionManager {
     private static final String TAG = "DialerExtensionManager";
@@ -136,11 +137,14 @@
         if (mDialPadExtension == null) {
             synchronized (IDialPadExtension.class) {
                 if (mDialPadExtension == null) {
+					/*
                     mDialPadExtension = (IDialPadExtension) createInstance(
                             IDialPadExtension.class.getName(), mContext);
                     if (mDialPadExtension == null) {
                         mDialPadExtension = new DefaultDialPadExtension();
                     }
+                    */
+                    mDialPadExtension=new DialPadExtension (mContext);
                     Log.i(TAG, "[getDialPadExtension]create ext instance: " + mDialPadExtension);
                 }
             }
