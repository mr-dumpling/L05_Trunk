Index: vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java	(revision 8255)
@@ -0,0 +1,1030 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar;
+
+import android.annotation.DrawableRes;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.AnimatedVectorDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.telephony.SubscriptionInfo;
+import android.telephony.TelephonyManager;
+import android.telephony.PhoneStateListener;
+import android.telephony.PreciseDataConnectionState;
+
+import android.util.ArraySet;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.android.systemui.R;
+import com.android.systemui.statusbar.phone.StatusBarIconController;
+import com.android.systemui.statusbar.policy.NetworkController.IconState;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl;
+import com.android.systemui.statusbar.policy.SecurityController;
+import com.android.systemui.tuner.TunerService;
+import com.android.systemui.tuner.TunerService.Tunable;
+
+import com.mediatek.systemui.ext.ISystemUIStatusBarExt;
+import com.mediatek.systemui.PluginManager;
+import com.mediatek.systemui.statusbar.util.FeatureOptions;
+
+import java.util.ArrayList;
+import java.util.List;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.telephony.SubscriptionManager;
+
+// Intimately tied to the design of res/layout/signal_cluster_view.xml
+public class SignalClusterView
+        extends LinearLayout
+        implements NetworkControllerImpl.SignalCallback,
+        SecurityController.SecurityControllerCallback, Tunable {
+
+    static final String TAG = "SignalClusterView";
+    static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+
+    private static final String SLOT_AIRPLANE = "airplane";
+    private static final String SLOT_MOBILE = "mobile";
+    private static final String SLOT_WIFI = "wifi";
+    private static final String SLOT_ETHERNET = "ethernet";
+
+    NetworkControllerImpl mNC;
+    SecurityController mSC;
+
+    private boolean mNoSimsVisible = false;
+    private boolean mVpnVisible = false;
+    private int mVpnIconId = 0;
+    private int mLastVpnIconId = -1;
+    private boolean mEthernetVisible = false;
+    private int mEthernetIconId = 0;
+    private int mLastEthernetIconId = -1;
+    private boolean mWifiVisible = false;
+    private int mWifiStrengthId = 0;
+    private int mLastWifiStrengthId = -1;
+    private boolean mIsAirplaneMode = false;
+    private int mAirplaneIconId = 0;
+    private int mLastAirplaneIconId = -1;
+    private String mAirplaneContentDescription;
+    private String mWifiDescription;
+    private String mEthernetDescription;
+    private ArrayList<PhoneState> mPhoneStates = new ArrayList<PhoneState>();
+    private int mIconTint = Color.WHITE;
+    private float mDarkIntensity;
+    private final Rect mTintArea = new Rect();
+
+    ViewGroup mEthernetGroup, mWifiGroup;
+    View mNoSimsCombo;
+    View mNoSimsComboSlot2;
+    ImageView mVpn, mEthernet, mWifi, mAirplane, mNoSims, mEthernetDark, mWifiDark, mNoSimsDark;
+    ImageView mNoSimsSlot2, mNoSimsDarkSlot2;
+    View mWifiAirplaneSpacer;
+    View mWifiSignalSpacer;
+    LinearLayout mMobileSignalGroup;
+
+    private final int mMobileSignalGroupEndPadding;
+    private final int mMobileDataIconStartPadding;
+    private final int mWideTypeIconStartPadding;
+    private final int mSecondaryTelephonyPadding;
+    private final int mEndPadding;
+    private final int mEndPaddingNothingVisible;
+    private final float mIconScaleFactor;
+
+    private boolean mBlockAirplane;
+    private boolean mBlockMobile;
+    private boolean mBlockWifi;
+    private boolean mBlockEthernet;
+	private TelephonyManager mPhone;
+	private MobilePhoneStateListener mPhoneStateListener;
+	private String mApnType = "unknow";
+	private boolean showDataIcon=false;
+
+    static final int[] DATA_ACTIVITY = {
+        R.drawable.stat_sys_signal,
+        R.drawable.stat_sys_signal_in,
+        R.drawable.stat_sys_signal_out,
+        R.drawable.stat_sys_signal_inout
+    };
+
+    /// M: Add for Plugin feature @ {
+    private ISystemUIStatusBarExt mStatusBarExt;
+    /// @ }
+
+    /// M: for vowifi
+    boolean mIsWfcEnable;
+
+    public SignalClusterView(Context context) {
+        this(context, null);
+    }
+
+    public SignalClusterView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public SignalClusterView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+		mPhone=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
+		mPhoneStateListener=new MobilePhoneStateListener();
+		mPhone.listen(mPhoneStateListener, PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE);
+        Resources res = getResources();
+        mMobileSignalGroupEndPadding =
+                res.getDimensionPixelSize(R.dimen.mobile_signal_group_end_padding);
+        mMobileDataIconStartPadding =
+                res.getDimensionPixelSize(R.dimen.mobile_data_icon_start_padding);
+        mWideTypeIconStartPadding = res.getDimensionPixelSize(R.dimen.wide_type_icon_start_padding);
+        mSecondaryTelephonyPadding = res.getDimensionPixelSize(R.dimen.secondary_telephony_padding);
+        mEndPadding = res.getDimensionPixelSize(R.dimen.signal_cluster_battery_padding);
+        mEndPaddingNothingVisible = res.getDimensionPixelSize(
+                R.dimen.no_signal_cluster_battery_padding);
+
+        TypedValue typedValue = new TypedValue();
+        res.getValue(R.dimen.status_bar_icon_scale_factor, typedValue, true);
+        mIconScaleFactor = typedValue.getFloat();
+
+        /// M: Add for Plugin feature @ {
+        mStatusBarExt = PluginManager.getSystemUIStatusBarExt(context);
+        /// @ }
+        mIsWfcEnable = SystemProperties.get("persist.mtk_wfc_support").equals("1");
+    }
+
+    @Override
+    public void onTuningChanged(String key, String newValue) {
+        if (!StatusBarIconController.ICON_BLACKLIST.equals(key)) {
+            return;
+        }
+        ArraySet<String> blockList = StatusBarIconController.getIconBlacklist(newValue);
+        boolean blockAirplane = blockList.contains(SLOT_AIRPLANE);
+        boolean blockMobile = blockList.contains(SLOT_MOBILE);
+        boolean blockWifi = blockList.contains(SLOT_WIFI);
+        boolean blockEthernet = blockList.contains(SLOT_ETHERNET);
+
+        if (blockAirplane != mBlockAirplane || blockMobile != mBlockMobile
+                || blockEthernet != mBlockEthernet || blockWifi != mBlockWifi) {
+            mBlockAirplane = blockAirplane;
+            mBlockMobile = blockMobile;
+            mBlockEthernet = blockEthernet;
+            mBlockWifi = blockWifi;
+            // Re-register to get new callbacks.
+            mNC.removeSignalCallback(this);
+            mNC.addSignalCallback(this);
+        }
+    }
+
+    public void setNetworkController(NetworkControllerImpl nc) {
+        if (DEBUG) Log.d(TAG, "NetworkController=" + nc);
+        mNC = nc;
+    }
+
+    public void setSecurityController(SecurityController sc) {
+        if (DEBUG) Log.d(TAG, "SecurityController=" + sc);
+        mSC = sc;
+        mSC.addCallback(this);
+        mVpnVisible = mSC.isVpnEnabled();
+        mVpnIconId = currentVpnIconId(mSC.isVpnBranded());
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mVpn            = (ImageView) findViewById(R.id.vpn);
+        mEthernetGroup  = (ViewGroup) findViewById(R.id.ethernet_combo);
+        mEthernet       = (ImageView) findViewById(R.id.ethernet);
+        mEthernetDark   = (ImageView) findViewById(R.id.ethernet_dark);
+        mWifiGroup      = (ViewGroup) findViewById(R.id.wifi_combo);
+        mWifi           = (ImageView) findViewById(R.id.wifi_signal);
+        mWifiDark       = (ImageView) findViewById(R.id.wifi_signal_dark);
+        mAirplane       = (ImageView) findViewById(R.id.airplane);
+        mNoSims         = (ImageView) findViewById(R.id.no_sims);
+        mNoSimsDark     = (ImageView) findViewById(R.id.no_sims_dark);
+        mNoSimsCombo    =             findViewById(R.id.no_sims_combo);
+        mWifiAirplaneSpacer =         findViewById(R.id.wifi_airplane_spacer);
+        mWifiSignalSpacer =           findViewById(R.id.wifi_signal_spacer);
+        mMobileSignalGroup = (LinearLayout) findViewById(R.id.mobile_signal_group);
+        mNoSimsSlot2 = (ImageView) findViewById(R.id.no_sims_slot2);
+        mNoSimsDarkSlot2     = (ImageView) findViewById(R.id.no_sims_dark_slot2);
+        mNoSimsComboSlot2 = findViewById(R.id.no_sims_combo_slot2);
+
+        maybeScaleVpnAndNoSimsIcons();
+    }
+
+    /**
+     * Extracts the icon off of the VPN and no sims views and maybe scale them by
+     * {@link #mIconScaleFactor}. Note that the other icons are not scaled here because they are
+     * dynamic. As such, they need to be scaled each time the icon changes in {@link #apply()}.
+     */
+    private void maybeScaleVpnAndNoSimsIcons() {
+        if (mIconScaleFactor == 1.f) {
+            return;
+        }
+
+        mVpn.setImageDrawable(new ScalingDrawableWrapper(mVpn.getDrawable(), mIconScaleFactor));
+
+        mNoSims.setImageDrawable(
+                new ScalingDrawableWrapper(mNoSims.getDrawable(), mIconScaleFactor));
+        mNoSimsDark.setImageDrawable(
+                new ScalingDrawableWrapper(mNoSimsDark.getDrawable(), mIconScaleFactor));
+        mNoSimsSlot2.setImageDrawable(
+                new ScalingDrawableWrapper(mNoSimsSlot2.getDrawable(), mIconScaleFactor));
+        mNoSimsDarkSlot2.setImageDrawable(
+                new ScalingDrawableWrapper(mNoSimsDarkSlot2.getDrawable(), mIconScaleFactor));
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        for (PhoneState state : mPhoneStates) {
+            mMobileSignalGroup.addView(state.mMobileGroup);
+        }
+
+        int endPadding = mMobileSignalGroup.getChildCount() > 0 ? mMobileSignalGroupEndPadding : 0;
+        mMobileSignalGroup.setPaddingRelative(0, 0, endPadding, 0);
+
+        TunerService.get(mContext).addTunable(this, StatusBarIconController.ICON_BLACKLIST);
+
+        /// M: Add for Plugin feature @ {
+        mStatusBarExt.setCustomizedNoSimView(mNoSims);
+        mStatusBarExt.setCustomizedNoSimView(mNoSimsDark);
+        mStatusBarExt.setCustomizedNoSimView(mNoSimsSlot2);
+        mStatusBarExt.setCustomizedNoSimView(mNoSimsDarkSlot2);
+        mStatusBarExt.addSignalClusterCustomizedView(mContext, this,
+                indexOfChild(findViewById(R.id.mobile_signal_group)));
+        /// @ }
+
+        apply();
+        applyIconTint();
+        mNC.addSignalCallback(this);
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        mMobileSignalGroup.removeAllViews();
+        TunerService.get(mContext).removeTunable(this);
+        mSC.removeCallback(this);
+        mNC.removeSignalCallback(this);
+
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        super.onLayout(changed, l, t, r, b);
+
+        // Re-run all checks against the tint area for all icons
+        applyIconTint();
+    }
+
+    // From SecurityController.
+    @Override
+    public void onStateChanged() {
+        post(new Runnable() {
+            @Override
+            public void run() {
+                mVpnVisible = mSC.isVpnEnabled();
+                mVpnIconId = currentVpnIconId(mSC.isVpnBranded());
+                apply();
+            }
+        });
+    }
+
+    @Override
+    public void setWifiIndicators(boolean enabled, IconState statusIcon, IconState qsIcon,
+            boolean activityIn, boolean activityOut, String description) {
+        mWifiVisible = statusIcon.visible && !mBlockWifi;
+        mWifiStrengthId = statusIcon.icon;
+        mWifiDescription = statusIcon.contentDescription;
+
+        apply();
+    }
+
+    public void setDataActivityMTK(boolean in, boolean out, int subId) {
+        Log.d(TAG, "zly --> setDataActivityMTK(in= " + in + "), out= " + out);
+
+
+        int imgDataActivityID=0;
+        if (in && out) {
+            imgDataActivityID=DATA_ACTIVITY[3];
+        } else if (out) {
+            imgDataActivityID=DATA_ACTIVITY[2];
+        } else if (in) {
+            imgDataActivityID=DATA_ACTIVITY[1];
+        } else {
+            imgDataActivityID=DATA_ACTIVITY[0];
+        }
+        PhoneState state = getState(subId);
+        state.mDataActivityId = imgDataActivityID;
+    }
+
+    ///M: Support[Network Type and volte on StatusBar]. Add more parameter networkType and volte .
+    @Override
+    public void setMobileDataIndicators(IconState statusIcon, IconState qsIcon, int statusType,
+            int networkType, int volteIcon, int qsType, boolean activityIn, boolean activityOut,
+            String typeContentDescription, String description, boolean isWide, int subId) {
+        PhoneState state = getState(subId);
+        if (state == null) {
+            return;
+        }
+        state.mMobileVisible = statusIcon.visible && !mBlockMobile;
+        state.mMobileStrengthId = statusIcon.icon;
+        state.mMobileTypeId = statusType;
+        state.mMobileDescription = statusIcon.contentDescription;
+        state.mMobileTypeDescription = typeContentDescription;
+        state.mIsMobileTypeIconWide = statusType != 0 && isWide;
+        state.mNetworkIcon = networkType;
+        state.mVolteIcon = volteIcon;
+
+        /// M: Add for plugin features. @ {
+        state.mDataActivityIn = activityIn;
+        state.mDataActivityOut = activityOut;
+        /// @ }
+
+        setDataActivityMTK(activityIn, activityOut, subId);
+
+        apply();
+    }
+
+    @Override
+    public void setEthernetIndicators(IconState state) {
+        mEthernetVisible = state.visible && !mBlockEthernet;
+        mEthernetIconId = state.icon;
+        mEthernetDescription = state.contentDescription;
+
+        apply();
+    }
+
+    @Override
+    public void setNoSims(boolean show) {
+        mNoSimsVisible = show && !mBlockMobile;
+        // M: Bug fix ALPS02302143, in case UI need to be refreshed.
+        // MR1 also add this patch
+        apply();
+    }
+
+    @Override
+    public void setSubs(List<SubscriptionInfo> subs) {
+        if (hasCorrectSubs(subs)) {
+            return;
+        }
+        // Clear out all old subIds.
+        for (PhoneState state : mPhoneStates) {
+            if (state.mMobile != null) {
+                state.maybeStopAnimatableDrawable(state.mMobile);
+            }
+            if (state.mMobileDark != null) {
+                state.maybeStopAnimatableDrawable(state.mMobileDark);
+            }
+        }
+        mPhoneStates.clear();
+        if (mMobileSignalGroup != null) {
+            mMobileSignalGroup.removeAllViews();
+        }
+        final int n = subs.size();
+        for (int i = 0; i < n; i++) {
+            inflatePhoneState(subs.get(i).getSubscriptionId());
+        }
+        if (isAttachedToWindow()) {
+            applyIconTint();
+        }
+    }
+
+    private boolean hasCorrectSubs(List<SubscriptionInfo> subs) {
+        final int N = subs.size();
+        if (N != mPhoneStates.size()) {
+            return false;
+        }
+        for (int i = 0; i < N; i++) {
+            if (mPhoneStates.get(i).mSubId != subs.get(i).getSubscriptionId()) {
+                return false;
+            }
+            ///M: fix 2968114, if sim swap but subId has not changed, need to inflate PhoneState
+            /// for op views. @ {
+            if (mStatusBarExt.checkIfSlotIdChanged(subs.get(i).getSubscriptionId(),
+                            subs.get(i).getSimSlotIndex())) {
+                return false;
+            }
+            /// @ }
+        }
+        return true;
+    }
+
+    private PhoneState getState(int subId) {
+        for (PhoneState state : mPhoneStates) {
+            if (state.mSubId == subId) {
+                return state;
+            }
+        }
+        Log.e(TAG, "Unexpected subscription " + subId);
+        return null;
+    }
+
+    private PhoneState inflatePhoneState(int subId) {
+        PhoneState state = new PhoneState(subId, mContext);
+        if (mMobileSignalGroup != null) {
+            mMobileSignalGroup.addView(state.mMobileGroup);
+        }
+        mPhoneStates.add(state);
+        return state;
+    }
+
+    @Override
+    public void setIsAirplaneMode(IconState icon) {
+        mIsAirplaneMode = icon.visible && !mBlockAirplane;
+        mAirplaneIconId = icon.icon;
+        mAirplaneContentDescription = icon.contentDescription;
+
+        apply();
+    }
+
+    @Override
+    public void setMobileDataEnabled(boolean enabled) {
+        // Don't care.
+    }
+
+    @Override
+    public boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent event) {
+        // Standard group layout onPopulateAccessibilityEvent() implementations
+        // ignore content description, so populate manually
+        if (mEthernetVisible && mEthernetGroup != null &&
+                mEthernetGroup.getContentDescription() != null)
+            event.getText().add(mEthernetGroup.getContentDescription());
+        if (mWifiVisible && mWifiGroup != null && mWifiGroup.getContentDescription() != null)
+            event.getText().add(mWifiGroup.getContentDescription());
+        for (PhoneState state : mPhoneStates) {
+            state.populateAccessibilityEvent(event);
+        }
+        return super.dispatchPopulateAccessibilityEventInternal(event);
+    }
+
+    @Override
+    public void onRtlPropertiesChanged(int layoutDirection) {
+        super.onRtlPropertiesChanged(layoutDirection);
+
+        if (mEthernet != null) {
+            mEthernet.setImageDrawable(null);
+            mEthernetDark.setImageDrawable(null);
+            mLastEthernetIconId = -1;
+        }
+
+        if (mWifi != null) {
+            mWifi.setImageDrawable(null);
+            mWifiDark.setImageDrawable(null);
+            mLastWifiStrengthId = -1;
+        }
+
+        for (PhoneState state : mPhoneStates) {
+            if (state.mMobile != null) {
+                state.maybeStopAnimatableDrawable(state.mMobile);
+                state.mMobile.setImageDrawable(null);
+                state.mLastMobileStrengthId = -1;
+            }
+            if (state.mMobileDark != null) {
+                state.maybeStopAnimatableDrawable(state.mMobileDark);
+                state.mMobileDark.setImageDrawable(null);
+                state.mLastMobileStrengthId = -1;
+            }
+            if (state.mMobileType != null) {
+                state.mMobileType.setImageDrawable(null);
+                state.mLastMobileTypeId = -1;
+            }
+        }
+
+        if (mAirplane != null) {
+            mAirplane.setImageDrawable(null);
+            mLastAirplaneIconId = -1;
+        }
+
+        apply();
+    }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
+
+    // Run after each indicator change.
+    private void apply() {
+        if (mWifiGroup == null) return;
+
+        mVpn.setVisibility(mVpnVisible ? View.VISIBLE : View.GONE);
+        if (mVpnVisible) {
+            if (mLastVpnIconId != mVpnIconId) {
+                setIconForView(mVpn, mVpnIconId);
+                mLastVpnIconId = mVpnIconId;
+            }
+            mVpn.setVisibility(View.VISIBLE);
+        } else {
+            mVpn.setVisibility(View.GONE);
+        }
+        if (DEBUG) Log.d(TAG, String.format("vpn: %s", mVpnVisible ? "VISIBLE" : "GONE"));
+
+        if (mEthernetVisible) {
+            if (mLastEthernetIconId != mEthernetIconId) {
+                setIconForView(mEthernet, mEthernetIconId);
+                setIconForView(mEthernetDark, mEthernetIconId);
+                mLastEthernetIconId = mEthernetIconId;
+            }
+            mEthernetGroup.setContentDescription(mEthernetDescription);
+            mEthernetGroup.setVisibility(View.VISIBLE);
+        } else {
+            mEthernetGroup.setVisibility(View.GONE);
+        }
+
+        if (DEBUG) Log.d(TAG,
+                String.format("ethernet: %s",
+                    (mEthernetVisible ? "VISIBLE" : "GONE")));
+
+        if (mWifiVisible) {
+            if (mWifiStrengthId != mLastWifiStrengthId) {
+                setIconForView(mWifi, mWifiStrengthId);
+                setIconForView(mWifiDark, mWifiStrengthId);
+                mLastWifiStrengthId = mWifiStrengthId;
+            }
+            mWifiGroup.setContentDescription(mWifiDescription);
+            mWifiGroup.setVisibility(View.VISIBLE);
+        } else {
+            mWifiGroup.setVisibility(View.GONE);
+        }
+
+        if (DEBUG) Log.d(TAG,
+                String.format("wifi: %s sig=%d",
+                    (mWifiVisible ? "VISIBLE" : "GONE"),
+                    mWifiStrengthId));
+
+        boolean anyMobileVisible = false;
+        /// M: Support for [Network Type on Statusbar]
+        /// A spacer is set between networktype and WIFI icon @ {
+        if (FeatureOptions.MTK_CTA_SET) {
+            anyMobileVisible = true;
+        }
+        /// @ }
+        int firstMobileTypeId = 0;
+        for (PhoneState state : mPhoneStates) {
+            if (state.apply(anyMobileVisible)) {
+                if (!anyMobileVisible) {
+                    firstMobileTypeId = state.mMobileTypeId;
+                    anyMobileVisible = true;
+                }
+            }
+        }
+
+        if (mIsAirplaneMode) {
+            if (mLastAirplaneIconId != mAirplaneIconId) {
+                setIconForView(mAirplane, mAirplaneIconId);
+                mLastAirplaneIconId = mAirplaneIconId;
+            }
+            mAirplane.setContentDescription(mAirplaneContentDescription);
+            mAirplane.setVisibility(View.VISIBLE);
+        } else {
+            mAirplane.setVisibility(View.GONE);
+        }
+
+        if (mIsAirplaneMode && mWifiVisible) {
+            mWifiAirplaneSpacer.setVisibility(View.VISIBLE);
+        } else {
+            mWifiAirplaneSpacer.setVisibility(View.GONE);
+        }
+
+        if (((anyMobileVisible && firstMobileTypeId != 0) || mNoSimsVisible) && mWifiVisible) {
+            mWifiSignalSpacer.setVisibility(View.VISIBLE);
+        } else {
+            mWifiSignalSpacer.setVisibility(View.GONE);
+        }
+
+        mNoSimsCombo.setVisibility(mNoSimsVisible ? View.VISIBLE : View.GONE);
+        mNoSimsComboSlot2.setVisibility(mNoSimsVisible ? View.VISIBLE : View.GONE);
+        /// M: Add for Plugin feature @ {
+        mStatusBarExt.setCustomizedNoSimsVisible(mNoSimsVisible);
+        mStatusBarExt.setCustomizedAirplaneView(mNoSimsCombo, mIsAirplaneMode);
+        mStatusBarExt.setCustomizedAirplaneView(mNoSimsComboSlot2, mIsAirplaneMode);
+        /// @ }
+
+        boolean anythingVisible = mNoSimsVisible || mWifiVisible || mIsAirplaneMode
+                || anyMobileVisible || mVpnVisible || mEthernetVisible;
+        setPaddingRelative(0, 0, anythingVisible ? mEndPadding : mEndPaddingNothingVisible, 0);
+    }
+
+    /**
+     * Sets the given drawable id on the view. This method will also scale the icon by
+     * {@link #mIconScaleFactor} if appropriate.
+     */
+    private void setIconForView(ImageView imageView, @DrawableRes int iconId) {
+        // Using the imageView's context to retrieve the Drawable so that theme is preserved.
+        Drawable icon = imageView.getContext().getDrawable(iconId);
+
+        if (mIconScaleFactor == 1.f) {
+            imageView.setImageDrawable(icon);
+        } else {
+            imageView.setImageDrawable(new ScalingDrawableWrapper(icon, mIconScaleFactor));
+        }
+    }
+
+    public void setIconTint(int tint, float darkIntensity, Rect tintArea) {
+        boolean changed = tint != mIconTint || darkIntensity != mDarkIntensity
+                || !mTintArea.equals(tintArea);
+        mIconTint = tint;
+        mDarkIntensity = darkIntensity;
+        mTintArea.set(tintArea);
+        if (changed && isAttachedToWindow()) {
+            applyIconTint();
+        }
+    }
+
+    private void applyIconTint() {
+        setTint(mVpn, StatusBarIconController.getTint(mTintArea, mVpn, mIconTint));
+        setTint(mAirplane, StatusBarIconController.getTint(mTintArea, mAirplane, mIconTint));
+        applyDarkIntensity(
+                StatusBarIconController.getDarkIntensity(mTintArea, mNoSims, mDarkIntensity),
+                mNoSims, mNoSimsDark);
+        applyDarkIntensity(
+                StatusBarIconController.getDarkIntensity(mTintArea, mNoSimsSlot2, mDarkIntensity),
+                mNoSimsSlot2, mNoSimsDarkSlot2);
+        /// M: Add for noSim view in tint mode. @{
+        mStatusBarExt.setNoSimIconTint(mIconTint, mNoSims);
+        mStatusBarExt.setNoSimIconTint(mIconTint, mNoSimsSlot2);
+        /// @}
+
+        /// M: Add for plugin items tint handling. @{
+        mStatusBarExt.setCustomizedPlmnTextTint(mIconTint);
+        /// @}
+
+        applyDarkIntensity(
+                StatusBarIconController.getDarkIntensity(mTintArea, mWifi, mDarkIntensity),
+                mWifi, mWifiDark);
+        applyDarkIntensity(
+                StatusBarIconController.getDarkIntensity(mTintArea, mEthernet, mDarkIntensity),
+                mEthernet, mEthernetDark);
+        for (int i = 0; i < mPhoneStates.size(); i++) {
+            mPhoneStates.get(i).setIconTint(mIconTint, mDarkIntensity, mTintArea);
+        }
+    }
+
+    private void applyDarkIntensity(float darkIntensity, View lightIcon, View darkIcon) {
+        lightIcon.setAlpha(1 - darkIntensity);
+        darkIcon.setAlpha(darkIntensity);
+    }
+
+    private void setTint(ImageView v, int tint) {
+        v.setImageTintList(ColorStateList.valueOf(tint));
+    }
+
+    private int currentVpnIconId(boolean isBranded) {
+        return isBranded ? R.drawable.stat_sys_branded_vpn : R.drawable.stat_sys_vpn_ic;
+    }
+
+    private class PhoneState {
+        private final int mSubId;
+        private boolean mMobileVisible = false;
+        private int mMobileStrengthId = 0, mMobileTypeId = 0, mNetworkIcon = 0;
+        private int mVolteIcon = 0;
+        private int mLastMobileStrengthId = -1;
+        private int mLastMobileTypeId = -1;
+        private boolean mIsMobileTypeIconWide;
+        private String mMobileDescription, mMobileTypeDescription;
+
+        private ViewGroup mMobileGroup;
+
+        private ImageView mMobile, mMobileDark, mMobileType;
+
+        /// M: Add for new features @ {
+        // Add for [Network Type and volte on Statusbar]
+        private ImageView mNetworkType;
+        private ImageView mVolteType;
+        private boolean mIsWfcCase;
+        /// @ }
+
+        /// M: Add for plugin features. @ {
+        private boolean mDataActivityIn, mDataActivityOut;
+        private ISystemUIStatusBarExt mPhoneStateExt;
+        /// @ }
+
+        private ImageView mDataActivityInOut;
+        private int mDataActivityId = 0;
+        private Context mContext;
+
+        public PhoneState(int subId, Context context) {
+            ViewGroup root = (ViewGroup) LayoutInflater.from(context)
+                    .inflate(R.layout.mobile_signal_group_ext, null);
+
+            /// M: Add data group for plugin feature. @ {
+            mPhoneStateExt = PluginManager.getSystemUIStatusBarExt(context);
+            mPhoneStateExt.addCustomizedView(subId, context, root);
+            /// @ }
+
+            setViews(root);
+            mSubId = subId;
+            mContext = context;
+        }
+
+        public void setViews(ViewGroup root) {
+            mMobileGroup    = root;
+            mMobile         = (ImageView) root.findViewById(R.id.mobile_signal);
+            mMobileDark     = (ImageView) root.findViewById(R.id.mobile_signal_dark);
+            mMobileType     = (ImageView) root.findViewById(R.id.mobile_type);
+            mNetworkType    = (ImageView) root.findViewById(R.id.network_type);
+            mVolteType      = (ImageView) root.findViewById(R.id.volte_indicator_ext);
+            mDataActivityInOut = (ImageView) root.findViewById(R.id.data_inout);
+        }
+
+        public boolean isCellNetwork() {
+            ConnectivityManager connManager = (ConnectivityManager) mContext
+                    .getSystemService(Context.CONNECTIVITY_SERVICE);
+
+            if (null == connManager) {
+                Log.d(TAG, "connectivity manager is null when checking active network");
+                return false;
+            }
+
+            NetworkInfo info = connManager.getActiveNetworkInfo();
+            if (info == null) {
+                Log.d(TAG, "no active network when checking active network");
+                return false;
+            }
+
+            if (!info.isConnected()) {
+                Log.d(TAG, "current network is not connected when checking active network");
+                return false;
+            }
+
+            if (!info.isAvailable()) {
+                Log.d(TAG, "current network is not available when checking active network");
+                return false;
+            }
+
+            if (ConnectivityManager.TYPE_MOBILE == info.getType()) {
+                return true;
+            }
+            return false;
+        }
+
+        public boolean apply(boolean isSecondaryIcon) {
+            if (mMobileVisible && !mIsAirplaneMode) {
+                if (mLastMobileStrengthId != mMobileStrengthId) {
+                    updateAnimatableIcon(mMobile, mMobileStrengthId);
+                    updateAnimatableIcon(mMobileDark, mMobileStrengthId);
+                    mLastMobileStrengthId = mMobileStrengthId;
+                }
+
+                if (mLastMobileTypeId != mMobileTypeId) {
+                    mMobileType.setImageResource(mMobileTypeId);
+                    mLastMobileTypeId = mMobileTypeId;
+                }
+                mMobileGroup.setContentDescription(mMobileTypeDescription
+                        + " " + mMobileDescription);
+                mMobileGroup.setVisibility(View.VISIBLE);
+                showViewInWfcCase();
+
+                if (mDataActivityId != 0 && isCellNetwork() && mSubId == SubscriptionManager.getDefaultDataSubscriptionId()) {
+                    mDataActivityInOut.setImageResource(mDataActivityId);
+                    mDataActivityInOut.setVisibility(View.VISIBLE);
+                } else {
+                    mDataActivityInOut.setImageDrawable(null);
+                    mDataActivityInOut.setVisibility(View.GONE);
+                }
+				if(mApnType.equals("mms")){
+					if(showDataIcon){
+						mDataActivityInOut.setImageResource(mDataActivityId);
+                    	mDataActivityInOut.setVisibility(View.VISIBLE);
+					}else{
+						mDataActivityInOut.setImageDrawable(null);
+                    	mDataActivityInOut.setVisibility(View.GONE);
+					}
+				}
+            } else {
+                if (mIsAirplaneMode && (mIsWfcEnable && mVolteIcon != 0)) {
+                    /// M:Bug fix for show vowifi icon in flight mode
+                    mMobileGroup.setVisibility(View.VISIBLE);
+                    hideViewInWfcCase();
+                } else {
+                    mMobileGroup.setVisibility(View.GONE);
+                }
+            }
+
+            /// M: Set all added or customised view. @ {
+            setCustomizeViewProperty();
+            /// @ }
+
+            // When this isn't next to wifi, give it some extra padding between the signals.
+            mMobileGroup.setPaddingRelative(isSecondaryIcon ? mSecondaryTelephonyPadding : 0,
+                    0, 0, 0);
+            mMobile.setPaddingRelative(
+                    mIsMobileTypeIconWide ? mWideTypeIconStartPadding : mMobileDataIconStartPadding,
+                    0, 0, 0);
+            mMobileDark.setPaddingRelative(
+                    mIsMobileTypeIconWide ? mWideTypeIconStartPadding : mMobileDataIconStartPadding,
+                    0, 0, 0);
+
+            if (DEBUG) Log.d(TAG, String.format("mobile: %s sig=%d typ=%d",
+                        (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileTypeId));
+
+            mMobileType.setVisibility(mMobileTypeId != 0 ? View.VISIBLE : View.GONE);
+
+            /// M: Add for support plugin featurs. @ {
+            setCustomizedOpViews();
+            /// @ }
+
+            return mMobileVisible;
+        }
+
+        private void updateAnimatableIcon(ImageView view, int resId) {
+            maybeStopAnimatableDrawable(view);
+            setIconForView(view, resId);
+            maybeStartAnimatableDrawable(view);
+        }
+
+        private void maybeStopAnimatableDrawable(ImageView view) {
+            Drawable drawable = view.getDrawable();
+
+            // Check if the icon has been scaled. If it has retrieve the actual drawable out of the
+            // wrapper.
+            if (drawable instanceof ScalingDrawableWrapper) {
+                drawable = ((ScalingDrawableWrapper) drawable).getDrawable();
+            }
+
+            if (drawable instanceof Animatable) {
+                Animatable ad = (Animatable) drawable;
+                if (ad.isRunning()) {
+                    ad.stop();
+                }
+            }
+        }
+
+        private void maybeStartAnimatableDrawable(ImageView view) {
+            Drawable drawable = view.getDrawable();
+
+            // Check if the icon has been scaled. If it has retrieve the actual drawable out of the
+            // wrapper.
+            if (drawable instanceof ScalingDrawableWrapper) {
+                drawable = ((ScalingDrawableWrapper) drawable).getDrawable();
+            }
+
+            if (drawable instanceof Animatable) {
+                Animatable ad = (Animatable) drawable;
+                if (ad instanceof AnimatedVectorDrawable) {
+                    ((AnimatedVectorDrawable) ad).forceAnimationOnUI();
+                }
+                if (!ad.isRunning()) {
+                    ad.start();
+                }
+            }
+        }
+
+        public void populateAccessibilityEvent(AccessibilityEvent event) {
+            if (mMobileVisible && mMobileGroup != null
+                    && mMobileGroup.getContentDescription() != null) {
+                event.getText().add(mMobileGroup.getContentDescription());
+            }
+        }
+
+        public void setIconTint(int tint, float darkIntensity, Rect tintArea) {
+            applyDarkIntensity(
+                    StatusBarIconController.getDarkIntensity(tintArea, mMobile, darkIntensity),
+                    mMobile, mMobileDark);
+            setTint(mMobileType, StatusBarIconController.getTint(tintArea, mMobileType, tint));
+            setTint(mNetworkType, StatusBarIconController.getTint(tintArea, mNetworkType, tint));
+            setTint(mVolteType, StatusBarIconController.getTint(tintArea, mVolteType, tint));
+            /// M: Add for op views in tint mode. @{
+            mPhoneStateExt.setIconTint(tint, darkIntensity);
+            /// @}
+        }
+
+        /// M: Set all added or customised view. @ {
+        private void setCustomizeViewProperty() {
+            // Add for [Network Type on Statusbar], the place to set network type icon.
+            setNetworkIcon();
+            /// M: Add for volte icon.
+            setVolteIcon();
+        }
+
+        /// M: Add for volte icon on Statusbar @{
+        private void setVolteIcon() {
+            if (mVolteIcon == 0) {
+                mVolteType.setVisibility(View.GONE);
+            } else {
+                mVolteType.setImageResource(mVolteIcon);
+                mVolteType.setVisibility(View.VISIBLE);
+            }
+            /// M: customize VoLTE icon. @{
+            mStatusBarExt.setCustomizedVolteView(mVolteIcon, mVolteType);
+            mStatusBarExt.setDisVolteView(mSubId, mVolteIcon, mVolteType);
+            /// M: customize VoLTE icon. @}
+        }
+        ///@}
+
+        /// M : Add for [Network Type on Statusbar]
+        private void setNetworkIcon() {
+            // Network type is CTA feature, so non CTA project should not set this.
+            if (!FeatureOptions.MTK_CTA_SET) {
+                return;
+            }
+            if (mNetworkIcon == 0) {
+                mNetworkType.setVisibility(View.GONE);
+            } else {
+				// modify for 114893 by dongdongli 20171205 start 
+                //mNetworkType.setImageResource(mNetworkIcon);
+                //mNetworkType.setVisibility(View.VISIBLE);
+				// modify for 114893 by dongdongli 20171205 end
+            }
+        }
+
+        /// M: Add for plugin features. @ {
+        private void setCustomizedOpViews() {
+            if (mMobileVisible && !mIsAirplaneMode) {
+                mPhoneStateExt.getServiceStateForCustomizedView(mSubId);
+
+                mPhoneStateExt.setCustomizedAirplaneView(
+                    mNoSimsCombo, mIsAirplaneMode);
+                mPhoneStateExt.setCustomizedAirplaneView(
+                        mNoSimsComboSlot2, mIsAirplaneMode);
+                mPhoneStateExt.setCustomizedNetworkTypeView(
+                    mSubId, mNetworkIcon, mNetworkType);
+                mPhoneStateExt.setCustomizedDataTypeView(
+                    mSubId, mMobileTypeId,
+                    mDataActivityIn, mDataActivityOut);
+                mPhoneStateExt.setCustomizedSignalStrengthView(
+                    mSubId, mMobileStrengthId, mMobile);
+                mPhoneStateExt.setCustomizedSignalStrengthView(
+                    mSubId, mMobileStrengthId, mMobileDark);
+                mPhoneStateExt.setCustomizedMobileTypeView(
+                    mSubId, mMobileType);
+                mPhoneStateExt.setCustomizedView(mSubId);
+            }
+        }
+        /// @ }
+
+        private void hideViewInWfcCase() {
+            Log.d(TAG, "hideViewInWfcCase, isWfcEnabled = " + mIsWfcEnable + " mSubId =" + mSubId);
+            mMobile.setVisibility(View.GONE);
+            mMobileDark.setVisibility(View.GONE);
+            mMobileType.setVisibility(View.GONE);
+            mNetworkType.setVisibility(View.GONE);
+            mIsWfcCase = true;
+        }
+
+        private void showViewInWfcCase() {
+            if (mIsWfcCase) {
+                Log.d(TAG, "showViewInWfcCase: mSubId = " + mSubId);
+                mMobile.setVisibility(View.VISIBLE);
+                mMobileDark.setVisibility(View.VISIBLE);
+                mMobileType.setVisibility(View.VISIBLE);
+                mNetworkType.setVisibility(View.VISIBLE);
+                mIsWfcCase = false;
+            }
+        }
+    }
+	class MobilePhoneStateListener extends PhoneStateListener {
+        public MobilePhoneStateListener() {
+            super();
+			
+        }
+		@Override 
+		public void onPreciseDataConnectionStateChanged(PreciseDataConnectionState dataConnectionState){
+			if (DEBUG) {
+				Log.d(TAG, "MobilePhoneStateListener:onPreciseDataConnectionStateChanged() dataConnectionState=" + dataConnectionState);
+	 		}
+            mApnType = dataConnectionState.getDataConnectionAPNType();
+            
+		}
+		@Override
+        public void onDataConnectionStateChanged(int state, int networkType) {
+        	if (DEBUG) {
+				Log.d(TAG, "onDataConnectionStateChanged: dataConnectionState..." );
+	 		}
+			switch(state){
+				case TelephonyManager.DATA_DISCONNECTED:
+					showDataIcon=false;
+				break;
+				case TelephonyManager.DATA_CONNECTED:
+				case TelephonyManager.DATA_CONNECTING:
+					showDataIcon=true;
+				break;
+			}
+        }
+    }
+		
+}
Index: vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java	(revision 8255)
@@ -0,0 +1,1140 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.net.ConnectivityManager;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiManager;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.MathUtils;
+
+import com.android.ims.ImsManager;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.settingslib.net.DataUsageController;
+import com.android.systemui.DemoMode;
+import com.android.systemui.R;
+import com.mediatek.systemui.PluginManager;
+import com.mediatek.systemui.ext.ISystemUIStatusBarExt;
+import com.mediatek.systemui.statusbar.networktype.NetworkTypeUtils;
+import com.mediatek.systemui.statusbar.util.SIMHelper;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
+
+/** Platform implementation of the network controller. **/
+public class NetworkControllerImpl extends BroadcastReceiver
+        implements NetworkController, DemoMode, DataUsageController.NetworkNameProvider {
+    // debug
+    static final String TAG = "NetworkController";
+    static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+    // additional diagnostics, but not logspew
+    static final boolean CHATTY =  Log.isLoggable(TAG + "Chat", Log.DEBUG);
+
+    private static final int EMERGENCY_NO_CONTROLLERS = 0;
+    private static final int EMERGENCY_FIRST_CONTROLLER = 100;
+    private static final int EMERGENCY_VOICE_CONTROLLER = 200;
+    private static final int EMERGENCY_NO_SUB = 300;
+
+    private final Context mContext;
+    private final TelephonyManager mPhone;
+    private final WifiManager mWifiManager;
+    private final ConnectivityManager mConnectivityManager;
+    private final SubscriptionManager mSubscriptionManager;
+    private final boolean mHasMobileDataFeature;
+    private final SubscriptionDefaults mSubDefaults;
+    private final DataSaverController mDataSaverController;
+    private Config mConfig;
+
+    // Subcontrollers.
+    @VisibleForTesting
+    final WifiSignalController mWifiSignalController;
+
+    @VisibleForTesting
+    final EthernetSignalController mEthernetSignalController;
+
+    @VisibleForTesting
+    final Map<Integer, MobileSignalController> mMobileSignalControllers =
+            new HashMap<Integer, MobileSignalController>();
+    // When no SIMs are around at setup, and one is added later, it seems to default to the first
+    // SIM for most actions.  This may be null if there aren't any SIMs around.
+    private MobileSignalController mDefaultSignalController;
+    private final AccessPointControllerImpl mAccessPoints;
+    private final DataUsageController mDataUsageController;
+
+    private boolean mInetCondition; // Used for Logging and demo.
+    // BitSets indicating which network transport types (e.g., TRANSPORT_WIFI, TRANSPORT_MOBILE) are
+    // connected and validated, respectively.
+    private final BitSet mConnectedTransports = new BitSet();
+    private final BitSet mValidatedTransports = new BitSet();
+
+    // States that don't belong to a subcontroller.
+    private boolean mAirplaneMode = false;
+    private boolean mHasNoSims;
+    private Locale mLocale = null;
+    // This list holds our ordering.
+    private List<SubscriptionInfo> mCurrentSubscriptions = new ArrayList<>();
+
+    @VisibleForTesting
+    boolean mListening;
+
+    // The current user ID.
+    private int mCurrentUserId;
+
+    private OnSubscriptionsChangedListener mSubscriptionListener;
+
+    // Handler that all broadcasts are received on.
+    private final Handler mReceiverHandler;
+    // Handler that all callbacks are made on.
+    private final CallbackHandler mCallbackHandler;
+
+    private int mEmergencySource;
+    private boolean mIsEmergency;
+
+    ///: M: Support for PLMN @{
+    String[] mNetworkName;
+    int mSlotCount = 0;
+
+    /// M: Add for Plugin feature. @ {
+    private ISystemUIStatusBarExt mStatusBarSystemUIExt;
+    /// @ }
+
+    // M: [ALPS02614114] Check all phone's emergency state when no sims
+    private boolean mEmergencyPhone[];
+    private int mCellularSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+
+    @VisibleForTesting
+    ServiceState mLastServiceState;
+    private boolean mUserSetup;
+    private NotificationManager mNotificationManager;
+    private Notification mSlot1Notification;
+    private Notification mSlot2Notification;
+    private int SLOT1_NOTIFICATION_ID = 54300;
+    private int SLOT2_NOTIFICATION_ID = 54301;
+    private final int ERR_GPS_DO_NONE = -10;
+    private int nGpsState = ERR_GPS_DO_NONE;
+
+    /**
+     * Construct this controller object and register for updates.
+     */
+    public NetworkControllerImpl(Context context, Looper bgLooper) {
+        this(context, (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE),
+                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE),
+                (WifiManager) context.getSystemService(Context.WIFI_SERVICE),
+                SubscriptionManager.from(context), Config.readConfig(context), bgLooper,
+                new CallbackHandler(),
+                new AccessPointControllerImpl(context, bgLooper),
+                new DataUsageController(context),
+                new SubscriptionDefaults());
+        mReceiverHandler.post(mRegisterListeners);
+    }
+
+    @VisibleForTesting
+    NetworkControllerImpl(Context context, ConnectivityManager connectivityManager,
+            TelephonyManager telephonyManager, WifiManager wifiManager,
+            SubscriptionManager subManager, Config config, Looper bgLooper,
+            CallbackHandler callbackHandler,
+            AccessPointControllerImpl accessPointController,
+            DataUsageController dataUsageController,
+            SubscriptionDefaults defaultsHandler) {
+        mContext = context;
+        mConfig = config;
+        mReceiverHandler = new Handler(bgLooper);
+        mCallbackHandler = callbackHandler;
+        mDataSaverController = new DataSaverController(context);
+
+        mSubscriptionManager = subManager;
+        mSubDefaults = defaultsHandler;
+        mConnectivityManager = connectivityManager;
+        mHasMobileDataFeature =
+                mConnectivityManager.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
+
+        /// M: Support for PLMN. @{
+        mSlotCount = SIMHelper.getSlotCount();
+        mNetworkName = new String[mSlotCount];
+        /// M: Support for PLMN. @}
+
+        // M: [ALPS02614114] Check all phone's emergency state when no sims
+        mEmergencyPhone = new boolean[mSlotCount];
+
+        // telephony
+        mPhone = telephonyManager;
+
+        // wifi
+        mWifiManager = wifiManager;
+
+        mLocale = mContext.getResources().getConfiguration().locale;
+        mAccessPoints = accessPointController;
+        mDataUsageController = dataUsageController;
+        mDataUsageController.setNetworkController(this);
+        // TODO: Find a way to move this into DataUsageController.
+        mDataUsageController.setCallback(new DataUsageController.Callback() {
+            @Override
+            public void onMobileDataEnabled(boolean enabled) {
+                mCallbackHandler.setMobileDataEnabled(enabled);
+            }
+        });
+        mWifiSignalController = new WifiSignalController(mContext, mHasMobileDataFeature,
+                mCallbackHandler, this);
+
+        mEthernetSignalController = new EthernetSignalController(mContext, mCallbackHandler, this);
+
+        // AIRPLANE_MODE_CHANGED is sent at boot; we've probably already missed it
+        updateAirplaneMode(true /* force callback */);
+
+        /// M: Support for plugin. @{
+        mStatusBarSystemUIExt = PluginManager.getSystemUIStatusBarExt(mContext);
+        /// M: Support for plugin. @}
+        mNotificationManager = (NotificationManager)mContext
+                .getSystemService(Context.NOTIFICATION_SERVICE);
+    }
+
+    public DataSaverController getDataSaverController() {
+        return mDataSaverController;
+    }
+
+    private void registerListeners() {
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.registerListener();
+        }
+        if (mSubscriptionListener == null) {
+            mSubscriptionListener = new SubListener();
+        }
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionListener);
+
+        // broadcasts
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
+        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+        filter.addAction(ConnectivityManager.INET_CONDITION_ACTION);
+        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        addCustomizedAction(filter);
+        mContext.registerReceiver(this, filter, null, mReceiverHandler);
+        mListening = true;
+
+        updateMobileControllers();
+    }
+
+    /// M: Add MTK more filter action
+    private void addCustomizedAction(IntentFilter filter) {
+        filter.addAction(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        /// Add for [VOLTE status icon]
+        filter .addAction(ImsManager.ACTION_IMS_STATE_CHANGED);
+        /// Receive preboot ipo broadcast.
+        filter.addAction("android.intent.action.ACTION_PREBOOT_IPO");
+        /// shutdown ipo
+        filter.addAction("android.intent.action.ACTION_SHUTDOWN_IPO");
+    }
+    /// @ }
+
+    private void unregisterListeners() {
+        mListening = false;
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.unregisterListener();
+        }
+        mSubscriptionManager.removeOnSubscriptionsChangedListener(mSubscriptionListener);
+        mContext.unregisterReceiver(this);
+    }
+
+    public int getConnectedWifiLevel() {
+        return mWifiSignalController.getState().level;
+    }
+
+    @Override
+    public AccessPointController getAccessPointController() {
+        return mAccessPoints;
+    }
+
+    @Override
+    public DataUsageController getMobileDataController() {
+        return mDataUsageController;
+    }
+
+    public void addEmergencyListener(EmergencyListener listener) {
+        mCallbackHandler.setListening(listener, true);
+        mCallbackHandler.setEmergencyCallsOnly(isEmergencyOnly());
+    }
+
+    public void removeEmergencyListener(EmergencyListener listener) {
+        mCallbackHandler.setListening(listener, false);
+    }
+
+    public boolean hasMobileDataFeature() {
+        return mHasMobileDataFeature;
+    }
+
+    public boolean hasVoiceCallingFeature() {
+        return mPhone.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE;
+    }
+
+    private MobileSignalController getDataController() {
+        int dataSubId = mSubDefaults.getDefaultDataSubId();
+        if (!SubscriptionManager.isValidSubscriptionId(dataSubId)) {
+            if (DEBUG) Log.e(TAG, "No data sim selected");
+            return mDefaultSignalController;
+        }
+        if (mMobileSignalControllers.containsKey(dataSubId)) {
+            return mMobileSignalControllers.get(dataSubId);
+        }
+        if (DEBUG) Log.e(TAG, "Cannot find controller for data sub: " + dataSubId);
+        return mDefaultSignalController;
+    }
+
+    public String getMobileDataNetworkName() {
+        MobileSignalController controller = getDataController();
+        return controller != null ? controller.getState().networkNameData : "";
+    }
+
+    public boolean isEmergencyOnly() {
+        if (mMobileSignalControllers.size() == 0) {
+            // When there are no active subscriptions, determine emengency state from last
+            // broadcast.
+            Log.d(TAG, "isEmergencyOnly No sims ");
+            mEmergencySource = EMERGENCY_NO_CONTROLLERS;
+            /// M: [ALPS02614114] Check all phone's emergency state when no sims @{
+            for (int i = 0; i < mEmergencyPhone.length; i++) {
+                if (mEmergencyPhone[i]) {
+                    if (DEBUG) Log.d(TAG, "Found emergency in phone " + i);
+                    return true;
+                }
+            }
+            return false;
+            // return mLastServiceState != null && mLastServiceState.isEmergencyOnly();
+            // @}
+        }
+        int voiceSubId = mSubDefaults.getDefaultVoiceSubId();
+        if (!SubscriptionManager.isValidSubscriptionId(voiceSubId)) {
+            for (MobileSignalController mobileSignalController :
+                                            mMobileSignalControllers.values()) {
+                if (!mobileSignalController.getState().isEmergency) {
+                    mEmergencySource = EMERGENCY_FIRST_CONTROLLER
+                            + mobileSignalController.mSubscriptionInfo.getSubscriptionId();
+                    if (DEBUG) Log.d(TAG, "Found emergency " + mobileSignalController.mTag);
+                    return false;
+                }
+            }
+        }
+        if (mMobileSignalControllers.containsKey(voiceSubId)) {
+            mEmergencySource = EMERGENCY_VOICE_CONTROLLER + voiceSubId;
+            if (DEBUG) Log.d(TAG, "Getting emergency from " + voiceSubId);
+            return mMobileSignalControllers.get(voiceSubId).getState().isEmergency;
+        }
+        if (DEBUG) Log.e(TAG, "Cannot find controller for voice sub: " + voiceSubId);
+        mEmergencySource = EMERGENCY_NO_SUB + voiceSubId;
+        // Something is wrong, better assume we can't make calls...
+        return true;
+    }
+
+    /**
+     * Emergency status may have changed (triggered by MobileSignalController),
+     * so we should recheck and send out the state to listeners.
+     */
+    void recalculateEmergency() {
+        mIsEmergency = isEmergencyOnly();
+        mCallbackHandler.setEmergencyCallsOnly(mIsEmergency);
+    }
+
+    public void addSignalCallback(SignalCallback cb) {
+        cb.setSubs(mCurrentSubscriptions);
+        cb.setIsAirplaneMode(new IconState(mAirplaneMode,
+                TelephonyIcons.FLIGHT_MODE_ICON, R.string.accessibility_airplane_mode, mContext));
+        /// M: for ALPS02814831
+        //cb.setNoSims(mHasNoSims);
+        mWifiSignalController.notifyListeners(cb);
+        mEthernetSignalController.notifyListeners(cb);
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.notifyListeners(cb);
+        }
+        mCallbackHandler.setListening(cb, true);
+        /// M: for ALPS02814831,mutil-thread timing issue.
+        cb.setNoSims(mHasNoSims);
+    }
+
+    @Override
+    public void removeSignalCallback(SignalCallback cb) {
+        mCallbackHandler.setListening(cb, false);
+    }
+
+    @Override
+    public void setWifiEnabled(final boolean enabled) {
+        new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(Void... args) {
+                // Disable tethering if enabling Wifi
+                final int wifiApState = mWifiManager.getWifiApState();
+                if (enabled && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
+                        (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
+                    mWifiManager.setWifiApEnabled(null, false);
+                }
+
+                mWifiManager.setWifiEnabled(enabled);
+                return null;
+            }
+        }.execute();
+    }
+
+    @Override
+    public void onUserSwitched(int newUserId) {
+        mCurrentUserId = newUserId;
+        mAccessPoints.onUserSwitched(newUserId);
+        updateConnectivity();
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (CHATTY) {
+            Log.d(TAG, "onReceive: intent=" + intent);
+        }
+        final String action = intent.getAction();
+        if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) ||
+                action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
+            updateConnectivity();
+        } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+            refreshLocale();
+            boolean airplaneMode = intent.getBooleanExtra("state", false);
+            updateAirplaneMode(airplaneMode, false);
+			boolean bFrBug119376 = context.getResources().getBoolean(com.android.internal.R.bool.FR_GPS_AIRPLANE_OFF_BUG);
+			if(airplaneMode && bFrBug119376){
+				nGpsState = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE, nGpsState);
+				Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE, android.provider.Settings.Secure.LOCATION_MODE_OFF);
+			}else if(bFrBug119376){
+				if((nGpsState != ERR_GPS_DO_NONE)){
+					Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE, nGpsState);
+					nGpsState = ERR_GPS_DO_NONE;
+				}
+			}
+        } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED)) {
+            // We are using different subs now, we might be able to make calls.
+            recalculateEmergency();
+        } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
+            // Notify every MobileSignalController so they can know whether they are the
+            // data sim or not.
+            for (MobileSignalController controller : mMobileSignalControllers.values()) {
+                controller.handleBroadcast(intent);
+            }
+        } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+            // Might have different subscriptions now.
+            checkSimStateForNotification(context);
+            updateMobileControllers();
+        /// M: Support "subinfo record update". @{
+        } else if (action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED)) {
+            updateMobileControllersEx(intent);
+            /// M: Support "subinfo record update". @}
+            /// M: update plmn label @{
+            refreshPlmnCarrierLabel();
+            /// @}
+        } else if (action.equals(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED)) {
+            mLastServiceState = ServiceState.newFromBundle(intent.getExtras());
+            // If none of the subscriptions are active, we might need to recalculate
+            // emergency state.
+            /// M:[ALPS02809725]Always save ecc state not only no sim
+            /// M: [ALPS02614114] Check all phone's emergency state when no sims @{
+            if (mLastServiceState != null) {
+               int phoneId = intent.getIntExtra(PhoneConstants.PHONE_KEY,
+                     PhoneConstants.SIM_ID_1);
+               mEmergencyPhone[phoneId] = mLastServiceState.isEmergencyOnly();
+               if (DEBUG) {
+                   Log.d(TAG, "Service State changed...phoneId: " + phoneId
+                           + " ,isEmergencyOnly: " + mEmergencyPhone[phoneId]);
+               }
+               if (mMobileSignalControllers.size() == 0) {
+                  recalculateEmergency();
+               }
+               // @}
+            }
+        } else if (action.equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+            Log.d(TAG, "onRecevie ACTION_IMS_STATE_CHANGED");
+            handleIMSAction(intent);
+        }
+        /// M: Fix ALPS02355838, when ipo boot, re-update the airplane mode status. @{
+        else if (action.equals("android.intent.action.ACTION_PREBOOT_IPO")) {
+            updateAirplaneMode(false);
+        }
+        /// @}
+        /// M: Fix ALPS02491846 when ipo shout down, clear mobilesignalController.
+        else if (action.equals("android.intent.action.ACTION_SHUTDOWN_IPO")){
+            Log.d(TAG, "IPO SHUTDOWN!!!");
+            List<SubscriptionInfo> subscriptions = Collections.emptyList();
+            setCurrentSubscriptions(subscriptions);
+            updateNoSims();
+            recalculateEmergency();
+        }
+        /// @}
+        else {
+            int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                    SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                if (mMobileSignalControllers.containsKey(subId)) {
+                    mMobileSignalControllers.get(subId).handleBroadcast(intent);
+                } else {
+                    // Can't find this subscription...  We must be out of date.
+                    updateMobileControllers();
+                }
+            } else {
+                // No sub id, must be for the wifi.
+                mWifiSignalController.handleBroadcast(intent);
+            }
+        }
+    }
+    
+    private void checkSimStateForNotification(Context mContext) {
+        Notification.Builder builder = new Notification.Builder(mContext);
+        if (!mPhone.hasIccCard(0)) {
+            if (mSlot1Notification == null) {
+                builder.setContentText(mContext.getResources().getString(R.string.no_sim_card1));
+                builder.setDefaults(Notification.DEFAULT_SOUND);
+                builder.setSmallIcon(R.drawable.notification);
+                mSlot1Notification = builder.build();
+                mNotificationManager.notify(SLOT1_NOTIFICATION_ID ,mSlot1Notification);
+            }
+        } else {
+            mNotificationManager.cancel(SLOT1_NOTIFICATION_ID);
+        }
+
+        if (!mPhone.hasIccCard(1)) {
+            if (mSlot2Notification == null) {
+                builder.setContentText(mContext.getResources().getString(R.string.no_sim_card2));
+                builder.setDefaults(Notification.DEFAULT_SOUND);
+                builder.setSmallIcon(R.drawable.notification);
+                mSlot2Notification = builder.build();
+                mNotificationManager.notify(SLOT2_NOTIFICATION_ID ,mSlot2Notification);
+            }
+        } else {
+            mNotificationManager.cancel(SLOT2_NOTIFICATION_ID);
+        }
+    }
+
+    public void onConfigurationChanged() {
+        mConfig = Config.readConfig(mContext);
+        mReceiverHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                handleConfigurationChanged();
+            }
+        });
+    }
+
+    @VisibleForTesting
+    void handleConfigurationChanged() {
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.setConfiguration(mConfig);
+        }
+        refreshLocale();
+    }
+
+    /// M: Support "subinfo record update".
+    private void updateMobileControllersEx(Intent intent){
+        int detectedType = SubscriptionManager.EXTRA_VALUE_NOCHANGE;
+        if (intent != null) {
+            detectedType = intent.getIntExtra(SubscriptionManager.INTENT_KEY_DETECT_STATUS, 0);
+            Log.d(TAG, "updateMobileControllers detectedType: " + detectedType);
+        }
+        // If there have been no relevant changes to any of the subscriptions, we can leave as is.
+        if (detectedType != SubscriptionManager.EXTRA_VALUE_REPOSITION_SIM) {
+            // Even if the controllers are correct, make sure we have the right no sims state.
+            // Such as on boot, don't need any controllers, because there are no sims,
+            // but we still need to update the no sim state.
+            updateNoSims();
+            return;
+        }
+
+        updateMobileControllers();
+    }
+
+    private void updateMobileControllers() {
+        /// M: SIMHelper update Active SubscriptionInfo
+        SIMHelper.updateSIMInfos(mContext);
+
+        if (!mListening) {
+            if (DEBUG) {
+                Log.d(TAG, "updateMobileControllers: it's not listening");
+            }
+            return;
+        }
+        doUpdateMobileControllers();
+    }
+
+    @VisibleForTesting
+    void doUpdateMobileControllers() {
+        List<SubscriptionInfo> subscriptions = mSubscriptionManager.getActiveSubscriptionInfoList();
+        if (subscriptions == null) {
+            Log.d(TAG, "subscriptions is null");
+            subscriptions = Collections.emptyList();
+        }
+        // If there have been no relevant changes to any of the subscriptions, we can leave as is.
+        if (hasCorrectMobileControllers(subscriptions)) {
+            // Even if the controllers are correct, make sure we have the right no sims state.
+            // Such as on boot, don't need any controllers, because there are no sims,
+            // but we still need to update the no sim state.
+            updateNoSims();
+            return;
+        }
+        setCurrentSubscriptions(subscriptions);
+        updateNoSims();
+        recalculateEmergency();
+    }
+
+    @VisibleForTesting
+    protected void updateNoSims() {
+        boolean hasNoSims = mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
+        if (hasNoSims != mHasNoSims) {
+            mHasNoSims = hasNoSims;
+            mCallbackHandler.setNoSims(mHasNoSims);
+        }
+    }
+
+    @VisibleForTesting
+    void setCurrentSubscriptions(List<SubscriptionInfo> subscriptions) {
+        Collections.sort(subscriptions, new Comparator<SubscriptionInfo>() {
+            @Override
+            public int compare(SubscriptionInfo lhs, SubscriptionInfo rhs) {
+                return lhs.getSimSlotIndex() == rhs.getSimSlotIndex()
+                        ? lhs.getSubscriptionId() - rhs.getSubscriptionId()
+                        : lhs.getSimSlotIndex() - rhs.getSimSlotIndex();
+            }
+        });
+        mCurrentSubscriptions = subscriptions;
+
+        HashMap<Integer, MobileSignalController> cachedControllers =
+                new HashMap<Integer, MobileSignalController>(mMobileSignalControllers);
+        mMobileSignalControllers.clear();
+        final int num = subscriptions.size();
+        for (int i = 0; i < num; i++) {
+            int subId = subscriptions.get(i).getSubscriptionId();
+            // If we have a copy of this controller already reuse it, otherwise make a new one.
+            if (cachedControllers.containsKey(subId)) {
+                /// M: Fix bug ALPS02416794 @{
+                MobileSignalController msc = cachedControllers.remove(subId);
+                msc.mSubscriptionInfo = subscriptions.get(i);
+                mMobileSignalControllers.put(subId, msc);
+                /// @}
+            } else {
+                MobileSignalController controller = new MobileSignalController(mContext, mConfig,
+                        mHasMobileDataFeature, mPhone, mCallbackHandler,
+                        this, subscriptions.get(i), mSubDefaults, mReceiverHandler.getLooper());
+                controller.setUserSetupComplete(mUserSetup);
+                mMobileSignalControllers.put(subId, controller);
+                if (subscriptions.get(i).getSimSlotIndex() == 0) {
+                    mDefaultSignalController = controller;
+                }
+                if (mListening) {
+                    controller.registerListener();
+                }
+            }
+        }
+        if (mListening) {
+            for (Integer key : cachedControllers.keySet()) {
+                if (cachedControllers.get(key) == mDefaultSignalController) {
+                    mDefaultSignalController = null;
+                }
+                cachedControllers.get(key).unregisterListener();
+            }
+        }
+        mCallbackHandler.setSubs(subscriptions);
+        notifyAllListeners();
+
+        // There may be new MobileSignalControllers around, make sure they get the current
+        // inet condition and airplane mode.
+        pushConnectivityToSignals();
+        updateAirplaneMode(true /* force */);
+    }
+
+    public void setUserSetupComplete(final boolean userSetup) {
+        mReceiverHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                handleSetUserSetupComplete(userSetup);
+            }
+        });
+    }
+
+    @VisibleForTesting
+    void handleSetUserSetupComplete(boolean userSetup) {
+        mUserSetup = userSetup;
+        for (MobileSignalController controller : mMobileSignalControllers.values()) {
+            controller.setUserSetupComplete(mUserSetup);
+        }
+    }
+
+    @VisibleForTesting
+    boolean hasCorrectMobileControllers(List<SubscriptionInfo> allSubscriptions) {
+        if (allSubscriptions.size() != mMobileSignalControllers.size()) {
+            Log.d(TAG,"size not equals, reset subInfo");
+            return false;
+        }
+        /// M: Fix bug ALPS02416794 for check subid that map order is whether match.@{
+        for (SubscriptionInfo info : allSubscriptions) {
+            /*if (!mMobileSignalControllers.containsKey(info.getSubscriptionId())) {
+                return false;
+            }*/
+            MobileSignalController msc = mMobileSignalControllers.get(info.getSubscriptionId());
+            if (msc == null || msc.mSubscriptionInfo.getSimSlotIndex() != info.getSimSlotIndex()) {
+                Log.d(TAG, "info_subId = " + info.getSubscriptionId() +
+                       " info_slotId = " + info.getSimSlotIndex());
+                return false;
+            }
+        }
+        /// @}
+        return true;
+    }
+
+    private void updateAirplaneMode(boolean force) {
+        boolean airplaneMode = (Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_ON, 0) == 1);
+        /**
+         *  M: Extract the method to another function called
+         *  {@link updateAirplaneMode(boolean airplaneMode, boolean force)}
+         */
+        updateAirplaneMode(airplaneMode, force);
+    }
+
+    /// M: Since in broadcast case the provider may have delay, so extract a method
+    /// and pass airplane mode state. @ {
+    private void updateAirplaneMode(boolean airplaneMode, boolean force) {
+        if (airplaneMode != mAirplaneMode || force) {
+            mAirplaneMode = airplaneMode;
+            for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+                mobileSignalController.setAirplaneMode(mAirplaneMode);
+            }
+            notifyListeners();
+        }
+    }
+    /// @ }
+
+    private void refreshLocale() {
+        Locale current = mContext.getResources().getConfiguration().locale;
+        if (!current.equals(mLocale)) {
+            mLocale = current;
+            notifyAllListeners();
+        }
+    }
+
+    /**
+     * Forces update of all callbacks on both SignalClusters and
+     * NetworkSignalChangedCallbacks.
+     */
+    private void notifyAllListeners() {
+        notifyListeners();
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.notifyListeners();
+        }
+        mWifiSignalController.notifyListeners();
+        mEthernetSignalController.notifyListeners();
+    }
+
+    /**
+     * Notifies listeners of changes in state of to the NetworkController, but
+     * does not notify for any info on SignalControllers, for that call
+     * notifyAllListeners.
+     */
+    private void notifyListeners() {
+        mCallbackHandler.setIsAirplaneMode(new IconState(mAirplaneMode,
+                TelephonyIcons.FLIGHT_MODE_ICON, R.string.accessibility_airplane_mode, mContext));
+        mCallbackHandler.setNoSims(mHasNoSims);
+    }
+
+    /**
+     * Update the Inet conditions and what network we are connected to.
+     */
+    private void updateConnectivity() {
+        mConnectedTransports.clear();
+        mValidatedTransports.clear();
+        mCellularSubId = mSubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        for (NetworkCapabilities nc :
+                mConnectivityManager.getDefaultNetworkCapabilitiesForUser(mCurrentUserId)) {
+            for (int transportType : nc.getTransportTypes()) {
+                mConnectedTransports.set(transportType);
+                if (transportType == NetworkCapabilities.TRANSPORT_CELLULAR) {
+                    mCellularSubId = Integer.parseInt(nc.getNetworkSpecifier());
+                    Log.d(TAG,"mCellularSubId = " + mCellularSubId);
+                }
+                if (nc.hasCapability(NET_CAPABILITY_VALIDATED)) {
+                    mValidatedTransports.set(transportType);
+                }
+            }
+        }
+
+        if (CHATTY) {
+            Log.d(TAG, "updateConnectivity: mConnectedTransports=" + mConnectedTransports);
+            Log.d(TAG, "updateConnectivity: mValidatedTransports=" + mValidatedTransports);
+        }
+
+        mInetCondition = !mValidatedTransports.isEmpty();
+
+        pushConnectivityToSignals();
+    }
+
+    // M: Get whether the connected cellular sim is passed in subId
+    boolean isCellularConnected(int subId) {
+        return mCellularSubId == subId;
+    }
+
+    /**
+     * Pushes the current connectivity state to all SignalControllers.
+     */
+    private void pushConnectivityToSignals() {
+        // We want to update all the icons, all at once, for any condition change
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.updateConnectivity(mConnectedTransports, mValidatedTransports);
+        }
+        mWifiSignalController.updateConnectivity(mConnectedTransports, mValidatedTransports);
+        mEthernetSignalController.updateConnectivity(mConnectedTransports, mValidatedTransports);
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("NetworkController state:");
+
+        pw.println("  - telephony ------");
+        pw.print("  hasVoiceCallingFeature()=");
+        pw.println(hasVoiceCallingFeature());
+
+        pw.println("  - connectivity ------");
+        pw.print("  mConnectedTransports=");
+        pw.println(mConnectedTransports);
+        pw.print("  mValidatedTransports=");
+        pw.println(mValidatedTransports);
+        pw.print("  mInetCondition=");
+        pw.println(mInetCondition);
+        pw.print("  mAirplaneMode=");
+        pw.println(mAirplaneMode);
+        pw.print("  mLocale=");
+        pw.println(mLocale);
+        pw.print("  mLastServiceState=");
+        pw.println(mLastServiceState);
+        pw.print("  mIsEmergency=");
+        pw.println(mIsEmergency);
+        pw.print("  mEmergencySource=");
+        pw.println(emergencyToString(mEmergencySource));
+
+        for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
+            mobileSignalController.dump(pw);
+        }
+        mWifiSignalController.dump(pw);
+
+        mEthernetSignalController.dump(pw);
+
+        mAccessPoints.dump(pw);
+    }
+
+    private static final String emergencyToString(int emergencySource) {
+        if (emergencySource > EMERGENCY_NO_SUB) {
+            return "NO_SUB(" + (emergencySource - EMERGENCY_NO_SUB) + ")";
+        } else if (emergencySource > EMERGENCY_VOICE_CONTROLLER) {
+            return "VOICE_CONTROLLER(" + (emergencySource - EMERGENCY_VOICE_CONTROLLER) + ")";
+        } else if (emergencySource > EMERGENCY_FIRST_CONTROLLER) {
+            return "FIRST_CONTROLLER(" + (emergencySource - EMERGENCY_FIRST_CONTROLLER) + ")";
+        } else if (emergencySource == EMERGENCY_NO_CONTROLLERS) {
+            return "NO_CONTROLLERS";
+        }
+        return "UNKNOWN_SOURCE";
+    }
+
+    private boolean mDemoMode;
+    private boolean mDemoInetCondition;
+    private WifiSignalController.WifiState mDemoWifiState;
+
+    @Override
+    public void dispatchDemoCommand(String command, Bundle args) {
+        if (!mDemoMode && command.equals(COMMAND_ENTER)) {
+            if (DEBUG) Log.d(TAG, "Entering demo mode");
+            unregisterListeners();
+            mDemoMode = true;
+            mDemoInetCondition = mInetCondition;
+            mDemoWifiState = mWifiSignalController.getState();
+        } else if (mDemoMode && command.equals(COMMAND_EXIT)) {
+            if (DEBUG) Log.d(TAG, "Exiting demo mode");
+            mDemoMode = false;
+            // Update what MobileSignalControllers, because they may change
+            // to set the number of sim slots.
+            updateMobileControllers();
+            for (MobileSignalController controller : mMobileSignalControllers.values()) {
+                controller.resetLastState();
+            }
+            mWifiSignalController.resetLastState();
+            mReceiverHandler.post(mRegisterListeners);
+            notifyAllListeners();
+        } else if (mDemoMode && command.equals(COMMAND_NETWORK)) {
+            String airplane = args.getString("airplane");
+            if (airplane != null) {
+                boolean show = airplane.equals("show");
+                mCallbackHandler.setIsAirplaneMode(new IconState(show,
+                        TelephonyIcons.FLIGHT_MODE_ICON, R.string.accessibility_airplane_mode,
+                        mContext));
+            }
+            String fully = args.getString("fully");
+            if (fully != null) {
+                mDemoInetCondition = Boolean.parseBoolean(fully);
+                BitSet connected = new BitSet();
+
+                if (mDemoInetCondition) {
+                    connected.set(mWifiSignalController.mTransportType);
+                }
+                mWifiSignalController.updateConnectivity(connected, connected);
+                for (MobileSignalController controller : mMobileSignalControllers.values()) {
+                    if (mDemoInetCondition) {
+                        connected.set(controller.mTransportType);
+                    }
+                    controller.updateConnectivity(connected, connected);
+                }
+            }
+            String wifi = args.getString("wifi");
+            if (wifi != null) {
+                boolean show = wifi.equals("show");
+                String level = args.getString("level");
+                if (level != null) {
+                    mDemoWifiState.level = level.equals("null") ? -1
+                            : Math.min(Integer.parseInt(level), WifiIcons.WIFI_LEVEL_COUNT - 1);
+                    mDemoWifiState.connected = mDemoWifiState.level >= 0;
+                }
+                mDemoWifiState.enabled = show;
+                mWifiSignalController.notifyListeners();
+            }
+            String sims = args.getString("sims");
+            if (sims != null) {
+                int num = MathUtils.constrain(Integer.parseInt(sims), 1, 8);
+                List<SubscriptionInfo> subs = new ArrayList<>();
+                if (num != mMobileSignalControllers.size()) {
+                    mMobileSignalControllers.clear();
+                    int start = mSubscriptionManager.getActiveSubscriptionInfoCountMax();
+                    for (int i = start /* get out of normal index range */; i < start + num; i++) {
+                        subs.add(addSignalController(i, i));
+                    }
+                    mCallbackHandler.setSubs(subs);
+                }
+            }
+            String nosim = args.getString("nosim");
+            if (nosim != null) {
+                mHasNoSims = nosim.equals("show");
+                mCallbackHandler.setNoSims(mHasNoSims);
+            }
+            String mobile = args.getString("mobile");
+            if (mobile != null) {
+                boolean show = mobile.equals("show");
+                String datatype = args.getString("datatype");
+                String slotString = args.getString("slot");
+                int slot = TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
+                slot = MathUtils.constrain(slot, 0, 8);
+                // Ensure we have enough sim slots
+                List<SubscriptionInfo> subs = new ArrayList<>();
+                while (mMobileSignalControllers.size() <= slot) {
+                    int nextSlot = mMobileSignalControllers.size();
+                    subs.add(addSignalController(nextSlot, nextSlot));
+                }
+                if (!subs.isEmpty()) {
+                    mCallbackHandler.setSubs(subs);
+                }
+                // Hack to index linearly for easy use.
+                MobileSignalController controller = mMobileSignalControllers
+                        .values().toArray(new MobileSignalController[0])[slot];
+                controller.getState().dataSim = datatype != null;
+                if (datatype != null) {
+                    controller.getState().iconGroup =
+                            datatype.equals("1x") ? TelephonyIcons.ONE_X :
+                            datatype.equals("3g") ? TelephonyIcons.THREE_G :
+                            datatype.equals("4g") ? TelephonyIcons.FOUR_G :
+                            datatype.equals("4g+") ? TelephonyIcons.FOUR_G_PLUS :
+                            datatype.equals("e") ? TelephonyIcons.E :
+                            datatype.equals("g") ? TelephonyIcons.G :
+                            datatype.equals("h") ? TelephonyIcons.H :
+                            datatype.equals("lte") ? TelephonyIcons.LTE :
+                            datatype.equals("lte+") ? TelephonyIcons.LTE_PLUS :
+                            datatype.equals("roam") ? TelephonyIcons.ROAMING :
+                            TelephonyIcons.UNKNOWN;
+                }
+                int[][] icons = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
+                String level = args.getString("level");
+                if (level != null) {
+                    controller.getState().level = level.equals("null") ? -1
+                            : Math.min(Integer.parseInt(level), icons[0].length - 1);
+                    controller.getState().connected = controller.getState().level >= 0;
+                }
+                controller.getState().enabled = show;
+                controller.notifyListeners();
+            }
+            String carrierNetworkChange = args.getString("carriernetworkchange");
+            if (carrierNetworkChange != null) {
+                boolean show = carrierNetworkChange.equals("show");
+                for (MobileSignalController controller : mMobileSignalControllers.values()) {
+                    controller.setCarrierNetworkChangeMode(show);
+                }
+            }
+        }
+    }
+
+    private SubscriptionInfo addSignalController(int id, int simSlotIndex) {
+        SubscriptionInfo info = new SubscriptionInfo(id, "", simSlotIndex, "", "", 0, 0, "", 0,
+                null, 0, 0, "");
+        mMobileSignalControllers.put(id, new MobileSignalController(mContext,
+                mConfig, mHasMobileDataFeature, mPhone, mCallbackHandler, this, info,
+                mSubDefaults, mReceiverHandler.getLooper()));
+        return info;
+    }
+
+    public boolean hasEmergencyCryptKeeperText() {
+        return EncryptionHelper.IS_DATA_ENCRYPTED;
+    }
+
+    public boolean isRadioOn() {
+        return !mAirplaneMode;
+    }
+
+    private class SubListener extends OnSubscriptionsChangedListener {
+        @Override
+        public void onSubscriptionsChanged() {
+            updateMobileControllers();
+        }
+    }
+    /**
+     * Used to register listeners from the BG Looper, this way the PhoneStateListeners that
+     * get created will also run on the BG Looper.
+     */
+    private final Runnable mRegisterListeners = new Runnable() {
+        @Override
+        public void run() {
+            registerListeners();
+        }
+    };
+
+    public static class SubscriptionDefaults {
+        public int getDefaultVoiceSubId() {
+            return SubscriptionManager.getDefaultVoiceSubscriptionId();
+        }
+
+        public int getDefaultDataSubId() {
+            return SubscriptionManager.getDefaultDataSubscriptionId();
+        }
+    }
+    /// M: Support[Network Type on Statusbar]
+    /// public the class so other class able to access config.
+    @VisibleForTesting
+    public static class Config {
+        public boolean showAtLeast3G = false;
+        public boolean alwaysShowCdmaRssi = false;
+        public boolean show4gForLte = false;
+        public boolean hideLtePlus = false;
+        public boolean hspaDataDistinguishable;
+
+        static Config readConfig(Context context) {
+            Config config = new Config();
+            Resources res = context.getResources();
+
+            config.showAtLeast3G = res.getBoolean(R.bool.config_showMin3G);
+            config.alwaysShowCdmaRssi =
+                    res.getBoolean(com.android.internal.R.bool.config_alwaysUseCdmaRssi);
+            config.show4gForLte = res.getBoolean(R.bool.config_show4GForLTE);
+            config.hspaDataDistinguishable =
+                    res.getBoolean(R.bool.config_hspa_data_distinguishable);
+            config.hideLtePlus = res.getBoolean(R.bool.config_hideLtePlus);
+            return config;
+        }
+    }
+
+    /// M: Support [Volte icon status]
+    @VisibleForTesting
+    void handleIMSAction(Intent intent) {
+        int phoneId = intent.getIntExtra(ImsManager.EXTRA_PHONE_ID,
+                SubscriptionManager.INVALID_PHONE_INDEX);
+        mStatusBarSystemUIExt.setImsSlotId(phoneId);
+        for (MobileSignalController controller : mMobileSignalControllers.values()) {
+            if (controller.getControllerSubInfo().getSimSlotIndex() ==
+                    intent.getIntExtra(ImsManager.EXTRA_PHONE_ID,
+                            SubscriptionManager.INVALID_PHONE_INDEX)) {
+                controller.handleBroadcast(intent);
+                break;
+            }
+        }
+    }
+    /// @}
+
+    /// M: Support "Operator plugin - Customize Carrier Label for PLMN". @{
+    /**
+     * Recalculate and update the plmn carrier label.
+     */
+    public void refreshPlmnCarrierLabel() {
+        for (int i = 0; i < mSlotCount; i++) {
+            boolean found = false;
+            for (Map.Entry<Integer, MobileSignalController> entry : mMobileSignalControllers
+                    .entrySet()) {
+                int subId = entry.getKey();
+                int slotId = -1;
+                MobileSignalController controller = entry.getValue();
+
+                if (controller.getControllerSubInfo() != null) {
+                    slotId = controller.getControllerSubInfo().getSimSlotIndex();
+                }
+
+                if (i == slotId) {
+                    mNetworkName[slotId] = controller.mCurrentState.networkName;
+                    PluginManager.getStatusBarPlmnPlugin(mContext).updateCarrierLabel(i, true,
+                            controller.getControllserHasService(), mNetworkName);
+                    mStatusBarSystemUIExt.setSimInserted(i, true);
+                    found = true;
+                    break;
+                }
+            }
+            // not have sub
+            if (!found) {
+                mNetworkName[i] = mContext
+                        .getString(com.android.internal.R.string.lockscreen_carrier_default);
+                PluginManager.getStatusBarPlmnPlugin(mContext).updateCarrierLabel(i, false, false,
+                        mNetworkName);
+                mStatusBarSystemUIExt.setSimInserted(i, false);
+            }
+        }
+    }
+    /// M: Support "Operator plugin - Customize Carrier Label for PLMN". @}
+
+}
Index: vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/res/layout/signal_cluster_view.xml
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/res/layout/signal_cluster_view.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/base/packages/SystemUI/res/layout/signal_cluster_view.xml	(revision 8255)
@@ -0,0 +1,139 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
+**
+**     http://www.apache.org/licenses/LICENSE-2.0 
+**
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
+** limitations under the License.
+*/
+-->
+<!-- extends LinearLayout -->
+<com.android.systemui.statusbar.SignalClusterView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/signal_cluster"
+    android:layout_height="match_parent"
+    android:layout_width="wrap_content"
+    android:gravity="center_vertical"
+    android:orientation="horizontal"
+    android:paddingEnd="@dimen/signal_cluster_battery_padding"
+    >
+    <ImageView
+        android:id="@+id/vpn"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:paddingEnd="6dp"
+        android:src="@drawable/stat_sys_vpn_ic"
+        />
+    <FrameLayout
+        android:id="@+id/ethernet_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneLightTheme"
+            android:id="@+id/ethernet"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            />
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneDarkTheme"
+            android:id="@+id/ethernet_dark"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:alpha="0.0"
+            />
+    </FrameLayout>
+    <FrameLayout
+        android:id="@+id/wifi_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneLightTheme"
+            android:id="@+id/wifi_signal"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            />
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneDarkTheme"
+            android:id="@+id/wifi_signal_dark"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:alpha="0.0"
+            />
+    </FrameLayout>
+    <View
+        android:id="@+id/wifi_signal_spacer"
+        android:layout_width="@dimen/status_bar_wifi_signal_spacer_width"
+        android:layout_height="4dp"
+        android:visibility="gone"
+        />
+    <LinearLayout
+        android:id="@+id/mobile_signal_group"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+    </LinearLayout>
+    <FrameLayout
+        android:id="@+id/no_sims_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:contentDescription="@string/accessibility_no_sims">
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneLightTheme"
+            android:id="@+id/no_sims"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:src="@drawable/stat_sys_no_sims"
+            />
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneDarkTheme"
+            android:id="@+id/no_sims_dark"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:src="@drawable/stat_sys_no_sims"
+            android:alpha="0.0"
+            />
+    </FrameLayout>
+    <FrameLayout
+        android:id="@+id/no_sims_combo_slot2"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:contentDescription="@string/accessibility_no_sims">
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneLightTheme"
+            android:id="@+id/no_sims_slot2"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:src="@drawable/stat_sys_no_sims"
+            />
+        <com.android.systemui.statusbar.AlphaOptimizedImageView
+            android:theme="@style/DualToneDarkTheme"
+            android:id="@+id/no_sims_dark_slot2"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:src="@drawable/stat_sys_no_sims"
+            android:alpha="0.0"
+            />
+    </FrameLayout>
+    <View
+        android:id="@+id/wifi_airplane_spacer"
+        android:layout_width="@dimen/status_bar_airplane_spacer_width"
+        android:layout_height="4dp"
+        android:visibility="gone"
+        />
+    <ImageView
+        android:id="@+id/airplane"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        />
+</com.android.systemui.statusbar.SignalClusterView>
