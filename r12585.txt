Index: vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h
===================================================================
--- vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h	(revision 0)
+++ vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h	(revision 12585)
@@ -0,0 +1,14 @@
+#ifndef __CUST_USB_H__
+#define __CUST_USB_H__
+
+#define CONFIG_USBD_LANG	"0409"
+
+#define USB_VENDORID		(0x0BB4)
+#define USB_PRODUCTID		(0x0C01)
+#define USB_VERSIONID		(0x0100)
+#define USB_MANUFACTURER	"3Prism XX"
+#define USB_PRODUCT_NAME	"3Prism XX"
+#define FASTBOOT_DEVNAME	"3Prism XX"
+#define SN_BUF_LEN		19
+
+#endif /* __CUST_USB_H__ */

Property changes on: vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h
===================================================================
--- vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h	(revision 0)
+++ vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h	(revision 12585)
@@ -0,0 +1,52 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+
+#ifndef CUST_USB_H
+#define CUST_USB_H
+
+
+/*=======================================================================*/
+/* USB Control                                                           */	
+/*=======================================================================*/
+#define USBD_MANUFACTURER               "3Prism XX"
+#define USBD_PRODUCT_NAME               "3Prism XX"
+#define USBD_VENDORID                   (0x0E8D)
+#define USBD_PRODUCTID                  (0x2000)
+
+#define CFG_USB_HANDSHAKE_TIMEOUT_EN    (1)
+#define CFG_USB_ENUM_TIMEOUT_EN         (1)
+
+#endif   /*_CUST_USBDL_FLOW_H*/

Property changes on: vendor/branch/5058Y_ALIE/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/device/mediatek/common/custom.conf
===================================================================
--- vendor/branch/5058Y_ALIE/device/mediatek/common/custom.conf	(revision 0)
+++ vendor/branch/5058Y_ALIE/device/mediatek/common/custom.conf	(revision 12585)
@@ -0,0 +1,34 @@
+# [usage]
+# format-> m.n=v
+# m -> module definition, support wildcards
+# p -> property name, used as key, case sensitive
+# v -> property value
+#
+# [example]
+# mms.UserAgent = Android 4.0/Release 01.05.2012
+# bluetooth.HostName = BtDevice
+# *.UAProfileURL = http://www.google.com/UAProf.xml
+#
+# [notice]
+# CR/LF used as only delimiter of each configuaration items, both LINUX/MAC/DOS format supported
+# character set: ASCII, encoding type: UTF8
+
+#browser.UserAgent = Athens15_TD/V2 Linux/3.0.13 Android/4.0 Release/02.15.2012 Browser/AppleWebKit534.30 Mobile Safari/534.30 System/Android 4.0.1;
+browser.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
+mms.UserAgent = Android-Mms/0.1
+mms.UAProfileURL = http://www.google.com/oha/rdf/ua-profile-kila.xml 
+http_streaming.UserAgent = stagefright/1.2 (Linux;Android @ro.build.version.release )
+rtsp_streaming.UserAgent = stagefright/1.2 (Linux;Android @ro.build.version.release )
+#http_streaming.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml
+#rtsp_streaming.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml
+dm.Manufacturer = ALCATEL
+dm.Model = 5058Y
+bluetooth.HostName = 3Prism XX
+fmtransmitter.RDSValue = 3Prism XX
+wlan.SSID = 3Prism XX
+Setting.Model=@ro.product.model@
+Setting.SWVerno= 01001
+
+
+
+

Property changes on: vendor/branch/5058Y_ALIE/device/mediatek/common/custom.conf
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/frameworks/av/media/mtp/MtpServer.cpp
===================================================================
--- vendor/branch/5058Y_ALIE/frameworks/av/media/mtp/MtpServer.cpp	(revision 0)
+++ vendor/branch/5058Y_ALIE/frameworks/av/media/mtp/MtpServer.cpp	(revision 12585)
@@ -0,0 +1,1384 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+#include <cutils/properties.h>
+
+#define LOG_TAG "MtpServer"
+
+#include "MtpDebug.h"
+#include "MtpDatabase.h"
+#include "MtpObjectInfo.h"
+#include "MtpProperty.h"
+#include "MtpServer.h"
+#include "MtpStorage.h"
+#include "MtpStringBuffer.h"
+
+#include <linux/usb/f_mtp.h>
+
+// switch log level for user build
+#ifdef MTK_USER_BUILD
+#undef ALOGD
+#define ALOGD ALOGV
+#endif
+
+namespace android {
+
+static const MtpOperationCode kSupportedOperationCodes[] = {
+    MTP_OPERATION_GET_DEVICE_INFO,
+    MTP_OPERATION_OPEN_SESSION,
+    MTP_OPERATION_CLOSE_SESSION,
+    MTP_OPERATION_GET_STORAGE_IDS,
+    MTP_OPERATION_GET_STORAGE_INFO,
+    MTP_OPERATION_GET_NUM_OBJECTS,
+    MTP_OPERATION_GET_OBJECT_HANDLES,
+    MTP_OPERATION_GET_OBJECT_INFO,
+    MTP_OPERATION_GET_OBJECT,
+    MTP_OPERATION_GET_THUMB,
+    MTP_OPERATION_DELETE_OBJECT,
+    MTP_OPERATION_SEND_OBJECT_INFO,
+    MTP_OPERATION_SEND_OBJECT,
+//    MTP_OPERATION_INITIATE_CAPTURE,
+//    MTP_OPERATION_FORMAT_STORE,
+//    MTP_OPERATION_RESET_DEVICE,
+//    MTP_OPERATION_SELF_TEST,
+//    MTP_OPERATION_SET_OBJECT_PROTECTION,
+//    MTP_OPERATION_POWER_DOWN,
+    MTP_OPERATION_GET_DEVICE_PROP_DESC,
+    MTP_OPERATION_GET_DEVICE_PROP_VALUE,
+    MTP_OPERATION_SET_DEVICE_PROP_VALUE,
+    MTP_OPERATION_RESET_DEVICE_PROP_VALUE,
+//    MTP_OPERATION_TERMINATE_OPEN_CAPTURE,
+//    MTP_OPERATION_MOVE_OBJECT,
+//    MTP_OPERATION_COPY_OBJECT,
+    MTP_OPERATION_GET_PARTIAL_OBJECT,
+//    MTP_OPERATION_INITIATE_OPEN_CAPTURE,
+    MTP_OPERATION_GET_OBJECT_PROPS_SUPPORTED,
+    MTP_OPERATION_GET_OBJECT_PROP_DESC,
+    MTP_OPERATION_GET_OBJECT_PROP_VALUE,
+    MTP_OPERATION_SET_OBJECT_PROP_VALUE,
+    MTP_OPERATION_GET_OBJECT_PROP_LIST,
+//    MTP_OPERATION_SET_OBJECT_PROP_LIST,
+//    MTP_OPERATION_GET_INTERDEPENDENT_PROP_DESC,
+//    MTP_OPERATION_SEND_OBJECT_PROP_LIST,
+    MTP_OPERATION_GET_OBJECT_REFERENCES,
+    MTP_OPERATION_SET_OBJECT_REFERENCES,
+//    MTP_OPERATION_SKIP,
+    // Android extension for direct file IO
+    MTP_OPERATION_GET_PARTIAL_OBJECT_64,
+    MTP_OPERATION_SEND_PARTIAL_OBJECT,
+    MTP_OPERATION_TRUNCATE_OBJECT,
+    MTP_OPERATION_BEGIN_EDIT_OBJECT,
+    MTP_OPERATION_END_EDIT_OBJECT,
+};
+
+static const MtpEventCode kSupportedEventCodes[] = {
+    MTP_EVENT_OBJECT_ADDED,
+    MTP_EVENT_OBJECT_REMOVED,
+    MTP_EVENT_STORE_ADDED,
+    MTP_EVENT_STORE_REMOVED,
+    MTP_EVENT_DEVICE_PROP_CHANGED,
+    // for storage update
+    MTP_EVENT_OBJECT_INFO_CHANGED,
+    MTP_EVENT_STORAGE_INFO_CHANGED,
+};
+
+MtpServer::MtpServer(int fd, MtpDatabase* database, bool ptp,
+                    int fileGroup, int filePerm, int directoryPerm)
+    :   mFD(fd),
+        mDatabase(database),
+        mPtp(ptp),
+        mFileGroup(fileGroup),
+        mFilePermission(filePerm),
+        mDirectoryPermission(directoryPerm),
+        mSessionID(0),
+        mSessionOpen(false),
+        mSendObjectHandle(kInvalidObjectHandle),
+        mSendObjectFormat(0),
+        mSendObjectFileSize(0)
+{
+}
+
+MtpServer::~MtpServer() {
+}
+
+void MtpServer::addStorage(MtpStorage* storage) {
+    Mutex::Autolock autoLock(mMutex);
+
+    mStorages.push(storage);
+    sendStoreAdded(storage->getStorageID());
+
+    ALOGD("addStorage, storageID = 0x%x, size = %zd",
+        storage->getStorageID(), mStorages.size());
+}
+
+void MtpServer::removeStorage(MtpStorage* storage) {
+    Mutex::Autolock autoLock(mMutex);
+
+    ALOGD("removeStorage, storageID = 0x%x",
+        storage->getStorageID());
+
+    for (size_t i = 0; i < mStorages.size(); i++) {
+        if (mStorages[i] == storage) {
+            mStorages.removeAt(i);
+            sendStoreRemoved(storage->getStorageID());
+            break;
+        }
+    }
+}
+
+MtpStorage* MtpServer::getStorage(MtpStorageID id) {
+    if (id == 0)
+        return mStorages[0];
+    for (size_t i = 0; i < mStorages.size(); i++) {
+        MtpStorage* storage = mStorages[i];
+        if (storage->getStorageID() == id)
+            return storage;
+    }
+    return NULL;
+}
+
+bool MtpServer::hasStorage(MtpStorageID id) {
+    if (id == 0 || id == 0xFFFFFFFF)
+        return mStorages.size() > 0;
+    return (getStorage(id) != NULL);
+}
+
+void MtpServer::run() {
+    int fd = mFD;
+
+    ALOGD("MtpServer::run fd: %d\n", fd);
+
+    while (1) {
+        int ret = mRequest.read(fd);
+        if (ret < 0) {
+            ALOGD("request read returned %d, errno: %d", ret, errno);
+            if (errno == ECANCELED) {
+                // return to top of loop and wait for next command
+                continue;
+            }
+            break;
+        }
+        MtpOperationCode operation = mRequest.getOperationCode();
+        MtpTransactionID transaction = mRequest.getTransactionID();
+
+        ALOGD("operation: %s", MtpDebug::getOperationCodeName(operation));
+
+        // FIXME need to generalize this
+        bool dataIn = (operation == MTP_OPERATION_SEND_OBJECT_INFO
+                    || operation == MTP_OPERATION_SET_OBJECT_REFERENCES
+                    || operation == MTP_OPERATION_SET_OBJECT_PROP_VALUE
+                    || operation == MTP_OPERATION_SET_DEVICE_PROP_VALUE);
+        if (dataIn) {
+            int ret = mData.read(fd);
+            if (ret < 0) {
+                ALOGE("data read returned %d, errno: %d", ret, errno);
+                if (errno == ECANCELED) {
+                    // return to top of loop and wait for next command
+                    continue;
+                }
+                break;
+            }
+            ALOGV("received data:");
+        } else {
+            mData.reset();
+        }
+
+        if (handleRequest()) {
+            if (!dataIn && mData.hasData()) {
+                mData.setOperationCode(operation);
+                mData.setTransactionID(transaction);
+                ALOGV("sending data:");
+                ret = mData.write(fd);
+                if (ret < 0) {
+                    ALOGE("request write returned %d, errno: %d", ret, errno);
+                    if (errno == ECANCELED) {
+                        // return to top of loop and wait for next command
+                        continue;
+                    }
+                    break;
+                }
+            }
+
+            mResponse.setTransactionID(transaction);
+            ALOGD("sending response %04X", mResponse.getResponseCode());
+            ret = mResponse.write(fd);
+            const int savedErrno = errno;
+            if (ret < 0) {
+                ALOGE("request write returned %d, errno: %d", ret, errno);
+                if (savedErrno == ECANCELED) {
+                    // return to top of loop and wait for next command
+                    continue;
+                }
+                break;
+            }
+        } else {
+            ALOGD("skipping response\n");
+        }
+    }
+
+    // commit any open edits
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        commitEdit(edit);
+        delete edit;
+    }
+    mObjectEditList.clear();
+
+    if (mSessionOpen)
+        mDatabase->sessionEnded();
+    close(fd);
+    mFD = -1;
+}
+
+void MtpServer::sendObjectAdded(MtpObjectHandle handle) {
+    ALOGV("sendObjectAdded %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_ADDED, handle);
+}
+
+void MtpServer::sendObjectRemoved(MtpObjectHandle handle) {
+    ALOGV("sendObjectRemoved %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_REMOVED, handle);
+}
+
+void MtpServer::sendStoreAdded(MtpStorageID id) {
+    ALOGV("sendStoreAdded %08X\n", id);
+    sendEvent(MTP_EVENT_STORE_ADDED, id);
+}
+
+void MtpServer::sendStoreRemoved(MtpStorageID id) {
+    ALOGV("sendStoreRemoved %08X\n", id);
+    sendEvent(MTP_EVENT_STORE_REMOVED, id);
+}
+
+void MtpServer::sendDevicePropertyChanged(MtpDeviceProperty property) {
+    ALOGV("sendDevicePropertyChanged %d\n", property);
+    sendEvent(MTP_EVENT_DEVICE_PROP_CHANGED, property);
+}
+
+void MtpServer::sendEvent(MtpEventCode code, uint32_t param1) {
+    if (mSessionOpen) {
+        mEvent.setEventCode(code);
+        mEvent.setTransactionID(mRequest.getTransactionID());
+        mEvent.setParameter(1, param1);
+        int ret = mEvent.write(mFD);
+        ALOGV("mEvent.write returned %d\n", ret);
+    }
+}
+
+void MtpServer::sendObjectInfoChanged(MtpObjectHandle handle) {
+    ALOGV("sendObjectInfoChanged handle = %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_INFO_CHANGED, handle);
+}
+void MtpServer::sendStorageInfoChanged(MtpStorageID id) {
+    ALOGV("sendStorageInfoChanged id = %d\n", id);
+    sendEvent(MTP_EVENT_STORAGE_INFO_CHANGED, id);
+}
+
+void MtpServer::addEditObject(MtpObjectHandle handle, MtpString& path,
+        uint64_t size, MtpObjectFormat format, int fd) {
+    ObjectEdit*  edit = new ObjectEdit(handle, path, size, format, fd);
+    mObjectEditList.add(edit);
+}
+
+MtpServer::ObjectEdit* MtpServer::getEditObject(MtpObjectHandle handle) {
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        if (edit->mHandle == handle) return edit;
+    }
+    return NULL;
+}
+
+void MtpServer::removeEditObject(MtpObjectHandle handle) {
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        if (edit->mHandle == handle) {
+            delete edit;
+            mObjectEditList.removeAt(i);
+            return;
+        }
+    }
+    ALOGE("ObjectEdit not found in removeEditObject");
+}
+
+void MtpServer::commitEdit(ObjectEdit* edit) {
+    mDatabase->endSendObject((const char *)edit->mPath, edit->mHandle, edit->mFormat, true);
+}
+
+
+bool MtpServer::handleRequest() {
+    Mutex::Autolock autoLock(mMutex);
+
+    MtpOperationCode operation = mRequest.getOperationCode();
+    MtpResponseCode response;
+
+    mResponse.reset();
+
+    if (mSendObjectHandle != kInvalidObjectHandle && operation != MTP_OPERATION_SEND_OBJECT) {
+        // FIXME - need to delete mSendObjectHandle from the database
+        ALOGE("expected SendObject after SendObjectInfo");
+        mDatabase->endSendObject(mSendObjectFilePath, mSendObjectHandle, mSendObjectFormat, 0);
+        mSendObjectHandle = kInvalidObjectHandle;
+    }
+
+    int containertype = mRequest.getContainerType();
+    if (containertype != MTP_CONTAINER_TYPE_COMMAND) {
+        ALOGE("wrong container type %d", containertype);
+        return false;
+    }
+
+    ALOGV("got command %s (%x)", MtpDebug::getOperationCodeName(operation), operation);
+
+    switch (operation) {
+        case MTP_OPERATION_GET_DEVICE_INFO:
+            response = doGetDeviceInfo();
+            break;
+        case MTP_OPERATION_OPEN_SESSION:
+            response = doOpenSession();
+            break;
+        case MTP_OPERATION_CLOSE_SESSION:
+            response = doCloseSession();
+            break;
+        case MTP_OPERATION_GET_STORAGE_IDS:
+            response = doGetStorageIDs();
+            break;
+         case MTP_OPERATION_GET_STORAGE_INFO:
+            response = doGetStorageInfo();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROPS_SUPPORTED:
+            response = doGetObjectPropsSupported();
+            break;
+        case MTP_OPERATION_GET_OBJECT_HANDLES:
+            response = doGetObjectHandles();
+            break;
+        case MTP_OPERATION_GET_NUM_OBJECTS:
+            response = doGetNumObjects();
+            break;
+        case MTP_OPERATION_GET_OBJECT_REFERENCES:
+            response = doGetObjectReferences();
+            break;
+        case MTP_OPERATION_SET_OBJECT_REFERENCES:
+            response = doSetObjectReferences();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_VALUE:
+            response = doGetObjectPropValue();
+            break;
+        case MTP_OPERATION_SET_OBJECT_PROP_VALUE:
+            response = doSetObjectPropValue();
+            break;
+        case MTP_OPERATION_GET_DEVICE_PROP_VALUE:
+            response = doGetDevicePropValue();
+            break;
+        case MTP_OPERATION_SET_DEVICE_PROP_VALUE:
+            response = doSetDevicePropValue();
+            break;
+        case MTP_OPERATION_RESET_DEVICE_PROP_VALUE:
+            response = doResetDevicePropValue();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_LIST:
+            response = doGetObjectPropList();
+            break;
+        case MTP_OPERATION_GET_OBJECT_INFO:
+            response = doGetObjectInfo();
+            break;
+        case MTP_OPERATION_GET_OBJECT:
+            response = doGetObject();
+            break;
+        case MTP_OPERATION_GET_THUMB:
+            response = doGetThumb();
+            break;
+        case MTP_OPERATION_GET_PARTIAL_OBJECT:
+        case MTP_OPERATION_GET_PARTIAL_OBJECT_64:
+            response = doGetPartialObject(operation);
+            break;
+        case MTP_OPERATION_SEND_OBJECT_INFO:
+            response = doSendObjectInfo();
+            break;
+        case MTP_OPERATION_SEND_OBJECT:
+            response = doSendObject();
+            break;
+        case MTP_OPERATION_DELETE_OBJECT:
+            response = doDeleteObject();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_DESC:
+            response = doGetObjectPropDesc();
+            break;
+        case MTP_OPERATION_GET_DEVICE_PROP_DESC:
+            response = doGetDevicePropDesc();
+            break;
+        case MTP_OPERATION_SEND_PARTIAL_OBJECT:
+            response = doSendPartialObject();
+            break;
+        case MTP_OPERATION_TRUNCATE_OBJECT:
+            response = doTruncateObject();
+            break;
+        case MTP_OPERATION_BEGIN_EDIT_OBJECT:
+            response = doBeginEditObject();
+            break;
+        case MTP_OPERATION_END_EDIT_OBJECT:
+            response = doEndEditObject();
+            break;
+        default:
+            ALOGE("got unsupported command %s (%x)",
+                    MtpDebug::getOperationCodeName(operation), operation);
+            response = MTP_RESPONSE_OPERATION_NOT_SUPPORTED;
+            break;
+    }
+
+    if (response == MTP_RESPONSE_TRANSACTION_CANCELLED)
+        return false;
+    mResponse.setResponseCode(response);
+    return true;
+}
+
+MtpResponseCode MtpServer::doGetDeviceInfo() {
+    MtpStringBuffer   string;
+    char prop_value[PROPERTY_VALUE_MAX];
+
+    MtpObjectFormatList* playbackFormats = mDatabase->getSupportedPlaybackFormats();
+    MtpObjectFormatList* captureFormats = mDatabase->getSupportedCaptureFormats();
+    MtpDevicePropertyList* deviceProperties = mDatabase->getSupportedDeviceProperties();
+
+    // fill in device info
+    mData.putUInt16(MTP_STANDARD_VERSION);
+    if (mPtp) {
+        mData.putUInt32(0);
+    } else {
+        // MTP Vendor Extension ID
+        mData.putUInt32(6);
+    }
+    mData.putUInt16(MTP_STANDARD_VERSION);
+    if (mPtp) {
+        // no extensions
+        string.set("");
+    } else {
+        // MTP extensions
+        string.set("microsoft.com: 1.0; android.com: 1.0;");
+    }
+    mData.putString(string); // MTP Extensions
+    mData.putUInt16(0); //Functional Mode
+    mData.putAUInt16(kSupportedOperationCodes,
+            sizeof(kSupportedOperationCodes) / sizeof(uint16_t)); // Operations Supported
+    mData.putAUInt16(kSupportedEventCodes,
+            sizeof(kSupportedEventCodes) / sizeof(uint16_t)); // Events Supported
+    mData.putAUInt16(deviceProperties); // Device Properties Supported
+    mData.putAUInt16(captureFormats); // Capture Formats
+    mData.putAUInt16(playbackFormats);  // Playback Formats
+
+    property_get("ro.product.manufacturer", prop_value, "unknown manufacturer");
+    string.set("3Prism XX");
+    mData.putString(string);   // Manufacturer
+
+    property_get("ro.product.model", prop_value, "MTP Device");
+    //string.set(prop_value);
+	string.set("3Prism XX");
+    mData.putString(string);   // Model
+    string.set("1.0");
+    mData.putString(string);   // Device Version
+
+    property_get("ro.serialno", prop_value, "????????");
+    string.set(prop_value);
+    mData.putString(string);   // Serial Number
+
+    delete playbackFormats;
+    delete captureFormats;
+    delete deviceProperties;
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doOpenSession() {
+    if (mSessionOpen) {
+        mResponse.setParameter(1, mSessionID);
+        return MTP_RESPONSE_SESSION_ALREADY_OPEN;
+    }
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    mSessionID = mRequest.getParameter(1);
+    mSessionOpen = true;
+
+    mDatabase->sessionStarted();
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doCloseSession() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    mSessionID = 0;
+    mSessionOpen = false;
+    mDatabase->sessionEnded();
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetStorageIDs() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+
+    int count = mStorages.size();
+
+    ALOGD("doGetStorageIDs: mStorageCount = %d", count);
+
+    mData.putUInt32(count);
+    for (int i = 0; i < count; i++)
+        mData.putUInt32(mStorages[i]->getStorageID());
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetStorageInfo() {
+    MtpStringBuffer   string;
+
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    MtpStorageID id = mRequest.getParameter(1);
+    MtpStorage* storage = getStorage(id);
+    if (!storage)
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    mData.putUInt16(storage->getType());
+    mData.putUInt16(storage->getFileSystemType());
+    mData.putUInt16(storage->getAccessCapability());
+    mData.putUInt64(storage->getMaxCapacity());
+    mData.putUInt64(storage->getFreeSpace());
+    mData.putUInt32(1024*1024*1024); // Free Space in Objects
+    string.set(storage->getDescription());
+    mData.putString(string);
+    mData.putEmptyString();   // Volume Identifier
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropsSupported() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectFormat format = mRequest.getParameter(1);
+    MtpObjectPropertyList* properties = mDatabase->getSupportedObjectProperties(format);
+    mData.putAUInt16(properties);
+    delete properties;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetObjectHandles() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);      // 0xFFFFFFFF for all storage
+    MtpObjectFormat format = mRequest.getParameter(2);      // 0 for all formats
+    MtpObjectHandle parent = mRequest.getParameter(3);      // 0xFFFFFFFF for objects with no parent
+                                                            // 0x00000000 for all objects
+
+    ALOGD("doGetObjectHandles: storageID = 0x%x, format = 0x%x, parent = 0x%x",
+        storageID, format, parent);
+
+
+    if (!hasStorage(storageID))
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    MtpObjectHandleList* handles = mDatabase->getObjectList(storageID, format, parent);
+    mData.putAUInt32(handles);
+    delete handles;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetNumObjects() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);      // 0xFFFFFFFF for all storage
+    MtpObjectFormat format = mRequest.getParameter(2);      // 0 for all formats
+    MtpObjectHandle parent = mRequest.getParameter(3);      // 0xFFFFFFFF for objects with no parent
+                                                            // 0x00000000 for all objects
+
+    ALOGD("doGetNumObjects: storageID = 0x%x, format = 0x%x, parent = 0x%x \n",
+        storageID, format, parent);
+
+    if (!hasStorage(storageID))
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    int count = mDatabase->getNumObjects(storageID, format, parent);
+    if (count >= 0) {
+        mResponse.setParameter(1, count);
+        return MTP_RESPONSE_OK;
+    } else {
+        mResponse.setParameter(1, 0);
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    }
+}
+
+MtpResponseCode MtpServer::doGetObjectReferences() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObjectReferences: handle = 0x%x \n",handle);
+
+    // FIXME - check for invalid object handle
+    MtpObjectHandleList* handles = mDatabase->getObjectReferences(handle);
+    if (handles) {
+        mData.putAUInt32(handles);
+        delete handles;
+    } else {
+        mData.putEmptyArray();
+    }
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSetObjectReferences() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID handle = mRequest.getParameter(1);
+
+    MtpObjectHandleList* references = mData.getAUInt32();
+    if (!references)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    ALOGD("doSetObjectReferences: handle = 0x%x \n", handle);
+
+    MtpResponseCode result = mDatabase->setObjectReferences(handle, references);
+    delete references;
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropValue() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectProperty property = mRequest.getParameter(2);
+    ALOGD("GetObjectPropValue %d %s\n", handle,
+            MtpDebug::getObjectPropCodeName(property));
+
+    return mDatabase->getObjectPropertyValue(handle, property, mData);
+}
+
+MtpResponseCode MtpServer::doSetObjectPropValue() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectProperty property = mRequest.getParameter(2);
+    ALOGD("SetObjectPropValue %d %s\n", handle,
+            MtpDebug::getObjectPropCodeName(property));
+
+    return mDatabase->setObjectPropertyValue(handle, property, mData);
+}
+
+MtpResponseCode MtpServer::doGetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("GetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->getDevicePropertyValue(property, mData);
+}
+
+MtpResponseCode MtpServer::doSetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("SetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->setDevicePropertyValue(property, mData);
+}
+
+MtpResponseCode MtpServer::doResetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("ResetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->resetDeviceProperty(property);
+}
+
+MtpResponseCode MtpServer::doGetObjectPropList() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 5)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    // use uint32_t so we can support 0xFFFFFFFF
+    uint32_t format = mRequest.getParameter(2);
+    uint32_t property = mRequest.getParameter(3);
+    int groupCode = mRequest.getParameter(4);
+    int depth = mRequest.getParameter(5);
+   ALOGD("GetObjectPropList %d format: %s property: %s group: %d depth: %d\n",
+            handle, MtpDebug::getFormatCodeName(format),
+            MtpDebug::getObjectPropCodeName(property), groupCode, depth);
+
+    return mDatabase->getObjectPropertyList(handle, format, property, groupCode, depth, mData);
+}
+
+MtpResponseCode MtpServer::doGetObjectInfo() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObjectInfo handle = 0x%x \n", handle);
+
+    MtpObjectInfo info(handle);
+    MtpResponseCode result = mDatabase->getObjectInfo(handle, info);
+    if (result == MTP_RESPONSE_OK) {
+        char    date[20];
+
+        mData.putUInt32(info.mStorageID);
+        mData.putUInt16(info.mFormat);
+        mData.putUInt16(info.mProtectionStatus);
+
+        // if object is being edited the database size may be out of date
+        uint32_t size = info.mCompressedSize;
+        ObjectEdit* edit = getEditObject(handle);
+        if (edit)
+            size = (edit->mSize > 0xFFFFFFFFLL ? 0xFFFFFFFF : (uint32_t)edit->mSize);
+        mData.putUInt32(size);
+
+        ALOGD("doGetObjectInfo edit = %p, size=%d \n", edit, size);
+        if (info.mName)
+            ALOGD("doGetObjectInfo info.mName = %s \n", info.mName);
+
+        mData.putUInt16(info.mThumbFormat);
+        mData.putUInt32(info.mThumbCompressedSize);
+        mData.putUInt32(info.mThumbPixWidth);
+        mData.putUInt32(info.mThumbPixHeight);
+        mData.putUInt32(info.mImagePixWidth);
+        mData.putUInt32(info.mImagePixHeight);
+        mData.putUInt32(info.mImagePixDepth);
+        mData.putUInt32(info.mParent);
+        mData.putUInt16(info.mAssociationType);
+        mData.putUInt32(info.mAssociationDesc);
+        mData.putUInt32(info.mSequenceNumber);
+        mData.putString(info.mName);
+        formatDateTime(info.mDateCreated, date, sizeof(date));
+        mData.putString(date);   // date created
+        formatDateTime(info.mDateModified, date, sizeof(date));
+        mData.putString(date);   // date modified
+        mData.putEmptyString();   // keywords
+    }
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObject handle = 0x%x \n", handle);
+
+    MtpString pathBuf;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, pathBuf, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+
+    const char* filePath = (const char *)pathBuf;
+    mtp_file_range  mfr;
+    mfr.fd = open(filePath, O_RDONLY);
+    if (mfr.fd < 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+    mfr.offset = 0;
+    mfr.length = fileLength;
+    mfr.command = mRequest.getOperationCode();
+    mfr.transaction_id = mRequest.getTransactionID();
+
+    ALOGD("doGetObject filePath = %s \n", (const char *)filePath);
+    ALOGD("mfr.length = %" PRIu64 "\n", mfr.length);
+    ALOGD("mfr.transaction_id = %d \n", mfr.transaction_id);
+
+    // then transfer the file
+    int ret = ioctl(mFD, MTP_SEND_FILE_WITH_HEADER, (unsigned long)&mfr);
+    close(mfr.fd);
+    if (ret < 0) {
+        ALOGE("read file error: errno = 0x%x \n", errno);
+        if (errno == ECANCELED)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    } else {
+        result = MTP_RESPONSE_OK;
+    }
+    ALOGV("MTP_SEND_FILE_WITH_HEADER returned %d\n", result);
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetThumb() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetThumb Handle 0x%x\n", handle);
+
+    size_t thumbSize;
+    void* thumb = mDatabase->getThumbnail(handle, thumbSize);
+    if (thumb) {
+        // send data
+        mData.setOperationCode(mRequest.getOperationCode());
+        mData.setTransactionID(mRequest.getTransactionID());
+        mData.writeData(mFD, thumb, thumbSize);
+        free(thumb);
+        return MTP_RESPONSE_OK;
+    } else {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+}
+
+MtpResponseCode MtpServer::doGetPartialObject(MtpOperationCode operation) {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    uint64_t offset;
+    uint32_t length;
+    offset = mRequest.getParameter(2);
+    if (operation == MTP_OPERATION_GET_PARTIAL_OBJECT_64) {
+        // MTP_OPERATION_GET_PARTIAL_OBJECT_64 takes 4 arguments
+        if (mRequest.getParameterCount() < 4)
+            return MTP_RESPONSE_INVALID_PARAMETER;
+
+        // android extension with 64 bit offset
+        uint64_t offset2 = mRequest.getParameter(3);
+        offset = offset | (offset2 << 32);
+        length = mRequest.getParameter(4);
+    } else {
+        // MTP_OPERATION_GET_PARTIAL_OBJECT takes 3 arguments
+        if (mRequest.getParameterCount() < 3)
+            return MTP_RESPONSE_INVALID_PARAMETER;
+
+        // standard GetPartialObject
+        length = mRequest.getParameter(3);
+    }
+    MtpString pathBuf;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, pathBuf, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+    if (offset + length > (uint64_t)fileLength)
+        length = fileLength - offset;
+
+    const char* filePath = (const char *)pathBuf;
+    mtp_file_range  mfr;
+    mfr.fd = open(filePath, O_RDONLY);
+    if (mfr.fd < 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+    mfr.offset = offset;
+    mfr.length = length;
+    mfr.command = mRequest.getOperationCode();
+    mfr.transaction_id = mRequest.getTransactionID();
+    mResponse.setParameter(1, length);
+
+    // transfer the file
+    int ret = ioctl(mFD, MTP_SEND_FILE_WITH_HEADER, (unsigned long)&mfr);
+    ALOGV("MTP_SEND_FILE_WITH_HEADER returned %d\n", ret);
+    result = MTP_RESPONSE_OK;
+    if (ret < 0) {
+        if (errno == ECANCELED)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    }
+    close(mfr.fd);
+    return result;
+}
+
+MtpResponseCode MtpServer::doSendObjectInfo() {
+    MtpString path;
+    uint16_t temp16;
+    uint32_t temp32;
+
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);
+    MtpStorage* storage = getStorage(storageID);
+    MtpObjectHandle parent = mRequest.getParameter(2);
+    if (!storage)
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    ALOGD("storageID: %08X, parent: 0x%x", storageID, parent );
+    // special case the root
+    if (parent == MTP_PARENT_ROOT) {
+        path = storage->getPath();
+        parent = 0;
+    } else {
+        int64_t length;
+        MtpObjectFormat format;
+        int result = mDatabase->getObjectFilePath(parent, path, length, format);
+        if (result != MTP_RESPONSE_OK)
+            return result;
+        if (format != MTP_FORMAT_ASSOCIATION)
+            return MTP_RESPONSE_INVALID_PARENT_OBJECT;
+    }
+
+    // read only the fields we need
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // storage ID
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectFormat format = temp16;
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;  // protection status
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;
+    mSendObjectFileSize = temp32;
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb format
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb compressed size
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb pix width
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb pix height
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image pix width
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image pix height
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image bit depth
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // parent
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // sequence number
+    MtpStringBuffer name, created, modified;
+    if (!mData.getString(name)) return MTP_RESPONSE_INVALID_PARAMETER;    // file name
+    if (name.getCharCount() == 0) {
+        ALOGE("empty name");
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    }
+    if (!mData.getString(created)) return MTP_RESPONSE_INVALID_PARAMETER;      // date created
+    if (!mData.getString(modified)) return MTP_RESPONSE_INVALID_PARAMETER;     // date modified
+    // keywords follow
+
+    ALOGV("name: %s format: %04X\n", (const char *)name, format);
+    time_t modifiedTime;
+    if (!parseDateTime(modified, modifiedTime))
+        modifiedTime = 0;
+
+    if (path[path.size() - 1] != '/')
+        path += "/";
+    path += (const char *)name;
+
+    // check space first
+    if (mSendObjectFileSize > storage->getFreeSpace())
+        return MTP_RESPONSE_STORAGE_FULL;
+    uint64_t maxFileSize = storage->getMaxFileSize();
+    // check storage max file size
+    ALOGD("name: %s , mSendObjectFileSize = %zd, maxSize: %" PRIu64 "\n",
+        (const char *)name, mSendObjectFileSize, maxFileSize);
+
+    if (maxFileSize != 0) {
+        // if mSendObjectFileSize is 0xFFFFFFFF, then all we know is the file size
+        // is >= 0xFFFFFFFF
+        if (mSendObjectFileSize > maxFileSize || mSendObjectFileSize == 0xFFFFFFFF)
+            return MTP_RESPONSE_OBJECT_TOO_LARGE;
+    }
+
+    ALOGD("path: %s parent: %d storageID: %08X", (const char*)path, parent, storageID);
+    MtpObjectHandle handle = mDatabase->beginSendObject((const char*)path,
+            format, parent, storageID, mSendObjectFileSize, modifiedTime);
+    if (handle == kInvalidObjectHandle) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+  if (format == MTP_FORMAT_ASSOCIATION) {
+        struct stat statbuf;
+        mode_t mask = umask(0);
+        int ret = mkdir((const char *)path, mDirectoryPermission);
+        umask(mask);
+        if (ret && stat((const char *)path, &statbuf) != 0) {
+            ALOGE("mkdir %s failed: %d", (const char *)path, ret);
+            return MTP_RESPONSE_GENERAL_ERROR;
+        }
+        chown((const char *)path, getuid(), mFileGroup);
+
+        // SendObject does not get sent for directories, so call endSendObject here instead
+        mDatabase->endSendObject(path, handle, MTP_FORMAT_ASSOCIATION, MTP_RESPONSE_OK);
+    } else {
+        mSendObjectFilePath = path;
+        // save the handle for the SendObject call, which should follow
+        mSendObjectHandle = handle;
+        mSendObjectFormat = format;
+    }
+
+    mResponse.setParameter(1, storageID);
+    mResponse.setParameter(2, parent);
+    mResponse.setParameter(3, handle);
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSendObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_GENERAL_ERROR;
+    MtpResponseCode result = MTP_RESPONSE_OK;
+    mode_t mask;
+    int ret, initialData;
+    bool isCanceled = false;
+
+    if (mSendObjectHandle == kInvalidObjectHandle) {
+        ALOGE("Expected SendObjectInfo before SendObject");
+        result = MTP_RESPONSE_NO_VALID_OBJECT_INFO;
+        goto done;
+    }
+
+    // read the header, and possibly some data
+    ret = mData.read(mFD);
+    if (ret < MTP_CONTAINER_HEADER_SIZE) {
+        result = MTP_RESPONSE_GENERAL_ERROR;
+        goto done;
+    }
+    initialData = ret - MTP_CONTAINER_HEADER_SIZE;
+
+    mtp_file_range  mfr;
+    mfr.fd = open(mSendObjectFilePath, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+    if (mfr.fd < 0) {
+        ALOGE("mfr.fd %d < 0", mfr.fd);
+        result = MTP_RESPONSE_GENERAL_ERROR;
+        goto done;
+    }
+        fchown(mfr.fd, getuid(), mFileGroup);
+        // set permissions
+        mask = umask(0);
+        fchmod(mfr.fd, mFilePermission);
+        umask(mask);
+
+        if (initialData > 0) {
+            ret = write(mfr.fd, mData.getData(), initialData);
+        }
+
+        if (ret < 0) {
+            ALOGE("failed to write initial data");
+            result = MTP_RESPONSE_GENERAL_ERROR;
+        } else {
+            if (mSendObjectFileSize - initialData > 0) {
+                mfr.offset = initialData;
+                if (mSendObjectFileSize == 0xFFFFFFFF) {
+                    // tell driver to read until it receives a short packet
+                    mfr.length = 0xFFFFFFFF;
+                } else {
+                    mfr.length = mSendObjectFileSize - initialData;
+                }
+
+            ALOGV("receiving %s\n", (const char *)mSendObjectFilePath);
+            // transfer the file
+            ret = ioctl(mFD, MTP_RECEIVE_FILE, (unsigned long)&mfr);
+            if ((ret < 0) && (errno == ECANCELED)) {
+                isCanceled = true;
+            }
+
+            ALOGV("MTP_RECEIVE_FILE returned %d\n", ret);
+            }
+        }
+        close(mfr.fd);
+
+    if (ret < 0) {
+        unlink(mSendObjectFilePath);
+        if (isCanceled)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+done:
+    // reset so we don't attempt to send the data back
+    mData.reset();
+
+    mDatabase->endSendObject(mSendObjectFilePath, mSendObjectHandle, mSendObjectFormat,
+            result == MTP_RESPONSE_OK);
+    mSendObjectHandle = kInvalidObjectHandle;
+    mSendObjectFormat = 0;
+    return result;
+}
+
+static void deleteRecursive(const char* path) {
+    char pathbuf[PATH_MAX];
+    size_t pathLength = strlen(path);
+    if (pathLength >= sizeof(pathbuf) - 1) {
+        ALOGE("path too long: %s\n", path);
+    }
+    strcpy(pathbuf, path);
+    if (pathbuf[pathLength - 1] != '/') {
+        pathbuf[pathLength++] = '/';
+    }
+    char* fileSpot = pathbuf + pathLength;
+    int pathRemaining = sizeof(pathbuf) - pathLength - 1;
+
+    DIR* dir = opendir(path);
+    if (!dir) {
+        ALOGE("opendir %s failed: %s", path, strerror(errno));
+        return;
+    }
+
+    struct dirent* entry;
+    while ((entry = readdir(dir))) {
+        const char* name = entry->d_name;
+
+        // ignore "." and ".."
+        if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {
+            continue;
+        }
+
+        int nameLength = strlen(name);
+        if (nameLength > pathRemaining) {
+            ALOGE("path %s/%s too long\n", path, name);
+            continue;
+        }
+        strcpy(fileSpot, name);
+
+        if (entry->d_type == DT_DIR) {
+            deleteRecursive(pathbuf);
+            rmdir(pathbuf);
+        } else {
+            unlink(pathbuf);
+        }
+    }
+    closedir(dir);
+}
+
+static void deletePath(const char* path) {
+    struct stat statbuf;
+    if (stat(path, &statbuf) == 0) {
+        if (S_ISDIR(statbuf.st_mode)) {
+            deleteRecursive(path);
+            rmdir(path);
+        } else {
+            unlink(path);
+        }
+    } else {
+        ALOGE("deletePath stat failed for %s: %s", path, strerror(errno));
+    }
+}
+
+MtpResponseCode MtpServer::doDeleteObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectFormat format;
+    // FIXME - support deleting all objects if handle is 0xFFFFFFFF
+    // FIXME - implement deleting objects by format
+
+    MtpString filePath;
+    int64_t fileLength;
+    int result = mDatabase->getObjectFilePath(handle, filePath, fileLength, format);
+    if (result == MTP_RESPONSE_OK) {
+        ALOGD("deleting %s", (const char *)filePath);
+        result = mDatabase->deleteFile(handle);
+        // Don't delete the actual files unless the database deletion is allowed
+        if (result == MTP_RESPONSE_OK) {
+            deletePath((const char *)filePath);
+        }
+    }
+
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropDesc() {
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectProperty propCode = mRequest.getParameter(1);
+    MtpObjectFormat format = mRequest.getParameter(2);
+    ALOGD("GetObjectPropDesc %s %s\n", MtpDebug::getObjectPropCodeName(propCode),
+                                        MtpDebug::getFormatCodeName(format));
+    MtpProperty* property = mDatabase->getObjectPropertyDesc(propCode, format);
+    if (!property)
+        return MTP_RESPONSE_OBJECT_PROP_NOT_SUPPORTED;
+    property->write(mData);
+    delete property;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetDevicePropDesc() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty propCode = mRequest.getParameter(1);
+    ALOGD("GetDevicePropDesc %s\n", MtpDebug::getDevicePropCodeName(propCode));
+    MtpProperty* property = mDatabase->getDevicePropertyDesc(propCode);
+    if (!property)
+        return MTP_RESPONSE_DEVICE_PROP_NOT_SUPPORTED;
+    property->write(mData);
+    delete property;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSendPartialObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 4)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    uint64_t offset = mRequest.getParameter(2);
+    uint64_t offset2 = mRequest.getParameter(3);
+    offset = offset | (offset2 << 32);
+    uint32_t length = mRequest.getParameter(4);
+
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doSendPartialObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    // can't start writing past the end of the file
+    if (offset > edit->mSize) {
+        ALOGD("writing past end of object, offset: %" PRIu64 ", edit->mSize: %" PRIu64,
+            offset, edit->mSize);
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    const char* filePath = (const char *)edit->mPath;
+    ALOGV("receiving partial %s %" PRIu64 " %" PRIu32, filePath, offset, length);
+
+    // read the header, and possibly some data
+    int ret = mData.read(mFD);
+    if (ret < MTP_CONTAINER_HEADER_SIZE)
+        return MTP_RESPONSE_GENERAL_ERROR;
+    int initialData = ret - MTP_CONTAINER_HEADER_SIZE;
+
+    if (initialData > 0) {
+        ret = pwrite(edit->mFD, mData.getData(), initialData, offset);
+        offset += initialData;
+        length -= initialData;
+    }
+
+    bool isCanceled = false;
+    if (ret < 0) {
+        ALOGE("failed to write initial data");
+    } else {
+        if (length > 0) {
+            mtp_file_range  mfr;
+            mfr.fd = edit->mFD;
+            mfr.offset = offset;
+            mfr.length = length;
+
+            // transfer the file
+            ret = ioctl(mFD, MTP_RECEIVE_FILE, (unsigned long)&mfr);
+            if ((ret < 0) && (errno == ECANCELED)) {
+                isCanceled = true;
+            }
+            ALOGV("MTP_RECEIVE_FILE returned %d", ret);
+        }
+    }
+    if (ret < 0) {
+        mResponse.setParameter(1, 0);
+        ALOGE("MTP_RECEIVE_FILE, ret=%d, errno = %d\n", ret, errno);
+        if (isCanceled)
+            return MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    // reset so we don't attempt to send this back
+    mData.reset();
+    mResponse.setParameter(1, length);
+    uint64_t end = offset + length;
+    if (end > edit->mSize) {
+        edit->mSize = end;
+    }
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doTruncateObject() {
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doTruncateObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    uint64_t offset = mRequest.getParameter(2);
+    uint64_t offset2 = mRequest.getParameter(3);
+    offset |= (offset2 << 32);
+    if (ftruncate(edit->mFD, offset) != 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    } else {
+        edit->mSize = offset;
+        return MTP_RESPONSE_OK;
+    }
+}
+
+MtpResponseCode MtpServer::doBeginEditObject() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    if (getEditObject(handle)) {
+        ALOGE("object already open for edit in doBeginEditObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    MtpString path;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, path, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+
+    int fd = open((const char *)path, O_RDWR | O_EXCL);
+    if (fd < 0) {
+        ALOGE("open failed for %s in doBeginEditObject (%d)", (const char *)path, errno);
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    addEditObject(handle, path, fileLength, format, fd);
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doEndEditObject() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doEndEditObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    commitEdit(edit);
+    removeEditObject(handle);
+    return MTP_RESPONSE_OK;
+}
+
+}  // namespace android

Property changes on: vendor/branch/5058Y_ALIE/frameworks/av/media/mtp/MtpServer.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/frameworks/base/core/res/res/values/strings.xml
===================================================================
--- vendor/branch/5058Y_ALIE/frameworks/base/core/res/res/values/strings.xml	(revision 0)
+++ vendor/branch/5058Y_ALIE/frameworks/base/core/res/res/values/strings.xml	(revision 12585)
@@ -0,0 +1,4206 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Suffix added to a number to signify size in bytes. -->
+    <string name="byteShort">B</string>
+    <!-- Suffix added to a number to signify size in kilobytes. -->
+    <string name="kilobyteShort">KB</string>
+    <!-- Suffix added to a number to signify size in megabytes. -->
+    <string name="megabyteShort">MB</string>
+    <!-- Suffix added to a number to signify size in gigabytes. -->
+    <string name="gigabyteShort">GB</string>
+    <!-- Suffix added to a number to signify size in terabytes. -->
+    <string name="terabyteShort">TB</string>
+    <!-- Suffix added to a number to signify size in petabytes. -->
+    <string name="petabyteShort">PB</string>
+    <!-- Format string used to add a suffix like "KB" or "MB" to a number
+         to display a size in kilobytes, megabytes, or other size units.
+         Some languages (like French) will want to add a space between
+         the placeholders. -->
+    <string name="fileSizeSuffix"><xliff:g example="123" id="number">%1$s</xliff:g> <xliff:g example="KB" id="unit">%2$s</xliff:g></string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration in days -->
+    <string name="durationDays"><xliff:g id="days">%1$d</xliff:g> days</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one day with hours -->
+    <string name="durationDayHours"><xliff:g id="days">%1$d</xliff:g> day <xliff:g id="hours">%2$d</xliff:g> hrs</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one day with one hours -->
+    <string name="durationDayHour"><xliff:g id="days">%1$d</xliff:g> day <xliff:g id="hours">%2$d</xliff:g> hr</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration in hours -->
+    <string name="durationHours"><xliff:g id="hours">%1$d</xliff:g> hrs</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one hour with minutes -->
+    <string name="durationHourMinutes"><xliff:g id="hours">%1$d</xliff:g> hr <xliff:g id="minutes">%2$d</xliff:g> mins</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one hour with one minute -->
+    <string name="durationHourMinute"><xliff:g id="hours">%1$d</xliff:g> hr <xliff:g id="minutes">%2$d</xliff:g> min</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration in minutes -->
+    <string name="durationMinutes"><xliff:g id="minutes">%1$d</xliff:g> mins</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one minute -->
+    <string name="durationMinute"><xliff:g id="minutes">%1$d</xliff:g> min</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one minute with seconds -->
+    <string name="durationMinuteSeconds"><xliff:g id="minutes">%1$d</xliff:g> min <xliff:g id="seconds">%2$d</xliff:g> secs</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one minute with one second -->
+    <string name="durationMinuteSecond"><xliff:g id="minutes">%1$d</xliff:g> min <xliff:g id="seconds">%2$d</xliff:g> sec</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration in seconds -->
+    <string name="durationSeconds"><xliff:g id="seconds">%1$d</xliff:g> secs</string>
+
+    <!-- [CHAR_LIMIT=10] Suffix added to signify duration of one second -->
+    <string name="durationSecond"><xliff:g id="seconds">%1$d</xliff:g> sec</string>
+
+    <!-- Used in Contacts for a field that has no label and in Note Pad
+         for a note with no name. -->
+    <string name="untitled">&lt;Untitled&gt;</string>
+
+    <!-- How to display the lack of a phone number -->
+    <string name="emptyPhoneNumber">(No phone number)</string>
+
+    <!-- How to display the lack of a name -->
+    <string name="unknownName">Unknown</string>
+
+    <!-- What the UI should display for "voice mail" unless overridden by the SIM-->
+    <string name="defaultVoiceMailAlphaTag">Voicemail</string>
+
+    <!-- What the UI should display for "Msisdn" unless overridden by the SIM-->
+    <string name="defaultMsisdnAlphaTag">"MSISDN1"</string>
+
+    <!-- For GsmMmiCode.java --> <skip/>
+    <!-- Displayed when the user dialed an MMI code whose function
+         could not be performed. This will be displayed in a toast. -->
+    <string name="mmiError">Connection problem or invalid MMI code.</string>
+    <!-- Displayed when the user dialed an MMI code whose function
+         could not be performed because FDN is enabled. This will be displayed in a toast. -->
+    <string name="mmiFdnError">Operation is restricted to fixed dialing numbers only.</string>
+
+    <!-- Displayed when a phone feature such as call barring was activated. -->
+    <string name="serviceEnabled">Service was enabled.</string>
+    <!-- Displayed in front of the list of a set of service classes
+         (voice, data, fax, etc.) that were enabled. -->
+    <string name="serviceEnabledFor">Service was enabled for:</string>
+    <!-- Displayed when a phone feature such as call forwarding was deactivated. -->
+    <string name="serviceDisabled">Service has been disabled.</string>
+    <!-- Displayed when a phone property such as a SIM password was registered. -->
+    <string name="serviceRegistered">Registration was successful.</string>
+    <string name="serviceRegistered_telcel_21">"For all calls, The registration was successful."</string>
+    <string name="serviceRegistered_telcel_61">"When the line does not respond, the registration has been made correctly."</string>
+    <string name="serviceRegistered_telcel_62">"When the line is not available, the registration has been made correctly."</string>
+    <string name="serviceRegistered_telcel_67">"When the line is busy, the registration has been made correctly."</string>
+    <!-- Displayed when a phone property such as a SIM password was erased. -->
+    <string name="serviceErased">Erasure was successful.</string>
+    <!-- Displayed when a SIM password was entered incorrectly. -->
+    <string name="passwordIncorrect">Incorrect password.</string>
+    <!-- Displayed when a phone feature triggered by an MMI code is complete. -->
+    <string name="mmiComplete">MMI complete.</string>
+    <!-- Displayed when a SIM PIN password is entered incorrectly. -->
+    <string name="badPin">The old PIN you typed isn\'t correct</string>
+    <!-- Displayed when a SIM PUK password is entered incorrectly. -->
+    <string name="badPuk">The PUK you typed isn\'t correct</string>
+    <!-- Displayed when SIM PIN passwords are entered inconsistently. -->
+    <string name="mismatchPin">The PINs you typed don\'t match</string>
+    <!-- Displayed when a SIM PIN password is too long or too short. -->
+    <string name="invalidPin">Type a PIN that is 4\u20118 digits.</string>
+    <!-- Displayed when a SIM PUK password is too short. -->
+    <string name="invalidPuk">Type a PUK that is 8 digits or longer.</string>
+    <!-- Displayed to prompt the user to type the PUK password to unlock
+         the SIM card. -->
+    <string name="needPuk">Your SIM card is PUK\u2011locked. Type the PUK code to unlock it.</string>
+    <string name="needPuk2">Type PUK2 to unblock SIM card.</string>
+    <!-- Displayed when user attempts to change SIM PIN1 without enabling PIN1. -->
+    <string name="enablePin">Unsuccessful, enable SIM/RUIM Lock.</string>
+    <!-- Displayed when a SIM PIN/PUK is entered incorrectly. -->
+    <plurals name="pinpuk_attempts">
+        <item quantity="one">You have <xliff:g id="number">%d</xliff:g> remaining attempt before SIM is locked.</item>
+        <item quantity="other">You have <xliff:g id="number">%d</xliff:g> remaining attempts before SIM is locked.</item>
+    </plurals>
+    <!-- Title for the dialog used to display the user's IMEI number [CHAR LIMIT=10] -->
+    <string name="imei">IMEI</string>
+
+    <!-- Title for the dialog used to display the user's MEID number on CDMA network
+         [CHAR LIMIT=10] -->
+    <string name="meid">MEID</string>
+
+    <!-- Displayed as the title for a success/failure report enabling/disabling caller ID. -->
+    <string name="ClipMmi">Incoming Caller ID</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling caller ID. -->
+    <string name="ClirMmi">Outgoing Caller ID</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling connected line ID. -->
+    <string name="ColpMmi">Connected Line ID</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling connected line ID restriction. -->
+    <string name="ColrMmi">Connected Line ID Restriction</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling call forwarding. -->
+    <string name="CfMmi">Call forwarding</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling call waiting. -->
+    <string name="CwMmi">Call waiting</string>
+    <!-- Displayed as the title for a success/failure report enabling/disabling call barring. -->
+    <string name="BaMmi">Call barring</string>
+    <!-- Displayed as the title for a success/failure report changing the SIM password. -->
+    <string name="PwdMmi">Password change</string>
+    <!-- Displayed as the title for a success/failure report changing the SIM PIN. -->
+    <string name="PinMmi">PIN change</string>
+    <string name="CnipMmi">Calling number present</string>
+    <string name="CnirMmi">Calling number restricted</string>
+    <string name="ThreeWCMmi">Three\u2011party conference</string>
+    <string name="RuacMmi">Rejection of undesired annoying calls</string>
+    <string name="CndMmi">Calling number delivery</string>
+    <string name="DndMmi">Do not disturb</string>
+
+    <!-- Displayed to confirm to the user that caller ID will be restricted on the next call as usual. -->
+    <string name="CLIRDefaultOnNextCallOn">Caller ID defaults to restricted. Next call: Restricted</string>
+    <!-- Displayed to confirm to the user that caller ID will be not restricted on the next call even though it usually is. -->
+    <string name="CLIRDefaultOnNextCallOff">Caller ID defaults to restricted. Next call: Not restricted</string>
+    <!-- Displayed to confirm to the user that caller ID will not be restricted on the next call but usually is. -->
+    <string name="CLIRDefaultOffNextCallOn">Caller ID defaults to not restricted. Next call: Restricted</string>
+    <!-- Displayed to confirm to the user that caller ID will not be restricted on the next call or in general. -->
+    <string name="CLIRDefaultOffNextCallOff">Caller ID defaults to not restricted. Next call: Not restricted</string>
+
+
+    <!-- Displayed to tell the user that caller ID is not provisioned for their SIM. -->
+    <string name="serviceNotProvisioned">Service not provisioned.</string>
+    <!-- Displayed to tell the user that they cannot change the caller ID setting. -->
+    <string name="CLIRPermanent">You can\'t change the caller ID setting</string>
+
+    <!-- Displayed to tell the user that data service is blocked by access control. -->
+    <string name="RestrictedOnData">Data service is blocked.</string>
+    <!-- Displayed to tell the user that emergency service is blocked by access control. -->
+    <string name="RestrictedOnEmergency">Emergency service is blocked.</string>
+    <!-- Displayed to tell the user that normal service is blocked by access control. -->
+    <string name="RestrictedOnNormal">Voice service is blocked.</string>
+    <!-- Displayed to tell the user that all emergency and normal voice services are blocked by access control. -->
+    <string name="RestrictedOnAllVoice">All voice services are blocked.</string>
+    <!-- Displayed to tell the user that sms service is blocked by access control. -->
+    <string name="RestrictedOnSms">SMS service is blocked.</string>
+    <!-- Displayed to tell the user that voice/data service is blocked by access control. -->
+    <string name="RestrictedOnVoiceData">Voice/data services are blocked.</string>
+    <!-- Displayed to tell the user that voice and sms service are blocked by access control. -->
+    <string name="RestrictedOnVoiceSms">Voice/SMS services are blocked.</string>
+    <!-- Displayed to tell the user that all service is blocked by access control. -->
+    <string name="RestrictedOnAll">All voice/data/SMS services are blocked.</string>
+
+    <!-- Displayed to tell the user that peer changed TTY mode -->
+    <string name="peerTtyModeFull">Peer requested TTY Mode FULL</string>
+    <string name="peerTtyModeHco">Peer requested TTY Mode HCO</string>
+    <string name="peerTtyModeVco">Peer requested TTY Mode VCO</string>
+    <string name="peerTtyModeOff">Peer requested TTY Mode OFF</string>
+
+    <!-- Mappings between TS 27.007 +CFCC/+CLCK "service classes" and human-readable strings--> <skip/>
+    <!-- Example: Service was enabled for: Voice, Data -->
+    <string name="serviceClassVoice">Voice</string>
+    <!-- Example: Service was enabled for: Voice, Data -->
+    <string name="serviceClassData">Data</string>
+    <!-- Example: Service was enabled for: Voice, FAX -->
+    <string name="serviceClassFAX">Fax</string>
+    <!-- Example: Service was enabled for: Voice, SMS -->
+    <string name="serviceClassSMS">SMS</string>
+    <!-- Meaning: asynchronous data.  Example: Service was enabled for: Voice, Async -->
+    <string name="serviceClassDataAsync">Async</string>
+    <!-- Meaning: synchronous data.  Example: Service was enabled for: Voice, Async -->
+    <string name="serviceClassDataSync">Sync</string>
+    <!-- Meaning: packet data.  Example: Service was enabled for: Voice, Packet -->
+    <string name="serviceClassPacket">Packet</string>
+    <!-- Meaning: unknown.  Example: Service was enabled for: Voice, PAD -->
+    <string name="serviceClassPAD">PAD</string>
+
+    <!-- CDMA Roaming Indicator Strings (non ERI)--> <skip/>
+    <!-- Default roaming indicator text -->
+    <string name="roamingText0">Roaming Indicator On</string>
+    <string name="roamingText1">Roaming Indicator Off</string>
+    <string name="roamingText2">Roaming Indicator Flashing</string>
+    <string name="roamingText3">Out of Neighborhood</string>
+    <string name="roamingText4">Out of Building</string>
+    <string name="roamingText5">Roaming \u2011 Preferred System</string>
+    <string name="roamingText6">Roaming \u2011 Available System</string>
+    <string name="roamingText7">Roaming \u2011 Alliance Partner</string>
+    <string name="roamingText8">Roaming \u2011 Premium Partner</string>
+    <string name="roamingText9">Roaming \u2011 Full Service Functionality</string>
+    <string name="roamingText10">Roaming \u2011 Partial Service Functionality</string>
+    <string name="roamingText11">Roaming Banner On</string>
+    <string name="roamingText12">Roaming Banner Off</string>
+    <string name="roamingTextSearching">Searching for Service</string>
+
+    <!-- Displayed when WFC registration fails -->
+    <string name="wfcRegErrorTitle">Wi\u2011Fi calling</string>
+    <!-- WFC Operator Error Codes -->
+    <string-array name="wfcOperatorErrorCodes" translatable="false">
+        <item>100</item>     <!-- CODE_WFC_DEFAULT -->
+        <item>2006</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_DENY -->
+        <item>2007</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_NONE -->
+        <item>1201</item>    <!-- CODE_WFC_DNS_RECV_NAPTR_QUERY_RSP_ERROR -->
+        <item>1202</item>    <!-- CODE_WFC_DNS_RECV_RSP_SRV_QUERY_ERROR -->
+        <item>1203</item>    <!-- CODE_WFC_DNS_RECV_RSP_QUERY_ERROR -->
+        <item>1041</item>    <!-- CODE_WFC_DNS_RESOLVE_FQDN_ERROR -->
+        <item>1301</item>    <!-- CODE_WFC_INCORRECT_SIM_CARD_ERROR -->
+        <item>1401</item>    <!-- CODE_WFC_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>1081</item>    <!-- CODE_WFC_EPDG_CON_OR_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>1082</item>    <!-- CODE_WFC_EPDG_IPSEC_SETUP_ERROR -->
+        <item>1405</item>    <!-- CODE_WFC_TLS_CONN_ERROR -->
+        <item>1406</item>    <!-- CODE_WFC_INTERNAL_SERVER_ERROR -->
+        <item>1501</item>    <!-- CODE_WFC_SERVER_CERT_VALIDATION_ERROR -->
+        <item>1101</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_VALIDATION_ERROR -->
+        <item>1111</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_INVALID_ERROR -->
+        <item>1504</item>    <!-- CODE_WFC_SERVER_CERT_INVALID_ERROR -->
+        <item>1601</item>    <!-- CODE_WFC_403_UNKNOWN_USER -->
+        <item>1602</item>    <!-- CODE_WFC_403_ROAMING_NOT_ALLOWED -->
+        <item>1603</item>    <!-- CODE_WFC_403_MISMATCH_IDENTITIES -->
+        <item>1604</item>    <!-- CODE_WFC_403_AUTH_SCHEME_UNSUPPORTED -->
+        <item>1605</item>    <!-- CODE_WFC_403_HANDSET_BLACKLISTED -->
+        <item>1701</item>    <!-- CODE_WFC_911_MISSING -->
+        <item>1407</item>    <!-- CODE_WFC_ANY_OTHER_CONN_ERROR -->
+        <item>999</item>     <!-- CODE_UNSPECIFIED -->
+    </string-array>
+
+    <!-- WFC Operator Error Messages showed as alerts -->
+    <string-array name="wfcOperatorErrorAlertMessages">
+        <item>Wi\u2011Fi calling off</item>       <!-- CODE_WFC_DEFAULT -->
+        <item>No mobile network available. Connect to an available Wi\u2011Fi network to make calls.</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_DENY -->
+        <item>String to be decided</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_NONE -->
+        <item>Error02: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_NAPTR_QUERY_RSP_ERROR -->
+        <item>Error03: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_RSP_SRV_QUERY_ERROR -->
+        <item>Error04: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_RSP_QUERY_ERROR -->
+        <item>Error041: DNS Error</item>     <!-- CODE_WFC_DNS_RESOLVE_FQDN_ERROR -->
+        <item>Error05: Invalid SIM card</item>   <!-- CODE_WFC_INCORRECT_SIM_CARD_ERROR -->
+        <item>Error07: Unable to Connect</item>  <!-- CODE_WFC_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>Error081: Unable to connect</item> <!-- CODE_WFC_EPDG_CON_OR_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>Error082: Unable to Connect</item> <!-- CODE_WFC_EPDG_IPSEC_SETUP_ERROR -->
+        <item>Error08: Unable to Connect</item>  <!-- CODE_WFC_TLS_CONN_ERROR -->
+        <item>REG91: Unable to Connect</item>    <!-- CODE_WFC_INTERNAL_SERVER_ERROR -->
+        <item>Error010: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_CERT_VALIDATION_ERROR -->
+        <item>Error101: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_VALIDATION_ERROR -->
+        <item>Error111: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_INVALID_ERROR -->
+        <item>Error011: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_CERT_INVALID_ERROR -->
+        <item>Error403: Unknown user</item>    <!-- CODE_WFC_403_UNKNOWN_USER -->
+        <item>Error403: Roaming not allowed</item>    <!-- CODE_WFC_403_ROAMING_NOT_ALLOWED -->
+        <item>Error403: Mismatch identities</item>    <!-- CODE_WFC_403_MISMATCH_IDENTITIES -->
+        <item>Error403: authentication scheme unsupported</item>    <!-- CODE_WFC_403_AUTH_SCHEME_UNSUPPORTED -->
+        <item>Error403: handset is blacklisted</item>    <!-- CODE_WFC_403_HANDSET_BLACKLISTED -->
+        <item>REG09: Missing 911 Address</item>    <!-- CODE_WFC_911_MISSING -->
+        <item>REG99: Unable to Connect</item>      <!-- CODE_WFC_ANY_OTHER_CONN_ERROR -->
+        <item>REG99: Unable to Connect</item>      <!-- CODE_UNSPECIFIED -->
+    </string-array>
+
+    <!-- WFC Operator Error Messages showed as notifications -->
+    <string-array name="wfcOperatorErrorNotificationMessages">
+        <item>Wi\u2011Fi calling off</item>       <!-- CODE_WFC_DEFAULT -->
+        <item>No mobile network available. Connect to an available Wi\u2011Fi network to make calls.</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_DENY -->
+        <item>String to be decided</item>    <!-- CODE_WFC_RNS_ALLOWED_RADIO_NONE -->
+        <item>Error02: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_NAPTR_QUERY_RSP_ERROR -->
+        <item>Error03: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_RSP_SRV_QUERY_ERROR -->
+        <item>Error04: DNS Error</item>      <!-- CODE_WFC_DNS_RECV_RSP_QUERY_ERROR -->
+        <item>Error041: DNS Error</item>     <!-- CODE_WFC_DNS_RESOLVE_FQDN_ERROR -->
+        <item>Error05: Invalid SIM card</item>   <!-- CODE_WFC_INCORRECT_SIM_CARD_ERROR -->
+        <item>Error07: Unable to Connect</item>  <!-- CODE_WFC_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>Error081: Unable to connect</item> <!-- CODE_WFC_EPDG_CON_OR_LOCAL_OR_NULL_PTR_ERROR -->
+        <item>Error082: Unable to Connect</item> <!-- CODE_WFC_EPDG_IPSEC_SETUP_ERROR -->
+        <item>Error08: Unable to Connect</item>  <!-- CODE_WFC_TLS_CONN_ERROR -->
+        <item>REG91: Unable to Connect</item>    <!-- CODE_WFC_INTERNAL_SERVER_ERROR -->
+        <item>Error010: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_CERT_VALIDATION_ERROR -->
+        <item>Error101: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_VALIDATION_ERROR -->
+        <item>Error111: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_IPSEC_CERT_INVALID_ERROR -->
+        <item>Error011: Invalid Certificate</item>    <!-- CODE_WFC_SERVER_CERT_INVALID_ERROR -->
+        <item>Error403: Unknown user</item>    <!-- CODE_WFC_403_UNKNOWN_USER -->
+        <item>Error403: Roaming not allowed</item>    <!-- CODE_WFC_403_ROAMING_NOT_ALLOWED -->
+        <item>Error403: Mismatch identities</item>    <!-- CODE_WFC_403_MISMATCH_IDENTITIES -->
+        <item>Error403: authentication scheme unsupported</item>    <!-- CODE_WFC_403_AUTH_SCHEME_UNSUPPORTED -->
+        <item>Error403: handset is blacklisted</item>    <!-- CODE_WFC_403_HANDSET_BLACKLISTED -->
+        <item>REG09: Missing 911 Address</item>    <!-- CODE_WFC_911_MISSING -->
+        <item>REG99: Unable to Connect</item>      <!-- CODE_WFC_ANY_OTHER_CONN_ERROR -->
+        <item>REG99: Unable to Connect</item>      <!-- CODE_UNSPECIFIED -->
+    </string-array>
+
+
+    <!-- Template for showing cellular network operator name while WFC is active -->
+    <string-array name="wfcSpnFormats">
+        <item>%s</item>
+        <item>%s Wi\u2011Fi calling</item>
+    </string-array>
+    <!-- WFC, summary for Disabled -->
+    <string name="wifi_calling_off_summary">Off</string>
+    <!-- WFC, summary for Wi-Fi Preferred -->
+    <string name="wfc_mode_wifi_preferred_summary">Wi\u2011Fi preferred</string>
+    <!-- WFC, summary for Cellular Preferred -->
+    <string name="wfc_mode_cellular_preferred_summary">Cellular preferred</string>
+    <!-- WFC, summary for Wi-Fi Only -->
+    <string name="wfc_mode_wifi_only_summary">Wi\u2011Fi only</string>
+
+    <!--
+        {0} is one of "bearerServiceCode*"
+        {1} is dialing number
+        {2} is time in seconds
+
+        cfTemplateRegistered and cfTemplateRegisteredTime mean that a phone number
+        has been set but forwarding is not on.
+    --> <skip/>
+    <!-- Displayed when the call forwarding query was not able to be forwarded. -->
+    <string name="cfTemplateNotForwarded"><xliff:g id="bearer_service_code">{0}</xliff:g>: Not forwarded</string>
+    <!-- Displayed when the call forwarding query was forwarded. -->
+    <string name="cfTemplateForwarded"><xliff:g id="bearer_service_code">{0}</xliff:g>: <xliff:g id="dialing_number">{1}</xliff:g></string>
+    <!-- Displayed when the call forwarding query will be forwarded after some time. -->
+    <string name="cfTemplateForwardedTime"><xliff:g id="bearer_service_code">{0}</xliff:g>: <xliff:g id="dialing_number">{1}</xliff:g> after <xliff:g id="time_delay">{2}</xliff:g> seconds</string>
+    <!-- Displayed when the call forwarding query was set but forwarding is not enabled. -->
+    <string name="cfTemplateRegistered"><xliff:g id="bearer_service_code">{0}</xliff:g>: Not forwarded</string>
+    <!-- Displayed when the call forwarding query was set but forwarding is not enabled. -->
+    <string name="cfTemplateRegisteredTime"><xliff:g id="bearer_service_code">{0}</xliff:g>: Not forwarded</string>
+
+    <!-- android.net.http Error strings --> <skip/>
+    <!-- Displayed when a feature code (non-phone number) is dialed and completes successfully. -->
+    <string name="fcComplete">Feature code complete.</string>
+    <!-- Displayed when a feature code (non-phone number) is dialed and completes unsuccessfully. -->
+    <string name="fcError">Connection problem or invalid feature code.</string>
+    <!-- android.net.http Error strings --> <skip/>
+    <!-- Displayed when a web request was successful. -->
+    <string name="httpErrorOk">OK</string>
+    <!-- Displayed when a web request failed with a generic network error. -->
+    <string name="httpError">There was a network error.</string>
+    <!-- Displayed when a web request failed because the URL could not be found. -->
+    <string name="httpErrorLookup">Couldn\'t find the URL</string>
+    <!-- Displayed when a web request failed because the site's authentication scheme is not supported by us. -->
+    <string name="httpErrorUnsupportedAuthScheme">The site authentication scheme isn\'t supported.</string>
+    <!-- Displayed when a web request failed because the authentication failed. -->
+    <string name="httpErrorAuth">Couldn\'t authenticate.</string>
+    <!-- Displayed when a web request failed because the authentication with the proxy failed. -->
+    <string name="httpErrorProxyAuth">Authentication via the proxy server was unsuccessful.</string>
+    <!-- Displayed when a web request failed because there was a connection error. -->
+    <string name="httpErrorConnect">Couldn\'t connect to the server.</string>
+    <!-- Displayed when a web request failed because there was an input or output error. -->
+    <string name="httpErrorIO">Couldn\'t communicate with the server. Try again later.</string>
+    <!-- Displayed when a web request failed because the request timed out -->
+    <string name="httpErrorTimeout">The connection to the server timed out.</string>
+    <!-- Displayed when a web request failed because the site tried to redirect us one too many times -->
+    <string name="httpErrorRedirectLoop">The page contains too many server redirects.</string>
+    <!-- Displayed when a web request failed because the protocol of the server is not supported. -->
+    <string name="httpErrorUnsupportedScheme">The protocol isn\'t supported.</string>
+    <!-- Displayed when a web request failed because the a secure connection couldn't be made to the server.-->
+    <string name="httpErrorFailedSslHandshake">Couldn\'t establish a secure connection.</string>
+    <!-- Displayed when a web request failed because the URL isn't in a valid form. -->
+    <string name="httpErrorBadUrl">Couldn\'t open the page because the URL is invalid</string>
+    <!-- Displayed when a request failed because we failed to open the file. -->
+    <string name="httpErrorFile">Couldn\'t access the file</string>
+    <!-- Displayed when a request failed because the file wasn't found. -->
+    <string name="httpErrorFileNotFound">Couldn\'t find the requested file</string>
+    <!-- Displayed when a request failed because there are too many requests right now. -->
+    <string name="httpErrorTooManyRequests">Too many requests are being processed. Try again later.</string>
+
+    <!-- Account notifications --> <skip/>
+    <!-- A notification is shown when the AccountManager is unable to
+    supply an auth token without prompting the user to re-enter the
+    password.  This is the text that will scroll through the
+    notification bar (will be seen by the user as he uses another application). -->
+    <string name="notification_title">Signin error for <xliff:g example="foo@gmail.com" id="account">%1$s</xliff:g></string>
+
+    <!-- Sync notifications --> <skip/>
+    <!-- A notification is shown when there is a sync error.  This is the text that will scroll through the notification bar (will be seen by the user as he uses another application). -->
+    <string name="contentServiceSync">Sync</string>
+    <!-- A notification is shown when there is a sync error.  This is the title of the notification.  It will be seen in the pull-down notification tray. -->
+    <string name="contentServiceSyncNotificationTitle">Sync</string>
+    <!-- A notification is shown when there is a sync error.  This is the message of the notification.  It describes the error, in this case is there were too many deletes. The argument is the type of content, for example Gmail or Calendar. It will be seen in the pull-down notification tray. -->
+    <string name="contentServiceTooManyDeletesNotificationDesc">Too many <xliff:g id="content_type">%s</xliff:g> deletes.</string>
+
+    <!-- If MMS discovers there isn't much space left on the device, it will show a toast with this message. -->
+    <string name="low_memory" product="tablet">Tablet storage is full. Delete some files to free space.</string>
+    <!-- If MMS discovers there isn't much space left on the device, it will show a toast with this message. -->
+    <string name="low_memory" product="watch">Watch storage is full. Delete some files to free up space.</string>
+    <!-- If MMS discovers there isn't much space left on the device, it will show a toast with this message. -->
+    <string name="low_memory" product="tv">TV storage is full. Delete some files to free space.</string>
+    <!-- If MMS discovers there isn't much space left on the device, it will show a toast with this message. -->
+    <string name="low_memory" product="default">Phone storage is full. Delete some files to free space.</string>
+
+    <!-- SSL CA cert notification --> <skip/>
+    <!-- Shows up when there is a user SSL CA Cert installed on the
+         device.  Indicates to the user that SSL traffic can be intercepted.  [CHAR LIMIT=NONE] -->
+    <plurals name="ssl_ca_cert_warning">
+        <item quantity="one">Certificate authority installed</item>
+        <item quantity="other">Certificate authorities installed</item>
+    </plurals>
+    <!-- Content text for a notification. The Title of the notification is "ssl_ca_cert_warning".
+         This says that an unknown party is doing the monitoring. [CHAR LIMIT=100]-->
+    <string name="ssl_ca_cert_noti_by_unknown">By an unknown third party</string>
+    <!-- Content text for a notification. The Title of the notification is "ssl_ca_cert_warning".
+         This indicates that an unspecified administrator is doing the monitoring. [CHAR LIMIT=100]-->
+    <string name="ssl_ca_cert_noti_by_administrator">By your work profile administrator</string>
+    <!-- Content text for a notification. The Title of the notification is "ssl_ca_cert_warning".
+         This indicates who is doing the monitoring. [CHAR LIMIT=100]-->
+    <string name="ssl_ca_cert_noti_managed">By <xliff:g id="managing_domain">%s</xliff:g></string>
+
+    <!-- Work profile deleted notification--> <skip/>
+    <!-- Shows up in the notification's title when the system deletes the work profile. [CHAR LIMIT=NONE] -->
+    <string name="work_profile_deleted">Work profile deleted</string>
+    <!-- Content text for a notification. The Title of the notification is "work_profile_deleted",
+         i.e. "Work profile deleted". This says that the profile is deleted by the system as a result of
+         the current profile owner gone missing. [CHAR LIMIT=100]-->
+    <string name="work_profile_deleted_description">Work profile deleted due to missing admin app.</string>
+    <!-- Content text for an expanded notification. The Title of the notification is "work_profile_deleted",
+         i.e. "Work profile deleted". This further explains that the profile is deleted by the system
+         as a result of the current profile admin gone missing. [CHAR LIMIT=NONE]-->
+    <string name="work_profile_deleted_details">The work profile admin app is either missing or corrupted. As a result, your work profile and related data have been deleted. Contact your administrator for assistance.</string>
+    <!-- Content text for a notification. The Title of the notification is "work_profile_deleted",
+        This indicates that a work profile has been deleted. [CHAR LIMIT=NONE]-->
+    <string name="work_profile_deleted_description_dpm_wipe">Your work profile is no longer available on this device.</string>
+
+    <!-- Factory reset warning dialog strings--> <skip/>
+    <!-- Shows up in the dialog's title to warn about an impeding factory reset. [CHAR LIMIT=NONE] -->
+    <string name="factory_reset_warning">Your device will be erased</string>
+    <!-- Text message in the factory reset warning dialog. This says that the the device admin app
+         is missing or corrupted. As a result the device will be erased. [CHAR LIMIT=NONE]-->
+    <string name="factory_reset_message">The admin app lacks of components or is corrupted, and can\'t be used. Your device will now be erased. Contact your administrator for assistance.</string>
+
+    <!-- Display name for any time a piece of data refers to the owner of the phone. For example, this could be used in place of the phone's phone number. -->
+    <string name="me">Me</string>
+
+    <!-- Power Dialog --> <skip/>
+    <!-- Title for the Phone Options dialog to lock the screen, turn off the phone etc. -->
+    <string name="power_dialog" product="tablet">Tablet options</string>
+    <!-- Title for the Phone Options dialog to lock the screen, turn off the phone etc. -->
+    <string name="power_dialog" product="tv">TV options</string>
+    <!-- Title for the Phone Options dialog to lock the screen, turn off the phone etc. -->
+    <string name="power_dialog" product="default">Phone options</string>
+    <!-- Button to turn on silent mode, within the Phone Options dialog -->
+    <string name="silent_mode">Silent mode</string>
+    <!-- Button to turn on the radio, within the Phone Options dialog -->
+    <string name="turn_on_radio">Turn on wireless</string>
+    <!-- Button to turn off the radio, within the Phone Options dialog -->
+    <string name="turn_off_radio">Turn off wireless</string>
+    <!-- Button to lock the screen, within the Phone Options dialog -->
+    <string name="screen_lock">Screen lock</string>
+    <!-- Button to turn off the phone, within the Phone Options dialog -->
+    <string name="power_off">Power off</string>
+    <!-- Spoken description for ringer silent option. [CHAR LIMIT=NONE] -->
+    <string name="silent_mode_silent">Ringer off</string>
+    <!-- Spoken description for ringer vibrate option. [CHAR LIMIT=NONE] -->
+    <string name="silent_mode_vibrate">Ringer vibrate</string>
+    <!-- Spoken description for ringer normal option. [CHAR LIMIT=NONE] -->
+    <string name="silent_mode_ring">Ringer on</string>
+
+    <!-- Reboot to Recovery Progress Dialog. This is shown before it reboots to recovery. -->
+    <string name="reboot_to_update_title">Android system update</string>
+    <string name="reboot_to_update_prepare">Preparing to update\u2026</string>
+    <string name="reboot_to_update_package">Processing the update package\u2026</string>
+    <string name="reboot_to_update_reboot">Restarting\u2026</string>
+
+    <!-- Reboot to Recovery for factory reset. -->
+    <string name="reboot_to_reset_title">Factory data reset</string>
+    <string name="reboot_to_reset_message">Restarting\u2026</string>
+
+    <!-- Shutdown Progress Dialog. This is shown if the user chooses to power off the phone. -->
+    <string name="shutdown_progress">Powering off\u2026</string>
+
+    <!-- Shutdown Confirmation Dialog.  When the user chooses to power off the phone, there will
+         be a confirmation dialog.  This is the message. -->
+    <string name="shutdown_confirm" product="tablet">Your tablet will shut down.</string>
+    <!-- Shutdown Confirmation Dialog.  When the user chooses to power off the TV, there will
+         be a confirmation dialog.  This is the message. -->
+    <string name="shutdown_confirm" product="tv">Your TV will shut down.</string>
+    <!-- Shutdown Confirmation Dialog.  When the user chooses to power off the watch, there will
+         be a confirmation dialog.  This is the message. -->
+    <string name="shutdown_confirm" product="watch">Your watch will shut down.</string>
+    <!-- Shutdown Confirmation Dialog.  When the user chooses to power off the phone, there will
+         be a confirmation dialog.  This is the message. -->
+    <string name="shutdown_confirm" product="default">Your phone will power off</string>
+
+    <!-- Shutdown Confirmation Dialog.  When the user chooses to power off the phone, it asks
+         the user if they'd like to shut down.  This is the message.  This is used instead of
+         shutdown_confirm when the system is configured to use long press to go directly to the
+         power off dialog instead of the global actions menu. -->
+    <string name="shutdown_confirm_question">Power off?</string>
+
+    <!-- Title of dialog to confirm rebooting into safe mode. [CHAR LIMIT=50] -->
+    <string name="reboot_safemode_title">Reboot to safe mode</string>
+
+    <!-- Shutdown Confirmation Dialog.  Message in the confirmation dialog
+         when the user asks to reboot into safe mode. [CHAR LIMIT=NONE] -->
+    <string name="reboot_safemode_confirm">Reboot into safe mode? This will disable all third party applications you have installed. They will be restored when you reboot again.</string>
+
+    <!-- Recent Tasks dialog: title
+     TODO: this should move to SystemUI.apk, but the code for the old
+            recent dialog is still in the framework
+     -->
+    <string name="recent_tasks_title">Recent</string>
+    <!-- Recent Tasks dialog: message when there are no recent applications
+     TODO: this should move to SystemUI.apk, but the code for the old
+            recent dialog is still in the framework
+     -->
+    <string name="no_recent_tasks">No recent apps</string>
+
+    <!-- Title of the Global Actions Dialog -->
+    <string name="global_actions" product="tablet">Tablet options</string>
+    <!-- Title of the Global Actions Dialog -->
+    <string name="global_actions" product="tv">TV options</string>
+    <!-- Title of the Global Actions Dialog -->
+    <string name="global_actions" product="default">Phone options</string>
+
+    <!-- label for item that locks the phone in the phone options dialog -->
+    <string name="global_action_lock">Screen lock</string>
+
+    <!-- label for item that turns off power in phone options dialog -->
+    <string name="global_action_power_off">Power off</string>
+
+    <!-- label for item that restarts phone in phone options dialog -->
+    <!-- TODO: promote to separate string-->
+    <string name="global_action_restart" translatable="false">@string/sim_restart_button</string>
+
+    <!-- label for item that starts emergency call -->
+    <string name="global_action_emergency">Emergency</string>
+
+    <!-- label for item that generates a bug report in the phone options dialog -->
+    <string name="global_action_bug_report">Bug report</string>
+
+    <!-- Take bug report menu title [CHAR LIMIT=NONE] -->
+    <string name="bugreport_title">Take bug report</string>
+    <!-- Message in bugreport dialog describing what it does [CHAR LIMIT=NONE] -->
+    <!-- TODO: remove if not used anymore -->
+    <string name="bugreport_message">This will collect information about your current device state, to send as an email message. It will take a little time from starting the bug report until it is ready to be sent; please be patient.</string>
+    <!-- Title in the bugreport dialog for the interactive workflow. Should fit in one line. [CHAR LIMIT=30] -->
+    <string name="bugreport_option_interactive_title">Interactive report</string>
+    <!-- Summary in the bugreport dialog for the interactive workflow. [CHAR LIMIT=NONE] -->
+    <string name="bugreport_option_interactive_summary">Use this under most circumstances. It allows you to track progress of the report, enter more details about the problem, and take screenshots. It might omit some less\u2011used sections that take a long time to report.</string>
+    <!-- Title in the bugreport dialog for the full workflow. Should fit in one line. [CHAR LIMIT=30] -->
+    <string name="bugreport_option_full_title">Full report</string>
+    <!-- Summary in the bugreport dialog for the full workflow. [CHAR LIMIT=NONE] -->
+    <string name="bugreport_option_full_summary">Use this option for minimal system interference when your device is unresponsive or too slow, or when you need all report sections. Does not allow you to enter more details or take additional screenshots.</string>
+    <!--  Toast message informing user in how many seconds a bugreport screenshot will be taken -->
+    <plurals name="bugreport_countdown">
+        <item quantity="one">Taking screenshot for bug report in <xliff:g id="number">%d</xliff:g> second.</item>
+        <item quantity="other">Taking screenshot for bug report in <xliff:g id="number">%d</xliff:g> seconds.</item>
+    </plurals>
+
+    <!-- Format for build summary info [CHAR LIMIT=NONE] -->
+    <string name="bugreport_status" translatable="false">%s (%s)</string>
+
+    <!-- label for item that enables silent mode in phone options dialog -->
+    <string name="global_action_toggle_silent_mode">Silent mode</string>
+
+    <!-- status message in phone options dialog for when silent mode is enabled -->
+    <string name="global_action_silent_mode_on_status">Sound is OFF</string>
+
+    <!-- status message in phone options dialog for when silent mode is disabled -->
+    <string name="global_action_silent_mode_off_status">Sound is ON</string>
+
+    <!-- label for item that toggles airplane mode -->
+    <string name="global_actions_toggle_airplane_mode">Aeroplane mode</string>
+
+    <!-- status message in phone options dialog for when airplane mode is on -->
+    <string name="global_actions_airplane_mode_on_status">Aeroplane mode is ON</string>
+
+    <!-- status message in phone options dialog for when airplane mode is off -->
+    <string name="global_actions_airplane_mode_off_status">Aeroplane mode is OFF</string>
+
+    <!-- label for item that launches settings in phone options dialog [CHAR LIMIT=15]-->
+    <string name="global_action_settings">Settings</string>
+
+    <!-- label for item that launches assist in phone options dialog [CHAR LIMIT=15]-->
+    <string name="global_action_assist">Assist</string>
+
+    <!-- label for item that launches voice assist in phone options dialog [CHAR LIMIT=15]-->
+    <string name="global_action_voice_assist">Voice Assist</string>
+
+    <!-- label for item that locks the phone and enforces that it can't be unlocked without entering a credential. [CHAR LIMIT=15] -->
+    <string name="global_action_lockdown">Lock now</string>
+
+    <!-- Text to use when the number in a notification info is too large
+         (greater than status_bar_notification_info_maxnum, defined in
+         values/config.xml) and must be truncated. May need to be localized
+         for most appropriate textual indicator of "more than X".
+         [CHAR LIMIT=4] -->
+    <string name="status_bar_notification_info_overflow">999+</string>
+
+    <!-- The divider symbol between different parts of the notification header. not translatable [CHAR LIMIT=1] -->
+    <string name="notification_header_divider_symbol" translatable="false">•</string>
+
+    <!-- Text shown in place of notification contents when the notification is hidden on a secure lockscreen -->
+    <string name="notification_hidden_text">Contents hidden</string>
+
+    <!-- Text shown in place of notification contents when the notification is hidden by policy on a secure lockscreen -->
+    <string name="notification_hidden_by_policy_text">Contents hidden by policy</string>
+
+    <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
+    <string name="safeMode">Safe mode</string>
+
+    <!-- Label for the Android system components when they are shown to the user. -->
+    <string name="android_system_label">Android System</string>
+
+    <!-- Label for the user owner in the intent forwarding app. -->
+    <string name="user_owner_label">Switch to Personal</string>
+
+    <!-- Label for a corporate profile in the intent forwarding app. -->
+    <string name="managed_profile_label">Switch to Work</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_contacts">Contacts</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_contacts">access your contacts</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_location">Location</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_location">access this device\'s location</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_calendar">Calendar</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_calendar">access your calendar</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_sms">SMS</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_sms">send and view SMS messages</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_storage">Storage</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_storage">access photos, media, and files on your device</string>
+
+    <!-- Title of a category of application permissioncds, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_microphone">Microphone</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_microphone">record audio</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_camera">Camera</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_camera">take pictures and record video</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_phone">Phone</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_phone">make and manage phone calls</string>
+
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_sensors">Body Sensors</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_sensors">access sensor data about your vital signs</string>
+
+    <!-- Title for the capability of an accessibility service to retrieve window content. -->
+    <string name="capability_title_canRetrieveWindowContent">Retrieve window content</string>
+    <!-- Description for the capability of an accessibility service to retrieve window content. -->
+    <string name="capability_desc_canRetrieveWindowContent">Inspect the content of a window you\'re interacting with.</string>
+
+    <!-- Title for the capability of an accessibility service to request touch exploration. -->
+    <string name="capability_title_canRequestTouchExploration">Turn on Explore by Touch</string>
+    <!-- Description for the capability of an accessibility service to request touch exploration. -->
+    <string name="capability_desc_canRequestTouchExploration">Tapped items will be spoken aloud and the screen can be explored using gestures.</string>
+
+    <!-- Title for the capability of an accessibility service to request enhanced web accessibility. -->
+    <string name="capability_title_canRequestEnhancedWebAccessibility">Turn on enhanced web accessibility</string>
+    <!-- Description for the capability of an accessibility service to request enhanced web accessibility. -->
+    <string name="capability_desc_canRequestEnhancedWebAccessibility">Scripts may be installed to make app content more accessible.</string>
+
+    <!-- Title for the capability of an accessibility service to request to filter key events. -->
+    <string name="capability_title_canRequestFilterKeyEvents">Observe text you type</string>
+    <!-- Description for the capability of an accessibility service to request to filter key events. -->
+    <string name="capability_desc_canRequestFilterKeyEvents">Includes personal data such as credit card numbers and passwords.</string>
+
+    <!-- Title for the capability of an accessibility service to control display magnification. -->
+    <string name="capability_title_canControlMagnification">Control display magnification</string>
+    <!-- Description for the capability of an accessibility service to control display magnification. -->
+    <string name="capability_desc_canControlMagnification">Control the display\'s zoom level and positioning.</string>
+
+    <!-- Title for the capability of an accessibility service to perform gestures. -->
+    <string name="capability_title_canPerformGestures">Perform gestures</string>
+    <!-- Description for the capability of an accessibility service to perform gestures. -->
+    <string name="capability_desc_canPerformGestures">Can tap, swipe, pinch, and perform other gestures.</string>
+
+    <!--  Permissions -->
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_statusBar">disable or modify status bar</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_statusBar">Allows the app to disable the status bar or add and remove system icons.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_statusBarService">be the status bar</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_statusBarService">Allows the app to be the status bar.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_expandStatusBar">expand/collapse status bar</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_expandStatusBar">Allows the app to expand or collapse the status bar.</string>
+
+    <!-- Title of an application permission, listed so the user can install application shortcuts
+    in their Launcher -->
+    <string name="permlab_install_shortcut">install shortcuts</string>
+    <!-- Description of an application permission, listed so the user can install application shortcuts
+    in their Launcher -->
+    <string name="permdesc_install_shortcut">Allows an application to add Homescreen shortcuts without user intervention.</string>
+
+    <!-- Title of an application permission, listed so the user can uninstall application shortcuts
+    in their Launcher -->
+    <string name="permlab_uninstall_shortcut">uninstall shortcuts</string>
+    <!-- Description of an application permission, listed so the user can install application shortcuts
+    in their Launcher -->
+    <string name="permdesc_uninstall_shortcut">Allows the application to remove Homescreen shortcuts without user intervention.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_processOutgoingCalls">reroute outgoing calls</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_processOutgoingCalls">Allows the app to see the number being dialled during an outgoing call with the option to redirect the call to a different number or abort the call altogether.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_receiveSms">receive text messages (SMS)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveSms">Allows the app to receive and process SMS messages. This means the app could monitor or delete messages sent to your device without showing them to you.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_receiveMms">receive text messages (MMS)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveMms">Allows the app to receive and process MMS messages. This means the app could monitor or delete messages sent to your device without showing them to you.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readCellBroadcasts">read Cell Broadcast messages</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCellBroadcasts">Allows the app to read Cell Broadcast messages received by your device. Cell broadcast alerts are delivered in some locations to warn you of emergency situations. Malicious apps may interfere with the performance or operation of your device when an emergency cell broadcast is received.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_subscribedFeedsRead">read subscribed feeds</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_subscribedFeedsRead">Allows the app to get details about the currently synced feeds.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_sendSms">send and view SMS messages</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_sendSms">Allows the app to send SMS messages. This may result in unexpected charges. Malicious apps may cost you money by sending messages without your confirmation.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readSms">read your text messages (SMS or MMS)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readSms" product="tablet">Allows the app to read SMS messages stored on your tablet or SIM card. This allows the app to read all SMS messages, regardless of content or confidentiality.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readSms" product="tv">Allows the app to read SMS messages stored on your TV or SIM card. This allows the app to read all SMS messages, regardless of content or confidentiality.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readSms" product="default">Allows the app to read SMS messages stored on your phone or SIM card. This allows the app to read all SMS messages, regardless of content or confidentiality.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_receiveWapPush">receive text messages (WAP)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveWapPush">Allows the app to receive and process WAP messages. This permission includes the ability to monitor or delete messages sent to you without showing them to you.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_getTasks">retrieve running apps</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_getTasks">Allows the app to retrieve information about currently and recently running tasks. This may allow the app to discover information about which applications are used on the device.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_manageProfileAndDeviceOwners">manage profile and device owners</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to set the profile/device owners.
+     [CHAR LIMIT=NONE] -->
+    <string name="permdesc_manageProfileAndDeviceOwners">Allows apps to set the profile owners and the device owner.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_reorderTasks">reorder running apps</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_reorderTasks">Allows the app to move tasks to the foreground and background. The app may do this without your input.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_enableCarMode">enable car mode</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_enableCarMode">Allows the app to enable the car mode.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_killBackgroundProcesses">close other apps</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_killBackgroundProcesses">Allows the app to end background processes of other apps. This may cause other apps to stop running.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_systemAlertWindow">draw over other apps</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_systemAlertWindow">Allows the app to draw on top of other applications or parts of the user interface. They may interfere with your use of the interface in any application, or change what you think you are seeing in other applications.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_persistentActivity">make app always run</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_persistentActivity" product="tablet">Allows the app to make parts of itself persistent in memory. This can limit memory available to other apps slowing down the tablet.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_persistentActivity" product="tv">Allows the app to make parts of itself persistent in memory. This can limit memory available to other apps slowing down the TV.</string>
+    <string name="permdesc_persistentActivity" product="default">Allows the app to make parts of itself persistent in memory. This can limit memory available to other apps slowing down the phone.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_getPackageSize">measure app storage space</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_getPackageSize">Allows the app to retrieve its code, data, and cache sizes</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_writeSettings">modify system settings</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeSettings">Allows the app to modify the system\'s settings data. Malicious apps may corrupt your system\'s configuration.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_receiveBootCompleted">run at startup</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveBootCompleted" product="tablet">Allows the app to have itself started as soon as the system has finished booting. This can make it take longer to start the tablet and allow the app to slow down the overall tablet by always running.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveBootCompleted" product="tv">Allows the app to have itself started as soon as the system has finished booting. This can make it take longer to start the TV and allow the app to slow down the overall tablet by always running.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_receiveBootCompleted" product="default">Allows the app to have itself started as soon as the system has finished booting. This can make it take longer to start the phone and allow the app to slow down the overall phone by always running.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_broadcastSticky">send sticky broadcast</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_broadcastSticky" product="tablet">Allows the app to send sticky broadcasts, which remain after the broadcast ends. Excessive use may make the tablet slow or unstable by causing it to use too much memory. </string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_broadcastSticky" product="tv">Allows the app to send sticky broadcasts, which remain after the broadcast ends. Excessive use may make the TV slow or unstable by causing it to use too much memory. </string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_broadcastSticky" product="default">Allows the app to send sticky broadcasts, which remain after the broadcast ends. Excessive use may make the phone slow or unstable by causing it to use too much memory.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readContacts">read your contacts</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readContacts" product="tablet">Allows the app to read data about your contacts stored on your tablet, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific individuals. This permission allows apps to save your contact data, and malicious apps may share contact data without your knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readContacts" product="tv">Allows the app to read data about your contacts stored on your TV, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific individuals. This permission allows apps to save your contact data, and malicious apps may share contact data without your knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readContacts" product="default">Allows the app to read data about your contacts stored on your phone, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific individuals. This permission allows apps to save your contact data, and malicious apps may share contact data without your knowledge.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_writeContacts">modify your contacts</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeContacts" product="tablet">Allows the app to modify the data about your contacts stored on your tablet, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific contacts. This permission allows apps to delete contact data.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeContacts" product="tv">Allows the app to modify the data about your contacts stored on your TV, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific contacts. This permission allows apps to delete contact data.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeContacts" product="default">Allows the app to modify the data about your contacts stored on your phone, including the frequency with which you\'ve called, emailed, or communicated in other ways with specific contacts. This permission allows apps to delete contact data.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readCallLog">read call log</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCallLog" product="tablet">Allows the app to read your tablet\'s call log, including data about incoming and outgoing calls. This permission allows apps to save your call log data, and malicious apps may share call log data without your knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCallLog" product="tv">Allows the app to read your TV\'s call log, including data about incoming and outgoing calls. This permission allows apps to save your call log data, and malicious apps may share call log data without your knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCallLog" product="default">Allows the app to read your phone\'s call log, including data about incoming and outgoing calls. This permission allows apps to save your call log data, and malicious apps may share call log data without your knowledge.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_writeCallLog">write call log</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCallLog" product="tablet">Allows the app to modify your tablet\'s call log, including data about incoming and outgoing calls. Malicious apps may use this to erase or modify your call log.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCallLog" product="tv">Allows the app to modify your TV\'s call log, including data about incoming and outgoing calls. Malicious apps may use this to erase or modify your call log.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCallLog" product="default">Allows the app to modify your phone\'s call log, including data about incoming and outgoing calls. Malicious apps may use this to erase or modify your call log.</string>
+
+    <!-- Title of the body sensors permission, listed so the user can decide whether to allow the application to access body sensor data. [CHAR LIMIT=30] -->
+    <string name="permlab_bodySensors">access body sensors (like heart rate monitors) </string>
+    <!-- Description of the body sensors permission, listed so the user can decide whether to allow the application to access data from body sensors. [CHAR LIMIT=NONE] -->
+    <string name="permdesc_bodySensors" product="default">Allows the app to access data from sensors that monitor your physical condition, such as your heart rate.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readCalendar">read calendar events plus confidential information</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCalendar" product="tablet">Allows the app to read all calendar events stored on your tablet, including those of friends or co-workers. This may allow the app to share or save your calendar data, regardless of confidentiality or sensitivity.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCalendar" product="tv">Allows the app to read all calendar events stored on your TV, including those of friends or co-workers. This may allow the app to share or save your calendar data, regardless of confidentiality or sensitivity.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readCalendar" product="default">Allows the app to read all calendar events stored on your phone, including those of friends or co\u2011workers. This may allow the app to share or save your calendar data, regardless of confidentiality or sensitivity.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_writeCalendar">add or modify calendar events and send email to guests without owners\' knowledge</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCalendar" product="tablet">Allows the app to add, remove, change events that you can modify on your tablet, including those of friends or co-workers. This may allow the app to send messages that appear to come from calendar owners, or modify events without the owners\' knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCalendar" product="tv">Allows the app to add, remove, change events that you can modify on your TV, including those of friends or co-workers. This may allow the app to send messages that appear to come from calendar owners, or modify events without the owners\' knowledge.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeCalendar" product="default">Allows the app to add, remove, change events that you can modify on your phone, including those of friends or co\u2011workers. This may allow the app to send messages that appear to come from calendar owners, or modify events without the owners\' knowledge.</string>
+
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessLocationExtraCommands">access extra location provider commands</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessLocationExtraCommands">Allows the app to access extra location provider commands. This may allow the app to interfere with the operation of the GPS or other location sources.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessFineLocation">access precise location (GPS and network\u2011based)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessFineLocation">Allows the app to get your precise location using the Global Positioning System (GPS) or network location sources such as cell towers and Wi\u2011Fi. These location services must be turned on and available to your device for the app to use them. Apps may use this to determine where you are, and may consume additional battery power.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessCoarseLocation">access approximate location (network\u2011based)</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessCoarseLocation">Allows the app to get your approximate location. This location is derived by location services using network location sources such as cell towers and Wi\u2011Fi. These location services must be turned on and available to your device for the app to use them. Apps may use this to determine approximately where you are.</string>
+
+ <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_modifyAudioSettings">change your audio settings</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_modifyAudioSettings">Allows the app to modify global audio settings such as volume and which speaker is used for output.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_recordAudio">record audio</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_recordAudio">Allows the app to record audio with the microphone. This permission allows the app to record audio at any time without your confirmation.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_sim_communication">send commands to the SIM</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_sim_communication">Allows the app to send commands to the SIM. This is very dangerous.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_camera">take pictures and videos</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_camera">Allows the app to take pictures and videos with the camera. This permission allows the app to use the camera at any time without your confirmation.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_vibrate">control vibration</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_vibrate">Allows the app to control the vibrator.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_callPhone">directly call phone numbers</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_callPhone">Allows the app to call phone numbers without your intervention. This may result in unexpected charges or calls. Note that this doesn\'t allow the app to call emergency numbers. Malicious apps may cost you money by making calls without your confirmation.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessImsCallService">access IMS call service</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessImsCallService">Allows the app to use the IMS service to make calls without your intervention.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readPhoneState">read phone status and identity</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readPhoneState">Allows the app to access the phone features of the device. This permission allows the app to determine the phone number and device IDs, whether a call is active, and the remote number connected by a call.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_wakeLock" product="tablet">prevent tablet from sleeping</string>
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_wakeLock" product="tv">prevent TV from sleeping</string>
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_wakeLock" product="default">prevent phone from sleeping</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_wakeLock" product="tablet">Allows the app to prevent the tablet from going to sleep.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_wakeLock" product="tv">Allows the app to prevent the TV from going to sleep.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_wakeLock" product="default">Allows the app to prevent the phone from going to sleep.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_transmitIr">transmit infrared</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_transmitIr" product="tablet">Allows the app to use the tablet\'s infrared transmitter.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_transmitIr" product="tv">Allows the app to use the TV\'s infrared transmitter.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_transmitIr" product="default">Allows the app to use the phone\'s infrared transmitter.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_setWallpaper">set wallpaper</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setWallpaper">Allows the app to set the system wallpaper.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_setWallpaperHints">adjust your wallpaper size</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setWallpaperHints">Allows the app to set the system wallpaper size hints.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_setTimeZone">set time zone</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setTimeZone" product="tablet">Allows the app to change the tablet\'s time zone.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setTimeZone" product="tv">Allows the app to change the TV\'s time zone.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setTimeZone" product="default">Allows the app to change the phone\'s time zone.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_getAccounts">find accounts on the device</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_getAccounts" product="tablet">Allows the app to get the list of accounts known by the tablet. This may include any accounts created by applications you have installed.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_getAccounts" product="tv">Allows the app to get the list of accounts known by the TV. This may include any accounts created by applications you have installed.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_getAccounts" product="default">Allows the app to get the list of accounts known by the phone. This may include any accounts created by applications you have installed.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessNetworkState">view network connections</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessNetworkState">Allows the app to view information about network connections such as which networks exist and are connected.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_createNetworkSockets">have full network access</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_createNetworkSockets">Allows the app to create network sockets and use custom network protocols. The browser and other applications provide means to send data to the internet, so this permission is not required to send data to the internet.</string>
+
+ <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_changeNetworkState">change network connectivity</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_changeNetworkState">Allows the app to change the state of network connectivity.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_changeTetherState">change tethered connectivity</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the applicaiton to do this. -->
+    <string name="permdesc_changeTetherState">Allows the app to change the state of tethered network connectivity.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessWifiState">view Wi\u2011Fi connections</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessWifiState">Allows the app to view information about Wi\u2011Fi networking, such as whether Wi\u2011Fi is enabled and name of connected Wi\u2011Fi devices.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_changeWifiState">connect and disconnect from Wi\u2011Fi</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_changeWifiState">Allows the app to connect to and disconnect from Wi\u2011Fi access points and to make changes to device configuration for Wi\u2011Fi networks.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_changeWifiMulticastState">allow Wi\u2011Fi Multicast reception</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_changeWifiMulticastState" product="tablet">Allows the app to receive packets sent to all devices on a Wi-Fi network using multicast addresses, not just your tablet. It uses more power than the non-multicast mode.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_changeWifiMulticastState" product="tv">Allows the app to receive packets sent to all devices on a Wi-Fi network using multicast addresses, not just your TV. It uses more power than the non-multicast mode.</string>
+    <string name="permdesc_changeWifiMulticastState" product="default">Allows the app to receive packets sent to all devices on a Wi\u2011Fi network using multicast addresses, not just your phone. It uses more power than the non\u2011multicast mode.</string>
+
+ <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bluetoothAdmin">access Bluetooth settings</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetoothAdmin" product="tablet">Allows the app to configure the local Bluetooth tablet, and to discover and pair with remote devices.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetoothAdmin" product="tv">Allows the app to configure the local Bluetooth TV, and to discover and pair with remote devices.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetoothAdmin" product="default">Allows the app to configure the local Bluetooth phone, and to discover and pair with remote devices.</string>
+
+    <string name="permlab_accessWimaxState">connect and disconnect from WiMAX</string>
+    <string name="permdesc_accessWimaxState">Allows the app to determine whether WiMAX is enabled and information about any WiMAX networks that are connected. </string>
+
+    <string name="permlab_changeWimaxState">change WiMAX state</string>
+    <string name="permdesc_changeWimaxState" product="tablet">Allows the app to connect the tablet to and disconnect the tablet from WiMAX networks.</string>
+    <string name="permdesc_changeWimaxState" product="tv">Allows the app to connect the TV to and disconnect the TV from WiMAX networks.</string>
+    <string name="permdesc_changeWimaxState" product="default">Allows the app to connect the phone to and disconnect the phone from WiMAX networks.</string>
+
+ <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bluetooth">pair with Bluetooth devices</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetooth" product="tablet">Allows the app to view the configuration of Bluetooth on the tablet, and to make and accept connections with paired devices.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetooth" product="tv">Allows the app to view the configuration of Bluetooth on the TV, and to make and accept connections with paired devices.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bluetooth" product="default">Allows the app to view the configuration of the Bluetooth on the phone, and to make and accept connections with paired devices.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_nfc">control Near Field Communication</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_nfc">Allows the app to communicate with Near Field Communication (NFC) tags, cards, and readers.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_disableKeyguard">disable your screen lock</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_disableKeyguard">Allows the app to disable the keylock and any associated password security. For example, the phone disables the keylock when receiving an incoming phone call, then re\u2011enables the keylock when the call is finished.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_manageFingerprint">manage fingerprint hardware</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_manageFingerprint">Allows the app to invoke methods to add and delete fingerprint templates for use.</string>
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_useFingerprint">use fingerprint hardware</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_useFingerprint">Allows the app to use fingerprint hardware for authentication</string>
+
+    <!-- Message shown during fingerprint acquisision when the fingerprint cannot be recognized -->
+    <string name="fingerprint_acquired_partial">Partial fingerprint detected. Try again.</string>
+    <!-- Message shown during fingerprint acquisision when the fingerprint cannot be recognized -->
+    <string name="fingerprint_acquired_insufficient">Couldn\'t process fingerprint. Try again.</string>
+    <!-- Message shown during fingerprint acquisision when the fingerprint sensor needs cleaning -->
+    <string name="fingerprint_acquired_imager_dirty">Fingerprint sensor is dirty. Clean it and try again.</string>
+    <!-- Message shown during fingerprint acquisision when the user removes their finger from the sensor too quickly -->
+    <string name="fingerprint_acquired_too_fast">Finger moved too fast. Try again.</string>
+    <!-- Message shown during fingerprint acquisision when the user moves their finger too slowly -->
+    <string name="fingerprint_acquired_too_slow">Finger moved too slow. Try again.</string>
+    <!-- Array containing custom messages shown during fingerprint acquisision from vendor.  Vendor is expected to add and translate these strings -->
+    <string-array name="fingerprint_acquired_vendor">
+    </string-array>
+
+    <!-- Error message shown when the fingerprint hardware can't be accessed -->
+    <string name="fingerprint_error_hw_not_available">Fingerprint hardware not available.</string>
+    <!-- Error message shown when the fingerprint hardware has run out of room for storing fingerprints -->
+    <string name="fingerprint_error_no_space">Fingerprint can\'t be stored. Remove an existing fingerprint.</string>
+    <!-- Error message shown when the fingerprint hardware timer has expired and the user needs to restart the operation. -->
+    <string name="fingerprint_error_timeout">Fingerprint time out reached. Try again.</string>
+    <!-- Generic error message shown when the fingerprint operation (e.g. enrollment or authentication) is canceled. Generally not shown to the user-->
+    <string name="fingerprint_error_canceled">Fingerprint operation cancelled.</string>
+    <!-- Generic error message shown when the fingerprint operation fails because too many attempts have been made. -->
+    <string name="fingerprint_error_lockout">Too many attempts. Try again later.</string>
+    <!-- Generic error message shown when the fingerprint hardware can't recognize the fingerprint -->
+    <string name="fingerprint_error_unable_to_process">Try again.</string>
+
+    <!-- Template to be used to name enrolled fingerprints by default. -->
+    <string name="fingerprint_name_template">Finger <xliff:g example="1" id="fingerId">%d</xliff:g></string>
+
+    <!-- Array containing custom error messages from vendor.  Vendor is expected to add and translate these strings -->
+    <string-array name="fingerprint_error_vendor">
+    </string-array>
+
+    <!-- Content description which should be used for the fingerprint icon. -->
+    <string name="fingerprint_icon_content_description">Fingerprint icon</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readSyncSettings">read sync settings</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readSyncSettings">Allows the app to read the sync settings for an account. For example, this can determine whether the People app is synced with an account.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_writeSyncSettings">toggle sync on and off</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_writeSyncSettings">Allows an app to modify the sync settings for an account. For example, this can be used to enable sync of the People app with an account.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readSyncStats">read sync statistics</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readSyncStats">Allows an app to read the sync stats for an account, including the history of sync events and how much data is synced. </string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. [CHAR LIMIT=30] -->
+    <string name="permlab_sdcardRead" product="nosdcard">read the contents of your USB storage</string>
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_sdcardRead" product="default">read the contents of your SD card</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. [CHAR LIMIT=30] -->
+    <string name="permdesc_sdcardRead" product="nosdcard">Allows the app to read the contents of your USB storage.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_sdcardRead" product="default">Allows the app to read the contents of your SD card.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. [CHAR LIMIT=30] -->
+    <string name="permlab_sdcardWrite" product="nosdcard">modify or delete the contents of your USB storage</string>
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_sdcardWrite" product="default">modify or delete the contents of your SD card</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. [CHAR LIMIT=30] -->
+    <string name="permdesc_sdcardWrite" product="nosdcard">Allows the app to write to the USB storage.</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_sdcardWrite" product="default">Allows the app to write to the SD card.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_use_sip">make/receive SIP calls</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_use_sip">Allows the app to make and receive SIP calls.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_register_sim_subscription">register new telecom SIM connections</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_register_sim_subscription">Allows the app to register new telecom SIM connections.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_register_call_provider">register new telecom connections</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_register_call_provider">Allows the app to register new telecom connections.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_connection_manager">manage telecom connections</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_connection_manager">Allows the app to manage telecom connections.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bind_incall_service">interact with in\u2011call screen</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bind_incall_service">Allows the app to control when and how the user sees the in\u2011call screen.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bind_connection_service">interact with telephony services</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bind_connection_service">Allows the app to interact with telephony services to make/receive calls.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_control_incall_experience">provide an in\u2011call user experience</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_control_incall_experience">Allows the app to provide an in\u2011call user experience.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_readNetworkUsageHistory">read historical network usage</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_readNetworkUsageHistory">Allows the app to read historical network usage for specific networks and apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_manageNetworkPolicy">manage network policy</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_manageNetworkPolicy">Allows the app to manage network policies and define app\u2011specific rules.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_modifyNetworkAccounting">modify network usage accounting</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_modifyNetworkAccounting">Allows the app to modify how network usage is accounted against apps. Not for use by normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessNotifications">access notifications</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessNotifications">Allows the app to retrieve, examine, and clear notifications, including those posted by other apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bindNotificationListenerService">bind to a notification listener service</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bindNotificationListenerService">Allows the holder to bind to the top\u2011level interface of a notification listener service. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bindConditionProviderService">bind to a condition provider service</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bindConditionProviderService">Allows the holder to bind to the top\u2011level interface of a condition provider service. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bindDreamService">bind to a dream service</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bindDreamService">Allows the holder to bind to the top\u2011level interface of a dream service. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_invokeCarrierSetup">invoke the carrier\u2011provided configuration app</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_invokeCarrierSetup">Allows the holder to invoke the carrier\u2011provided configuration app. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessNetworkConditions">listen for observations on network conditions</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessNetworkConditions">Allows an application to listen for observations on network conditions. Should never be needed for normal apps.</string>
+
+    <string name="permlab_setInputCalibration">change input device calibration</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_setInputCalibration">Allows the app to modify the calibration parameters of the touch screen. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessDrmCertificates">access DRM certificates</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessDrmCertificates">Allows an application to provision and use DRM certficates. Should never be needed for normal apps.</string>
+
+    <string name="permlab_handoverStatus">receive Android Beam transfer status</string>
+    <string name="permdesc_handoverStatus">Allows this application to receive information about current Android Beam transfers</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_removeDrmCertificates">remove DRM certificates</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_removeDrmCertificates">Allows an application to remove DRM certficates. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bindCarrierMessagingService">bind to a carrier messaging service</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bindCarrierMessagingService">Allows the holder to bind to the top\u2011level interface of a carrier messaging service. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_bindCarrierServices">bind to carrier services</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_bindCarrierServices">Allows the holder to bind to carrier services. Should never be needed for normal apps.</string>
+
+    <!-- Title of an application permission, for applications that wish to access notification policy. -->
+    <string name="permlab_access_notification_policy">access Do Not Disturb</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_access_notification_policy">Allows the app to read and write Do Not Disturb configuration.</string>
+
+    <!-- Policy administration -->
+
+    <!-- Title of policy access to limiting the user's password choices -->
+    <string name="policylab_limitPassword">Set password rules</string>
+    <!-- Description of policy access to limiting the user's password choices -->
+    <string name="policydesc_limitPassword">Control the length and the characters allowed in screen lock passwords and PINs.</string>
+    <!-- Title of policy access to watch user login attempts -->
+    <string name="policylab_watchLogin">Monitor screen\u2011unlock attempts</string>
+    <!-- Description of policy access to watch user login attempts -->
+    <string name="policydesc_watchLogin" product="tablet">Monitor the number of incorrect passwords typed when unlocking the screen, and lock the tablet or erase all the tablet\'s data if too many incorrect passwords are typed.</string>
+    <!-- Description of policy access to watch user login attempts -->
+    <string name="policydesc_watchLogin" product="TV">Monitor the number of incorrect passwords typed when unlocking the screen, and lock the TV or erase all the TV\'s data if too many incorrect passwords are typed.</string>
+    <!-- Description of policy access to watch user login attempts -->
+    <string name="policydesc_watchLogin" product="default">Monitor the number of incorrect passwords typed. when unlocking the screen, and lock the phone or erase all the phone\'s data if too many incorrect passwords are typed.</string>
+    <string name="policydesc_watchLogin_secondaryUser" product="tablet">Monitor the number of incorrect passwords typed when unlocking the screen, and lock the tablet or erase all this user\'s data if too many incorrect passwords are typed.</string>
+    <string name="policydesc_watchLogin_secondaryUser" product="TV">Monitor the number of incorrect passwords typed when unlocking the screen, and lock the TV or erase all this user\'s data if too many incorrect passwords are typed.</string>
+    <string name="policydesc_watchLogin_secondaryUser" product="default">Monitor the number of incorrect passwords typed when unlocking the screen, and lock the phone or erase all this user\'s data if too many incorrect passwords are typed.</string>
+    <!-- Title of policy access to reset user's password -->
+    <string name="policylab_resetPassword">Change the screen lock</string>
+    <!-- Description of policy access to reset user's password -->
+    <string name="policydesc_resetPassword">Change the screen lock.</string>
+    <!-- Title of policy access to force lock the device -->
+    <string name="policylab_forceLock">Lock the screen</string>
+    <!-- Description of policy access to limiting the user's password choices -->
+    <string name="policydesc_forceLock">Control how and when the screen locks.</string>
+    <!-- Title of policy access to wipe primary user's data -->
+    <string name="policylab_wipeData">Erase all data</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData" product="tablet">Erase the tablet\'s data without warning by performing a factory data reset.</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData" product="tv">Erase the TV\'s data without warning by performing a factory data reset.</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData" product="default">Erase the phone\'s data without warning by performing a factory data reset.</string>
+    <!-- Title of policy access to wipe secondary user's data -->
+    <string name="policylab_wipeData_secondaryUser">Erase user data</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData_secondaryUser" product="tablet">Erase this user\'s data on this tablet without warning.</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData_secondaryUser" product="tv">Erase this user\'s data on this TV without warning.</string>
+    <!-- Description of policy access to wipe the user's data -->
+    <string name="policydesc_wipeData_secondaryUser" product="default">Erase this user\'s data on this phone without warning.</string>
+    <!-- Title of policy access to set global proxy -->
+    <string name="policylab_setGlobalProxy">Set the device global proxy</string>
+    <!-- Description of policy access to set global proxy -->
+    <string name="policydesc_setGlobalProxy">Set the device global proxy to be used while policy is enabled. Only the device owner can set the global proxy.</string>
+    <!-- Title of policy access to enforce password expiration [CHAR LIMIT=50]-->
+    <string name="policylab_expirePassword">Set screen lock password expiration</string>
+    <!-- Description of policy access to enforce password expiration [CHAR LIMIT=110]-->
+    <string name="policydesc_expirePassword">Change how frequently the screen lock password, PIN, or pattern must be changed.</string>
+    <!-- Title of policy access to require encrypted storage [CHAR LIMIT=30]-->
+    <string name="policylab_encryptedStorage">Set storage encryption</string>
+    <!-- Description of policy access to require encrypted storage [CHAR LIMIT=110]-->
+    <string name="policydesc_encryptedStorage">Require that stored app data be encrypted.</string>
+    <!-- Title of policy access to disable all device cameras [CHAR LIMIT=30]-->
+    <string name="policylab_disableCamera">Disable cameras</string>
+    <!-- Description of policy access to disable all device cameras [CHAR LIMIT=110]-->
+    <string name="policydesc_disableCamera">Prevent use of all device cameras.</string>
+    <!-- Title of policy access to disable keyguard features [CHAR LIMIT=30]-->
+    <string name="policylab_disableKeyguardFeatures">Disable some screen lock features</string>
+    <!-- Description of policy access to disable keyguard features. [CHAR LIMIT=110]-->
+    <string name="policydesc_disableKeyguardFeatures">Prevent use of some screen lock features.</string>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Phone number types from android.provider.Contacts. This could be used when adding a new phone number for a contact, for example. -->
+    <string-array name="phoneTypes">
+        <item>Home</item>
+        <item>Mobile</item>
+        <item>Work</item>
+        <item>Work fax</item>
+        <item>Home fax</item>
+        <item>Pager</item>
+        <item>Other</item>
+        <item>Custom</item>
+    </string-array>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Email address types from android.provider.Contacts. This could be used when adding a new e-mail address for a contact, for example. -->
+    <string-array name="emailAddressTypes">
+        <item>Home</item>
+        <item>Work</item>
+        <item>Other</item>
+        <item>Custom</item>
+    </string-array>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Postal address types from android.provider.Contacts. This could be used when adding a new address for a contact, for example. -->
+    <string-array name="postalAddressTypes">
+        <item>Home</item>
+        <item>Work</item>
+        <item>Other</item>
+        <item>Custom</item>
+    </string-array>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Instant Messenger ID types from android.provider.Contacts. This could be used when adding a new IM for a contact, for example. -->
+    <string-array name="imAddressTypes">
+        <item>Home</item>
+        <item>Work</item>
+        <item>Other</item>
+        <item>Custom</item>
+    </string-array>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Organization types from android.provider.Contacts. This could be used when adding a new organization for a contact, for example. -->
+    <string-array name="organizationTypes">
+        <item>Work</item>
+        <item>Other</item>
+        <item>Custom</item>
+    </string-array>
+
+    <!-- The order of these is important, don't reorder without changing Contacts.java --> <skip/>
+    <!-- Instant Message protocols/providers from android.provider.Contacts -->
+    <string-array name="imProtocols">
+        <item>"AIM"</item>
+        <item>"Windows Live"</item>
+        <item>Yahoo</item>
+        <item>"Skype"</item>
+        <item>QQ</item>
+        <item>Google Talk</item>
+        <item>ICQ</item>
+        <item>Jabber</item>
+    </string-array>
+
+    <!-- Custom phone number type -->
+    <string name="phoneTypeCustom">Custom</string>
+    <!-- Home phone number type -->
+    <string name="phoneTypeHome">Home</string>
+    <!-- Mobile phone number type -->
+    <string name="phoneTypeMobile">Mobile</string>
+    <!-- Work phone number type -->
+    <string name="phoneTypeWork">Work</string>
+    <!-- Work fax phone number type -->
+    <string name="phoneTypeFaxWork">Work Fax</string>
+    <!-- Home fax phone number type -->
+    <string name="phoneTypeFaxHome">Home Fax</string>
+    <!-- Pager phone number type -->
+    <string name="phoneTypePager">Pager</string>
+    <!-- Other phone number type -->
+    <string name="phoneTypeOther">Other</string>
+    <!-- Callback phone number type -->
+    <string name="phoneTypeCallback">Callback</string>
+    <!-- Car phone number type -->
+    <string name="phoneTypeCar">Car</string>
+    <!-- Company main phone number type -->
+    <string name="phoneTypeCompanyMain">Company main</string>
+    <!-- ISDN phone number type -->
+    <string name="phoneTypeIsdn">ISDN</string>
+    <!-- Main phone number type -->
+    <string name="phoneTypeMain">Main</string>
+    <!-- Other fax phone number type -->
+    <string name="phoneTypeOtherFax">Other fax</string>
+    <!-- Radio phone number type -->
+    <string name="phoneTypeRadio">Radio</string>
+    <!-- Telex phone number type -->
+    <string name="phoneTypeTelex">Telex</string>
+    <!-- TTY TDD phone number type -->
+    <string name="phoneTypeTtyTdd">TTY TDD</string>
+    <!-- Work mobile phone number type -->
+    <string name="phoneTypeWorkMobile">Work mobile</string>
+    <!-- Work pager phone number type -->
+    <string name="phoneTypeWorkPager">Work pager</string>
+    <!-- Assistant phone number type -->
+    <string name="phoneTypeAssistant">Assistant</string>
+    <!-- MMS phone number type -->
+    <string name="phoneTypeMms">MMS</string>
+
+    <!-- Label for custom events  [CHAR LIMIT=20] -->
+    <string name="eventTypeCustom">Custom</string>
+    <!-- Label for a birthday event  [CHAR LIMIT=20] -->
+    <string name="eventTypeBirthday">Birthday</string>
+    <!-- Label for an anniversary event  [CHAR LIMIT=20] -->
+    <string name="eventTypeAnniversary">Anniversary</string>
+    <!-- Label for other events  [CHAR LIMIT=20] -->
+    <string name="eventTypeOther">Other</string>
+
+    <!-- Custom email type -->
+    <string name="emailTypeCustom">Custom</string>
+    <!-- Home email type -->
+    <string name="emailTypeHome">Home</string>
+    <!-- Work email type -->
+    <string name="emailTypeWork">Work</string>
+    <!-- Other email type -->
+    <string name="emailTypeOther">Other</string>
+    <!-- Mobile email type -->
+    <string name="emailTypeMobile">Mobile</string>
+
+    <!-- Custom postal address type -->
+    <string name="postalTypeCustom">Custom</string>
+    <!-- Home postal address type -->
+    <string name="postalTypeHome">Home</string>
+    <!-- Work postal address type -->
+    <string name="postalTypeWork">Work</string>
+    <!-- Other postal address type -->
+    <string name="postalTypeOther">Other</string>
+
+    <!-- Custom IM address type -->
+    <string name="imTypeCustom">Custom</string>
+    <!-- Home IM address type -->
+    <string name="imTypeHome">Home</string>
+    <!-- Work IM address type -->
+    <string name="imTypeWork">Work</string>
+    <!-- Other IM address type -->
+    <string name="imTypeOther">Other</string>
+
+    <!-- Custom IM protocol type -->
+    <string name="imProtocolCustom">Custom</string>
+    <!-- AIM IM protocol type -->
+    <string name="imProtocolAim">AIM</string>
+    <!-- MSN IM protocol type -->
+    <string name="imProtocolMsn">Windows Live</string>
+    <!-- Yahoo IM protocol type -->
+    <string name="imProtocolYahoo">Yahoo</string>
+    <!-- Skype IM protocol type -->
+    <string name="imProtocolSkype">Skype</string>
+    <!-- QQ IM protocol type -->
+    <string name="imProtocolQq">QQ</string>
+    <!-- Google Talk IM protocol type -->
+    <string name="imProtocolGoogleTalk">Hangouts</string>
+    <!-- ICQ IM protocol type -->
+    <string name="imProtocolIcq">ICQ</string>
+    <!-- Jabber IM protocol type -->
+    <string name="imProtocolJabber">Jabber</string>
+    <!-- NetMeeting IM protocol type -->
+    <string name="imProtocolNetMeeting">NetMeeting</string>
+
+    <!-- Work organization type -->
+    <string name="orgTypeWork">Work</string>
+    <!-- Other organization type -->
+    <string name="orgTypeOther">Other</string>
+    <!-- Custom organization type -->
+    <string name="orgTypeCustom">Custom</string>
+
+    <!-- Custom relationship custom [CHAR LIMIT=20] -->
+    <string name="relationTypeCustom">Custom</string>
+    <!-- Assistant relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeAssistant">Assistant</string>
+    <!-- Brother relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeBrother">Brother</string>
+    <!-- Child relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeChild">Child</string>
+    <!-- Domestic Partner relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeDomesticPartner">Domestic partner</string>
+    <!-- Father relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeFather">Father</string>
+    <!-- Friend relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeFriend">Friend</string>
+    <!-- Manager relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeManager">Manager</string>
+    <!-- Mother relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeMother">Mother</string>
+    <!-- Parent relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeParent">Parent</string>
+    <!-- Partner relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypePartner">Partner</string>
+    <!-- Referred by relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeReferredBy">Referred by</string>
+    <!-- Relative relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeRelative">Relative</string>
+    <!-- Sister relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeSister">Sister</string>
+    <!-- Spouse relationship type [CHAR LIMIT=20] -->
+    <string name="relationTypeSpouse">Spouse</string>
+
+    <!-- Custom SIP address type. Same context as Custom phone type.  -->
+    <string name="sipAddressTypeCustom">Custom</string>
+    <!-- Home SIP address type. Same context as Home phone type. -->
+    <string name="sipAddressTypeHome">Home</string>
+    <!-- Work SIP address type. Same context as Work phone type. -->
+    <string name="sipAddressTypeWork">Work</string>
+    <!-- Other SIP address type. Same context as Other phone type. -->
+    <string name="sipAddressTypeOther">Other</string>
+
+    <!-- Error message that is displayed when the user clicks on a quick contacts badge, but
+         there is no contacts application installed that can display the quick contact -->
+    <string name="quick_contacts_not_available">No application found to view this contact.</string>
+
+    <!-- Instructions telling the user to enter their SIM PIN to unlock the keyguard.
+         Displayed in one line in a large font.  -->
+    <string name="keyguard_password_enter_pin_code">Type PIN code</string>
+
+    <!-- Instructions telling the user to enter their SIM PUK to unlock the keyguard.
+         Displayed in one line in a large font.  -->
+    <string name="keyguard_password_enter_puk_code">Type PUK and new PIN code</string>
+
+    <!-- Prompt to enter SIM PUK in Edit Text Box in unlock screen -->
+    <string name="keyguard_password_enter_puk_prompt">PUK code</string>
+    <!-- Prompt to enter New SIM PIN in Edit Text Box in unlock screen -->
+    <string name="keyguard_password_enter_pin_prompt">New PIN code</string>
+
+    <!-- Displayed as hint in passwordEntry EditText on PasswordUnlockScreen [CHAR LIMIT=30]-->
+    <string name="keyguard_password_entry_touch_hint"><font size="17">Tap to type password</font></string>
+
+    <!-- Instructions telling the user to enter their text password to unlock the keyguard.
+         Displayed in one line in a large font.  -->
+    <string name="keyguard_password_enter_password_code">Type password to unlock</string>
+
+    <!-- Instructions telling the user to enter their PIN password to unlock the keyguard.
+         Displayed in one line in a large font.  -->
+    <string name="keyguard_password_enter_pin_password_code">Type PIN to unlock</string>
+
+    <!-- Instructions telling the user that they entered the wrong pin while trying
+         to unlock the keyguard.  Displayed in one line in a large font.  -->
+    <string name="keyguard_password_wrong_pin_code">Incorrect PIN code.</string>
+
+    <!-- Instructions telling the user how to unlock the phone. -->
+    <string name="keyguard_label_text">To unlock, press Menu then 0.</string>
+
+    <!-- This can be used in any application wanting to disable the text "Emergency number" -->
+    <string name="emergency_call_dialog_number_for_display">Emergency number</string>
+
+    <!--
+       *** touch based lock / unlock ***
+                                          --> <skip/>
+
+    <!-- On the keyguard screen, it shows the carrier the phone is connected to.  This is displayed if the phone is not connected to a carrier.-->
+    <string name="lockscreen_carrier_default">No service</string>
+
+    <!-- Shown in the lock screen to tell the user that the screen is locked. -->
+    <string name="lockscreen_screen_locked">Screen locked.</string>
+
+    <!-- when pattern lock is enabled, tell them about the emergency dial -->
+    <string name="lockscreen_instructions_when_pattern_enabled">Press Menu to unlock or place emergency call</string>
+
+    <!-- On the keyguard screen, when pattern lock is disabled, only tell them to press menu to unlock.  This is shown in small font at the bottom. -->
+    <string name="lockscreen_instructions_when_pattern_disabled">Press Menu to unlock.</string>
+
+    <!-- On the unlock pattern screen, shown at the top of the unlock screen to tell the user what to do. Below this text is the place for theu ser to draw the pattern. -->
+    <string name="lockscreen_pattern_instructions">Draw pattern to unlock</string>
+    <!-- Button at the bottom of the unlock screen to make an emergency call or access other emergency assistance functions. -->
+    <string name="lockscreen_emergency_call">Emergency</string>
+    <!-- Button at the bottom of the unlock screen that lets the user return to a call -->
+    <string name="lockscreen_return_to_call">Return to call</string>
+    <!-- Shown to confirm that the user entered their lock pattern correctly. -->
+    <string name="lockscreen_pattern_correct">Correct</string>
+    <!-- On the unlock pattern screen, shown when the user enters the wrong lock pattern and must try again. -->
+    <string name="lockscreen_pattern_wrong">Try again</string>
+    <!-- On the unlock password screen, shown when the user enters the wrong lock password and must try again. -->
+    <string name="lockscreen_password_wrong">Try again</string>
+
+    <!-- On the keyguard screen, this string explains that some features or data may not be available until the device is unlocked. [CHAR LIMIT=48] -->
+    <string name="lockscreen_storage_locked">Unlock for all features and data</string>
+
+    <!-- Shown when face unlock failed multiple times so we're just using the backup -->
+    <string name="faceunlock_multiple_failures">Maximum Face Unlock attempts exceeded</string>
+
+    <!-- Shown in the lock screen when there is no SIM card. -->
+    <string name="lockscreen_missing_sim_message_short">No SIM card</string>
+    <!-- Shown in the lock screen when there is no SIM card. -->
+    <string name="lockscreen_missing_sim_message" product="tablet">No SIM card in tablet.</string>
+    <!-- Shown in the lock screen when there is no SIM card. -->
+    <string name="lockscreen_missing_sim_message" product="tv">No SIM card in TV.</string>
+    <!-- Shown in the lock screen when there is no SIM card. -->
+    <string name="lockscreen_missing_sim_message" product="default">No SIM card in phone.</string>
+    <!-- Shown in the lock screen to ask the user to insert a SIM card. -->
+    <string name="lockscreen_missing_sim_instructions">Insert a SIM card.</string>
+    <!-- Shown in the lock screen to ask the user to insert a SIM card when sim is missing or not readable. -->
+    <string name="lockscreen_missing_sim_instructions_long">The SIM card is missing or not readable. Insert a SIM card.</string>
+    <!-- Shown in the lock screen when SIM card is permanently disabled. -->
+    <string name="lockscreen_permanent_disabled_sim_message_short">Unusable SIM card.</string>
+    <!-- Shown in the lock screen to inform the user to SIM card is permanently disabled. -->
+    <string name="lockscreen_permanent_disabled_sim_instructions">Your SIM card has been permanently disabled.\n Contact your wireless service provider for another SIM card.</string>
+
+    <!-- Shown on transport control of lockscreen. Pressing button goes to previous track. -->
+    <string name="lockscreen_transport_prev_description">Previous track</string>
+    <!-- Shown on transport control of lockscreen. Pressing button goes to next track. -->
+    <string name="lockscreen_transport_next_description">Next track</string>
+    <!-- Shown on transport control of lockscreen. Pressing button pauses playback -->
+    <string name="lockscreen_transport_pause_description">Pause</string>
+    <!-- Shown on transport control of lockscreen. Pressing button pauses playback -->
+    <string name="lockscreen_transport_play_description">Play</string>
+    <!-- Shown on transport control of lockscreen. Pressing button pauses playback -->
+    <string name="lockscreen_transport_stop_description">Stop</string>
+    <!-- Shown on transport control screens. Pressing button rewinds playback [CHAR LIMIT=NONE]-->
+    <string name="lockscreen_transport_rew_description">Rewind</string>
+    <!-- Shown on transport control screens. Pressing button fast forwards playback [CHAR LIMIT=NONE]-->
+    <string name="lockscreen_transport_ffw_description">Fast forward</string>
+
+    <!-- Shown in the lock screen when there is emergency calls only mode. -->
+    <string msgid="2485604591272668370" name="emergency_calls_only">Emergency calls only</string>
+
+    <!-- When the user inserts a sim card from an unsupported network, it becomes network
+         locked -->
+    <string name="lockscreen_network_locked_message">Network locked</string>
+
+
+    <!-- When the user enters a wrong sim pin too many times, it becomes
+         PUK locked (Pin Unlock Kode) -->
+    <string name="lockscreen_sim_puk_locked_message">SIM card is PUK\u2011locked.</string>
+    <!-- Shown in the lock screen when the SIM has become PUK locked and the user must call customer care to unlock it. -->
+    <string name="lockscreen_sim_puk_locked_instructions">See the User Guide or contact Customer Care.</string>
+
+    <!-- Shown in the lock screen to tell the user that their SIM is locked and they must unlock it. -->
+    <string name="lockscreen_sim_locked_message">SIM card is locked.</string>
+
+    <!-- For the unlock screen, When the user enters a sim unlock code, it takes a little while to check
+         whether it is valid, and to unlock the sim if it is valid.  we display a
+         progress dialog in the meantime.  this is the emssage. -->
+    <string name="lockscreen_sim_unlock_progress_dialog_message">Unlocking SIM card\u2026</string>
+
+    <!-- For the unlock screen, Information message shown in dialog when user has too many failed attempts at
+         drawing the unlock pattern -->
+    <string name="lockscreen_too_many_failed_attempts_dialog_message">You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, Information message shown in dialog when user has too many failed attempts at
+         entering the password -->
+    <string name="lockscreen_too_many_failed_password_attempts_dialog_message">You have incorrectly typed your password <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, Information message shown in dialog when user has too many failed attempts at
+         entering the PIN -->
+    <string name="lockscreen_too_many_failed_pin_attempts_dialog_message">You have incorrectly typed your PIN <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where they will be locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="lockscreen_failed_attempts_almost_glogin" product="tablet"> You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your tablet using your Google signin.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where they will be locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="lockscreen_failed_attempts_almost_glogin" product="tv"> You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your TV using your Google signin.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where they will be locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="lockscreen_failed_attempts_almost_glogin" product="default">You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your phone using your Google signin.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where the device will be wiped. -->
+    <string name="lockscreen_failed_attempts_almost_at_wipe" product="tablet"> You have incorrectly attempted to unlock the tablet <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the tablet will be reset to factory default and all user data will be lost. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where the device will be wiped. -->
+    <string name="lockscreen_failed_attempts_almost_at_wipe" product="tv"> You have incorrectly attempted to unlock the TV <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the TV will be reset to factory default and all user data will be lost. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user is almost at the limit
+         where the device will be wiped. -->
+    <string name="lockscreen_failed_attempts_almost_at_wipe" product="default">You have incorrectly attempted to unlock the phone <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the phone will be reset to factory default and all user data will be lost. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user has exceeded the
+        maximum attempts and the device will now be wiped -->
+    <string name="lockscreen_failed_attempts_now_wiping" product="tablet"> You have incorrectly attempted to unlock the tablet <xliff:g id="number">%d</xliff:g> times. The tablet will now be reset to factory default. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user has exceeded the
+        maximum attempts and the device will now be wiped -->
+    <string name="lockscreen_failed_attempts_now_wiping" product="tv"> You have incorrectly attempted to unlock the TV <xliff:g id="number">%d</xliff:g> times. The TV will now be reset to factory default. </string>
+
+    <!-- For the unlock screen, informational message shown in dialog when user has exceeded the
+        maximum attempts and the device will now be wiped -->
+    <string name="lockscreen_failed_attempts_now_wiping" product="default">You have incorrectly attempted to unlock the phone <xliff:g id="number">%d</xliff:g> times. The phone will now be reset to factory default. </string>
+
+    <!-- On the unlock screen, countdown message shown while user is waiting to try again after too many
+         failed attempts -->
+    <string name="lockscreen_too_many_failed_attempts_countdown">Try again in <xliff:g id="number">%d</xliff:g> seconds.</string>
+
+    <!-- On the unlock screen, message shown on button that appears once it's apparent the user may have forgotten
+         their lock gesture -->
+    <string name="lockscreen_forgot_pattern_button_text">Forgot pattern?</string>
+
+    <!-- Title of the unlock screen that uses your Google login and password when the user hit
+         the 'forgot pattern' button.-->
+    <string name="lockscreen_glogin_forgot_pattern">Account unlock</string>
+    <!-- Title of the unlock screen that uses your Google login and password when the user attempted
+         too many patterns and we are forcing them to use their account instead. -->
+    <string name="lockscreen_glogin_too_many_attempts">Too many pattern attempts</string>
+    <!-- In the unlock screen, message telling the user that they need to use their Google login and password to unlock the phone -->
+    <string name="lockscreen_glogin_instructions">To unlock, sign in with your Google account.</string>
+    <!-- Hint caption for the username field when unlocking the phone using login and password -->
+    <string name="lockscreen_glogin_username_hint">Username (email)</string>
+    <!-- Hint caption for the password field when unlocking the phone using login and password -->
+    <string name="lockscreen_glogin_password_hint">Password</string>
+    <!-- Button to try to unlock the phone using username and password -->
+    <string name="lockscreen_glogin_submit_button">Sign in</string>
+    <!-- Displayed to the user when unlocking the phone with a username and password fails. -->
+    <string name="lockscreen_glogin_invalid_input">Invalid username or password.</string>
+    <!-- Hint displayed on account unlock screen to advise the user on how to recover the account. -->
+    <string name="lockscreen_glogin_account_recovery_hint">Forgot your username or password\?\nVisit <b>google.com/accounts/recovery</b>.</string>
+
+    <!-- Displayed in a progress dialog while a username and password are being checked. -->
+    <string name="lockscreen_glogin_checking_password">Checking\u2026</string>
+    <!-- Displayed on lock screen's left tab - unlock -->
+    <string name="lockscreen_unlock_label">Unlock</string>
+    <!-- Displayed on lock screen's right tab - turn sound on -->
+    <string name="lockscreen_sound_on_label">Sound on</string>
+    <!-- Displayed on lock screen's right tab - turn sound off -->
+    <string name="lockscreen_sound_off_label">Sound off</string>
+
+    <!-- Accessibility description sent when user starts drawing a lock pattern. [CHAR LIMIT=NONE] -->
+    <string name="lockscreen_access_pattern_start">Pattern started</string>
+    <!-- Accessibility description sent when the pattern times out and is cleared. [CHAR LIMIT=NONE] -->
+    <string name="lockscreen_access_pattern_cleared">Pattern cleared</string>
+    <!-- Accessibility description sent when user adds a dot to the pattern. [CHAR LIMIT=NONE]  -->
+    <string name="lockscreen_access_pattern_cell_added">Cell added</string>
+    <!-- Accessibility description sent when user adds a dot to the pattern. Announces the
+    actual cell when headphones are connected [CHAR LIMIT=NONE]  -->
+    <string name="lockscreen_access_pattern_cell_added_verbose">Cell <xliff:g example="3" id="cell_index">%1$s</xliff:g> added</string>
+    <!-- Accessibility description sent when user completes drawing a pattern. [CHAR LIMIT=NONE] -->
+    <string name="lockscreen_access_pattern_detected">Pattern completed</string>
+    <!-- Accessibility description of the unlock pattern area. [CHAR_LIMIT=none] -->
+    <string msgid="" name="lockscreen_access_pattern_area">Pattern area.</string>
+
+    <!-- Accessibility description sent when user changes the current lock screen widget. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget_changed">%1$s. Widget %2$d of %3$d.</string>
+    <!-- Accessibility description of the add widget button. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_add_widget">Add widget.</string>
+    <!-- Accessibility description of the empty sidget slot (place holder for a new widget). [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget_empty_slot">Empty</string>
+    <!-- Accessibility description of the event of expanding an unlock area. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_unlock_area_expanded">Unlock area expanded.</string>
+    <!-- Accessibility description of the event of collapsing an unlock area. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_unlock_area_collapsed">Unlock area collapsed.</string>
+    <!-- Accessibility description of a lock screen widget. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget"><xliff:g id="widget_index">%1$s</xliff:g> widget.</string>
+    <!-- Accessibility description of the lock screen user selector widget. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_user_selector">User selector</string>
+    <!-- Accessibility description of the lock screen status widget. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_status">Status</string>
+    <!-- Accessibility description of the camera widget. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_camera">Camera</string>
+    <!-- Accessibility description of the lock media control widget. [CHAR_LIMIT=none] -->
+    <string name="keygaurd_accessibility_media_controls">Media controls</string>
+    <!-- Accessibility description of widget reordering start. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget_reorder_start">Widget reordering started.</string>
+    <!-- Accessibility description of widget reordering end. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget_reorder_end">Widget reordering ended.</string>
+    <!-- Accessibility description of the a widget deletion event. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_widget_deleted">Widget <xliff:g id="widget_index">%1$s</xliff:g> deleted.</string>
+    <!-- Accessibility description of the button to expand the lock area. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_expand_lock_area">Expand unlock area.</string>
+    <!-- Accessibility description of the slide unlock. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_slide_unlock">Slide unlock.</string>
+    <!-- Accessibility description of the pattern unlock. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_pattern_unlock">Pattern unlock.</string>
+    <!-- Accessibility description of the face unlock. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_face_unlock">Face unlock.</string>
+    <!-- Accessibility description of the pin lock. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_pin_unlock">Pin unlock.</string>
+    <!-- Accessibility description of the password lock. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_password_unlock">Password unlock.</string>
+    <!-- Accessibility description of the unlock pattern area. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_pattern_area">Pattern area.</string>
+    <!-- Accessibility description of the unlock slide area. [CHAR_LIMIT=none] -->
+    <string name="keyguard_accessibility_slide_area">Slide area.</string>
+
+    <!-- Password keyboard strings. Used by LockScreen and Settings --><skip/>
+    <!-- Label for "switch to symbols" key.  Must be short to fit on key! -->
+    <string name="password_keyboard_label_symbol_key">\?123</string>
+    <!-- Label for "switch to alphabetic" key.  Must be short to fit on key! -->
+    <string name="password_keyboard_label_alpha_key">ABC</string>
+    <!-- Label for ALT modifier key.  Must be short to fit on key! -->
+    <string name="password_keyboard_label_alt_key">ALT</string>
+
+    <!-- Label for granularity to traverse the content on an AccessibilityNodeInfo by character. Only spoken to the user. [CHAR LIMIT=NONE] -->
+    <string name="granularity_label_character">character</string>
+    <!-- Label for granularity to traverse the content on an AccessibilityNodeInfo by word. Only spoken to the user. [CHAR LIMIT=NONE] -->
+    <string name="granularity_label_word">word</string>
+    <!-- Label for granularity to traverse the content on an AccessibilityNodeInfo by link. Only spoken to the user. [CHAR LIMIT=NONE] -->
+    <string name="granularity_label_link">link</string>
+    <!-- Label for granularity to traverse the content on an AccessibilityNodeInfo by line. Only spoken to the user. [CHAR LIMIT=NONE] -->
+    <string name="granularity_label_line">line</string>
+
+    <!-- Title of the alert when something went wrong in the factory test. -->
+    <string name="factorytest_failed">Factory test failed</string>
+    <!-- Error message displayed when a non-system application tries to start a factory test. -->
+    <string name="factorytest_not_system">The FACTORY_TEST action is only supported for packages installed in /system/app.</string>
+    <!-- Error message displayed when the factory test could not be started. -->
+    <string name="factorytest_no_action">No package was found that provides the FACTORY_TEST action.</string>
+    <!-- Button to restart the device after the factory test. -->
+    <string name="factorytest_reboot">Reboot</string>
+
+    <!-- Do not translate.  WebView User Agent string -->
+    <string name="web_user_agent" translatable="false">Mozilla/5.0 (Linux; U; <xliff:g id="x">Android %s</xliff:g>) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 <xliff:g id="mobile">%s</xliff:g>Safari/537.36</string>
+    <!-- Do not translate.  WebView User Agent targeted content -->
+    <string name="web_user_agent_target_content" translatable="false">Mobile </string>
+
+    <!-- Title for a JavaScript dialog. "The page at <url of current page> says:" -->
+    <string name="js_dialog_title">The page at \"<xliff:g id="title">%s</xliff:g>\" says:</string>
+    <!-- Default title for a javascript dialog -->
+    <string name="js_dialog_title_default">JavaScript</string>
+    <!-- Title for the unload javascript dialog -->
+    <string name="js_dialog_before_unload_title">Confirm Navigation</string>
+    <!-- Text for the positive button on the unload javascript dialog -->
+    <string name="js_dialog_before_unload_positive_button">Leave this Page</string>
+    <!-- Text for the negative button on the unload javascript dialog -->
+    <string name="js_dialog_before_unload_negative_button">Stay on this Page</string>
+    <!-- Message in a javascript dialog asking if the user wishes to leave the current page -->
+    <string name="js_dialog_before_unload"><xliff:g id="message">%s</xliff:g>\n\nAre you sure you want to navigate away from this page?</string>
+
+    <!-- Title of the WebView save password dialog.  If the user enters a password in a form on a website, a dialog will come up asking if they want to save the password. -->
+    <string name="save_password_label">Confirm</string>
+
+    <!-- Toast for double-tap -->
+    <string name="double_tap_toast">Tip: Double\u2011tap to zoom in and out.</string>
+
+    <!-- Text to show in the auto complete drop down list on a text view when the WebView can auto fill the entire form, and the user has configured an AutoFill profile [CHAR-LIMIT=8] -->
+    <string name="autofill_this_form">Autofill</string>
+    <!-- Text to show in the auto complete drop down list on a text view when the WebView can auto fill the entire form but the user has not configured an AutoFill profile [CHAR-LIMIT=19] -->
+    <string name="setup_autofill">Set up Autofill</string>
+
+    <!-- String used to separate FirstName and LastName when writing out a local name
+         e.g. John<separator>Smith [CHAR-LIMIT=NONE]-->
+    <string name="autofill_address_name_separator">\u0020</string>
+    <!-- Format string for displaying a name. $1 is First Name, $2 is autofill_address_name_separator, $3 is Last Name.
+         e.g. (John)( )(Smith) -->
+    <string name="autofill_address_summary_name_format">$1$2$3</string>
+
+    <!-- String used to separate Name and Address Line 1
+         e.g. John Smith<separator>123 Main Street [CHAR-LIMIT=NONE]-->
+    <string name="autofill_address_summary_separator">,\u0020</string>
+    <!-- Format string for displaying a name and address summary. $1 is the Full Name, $2 is autofill_address_summary_separator, $3 is the Address
+         e.g. (John Smith)(, )(123 Main Street) -->
+    <string name="autofill_address_summary_format">$1$2$3</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_attention_ignored_re">attention|attn</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_region_ignored_re">province|region|other<!-- es -->|provincia<!-- pt-BR, pt-PT -->|bairro|suburb</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_company_re">company|business|organization|organisation|department<!-- de-DE -->|firma|firmenname<!-- es -->|empresa<!-- fr-FR -->|societe|société<!-- it-IT -->|ragione.?sociale<!-- ja-JP -->|会社<!-- ru -->|название.?компании<!-- zh-CN -->|单位|公司</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_line_1_re">address.?line|address1|addr1|street<!-- de-DE -->|strasse|straße|hausnummer|housenumber<!-- en-GB -->|house.?name<!-- es -->|direccion|dirección<!-- fr-FR -->|adresse<!-- it-IT -->|indirizzo<!-- ja-JP -->|住所1<!-- pt-BR, pt-PT -->|morada|endereço<!-- ru -->|Адрес<!-- zh-CN -->|地址</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_line_1_label_re">address<!-- fr-FR -->|adresse<!-- it-IT -->|indirizzo<!-- ja-JP -->|住所<!-- zh-CN -->|地址</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_line_2_re">address.?line2|address2|addr2|street|suite|unit<!-- de-DE -->|adresszusatz|ergänzende.?angaben<!-- es -->|direccion2|colonia|adicional<!-- fr-FR -->|addresssuppl|complementnom|appartement<!-- it-IT -->|indirizzo2<!-- ja-JP -->|住所2</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_line_3_re">address.?line3|address3|addr3|street|line3<!-- es -->|municipio<!-- fr-FR -->|batiment|residence<!-- it-IT -->|indirizzo3</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_country_re">country|location<!-- ja-JP -->|国<!-- zh-CN -->|国家</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_zip_code_re">zip|postal|post code|pcode|^1z$<!-- de-DE -->|postleitzahl<!-- es -->|cp<!-- fr-FR -->|cdp<!-- it-IT -->|cap<!-- ja-JP -->|郵便番号<!-- pt-BR, pt-PT -->|codigo|codpos|cep<!-- ru -->|Почтовый.?Индекс<!--zh-CN -->|邮政编码|邮编<!-- zh-TW -->|郵遞區號</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_zip_4_re">zip|^-$|post2<!-- pt-BR, pt-PT -->|codpos2</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_city_re">city|town<!-- de-DE -->|ort|stadt<!-- en-AU -->|suburb<!-- es -->|ciudad|provincia|localidad|poblacion<!-- fr-FR -->|ville|commune<!-- it-IT -->|localita<!-- ja-JP -->|市区町村<!-- pt-BR, pt-PT -->|cidade<!-- ru -->|Город<!-- zh-CN -->|市<!-- zh-TW -->|分區</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_state_re">state|county|region|province<!-- de-DE -->|land<!-- en-UK -->|county|principality<!-- ja-JP -->|都道府県<!-- pt-BR, pt-PT -->|estado|provincia<!-- ru -->|область<!-- zh-CN -->|省<!-- zh-TW -->|地區</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_type_same_as_re">same as</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_address_type_use_my_re">use my</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_billing_designator_re">bill</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_shipping_designator_re">ship</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_email_re">e.?mail<!-- ja-JP -->|メールアドレス<!-- ru -->|Электронной.?Почты<!-- zh-CN -->|邮件|邮箱<!-- zh-TW -->|電郵地址</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_username_re">user.?name|user.?id<!-- de-DE -->|vollständiger.?name<!-- zh-CN -->|用户名</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_name_re">^name|full.?name|your.?name|customer.?name|firstandlastname<!-- es -->|nombre.*y.*apellidos<!-- fr-FR -->|^nom<!-- ja-JP -->|お名前|氏名<!-- pt-BR, pt-PT -->|^nome<!-- zh-CN -->|姓名</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_name_specific_re">^name<!-- fr-FR -->|^nom<!-- pt-BR, pt-PT -->|^nome</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+
+    <string name="autofill_first_name_re">irst.*name|initials|fname|first$<!-- de-DE -->|vorname<!-- es -->|nombre<!-- fr-FR -->|forename|prénom|prenom<!-- ja-JP -->|名<!-- pt-BR, pt-PT -->|nome<!-- ru -->|Имя</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_middle_initial_re">middle.*initial|m\\.i\\.|mi$</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_middle_name_re">middle.*name|mname|middle$<!-- es -->|apellido.?materno|lastlastname</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_last_name_re">last.*name|lname|surname|last$<!-- de-DE -->|nachname<!-- es -->|apellidos<!-- fr-FR -->|famille|^nom<!-- it-IT -->|cognome<!-- ja-JP -->|姓<!-- pt-BR, pt-PT -->|morada|apelidos|surename|sobrenome<!-- ru -->|Фамилия</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_re">phone<!-- de-DE -->|telefonnummer<!-- es -->|telefono|teléfono<!-- fr-FR -->|telfixe<!-- ja-JP -->|電話<!-- pt-BR, pt-PT -->|telefone|telemovel<!-- ru -->|телефон<!-- zh-CN -->|电话</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_area_code_re">area.*code|acode|area</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_prefix_re">prefix<!-- fr-FR -->|preselection<!-- pt-BR, pt-PT -->|ddd</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_suffix_re">suffix</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_extension_re">ext<!-- pt-BR, pt-PT -->|ramal</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_name_on_card_re">card.?holder|name.?on.?card|ccname|owner<!-- de-DE -->|karteninhaber<!-- es -->|nombre.*tarjeta<!-- fr-FR -->|nom.*carte<!-- it-IT -->|nome.*cart<!-- ja-JP -->|名前<!-- ru -->|Имя.*карты<!-- zh-CN -->|信用卡开户名|开户名|持卡人姓名<!-- zh-TW -->|持卡人姓名</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_name_on_card_contextual_re">name</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_card_cvc_re">verification|card identification|cvn|security code|cvv code|cvc</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_card_number_re">number|card.?#|card.?no|ccnum<!-- de-DE -->|nummer<!-- es -->|credito|numero|número<!-- fr-FR -->|numéro<!-- ja-JP -->|カード番号<!-- ru -->|Номер.*карты<!-- zh-CN -->|信用卡号|信用卡号码<!-- zh-TW -->|信用卡卡號</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_expiration_month_re">expir|exp.*month|exp.*date|ccmonth<!-- de-DE -->|gueltig|gültig|monat<!-- es -->|fecha<!-- fr-FR -->|date.*exp<!-- it-IT -->|scadenza<!-- ja-JP -->|有効期限<!-- pt-BR, pt-PT -->|validade<!-- ru -->|Срок действия карты<!-- zh-CN -->|月</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_expiration_date_re">exp|^/|year<!-- de-DE -->|ablaufdatum|gueltig|gültig|yahr<!-- es -->|fecha<!-- it-IT -->|scadenza<!-- ja-JP -->|有効期限<!-- pt-BR, pt-PT -->|validade<!-- ru -->|Срок действия карты<!-- zh-CN -->|年|有效期</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_card_ignored_re">^card</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_fax_re">fax<!-- fr-FR -->|télécopie|telecopie<!-- ja-JP -->|ファックス<!-- ru -->|факс<!-- zh-CN -->|传真<!-- zh-TW -->|傳真</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_country_code_re">country.*code|ccode|_cc</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_area_code_notext_re">^\\($</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_prefix_separator_re">^-$|^\\)$</string>
+
+    <!-- Do not translate. Regex used by AutoFill. -->
+    <string name="autofill_phone_suffix_separator_re">^-$</string>
+
+    <!-- Label in a web form for "Province" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_province">Province</string>
+
+    <!-- Label in a web form for "Postal code" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_postal_code">Postal code</string>
+
+    <!-- Label in a web form for "State" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_state">State</string>
+
+    <!-- Label in a web form for "ZIP code" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_zip_code">ZIP code</string>
+
+    <!-- Label in a web form for "County" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_county">County</string>
+
+    <!-- Label in a web form for "Island" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_island">Island</string>
+
+    <!-- Label in a web form for "District" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_district">District</string>
+
+    <!-- Label in a web form for "Department" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_department">Department</string>
+
+    <!-- Label in a web form for "Prefecture" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_prefecture">Prefecture</string>
+
+    <!-- Label in a web form for "Parish" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_parish">Parish</string>
+
+    <!-- Label in a web form for "Area" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_area">Area</string>
+
+    <!-- Label in a web form for "Emirate" [CHAR-LIMIT=NONE]  -->
+    <string name="autofill_emirate">Emirate</string>
+
+
+    <!-- Title of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permlab_readHistoryBookmarks">read your Web bookmarks and history</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_readHistoryBookmarks">Allows the app to read the history of all URLs that the Browser has visited, and all of the Browser\'s bookmarks. Note: this permission may not be enforced by third\u2011party browsers or other applications with web browsing capabilities.</string>
+    <!-- Title of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+
+    <string name="permlab_writeHistoryBookmarks">write web bookmarks and history</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_writeHistoryBookmarks" product="tablet">Allows the app to modify the Browser\'s history or bookmarks stored on your tablet. This may allow the app to erase or modify Browser data. Note: this permission may note be enforced by third-party browsers or other applications with web browsing capabilities.</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_writeHistoryBookmarks" product="tv">Allows the app to modify the Browser\'s history or bookmarks stored on your TV. This may allow the app to erase or modify Browser data. Note: this permission may note be enforced by third\u2011party browsers or other applications with web browsing capabilities.</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_writeHistoryBookmarks" product="default">Allows the app to modify the Browser\'s history or bookmarks stored on your phone. This may allow the app to erase or modify Browser data. Note: this permission may note be enforced by third\u2011party browsers or other applications with web browsing capabilities.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether
+    they want to allow the application to do this. -->
+    <string name="permlab_setAlarm">set an alarm</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_setAlarm">Allows the app to set an alarm in an installed alarm clock app. Some alarm clock apps may not implement this feature.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. [CHAR LIMIT=NONE] -->
+    <string name="permlab_addVoicemail">add voicemail</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. [CHAR LIMIT=NONE] -->
+    <string name="permdesc_addVoicemail">Allows the app to add messages to your voicemail inbox.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permlab_writeGeolocationPermissions">modify Browser geolocation permissions</string>
+    <!-- Description of an application permission, listed so the user can choose whether
+        they want to allow the application to do this. -->
+    <string name="permdesc_writeGeolocationPermissions">Allows the app to modify the Browser\'s geolocation permissions. Malicious apps may use this to allow sending location information to arbitrary websites.</string>
+
+    <!-- If the user enters a password in a form on a website, a dialog will come up asking if they want to save the password. Text in the save password dialog, asking if the browser should remember a password. -->
+    <string name="save_password_message">Do you want the browser to remember this password?</string>
+    <!-- If the user enters a password in a form on a website, a dialog will come up asking if they want to save the password. Button in the save password dialog, saying not to remember this password. -->
+    <string name="save_password_notnow">Not now</string>
+    <!-- If the user enters a password in a form on a website, a dialog will come up asking if they want to save the password. Button in the save password dialog, saying to remember this password. -->
+    <string name="save_password_remember">Remember</string>
+    <!-- Button in the save password dialog, saying never to remember this password. This should be short. Should be "Never for this site". But it is too long, use "Never" instead -->
+    <string name="save_password_never">Never</string>
+
+    <!-- Displayed to the user when they do not have permission to open a particular web page. -->
+    <string name="open_permission_deny">You don\'t have permission to open this page</string>
+
+    <!-- Displayed to the user to confirm that they have copied text from a web page to the clipboard. -->
+    <string name="text_copied">Text copied to clipboard.</string>
+
+    <!-- Menu item displayed at the end of a menu to allow users to see another page worth of menu items. This is shown on any app's menu as long as the app has too many items in the menu.-->
+    <string name="more_item_label">More</string>
+    <!-- Prepended to the shortcut for a menu item to indicate that the user should hold the MENU button together with the shortcut to invoke the item. For example, if the shortcut to open a new tab in browser is MENU and B together, then this would be prepended to the letter "B" -->
+    <string name="prepend_shortcut_label">Menu+</string>
+    <!-- Displayed in place of the regular shortcut letter when a menu item has Menu+space for the shortcut. -->
+    <string name="menu_space_shortcut_label">space</string>
+    <!-- Displayed in place of the regular shortcut letter when a menu item has Menu+enter for the shortcut. -->
+    <string name="menu_enter_shortcut_label">enter</string>
+    <!-- Displayed in place of the regular shortcut letter when a menu item has Menu+delete for the shortcut. -->
+    <string name="menu_delete_shortcut_label">delete</string>
+
+    <!-- Strings used for search bar --><skip/>
+
+    <!-- This is the default button label in the system-wide search UI.
+         It is also used by the home screen's search "widget". It should be short -->
+    <string name="search_go">Search</string>
+    <!-- Default hint text for the system-wide search UI's text field. [CHAR LIMIT=30] -->
+    <string name="search_hint">Search…</string>
+    <!-- SearchView accessibility description for search button [CHAR LIMIT=NONE] -->
+    <string name="searchview_description_search">Search</string>
+    <!-- SearchView accessibility description for search text field [CHAR LIMIT=NONE] -->
+    <string name="searchview_description_query">Search query</string>
+    <!-- SearchView accessibility description for clear button [CHAR LIMIT=NONE] -->
+    <string name="searchview_description_clear">Clear query</string>
+    <!-- SearchView accessibility description for submit button [CHAR LIMIT=NONE] -->
+    <string name="searchview_description_submit">Submit query</string>
+    <!-- SearchView accessibility description for voice button [CHAR LIMIT=NONE] -->
+    <string name="searchview_description_voice">Voice search</string>
+
+    <!-- Title for a warning message about the interaction model changes after allowing an accessibility
+         service to put the device into explore by touch mode, displayed as a dialog message when
+         the user selects to enables the service. (default). [CHAR LIMIT=45] -->
+    <string name="enable_explore_by_touch_warning_title">Enable Explore by Touch?</string>
+    <!-- Summary for a warning message about the interaction model changes after allowing an accessibility
+         service to put the device into explore by touch mode, displayed as a dialog message when
+         the user selects to enables the service. (tablet). [CHAR LIMIT=NONE] -->
+    <string name="enable_explore_by_touch_warning_message" product="tablet"> <xliff:g id="accessibility_service_name">%1$s</xliff:g> wants to enable Explore by Touch. When Explore by Touch is turned on, you can hear or see descriptions of what\'s under your finger or perform gestures to interact with the tablet.</string>
+    <!-- Summary for a warning message about the interaction model changes after allowing an accessibility
+         service to put the device into explore by touch mode, displayed as a dialog message when
+         the user selects to enables the service. (default). [CHAR LIMIT=NONE] -->
+    <string name="enable_explore_by_touch_warning_message" product="default"><xliff:g id="accessibility_service_name">%1$s</xliff:g> wants to enable Explore by Touch. When Explore by Touch is turned on, you can hear or see descriptions of what\'s under your finger or perform gestures to interact with the phone.</string>
+
+    <!-- String used to display the date. This is the string to say something happened 1 month ago. -->
+    <string name="oneMonthDurationPast">1 month ago</string>
+    <!-- String used to display the date. This is the string to say something happened more than 1 month ago. -->
+    <string name="beforeOneMonthDurationPast">Before 1 month ago</string>
+
+    <!-- This is used to express that something occurred within the last X days (e.g., Last 7 days). -->
+    <plurals name="last_num_days">
+        <item quantity="one">Last <xliff:g id="count">%d</xliff:g> day</item>
+        <item quantity="other">Last <xliff:g id="count">%d</xliff:g> days</item>
+    </plurals>
+
+    <!-- This is used to express that something has occurred within the last month -->
+    <string name="last_month">Last month</string>
+
+    <!-- This is used to express that something happened longer ago than the previous options -->
+    <string name="older">Older</string>
+
+    <!-- String used to display the date. Preposition for date display ("on May 29") -->
+    <string name="preposition_for_date">on <xliff:g example="May 29" id="date">%s</xliff:g></string>
+    <!-- String used to display the date. Preposition for time display ("at 2:33am") -->
+    <string name="preposition_for_time">at <xliff:g example="2:33 am" id="time">%s</xliff:g></string>
+    <!-- String used to display the date. Preposition for year display ("in 2008") -->
+    <string name="preposition_for_year">in <xliff:g example="2003" id="year">%s</xliff:g></string>
+
+    <!-- Appened to express the value is this unit of time: singular day -->
+    <string name="day">day</string>
+    <!-- Appened to express the value is this unit of time: plural days -->
+    <string name="days">days</string>
+    <!-- Appened to express the value is this unit of time: singular hour -->
+    <string name="hour">hour</string>
+    <!-- Appened to express the value is this unit of time: plural hours -->
+    <string name="hours">hours</string>
+    <!-- Appened to express the value is this unit of time: singular minute -->
+    <string name="minute">min</string>
+    <!-- Appened to express the value is this unit of time: plural minutes -->
+    <string name="minutes">mins</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="second">sec</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="seconds">secs</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="week">week</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="weeks">weeks</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="year">year</string>
+    <!-- Appened to express the value is this unit of time. -->
+    <string name="years">years</string>
+
+    <!-- Phrase describing a time duration using seconds [CHAR LIMIT=16] -->
+    <plurals name="duration_seconds">
+        <item quantity="one">1 second</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> seconds</item>
+    </plurals>
+    <!-- Phrase describing a time duration using minutes [CHAR LIMIT=16] -->
+    <plurals name="duration_minutes">
+        <item quantity="one">1 minute</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> minutes</item>
+    </plurals>
+    <!-- Phrase describing a time duration using hours [CHAR LIMIT=16] -->
+    <plurals name="duration_hours">
+        <item quantity="one">1 hour</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> hours</item>
+    </plurals>
+
+    <!-- A string denoting the current point in time that should be as short as possible. Abbreviations are preferred to full strings as this might be shown repetitively. It is used in the header of notifications. [CHAR LIMIT=8]-->
+    <string name="now_string_shortest">now</string>
+
+    <!-- Phrase describing a time duration using minutes that is as short as possible, preferrably one character. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=6] -->
+    <plurals name="duration_minutes_shortest">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g>m</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g>m</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using hours that is as short as possible, preferrably one character. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=6] -->
+    <plurals name="duration_hours_shortest">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g>h</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g>h</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using days that is as short as possible, preferrably one character. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=6] -->
+    <plurals name="duration_days_shortest">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g>d</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g>d</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using years that is as short as possible, preferrably one character. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=6] -->
+    <plurals name="duration_years_shortest">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g>y</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g>y</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using minutes that is as short as possible, preferrably one character. This version should be a future point in time. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=14] -->
+    <plurals name="duration_minutes_shortest_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g>m</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g>m</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using hours that is as short as possible, preferrably one character. This version should be a future point in time. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=14] -->
+    <plurals name="duration_hours_shortest_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g>h</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g>h</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using days that is as short as possible, preferrably one character. This version should be a future point in time. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=14] -->
+    <plurals name="duration_days_shortest_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g>d</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g>d</item>
+    </plurals>
+
+    <!-- Phrase describing a time duration using years that is as short as possible, preferrably one character. This version should be a future point in time. If the language needs a space in between the integer and the unit, please also integrate it in the string, but preferably it should not have a space in between.[CHAR LIMIT=14] -->
+    <plurals name="duration_years_shortest_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g>y</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g>y</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using minutes in the past that is not shown on the screen but used for accessibility. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_minutes_relative">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g> minute ago</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g> minutes ago</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using hours in the past that is not shown on the screen but used for accessibility. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_hours_relative">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g> hour ago</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g> hours ago</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using days in the past that is not shown on the screen but used for accessibility. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_days_relative">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g> day ago</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g> days ago</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using years in the past that is not shown on the screen but used for accessibility. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_years_relative">
+        <item quantity="one"><xliff:g example="1" id="count">%d</xliff:g> year ago</item>
+        <item quantity="other"><xliff:g example="2" id="count">%d</xliff:g> years ago</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using minutes that is not shown on the screen but used for accessibility. This version should be a future point in time. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_minutes_relative_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g> minute</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g> minutes</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using hours that is not shown on the screen but used for accessibility. This version should be a future point in time. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_hours_relative_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g> hour</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g> hours</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using days that is not shown on the screen but used for accessibility. This version should be a future point in time. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_days_relative_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g> day</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g> days</item>
+    </plurals>
+
+    <!-- Phrase describing a relative time using years that is not shown on the screen but used for accessibility. This version should be a future point in time. [CHAR LIMIT=NONE] -->
+    <plurals name="duration_years_relative_future">
+        <item quantity="one">in <xliff:g example="1" id="count">%d</xliff:g> year</item>
+        <item quantity="other">in <xliff:g example="2" id="count">%d</xliff:g> years</item>
+    </plurals>
+
+    <!-- Title for error alert when a video cannot be played.  it can be used by any app. -->
+    <string name="VideoView_error_title">Video problem</string>
+    <!-- Text for error alert when a video container is not valid for progressive download/playback. -->
+    <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device</string>
+    <!-- Text for error alert when a video cannot be played. it can be used by any app. -->
+    <string name="VideoView_error_text_unknown">Can\'t play this video</string>
+    <!-- Button to close error alert when a video cannot be played -->
+    <string name="VideoView_error_button">OK</string>
+
+
+
+
+    <!-- Format indicating a relative expression and time.
+         Example: "4 hours ago, 11:00 am" -->
+    <string name="relative_time"><xliff:g example="4 hours ago" id="date">%1$s</xliff:g>, <xliff:g example="11:00 am" id="time">%2$s</xliff:g></string>
+
+
+    <!-- Quoted name for 12pm, lowercase -->
+    <string name="noon">noon</string>
+    <!-- Quoted name for 12pm, uppercase first letter -->
+    <string name="Noon">Noon</string>
+    <!-- Quoted name for 12am, lowercase -->
+    <string name="midnight">midnight</string>
+    <!-- Quoted name for 12am, uppercase first letter -->
+    <string name="Midnight">Midnight</string>
+
+
+
+
+
+
+
+
+
+
+
+    <!-- Format string for durations like "01:23" (1 minute, 23 seconds) -->
+    <string name="elapsed_time_short_format_mm_ss"><xliff:g example="1" id="minutes">%1$02d</xliff:g>:<xliff:g example="23" id="seconds">%2$02d</xliff:g></string>
+
+    <!-- Format string for times like "1:43:33" (1 hour, 43 minutes, 33 seconds) -->
+    <string name="elapsed_time_short_format_h_mm_ss"><xliff:g example="1" id="hours">%1$d</xliff:g>:<xliff:g example="43" id="minutes">%2$02d</xliff:g>:<xliff:g example="33" id="seconds">%3$02d</xliff:g></string>
+
+    <!-- Item on EditText context menu. This action is used to select all text in the edit field. -->
+    <string name="selectAll">Select all</string>
+
+    <!-- Item on EditText context menu.  This action is used to cut selected the text into the clipboard.  -->
+    <string name="cut">Cut</string>
+
+    <!-- Item on EditText context menu. This action is used to cut selected the text into the clipboard. -->
+    <string name="copy">Copy</string>
+
+    <!-- Item on EditText context menu. This action is used to paste from the clipboard into the eidt field -->
+    <string name="paste">Paste</string>
+
+    <!-- Item on EditText context menu. This action is used to paste from the clipboard into the eidt field without formatting -->
+    <string name="paste_as_plain_text">Paste as plain text</string>
+
+    <!-- Item on EditText context menu. This action is used to replace the current word by other suggested words, suggested by the IME or the spell checker -->
+    <string name="replace">Replace\u2026</string>
+
+    <!-- Item on EditText pop-up window. This action is used to delete the text that the user recently added. [CHAR LIMIT=15] -->
+    <string name="delete">Delete</string>
+
+    <!-- Item on EditText context menu. This action is used to copy a URL from the edit field into the clipboard. -->
+    <string name="copyUrl">Copy URL</string>
+
+    <!-- Item on EditText context menu. Added only when the context menu is not empty, it enable selection context mode. [CHAR LIMIT=20] -->
+    <string name="selectTextMode">Select text</string>
+
+    <!-- Item on EditText context menu. This action is used to undo a text edit operation. -->
+    <string name="undo">Undo</string>
+
+    <!-- Item on EditText context menu. This action is used to redo a text edit operation. -->
+    <string name="redo">Redo</string>
+
+    <!-- Text selection contextual mode title, displayed in the CAB. [CHAR LIMIT=20] -->
+    <string name="textSelectionCABTitle">Text selection</string>
+
+    <!-- Option to add the current misspelled word to the user dictionary. [CHAR LIMIT=25] -->
+    <string name="addToDictionary">Add to dictionary</string>
+
+    <!-- Option to delete the highlighted part of the text from the suggestion popup. [CHAR LIMIT=25] -->
+    <string name="deleteText">Delete</string>
+
+    <!-- EditText context menu -->
+    <string name="inputMethod">Input method</string>
+
+    <!-- Title for EditText context menu [CHAR LIMIT=20] -->
+    <string name="editTextMenuTitle">Text actions</string>
+
+    <!-- If the device is getting low on internal storage, a notification is shown to the user.  This is the title of that notification. -->
+    <string name="low_internal_storage_view_title">Storage space running out</string>
+    <!-- If the device is getting low on internal storage, a notification is shown to the user.  This is the message of that notification. -->
+    <string name="low_internal_storage_view_text">Some system functions may not work</string>
+    <!-- If the device does not have storage for the main system classes, a notification is shown to the user.  This is the message of that notification. -->
+    <string name="low_internal_storage_view_text_no_boot">Not enough storage for the system. Make sure you have 250MB of free space and restart.</string>
+
+    <!-- [CHAR LIMIT=NONE] Stub notification title for an app running a service that has provided
+         a bad bad notification for itself. -->
+    <string name="app_running_notification_title"><xliff:g id="app_name">%1$s</xliff:g> is running</string>
+    <!-- [CHAR LIMIT=NONE] Stub notification text for an app running a service that has provided
+         a bad bad notification for itself. -->
+    <string name="app_running_notification_text">Touch for more information or to stop the app</string>
+
+    <!-- Preference framework strings. -->
+    <string name="ok">OK</string>
+    <!-- Preference framework strings. -->
+    <string name="cancel">Cancel</string>
+    <!-- Preference framework strings. -->
+    <string name="yes">OK</string>
+    <!-- Preference framework strings. -->
+    <string name="no">Cancel</string>
+    <!-- This is the generic "attention" string to be used in attention dialogs.  Typically
+         combined with setIconAttribute(android.R.attr.alertDialogIcon)
+         (or setIcon(android.R.drawable.ic_dialog_alert) on legacy versions of the platform) -->
+    <string name="dialog_alert_title">Attention</string>
+
+    <!-- Text shown by list fragment when waiting for data to display. -->
+    <string name="loading">Loading\u2026</string>
+
+    <!-- Default text for a button that can be toggled on and off. -->
+    <string name="capital_on">ON</string>
+    <!-- Default text for a button that can be toggled on and off. -->
+    <string name="capital_off">OFF</string>
+
+    <!-- Title of intent resolver dialog when selecting an application to run. -->
+    <string name="whichApplication">Complete action using</string>
+    <!-- Title of intent resolver dialog when selecting an application to run
+         and a previously used application is known. -->
+    <string name="whichApplicationNamed">Complete action using %1$s</string>
+    <!-- Generic label for a link to a intent resolver. -->
+    <string name="whichApplicationLabel">Complete action</string>
+    <!-- Title of intent resolver dialog when selecting a viewer application to run. -->
+    <string name="whichViewApplication">Open with</string>
+    <!-- Title of intent resolver dialog when selecting a viewer application to run
+         and a previously used application is known. -->
+    <string name="whichViewApplicationNamed">Open with %1$s</string>
+    <!-- Label for a link to a intent resolver dialog to view something -->
+    <string name="whichViewApplicationLabel">Open</string>
+    <!-- Title of intent resolver dialog when selecting an editor application to run. -->
+    <string name="whichEditApplication">Edit with</string>
+    <!-- Title of intent resolver dialog when selecting an editor application to run
+         and a previously used application is known. -->
+    <string name="whichEditApplicationNamed">Edit with %1$s</string>
+    <!-- Label for a link to a intent resolver dialog when selecting an editor application -->
+    <string name="whichEditApplicationLabel">Edit</string>
+    <!-- Title of intent resolver dialog when selecting a sharing application to run. -->
+    <string name="whichSendApplication">Share with</string>
+    <!-- Title of intent resolver dialog when selecting a sharing application to run
+         and a previously used application is known. -->
+    <string name="whichSendApplicationNamed">Share with %1$s</string>
+    <!-- Label for a link to a intent resolver dialog to sharing something -->
+    <string name="whichSendApplicationLabel">Share</string>
+    <!-- Title of intent resolver dialog when selecting an application to run to
+         send content to a specific recipient. Often used for email. -->
+    <string name="whichSendToApplication">Send using</string>
+    <!-- Title of intent resolver dialog when selecting an application to run to
+         send content to a specific recipient and a previously used application is known.
+         Often used for email. -->
+    <string name="whichSendToApplicationNamed">Send using %1$s</string>
+    <!-- Label for a link to a intent resolver dialog to send content to a specific recipient. -->
+    <string name="whichSendToApplicationLabel">Send</string>
+    <!-- Title of intent resolver dialog when selecting a HOME application to run. -->
+    <string name="whichHomeApplication">Select a Home app</string>
+    <!-- Title of intent resolver dialog when selecting a HOME application to run
+         and a previously used application is known. -->
+    <string name="whichHomeApplicationNamed">Use %1$s as Home</string>
+    <!-- Label for a link to a intent resolver dialog when selecting a HOME -->
+    <string name="whichHomeApplicationLabel">Capture image</string>
+    <!-- Option to always use the selected application resolution in the future. See the "Complete action using" dialog title-->
+    <!-- Title of intent resolver dialog when capturing an image. -->
+    <string name="whichImageCaptureApplication">Capture image with</string>
+    <!-- Title of intent resolver dialog when capturing an image
+         and a previously used application is known. -->
+    <string name="whichImageCaptureApplicationNamed">Capture image with %1$s</string>
+    <!-- Label for a link to a intent resolver dialog when capturing an image -->
+    <string name="whichImageCaptureApplicationLabel">Capture image</string>
+    <!-- Option to always use the selected application resolution in the future. See the "Complete action using" dialog title-->
+    <string name="alwaysUse">Use by default for this action.</string>
+    <!-- Title of the list of alternate options to complete an action shown when the
+         last used option is being displayed separately. -->
+    <string name="use_a_different_app">Use a different app</string>
+    <!-- Text displayed when the user selects the check box for setting default application.  See the "Use by default for this action" check box. -->
+    <string name="clearDefaultHintMsg">Clear default in System settings &gt; Apps &gt; Downloaded</string>
+    <!-- Default title for the activity chooser, when one is not given. Android allows multiple activities to perform an action.  for example, there may be many ringtone pickers installed.  A dialog is shown to the user allowing him to pick which activity should be used.  This is the title. -->
+    <string name="chooseActivity">Choose an action</string>
+    <!-- title for the USB activity chooser. -->
+    <string name="chooseUsbActivity">Choose an app for the USB device</string>
+    <!-- Text to display when there are no activities found to display in the
+         activity chooser. See the "Select an action" title. -->
+    <string name="noApplications">No apps can perform this action.</string>
+    <!-- Text of the alert that is displayed when an application has crashed. -->
+    <string name="aerr_application"><xliff:g id="application">%1$s</xliff:g> has stopped</string>
+    <!-- Text of the alert that is displayed when a process has crashed. -->
+    <string name="aerr_process"><xliff:g id="process">%1$s</xliff:g> has stopped</string>
+    <!-- Text of the alert that is displayed when an application has crashed repeatedly. -->
+    <string name="aerr_application_repeated"><xliff:g id="application">%1$s</xliff:g> keeps stopping</string>
+    <!-- Text of the alert that is displayed when a process has crashed repeatedly. -->
+    <string name="aerr_process_repeated"><xliff:g id="process">%1$s</xliff:g> keeps stopping</string>
+    <!-- Button that restarts a crashed application -->
+    <string name="aerr_restart">Open app again</string>
+    <!-- Button that sends feedback about a crashed application -->
+    <string name="aerr_report">Send feedback</string>
+    <!-- Button that closes a crashed application -->
+    <string name="aerr_close">Close</string>
+    <!-- Button that mutes further crashes of the crashed application. Note that this only appears on engineering builds. -->
+    <string name="aerr_mute">Mute until device restarts</string>
+    <!-- Button that waits a bit more for an unresponsive app -->
+    <string name="aerr_wait">Wait</string>
+    <!-- Button that closes an unresponsive application -->
+    <string name="aerr_close_app">Close app</string>
+
+    <!-- Title of the alert when an application is not responding. -->
+    <string name="anr_title"/>
+    <!-- Text of the alert that is displayed when an application is not responding. -->
+    <string name="anr_activity_application"><xliff:g id="application">%2$s</xliff:g> isn\'t responding</string>
+    <!-- Text of the alert that is displayed when an application is not responding. -->
+    <string name="anr_activity_process"><xliff:g id="activity">%1$s</xliff:g> isn\'t responding</string>
+    <!-- Text of the alert that is displayed when an application is not responding. -->
+    <string name="anr_application_process"><xliff:g id="application">%1$s</xliff:g> isn\'t responding</string>
+    <!-- Text of the alert that is displayed when an application is not responding. -->
+    <string name="anr_process">Process <xliff:g id="process">%1$s</xliff:g> isn\'t responding</string>
+    <!-- Button allowing the user to close an application that is not responding. This will kill the application. -->
+    <string name="force_close">OK</string>
+    <!-- Button allowing the user to send a bug report for application which has encountered an error. -->
+    <string name="report">Report</string>
+    <!-- Button allowing the user to choose to wait for an application that is not responding to become responsive again. -->
+    <string name="wait">Wait</string>
+    <!-- Text of the alert that is displayed when a web page is not responding. [CHAR-LIMIT=NONE] -->
+    <string name="webpage_unresponsive">The page has become unresponsive.\n\nDo you want to close it?</string>
+    <!-- [CHAR LIMIT=25] Title of the alert when application launches on top of another. -->
+    <string name="launch_warning_title">App redirected</string>
+    <!-- [CHAR LIMIT=50] Title of the alert when application launches on top of another. -->
+    <string name="launch_warning_replace"><xliff:g id="app_name">%1$s</xliff:g> is now running.</string>
+    <!-- [CHAR LIMIT=50] Title of the alert when application launches on top of another. -->
+    <string name="launch_warning_original"><xliff:g id="app_name">%1$s</xliff:g> was originally launched.</string>
+    <!-- [CHAR LIMIT=50] Compat mode dialog: compat mode switch label. -->
+    <string name="screen_compat_mode_scale">Scale</string>
+    <!-- [CHAR LIMIT=50] Compat mode dialog: compat mode switch label. -->
+    <string name="screen_compat_mode_show">Always show</string>
+    <!-- [CHAR LIMIT=200] Compat mode dialog: hint to re-enable compat mode dialog. -->
+    <string name="screen_compat_mode_hint">Re\u2011enable this in System settings &gt; Apps &gt; Downloaded</string>
+
+    <!-- [CHAR LIMIT=200] Unsupported display size dialog: message. Refers to "Display size" setting. -->
+    <string name="unsupported_display_size_message"><xliff:g id="app_name">%1$s</xliff:g> does not support the current Display size setting and may behave unexpectedly.</string>
+    <!-- [CHAR LIMIT=50] Unsupported display size dialog: check box label. -->
+    <string name="unsupported_display_size_show">Always show</string>
+
+    <!-- Text of the alert that is displayed when an application has violated StrictMode. -->
+    <string name="smv_application">The app <xliff:g id="application">%1$s</xliff:g> (process <xliff:g id="process">%2$s</xliff:g>) has violated its self\u2011enforced StrictMode policy.</string>
+    <!-- Text of the alert that is displayed when an application has violated StrictMode. -->
+    <string name="smv_process">The process <xliff:g id="process">%1$s</xliff:g> has violated its self\u2011enforced StrictMode policy.</string>
+
+    <!-- [CHAR LIMIT=40] Title of dialog that is shown when performing a system upgrade. -->
+    <string name="android_upgrading_title">Android is upgrading\u2026</string>
+
+    <!-- [CHAR LIMIT=40] Title of dialog that is shown when system is starting. -->
+    <string name="android_start_title">Android is starting\u2026</string>
+
+    <!-- [CHAR LIMIT=NONE] Message shown in upgrading dialog when doing an fstrim. -->
+    <string name="android_upgrading_fstrim">Optimising storage</string>
+
+    <!-- [CHAR LIMIT=40] Title of notification that is shown when finishing a system upgrade. -->
+    <string name="android_upgrading_notification_title">Finishing Android update\u2026</string>
+    <!-- [CHAR LIMIT=200] Body of notification that is shown when performing a system upgrade. -->
+    <string name="android_upgrading_notification_body">Some apps may not work properly until the update is complete.</string>
+
+    <!-- [CHAR LIMIT=40] Toast that is shown when an app is still upgrading. -->
+    <string name="app_upgrading_toast"><xliff:g id="application">%1$s</xliff:g> is upgrading\u2026</string>
+
+    <!-- [CHAR LIMIT=NONE] Message shown in upgrading dialog for each .apk that is optimized. -->
+    <string name="android_upgrading_apk">Optimising app <xliff:g example="123" id="number">%1$d</xliff:g> of <xliff:g example="123" id="number">%2$d</xliff:g>.</string>
+
+    <!-- [CHAR LIMIT=NONE] Message shown in upgrading dialog for each .apk pre boot broadcast -->
+    <string name="android_preparing_apk">Preparing <xliff:g id="appname">%1$s</xliff:g>.</string>
+
+    <!-- [CHAR LIMIT=NONE] Message to show in upgrading dialog when reached the point of starting apps. -->
+    <string name="android_upgrading_starting_apps">Starting apps.</string>
+
+    <!-- [CHAR LIMIT=NONE] Message to show in upgrading dialog when the bulk of the upgrade work is done. -->
+    <string name="android_upgrading_complete">Finishing boot.</string>
+
+    <!-- Notification text to tell the user that a heavy-weight application is running. -->
+    <string name="heavy_weight_notification"><xliff:g id="app">%1$s</xliff:g> running</string>
+
+    <!-- Notification details to tell the user that a heavy-weight application is running. -->
+    <string name="heavy_weight_notification_detail">Touch to switch to app</string>
+
+    <!-- Title of dialog prompting whether user wants to switch between heavy-weight apps. -->
+    <string name="heavy_weight_switcher_title">Switch apps?</string>
+
+    <!-- Descriptive text for switching to a new heavy-weight application. -->
+    <string name="heavy_weight_switcher_text">Another app is already running that must be stopped before you can start a new one.</string>
+
+    <string name="old_app_action">Return to <xliff:g id="old_app">%1$s</xliff:g></string>
+    <string name="old_app_description">Don\'t start the new app</string>
+
+    <string name="new_app_action">Start <xliff:g id="old_app">%1$s</xliff:g></string>
+    <string name="new_app_description">Stop the old app without saving.</string>
+
+    <!-- Notification text to tell the user that a process has exceeded its memory limit. -->
+    <string name="dump_heap_notification"><xliff:g id="proc">%1$s</xliff:g> exceeded memory limit</string>
+
+    <!-- Notification details to tell the user that a process has exceeded its memory limit. -->
+    <string name="dump_heap_notification_detail">Heap dump has been collected; touch to share</string>
+
+    <!-- Title of dialog prompting the user to share a heap dump. -->
+    <string name="dump_heap_title">Share heap dump?</string>
+
+    <!-- Text of dialog prompting the user to share a heap dump. -->
+    <string name="dump_heap_text">The process <xliff:g id="proc">%1$s</xliff:g> has exceeded its process memory limit of <xliff:g id="size">%2$s</xliff:g>. A heap dump is available for you to share with its developer. Be careful: this heap dump can contain any of your personal information that the application has access to.</string>
+
+    <!-- Displayed in the title of the chooser for things to do with text that
+         is to be sent to another application. For example, I can send
+         text through SMS or IM.  A dialog with those choices would be shown,
+         and this would be the title. -->
+    <string name="sendText">Choose an action for text</string>
+
+    <!-- Title of the dialog where the user is adjusting the phone ringer volume -->
+    <string name="volume_ringtone">Ringer volume</string>
+    <!-- Title of the dialog where the user is adjusting the music volume -->
+    <string name="volume_music">Media volume</string>
+    <!-- Hint shown in the volume toast to inform the user that the media audio is playing through Bluetooth. -->
+    <string name="volume_music_hint_playing_through_bluetooth">Playing through Bluetooth</string>
+    <!-- Hint shown in the volume toast to inform the user that the current ringtone is the silent ringtone. -->
+    <string name="volume_music_hint_silent_ringtone_selected">Silent ringtone set</string>
+    <!-- Title of the dialog where the user is adjusting the phone call volume -->
+    <string name="volume_call">In\u2011call volume</string>
+    <!-- Title of the dialog where the user is adjusting the phone call volume when connected on bluetooth-->
+    <string name="volume_bluetooth_call">Bluetooth in\u2011call volume</string>
+    <!-- Title of the dialog where the user is adjusting the audio volume for alarms -->
+    <string name="volume_alarm">Alarm volume</string>
+    <!-- Title of the dialog where the user is adjusting the audio volume for notifications -->
+    <string name="volume_notification">Notification volume</string>
+    <!-- Title of the dialog where the user is adjusting the general audio volume -->
+    <string name="volume_unknown">Volume</string>
+
+    <!-- Content description for bluetooth volume icon [CHAR LIMIT=100] -->
+    <string name="volume_icon_description_bluetooth">Bluetooth volume</string>
+    <!-- Content description for ringer volume icon [CHAR LIMIT=100] -->
+    <string name="volume_icon_description_ringer">Ringtone volume</string>
+    <!-- Content description for in-call volume icon [CHAR LIMIT=100] -->
+    <string name="volume_icon_description_incall">Call volume</string>
+    <!-- Content description for media volume icon [CHAR LIMIT=100] -->
+    <string name="volume_icon_description_media">Media volume</string>
+    <!-- Content description for notification volume icon [CHAR LIMIT=100] -->
+    <string name="volume_icon_description_notification">Notification volume</string>
+
+    <!-- Ringtone picker strings --> <skip/>
+    <!-- Choice in the ringtone picker.  If chosen, the default ringtone will be used. -->
+    <string name="ringtone_default">Default ringtone</string>
+    <!-- Choice in the ringtone picker.  If chosen, the default ringtone will be used. This fills in the actual ringtone's title into the message. -->
+    <string name="ringtone_default_with_actual">Default ringtone (<xliff:g id="actual_ringtone">%1$s</xliff:g>)</string>
+    <!-- Choice in the ringtone picker.  If chosen, there will be silence instead of a ringtone played. -->
+    <string name="ringtone_silent">None</string>
+    <!-- The title of the ringtone picker dialog. -->
+    <string name="ringtone_picker_title">Ringtones</string>
+    <!-- If there is ever a ringtone set for some setting, but that ringtone can no longer be resolved, t his is shown instead.  For example, if the ringtone was on a SD card and it had been removed, this woudl be shown for ringtones on that SD card. -->
+    <string name="ringtone_unknown">Unknown ringtone</string>
+
+    <!-- A notification is shown when there are open wireless networks nearby.  This is the notification's title. -->
+    <plurals name="wifi_available">
+        <item quantity="one">Wi\u2011Fi network available</item>
+        <item quantity="other">Wi\u2011Fi networks available</item>
+    </plurals>
+    <!-- A notification is shown when there are open wireless networks nearby.  This is the notification's message. -->
+    <plurals name="wifi_available_detailed">
+        <item quantity="one">Open Wi\u2011Fi network available</item>
+        <item quantity="other">Open Wi\u2011Fi networks available</item>
+    </plurals>
+
+    <!-- A notification is shown when a wifi captive portal network is detected.  This is the notification's title. -->
+    <string name="wifi_available_sign_in">Sign in to Wi\u2011Fi network</string>
+
+    <!-- A notification is shown when a captive portal network is detected.  This is the notification's title. -->
+    <string name="network_available_sign_in">Sign in to network</string>
+
+    <!-- A notification is shown when a captive portal network is detected.  This is the notification's message. -->
+    <string name="network_available_sign_in_detailed"><xliff:g id="network_ssid">%1$s</xliff:g></string>
+
+    <!-- A notification is shown when the user connects to a Wi-Fi network and the system detects that that network has no Internet access. This is the notification's title. -->
+    <string name="wifi_no_internet">Wi\u2011Fi has no internet access</string>
+
+    <!-- A notification is shown when the user connects to a Wi-Fi network and the system detects that that network has no Internet access. This is the notification's message. -->
+    <string name="wifi_no_internet_detailed">Touch for options</string>
+
+    <!-- A notification might be shown if the device switches to another network type (e.g., cellular data) because it detects that the network it was using (e.g., Wi-Fi) has lost Internet connectivity. This is the notification's title. %1$s is the network type that the device switched to, e.g., cellular data. It is one of the strings in the network_switch_type_name array. -->
+    <string name="network_switch_metered">Switched to <xliff:g id="network_type">%1$s</xliff:g></string>
+
+    <!-- A notification might be shown if the device switches to another network type (e.g., cellular data) because it detects that the network it was using (e.g., Wi-Fi) has lost Internet connectivity. This is the notification's message. %1$s is the network that the device switched to, e.g., cellular data. %2$s is the network type the device switched from, e.g., Wi-Fi. Both are strings in the network_switch_type_name array. -->
+    <string name="network_switch_metered_detail">Device uses <xliff:g id="new_network">%1$s</xliff:g> when <xliff:g id="previous_network">%2$s</xliff:g> has no internet access. Charges may apply.</string>
+
+    <!-- A toast might be shown if the device switches to another network type (e.g., cellular data) because it detects that the network it was using (e.g., Wi-Fi) has lost Internet connectivity. This is the text of the toast. %1$s is the network that the device switched from, e.g., Wi-Fi. %2$s is the network type the device switched from, e.g., cellular data. Both are strings in the network_switch_type_name array. -->
+    <string name="network_switch_metered_toast">Switched from <xliff:g id="previous_network">%1$s</xliff:g> to <xliff:g id="new_network">%2$s</xliff:g></string>
+
+    <!-- Network type names used in the network_switch_metered and network_switch_metered_detail strings. These must be kept in the sync with the values NetworkCapabilities.TRANSPORT_xxx values, and in the same order. -->
+    <string-array name="network_switch_type_name">
+        <item>cellular data</item>
+        <item>Wi-Fi</item>
+        <item>Bluetooth</item>
+        <item>Ethernet</item>
+        <item>VPN</item>
+    </string-array>
+
+    <!-- Network type name displayed if one of the types is not found in network_switch_type_name. -->
+    <string name="network_switch_type_name_unknown">an unknown network type</string>
+
+     <!-- A notification is shown when a user's selected SSID is later disabled due to connectivity problems.  This is the notification's title / ticker. -->
+     <string name="wifi_watchdog_network_disabled">Couldn\'t connect to Wi\u2011Fi</string>
+     <!-- A notification is shown when a user's selected SSID is later disabled due to connectivity problems.  The complete alert msg is: <hotspot name> + this string, i.e. "Linksys has a poor internet connection" -->
+    <string name="wifi_watchdog_network_disabled_detailed">\u0020has a poor internet connection.</string>
+
+    <!-- Do not translate. Default access point SSID used for tethering -->
+    <string name="wifi_tether_configure_ssid_default" translatable="false">3Prism XX</string>
+
+    <!-- A notification is shown the first time a connection is attempted on an app owned AP -->
+    <!-- title for this message -->
+    <string name="wifi_connect_alert_title">Allow connection?</string>
+    <!-- message explaining who is connecting to what -->
+    <string name="wifi_connect_alert_message">Application %1$s would like to connect to Wi\u2011Fi network %2$s</string>
+    <!-- default application in case name can not be found -->
+    <string name="wifi_connect_default_application">An application</string>
+
+    <string name="wifi_p2p_dialog_title">Wi\u2011Fi Direct</string>
+    <string name="wifi_p2p_turnon_message">Start Wi\u2011Fi Direct. This will turn off Wi\u2011Fi client/hotspot.</string>
+    <string name="wifi_p2p_failed_message">Couldn\'t start Wi\u2011Fi Direct</string>
+    <string name="wifi_p2p_enabled_notification_title">Wi\u2011Fi Direct is on</string>
+    <string name="wifi_p2p_enabled_notification_message">Touch for settings</string>
+
+    <string name="accept">Accept</string>
+    <string name="decline">Decline</string>
+    <string name="wifi_p2p_invitation_sent_title">Invitation sent</string>
+    <string name="wifi_p2p_invitation_to_connect_title">Invitation to connect</string>
+
+    <string name="wifi_p2p_from_message">From: </string>
+    <string name="wifi_p2p_to_message">To: </string>
+    <string name="wifi_p2p_enter_pin_message">Type the required PIN: </string>
+    <string name="wifi_p2p_show_pin_message">PIN:</string>
+
+    <string name="wifi_p2p_frequency_conflict_message" product="tablet">The tablet will temporarily disconnect from Wi-Fi while it\'s connected to <xliff:g id="device_name">%1$s</xliff:g></string>
+    <string name="wifi_p2p_frequency_conflict_message" product="tv">The TV will temporarily disconnect from Wi-Fi while it\'s connected to <xliff:g id="device_name">%1$s</xliff:g></string>
+    <string name="wifi_p2p_frequency_conflict_message" product="default">The phone will temporarily disconnect from Wi\u2011Fi while it\'s connected to <xliff:g id="device_name">%1$s</xliff:g></string>
+
+    <!-- Name of the dialog that lets the user choose an accented character to insert -->
+    <string name="select_character">Insert character</string>
+
+    <!-- SMS per-application rate control Dialog --> <skip/>
+    <!-- SMS_DIALOG: An SMS dialog is shown if an application tries to send too many SMSes.  This is the title of that dialog. -->
+    <string name="sms_control_title">Sending SMS messages</string>
+    <!-- See SMS_DIALOG.  This is the message shown in that dialog. [CHAR LIMIT=NONE] -->
+    <string name="sms_control_message">&lt;b&gt;<xliff:g id="app_name">%1$s</xliff:g>&lt;/b&gt; is sending a large number of SMS messages. Allow this app to continue sending messages?</string>
+    <!-- See SMS_DIALOG.  This is a button choice to allow sending the SMSes. [CHAR LIMIT=30] -->
+    <string name="sms_control_yes">Allow</string>
+    <!-- See SMS_DIALOG.  This is a button choice to disallow sending the SMSes. [CHAR LIMIT=30] -->
+    <string name="sms_control_no">Deny</string>
+
+    <!-- SMS short code verification dialog. --> <skip/>
+    <!-- The message text for the SMS short code confirmation dialog. [CHAR LIMIT=NONE] -->
+    <string name="sms_short_code_confirm_message">&lt;b&gt;<xliff:g id="app_name">%1$s</xliff:g>&lt;/b&gt; would like to send a message to &lt;b&gt;<xliff:g id="dest_address">%2$s</xliff:g>&lt;/b&gt;.</string>
+    <!-- Message details for the SMS short code confirmation dialog (possible premium short code). [CHAR LIMIT=NONE] -->
+    <string name="sms_short_code_details">This <b>may cause charges</b> on your mobile account.</string>
+    <!-- Message details for the SMS short code confirmation dialog (premium short code). [CHAR LIMIT=NONE] -->
+    <string name="sms_premium_short_code_details"><b>This will cause charges on your mobile account.</b></string>
+    <!-- Text of the approval button for the SMS short code confirmation dialog. [CHAR LIMIT=30] -->
+    <string name="sms_short_code_confirm_allow">Send</string>
+    <!-- Text of the cancel button for the SMS short code confirmation dialog. [CHAR LIMIT=30] -->
+    <string name="sms_short_code_confirm_deny">Cancel</string>
+    <!-- Text of the checkbox for the SMS short code confirmation dialog to remember the user's choice. [CHAR LIMIT=40] -->
+    <string name="sms_short_code_remember_choice">Remember my choice</string>
+    <!-- Text shown when remember checkbox is checked to inform the user how they may undo the setting. [CHAR LIMIT=40] -->
+    <string name="sms_short_code_remember_undo_instruction">You can change this later in Settings\u00A0&gt;\u00A0Apps</string>
+
+    <!-- Text of the approval button for the SMS short code confirmation dialog when checkbox is checked. [CHAR LIMIT=30] -->
+    <string name="sms_short_code_confirm_always_allow">Always Allow</string>
+    <!-- Text of the cancel button for the SMS short code confirmation dialog when checkbox is checked. [CHAR LIMIT=30] -->
+    <string name="sms_short_code_confirm_never_allow">Never Allow</string>
+
+    <!-- SIM swap and device reboot Dialog --> <skip/>
+    <!-- See SIM_REMOVED_DIALOG.  This is the title of that dialog. -->
+    <string name="sim_removed_title">SIM card removed</string>
+    <!-- See SIM_REMOVED_DIALOG.  This is the message of that dialog. -->
+    <string name="sim_removed_message">The mobile network will be unavailable until you restart with a valid SIM card inserted.</string>
+    <!-- See SIM_REMOVED_DIALOG.  This is the button of that dialog. -->
+    <string name="sim_done_button">Done</string>
+    <!-- See SIM_ADDED_DIALOG.  This is the title of that dialog. -->
+    <string name="sim_added_title">SIM card added</string>
+    <!-- See SIM_ADDED_DIALOG.  This is the message of that dialog. -->
+    <string name="sim_added_message">Restart your device to access the mobile network.</string>
+    <!-- See SIM_ADDED_DIALOG.  This is the button of that dialog. -->
+    <string name="sim_restart_button">Restart</string>
+    <!-- See Carrier_App_Dialog. This is the message of that dialog. -->
+    <string name="carrier_app_dialog_message">To get your new SIM working properly, you\'ll need to install and open an app from your carrier.</string>
+    <!-- See Carrier_App_Dialog. This is the button of that dialog. -->
+    <string name="carrier_app_dialog_button">GET THE APP</string>
+    <string name="carrier_app_dialog_not_now">NOT NOW</string>
+    <!-- See carrier_app_notification. This is the headline. -->
+    <string name="carrier_app_notification_title">New SIM inserted</string>
+    <string name="carrier_app_notification_text">Touch to set it up</string>
+
+    <!-- Date/Time picker dialogs strings -->
+
+    <!-- The title of the time picker dialog. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_dialog_title">Set time</string>
+    <!-- The title of the date picker dialog. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_dialog_title">Set date</string>
+    <!-- Name of the button in the date/time picker to accept the date/time change -->
+    <string name="date_time_set">Set</string>
+    <!-- Name of the button in the date/time picker to accept the date/time change -->
+    <string name="date_time_done">Done</string>
+
+    <!-- Security Permissions strings-->
+    <!-- Text that is placed at the front of a permission name that is being added to an app [CHAR LIMIT=NONE] -->
+    <string name="perms_new_perm_prefix"><font fgcolor="#ff33b5e5" size="12">NEW: </font></string>
+    <!-- Text that is placed at the front of a permission name that is being added to an app [CHAR LIMIT=NONE] -->
+    <string name="perms_description_app">Provided by <xliff:g id="app_name">%1$s</xliff:g>.</string>
+    <!-- Shown for an application when it doesn't require any permission grants. -->
+    <string name="no_permissions">No permissions required</string>
+    <!-- [CHAR LIMIT=NONE] Additional text in permission description for perms that can cost money. -->
+    <string name="perm_costs_money">this may cost you money</string>
+    <!-- Dialog ok button-->
+    <string name="dlg_ok">OK</string>
+
+    <!-- USB_PREFERENCES: Notification for when the user connected to the charger only.  This is the title -->
+    <string name="usb_charging_notification_title">USB charging this device</string>
+    <!-- USB_PREFERENCES: Notification for when the user connects the phone to supply power to attached device.  This is the title -->
+    <string name="usb_supplying_notification_title">USB supplying power to attached device</string>
+    <!-- USB_PREFERENCES: Notification for when the user connects the phone to a computer via USB in MTP mode.  This is the title -->
+    <string name="usb_mtp_notification_title">USB for file transfer</string>
+    <!-- USB_PREFERENCES: Notification for when the user connects the phone to a computer via USB in PTP mode.  This is the title -->
+    <string name="usb_ptp_notification_title">USB for photo transfer</string>
+    <!-- USB_PREFERENCES: Notification for when the user connects the phone to a computer via USB in MIDI mode.  This is the title -->
+    <string name="usb_midi_notification_title">USB for MIDI</string>
+    <!-- USB_PREFERENCES: Notification for when a USB accessory is attached.  This is the title -->
+    <string name="usb_accessory_notification_title">Connected to a USB accessory</string>
+    <!-- See USB_PREFERENCES. This is the message. -->
+    <string name="usb_notification_message">Touch for more options</string>
+
+    <!-- Title of notification shown when ADB is actively connected to the phone. -->
+    <string name="adb_active_notification_title">USB debugging connected</string>
+    <!-- Message of notification shown when ADB is actively connected to the phone. -->
+    <string name="adb_active_notification_message">Touch to disable USB debugging</string>
+
+    <!-- Title of notification shown to indicate that bug report is being collected. -->
+    <string name="taking_remote_bugreport_notification_title">Taking bug report\u2026</string>
+    <!-- Title of notification shown to ask for user consent for sharing a bugreport that was requested remotely by the IT administrator. -->
+    <string name="share_remote_bugreport_notification_title">Share bug report?</string>
+    <!-- Title of notification shown to indicate that bug report is still being collected after sharing was accepted. -->
+    <string name="sharing_remote_bugreport_notification_title">Sharing bug report\u2026</string>
+    <!-- Message of a notification shown to ask for user consent for sharing a bugreport that was requested remotely by the IT administrator. -->
+    <string name="share_remote_bugreport_notification_message_finished">Your IT admin requested a bug report to help troubleshoot this device. Apps and data may be shared.</string>
+    <!-- Acceptance label of notification shown to ask for user consent for sharing the remote bugreport. -->
+    <string name="share_remote_bugreport_action">Share</string>
+    <!-- Decline label of notification shown to ask for user consent for sharing the remote bugreport. -->
+    <string name="decline_remote_bugreport_action">Decline</string>
+
+    <!-- Used to replace %s in urls retreived from the signin server with locales.  For Some        -->
+    <!-- devices we don't support all the locales we ship to and need to replace the '%s' with a    -->
+    <!-- locale string based on mcc values.  By default (0-length string) we don't replace the %s   -->
+    <!-- at all and later replace it with a locale string based on the users chosen locale          -->
+    <!-- DO NOT TRANSLATE -->
+    <string name="locale_replacement">""</string>
+
+    <!-- Title of the pop-up dialog in which the user switches keyboard, also known as input method. -->
+    <string name="select_input_method">Change keyboard</string>
+    <!-- Summary text of a toggle switch to enable/disable use of the IME while a physical
+         keyboard is connected -->
+    <string name="show_ime">Keep it on screen while physical keyboard is active</string>
+    <!-- Title of the physical keyboard category in the input method selector [CHAR LIMIT=30] -->
+    <string name="hardware">Show virtual keyboard</string>
+
+    <!-- Title of the notification to prompt the user to configure physical keyboard settings. -->
+    <string name="select_keyboard_layout_notification_title">Configure physical keyboard</string>
+    <!-- Message of the notification to prompt the user to configure physical keyboard settings
+         where the user can associate language with physical keyboard layout. -->
+    <string name="select_keyboard_layout_notification_message">Touch to select language and layout</string>
+
+    <string name="fast_scroll_alphabet">\u0020ABCDEFGHIJKLMNOPQRSTUVWXYZ</string>
+    <string name="fast_scroll_numeric_alphabet">\u00200123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</string>
+
+    <!-- External media notification strings -->
+    <skip/>
+
+    <!-- Notification title when external media is being checked [CHAR LIMIT=30] -->
+    <string name="ext_media_checking_notification_title">Preparing <xliff:g example="SD card" id="name">%s</xliff:g></string>
+    <!-- Notification body when external media is being checked [CHAR LIMIT=NONE] -->
+    <string name="ext_media_checking_notification_message">Checking for errors</string>
+
+    <!-- Notification body when new external media is detected [CHAR LIMIT=NONE] -->
+    <string name="ext_media_new_notification_message">New <xliff:g example="SD card" id="name">%s</xliff:g> detected</string>
+    <!-- Notification body when external media is ready for use [CHAR LIMIT=NONE] -->
+    <string name="ext_media_ready_notification_message">For transferring photos and media</string>
+
+    <!-- Notification title when external media is unmountable (corrupt) [CHAR LIMIT=30] -->
+    <string name="ext_media_unmountable_notification_title">Corrupted <xliff:g example="SD card" id="name">%s</xliff:g></string>
+    <!-- Notification body when external media is unmountable (corrupt) [CHAR LIMIT=NONE] -->
+    <string name="ext_media_unmountable_notification_message"><xliff:g example="SD card" id="name">%s</xliff:g> is corrupt. Touch to fix.</string>
+
+    <!-- Notification title when external media is unsupported [CHAR LIMIT=30] -->
+    <string name="ext_media_unsupported_notification_title">Unsupported <xliff:g example="SD card" id="name">%s</xliff:g></string>
+    <!-- Notification body when external media is unsupported [CHAR LIMIT=NONE] -->
+    <string name="ext_media_unsupported_notification_message">This device doesn\'t support this <xliff:g example="SD card" id="name">%s</xliff:g>. Touch to set up in a supported format.</string>
+
+    <!-- Notification title when external media is unsafely removed [CHAR LIMIT=30] -->
+    <string name="ext_media_badremoval_notification_title"><xliff:g example="SD card" id="name">%s</xliff:g> unexpectedly removed</string>
+    <!-- Notification body when external media is unsafely removed [CHAR LIMIT=NONE] -->
+    <string name="ext_media_badremoval_notification_message">Unmount <xliff:g example="SD card" id="name">%s</xliff:g> before removing to avoid data loss</string>
+
+    <!-- Notification title when external media is missing [CHAR LIMIT=30] -->
+    <string name="ext_media_nomedia_notification_title">Removed <xliff:g example="SD card" id="name">%s</xliff:g></string>
+    <!-- Notification body when external media is missing [CHAR LIMIT=NONE] -->
+    <string name="ext_media_nomedia_notification_message"><xliff:g example="SD card" id="name">%s</xliff:g> removed; insert a new one</string>
+
+    <!-- Notification title when external media is unmounting [CHAR LIMIT=30] -->
+    <string name="ext_media_unmounting_notification_title">Still ejecting <xliff:g example="SD card" id="name">%s</xliff:g>\u2026</string>
+    <!-- Notification body when external media is unmounting [CHAR LIMIT=NONE] -->
+    <string name="ext_media_unmounting_notification_message">Don\'t remove</string>
+
+    <!-- Notification action to setup external media [CHAR LIMIT=20] -->
+    <string name="ext_media_init_action">Set up</string>
+    <!-- Notification action to unmount external media [CHAR LIMIT=20] -->
+    <string name="ext_media_unmount_action">Eject</string>
+    <!-- Notification action to browse external media [CHAR LIMIT=20] -->
+    <string name="ext_media_browse_action">Explore</string>
+
+    <!-- Notification title when external media is missing [CHAR LIMIT=30] -->
+    <string name="ext_media_missing_title"><xliff:g example="SD card" id="name">%s</xliff:g> missing</string>
+    <!-- Notification body when external media is missing [CHAR LIMIT=30] -->
+    <string name="ext_media_missing_message">Reinsert this device</string>
+
+    <!-- Notification title when moving an application to external storage [CHAR LIMIT=30] -->
+    <string name="ext_media_move_specific_title">Moving <xliff:g example="Calculator" id="name">%s</xliff:g></string>
+    <!-- Notification title when moving data to external storage [CHAR LIMIT=32] -->
+    <string name="ext_media_move_title">Moving data</string>
+
+    <!-- Notification title when moving data to external storage [CHAR LIMIT=32] -->
+    <string name="ext_media_move_success_title">Move complete</string>
+    <!-- Notification title when moving data to external storage [CHAR LIMIT=64] -->
+    <string name="ext_media_move_success_message">Data moved to <xliff:g example="SD card" id="name">%s</xliff:g></string>
+
+    <!-- Notification title when moving data to external storage failed [CHAR LIMIT=32] -->
+    <string name="ext_media_move_failure_title">Couldn\'t move data</string>
+    <!-- Notification title when moving data to external storage failed [CHAR LIMIT=64] -->
+    <string name="ext_media_move_failure_message">Data left at original location</string>
+
+    <!-- Short summary of storage media status when removed [CHAR LIMIT=32] -->
+    <string name="ext_media_status_removed">Removed</string>
+    <!-- Short summary of storage media status when unmounted [CHAR LIMIT=32] -->
+    <string name="ext_media_status_unmounted">Ejected</string>
+    <!-- Short summary of storage media status when checking [CHAR LIMIT=32] -->
+    <string name="ext_media_status_checking">Checking\u2026</string>
+    <!-- Short summary of storage media status when mounted [CHAR LIMIT=32] -->
+    <string name="ext_media_status_mounted">Ready</string>
+    <!-- Short summary of storage media status when mounted read-only [CHAR LIMIT=32] -->
+    <string name="ext_media_status_mounted_ro">Read-only</string>
+    <!-- Short summary of storage media status when removed unsafely [CHAR LIMIT=32] -->
+    <string name="ext_media_status_bad_removal">Removed unsafely</string>
+    <!-- Short summary of storage media status when unmountable [CHAR LIMIT=32] -->
+    <string name="ext_media_status_unmountable">Corrupted</string>
+    <!-- Short summary of storage media status when unsupported [CHAR LIMIT=32] -->
+    <string name="ext_media_status_unsupported">Unsupported</string>
+    <!-- Short summary of storage media status when ejecting [CHAR LIMIT=32] -->
+    <string name="ext_media_status_ejecting">Ejecting\u2026</string>
+    <!-- Short summary of storage media status when formatting [CHAR LIMIT=32] -->
+    <string name="ext_media_status_formatting">Formatting\u2026</string>
+    <!-- Short summary of storage media status when missing [CHAR LIMIT=32] -->
+    <string name="ext_media_status_missing">Not inserted</string>
+
+    <!-- Shown in LauncherActivity when the requested target Intent didn't return any matching Activities, leaving the list empty. -->
+    <string name="activity_list_empty">No matching activities found.</string>
+
+    <!-- Title of an application permission that lets an application route media output. -->
+    <string name="permlab_route_media_output">route media output</string>
+    <!-- Description of an application permission that lets an application route media output. -->
+    <string name="permdesc_route_media_output">Allows an application to route media output to other external devices.</string>
+
+    <!-- Title of an application permission that lets it read install sessions. -->
+    <string name="permlab_readInstallSessions">read install sessions</string>
+    <!-- Description of an application permission that lets it read install sessions. -->
+    <string name="permdesc_readInstallSessions">Allows an application to read install sessions. This allows it to see details about active package installations.</string>
+
+    <!-- Title of an application permission that lets it read install sessions. -->
+    <string name="permlab_requestInstallPackages">request install packages</string>
+    <!-- Description of an application permission that lets it read install sessions. -->
+    <string name="permdesc_requestInstallPackages">Allows an application to request installation of packages.</string>
+
+    <!-- Shown in the tutorial for tap twice for zoom control. -->
+    <string name="tutorial_double_tap_to_zoom_message_short">Double\u2011tap for zoom control</string>
+
+
+    <!-- Shown in gadget hosts (e.g. the home screen) when there was an error inflating
+    the gadget. -->
+    <string name="gadget_host_error_inflating">Couldn\'t add widget</string>
+
+    <!-- Long label for a button on a full-screen input method for the "Go" action. -->
+    <string name="ime_action_go">Go</string>
+
+    <!-- Long label for a button on a full-screen input method for the "Search" action. -->
+    <string name="ime_action_search">Search</string>
+
+    <!-- Long label for a button on a full-screen input method for the "Send" action. -->
+    <string name="ime_action_send">Send</string>
+
+    <!-- Long label for a button on a full-screen input method for the "Next" action. -->
+    <string name="ime_action_next">Next</string>
+
+    <!-- Long label for a button on a full-screen input method for the "Done" action. -->
+    <string name="ime_action_done">Done</string>
+
+    <!-- [CHAR LIMIT=6] Long label for a button on a full-screen input method for the "Previous" action. -->
+    <string name="ime_action_previous">Prev</string>
+
+    <!-- Long label for a button on a full-screen input method for an unknown action. -->
+    <string name="ime_action_default">Execute</string>
+
+    <!-- Strings for search suggestions. These are going here because they are referenced by both
+         ContactsProvider and GoogleContactsProvider -->
+    <skip/>
+
+
+    <!-- This string appears (on two lines) when you type a number into contacts search, to let you dial the phone number you typed.  The first line will be in bigger type than the second. -->
+    <string name="dial_number_using">Dial number\nusing <xliff:g example="555" id="number">%s</xliff:g></string>
+
+    <!-- This string appears (on two lines) when you type a number into contacts search, to let you create a contact whose phone number is the number you typed.  The first line will be in bigger type than the second. -->
+    <string name="create_contact_using">Create contact\nusing <xliff:g example="555" id="number">%s</xliff:g></string>
+
+    <!-- This string array should be overridden by the manufacture to present a list of carrier-id,locale. The wifi regulatory domain is extracted from the locale information. This is used at startup to set system defaults by checking the system property ro.carrier for the carrier-id and searching through this array -->
+    <!-- An Array of [[Carrier-ID]                     -->
+    <!--              [default-locale]]                -->
+    <string-array name="carrier_properties" translatable="false">
+    </string-array>
+
+    <string name="grant_credentials_permission_message_header">The following one or more apps request permission to access your account, now and in the future.</string>
+    <string name="grant_credentials_permission_message_footer">Allow this request?</string>
+    <string name="grant_permissions_header_text">Access request</string>
+    <string name="allow">Allow</string>
+    <string name="deny">Deny</string>
+    <string name="permission_request_notification_title">Permission requested</string>
+    <string name="permission_request_notification_with_subtitle">Permission requested\nfor account <xliff:g example="foo@gmail.com" id="account">%s</xliff:g>.</string>
+
+    <!-- Message to show when an intent automatically switches users into the personal profile. -->
+    <string name="forward_intent_to_owner">You\'re using this app outside of your work profile</string>
+    <!-- Message to show when an intent automatically switches users into a work profile. -->
+    <string name="forward_intent_to_work">You\'re using this app in your work profile</string>
+
+    <!-- Label to show for a service that is running because it is an input method. -->
+    <string name="input_method_binding_label">Input method</string>
+    <!-- Label to show for a service that is running because it is a sync adapter. -->
+    <string name="sync_binding_label">Sync</string>
+    <!-- Label to show for a service that is running because it is an accessibility module. -->
+    <string name="accessibility_binding_label">Accessibility</string>
+    <!-- Label to show for a service that is running because it is a wallpaper. -->
+    <string name="wallpaper_binding_label">Wallpaper</string>
+    <!-- Dialog title for user to select a different wallpaper from service list -->
+    <string name="chooser_wallpaper">Change wallpaper</string>
+    <!-- Label to show for a service that is running because it is observing
+         the user's notifications. -->
+    <string name="notification_listener_binding_label">Notification listener</string>
+    <!-- Label to show for a service that is running because the system is in VR mode. -->
+    <string name="vr_listener_binding_label">VR listener</string>
+    <!-- Label to show for a service that is running because it is providing conditions. -->
+    <string name="condition_provider_service_binding_label">Condition provider</string>
+    <!-- Label to show for a service that is running because it is observing and modifying the
+         importance of the user's notifications. -->
+    <string name="notification_ranker_binding_label">Notification ranker service</string>
+
+    <!-- Do Not Translate: Alternate eri.xml -->
+    <string name="alternate_eri_file">/data/eri.xml</string>
+
+    <!-- The title of the notification when VPN is active. -->
+    <string name="vpn_title">VPN activated</string>
+    <!-- The title of the notification when VPN is active with an application name. -->
+    <string name="vpn_title_long">VPN is activated by <xliff:g example="FooVPN client" id="app">%s</xliff:g></string>
+    <!-- The text of the notification when VPN is active. -->
+    <string name="vpn_text">Touch to manage the network</string>
+    <!-- The text of the notification when VPN is active with a session name. -->
+    <string name="vpn_text_long">Connected to <xliff:g example="office" id="session">%s</xliff:g>. Touch to manage the network.</string>
+
+    <!-- Notification title when connecting to lockdown VPN. -->
+    <string name="vpn_lockdown_connecting">Always\u2011on VPN connecting\u2026</string>
+    <!-- Notification title when connected to lockdown VPN. -->
+    <string name="vpn_lockdown_connected">Always\u2011on VPN connected</string>
+    <!-- Notification title when not connected to lockdown VPN. -->
+    <string name="vpn_lockdown_disconnected">Always\u2011on VPN disconnected</string>
+    <!-- Notification title when error connecting to lockdown VPN. -->
+    <string name="vpn_lockdown_error">Always\u2011on VPN error</string>
+    <!-- Notification body that indicates user can touch to configure lockdown VPN connection. -->
+    <string name="vpn_lockdown_config">Touch to set up</string>
+
+    <!-- Localized strings for WebView -->
+    <!-- Label for button in a WebView that will open a chooser to choose a file to upload -->
+    <string name="upload_file">Choose file</string>
+    <!-- Label for the file upload control when no file has been chosen yet -->
+    <string name="no_file_chosen">No file chosen</string>
+    <!-- Label for <input type="reset"> button in html -->
+    <string name="reset">Reset</string>
+    <!-- Label for <input type="submit"> button in html -->
+    <string name="submit">Submit</string>
+
+    <!-- Strings for car mode notification -->
+    <!-- Shown when car mode is enabled -->
+    <string name="car_mode_disable_notification_title">Car mode enabled</string>
+    <string name="car_mode_disable_notification_message">Touch to exit car mode</string>
+
+    <!-- Strings for tethered notification -->
+    <!-- Shown when the device is tethered -->
+    <string name="tethered_notification_title">Tethering or hotspot active</string>
+    <string name="tethered_notification_message">Touch to set up</string>
+
+    <!--  Strings for possible PreferenceActivity Back/Next buttons -->
+    <string name="back_button_label">Back</string>
+    <string name="next_button_label">Next</string>
+
+    <!-- Optional button to Skip a PreferenceActivity [CHAR LIMIT=20] -->
+    <string name="skip_button_label">Skip</string>
+
+    <!-- Displayed on the Find dialog when there are no matches [CHAR LIMIT=NONE]-->
+    <string name="no_matches">No matches</string>
+
+    <!-- Find dialog hint text.  Also used in the menu item to open find on page [CHAR LIMIT=NONE] -->
+    <string name="find_on_page">Find on page</string>
+
+    <!-- Displayed on the Find dialog to display the index of the highlighted
+         match and total number of matches found in the current page. [CHAR LIMIT=NONE] -->
+    <plurals name="matches_found">
+        <!-- Case of one match -->
+        <item quantity="one">1 match</item>
+        <!-- Case of multiple total matches -->
+        <item quantity="other"><xliff:g example="2" id="index">%d</xliff:g> of <xliff:g example="137" id="total">%d</xliff:g></item>
+    </plurals>
+
+    <!-- Label for the "Done" button on the far left of action mode toolbars. -->
+    <string name="action_mode_done">Done</string>
+
+    <!-- Strings for MasterClearReceiver. -->
+    <!-- Text for progress dialog while erasing USB storage volume [CHAR LIMIT=NONE] -->
+    <string name="progress_erasing" product="nosdcard">Erasing USB storage\u2026</string>
+    <!-- Text for progress dialog while erasing SD card [CHAR LIMIT=NONE] -->
+    <string name="progress_erasing" product="default">Erasing SD card\u2026</string>
+
+    <!-- Text for WebView's text selection Action Mode -->
+    <!-- ActionBar action to share the current selection [CHAR LIMIT=10] -->
+    <string name="share">Share</string>
+    <!-- ActionBar action to use the current selection to open the Find on page functionality [CHAR LIMIT=10]-->
+    <string name="find">Find</string>
+    <!-- ActionBar action to use the current selection to perform a web search [CHAR-LIMIT=16] -->
+    <string name="websearch">Web Search</string>
+    <!-- ActionBar action to find the next match in the page [CHAR LIMIT=24] -->
+    <string name="find_next">Find next</string>
+    <!-- ActionBar action to find the previous match in the page [CHAR LIMIT=24] -->
+    <string name="find_previous">Find previous</string>
+
+    <!-- Network positioning notification ticker. The name of the user (e.g. John Doe) who sent
+         the request is shown as a dynamic string. -->
+    <string name="gpsNotifTicker">Location request from <xliff:g id="name">%s</xliff:g></string>
+    <!-- Network positioning notification and verification title to inform the user about
+         an incoming location request. -->
+    <string name="gpsNotifTitle">Location request</string>
+    <!-- Network positioning notification message. The name of the user (e.g. John Doe) and
+         service (SUPL-service) who sent the request is shown as dynamic strings.
+         Translation should not be longer than master text. -->
+    <string name="gpsNotifMessage">Requested by <xliff:g id="name">%1$s</xliff:g> (<xliff:g example="SUPL\u2011service" id="service">%2$s</xliff:g>)</string>
+    <!-- Network positioning verification Yes. Button to push to share location information. -->
+    <string name="gpsVerifYes">Yes</string>
+    <!-- Network positioning verification No. Button to push to deny sharing of location
+         information. -->
+    <string name="gpsVerifNo">No</string>
+
+    <!-- Error message when the sync tried to delete too many things -->
+    <string name="sync_too_many_deletes">Delete limit exceeded</string>
+    <!-- Dialog message for when there are too many deletes that would take place and we want user confirmation -->
+    <string name="sync_too_many_deletes_desc">There are <xliff:g id="number_of_deleted_items">%1$d</xliff:g> deleted items for <xliff:g id="type_of_sync">%2$s</xliff:g>, account <xliff:g id="account_name">%3$s</xliff:g>. What do you want to do?</string>
+    <!-- Dialog action for when there are too many deletes that would take place and we want user confirmation, and the user wants to delete the items -->
+    <string name="sync_really_delete">Delete the items</string>
+    <!-- Dialog action for when there are too many deletes that would take place and we want user confirmation, and the user wants to undo the deletions -->
+    <string name="sync_undo_deletes">Undo the deletes</string>
+    <!-- Dialog action for when there are too many deletes that would take place and we want user confirmation, and the user wants to do nothing for now -->
+    <string name="sync_do_nothing">Do nothing for now</string>
+
+    <!-- Choose Account Activity label -->
+    <string name="choose_account_label">Choose an account</string>
+
+    <string name="add_account_label">Add an account</string>
+
+    <!-- List item to add an account [CHAR LIMIT=20] -->
+    <string name="add_account_button_label">Add account</string>
+
+    <!-- NumberPicker - accessibility support -->
+    <!-- Description of the button to increase the NumberPicker value. [CHAR LIMIT=NONE] -->
+    <string name="number_picker_increment_button">Increase</string>
+    <!-- Description of the button to decrease the NumberPicker value. [CHAR LIMIT=NONE] -->
+    <string name="number_picker_decrement_button">Decrease</string>
+    <!-- Description of the tap and hold action to get into scroll mode in NumberPicker. [CHAR LIMIT=NONE] -->
+    <string name="number_picker_increment_scroll_mode"><xliff:g example="3" id="value">%s</xliff:g> touch &amp; hold.</string>
+    <!-- Description of the scrolling action in NumberPicker. [CHAR LIMIT=NONE] -->
+    <string name="number_picker_increment_scroll_action">Slide up to increase and down to decrease.</string>
+
+    <!-- TimePicker - accessibility support -->
+    <!-- Description of the button to increase the TimePicker's minute value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_increment_minute_button">Increase minute</string>
+    <!-- Description of the button to decrease the TimePicker's minute value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_decrement_minute_button">Decrease minute</string>
+    <!-- Description of the button to increase the TimePicker's hour value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_increment_hour_button">Increase hour</string>
+    <!-- Description of the button to decrease the TimePicker's hour value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_decrement_hour_button">Decrease hour</string>
+    <!-- Description of the button to increase the TimePicker's set PM value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_increment_set_pm_button">Set PM</string>
+    <!-- Description of the button to decrease the TimePicker's set AM value. [CHAR LIMIT=NONE] -->
+    <string name="time_picker_decrement_set_am_button">Set AM</string>
+
+    <!-- DatePicker - accessibility support -->
+    <!-- Description of the button to increase the DatePicker's month value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_increment_month_button">Increase month</string>
+    <!-- Description of the button to decrease the DatePicker's month value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_decrement_month_button">Decrease month</string>
+    <!-- Description of the button to increase the DatePicker's day value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_increment_day_button">Increase day</string>
+    <!-- Description of the button to decrease the DatePicker's day value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_decrement_day_button">Decrease day</string>
+    <!-- Description of the button to increase the DatePicker's year value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_increment_year_button">Increase year</string>
+    <!-- Description of the button to decrease the DatePicker's year value. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_decrement_year_button">Decrease year</string>
+    <!-- Description of the button to move to the previous month. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_prev_month_button">Previous month</string>
+    <!-- Description of the button to move to the next month. [CHAR LIMIT=NONE] -->
+    <string name="date_picker_next_month_button">Next month</string>
+
+    <!-- KeyboardView - accessibility support -->
+    <!-- Description of the Alt button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_alt">Alt</string>
+    <!-- Description of the Cancel button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_cancel">Cancel</string>
+    <!-- Description of the Delete button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_delete">Delete</string>
+    <!-- Description of the Done button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_done">Done</string>
+    <!-- Description of the Mode change button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_mode_change">Mode change</string>
+    <!-- Description of the Shift button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_shift">Shift</string>
+    <!-- Description of the Enter button in a KeyboardView. [CHAR LIMIT=NONE] -->
+    <string name="keyboardview_keycode_enter">Enter</string>
+
+    <!-- ActivityChooserView - accessibility support -->
+    <!-- Description of the shwoing of a popup window with activities to choose from. [CHAR LIMIT=NONE] -->
+    <string name="activitychooserview_choose_application">Choose an app</string>
+
+    <!-- Error message if the share target app cannto be launched. [CHAR LIMIT=NONE] -->
+    <string name="activitychooserview_choose_application_error">Couldn\'t launch <xliff:g example="Acme" id="application_name">%s</xliff:g></string>
+
+    <!-- ShareActionProvider - accessibility support -->
+    <!-- Description of the choose target button in a ShareActionProvider (share UI). [CHAR LIMIT=NONE] -->
+    <string name="shareactionprovider_share_with">Share with</string>
+    <!-- Description of a share target (both in the list of such or the default share button) in a ShareActionProvider (share UI). [CHAR LIMIT=NONE] -->
+    <string name="shareactionprovider_share_with_application">Share with <xliff:g example="Bluetooth" id="application_name">%s</xliff:g></string>
+
+    <!-- Slide lock screen -->
+
+    <!-- Description of the sliding handle in the Slide unlock screen. [CHAR LIMIT=NONE] -->
+    <string name="content_description_sliding_handle">Sliding handle. Touch &amp; hold.</string>
+
+    <!-- Description of the unlock handle in the Slide unlock screen for tablets. [CHAR LIMIT=NONE] -->
+    <string name="description_target_unlock_tablet">Swipe to unlock.</string>
+
+    <!-- Announce that a headset is required to hear keyboard keys while typing a password. [CHAR LIMIT=NONE] -->
+    <string name="keyboard_headset_required_to_hear_password">Plug in a headset to hear password keys spoken.</string>
+    <!-- The value of a keyboard key announced when accessibility is enabled and no headsed is used. [CHAR LIMIT=NONE] -->
+    <string name="keyboard_password_character_no_headset">Dot</string>
+
+    <!-- Content description for the action bar "home" affordance. [CHAR LIMIT=NONE] -->
+    <string name="action_bar_home_description">Navigate home</string>
+    <!-- Content description for the action bar "up" affordance. [CHAR LIMIT=NONE] -->
+    <string name="action_bar_up_description">Navigate up</string>
+    <!-- Content description for the action menu overflow button. [CHAR LIMIT=NONE] -->
+    <string name="action_menu_overflow_description">More options</string>
+    <!-- Formatting string for describing the action bar's title/home/up affordance.
+         This is a single tappable "button" that includes the app icon, the Up indicator
+         (usually a "<" chevron) and the window title text.
+         %1$s is the title. %2$s is the description of what tapping/clicking the whole
+         thing is going to do. -->
+    <string name="action_bar_home_description_format">%1$s, %2$s</string>
+    <!-- Just like action_bar_home_description_format, but this one will be used
+         if the window is also providing subtitle text.
+         %1$s is the title. %2$s is the subtitle. %3$s is the description of what
+         tapping/clicking the whole thing is going to do. -->
+    <string name="action_bar_home_subtitle_description_format">%1$s, %2$s, %3$s</string>
+
+    <!-- Storage description for internal shared storage. [CHAR LIMIT=NONE] -->
+    <string name="storage_internal">Internal shared storage</string>
+
+    <!-- Storage description for a generic SD card. [CHAR LIMIT=NONE] -->
+    <string name="storage_sd_card">SD card</string>
+    <!-- Storage description for a SD card from a specific manufacturer. [CHAR LIMIT=NONE] -->
+    <string name="storage_sd_card_label"><xliff:g example="SanDisk" id="manufacturer">%s</xliff:g> SD card</string>
+
+    <!-- Storage description for a generic USB drive. [CHAR LIMIT=NONE] -->
+    <string name="storage_usb_drive">USB drive</string>
+    <!-- Storage description for a USB drive from a specific manufacturer. [CHAR LIMIT=NONE] -->
+    <string name="storage_usb_drive_label"><xliff:g example="Seagate" id="manufacturer">%s</xliff:g> USB drive</string>
+
+    <!-- Storage description for USB storage. [CHAR LIMIT=NONE] -->
+    <string name="storage_usb">USB storage</string>
+
+    <!-- Button text for the edit menu in input method extract mode. [CHAR LIMIT=16] -->
+    <string name="extract_edit_menu_button">Edit</string>
+
+    <!-- Notification title when data usage has exceeded warning threshold. [CHAR LIMIT=50] -->
+    <string name="data_usage_warning_title">Data usage alert</string>
+    <!-- Notification body when data usage has exceeded warning threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_warning_body">Touch to view usage and settings</string>
+
+    <!-- Notification title when 2G-3G data usage has exceeded limit threshold, and has been disabled. [CHAR LIMIT=32] -->
+    <string name="data_usage_3g_limit_title">2G\u20113G data limit reached</string>
+    <!-- Notification title when 4G data usage has exceeded limit threshold, and has been disabled. [CHAR LIMIT=32] -->
+    <string name="data_usage_4g_limit_title">4G data limit reached</string>
+    <!-- Notification title when mobile data usage has exceeded limit threshold, and has been disabled. [CHAR LIMIT=32] -->
+    <string name="data_usage_mobile_limit_title">Mobile data limit reached</string>
+    <!-- Notification title when Wi-Fi data usage has exceeded limit threshold, and has been disabled. [CHAR LIMIT=32] -->
+    <string name="data_usage_wifi_limit_title">Wi\u2011Fi data limit reached</string>
+    <!-- Notification body when data usage has exceeded limit threshold, and has been disabled. [CHAR LIMIT=32] -->
+    <string name="data_usage_limit_body">Data paused for rest of cycle</string>
+
+    <!-- Notification title when 2G-3G data usage has exceeded limit threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_3g_limit_snoozed_title">2G\u20113G data limit exceeded</string>
+    <!-- Notification title when 4G data usage has exceeded limit threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_4g_limit_snoozed_title">4G data limit exceeded</string>
+    <!-- Notification title when mobile data usage has exceeded limit threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_mobile_limit_snoozed_title">Mobile data limit exceeded</string>
+    <!-- Notification title when Wi-Fi data usage has exceeded limit threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_wifi_limit_snoozed_title">Wi\u2011Fi data limit exceeded</string>
+    <!-- Notification body when data usage has exceeded limit threshold. [CHAR LIMIT=32] -->
+    <string name="data_usage_limit_snoozed_body"><xliff:g example="3.8GB" id="size">%s</xliff:g> over specified limit.</string>
+
+    <!-- Notification title when background data usage is limited. [CHAR LIMIT=32] -->
+    <string name="data_usage_restricted_title">Background data restricted</string>
+    <!-- Notification body when background data usage is limited. [CHAR LIMIT=32] -->
+    <string name="data_usage_restricted_body">Touch to remove restriction</string>
+
+    <!-- SSL Certificate dialogs -->
+    <!-- Title for an SSL Certificate dialog -->
+    <string name="ssl_certificate">Security certificate</string>
+    <!-- Message on an SSL Certificate dialog -->
+    <string name="ssl_certificate_is_valid">This certificate is valid.</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="issued_to">Issued to:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="common_name">Common name:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="org_name">Organisation:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="org_unit">Organisational unit:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="issued_by">Issued by:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="validity_period">Validity:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="issued_on">Issued on:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="expires_on">Expires on:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="serial_number">Serial number:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="fingerprints">Fingerprints:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="sha256_fingerprint">SHA\u2011256 fingerprint:</string>
+    <!-- Label for an information field on an SSL Certificate Dialog -->
+    <string name="sha1_fingerprint">SHA\u20111 fingerprint:</string>
+
+    <!-- Title for a button to expand the list of activities in ActivityChooserView [CHAR LIMIT=25] -->
+    <string name="activity_chooser_view_see_all">See all</string>
+    <!-- Title default for a dialog showing possible activities in ActivityChooserView [CHAR LIMIT=25] -->
+    <string name="activity_chooser_view_dialog_title_default">Choose activity</string>
+
+    <!-- Title for a dialog showing possible activities for sharing in ShareActionProvider [CHAR LIMIT=25] -->
+    <string name="share_action_provider_share_with">Share with</string>
+
+    <!-- STK sending DTMF, SMS, USSD, SS -->
+    <string name="sending">Sending\u2026</string>
+
+    <!-- STK launch Browser -->
+    <string name="launchBrowserDefault">Launch Browser?</string>
+
+    <!-- STK setup Call -->
+    <string name="SetupCallDefault">Accept call?</string>
+
+    <!-- Title for a button to choose the currently selected activity
+         as the default in the activity resolver. [CHAR LIMIT=25] -->
+    <string name="activity_resolver_use_always">Always</string>
+
+    <!-- Title for a button to choose the currently selected activity
+         from the activity resolver to use just this once. [CHAR LIMIT=25] -->
+    <string name="activity_resolver_use_once">Just once</string>
+
+    <!-- Text for the toast that is shown when the user clicks on a launcher that
+         doesn't support the work profile. [CHAR LIMIT=100] -->
+    <string name="activity_resolver_work_profiles_support">%1$s doesn\'t support work profile</string>
+
+    <!-- Name of the default audio route for tablets when nothing
+         is connected to a headphone or other wired audio output jack. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_name" product="tablet">Tablet</string>
+
+    <!-- Name of the default audio route for tablets when nothing
+         is connected to a headphone or other wired audio output jack. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_name" product="tv">TV</string>
+
+    <!-- Name of the default audio route when nothing is connected to
+         a headphone or other wired audio output jack. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_name" product="default">Phone</string>
+
+    <!-- Name of the default audio route when wired headphones are
+         connected. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_name_headphones">Headphones</string>
+
+    <!-- Name of the default audio route when an audio dock is connected. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_name_dock_speakers">Dock speakers</string>
+
+    <!-- Name of the default media route when HDMI is connected. [CHAR LIMIT=50] -->
+    <string name="default_media_route_name_hdmi">HDMI</string>
+
+    <!-- Name of the default audio route category. [CHAR LIMIT=50] -->
+    <string name="default_audio_route_category_name">System</string>
+
+    <!-- Description of the bluetooth a2dp audio route. [CHAR LIMIT=50] -->
+    <string name="bluetooth_a2dp_audio_route_name">Bluetooth audio</string>
+
+    <!-- Description of a wireless display route. [CHAR LIMIT=50] -->
+    <string name="wireless_display_route_description">Wireless display</string>
+
+    <!-- Content description of a MediaRouteButton for accessibility support.
+        Cast is the standard android verb for sending content to a remote device. [CHAR LIMIT=50] -->
+    <string name="media_route_button_content_description">Cast</string>
+
+    <!-- Title of the media route chooser dialog. [CHAR LIMIT=40] -->
+    <string name="media_route_chooser_title">Connect to device</string>
+
+    <!-- Title of the media route chooser dialog for selecting remote display routes. [CHAR LIMIT=40] -->
+    <string name="media_route_chooser_title_for_remote_display">Cast screen to device</string>
+
+    <!-- Placeholder text to show when no devices have been found. [CHAR LIMIT=50] -->
+    <string name="media_route_chooser_searching">Searching for devices\u2026</string>
+
+    <!-- Button to access extended settings.  [CHAR LIMIT=30] -->
+    <string name="media_route_chooser_extended_settings">Settings</string>
+
+    <!-- Button to disconnect from a media route.  [CHAR LIMIT=30] -->
+    <string name="media_route_controller_disconnect">Disconnect</string>
+
+    <!-- Status message for remote routes attempting to scan/determine availability -->
+    <string name="media_route_status_scanning">Scanning...</string>
+
+    <!-- Status message for a remote route attempting to connect -->
+    <string name="media_route_status_connecting">Connecting...</string>
+
+    <!-- Status message for a remote route that is confirmed to be available for connection -->
+    <string name="media_route_status_available">Available</string>
+
+    <!-- Status message for remote routes that are not available for connection right now -->
+    <string name="media_route_status_not_available">Not available</string>
+
+    <!-- Status message for a remote route that is in use (and thus unavailabe) right now -->
+    <string name="media_route_status_in_use">In use</string>
+
+    <!-- Display manager service -->
+
+    <!-- Name of the built-in display.  [CHAR LIMIT=50] -->
+    <string name="display_manager_built_in_display_name">Built\u2011in screen</string>
+
+    <!-- Name of the HDMI display.  [CHAR LIMIT=50] -->
+    <string name="display_manager_hdmi_display_name">HDMI screen</string>
+
+    <!-- Name of the N'th overlay display for testing.  [CHAR LIMIT=50] -->
+    <string name="display_manager_overlay_display_name">Overlay #<xliff:g id="id">%1$d</xliff:g></string>
+
+    <!-- Title text to show within the overlay.  [CHAR LIMIT=50] -->
+    <string name="display_manager_overlay_display_title"><xliff:g id="name">%1$s</xliff:g>: <xliff:g id="width">%2$d</xliff:g>x<xliff:g id="height">%3$d</xliff:g>, <xliff:g id="dpi">%4$d</xliff:g> dpi</string>
+
+    <!-- Title text to append when the display is secure.  [CHAR LIMIT=30] -->
+    <string name="display_manager_overlay_display_secure_suffix">, secure</string>
+
+    <!-- Keyguard strings -->
+    <!-- Message shown in pattern unlock after some number of unsuccessful attempts -->
+    <string name="kg_forgot_pattern_button_text">Forgot Pattern</string>
+    <!-- Message shown when user enters wrong pattern -->
+    <string name="kg_wrong_pattern">Wrong Pattern</string>
+    <!-- Message shown when user enters wrong password -->
+    <string name="kg_wrong_password">Wrong Password</string>
+    <!-- Message shown when user enters wrong PIN -->
+    <string name="kg_wrong_pin">Wrong PIN</string>
+    <!-- Countdown message shown after too many failed unlock attempts -->
+    <string name="kg_too_many_failed_attempts_countdown">Try again in <xliff:g id="number">%1$d</xliff:g> seconds.</string>
+    <!-- Instructions for using the pattern unlock screen -->
+    <string name="kg_pattern_instructions">Draw your pattern</string>
+    <!-- Instructions for using the SIM PIN unlock screen -->
+    <string name="kg_sim_pin_instructions">Enter SIM PIN</string>
+    <!-- Instructions for using the PIN unlock screen -->
+    <string name="kg_pin_instructions">Enter PIN</string>
+    <!-- Instructions for using the password unlock screen -->
+    <string name="kg_password_instructions">Enter Password</string>
+    <!-- Hint shown in the PUK screen that asks the user to enter the PUK code given to them by their provider -->
+    <string name="kg_puk_enter_puk_hint">SIM is now disabled. Enter PUK code to continue. Contact carrier for details.</string>
+    <!-- Hint shown in the PUK unlock screen PIN TextView -->
+    <string name="kg_puk_enter_pin_hint">Enter desired PIN code</string>
+    <!-- Message shown when the user needs to confirm the PIN they just entered in the PUK screen -->
+    <string name="kg_enter_confirm_pin_hint">Confirm desired PIN code</string>
+    <!-- Message shown in dialog while the device is unlocking the SIM card -->
+    <string name="kg_sim_unlock_progress_dialog_message">Unlocking SIM card\u2026</string>
+    <!-- Message shown when the user enters the wrong PIN code -->
+    <string name="kg_password_wrong_pin_code">Incorrect PIN code.</string>
+    <!-- Message shown when the user enters an invalid SIM pin password in PUK screen -->
+    <string name="kg_invalid_sim_pin_hint">Type a PIN that is 4\u20118 digits</string>
+    <!-- Message shown when the user enters an invalid PUK code in the PUK screen -->
+    <string name="kg_invalid_sim_puk_hint">PUK code should be 8 digits</string>
+    <!-- Message shown when the user enters an invalid PUK code -->
+    <string name="kg_invalid_puk">Re\u2011enter the correct PUK code. Repeated attempts will permanently disable the SIM.</string>
+      <!-- String shown in PUK screen when PIN codes don't match -->
+    <string name="kg_invalid_confirm_pin_hint" product="default">PIN codes does not match</string>
+    <!-- Message shown when the user exceeds the maximum number of pattern attempts -->
+    <string name="kg_login_too_many_attempts">Too many pattern attempts</string>
+    <!-- Instructions show in account unlock screen allowing user to enter their email password -->
+    <string name="kg_login_instructions">To unlock, sign in with your Google account.</string>
+    <!-- Hint shown in TextView in account unlock screen of keyguard -->
+    <string name="kg_login_username_hint">Username (email)</string>
+    <!-- Hint shown in TextView in account unlock screen of keyguard -->
+    <string name="kg_login_password_hint">Password</string>
+    <!-- Label shown on sign in button on account unlock screen of keyguard -->
+    <string name="kg_login_submit_button">Sign in</string>
+    <!-- Message shown when the user enters an invalid username/password combination in account unlock screen of keyguard -->
+    <string name="kg_login_invalid_input">Invalid username or password.</string>
+    <!-- Hint text shown when user has too many failed password attempts in account unlock screen of keyguard -->
+    <string name="kg_login_account_recovery_hint">Forgot your username or password\?\nVisit <b>google.com/accounts/recovery</b>.</string>
+    <!-- Message shown while device checks username/password in account unlock screen of keyguard -->
+    <string name="kg_login_checking_password">Checking account\u2026</string>
+    <!-- Message shown in dialog when max number of attempts are reached for PIN screen of keyguard -->
+    <string name="kg_too_many_failed_pin_attempts_dialog_message">You have incorrectly typed your PIN <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+    <!-- Message shown in dialog when max number of attempts are reached for password screen of keyguard -->
+    <string name="kg_too_many_failed_password_attempts_dialog_message">You have incorrectly typed your password <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+    <string name="kg_too_many_failed_pattern_attempts_dialog_message">You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. \n\nTry again in <xliff:g id="number">%2$d</xliff:g> seconds. </string>
+    <!-- Message shown when user is almost at the limit of password attempts where the device will be wiped. -->
+    <string name="kg_failed_attempts_almost_at_wipe" product="tablet"> You have incorrectly attempted to unlock the tablet <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the tablet will be reset to factory default and all user data will be lost. </string>
+    <!-- Message shown when user is almost at the limit of password attempts where the device will be wiped. -->
+    <string name="kg_failed_attempts_almost_at_wipe" product="tv"> You have incorrectly attempted to unlock the TV <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the TV will be reset to factory default and all user data will be lost. </string>
+    <!-- Message shown when user is almost at the limit of password attempts where the device will be wiped. -->
+    <string name="kg_failed_attempts_almost_at_wipe" product="default">You have incorrectly attempted to unlock the phone <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, the phone will be reset to factory default and all user data will be lost. </string>
+    <!-- Message shown in dialog when user has exceeded the maximum attempts and the device will now be wiped -->
+    <string name="kg_failed_attempts_now_wiping" product="tablet"> You have incorrectly attempted to unlock the tablet <xliff:g id="number">%d</xliff:g> times. The tablet will now be reset to factory default. </string>
+    <!-- Message shown in dialog when user has exceeded the maximum attempts and the device will now be wiped -->
+    <string name="kg_failed_attempts_now_wiping" product="tv"> You have incorrectly attempted to unlock the TV <xliff:g id="number">%d</xliff:g> times. The TV will now be reset to factory default. </string>
+    <!-- Message shown in dialog when user has exceeded the maximum attempts and the device will now be wiped -->
+    <string name="kg_failed_attempts_now_wiping" product="default">You have incorrectly attempted to unlock the phone <xliff:g id="number">%d</xliff:g> times. The phone will now be reset to factory default. </string>
+    <!-- Message shown in dialog when user is almost at the limit where they will be
+    locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="kg_failed_attempts_almost_at_login" product="tablet"> You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your tablet using an email account.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+    <!-- Message shown in dialog when user is almost at the limit where they will be
+    locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="kg_failed_attempts_almost_at_login" product="tv"> You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your TV using an email account.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+    <!-- Message shown in dialog when user is almost at the limit where they will be
+    locked out and may have to enter an alternate username/password to unlock the phone -->
+    <string name="kg_failed_attempts_almost_at_login" product="default">You have incorrectly drawn your unlock pattern <xliff:g id="number">%1$d</xliff:g> times. After <xliff:g id="number">%2$d</xliff:g> more unsuccessful attempts, you will be asked to unlock your phone using an email account.\n\n Try again in <xliff:g id="number">%3$d</xliff:g> seconds. </string>
+    <!-- Sequence of characters used to separate message strings in keyguard. Typically just em-dash
+         with spaces on either side. [CHAR LIMIT=3] -->
+    <string name="kg_text_message_separator" product="default">\u2014 </string>
+    <!-- The delete-widget drop target button text -->
+    <string name="kg_reordering_delete_drop_target_text">Remove</string>
+
+    <!-- Message shown in dialog when user is attempting to set the music volume above the
+    recommended maximum level for headphones -->
+    <string name="safe_media_volume_warning" product="default">Raise volume above recommended level?\n\nListening at high volume for long periods may damage your hearing.</string>
+
+    <!-- Text spoken when the user is performing a gesture that will enable accessibility. [CHAR LIMIT=none] -->
+    <string name="continue_to_enable_accessibility">Keep holding down two fingers to enable accessibility.</string>
+    <!-- Text spoken when the user enabled accessibility. [CHAR LIMIT=none] -->
+    <string name="accessibility_enabled">Accessibility enabled.</string>
+    <!-- Text spoken when the user stops preforming a gesture that would enable accessibility. [CHAR LIMIT=none] -->
+    <string name="enable_accessibility_canceled">Accessibility cancelled.</string>
+    <!-- Text spoken when the current user is switched if accessibility is enabled. [CHAR LIMIT=none] -->
+    <string name="user_switched">Current user <xliff:g example="Bob" id="name">%1$s</xliff:g>.</string>
+    <!-- Message shown when switching to a user [CHAR LIMIT=none] -->
+    <string name="user_switching_message">Switching to <xliff:g example="Bob" id="name">%1$s</xliff:g>\u2026</string>
+    <!-- Message when logging out a user on a split user system -->
+    <string name="user_logging_out_message">Logging out <xliff:g example="Bob" id="name">%1$s</xliff:g>\u2026</string>
+    <!-- Default name of the owner user [CHAR LIMIT=20] -->
+    <string msgid="3879126011135546571" name="owner_name">Owner</string>
+    <!-- Error message title [CHAR LIMIT=35] -->
+    <string name="error_message_title">Error</string>
+    <!-- Message informing user that the change was disallowed by an administrator. [CHAR LIMIT=none] -->
+    <string name="error_message_change_not_allowed">This change isn\'t allowed by your administrator</string>
+    <!-- Message informing user that the requested activity could not be found [CHAR LIMIT=none] -->
+    <string name="app_not_found">No application found to handle this action</string>
+    <string name="revoke">Revoke</string>
+
+    <!-- Printing -->
+
+    <!-- ISO (European standard) A0 media (paper) size: 33.11" × 46.81" -->
+    <string name="mediasize_iso_a0">ISO A0</string>
+    <!-- ISO (European standard) A1 media (paper) size: 23.39" × 33.11" -->
+    <string name="mediasize_iso_a1">ISO A1</string>
+    <!-- ISO (European standard) A2 media (paper) size: 16.54" x 23.39" -->
+    <string name="mediasize_iso_a2">ISO A2</string>
+    <!-- ISO (European standard) A3 media (paper) size: 11.69" x 16.54" -->
+    <string name="mediasize_iso_a3">ISO A3</string>
+    <!-- ISO (European standard) A4 media (paper) size: 8.27" x 11.69" -->
+    <string name="mediasize_iso_a4">ISO A4</string>
+    <!-- ISO (European standard) A5 media (paper) size: 5.83" x 8.27" -->
+    <string name="mediasize_iso_a5">ISO A5</string>
+    <!-- ISO (European standard) A6 media (paper) size: 4.13" x 5.83" -->
+    <string name="mediasize_iso_a6">ISO A6</string>
+    <!-- ISO (European standard) A7 media (paper) size: 2.91" x 4.13" -->
+    <string name="mediasize_iso_a7">ISO A7</string>
+    <!-- ISO (European standard) A8 media (paper) size: 2.05" x 2.91" -->
+    <string name="mediasize_iso_a8">ISO A8</string>
+    <!-- ISO (European standard) A9 media (paper) size: 1.46" x 2.05" -->
+    <string name="mediasize_iso_a9">ISO A9</string>
+    <!-- ISO (European standard) A10 media (paper) size: 1.02" x 1.46" -->
+    <string name="mediasize_iso_a10">ISO A10</string>
+
+    <!-- ISO (European standard) B0 media (paper) size: 39.37" x 55.67" -->
+    <string name="mediasize_iso_b0">ISO B0</string>
+    <!-- ISO (European standard) B1 media (paper) size: 27.83" x 39.37" -->
+    <string name="mediasize_iso_b1">ISO B1</string>
+    <!-- ISO (European standard) B2 media (paper) size - 19.69" x 27.83" -->
+    <string name="mediasize_iso_b2">ISO B2</string>
+    <!-- ISO (European standard) B3 media (paper) size: 13.90" x 19.69" -->
+    <string name="mediasize_iso_b3">ISO B3</string>
+    <!-- ISO (European standard) B4 media (paper) size: 9.84" x 13.90" -->
+    <string name="mediasize_iso_b4">ISO B4</string>
+    <!-- ISO (European standard) B5 media (paper) size: 6.93" x 9.84" -->
+    <string name="mediasize_iso_b5">ISO B5</string>
+    <!-- ISO (European standard) B6 media (paper) size: 4.92" x 6.93" -->
+    <string name="mediasize_iso_b6">ISO B6</string>
+    <!-- ISO (European standard) B7 media (paper) size: 3.46" x 4.92" -->
+    <string name="mediasize_iso_b7">ISO B7</string>
+    <!-- ISO (European standard) B8 media (paper) size: 2.44" x 3.46" -->
+    <string name="mediasize_iso_b8">ISO B8</string>
+    <!-- ISO (European standard) B9 media (paper) size: 1.73" x 2.44" -->
+    <string name="mediasize_iso_b9">ISO B9</string>
+    <!-- ISO (European standard) B10 media (paper) size: 1.22" x 1.73" -->
+    <string name="mediasize_iso_b10">ISO B10</string>
+
+    <!-- ISO (European standard) C0 media (paper) size: 36.10" x 51.06" -->
+    <string name="mediasize_iso_c0">ISO C0</string>
+    <!-- ISO (European standard) C1 media (paper) size: 25.51" x 36.10" -->
+    <string name="mediasize_iso_c1">ISO C1</string>
+    <!-- ISO (European standard) C2 media (paper) size: 18.03" x 25.51" -->
+    <string name="mediasize_iso_c2">ISO C2</string>
+    <!-- ISO (European standard) C3 media (paper) size: 12.76" x 18.03" -->
+    <string name="mediasize_iso_c3">ISO C3</string>
+    <!-- ISO (European standard) C4 media (paper) size: 9.02" x 12.76" -->
+    <string name="mediasize_iso_c4">ISO C4</string>
+    <!-- ISO (European standard) C5 media (paper) size: 6.38" x 9.02" -->
+    <string name="mediasize_iso_c5">ISO C5</string>
+    <!-- ISO (European standard) C6 media (paper) size: 4.49" x 6.38" -->
+    <string name="mediasize_iso_c6">ISO C6</string>
+    <!-- ISO (European standard) C7 media (paper) size: 3.19" x 4.49" -->
+    <string name="mediasize_iso_c7">ISO C7</string>
+    <!-- ISO ISO C8 media (paper) size: 2.24" x 3.19" -->
+    <string name="mediasize_iso_c8">ISO C8</string>
+    <!-- ISO ISO C9 media (paper) size: 1.57" x 2.24" -->
+    <string name="mediasize_iso_c9">ISO C9</string>
+    <!-- ISO (European standard) C10 media (paper) size: 1.10" x 1.57" -->
+    <string name="mediasize_iso_c10">ISO C10</string>
+
+    <!-- North America Letter media (paper) size: 8.5" × 11" (279mm x 216mm) -->
+    <string name="mediasize_na_letter">"Letter"</string>
+    <!-- North America Government Letter media (paper) size: 8.0" × 10.5" (203mm x 267mm) -->
+    <string name="mediasize_na_gvrnmt_letter">"Government Letter"</string>
+    <!-- North America Legal media (paper) size: 8.5" × 14" (216mm x 356mm) -->
+    <string name="mediasize_na_legal">"Legal"</string>
+    <!-- North America Junior Legal media (paper) size: 8.0" × 5.0" (203mm × 127mm) -->
+    <string name="mediasize_na_junior_legal">"Junior Legal"</string>
+    <!-- North America Ledger media (paper) size: 17" × 11" (432mm × 279mm) -->
+    <string name="mediasize_na_ledger">"Ledger"</string>
+    <!-- North America Tabloid media (paper) size: 11" × 17" (279mm × 432mm) -->
+    <string name="mediasize_na_tabloid">"Tabloid"</string>
+
+    <!-- North America Index Card 3x5 media (paper) size: 3" x 5" (76mm x 127mm) -->
+    <string name="mediasize_na_index_3x5">Index Card 3x5</string>
+    <!-- North America Index Card 4x6 media (paper) size: 4" x 6" (102mm x 152mm) -->
+    <string name="mediasize_na_index_4x6">Index Card 4x6</string>
+    <!-- North America Index Card 5x8 media (paper) size: 5" x 8" (127mm x 203mm) -->
+    <string name="mediasize_na_index_5x8">Index Card 5x8</string>
+    <!-- North America Monarch media (paper) size: 7.25" x 10.5" (184mm x 267mm) -->
+    <string name="mediasize_na_monarch">"Monarch"</string>
+    <!-- North America Quarto media (paper) size: 8" x 10" (203mm x 254mm) -->
+    <string name="mediasize_na_quarto">"Quarto"</string>
+    <!-- North America Foolscap media (paper) size: 8" x 13" (203mm x 330mm) -->
+    <string name="mediasize_na_foolscap">"Foolscap"</string>
+
+    <!-- Chinese Roc 8k media (paper) size: 270mm x 390mm (10.629" x 15.3543") -->
+    <string name="mediasize_chinese_roc_8k">ROC 8K</string>
+    <!-- Chinese Roc 16k media (paper) size: 195mm x 270mm (7.677" x 10.629") -->
+    <string name="mediasize_chinese_roc_16k">ROC 16K</string>
+
+    <!-- Chinese PRC 1 media (paper) size: 102mm x 165mm (4.015" x 6.496") -->
+    <string name="mediasize_chinese_prc_1">PRC 1</string>
+    <!-- Chinese PRC 2 media (paper) size: 102mm x 176mm (4.015" x 6.929") -->
+    <string name="mediasize_chinese_prc_2">PRC 2</string>
+    <!-- Chinese PRC 3 media (paper) size: 125mm x 176mm (4.921" x 6.929") -->
+    <string name="mediasize_chinese_prc_3">PRC 3</string>
+    <!-- Chinese PRC 4 media (paper) size: 110mm x 208mm (4.330" x 8.189") -->
+    <string name="mediasize_chinese_prc_4">PRC 4</string>
+    <!-- Chinese PRC 5 media (paper) size: 110mm x 220mm (4.330" x 8.661") -->
+    <string name="mediasize_chinese_prc_5">PRC 5</string>
+    <!-- Chinese PRC 6 media (paper) size: 120mm x 320mm (4.724" x 12.599") -->
+    <string name="mediasize_chinese_prc_6">PRC 6</string>
+    <!-- Chinese PRC 7 media (paper) size: 160mm x 230mm (6.299" x 9.055") -->
+    <string name="mediasize_chinese_prc_7">PRC 7</string>
+    <!-- Chinese PRC 8 media (paper) size: 120mm x 309mm (4.724" x 12.165") -->
+    <string name="mediasize_chinese_prc_8">PRC 8</string>
+    <!-- Chinese PRC 9 media (paper) size: 229mm x 324mm (9.016" x 12.756") -->
+    <string name="mediasize_chinese_prc_9">PRC 9</string>
+    <!-- Chinese PRC 10 media (paper) size: 324mm x 458mm (12.756" x 18.032") -->
+    <string name="mediasize_chinese_prc_10">PRC 10</string>
+
+    <!-- Chinese RPC 16K media (paper) size: 146mm x 215mm (5.749" x 8.465") -->
+    <string name="mediasize_chinese_prc_16k">PRC 16K</string>
+    <!-- Chinese Pa Kai media (paper) size: 146mm x 215mm (5.749" x 8.465") -->
+    <string name="mediasize_chinese_om_pa_kai">Pa Kai</string>
+    <!-- Chinese Dai Pa Kai media (paper) size: 275mm x 395mm (10.827" x 15.551") -->
+    <string name="mediasize_chinese_om_dai_pa_kai">Dai Pa Kai</string>
+    <!-- Chinese Jurro Ku Kai media (paper) size: 275mm x 395mm (10.827" x 15.551") -->
+    <string name="mediasize_chinese_om_jurro_ku_kai">Jurro Ku Kai</string>
+
+    <!-- Japanese JIS B10 media (paper) size: 32mm x 45mm (1.259" x 1.772") -->
+    <string name="mediasize_japanese_jis_b10">JIS B10</string>
+    <!-- Japanese JIS B9 media (paper) size: 45mm x 64mm (1.772" x 2.52") -->
+    <string name="mediasize_japanese_jis_b9">JIS B9</string>
+    <!-- Japanese JIS B8 media (paper) size: 64mm x 91mm (2.52" x 3.583") -->
+    <string name="mediasize_japanese_jis_b8">JIS B8</string>
+    <!-- Japanese JIS B7 media (paper) size: 91mm x 128mm (3.583" x 5.049") -->
+    <string name="mediasize_japanese_jis_b7">JIS B7</string>
+    <!-- Japanese JIS B6 media (paper) size: 128mm x 182mm (5.049" x 7.165") -->
+    <string name="mediasize_japanese_jis_b6">JIS B6</string>
+    <!-- Japanese JIS B5 media (paper) size: 182mm x 257mm (7.165" x 10.118") -->
+    <string name="mediasize_japanese_jis_b5">JIS B5</string>
+    <!-- Japanese JIS B4 media (paper) size: 257mm x 364mm (10.118" x 14.331") -->
+    <string name="mediasize_japanese_jis_b4">JIS B4</string>
+    <!-- Japanese JIS B3 media (paper) size: 364mm x 515mm (14.331" x 20.276") -->
+    <string name="mediasize_japanese_jis_b3">JIS B3</string>
+    <!-- Japanese JIS B2 media (paper) size: 515mm x 728mm (20.276" x 28.661") -->
+    <string name="mediasize_japanese_jis_b2">JIS B2</string>
+    <!-- Japanese JIS B1 media (paper) size: 728mm x 1030mm (28.661" x 40.551") -->
+    <string name="mediasize_japanese_jis_b1">JIS B1</string>
+    <!-- Japanese JIS B0 media (paper) size: 1030mm x 1456mm (40.551" x 57.323") -->
+    <string name="mediasize_japanese_jis_b0">JIS B0</string>
+
+    <!-- Japanese JIS Exec media (paper) size: 216mm x 330mm (8.504" x 12.992") -->
+    <string name="mediasize_japanese_jis_exec">JIS Exec</string>
+
+    <!-- Japanese Chou4 media (paper) size: 90mm x 205mm (3.543" x 8.071") -->
+    <string name="mediasize_japanese_chou4">Chou4</string>
+    <!-- Japanese Chou3 media (paper) size: 120mm x 235mm (4.724" x 9.252") -->
+    <string name="mediasize_japanese_chou3">Chou3</string>
+    <!-- Japanese Chou2 media (paper) size: 111.1mm x 146mm (4.374" x 5.748") -->
+    <string name="mediasize_japanese_chou2">Chou2</string>
+
+    <!-- Japanese Hagaki media (paper) size: 100mm x 148mm (3.937" x 5.827") -->
+    <string name="mediasize_japanese_hagaki">Hagaki </string>
+    <!-- Japanese Oufuku media (paper) size: 148mm x 200mm (5.827" x 7.874") -->
+    <string name="mediasize_japanese_oufuku">Oufuku </string>
+    <!-- Japanese Kahu media (paper) size: 240mm x 322.1mm (9.449" x 12.681") -->
+    <string name="mediasize_japanese_kahu">Kahu</string>
+    <!-- Japanese Kaku2 media (paper) size: 240mm x 332mm (9.449" x 13.071") -->
+    <string name="mediasize_japanese_kaku2">Kaku2</string>
+    <!-- Japanese You4 media (paper) size: 105mm x 235mm (4.134" x 9.252") -->
+    <string name="mediasize_japanese_you4">You4</string>
+
+    <!-- Media (paper) size for specifying any paper size in portrait.-->
+    <string name="mediasize_unknown_portrait">Unknown portrait</string>
+    <!-- Media (paper) size for specifying any paper size in landscape.-->
+    <string name="mediasize_unknown_landscape">Unknown landscape</string>
+
+    <!-- Write fail reason: printing was cancelled.[CHAR LIMIT=none] -->
+    <string name="write_fail_reason_cancelled">Cancelled</string>
+    <!-- Write fail reason: couldn't write the printed content. [CHAR LIMIT=none] -->
+    <string name="write_fail_reason_cannot_write">Error writing content</string>
+
+    <!-- Print fail reason: unknown. [CHAR LIMIT=25] -->
+    <string name="reason_unknown">unknown</string>
+
+    <!-- Print fail reason: the print service that has to process the print job is not available. [CHAR LIMIT=none] -->
+    <string name="reason_service_unavailable">Print service not enabled</string>
+
+    <!-- Title for the notification that a print service was installed. [CHAR LIMIT=50] -->
+    <string name="print_service_installed_title"><xliff:g example="Cloud Print" id="name">%s</xliff:g> service installed</string>
+    <!-- Message for the notification that a print service was installed. [CHAR LIMIT=50] -->
+    <string name="print_service_installed_message">Touch to enable</string>
+
+    <!-- PIN entry dialog title for entering the administrator PIN [CHAR LIMIT=none] -->
+    <string name="restr_pin_enter_admin_pin">Enter administrator PIN</string>
+    <!-- PIN entry dialog label/hint for PIN [CHAR LIMIT=none] -->
+    <string name="restr_pin_enter_pin">Enter PIN</string>
+    <!-- PIN entry dialog label/hint for incorrect PIN entry [CHAR LIMIT=none] -->
+    <string name="restr_pin_incorrect">Incorrect</string>
+    <!-- PIN entry dialog label/hint for old PIN [CHAR LIMIT=none] -->
+    <string name="restr_pin_enter_old_pin">Current PIN</string>
+    <!-- PIN entry dialog label for new PIN [CHAR LIMIT=none] -->
+    <string name="restr_pin_enter_new_pin">New PIN</string>
+    <!-- PIN entry dialog label for new PIN confirmation [CHAR LIMIT=none] -->
+    <string name="restr_pin_confirm_pin">Confirm new PIN</string>
+    <!-- PIN creation dialog message [CHAR LIMIT=none] -->
+    <string name="restr_pin_create_pin">Create a PIN for modifying restrictions</string>
+    <!-- PIN entry dialog error when PINs are not the same [CHAR LIMIT=none] -->
+    <string name="restr_pin_error_doesnt_match">PINs don\'t match. Try again.</string>
+    <!-- PIN entry dialog error when PIN is too short [CHAR LIMIT=none] -->
+    <string name="restr_pin_error_too_short">PIN is too short. Must be at least 4 digits.</string>
+    <!-- PIN entry dialog countdown message for next chance to enter the PIN [CHAR LIMIT=none] -->
+    <!-- Phrase describing a time duration using seconds [CHAR LIMIT=none] -->
+    <plurals name="restr_pin_countdown">
+        <item quantity="one">Try again in 1 second</item>
+        <item quantity="other">Try again in <xliff:g id="count">%d</xliff:g> seconds</item>
+    </plurals>
+    <!-- PIN entry dialog tells the user to not enter a PIN for a while. [CHAR LIMIT=none] -->
+    <string name="restr_pin_try_later">Try again later</string>
+
+    <!-- Cling help message title when hiding the navigation bar entering immersive mode [CHAR LIMIT=none] -->
+    <string name="immersive_cling_title">Viewing full screen</string>
+
+    <!-- Cling help message description when hiding the navigation bar entering immersive mode [CHAR LIMIT=none] -->
+    <string name="immersive_cling_description">To exit, swipe down from the top.</string>
+
+    <!-- Cling help message confirmation button when hiding the navigation bar entering immersive mode [CHAR LIMIT=30] -->
+    <string name="immersive_cling_positive">Got it</string>
+
+    <!-- Label for button to confirm chosen date or time [CHAR LIMIT=30] -->
+    <string name="done_label">Done</string>
+    <!--
+         Content description for the hour selector in the time picker, which displays
+         selectable hours of the day along the inside edge of a circle, as in an analog clock.
+         [CHAR LIMIT=50]
+    -->
+    <string name="hour_picker_description">Hours circular slider</string>
+    <!--
+         Content description for the minute selector in the time picker, which displays
+         selectable five-minute intervals along the inside edge of a circle, as in an analog clock.
+         [CHAR LIMIT=50]
+    -->
+    <string name="minute_picker_description">Minutes circular slider</string>
+    <!-- Accessibility announcement for hour circular picker [CHAR LIMIT=NONE] -->
+    <string name="select_hours">Select hours</string>
+    <!-- Accessibility announcement for minute circular picker [CHAR LIMIT=NONE] -->
+    <string name="select_minutes">Select minutes</string>
+
+    <!-- Accessibility announcement for the day picker [CHAR LIMIT=NONE] -->
+    <string name="select_day">Select month and day</string>
+    <!-- Accessibility announcement for the year picker [CHAR LIMIT=NONE] -->
+    <string name="select_year">Select year</string>
+    <!-- Accessibility announcement when a number that had been typed in is deleted [CHAR_LIMIT=NONE] -->
+    <string name="deleted_key"><xliff:g example="4" id="key">%1$s</xliff:g> deleted</string>
+
+    <!--
+        Used to wrap a label for content description for a work profile, e.g. "Work Email" instead
+        of email when there are two email apps.
+        [CHAR LIMIT=20]
+     -->
+    <string name="managed_profile_label_badge">Work <xliff:g example="Email" id="label">%1$s</xliff:g></string>
+
+    <!-- DO NOT TRANSLATE -->
+    <string name="time_placeholder">--</string>
+
+    <!-- DO NOT TRANSLATE -->
+    <string name="radial_numbers_typeface">sans-serif</string>
+    <!-- DO NOT TRANSLATE -->
+    <string name="sans_serif">sans-serif</string>
+
+    <!-- DO NOT TRANSLATE -->
+    <string name="date_picker_month_typeface">sans-serif-medium</string>
+    <!-- DO NOT TRANSLATE -->
+    <string name="date_picker_day_of_week_typeface">sans-serif-medium</string>
+    <!-- DO NOT TRANSLATE -->
+    <string name="date_picker_day_typeface">sans-serif-medium</string>
+
+    <!-- Notify use that they are in Lock-to-app -->
+    <string name="lock_to_app_toast">To unpin this screen, touch &amp; hold Back.</string>
+    <!-- Notify user that they are locked in lock-to-app mode -->
+    <string name="lock_to_app_toast_locked">App is pinned: Unpinning isn\'t allowed on this device.</string>
+    <!-- Starting lock-to-app indication. -->
+    <string name="lock_to_app_start">Screen pinned</string>
+    <!-- Exting lock-to-app indication. -->
+    <string name="lock_to_app_exit">Screen unpinned</string>
+
+    <!-- Lock-to-app unlock pin string -->
+    <string name="lock_to_app_unlock_pin">Ask for PIN before unpinning</string>
+    <!-- Lock-to-app unlock pattern string -->
+    <string name="lock_to_app_unlock_pattern">Ask for unlock pattern before unpinning</string>
+    <!-- Lock-to-app unlock password string -->
+    <string name="lock_to_app_unlock_password">Ask for password before unpinning</string>
+
+    <!-- Notification shown when device owner silently installs a package [CHAR LIMIT=NONE] -->
+    <string name="package_installed_device_owner">Installed by your administrator</string>
+    <!-- Notification shown when device owner silently updates a package [CHAR LIMIT=NONE] -->
+    <string name="package_updated_device_owner">Updated by your administrator</string>
+    <!-- Notification shown when device owner silently deletes a package [CHAR LIMIT=NONE] -->
+    <string name="package_deleted_device_owner">Deleted by your administrator</string>
+
+    <!-- [CHAR_LIMIT=NONE] Battery saver: Feature description -->
+    <string name="battery_saver_description">To help improve battery life, battery saver reduces your device’s performance and limits vibration, location services, and most background data. Email, messaging, and other apps that rely on syncing may not update unless you open them.\n\nBattery saver turns off automatically when your device is charging.</string>
+
+    <!-- [CHAR_LIMIT=NONE] Data saver: Feature description -->
+    <string name="data_saver_description">To help reduce data usage, data saver prevents some apps from sending or receiving data in the background. An app you’re currently using can access data, but may do so less frequently. This may mean, for example, that images don’t display until you tap them.</string>
+    <!-- [CHAR_LIMIT=35] Data saver: Title on first-time dialog -->
+    <string name="data_saver_enable_title">Turn on data saver?</string>
+    <!-- [CHAR_LIMIT=16] Data saver: Button to turn it on on first-time dialog -->
+    <string name="data_saver_enable_button">Turn on</string>
+
+    <!-- Zen mode condition - summary: time duration in minutes. [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_minutes_summary">
+        <item quantity="one">For one minute (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+        <item quantity="other">For %1$d minutes (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+    </plurals>
+
+    <!-- Zen mode condition - summary: time duration in minutes (short version). [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_minutes_summary_short">
+        <item quantity="one">For 1 min (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+        <item quantity="other">For %1$d min (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+    </plurals>
+
+    <!-- Zen mode condition - summary: time duration in hours. [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_hours_summary">
+        <item quantity="one">For one hour (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+        <item quantity="other">For %1$d hours (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+    </plurals>
+
+    <!-- Zen mode condition - summary: time duration in hours (short version). [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_hours_summary_short">
+        <item quantity="one">For 1 hr (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+        <item quantity="other">For %1$d hr (until <xliff:g example="10:00 PM" id="formattedTime">%2$s</xliff:g>)</item>
+    </plurals>
+
+    <!-- Zen mode condition - line one: time duration in minutes. [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_minutes">
+        <item quantity="one">For one minute</item>
+        <item quantity="other">For %d minutes</item>
+    </plurals>
+
+    <!-- Zen mode condition - line one: time duration in minutes (short version). [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_minutes_short">
+        <item quantity="one">For 1 min</item>
+        <item quantity="other">For %d min</item>
+    </plurals>
+
+    <!-- Zen mode condition - line one: time duration in hours. [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_hours">
+        <item quantity="one">For one hour</item>
+        <item quantity="other">For %d hours</item>
+    </plurals>
+
+    <!-- Zen mode condition - line one: time duration in hours (short version). [CHAR LIMIT=NONE] -->
+    <plurals name="zen_mode_duration_hours_short">
+        <item quantity="one">For 1 hr</item>
+        <item quantity="other">For %d hr</item>
+    </plurals>
+
+    <!-- Zen mode condition - line two: ending time. [CHAR LIMIT=NONE] -->
+    <string name="zen_mode_until">Until <xliff:g example="10:00 PM" id="formattedTime">%1$s</xliff:g></string>
+
+    <!-- Zen mode condition - line one: Until next alarm. [CHAR LIMIT=NONE] -->
+    <string name="zen_mode_alarm">Until <xliff:g example="10:00 PM" id="formattedTime">%1$s</xliff:g> (next alarm)</string>
+
+    <!-- Zen mode condition: no exit criteria. [CHAR LIMIT=NONE] -->
+    <string name="zen_mode_forever">Until you turn this off</string>
+
+    <!-- Zen mode condition: no exit criteria, includes the name of the feature for emphasis. [CHAR LIMIT=NONE] -->
+    <string name="zen_mode_forever_dnd">Until you turn off Do Not Disturb</string>
+
+    <!-- Zen mode active automatic rule name separator. [CHAR LIMIT=NONE] -->
+    <string name="zen_mode_rule_name_combination"><xliff:g example="Weeknights" id="first">%1$s</xliff:g> / <xliff:g example="Meetings" id="rest">%2$s</xliff:g></string>
+
+    <!-- Content description for the Toolbar icon used to collapse an expanded action mode. [CHAR LIMIT=NONE] -->
+    <string name="toolbar_collapse_description">Collapse</string>
+
+    <!-- Zen mode - feature name. [CHAR LIMIT=40] -->
+    <string name="zen_mode_feature_name">Do not disturb</string>
+
+    <!-- Zen mode - downtime legacy feature name. [CHAR LIMIT=40] -->
+    <string name="zen_mode_downtime_feature_name">Downtime</string>
+
+    <!-- Zen mode - name of default automatic schedule for weeknights. [CHAR LIMIT=40] -->
+    <string name="zen_mode_default_weeknights_name">Weeknight</string>
+
+    <!-- Zen mode - name of default automatic schedule for weekends. [CHAR LIMIT=40] -->
+    <string name="zen_mode_default_weekends_name">Weekend</string>
+
+    <!-- Zen mode - name of default automatic calendar event-based rule. [CHAR LIMIT=40] -->
+    <string name="zen_mode_default_events_name">Event</string>
+
+    <!-- Indication that the current volume and other effects (vibration) are being suppressed by a third party, such as a notification listener. [CHAR LIMIT=30] -->
+    <string name="muted_by">Muted by <xliff:g id="third_party">%1$s</xliff:g></string>
+
+    <!-- Error message shown when there is a system error which can be solved by user performing factory reset. [CHAR LIMIT=NONE] -->
+    <string name="system_error_wipe_data">There\'s an internal problem with your device, and it may be unstable until you factory data reset.</string>
+    <!-- Error message shown when there is a system error which can be solved by the manufacturer. [CHAR LIMIT=NONE] -->
+    <string name="system_error_manufacturer">There\'s an internal problem with your device. Contact your manufacturer for details.</string>
+
+    <!-- Displayed when the USSD/SS request is modified by STK CC to a
+    different request. This will be displayed in a toast. -->
+    <string name="stk_cc_ussd_to_dial">USSD request is modified to DIAL request.</string>
+    <string name="stk_cc_ussd_to_ss">USSD request is modified to SS request.</string>
+    <string name="stk_cc_ussd_to_ussd">USSD request is modified to new USSD request.</string>
+    <string name="stk_cc_ss_to_dial">SS request is modified to DIAL request.</string>
+    <string name="stk_cc_ss_to_ussd">SS request is modified to USSD request.</string>
+    <string name="stk_cc_ss_to_ss">SS request is modified to new SS request.</string>
+
+    <!-- Content description of the work profile icon in the notification. -->
+    <string name="notification_work_profile_content_description">Work profile</string>
+
+    <!-- Content description of the expand button icon in the notification.-->
+    <string name="expand_button_content_description">Expand button</string>
+
+    <!-- Accessibility action description on the expand button. -->
+    <string name="expand_action_accessibility">toggle expansion</string>
+
+    <!-- User visible name for USB MIDI Peripheral port -->
+    <string name="usb_midi_peripheral_name">Android USB Peripheral Port</string>
+    <!-- Manufacturer name for USB MIDI Peripheral port -->
+    <string name="usb_midi_peripheral_manufacturer_name">Android</string>
+    <!-- Product name for USB MIDI Peripheral port -->
+    <string name="usb_midi_peripheral_product_name">USB Peripheral Port</string>
+
+    <!-- Floating toolbar strings -->
+    <!-- Content description for the button that opens the floating toolbar overflow. [CHAR LIMIT=NONE] -->
+    <string name="floating_toolbar_open_overflow_description">More options</string>
+    <!-- Content description for the button that closes the floating toolbar overflow. [CHAR LIMIT=NONE] -->
+    <string name="floating_toolbar_close_overflow_description">Close overflow</string>
+
+    <!-- Free style window strings -->
+    <!-- Accessibility text for the maximize window button -->
+    <string name="maximize_button_text">Maximise</string>
+    <!-- Accessibility text for the close window button -->
+    <string name="close_button_text">Close</string>
+
+    <!-- Ellipsis character to appear in notification templates, e.g.
+         notification_template_material_inbox.xml.
+         DO NOT TRANSLATE -->
+    <string name="notification_inbox_ellipsis">\u2026</string>
+
+    <!-- Tempalate for Notification.MessagingStyle to join a conversation name with the name of the sender of a message, to make a notification title [CHAR LIMIT=NONE] -->
+    <string name="notification_messaging_title_template"><xliff:g example="Tasty Treat Team" id="conversation_title">%1$s</xliff:g>: <xliff:g example="Adrian Baker" id="sender_name">%2$s</xliff:g></string>
+
+
+    <!-- Label describing the number of selected items [CHAR LIMIT=48] -->
+    <plurals name="selected_count">
+        <item quantity="one"><xliff:g example="1" id="count">%1$d</xliff:g> selected</item>
+        <item quantity="other"><xliff:g example="3" id="count">%1$d</xliff:g> selected</item>
+    </plurals>
+
+    <string name="importance_from_user">You set the importance of these notifications.</string>
+    <string name="importance_from_person">This is important because of the people involved.</string>
+
+    <!-- Message to user that app trying to create user for an account that already exists. [CHAR LIMIT=none] -->
+    <string name="user_creation_account_exists">Allow <xliff:g example="Gmail" id="app">%1$s</xliff:g> to create a new User with <xliff:g example="foobar@gmail.com" id="account">%2$s</xliff:g> ?</string>
+    <!-- Message to user that app is trying to create user for a specified account. [CHAR LIMIT=none] -->
+    <string name="user_creation_adding">Allow <xliff:g example="Gmail" id="app">%1$s</xliff:g> to create a new User with <xliff:g example="foobar" id="account">%2$s</xliff:g> (a User with this account already exists) ?</string>
+
+    <!-- Locale picker strings -->
+
+    <!-- Title for the language selection screen [CHAR LIMIT=25] -->
+    <string name="language_selection_title">Add a language</string>
+    <!-- Title for the region selection screen [CHAR LIMIT=25] -->
+    <string name="country_selection_title">Region preference</string>
+    <!-- Hint text in a search edit box (used to filter long language / country lists) [CHAR LIMIT=25] -->
+    <string name="search_language_hint">Type language name</string>
+
+    <!-- List section subheader for the language picker, containing a list of suggested languages determined by the default region [CHAR LIMIT=30] -->
+    <string name="language_picker_section_suggested">Suggested</string>
+    <!-- List section subheader for the language picker, containing a list of all languages available [CHAR LIMIT=30] -->
+    <string name="language_picker_section_all">All languages</string>
+    <!-- List section subheader for the region picker, containing a list of all regions supported for the selected language.
+    Warning: this is a more 'neutral' term for 'country', not for the sub-divisions of a country. [CHAR LIMIT=30] -->
+    <string name="region_picker_section_all">All regions</string>
+
+    <!-- Menu item in the locale menu  [CHAR LIMIT=30] -->
+    <string name="locale_search_menu">Search</string>
+
+    <!-- Title for dialog displayed when work profile is turned off. [CHAR LIMIT=30] -->
+    <string name="work_mode_off_title">Work mode is OFF</string>
+    <!-- Message displayed in dialog when work profile is turned off. [CHAR LIMIT=NONE] -->
+    <string name="work_mode_off_message">Allow work profile to function, including apps, background sync, and related features.</string>
+    <!-- Title for button to turn on work profile. [CHAR LIMIT=NONE] -->
+    <string name="work_mode_turn_on">Turn on</string>
+
+    <!-- Notification title shown when new SMS/MMS is received while the device is locked [CHAR LIMIT=NONE] -->
+    <string name="new_sms_notification_title">You have new messages</string>
+    <!-- Notification content shown when new SMS/MMS is received while the device is locked [CHAR LIMIT=NONE] -->
+    <string name="new_sms_notification_content">Open SMS app to view</string>
+
+    <!-- Notification title shown when user profile is credential encrypted and requires the user to unlock before some features are usable [CHAR LIMIT=30] -->
+    <string name="user_encrypted_title">Some functionality may be limited</string>
+    <!-- Notification message shown when user profile is credential encrypted and requires the user to unlock before some features are usable [CHAR LIMIT=30] -->
+    <string name="user_encrypted_message">Touch to unlock</string>
+    <!-- Notification detail shown when user profile is credential encrypted and requires the user to unlock before some features are usable [CHAR LIMIT=30] -->
+    <string name="user_encrypted_detail">User data locked</string>
+
+    <!-- Notification detail shown when work profile is credential encrypted and requires the user to unlock before some features are usable [CHAR LIMIT=30] -->
+    <string name="profile_encrypted_detail">Work profile locked</string>
+    <!-- Notification message shown when work profile is credential encrypted and requires the user to unlock before some features are usable [CHAR LIMIT=30] -->
+    <string name="profile_encrypted_message">Touch to unlock work profile</string>
+
+    <!-- Title of notification shown after a MTP device is connected to Android. -->
+    <string name="usb_mtp_launch_notification_title">Connected to <xliff:g id="product_name">%1$s</xliff:g></string>
+    <!-- Description of notification shown after a MTP device is connected to Android. -->
+    <string name="usb_mtp_launch_notification_description">Touch to view files</string>
+
+    <!-- Resolver target actions strings -->
+
+    <!-- Pin (as in to a bulletin board with a pushpin) a resolver
+         target to the front of the list. -->
+    <string name="pin_target">Pin</string>
+    <!-- Unpin a resolver target such that it sorts normally. -->
+    <string name="unpin_target">Unpin</string>
+    <!-- View application info for a target. -->
+    <string name="app_info">App info</string>
+
+    <!-- The representation of a time duration when negative. An example is -1:14. This can be used with a countdown timer for example.-->
+    <string name="negative_duration">\u2212<xliff:g example="1:14" id="time">%1$s</xliff:g></string>
+
+    <!-- Title of notification to start a new demo session when device is in retail mode [CHAR LIMIT=NONE] -->
+    <string name="reset_retail_demo_mode_title">Reset device?</string>
+    <!-- Text of notification to start a new demo session when device is in retail mode [CHAR LIMIT=NONE] -->
+    <string name="reset_retail_demo_mode_text">Touch to reset device</string>
+    <!-- Text of dialog shown when starting a demo user for the first time [CHAR LIMIT=40] -->
+    <string name="demo_starting_message">Starting demo\u2026</string>
+    <!-- Text of dialog shown when starting a new demo user in retail demo mode [CHAR LIMIT=40] -->
+    <string name="demo_restarting_message">Resetting device\u2026</string>
+    <!-- Title of the dialog shown when user inactivity times out in retail demo mode [CHAR LIMIT=40] -->
+    <string name="demo_user_inactivity_timeout_title">Reset device?</string>
+    <!-- Warning message shown when user inactivity times out in retail demo mode [CHAR LIMIT=none] -->
+    <string name="demo_user_inactivity_timeout_countdown">You\'ll lose any changes and the demo will start again in <xliff:g example="9" id="timeout">%1$s</xliff:g> seconds\u2026</string>
+    <!-- Text of button to allow user to abort countdown and continue current session in retail demo mode [CHAR LIMIT=40] -->
+    <string name="demo_user_inactivity_timeout_left_button">Cancel</string>
+    <!-- Text of button to allow user to abort countdown and immediately start another session in retail demo mode [CHAR LIMIT=40] -->
+    <string name="demo_user_inactivity_timeout_right_button">Reset now</string>
+
+    <!-- Title of notification shown when device has been forced to safe mode after a security compromise. -->
+    <string name="audit_safemode_notification">Factory reset to use this device without restrictions</string>
+    <!-- Description of notification shown when device has been forced to safe mode after a security compromise. -->
+    <string name="audit_safemode_notification_details">Touch to learn more.</string>
+
+    <!-- Accessibilty string added to a widget that has been suspended [CHAR LIMIT=20] -->
+    <string name="suspended_widget_accessibility">Disabled <xliff:g example="Calendar" id="label">%1$s</xliff:g></string>
+
+    <!-- Label used by Telephony code, assigned as the display name for conference calls [CHAR LIMIT=60] -->
+    <string name="conference_call">Conference Call</string>
+  <string name="low_storage_view_title_500m">Storage less than 500MB</string>
+  <string name="low_storage_view_title_100m">Storage less than 100MB</string>
+  <string name="low_storage_view_title_50m">Storage less than 50MB</string>
+  <string name="low_storage_warning_message_500m">Apps might not work properly. Free up space? Don\'t remind me again.</string>
+  <string name="low_storage_warning_message_100m">Wi\u2011Fi and mobile data are disabled. Apps might stop working. Free up space?</string>
+  <string name="low_storage_warning_message_50m">Wi\u2011Fi and mobile data are disabled. Apps might stop working. Free up space?</string>
+  <string name="free_memory_ignore_btn">IGNORE</string>
+  <string name="free_memory_free_up_space_btn">FREE UP SPACE</string>
+  <string name="reboot">Reboot</string>
+  <string name="reboot_confirm">Your phone will reboot</string>
+  <string name="battery_countdown">Your phone will power off after 15 seconds.</string>
+  <string name="global_action_enforce_restart">Press and hold the power key for at least 8 seconds to power off or hold it longer to reboot.</string>
+  <string name="face_verify_fail_tip">Verify failure </string>
+  <string name="face_verify_timeout_tip">No face was detected</string>
+
+  <string name="fingerprint_acquired_duplicate_finger">Duplicate finger.Please change a finger.</string>
+  <string name="fingerprint_acquired_duplicate_area">Duplicate area.Please try again.</string>
+
+  <string name="shutdown_poweroff">POWER OFF</string>
+
+  <!--Begin added by Xutao.Wu for TASK5709544 on 2017/11/28-->
+  <!-- Title of the dialog shown when user inactivity times to start retail demo mode [CHAR LIMIT=40] -->
+  <string name="start_demo_mode_inactivity_timeout_title">Enter into demo mode</string>
+  <!-- Warning message shown when user inactivity times out to start retail demo mode [CHAR LIMIT=none] -->
+  <string name="start_demo_mode_inactivity_timeout_countdown">The demo mode will activate in <xliff:g example="9" id="timeout">%1$s</xliff:g> seconds\u2026</string>
+  <!-- Text of button to allow user to abort countdown and immediately start retail demo mode [CHAR LIMIT=40] -->
+  <string name="start_demo_mode_inactivity_timeout_right_button">ENTER</string>
+  <!--End added by Xutao.Wu for TASK5709544 on 2017/11/28-->
+  <string name="def_stk_name_for_telcel">SIM Telcel</string>
+  <string name="def_stk_name_for_wom">SIM WOM</string>
+  <string name="def_stk_name_for_ofus">"SIM OFUS"</string>
+  <string name="def_stk_name_for_cnt">"SIM CNT"</string>
+  <string name="def_stk_name_for_claro">"SIM CLARO"</string>
+  <string name="def_stk_name_for_entel">"SIM ENTEL"</string>
+  <string name="gsm_stk_title_unicode">stk unicode</string>
+  <string name="data_clearcode_29">Falla de Autenticación \u201129\u2011</string>
+  <string name="data_clearcode_33">Sin subscripcion al servicio \u201133\u2011</string>
+  <string name="data_clearcode_title">"Warning"</string>
+  <!-- Qj add for show toast message when usb otg unmounted for 115675 by zhangle at 2018/01/10 start -->
+  <string name="otgusb_device_unmount">"<xliff:g id="deviceName">%1$5s</xliff:g> has been removed"</string>
+  <!-- Qj add for show toast message when usb otg unmounted for 115675 by zhangle at 2018/01/10 end -->
+
+  <!-- Roaming reminder title -->
+  <string name="roaming_reminder_title">"Roaming reminder"</string>
+  <!-- Roaming reminder button continue -->
+  <string name="roaming_reminder_btn_continue">"Continue"</string>
+  <!-- Roaming reminder button disable -->
+  <string name="roaming_reminder_btn_disable">"Disable"</string>
+  <!-- Roaming reminder message single sim -->
+  <string name="roaming_reminder_message_single_sim">"Data roaming is enabled right now. This may incur significant roaming charges. Are you sure you want to continue using data roaming?"</string>
+  <!-- Roaming reminder message multiple sim -->
+  <string name="roaming_reminder_message_multiple_sim">"Data roaming is enabled right now for %s. This may incur significant roaming charges. Are you sure you want to continue using data roaming?"</string>
+
+</resources>
\ No newline at end of file

Property changes on: vendor/branch/5058Y_ALIE/frameworks/base/core/res/res/values/strings.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
===================================================================
--- vendor/branch/5058Y_ALIE/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java	(revision 0)
+++ vendor/branch/5058Y_ALIE/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java	(revision 12585)
@@ -0,0 +1,5319 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.p2p;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.net.ConnectivityManager;
+import android.net.DhcpResults;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkUtils;
+import android.net.ip.IpManager;
+import android.net.wifi.WpsInfo;
+import android.net.wifi.p2p.IWifiP2pManager;
+import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pGroup;
+import android.net.wifi.p2p.WifiP2pGroupList;
+import android.net.wifi.p2p.WifiP2pGroupList.GroupDeleteListener;
+import android.net.wifi.p2p.WifiP2pInfo;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pProvDiscEvent;
+import android.net.wifi.p2p.WifiP2pWfdInfo;
+import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pServiceRequest;
+import android.net.wifi.p2p.nsd.WifiP2pServiceResponse;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.android.internal.R;
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+import com.android.server.wifi.WifiMonitor;
+import com.android.server.wifi.WifiNative;
+import com.android.server.wifi.WifiStateMachine;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+///M:@{
+import android.net.StaticIpConfiguration;
+import android.net.wifi.SupplicantState;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.net.wifi.WifiSsid;
+import android.net.wifi.p2p.link.WifiP2pLinkInfo;
+import android.os.SystemProperties;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.mediatek.server.wifi.WifiNvRamAgent;
+
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.FileInputStream;
+///@}
+
+/**
+ * WifiP2pService includes a state machine to perform Wi-Fi p2p operations. Applications
+ * communicate with this service to issue device discovery and connectivity requests
+ * through the WifiP2pManager interface. The state machine communicates with the wifi
+ * driver through wpa_supplicant and handles the event responses through WifiMonitor.
+ *
+ * Note that the term Wifi when used without a p2p suffix refers to the client mode
+ * of Wifi operation
+ * @hide
+ */
+public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
+    private static final String TAG = "WifiP2pService";
+    private static final boolean DBG = true;  ///Modify by MTK
+    private static final String NETWORKTYPE = "WIFI_P2P";
+
+    private Context mContext;
+    private String mInterface;
+
+    INetworkManagementService mNwService;
+    private IpManager mIpManager;
+    private DhcpResults mDhcpResults;
+
+    private P2pStateMachine mP2pStateMachine;
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+    private AsyncChannel mWifiChannel;
+
+    private static final Boolean JOIN_GROUP = true;
+    private static final Boolean FORM_GROUP = false;
+
+    private static final Boolean RELOAD = true;
+    private static final Boolean NO_RELOAD = false;
+
+    /* Two minutes comes from the wpa_supplicant setting */
+    private static final int GROUP_CREATING_WAIT_TIME_MS = 120 * 1000;
+    private static int mGroupCreatingTimeoutIndex = 0;
+
+    private static final int DISABLE_P2P_WAIT_TIME_MS = 5 * 1000;
+    private static int mDisableP2pTimeoutIndex = 0;
+
+    /* Set a two minute discover timeout to avoid STA scans from being blocked */
+    private static final int DISCOVER_TIMEOUT_S = 120;
+
+    /* Idle time after a peer is gone when the group is torn down */
+    private static final int GROUP_IDLE_TIME_S = 10;
+
+    /*M: Used for received intive response with info unavailable */
+    private static final int RECONN_FOR_INVITE_RES_INFO_UNAVAILABLE_TIME_MS = 120 * 1000;
+
+    private static final int BASE = Protocol.BASE_WIFI_P2P_SERVICE;
+
+    /* Delayed message to timeout group creation */
+    public static final int GROUP_CREATING_TIMED_OUT        =   BASE + 1;
+
+    /* User accepted a peer request */
+    private static final int PEER_CONNECTION_USER_ACCEPT    =   BASE + 2;
+    /* User rejected a peer request */
+    private static final int PEER_CONNECTION_USER_REJECT    =   BASE + 3;
+    /* User wants to disconnect wifi in favour of p2p */
+    private static final int DROP_WIFI_USER_ACCEPT          =   BASE + 4;
+    /* User wants to keep his wifi connection and drop p2p */
+    private static final int DROP_WIFI_USER_REJECT          =   BASE + 5;
+    /* Delayed message to timeout p2p disable */
+    public static final int DISABLE_P2P_TIMED_OUT           =   BASE + 6;
+
+
+    /* Commands to the WifiStateMachine */
+    public static final int P2P_CONNECTION_CHANGED          =   BASE + 11;
+
+    /* These commands are used to temporarily disconnect wifi when we detect
+     * a frequency conflict which would make it impossible to have with p2p
+     * and wifi active at the same time.
+     *
+     * If the user chooses to disable wifi temporarily, we keep wifi disconnected
+     * until the p2p connection is done and terminated at which point we will
+     * bring back wifi up
+     *
+     * DISCONNECT_WIFI_REQUEST
+     *      msg.arg1 = 1 enables temporary disconnect and 0 disables it.
+     */
+    public static final int DISCONNECT_WIFI_REQUEST         =   BASE + 12;
+    public static final int DISCONNECT_WIFI_RESPONSE        =   BASE + 13;
+
+    public static final int SET_MIRACAST_MODE               =   BASE + 14;
+
+    // During dhcp (and perhaps other times) we can't afford to drop packets
+    // but Discovery will switch our channel enough we will.
+    //   msg.arg1 = ENABLED for blocking, DISABLED for resumed.
+    //   msg.arg2 = msg to send when blocked
+    //   msg.obj  = StateMachine to send to when blocked
+    public static final int BLOCK_DISCOVERY                 =   BASE + 15;
+
+    /*M: increase success rate for invitation*/
+    private static final int M_P2P_DEVICE_FOUND_INVITATION  =   BASE + 20;
+    ///@}
+
+    /*M: Used for received intive response with info unavailable */
+    private static final int M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE  =   BASE + 21;
+
+    private static final int SET_BEAM_MODE  =   BASE + 22;
+    ///@}
+
+    // Messages for interaction with IpManager.
+    private static final int IPM_PRE_DHCP_ACTION            =   BASE + 30;
+    private static final int IPM_POST_DHCP_ACTION           =   BASE + 31;
+    private static final int IPM_DHCP_RESULTS               =   BASE + 32;
+    private static final int IPM_PROVISIONING_SUCCESS       =   BASE + 33;
+    private static final int IPM_PROVISIONING_FAILURE       =   BASE + 34;
+
+    public static final int ENABLED                         = 1;
+    public static final int DISABLED                        = 0;
+
+    private final boolean mP2pSupported;
+
+    private WifiP2pDevice mThisDevice = new WifiP2pDevice();
+
+    /* When a group has been explicitly created by an app, we persist the group
+     * even after all clients have been disconnected until an explicit remove
+     * is invoked */
+    private boolean mAutonomousGroup;
+
+    /* Invitation to join an existing p2p group */
+    private boolean mJoinExistingGroup;
+
+    /* Track whether we are in p2p discovery. This is used to avoid sending duplicate
+     * broadcasts
+     */
+    private boolean mDiscoveryStarted;
+    /* Track whether servcice/peer discovery is blocked in favor of other wifi actions
+     * (notably dhcp)
+     */
+    private boolean mDiscoveryBlocked;
+
+    /*
+     * remember if we were in a scan when it had to be stopped
+     */
+    private boolean mDiscoveryPostponed = false;
+
+    private NetworkInfo mNetworkInfo;
+
+    private boolean mTemporarilyDisconnectedWifi = false;
+
+    /* The transaction Id of service discovery request */
+    private byte mServiceTransactionId = 0;
+
+    /* Service discovery request ID of wpa_supplicant.
+     * null means it's not set yet. */
+    private String mServiceDiscReqId;
+
+    /* clients(application) information list. */
+    private HashMap<Messenger, ClientInfo> mClientInfoList = new HashMap<Messenger, ClientInfo>();
+
+    /* Is chosen as a unique address to avoid conflict with
+       the ranges defined in Tethering.java */
+    private static final String SERVER_ADDRESS = "192.168.49.1";
+
+    ///M:@{
+    private boolean mGcIgnoresDhcpReq = false;
+    private static final String STATIC_CLIENT_ADDRESS = "192.168.49.2";
+    ///@}
+
+    ///M: variables @{
+    /*M: Set 25s for ALPS00450978, because scan block to
+     * feel some peers has diappeared*/
+    private static final int CONNECTED_DISCOVER_TIMEOUT_S = 25;
+
+    /*M: Power Saving Command*/
+    public static final int P2P_ACTIVE  = 0;
+    //When traffic is large will not ajust active/PS
+    public static final int P2P_MAX_PS  = 1;
+    //When traffic is large ajust active/PS automatically
+    public static final int P2P_FAST_PS = 2;
+
+    /*M: add to Enable wifi/wifi p2p */
+    private WifiManager mWifiManager;
+
+    /*M: ALPS00677009: broadcast the group removed reason*/
+    private P2pStatus mGroupRemoveReason = P2pStatus.UNKNOWN;
+
+    /*M: ALPS01593529: no p2p_invite in wfd source case*/
+    private int mMiracastMode = WifiP2pManager.MIRACAST_DISABLED;
+
+    /*M: ALPS01303168: wfd sink*/
+    private int mDeviceCapa;
+    // for getPeerIpAddress()
+    private static final String DHCP_INFO_FILE = "/data/misc/dhcp/dnsmasq.p2p0.leases";
+
+    /*M: ALPS01467393: disableState need stop WifiMonitor*/
+    private static final int STOP_P2P_MONITOR_WAIT_TIME_MS = 5 * 1000;
+    private int mStopP2pMonitorTimeoutIndex = 0;
+
+    /*M: ALPS01593529: For the dongles that don't support p2p_invite*/
+    private boolean WFD_DONGLE_USE_P2P_INVITE =
+        SystemProperties.getBoolean("persist.p2p.wfd.invitedongle", true);
+    private String mWfdSourceAddr;
+
+    /*M: enhance frequency conflict @{ */
+    private int mP2pOperFreq = -1;
+
+    /*M: ALPS01859775: handle device nego-failed wiht NO_COMMON_CHANNEL
+    after receiving nego-request*/
+    boolean mNegoChannelConflict = false;
+
+    /*M: ALPS01976478: SCC then MCC*/
+    private boolean mConnectToPeer = false;
+    private boolean mMccSupport = false;
+
+    /*M: Delay 120s to connect peer if info unavailable received*/
+    private boolean mDelayReconnectForInfoUnavailable = true;
+    ///@}
+
+    /*M: increase success rate for invitation*/
+    private boolean mUpdatePeerForInvited = false;
+
+    /*M: for crossmount*/
+    private boolean mCrossmountIEAdded = false;
+    private boolean mCrossmountEventReceived = false;
+    private String mCrossmountSessionInfo = "";
+
+    private static final int VENDOR_IE_ALL_FRAME_TAG = 99;
+    // refer to WifiNative.java "Frame id" comments
+    private static final int VENDOR_IE_FRAME_ID_AMOUNTS = 12;
+    private static final String UNKNOWN_COMMAND = "UNKNOWN COMMAND";
+    private static final String VENDOR_IE_TAG = "dd";
+    private static final String VENDOR_IE_MTK_OUI = "000ce7";
+    private static final String VENDOR_IE_OUI_TYPE__CROSSMOUNT = "33";
+    ///@}
+
+    /**
+     * Error code definition.
+     * see the Table.8 in the WiFi Direct specification for the detail.
+     */
+    public static enum P2pStatus {
+        /* Success. */
+        SUCCESS,
+
+        /* The target device is currently unavailable. */
+        INFORMATION_IS_CURRENTLY_UNAVAILABLE,
+
+        /* Protocol error. */
+        INCOMPATIBLE_PARAMETERS,
+
+        /* The target device reached the limit of the number of the connectable device.
+         * For example, device limit or group limit is set. */
+        LIMIT_REACHED,
+
+        /* Protocol error. */
+        INVALID_PARAMETER,
+
+        /* Unable to accommodate request. */
+        UNABLE_TO_ACCOMMODATE_REQUEST,
+
+        /* Previous protocol error, or disruptive behavior. */
+        PREVIOUS_PROTOCOL_ERROR,
+
+        /* There is no common channels the both devices can use. */
+        NO_COMMON_CHANNEL,
+
+        /* Unknown p2p group. For example, Device A tries to invoke the previous persistent group,
+         *  but device B has removed the specified credential already. */
+        UNKNOWN_P2P_GROUP,
+
+        /* Both p2p devices indicated an intent of 15 in group owner negotiation. */
+        BOTH_GO_INTENT_15,
+
+        /* Incompatible provisioning method. */
+        INCOMPATIBLE_PROVISIONING_METHOD,
+
+        /* Rejected by user */
+        REJECTED_BY_USER,
+
+        ///M: expand reason code  @{
+        MTK_EXPAND_01,
+        MTK_EXPAND_02,
+        ///@}
+
+        /* Unknown error */
+        UNKNOWN;
+
+        public static P2pStatus valueOf(int error) {
+            switch(error) {
+            case 0 :
+                return SUCCESS;
+            case 1:
+                return INFORMATION_IS_CURRENTLY_UNAVAILABLE;
+            case 2:
+                return INCOMPATIBLE_PARAMETERS;
+            case 3:
+                return LIMIT_REACHED;
+            case 4:
+                return INVALID_PARAMETER;
+            case 5:
+                return UNABLE_TO_ACCOMMODATE_REQUEST;
+            case 6:
+                return PREVIOUS_PROTOCOL_ERROR;
+            case 7:
+                return NO_COMMON_CHANNEL;
+            case 8:
+                return UNKNOWN_P2P_GROUP;
+            case 9:
+                return BOTH_GO_INTENT_15;
+            case 10:
+                return INCOMPATIBLE_PROVISIONING_METHOD;
+            case 11:
+                return REJECTED_BY_USER;
+            ///M: expand reason code  @{
+            case 12:
+                return MTK_EXPAND_01;
+            case 13:
+                return MTK_EXPAND_02;
+            ///@}
+            default:
+                return UNKNOWN;
+            }
+        }
+    }
+
+    /**
+     * Handles client connections
+     */
+    private class ClientHandler extends Handler {
+
+        ClientHandler(android.os.Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+              case WifiP2pManager.SET_DEVICE_NAME:
+              case WifiP2pManager.SET_WFD_INFO:
+              case WifiP2pManager.DISCOVER_PEERS:
+              case WifiP2pManager.STOP_DISCOVERY:
+              case WifiP2pManager.CONNECT:
+              case WifiP2pManager.CANCEL_CONNECT:
+              case WifiP2pManager.CREATE_GROUP:
+              case WifiP2pManager.REMOVE_GROUP:
+              case WifiP2pManager.START_LISTEN:
+              case WifiP2pManager.STOP_LISTEN:
+              case WifiP2pManager.SET_CHANNEL:
+              case WifiP2pManager.START_WPS:
+              case WifiP2pManager.ADD_LOCAL_SERVICE:
+              case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+              case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+              case WifiP2pManager.DISCOVER_SERVICES:
+              case WifiP2pManager.ADD_SERVICE_REQUEST:
+              case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+              case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+              case WifiP2pManager.REQUEST_PEERS:
+              case WifiP2pManager.REQUEST_CONNECTION_INFO:
+              case WifiP2pManager.REQUEST_GROUP_INFO:
+              case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+              case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
+              ///M: MTK added on feature  @{
+              case WifiP2pManager.GET_HANDOVER_REQUEST:  //Google feature
+              case WifiP2pManager.GET_HANDOVER_SELECT:  //Google feature
+              case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:  //Google feature
+              case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:  //Google feature
+              case WifiP2pManager.REQUEST_LINK_INFO:
+              case WifiP2pManager.SET_AUTO_CHANNEL_SELECT:
+              case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+              case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+              case WifiP2pManager.FREQ_CONFLICT_EX_RESULT:
+              case WifiP2pManager.REMOVE_CLIENT:
+              case WifiP2pManager.STOP_P2P_FIND_ONLY:
+              case WifiP2pManager.ADD_PERSISTENT_GROUP:
+              ///@}
+                mP2pStateMachine.sendMessage(Message.obtain(msg));
+                break;
+              default:
+                Slog.d(TAG, "ClientHandler.handleMessage ignoring msg=" + msg);
+                break;
+            }
+        }
+    }
+    private ClientHandler mClientHandler;
+
+    public WifiP2pServiceImpl(Context context) {
+        mContext = context;
+
+        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_WIFI_P2P, 0, NETWORKTYPE, "");
+
+        mP2pSupported = mContext.getPackageManager().hasSystemFeature(
+                PackageManager.FEATURE_WIFI_DIRECT);
+
+        mThisDevice.primaryDeviceType = mContext.getResources().getString(
+                com.android.internal.R.string.config_wifi_p2p_device_type);
+
+        HandlerThread wifiP2pThread = new HandlerThread("WifiP2pService");
+        wifiP2pThread.start();
+        mClientHandler = new ClientHandler(wifiP2pThread.getLooper());
+
+        mP2pStateMachine = new P2pStateMachine(TAG, wifiP2pThread.getLooper(), mP2pSupported);
+        mP2pStateMachine.start();
+    }
+
+    public void connectivityServiceReady() {
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNwService = INetworkManagementService.Stub.asInterface(b);
+    }
+
+    private void enforceAccessPermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_WIFI_STATE,
+                "WifiP2pService");
+    }
+
+    private void enforceChangePermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CHANGE_WIFI_STATE,
+                "WifiP2pService");
+    }
+
+    private void enforceConnectivityInternalPermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL,
+                "WifiP2pService");
+    }
+
+    private int checkConnectivityInternalPermission() {
+        return mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL);
+    }
+
+    private int checkLocationHardwarePermission() {
+        return mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.LOCATION_HARDWARE);
+    }
+
+    private void enforceConnectivityInternalOrLocationHardwarePermission() {
+        if (checkConnectivityInternalPermission() != PackageManager.PERMISSION_GRANTED
+                && checkLocationHardwarePermission() != PackageManager.PERMISSION_GRANTED) {
+            enforceConnectivityInternalPermission();
+        }
+    }
+
+    private void stopIpManager() {
+        if (mIpManager != null) {
+            mIpManager.stop();
+            mIpManager = null;
+        }
+        mDhcpResults = null;
+    }
+
+    private void startIpManager(String ifname) {
+        stopIpManager();
+
+        mIpManager = new IpManager(mContext, ifname,
+                new IpManager.Callback() {
+                    @Override
+                    public void onPreDhcpAction() {
+                        mP2pStateMachine.sendMessage(IPM_PRE_DHCP_ACTION);
+                    }
+                    @Override
+                    public void onPostDhcpAction() {
+                        mP2pStateMachine.sendMessage(IPM_POST_DHCP_ACTION);
+                    }
+                    @Override
+                    public void onNewDhcpResults(DhcpResults dhcpResults) {
+                        mP2pStateMachine.sendMessage(IPM_DHCP_RESULTS, dhcpResults);
+                    }
+                    @Override
+                    public void onProvisioningSuccess(LinkProperties newLp) {
+                        mP2pStateMachine.sendMessage(IPM_PROVISIONING_SUCCESS);
+                    }
+                    @Override
+                    public void onProvisioningFailure(LinkProperties newLp) {
+                        mP2pStateMachine.sendMessage(IPM_PROVISIONING_FAILURE);
+                    }
+                },
+                mNwService);
+
+        final IpManager.ProvisioningConfiguration config =
+                mIpManager.buildProvisioningConfiguration()
+                          .withoutIPv6()
+                          .withoutIpReachabilityMonitor()
+                          .withPreDhcpAction(30 * 1000)
+                          .withProvisioningTimeoutMs(36 * 1000)
+                          .build();
+        mIpManager.startProvisioning(config);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a client to establish
+     * an AsyncChannel communication with WifiP2pService
+     */
+    public Messenger getMessenger() {
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mClientHandler);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a WifiStateMachine to establish
+     * an AsyncChannel communication with P2pStateMachine
+     * @hide
+     */
+    public Messenger getP2pStateMachineMessenger() {
+        enforceConnectivityInternalOrLocationHardwarePermission();
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mP2pStateMachine.getHandler());
+    }
+
+    /** This is used to provide information to drivers to optimize performance depending
+     * on the current mode of operation.
+     * 0 - disabled
+     * 1 - source operation
+     * 2 - sink operation
+     *
+     * As an example, the driver could reduce the channel dwell time during scanning
+     * when acting as a source or sink to minimize impact on miracast.
+     */
+    public void setMiracastMode(int mode) {
+        enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode);
+    }
+
+    ///M: wfd source MCC mechanism, and crossmount mechanism  @{
+    /** This is used to provide information to drivers to optimize performance depending
+     * on the current mode of operation.
+     * 0 - disabled
+     * 1 - source operation
+     * 2 - sink operation
+     *
+     * As an example, the driver could reduce the channel dwell time during scanning
+     * when acting as a source or sink to minimize impact on miracast.
+     */
+    public void setMiracastModeEx(int mode, int freq) {
+        //enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode, freq);
+    }
+    ///@}
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump WifiP2pService from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        mP2pStateMachine.dump(fd, pw, args);
+        pw.println("mAutonomousGroup " + mAutonomousGroup);
+        pw.println("mJoinExistingGroup " + mJoinExistingGroup);
+        pw.println("mDiscoveryStarted " + mDiscoveryStarted);
+        pw.println("mNetworkInfo " + mNetworkInfo);
+        pw.println("mTemporarilyDisconnectedWifi " + mTemporarilyDisconnectedWifi);
+        pw.println("mServiceDiscReqId " + mServiceDiscReqId);
+        pw.println();
+
+        final IpManager ipManager = mIpManager;
+        if (ipManager != null) {
+            pw.println("mIpManager:");
+            ipManager.dump(fd, pw, args);
+        }
+    }
+
+    ///M:@{
+    /*M: get this device's Device Address*/
+    //M: ALPS01860962: To retrive wifi mac from NVRAM. Wifi p2p mac rule follow wifi hal.
+    public String getMacAddress() {
+        Log.d(TAG, "getMacAddress(): before retriving from NVRAM = " + mThisDevice.deviceAddress);
+
+        final String MAC_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/WIFI";
+        final int MAC_ADDRESS_DIGITS = 6;
+        final String NVRAM_AGENT_SERVICE = "NvRAMAgent";
+
+        try {
+            WifiNvRamAgent agent = WifiNvRamAgent.Stub.asInterface(
+                    ServiceManager.getService(NVRAM_AGENT_SERVICE));
+            byte[] buff = agent.readFileByName(MAC_ADDRESS_FILENAME);
+            String macFromNVRam = "";
+
+            if (buff != null) {
+                macFromNVRam = String.format("%02x:%02x:%02x:%02x:%02x:%02x",
+                    buff[4] | 0x02, buff[5], buff[6], buff[7], buff[8], buff[9]);
+                if (!TextUtils.isEmpty(macFromNVRam))
+                    mThisDevice.deviceAddress = macFromNVRam;
+            }
+
+        } catch (RemoteException re) {
+            re.printStackTrace();
+
+        } catch (IndexOutOfBoundsException iobe) {
+            iobe.printStackTrace();
+
+        } finally {
+            Log.d(TAG, "getMacAddress(): after retriving from NVRAM = " +
+                    mThisDevice.deviceAddress);
+
+        }
+
+        return mThisDevice.deviceAddress;
+    }
+
+    /*M: get peer device's IP*/
+    public String getPeerIpAddress(String peerMacAddress) {
+        return mP2pStateMachine.getPeerIpAddress(peerMacAddress);
+    }
+
+    /*M: set IE for crossmount*/
+    public void setCrossMountIE(boolean isAdd, String hexData) {
+        mP2pStateMachine.setCrossMountIE(isAdd, hexData);
+    }
+
+    /*M: Set beam mode*/
+    /** This is used to provide information to drivers to optimize performance depending.
+         * @param mode for beam mode and set to wifi driver.
+     */
+    public void setBeamMode(int mode) {
+        enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_BEAM_MODE, mode);
+    }
+    ///@}
+
+    /**
+     * Handles interaction with WifiStateMachine
+     */
+    private class P2pStateMachine extends StateMachine {
+
+        private DefaultState mDefaultState = new DefaultState();
+        private P2pNotSupportedState mP2pNotSupportedState = new P2pNotSupportedState();
+        private P2pDisablingState mP2pDisablingState = new P2pDisablingState();
+        private P2pDisabledState mP2pDisabledState = new P2pDisabledState();
+        private P2pEnablingState mP2pEnablingState = new P2pEnablingState();
+        private P2pEnabledState mP2pEnabledState = new P2pEnabledState();
+        // Inactive is when p2p is enabled with no connectivity
+        private InactiveState mInactiveState = new InactiveState();
+        private GroupCreatingState mGroupCreatingState = new GroupCreatingState();
+        private UserAuthorizingInviteRequestState mUserAuthorizingInviteRequestState
+                = new UserAuthorizingInviteRequestState();
+        private UserAuthorizingNegotiationRequestState mUserAuthorizingNegotiationRequestState
+                = new UserAuthorizingNegotiationRequestState();
+        private ProvisionDiscoveryState mProvisionDiscoveryState = new ProvisionDiscoveryState();
+        private GroupNegotiationState mGroupNegotiationState = new GroupNegotiationState();
+        private FrequencyConflictState mFrequencyConflictState = new FrequencyConflictState();
+
+        private GroupCreatedState mGroupCreatedState = new GroupCreatedState();
+        private UserAuthorizingJoinState mUserAuthorizingJoinState = new UserAuthorizingJoinState();
+        private OngoingGroupRemovalState mOngoingGroupRemovalState = new OngoingGroupRemovalState();
+
+        private WifiNative mWifiNative = WifiNative.getP2pNativeInterface();
+        private WifiMonitor mWifiMonitor = WifiMonitor.getInstance();
+        private final WifiP2pDeviceList mPeers = new WifiP2pDeviceList();
+        /* During a connection, supplicant can tell us that a device was lost. From a supplicant's
+         * perspective, the discovery stops during connection and it purges device since it does
+         * not get latest updates about the device without being in discovery state.
+         *
+         * From the framework perspective, the device is still there since we are connecting or
+         * connected to it. so we keep these devices in a separate list, so that they are removed
+         * when connection is cancelled or lost
+         */
+        private final WifiP2pDeviceList mPeersLostDuringConnection = new WifiP2pDeviceList();
+        private final WifiP2pGroupList mGroups = new WifiP2pGroupList(null,
+                new GroupDeleteListener() {
+            @Override
+            public void onDeleteGroup(int netId) {
+                if (DBG) logd("called onDeleteGroup() netId=" + netId);
+                mWifiNative.removeNetwork(netId);
+                mWifiNative.saveConfig();
+                sendP2pPersistentGroupsChangedBroadcast();
+            }
+        });
+        private final WifiP2pInfo mWifiP2pInfo = new WifiP2pInfo();
+        private WifiP2pGroup mGroup;
+
+        // Saved WifiP2pConfig for an ongoing peer connection. This will never be null.
+        // The deviceAddress will be an empty string when the device is inactive
+        // or if it is connected without any ongoing join request
+        private WifiP2pConfig mSavedPeerConfig = new WifiP2pConfig();
+
+        P2pStateMachine(String name, Looper looper, boolean p2pSupported) {
+            super(name, looper);
+
+            addState(mDefaultState);
+                addState(mP2pNotSupportedState, mDefaultState);
+                addState(mP2pDisablingState, mDefaultState);
+                addState(mP2pDisabledState, mDefaultState);
+                addState(mP2pEnablingState, mDefaultState);
+                addState(mP2pEnabledState, mDefaultState);
+                    addState(mInactiveState, mP2pEnabledState);
+                    addState(mGroupCreatingState, mP2pEnabledState);
+                        addState(mUserAuthorizingInviteRequestState, mGroupCreatingState);
+                        addState(mUserAuthorizingNegotiationRequestState, mGroupCreatingState);
+                        addState(mProvisionDiscoveryState, mGroupCreatingState);
+                        addState(mGroupNegotiationState, mGroupCreatingState);
+                        addState(mFrequencyConflictState, mGroupCreatingState);
+                    addState(mGroupCreatedState, mP2pEnabledState);
+                        addState(mUserAuthorizingJoinState, mGroupCreatedState);
+                        addState(mOngoingGroupRemovalState, mGroupCreatedState);
+
+            if (p2pSupported) {
+                setInitialState(mP2pDisabledState);
+            } else {
+                setInitialState(mP2pNotSupportedState);
+            }
+            setLogRecSize(50);
+            setLogOnlyTransitions(true);
+
+            String interfaceName = mWifiNative.getInterfaceName();
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AP_STA_CONNECTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AP_STA_DISCONNECTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AUTHENTICATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.NETWORK_CONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.NETWORK_DISCONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_DEVICE_FOUND_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_DEVICE_LOST_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_FIND_STOPPED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_REMOVED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_STARTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_INVITATION_RECEIVED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_INVITATION_RESULT_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_PBC_RSP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_SERV_DISC_RESP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SCAN_RESULTS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUP_CONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUP_DISCONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_FAIL_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_OVERLAP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_TIMEOUT_EVENT, getHandler());
+        }
+
+    class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
+                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        if (DBG) logd("Full connection with WifiStateMachine established");
+                        mWifiChannel = (AsyncChannel) message.obj;
+                    } else {
+                        loge("Full connection failure, error = " + message.arg1);
+                        mWifiChannel = null;
+                    }
+                    break;
+
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
+                    if (message.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
+                        loge("Send failed, client connection lost");
+                    } else {
+                        loge("Client connection lost with reason: " + message.arg1);
+                    }
+                    mWifiChannel = null;
+                    break;
+
+                case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION:
+                    AsyncChannel ac = new AsyncChannel();
+                    ac.connect(mContext, getHandler(), message.replyTo);
+                    break;
+                case BLOCK_DISCOVERY:
+                    mDiscoveryBlocked = (message.arg1 == ENABLED ? true : false);
+                    // always reset this - we went to a state that doesn't support discovery so
+                    // it would have stopped regardless
+                    mDiscoveryPostponed = false;
+                    if (mDiscoveryBlocked) {
+                        try {
+                            StateMachine m = (StateMachine)message.obj;
+                            m.sendMessage(message.arg2);
+                        } catch (Exception e) {
+                            loge("unable to send BLOCK_DISCOVERY response: " + e);
+                        }
+                    }
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CREATE_GROUP:
+                    replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    replyToMessage(message,
+                            WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    replyToMessage(message,
+                            WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.SET_WFD_INFO:
+                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REQUEST_PEERS:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_PEERS,
+                            new WifiP2pDeviceList(mPeers));
+                    break;
+                case WifiP2pManager.REQUEST_CONNECTION_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
+                            new WifiP2pInfo(mWifiP2pInfo));
+                    break;
+                case WifiP2pManager.REQUEST_GROUP_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO,
+                            mGroup != null ? new WifiP2pGroup(mGroup) : null);
+                    break;
+                case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_PERSISTENT_GROUP_INFO,
+                            new WifiP2pGroupList(mGroups, null));
+                    break;
+                case WifiP2pManager.START_WPS:
+                    replyToMessage(message, WifiP2pManager.START_WPS_FAILED,
+                        WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.GET_HANDOVER_REQUEST:
+                case WifiP2pManager.GET_HANDOVER_SELECT:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, null);
+                    break;
+                case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
+                case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
+                    replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                    // Ignore
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                case WifiMonitor.WPS_SUCCESS_EVENT:
+                case WifiMonitor.WPS_FAIL_EVENT:
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case WifiMonitor.WPS_TIMEOUT_EVENT:
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
+                case PEER_CONNECTION_USER_ACCEPT:
+                case PEER_CONNECTION_USER_REJECT:
+                case DISCONNECT_WIFI_RESPONSE:
+                case DROP_WIFI_USER_ACCEPT:
+                case DROP_WIFI_USER_REJECT:
+                case GROUP_CREATING_TIMED_OUT:
+                case DISABLE_P2P_TIMED_OUT:
+                case IPM_PRE_DHCP_ACTION:
+                case IPM_POST_DHCP_ACTION:
+                case IPM_DHCP_RESULTS:
+                case IPM_PROVISIONING_SUCCESS:
+                case IPM_PROVISIONING_FAILURE:
+                case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
+                case SET_MIRACAST_MODE:
+                case WifiP2pManager.START_LISTEN:
+                case WifiP2pManager.STOP_LISTEN:
+                case WifiP2pManager.SET_CHANNEL:
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    // Enable is lazy and has no response
+                    break;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    // If we end up handling in default, p2p is not enabled
+                    mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
+                    break;
+                    /* unexpected group created, remove */
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    loge("Unexpected group creation, remove " + mGroup);
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    break;
+                // A group formation failure is always followed by
+                // a group removed event. Flushing things at group formation
+                // failure causes supplicant issues. Ignore right now.
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    break;
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    break;
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                    break;
+                ///@}
+                ///M:  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                ///@}
+                ///M: Add persistent @{
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                ///@}
+                ///M: Set beam mode @{
+                case SET_BEAM_MODE:
+                    break;
+                ///@}
+                default:
+                    loge("Unhandled message " + message);
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pNotSupportedState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            switch (message.what) {
+               case WifiP2pManager.DISCOVER_PEERS:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+               case WifiP2pManager.CREATE_GROUP:
+                    replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    replyToMessage(message,
+                            WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    replyToMessage(message,
+                            WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.SET_WFD_INFO:
+                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.START_WPS:
+                    replyToMessage(message, WifiP2pManager.START_WPS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.START_LISTEN:
+                    replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    break;
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                    break;
+                ///@}
+                ///M:  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///@}
+                ///M: Add persistent @{
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pDisablingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendMessageDelayed(obtainMessage(DISABLE_P2P_TIMED_OUT,
+                    ++mDisableP2pTimeoutIndex, 0), DISABLE_P2P_WAIT_TIME_MS);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (DBG) logd("p2p socket connection lost");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    deferMessage(message);
+                    break;
+                case DISABLE_P2P_TIMED_OUT:
+                    if (mDisableP2pTimeoutIndex == message.arg1) {
+                        loge("P2p disable timed out");
+                        transitionTo(mP2pDisabledState);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
+        }
+    }
+
+    class P2pDisabledState extends State {
+       @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    try {
+                        mNwService.setInterfaceUp(mWifiNative.getInterfaceName());
+                        ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+                        //mNwService.disableIpv6(mInterface);
+                        ///@}
+                    } catch (RemoteException re) {
+                        loge("Unable to change interface settings: " + re);
+                    } catch (IllegalStateException ie) {
+                        loge("Unable to change interface settings: " + ie);
+                    }
+                    mWifiMonitor.startMonitoring(mWifiNative.getInterfaceName());
+                    transitionTo(mP2pEnablingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pEnablingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                    if (DBG) logd("P2p socket connection successful");
+                    mWifiNative.startDriver();  ///Add by MTK
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    loge("P2p socket connection failed");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pEnabledState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendP2pStateChangedBroadcast(true);
+            mNetworkInfo.setIsAvailable(true);
+            sendP2pConnectionChangedBroadcast();
+            initializeP2pSettings();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            ///M: To avoid ConcurrentModificationException in WifiStateMachine.dump()@{
+            if (DBG && message.what == BLOCK_DISCOVERY) logd("BLOCK_DISCOVERY");
+            else if (DBG) logd(getName() + message.toString());
+            ///@}
+            switch (message.what) {
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    loge("Unexpected loss of p2p socket connection");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    //Nothing to do
+                    break;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    if (mPeers.clear()) {
+                        sendPeersChangedBroadcast();
+                    }
+                    if (mGroups.clear()) sendP2pPersistentGroupsChangedBroadcast();
+
+                    mWifiMonitor.stopMonitoring(mWifiNative.getInterfaceName());
+                    mWifiNative.stopDriver();  ///Add by MTK
+                    transitionTo(mP2pDisablingState);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                {
+                    WifiP2pDevice d = (WifiP2pDevice) message.obj;
+                    if (d != null && setAndPersistDeviceName(d.deviceName)) {
+                        if (DBG) logd("set device name " + d.deviceName);
+                        replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                }
+                case WifiP2pManager.SET_WFD_INFO:
+                {
+                    WifiP2pWfdInfo d = (WifiP2pWfdInfo) message.obj;
+                    if (d != null && setWfdInfo(d)) {
+                        replyToMessage(message, WifiP2pManager.SET_WFD_INFO_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    //M: ALPS02303267: reset wfd info@crossmount case   @{
+                    if (mThisDevice.wfdInfo != null && mThisDevice.wfdInfo.mCrossmountLoaned) {
+                        mThisDevice.wfdInfo = null;
+                        logd("[crossmount] reset wfd info in wifi p2p framework");
+                    }
+                    ///@}
+                    break;
+                }
+                case BLOCK_DISCOVERY:
+                    boolean blocked = (message.arg1 == ENABLED ? true : false);
+                    logd("blocked:" + blocked + ", mDiscoveryBlocked:" + mDiscoveryBlocked);
+                    if (mDiscoveryBlocked == blocked) break;
+                    mDiscoveryBlocked = blocked;
+                    if (blocked && mDiscoveryStarted) {
+                        mWifiNative.p2pStopFind();
+                        mDiscoveryPostponed = true;
+                    }
+                    if (!blocked && mDiscoveryPostponed) {
+                        mDiscoveryPostponed = false;
+                        mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
+                    }
+                    if (blocked) {
+                        try {
+                            StateMachine m = (StateMachine)message.obj;
+                            m.sendMessage(message.arg2);
+                        } catch (Exception e) {
+                            loge("unable to send BLOCK_DISCOVERY response: " + e);
+                        }
+                    }
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    if (mDiscoveryBlocked) {
+                        logd("DiscoveryBlocked"); ///Add by MTK
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.BUSY);
+                        break;
+                    }
+                    // do not send service discovery request while normal find operation.
+                    clearSupplicantServiceRequest();
+                    ///M: Scan for Beam@{
+                    int timeout = message.arg1;
+                    ///@}
+
+                    ///M: wfd sink  @{
+                    boolean retP2pFind = false;
+                    if (isWfdSinkEnabled()) {
+                        //copy from HE dongle
+                        p2pConfigWfdSink();
+                        retP2pFind = mWifiNative.p2pFind();
+                    } else if (timeout == WifiP2pManager.BEAM_DISCOVERY_TIMEOUT) {
+                        ///M: Scan for Beam@{
+                        retP2pFind = mWifiNative.p2pFind(WifiP2pManager.BEAM_DISCOVERY_TIMEOUT);
+                        ///@}
+                    } else {
+                        retP2pFind = mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
+                    }
+                    if (retP2pFind) {
+                    ///@}
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
+                        sendP2pDiscoveryChangedBroadcast(true);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                    sendP2pDiscoveryChangedBroadcast(false);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (mWifiNative.p2pStopFind()) {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    ///M: wfd sink, restore configuration  @{
+                    if (isWfdSinkEnabled())
+                        p2pUnconfigWfdSink();
+                    ///@}
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    if (mDiscoveryBlocked) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.BUSY);
+                        break;
+                    }
+                    if (DBG) logd(getName() + " discover services");
+                    if (!updateSupplicantServiceRequest()) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.NO_SERVICE_REQUESTS);
+                        break;
+                    }
+                    if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(device.deviceAddress)) break;
+                    mPeers.updateSupplicantDetails(device);
+                    sendPeersChangedBroadcast();
+                     ///M: force update peer information for invitation  @{
+                    if (mUpdatePeerForInvited) {
+                        if (mSavedPeerConfig.deviceAddress.equals(device.deviceAddress)) {
+                            mUpdatePeerForInvited = false;
+                            sendMessage(M_P2P_DEVICE_FOUND_INVITATION);
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    // Gets current details for the one removed
+                    device = mPeers.remove(device.deviceAddress);
+                    if (device != null) {
+                        sendPeersChangedBroadcast();
+                    }
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    if (DBG) logd(getName() + " add service");
+                    WifiP2pServiceInfo servInfo = (WifiP2pServiceInfo)message.obj;
+                    if (addLocalService(message.replyTo, servInfo)) {
+                        replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    if (DBG) logd(getName() + " remove service");
+                    servInfo = (WifiP2pServiceInfo)message.obj;
+                    removeLocalService(message.replyTo, servInfo);
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_SUCCEEDED);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    if (DBG) logd(getName() + " clear service");
+                    clearLocalServices(message.replyTo);
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_SUCCEEDED);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    if (DBG) logd(getName() + " add service request");
+                    if (!addServiceRequest(message.replyTo, (WifiP2pServiceRequest)message.obj)) {
+                        replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED);
+                        break;
+                    }
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_SUCCEEDED);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    if (DBG) logd(getName() + " remove service request");
+                    removeServiceRequest(message.replyTo, (WifiP2pServiceRequest)message.obj);
+                    replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_SUCCEEDED);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    if (DBG) logd(getName() + " clear service request");
+                    clearServiceRequests(message.replyTo);
+                    replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_SUCCEEDED);
+                    break;
+                case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
+                    if (DBG) logd(getName() + " receive service response");
+                    List<WifiP2pServiceResponse> sdRespList =
+                        (List<WifiP2pServiceResponse>) message.obj;
+                    for (WifiP2pServiceResponse resp : sdRespList) {
+                        WifiP2pDevice dev =
+                            mPeers.get(resp.getSrcDevice().deviceAddress);
+                        resp.setSrcDevice(dev);
+                        sendServiceResponse(resp);
+                    }
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                   if (DBG) logd(getName() + " delete persistent group");
+                   mGroups.remove(message.arg1);
+                   replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP_SUCCEEDED);
+                   break;
+                case SET_MIRACAST_MODE:
+                    ///M: wfd sink MCC mechanism  @{
+                    if (0 != message.arg2) {
+                        mWifiNative.setMiracastMode(message.arg1, message.arg2);
+                    } else
+                    ///@}
+                    mWifiNative.setMiracastMode(message.arg1);
+
+                    ///M: ALPS01593529: no p2p_invite in wfd source case @{
+                    mMiracastMode = (int) message.arg1;
+                    ///@}
+                    break;
+                case WifiP2pManager.START_LISTEN:
+                    if (DBG) logd(getName() + " start listen mode");
+                    mWifiNative.p2pFlush();
+                    if (mWifiNative.p2pExtListen(true, 500, 500)) {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    if (DBG) logd(getName() + " stop listen mode");
+                    if (mWifiNative.p2pExtListen(false, 0, 0)) {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
+                    }
+                    mWifiNative.p2pFlush();
+                    break;
+                case WifiP2pManager.SET_CHANNEL:
+                    Bundle p2pChannels = (Bundle) message.obj;
+                    int lc = p2pChannels.getInt("lc", 0);
+                    int oc = p2pChannels.getInt("oc", 0);
+                    if (DBG) logd(getName() + " set listen and operating channel");
+                    if (mWifiNative.p2pSetChannel(lc, oc)) {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.GET_HANDOVER_REQUEST:
+                    Bundle requestBundle = new Bundle();
+                    requestBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE,
+                            mWifiNative.getNfcHandoverRequest());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE,
+                            requestBundle);
+                    break;
+                case WifiP2pManager.GET_HANDOVER_SELECT:
+                    Bundle selectBundle = new Bundle();
+                    selectBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE,
+                            mWifiNative.getNfcHandoverSelect());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE,
+                            selectBundle);
+                    break;
+                ///M:@{
+                case WifiP2pManager.REQUEST_LINK_INFO:
+                    WifiP2pLinkInfo info = (WifiP2pLinkInfo) message.obj;
+                    info.linkInfo = p2pLinkStatics(info.interfaceAddress);
+                    logd("Wifi P2p link info is " + info.toString());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_LINK_INFO,
+                            new WifiP2pLinkInfo(info));
+                    break;
+                case WifiP2pManager.SET_AUTO_CHANNEL_SELECT:
+                    int enable = message.arg1;
+                    p2pAutoChannel(enable);
+                    replyToMessage(message, WifiP2pManager.SET_AUTO_CHANNEL_SELECT_SUCCEEDED);
+                    break;
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    if (mWifiNative.p2pStopFind()) {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    if (DBG) {
+                        logd(getName() + " ADD_PERSISTENT_GROUP");
+                    }
+                    Bundle bVariables = (Bundle) message.obj;
+                    HashMap<String, String> hVariables =
+                        (HashMap<String, String>) bVariables.getSerializable("variables");
+                    if (hVariables != null) {
+                        WifiP2pGroup group = addPersistentGroup(hVariables);
+                        replyToMessage(message, WifiP2pManager.RESPONSE_ADD_PERSISTENT_GROUP,
+                                new WifiP2pGroup(group));
+                    } else {
+                        replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case SET_BEAM_MODE:
+                    if (DBG) {
+                        logd(getName() + " SET_BEAM_MODE");
+                    }
+                    setBeamMode(message.arg1);
+                    break;
+                ///@}
+                default:
+                   return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            sendP2pDiscoveryChangedBroadcast(false);
+            sendP2pStateChangedBroadcast(false);
+            mNetworkInfo.setIsAvailable(false);
+        }
+    }
+
+    class InactiveState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: MTK removed
+            // it will cause 2nd connect of channel conflict failed, Google issue @{
+            //mSavedPeerConfig.invalidate();
+            ///@}
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            ///M: To avoid ANR due to WifiLogger is locked in WifiStateMachine.dump()@{
+            if (DBG && message.what == BLOCK_DISCOVERY) logd("BLOCK_DISCOVERY");
+            else if (DBG) logd(getName() + message.toString());
+            ///@}
+            switch (message.what) {
+                case WifiP2pManager.CONNECT:
+                    if (DBG) logd(getName() + " sending connect:" + (WifiP2pConfig) message.obj);
+                    WifiP2pConfig config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping connect request " + config);
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
+                        break;
+                    }
+
+                    mAutonomousGroup = false;
+                    /** M: ALPS02364885: p2p stop find will disorder wpa_supplicant state */
+                    //mWifiNative.p2pStopFind();
+                    ///@}
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    mConnectToPeer = true;
+                    ///@}
+                    //M: ALPS01593529: no p2p_invite in wfd source case
+                    //logd("CONNECT: mMiracastMode=" + mMiracastMode);
+                    if (mMiracastMode == WifiP2pManager.MIRACAST_SOURCE
+                        && !WFD_DONGLE_USE_P2P_INVITE) {
+                        // To support WFD dongle that doesn't support p2p_invite
+                        transitionTo(mProvisionDiscoveryState);
+                    } else {
+                        // Normal connection case
+                        if (reinvokePersistentGroup(config)) {
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            transitionTo(mProvisionDiscoveryState);
+                        }
+                    }
+                    mSavedPeerConfig = config;
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (mWifiNative.p2pStopFind()) {
+                        // When discovery stops in inactive state, flush to clear
+                        // state peer data
+                        mWifiNative.p2pFlush();
+                        ///M: Google issue,
+                        /// reset mServiceDiscReqId would cause service discovery can't clear up @{
+                        //mServiceDiscReqId = null;
+                        clearSupplicantServiceRequest();
+                        ///@}
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT:
+                    config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping GO neg request " + config);
+                        break;
+                    }
+                    mSavedPeerConfig = config;
+                    mAutonomousGroup = false;
+                    mJoinExistingGroup = false;
+                    transitionTo(mUserAuthorizingNegotiationRequestState);
+                    break;
+                case WifiMonitor.P2P_INVITATION_RECEIVED_EVENT:
+                    WifiP2pGroup group = (WifiP2pGroup) message.obj;
+                    WifiP2pDevice owner = group.getOwner();
+
+                    if (owner == null) {
+                        int id = group.getNetworkId();
+                        if (id < 0) {
+                            loge("Ignored invitation from null owner");
+                            break;
+                        }
+
+                        String addr = mGroups.getOwnerAddr(id);
+                        if (addr != null) {
+                            group.setOwner(new WifiP2pDevice(addr));
+                            owner = group.getOwner();
+                        } else {
+                            loge("Ignored invitation from null owner");
+                            break;
+                        }
+                    }
+
+                    config = new WifiP2pConfig();
+                    config.deviceAddress = group.getOwner().deviceAddress;
+
+                    ///M: force update peer information for CrossMount vendor IE  @{
+                    if (mCrossmountIEAdded) {
+                        mWifiNative.doCustomSupplicantCommand("P2P_FIND " + DISCOVER_TIMEOUT_S +
+                            " type=progressive" + " dev_id=" + config.deviceAddress);
+                        mUpdatePeerForInvited = true;
+                    } else {
+                        if (isConfigInvalid(config)) {
+                            loge("Dropping invitation request " + config);
+                            break;
+                        }
+                        sendMessage(M_P2P_DEVICE_FOUND_INVITATION);
+                    }
+                    mSavedPeerConfig = config;
+                    break;
+                    ///@}
+                ///M: increase success rate for invitation  @{
+                case M_P2P_DEVICE_FOUND_INVITATION:
+                    WifiP2pDevice owner02 = null;
+
+                    //Check if we have the owner in peer list and use appropriate
+                    //wps method. Default is to use PBC.
+                    if ((owner02 = mPeers.get(mSavedPeerConfig.deviceAddress)) != null) {
+                        if (owner02.wpsPbcSupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.PBC;
+                        } else if (owner02.wpsKeypadSupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
+                        } else if (owner02.wpsDisplaySupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        }
+                    }
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(mSavedPeerConfig.deviceAddress);
+                    ///@}
+                    mAutonomousGroup = false;
+                    mJoinExistingGroup = true;
+                    transitionTo(mUserAuthorizingInviteRequestState);
+                    break;
+                ///@}
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    //We let the supplicant handle the provision discovery response
+                    //and wait instead for the GO_NEGOTIATION_REQUEST_EVENT.
+                    //Handling provision discovery and issuing a p2p_connect before
+                    //group negotiation comes through causes issues
+
+                    ///M: for crossmount  @{
+                    WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    ///M: support show PIN passively  @{
+                    if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
+                        logd("Show PIN passively");
+
+                        config = new WifiP2pConfig();
+                        config.deviceAddress = provDisc.device.deviceAddress;
+                        mSavedPeerConfig = config;
+                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        mSavedPeerConfig.wps.pin = provDisc.pin;
+
+                        if (isAppHandledConnection()) {
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        ///M: ALPS02537982: check scan result to avoid exception  @{
+                        } else if (mPeers.get(config.deviceAddress) == null) {
+                            loge("peer device is not in our scan result, drop this pd. "
+                                + config.deviceAddress);
+                        ///@}
+                        } else {
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            notifyInvitationSent(provDisc.pin, mSavedPeerConfig.deviceAddress);
+                            transitionTo(mGroupNegotiationState);
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiP2pManager.CREATE_GROUP:
+                    mAutonomousGroup = true;
+                    int netId = message.arg1;
+                    boolean ret = false;
+                    if (netId == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        // check if the go persistent group is present.
+                        netId = mGroups.getNetworkId(mThisDevice.deviceAddress);
+                        if (netId != -1) {
+                            ret = mWifiNative.p2pGroupAdd(netId);
+                        } else {
+                            ret = mWifiNative.p2pGroupAdd(true);
+                        }
+                    /// M: [ALPS03344752] fix typo, this will cause p2pGroupAdd twice
+                    } else if (netId > -1 && mGroups.contains(netId)) {
+                        // check if the go persistent group is present.
+                        if (mThisDevice.deviceAddress.equals(mGroups.getOwnerAddr(netId))) {
+                            ret = mWifiNative.p2pGroupAdd(netId);
+                        }
+                    } else {
+                        ret = mWifiNative.p2pGroupAdd(false);
+                    }
+
+                    if (ret) {
+                        replyToMessage(message, WifiP2pManager.CREATE_GROUP_SUCCEEDED);
+                        transitionTo(mGroupNegotiationState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                        // remain at this state.
+                    }
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    if (DBG) logd(getName() + " group started");
+
+                    // We hit this scenario when a persistent group is reinvoked
+                    if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        mAutonomousGroup = false;
+                        deferMessage(message);
+                        transitionTo(mGroupNegotiationState);
+                    } else {
+                        loge("Unexpected group creation, remove " + mGroup);
+                        mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    }
+                    break;
+                /// M: marked due to refactoring Google code.
+                /// Let event handled at P2pEnabledState  @{
+                /*
+                case WifiP2pManager.START_LISTEN:
+                    if (DBG) logd(getName() + " start listen mode");
+                    mWifiNative.p2pFlush();
+                    if (mWifiNative.p2pExtListen(true, 500, 500)) {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    if (DBG) logd(getName() + " stop listen mode");
+                    if (mWifiNative.p2pExtListen(false, 0, 0)) {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
+                    }
+                    mWifiNative.p2pFlush();
+                    break;
+                */
+                case WifiP2pManager.SET_CHANNEL:
+                    Bundle p2pChannels = (Bundle) message.obj;
+                    int lc = p2pChannels.getInt("lc", 0);
+                    int oc = p2pChannels.getInt("oc", 0);
+                    if (DBG) logd(getName() + " set listen and operating channel");
+                    if (mWifiNative.p2pSetChannel(lc, oc)) {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
+                    String handoverSelect = null;
+
+                    if (message.obj != null) {
+                        handoverSelect = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
+                    }
+
+                    if (handoverSelect != null
+                            && mWifiNative.initiatorReportNfcHandover(handoverSelect)) {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
+                        transitionTo(mGroupCreatingState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
+                    String handoverRequest = null;
+
+                    if (message.obj != null) {
+                        handoverRequest = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
+                    }
+
+                    if (handoverRequest != null
+                            && mWifiNative.responderReportNfcHandover(handoverRequest)) {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
+                        transitionTo(mGroupCreatingState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
+                    }
+                    break;
+                ///M:@{
+                case M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE:
+                    /*M: Reconnect to peer because received info unavailable 120s ago*/
+                    if (mDelayReconnectForInfoUnavailable) {
+                        if (DBG) logd(getName() + " mDelayReconnectForInfoUnavailable:" +
+                                         mDelayReconnectForInfoUnavailable +
+                                         " M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE:" +
+                                         (WifiP2pConfig) message.obj);
+                        config = (WifiP2pConfig) message.obj;
+                        mSavedPeerConfig = config;
+                        if (mPeers.containsPeer(mSavedPeerConfig.deviceAddress)) {
+                            p2pConnectWithPinDisplay(config);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            removeMessages(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE);
+                        }
+                    }
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            ///M: For received invire response with info unavailable = 1
+            if (mDelayReconnectForInfoUnavailable) {
+                if (DBG) logd(getName() + " mDelayReconnectForInfoUnavailable:" +
+                                 mDelayReconnectForInfoUnavailable +
+                                 ", remove M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE");
+                removeMessages(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE);
+            }
+            ///@}
+        }
+    }
+
+    class GroupCreatingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendMessageDelayed(obtainMessage(GROUP_CREATING_TIMED_OUT,
+                    ++mGroupCreatingTimeoutIndex, 0), GROUP_CREATING_WAIT_TIME_MS);
+            ///M: ALPS01212893: for poor link, wifi p2p start Tx all traffic @{
+            sendP2pTxBroadcast(true);
+            ///@}
+
+            /** M: enhance frequency conflict @{ */
+            mP2pOperFreq = -1;
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+               case GROUP_CREATING_TIMED_OUT:
+                    if (mGroupCreatingTimeoutIndex == message.arg1) {
+                        if (DBG) logd("Group negotiation timed out");
+                        handleGroupCreationFailure();
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    if (!mSavedPeerConfig.deviceAddress.equals(device.deviceAddress)) {
+                        if (DBG) {
+                            logd("mSavedPeerConfig " + mSavedPeerConfig.deviceAddress +
+                                "device " + device.deviceAddress);
+                        }
+                        // Do the regular device lost handling
+                        ret = NOT_HANDLED;
+                        break;
+                    }
+                    // Do nothing
+                    if (DBG) logd("Add device to lost list " + device);
+                    mPeersLostDuringConnection.updateSupplicantDetails(device);
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    /* Discovery will break negotiation */
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    //Do a supplicant p2p_cancel which only cancels an ongoing
+                    //group negotiation. This will fail for a pending provision
+                    //discovery or for a pending user action, but at the framework
+                    //level, we always treat cancel as succeeded and enter
+                    //an inactive state
+                    ///M: enhance cancelConnect() flow  @{
+                    boolean success = false;
+                    if (mWifiNative.p2pCancelConnect()) {
+                        success = true;
+                    } else if (mWifiNative.p2pGroupRemove(mInterface)) {
+                        success = true;
+                    }
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    if (success) {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED);
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                    // We hit this scenario when NFC handover is invoked.
+                    mAutonomousGroup = false;
+                    transitionTo(mGroupNegotiationState);
+                    break;
+                ///M:@{
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice peerDevice = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(peerDevice.deviceAddress)) break;
+                    if (mSavedPeerConfig != null &&
+                            mSavedPeerConfig.deviceAddress.equals(peerDevice.deviceAddress)) {
+                        peerDevice.status = WifiP2pDevice.INVITED;
+                    }
+                    mPeers.update(peerDevice);
+                    sendPeersChangedBroadcast();
+                    break;
+                //ALPS01497387
+                case BLOCK_DISCOVERY:
+                    if (DBG) logd("defer BLOCK_DISCOVERY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                //ALPS02191437: p2pStopFind() would make group nego. failed
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                    if (DBG) logd("defer P2P_FIND_STOPPED_EVENT@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                //ALPS02191437: STOP_DISCOVERY procedure would trigger p2pStopFind(),
+                // it would make group nego. failed.
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (DBG) logd("defer STOP_DISCOVERY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                // functionality is like WifiP2pManager.STOP_DISCOVERY
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    if (DBG) logd("defer STOP_P2P_FIND_ONLY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                ///@}
+                default:
+                    ret = NOT_HANDLED;
+            }
+            return ret;
+        }
+    }
+
+    class UserAuthorizingNegotiationRequestState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: wfd sink: dialog handling move to wfd framework  @{
+            if (isWfdSinkEnabled()) {
+                sendP2pGOandGCRequestConnectBroadcast();
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink and crossmount  @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER &&
+                        isAppHandledConnection()) {
+                        p2pUserAuthPreprocess(message);
+                        ///M: crossmount, support PIN code from outside  @{
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingNegotiationRequestState",
+                            message.obj);
+                        ///@
+                    }
+                ///@}
+                    if (DBG) logd("User accept negotiation: mSavedPeerConfig = " +
+                            mSavedPeerConfig);
+
+                    ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL
+                    // after receiving nego-request  @{
+                    if (mNegoChannelConflict) {
+                        mNegoChannelConflict = false;
+                        logd("PEER_CONNECTION_USER_ACCEPT_FROM_OUTER," +
+                                "switch to FrequencyConflictState");
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    ///@}
+                    ///M: ALPS01899589: Assign the freq for "Sink + MCC_Enabled"
+                    // to avoid performance issue {
+                    if (DBG) logd("isWfdSinkEnabled()=" + isWfdSinkEnabled());
+                    if (isWfdSinkEnabled()) {
+                        WifiInfo wifiInfo = getWifiConnectionInfo();
+                        if (wifiInfo != null) {
+                            if (DBG) logd("wifiInfo=" + wifiInfo);
+                            if (wifiInfo.getSupplicantState() == SupplicantState.COMPLETED) {
+                                if (DBG) {
+                                    logd("wifiInfo.getSupplicantState() ==" +
+                                        " SupplicantState.COMPLETED");
+                                    logd("wifiInfo.getFrequency()=" + wifiInfo.getFrequency());
+                                }
+                                mSavedPeerConfig.setPreferOperFreq(wifiInfo.getFrequency());
+                            }
+                        }
+                    }
+                    ///@}
+                    ///M: for peer isn't existed in mPeers
+                    /// but existing in supplicant's scan result  @{
+                    p2pUpdateScanList(mSavedPeerConfig.deviceAddress);
+                    ///@}
+                    mWifiNative.p2pStopFind();
+                    p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    transitionTo(mGroupNegotiationState);
+                   break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected negotiation " + mSavedPeerConfig);
+                    ///M: ALPS02494768: Peer status may be configured to INVITED.
+                    ///    Reset it when user reject this request.  @{
+                    if (mSavedPeerConfig != null) {
+                        WifiP2pDevice peerDevice02 = mPeers.get(mSavedPeerConfig.deviceAddress);
+                        if (peerDevice02 != null &&
+                                peerDevice02.status == WifiP2pDevice.INVITED) {
+                            mPeers.updateStatus(mSavedPeerConfig.deviceAddress,
+                                WifiP2pDevice.AVAILABLE);
+                            sendPeersChangedBroadcast();
+                        }
+                    }
+                    ///@}
+                    transitionTo(mInactiveState);
+                    break;
+                ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL after
+                // receiving nego-request  @{
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (message.arg1 != 0)    mP2pOperFreq = message.arg1;
+                    P2pStatus status = (P2pStatus) message.obj;
+                    loge("go negotiation failed@UserAuthorizingNegotiationRequestState, status = " +
+                         status + "\tmP2pOperFreq = " + mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        //transitionTo(mFrequencyConflictState);
+                        mNegoChannelConflict = true;
+                    } else {
+                        loge("other kinds of negotiation errors");
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return ret;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+    class UserAuthorizingInviteRequestState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: for wfd sink, reject 2nd gc  @{
+            if (isWfdSinkEnabled()) {
+                sendMessage(PEER_CONNECTION_USER_REJECT);
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    ///M: for crossmount, 3rd device's invitation procedure
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER &&
+                        mCrossmountEventReceived) {
+                        p2pUserAuthPreprocess(message);
+                        ///M: crossmount, support PIN code from outside  @{
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingInviteRequestState",
+                            message.obj);
+                        ///@
+                    }
+                ///@}
+                    mWifiNative.p2pStopFind();
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // Do negotiation when persistence fails
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    transitionTo(mGroupNegotiationState);
+                   break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected invitation " + mSavedPeerConfig);
+                    transitionTo(mInactiveState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return ret;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+
+
+    class ProvisionDiscoveryState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            mWifiNative.p2pProvisionDiscovery(mSavedPeerConfig);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            WifiP2pProvDiscEvent provDisc;
+            WifiP2pDevice device;
+            switch (message.what) {
+                case WifiMonitor.P2P_PROV_DISC_PBC_RSP_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                        transitionTo(mGroupNegotiationState);
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.KEYPAD) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        /* we already have the pin */
+                        if (!TextUtils.isEmpty(mSavedPeerConfig.wps.pin)) {
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            mJoinExistingGroup = false;
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        }
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.DISPLAY) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        ///M: for crossmount, support PIN code from outside  @{
+                        if (!mCrossmountEventReceived) {
+                            mSavedPeerConfig.wps.pin = provDisc.pin;
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            notifyInvitationSent(provDisc.pin, device.deviceAddress);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            logd("[crossmount] PD rsp: SHOW_PIN," +
+                                " move process to UserAuthorizingNegotiationRequestState");
+                            mJoinExistingGroup = false;
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        }
+                        ///@}
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
+                    loge("provision discovery failed");
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                ///M:@{
+                case WifiP2pManager.CANCEL_CONNECT:
+                    //Do a supplicant p2p_cancel which only cancels an ongoing
+                    //group negotiation. This will fail for a pending provision
+                    //discovery or for a pending user action, so try Remove group
+                    boolean success = mWifiNative.p2pGroupRemove(mInterface);
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    if (success) {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED);
+                    }
+
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class GroupNegotiationState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                // We ignore these right now, since we get a GROUP_STARTED notification
+                // afterwards
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
+                    if (DBG) logd(getName() + " go success");
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    if (DBG) logd(getName() + " group started");
+
+                    ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+                    // Always exception, mark until further CTS error with log provided
+                    /*try {
+                        mNwService.enableIpv6(mInterface);
+                    } catch (RemoteException re) {
+                        loge(getName() + " RemoteException: " + re);
+                    } catch (IllegalStateException ie) {
+                        loge(getName() + " IllegalStateException: " + ie);
+                    }*/
+
+                    ///@}
+                    if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        /*
+                         * update cache information and set network id to mGroup.
+                         */
+                        updatePersistentNetworks(NO_RELOAD);
+                        String devAddr = mGroup.getOwner().deviceAddress;
+                        mGroup.setNetworkId(mGroups.getNetworkId(devAddr,
+                                mGroup.getNetworkName()));
+
+                        ////M: ALPS01593529: no p2p_invite in wfd source case,
+                        //don't keep persistent group @{
+                        if (mMiracastMode == WifiP2pManager.MIRACAST_SOURCE
+                            && !WFD_DONGLE_USE_P2P_INVITE) {
+                            mWfdSourceAddr = mGroup.getOwner().deviceAddress;
+                            logd("wfd source case: mWfdSourceAddr = " + mWfdSourceAddr);
+                        }
+                        ///@}
+                    }
+
+                    if (mGroup.isGroupOwner()) {
+                        /* Setting an idle time out on GO causes issues with certain scenarios
+                         * on clients where it can be off-channel for longer and with the power
+                         * save modes used.
+                         *
+                         * TODO: Verify multi-channel scenarios and supplicant behavior are
+                         * better before adding a time out in future
+                         */
+                        //Set group idle timeout of 10 sec, to avoid GO beaconing incase of any
+                        //failure during 4-way Handshake.
+                        if (!mAutonomousGroup) {
+                            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
+                        }
+                        startDhcpServer(mGroup.getInterface());
+                    } else {
+                        ///M: No DHCP, use static IP @{
+                        if (mGcIgnoresDhcpReq) {
+                            setWifiP2pInfoOnGroupFormation(
+                                NetworkUtils.numericToInetAddress(SERVER_ADDRESS));
+                            String gcIp = STATIC_CLIENT_ADDRESS;
+                            String intf = mGroup.getInterface();
+                            try {
+                                InterfaceConfiguration ifcg = mNwService.getInterfaceConfig(intf);
+                                ifcg.setLinkAddress(new LinkAddress(
+                                        NetworkUtils.numericToInetAddress(gcIp), 24));
+                                ifcg.setInterfaceUp();
+                                mNwService.setInterfaceConfig(intf, ifcg);
+                                //do addInterfaceToLocalNetwork()
+                                StaticIpConfiguration staticIpConfiguration =
+                                    new StaticIpConfiguration();
+                                staticIpConfiguration.ipAddress =
+                                    new LinkAddress(NetworkUtils.numericToInetAddress(gcIp), 24);
+                                mNwService.addInterfaceToLocalNetwork(
+                                    intf,
+                                    staticIpConfiguration.getRoutes(intf));
+                            }  catch (RemoteException re) {
+                                loge("Error! Configuring static IP to " + intf +
+                                        ", :" + re);
+                            }
+                        } else {
+                            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
+                            startIpManager(mGroup.getInterface());
+                        }
+                        ///@}
+                        ///M: use MTK power saving command @{
+                        //mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
+                        setP2pPowerSaveMtk(mGroup.getInterface(), P2P_FAST_PS);
+                        ///@}
+                        WifiP2pDevice groupOwner = mGroup.getOwner();
+                        WifiP2pDevice peer = mPeers.get(groupOwner.deviceAddress);
+                        if (peer != null) {
+                            // update group owner details with peer details found at discovery
+                            groupOwner.updateSupplicantDetails(peer);
+                            mPeers.updateStatus(groupOwner.deviceAddress, WifiP2pDevice.CONNECTED);
+                            sendPeersChangedBroadcast();
+                        } else {
+                            // A supplicant bug can lead to reporting an invalid
+                            // group owner address (all zeroes) at times. Avoid a
+                            // crash, but continue group creation since it is not
+                            // essential.
+                            logw("Unknown group owner " + groupOwner);
+                        }
+                    }
+                    transitionTo(mGroupCreatedState);
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1) {
+                        mP2pOperFreq = message.arg1;
+                    }
+                    P2pStatus status = (P2pStatus) message.obj;
+                    loge("go negotiation failed, status = " + status + "\tmP2pOperFreq = " +
+                            mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    /* continue with group removal handling */
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                    if (DBG) logd(getName() + " go failure");
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                // A group formation failure is always followed by
+                // a group removed event. Flushing things at group formation
+                // failure causes supplicant issues. Ignore right now.
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1) {
+                        mP2pOperFreq = message.arg1;
+                    }
+                    status = (P2pStatus) message.obj;
+                    loge("group formation failed, status = " + status + "\tmP2pOperFreq = " +
+                            mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    break;
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                    status = (P2pStatus)message.obj;
+                    if (status == P2pStatus.SUCCESS) {
+                        // invocation was succeeded.
+                        // wait P2P_GROUP_STARTED_EVENT.
+                        break;
+                    }
+                    loge("Invitation result " + status);
+                    if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
+                        // target device has already removed the credential.
+                        // So, remove this credential accordingly.
+                        int netId = mSavedPeerConfig.netId;
+                        if (netId >= 0) {
+                            if (DBG) logd("Remove unknown client from the list");
+                            removeClientFromList(netId, mSavedPeerConfig.deviceAddress, true);
+                        }
+
+                        // Reinvocation has failed, try group negotiation
+                        mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    } else if (status == P2pStatus.INFORMATION_IS_CURRENTLY_UNAVAILABLE) {
+                        if (mDelayReconnectForInfoUnavailable) {
+                            if (DBG)
+                                logd(getName() +
+                                        " mDelayReconnectForInfoUnavailable:" +
+                                        mDelayReconnectForInfoUnavailable);
+                            WifiP2pDevice dev = fetchCurrentDeviceDetails(mSavedPeerConfig);
+                            if ((dev.groupCapability & 0x20 /*bit5*/) == 0) {
+                                if (DBG)
+                                    logd(getName() + "Persistent Reconnect=0, " +
+                                                 "wait for peer re-invite or " +
+                                                 "reconnect peer 120s later");
+
+                                WifiP2pConfig peerConfig = new WifiP2pConfig(mSavedPeerConfig);
+                                sendMessageDelayed(
+                                        obtainMessage(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE,
+                                        peerConfig),
+                                        RECONN_FOR_INVITE_RES_INFO_UNAVAILABLE_TIME_MS);
+                                if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
+                                    logd(getName() + "Sart p2pFind for waiting peer invitation");
+                                    sendP2pDiscoveryChangedBroadcast(true);
+                                }
+                                transitionTo(mInactiveState);
+                                break;
+                            } else {
+                                if (DBG)
+                                    logd(getName() + "Persistent Reconnect=1, " +
+                                                 "connect to peer directly");
+                            }
+                        }
+                        // Devices setting persistent_reconnect to 0 in wpa_supplicant
+                        // always defer the invocation request and return
+                        // "information is currently unable" error.
+                        // So, try another way to connect for interoperability.
+                        mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        /** M: enhance frequency conflict @{ */
+                        if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                        logd("Invitation mP2pOperFreq = " + mP2pOperFreq);
+                        transitionTo(mFrequencyConflictState);
+                    } else {
+                        handleGroupCreationFailure();
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                ///M:@{
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                    Toast.makeText(mContext, com.mediatek.internal.R.string.wifi_wps_failed_overlap
+                        , Toast.LENGTH_SHORT).show();
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class FrequencyConflictState extends State {
+        private AlertDialog mFrequencyConflictDialog;
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+
+            /** M: ALPS01976478: SCC then MCC @{ */
+            if (mMccSupport) {
+                p2pSetCCMode(1);
+            }
+            ///@}
+
+            /** M: enhance frequency conflict @{ */
+            if (!mMccSupport && mMiracastMode == WifiP2pManager.MIRACAST_SOURCE) {
+                sendP2pOPChannelBroadcast();
+                return;
+            } else if (mMiracastMode == WifiP2pManager.MIRACAST_SINK) {
+                // WFD/CrossMount Sink retry to connect.
+                // App wiil disconnect legcy wifi according to AIS channel after P2P connected.
+                logd("[sink] channel conflict, disconnecting wifi by app layer");
+                sendMessage(WifiP2pManager.FREQ_CONFLICT_EX_RESULT, 1);
+                return;
+            }
+            /** @} */
+
+            /** M: ALPS01976478: SCC then MCC, only pure SCC will need channel conflict dialog @{ */
+            if (mMccSupport == true) {
+                if (mConnectToPeer == true) {
+                    if (DBG) logd(getName() + " SCC->MCC, mConnectToPeer=" + mConnectToPeer +
+                        "\tP2pOperFreq=" + mP2pOperFreq);
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+
+                    // do p2p_connect/p2p_invite again
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // no need PD again!
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+
+                } else {
+                    if (DBG) logd(getName() + " SCC->MCC, mConnectToPeer=" + mConnectToPeer +
+                        "\tdo p2p_connect/p2p_invite again!");
+                    // don't attach peer op freq. parameter,
+                    //supplicant will switch to MCC automatically
+                    mP2pOperFreq = -1;
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+
+
+                    // do p2p_connect/p2p_invite again
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // no need PD again!
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+                }
+                transitionTo(mGroupNegotiationState);
+
+            } else {
+                notifyFrequencyConflict();
+
+            }
+            ///@}
+        }
+
+        private void notifyFrequencyConflict() {
+            logd("Notify frequency conflict");
+            Resources r = Resources.getSystem();
+
+            AlertDialog dialog = new AlertDialog.Builder(mContext)
+                .setMessage(r.getString(R.string.wifi_p2p_frequency_conflict_message,
+                        getDeviceName(mSavedPeerConfig.deviceAddress)))
+                .setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_ACCEPT);
+                        }
+                    })
+                .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .create();
+
+            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+            WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+            attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+            dialog.getWindow().setAttributes(attrs);
+            dialog.show();
+            mFrequencyConflictDialog = dialog;
+        }
+
+        /** M: enhance frequency conflict @{ */
+        private void notifyFrequencyConflictEx() {
+            logd("Notify frequency conflict enhancement! mP2pOperFreq = " + mP2pOperFreq);
+            Resources r = Resources.getSystem();
+            String localFreq = "";
+
+            if (mP2pOperFreq > 0) {
+                if (mP2pOperFreq < 5000) {
+                    localFreq = "2.4G band-" + new String("" + mP2pOperFreq) + " MHz";
+                } else {
+                    localFreq = "5G band-" + new String("" + mP2pOperFreq) + " MHz";
+                }
+            } else {
+                loge(getName() + " in-valid OP channel: " + mP2pOperFreq);
+            }
+
+            AlertDialog dialog = new AlertDialog.Builder(mContext)
+                .setMessage(r.getString(
+                        com.mediatek.internal.R.string.wifi_p2p_frequency_conflict_message,
+                        getDeviceName(mSavedPeerConfig.deviceAddress),
+                        localFreq))
+                .setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_ACCEPT);
+                        }
+                    })
+                .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .create();
+
+            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+            dialog.show();
+            mFrequencyConflictDialog = dialog;
+        }
+        /** @} */
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
+                    loge(getName() + "group sucess during freq conflict!");
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    loge(getName() + "group started after freq conflict, handle anyway");
+                    deferMessage(message);
+                    transitionTo(mGroupNegotiationState);
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    // Ignore failures since we retry again
+                    break;
+                case DROP_WIFI_USER_REJECT:
+                    ///M: ALPS01472489: notify user decline channel conflict  @{
+                    mGroupRemoveReason = P2pStatus.MTK_EXPAND_02;
+                    ///@}
+                    // User rejected dropping wifi in favour of p2p
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                case DROP_WIFI_USER_ACCEPT:
+                    // User accepted dropping wifi in favour of p2p
+                    mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 1);
+                    mTemporarilyDisconnectedWifi = true;
+                    break;
+                case DISCONNECT_WIFI_RESPONSE:
+                    // Got a response from wifistatemachine, retry p2p
+                    if (DBG) logd(getName() + "Wifi disconnected, retry p2p");
+                    transitionTo(mInactiveState);
+                    ///M:@{
+                    mP2pOperFreq = -1;
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+                    sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                    ///@}
+                    break;
+                /** M: enhance frequency conflict @{ */
+                case WifiP2pManager.FREQ_CONFLICT_EX_RESULT:
+                    int accept = (int) message.arg1;
+                    if (DBG) {
+                        logd(getName() + " frequency confliect enhancement decision: " + accept +
+                        ", and mP2pOperFreq = " + mP2pOperFreq);
+                    }
+                    if (1 == accept) {
+                        transitionTo(mInactiveState);
+                        mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+                        sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                    } else {
+                        notifyFrequencyConflictEx();
+                    }
+                    break;
+                /** @} */
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        public void exit() {
+            if (mFrequencyConflictDialog != null) mFrequencyConflictDialog.dismiss();
+        }
+    }
+
+    class GroupCreatedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            // Once connected, peer config details are invalid
+            mSavedPeerConfig.invalidate();
+            mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.CONNECTED, null, null);
+
+            updateThisDevice(WifiP2pDevice.CONNECTED);
+
+            //DHCP server has already been started if I am a group owner
+            if (mGroup.isGroupOwner()) {
+                setWifiP2pInfoOnGroupFormation(NetworkUtils.numericToInetAddress(SERVER_ADDRESS));
+            ///M:@{
+            } else {
+                ///M: wfd sink@GC, stop listening to avoid packet lost  @{
+                if (isWfdSinkConnected()) {
+                    if (DBG) logd(getName() + " [wfd sink] stop scan@GC, to avoid packet lost");
+                    mWifiNative.p2pStopFind();
+                }
+                ///@}
+            }
+            ///@}
+
+            // In case of a negotiation group, connection changed is sent
+            // after a client joins. For autonomous, send now
+            if (mAutonomousGroup) {
+                sendP2pConnectionChangedBroadcast();
+            }
+
+            // Use static IP without IPM message, send connection change now
+            if (mGcIgnoresDhcpReq) {
+                sendP2pConnectionChangedBroadcast();
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.AP_STA_CONNECTED_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    String deviceAddress = device.deviceAddress;
+                    // Clear timeout that was set when group was started.
+                    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
+                    if (deviceAddress != null) {
+                        if (mPeers.get(deviceAddress) != null) {
+                            mGroup.addClient(mPeers.get(deviceAddress));
+                        } else {
+                            ///M: ALPS00712601 + ALPS00741190: GC connected but not in GO UI @{
+                            //mGroup.addClient(deviceAddress);
+                            device = p2pGoGetSta(device, deviceAddress);
+                            mGroup.addClient(device);
+                            mPeers.update(device);
+                            ///@}
+                        }
+                        ///M: update interface address in mPeers @{
+                        WifiP2pDevice gcLocal = mPeers.get(deviceAddress);
+                        gcLocal.interfaceAddress = device.interfaceAddress;
+                        mPeers.update(gcLocal);
+                        ///@}
+                        mPeers.updateStatus(deviceAddress, WifiP2pDevice.CONNECTED);
+                        sendPeersChangedBroadcast();
+                        ///@}
+                        ///M: wfd sink@GO, stop listening to avoid packet lost  @{
+                        if (isWfdSinkConnected()) {
+                            if (DBG) {
+                                logd(getName() + " [wfd sink] stop scan@GO, to avoid packet lost");
+                            }
+                            mWifiNative.p2pStopFind();
+                        }
+                        ///@}
+                    } else {
+                        loge("Connect on null device address, ignore");
+                    }
+                    sendP2pConnectionChangedBroadcast();
+                    break;
+                case WifiMonitor.AP_STA_DISCONNECTED_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    deviceAddress = device.deviceAddress;
+                    if (deviceAddress != null) {
+                        mPeers.updateStatus(deviceAddress, WifiP2pDevice.AVAILABLE);
+                        if (mGroup.removeClient(deviceAddress)) {
+                            if (DBG) logd("Removed client " + deviceAddress);
+                            if (!mAutonomousGroup && mGroup.isClientListEmpty()) {
+                                logd("Client list empty, remove non-persistent p2p group");
+                                mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                                // We end up sending connection changed broadcast
+                                // when this happens at exit()
+                            } else {
+                                // Notify when a client disconnects from group
+                                sendP2pConnectionChangedBroadcast();
+                            }
+                        } else {
+                            if (DBG) logd("Failed to remove client " + deviceAddress);
+                            for (WifiP2pDevice c : mGroup.getClientList()) {
+                                if (DBG) logd("client " + c.deviceAddress);
+                            }
+                        }
+                        sendPeersChangedBroadcast();
+                        if (DBG) logd(getName() + " ap sta disconnected");
+                    } else {
+                        loge("Disconnect on unknown device: " + device);
+                    }
+                    break;
+                case IPM_PRE_DHCP_ACTION:
+                    mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
+                    mIpManager.completedPreDhcpAction();
+                    break;
+                case IPM_POST_DHCP_ACTION:
+                    /// M: MTK removed,
+                    /// GC power saving had doing at GroupNegotiationState
+                    /// P2P_GROUP_STARTED_EVENT @{
+                    //mWifiNative.setP2pPowerSave(mGroup.getInterface(), true);
+                    break;
+                case IPM_DHCP_RESULTS:
+                    mDhcpResults = (DhcpResults) message.obj;
+                    break;
+                case IPM_PROVISIONING_SUCCESS:
+                    if (DBG) logd("mDhcpResults: " + mDhcpResults);
+                    setWifiP2pInfoOnGroupFormation(mDhcpResults.serverAddress);
+                    // Send this broadcast later
+                    //sendP2pConnectionChangedBroadcast();
+                    try {
+                        final String ifname = mGroup.getInterface();
+                        mNwService.addInterfaceToLocalNetwork(
+                                ifname, mDhcpResults.getRoutes(ifname));
+                    } catch (RemoteException e) {
+                        loge("Failed to add iface to local network " + e);
+                    } catch (IllegalStateException ie) {
+                        loge("Failed to add iface to local network: IllegalStateException=" + ie);
+                    }
+                    ///M: for getPeerIpAddress(), remove "/" prefix  @{
+                    if (mDhcpResults != null) {
+                        if (mDhcpResults.serverAddress != null &&
+                                mDhcpResults.serverAddress.toString().startsWith("/")) {
+                            mGroup.getOwner().deviceIP =
+                                    mDhcpResults.serverAddress.toString().substring(1);
+                        } else {
+                            mGroup.getOwner().deviceIP = "" + mDhcpResults.serverAddress;
+                        }
+                    }
+                    ///@}
+                    /// M: To fix application start socket programming but p2p IP routing
+                    /// rule isn't ready. Do broadcast after addInterfaceToLocalNetwork().  @{
+                    sendP2pConnectionChangedBroadcast();
+                    ///@}
+                    break;
+                case IPM_PROVISIONING_FAILURE:
+                    loge("IP provisioning failed");
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    if (DBG) logd(getName() + " remove group");
+                    if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) {
+                        transitionTo(mOngoingGroupRemovalState);
+                        replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
+                    } else {
+                        handleGroupRemoved();
+                        transitionTo(mInactiveState);
+                        replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                /* We do not listen to NETWORK_DISCONNECTION_EVENT for group removal
+                 * handling since supplicant actually tries to reconnect after a temporary
+                 * disconnect until group idle time out. Eventually, a group removal event
+                 * will come when group has been removed.
+                 *
+                 * When there are connectivity issues during temporary disconnect, the application
+                 * will also just remove the group.
+                 *
+                 * Treating network disconnection as group removal causes race conditions since
+                 * supplicant would still maintain the group at that stage.
+                 */
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                    ///M:@{
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                    mGroupRemoveReason = (P2pStatus) message.obj;
+                    if (DBG) logd(getName() + " group removed, reason: " + mGroupRemoveReason +
+                        ", mP2pOperFreq: " + mP2pOperFreq);
+                    ///@}
+                    handleGroupRemoved();
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    //Device loss for a connected device indicates it is not in discovery any more
+                    if (mGroup.contains(device)) {
+                        if (DBG) logd("Add device to lost list " + device);
+                        mPeersLostDuringConnection.updateSupplicantDetails(device);
+                        return HANDLED;
+                    }
+                    // Do the regular device lost handling
+                    return NOT_HANDLED;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    sendMessage(WifiP2pManager.REMOVE_GROUP);
+                    deferMessage(message);
+                    break;
+                    // This allows any client to join the GO during the
+                    // WPS window
+                case WifiP2pManager.START_WPS:
+                    WpsInfo wps = (WpsInfo) message.obj;
+                    if (wps == null) {
+                        replyToMessage(message, WifiP2pManager.START_WPS_FAILED);
+                        break;
+                    }
+                    boolean ret = true;
+                    if (wps.setup == WpsInfo.PBC) {
+                        ret = mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                    } else {
+                        if (wps.pin == null) {
+                            String pin = mWifiNative.startWpsPinDisplay(mGroup.getInterface());
+                            try {
+                                Integer.parseInt(pin);
+                                notifyInvitationSent(pin, "any");
+                            } catch (NumberFormatException ignore) {
+                                ret = false;
+                            }
+                        } else {
+                            ret = mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
+                                    wps.pin);
+                        }
+                    }
+                    replyToMessage(message, ret ? WifiP2pManager.START_WPS_SUCCEEDED :
+                            WifiP2pManager.START_WPS_FAILED);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    WifiP2pConfig config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping connect requeset " + config);
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
+                        break;
+                    }
+                    logd("Inviting device : " + config.deviceAddress);
+                    mSavedPeerConfig = config;
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    mConnectToPeer = true;
+                    ///@}
+
+                    if (mWifiNative.p2pInvite(mGroup, config.deviceAddress)) {
+                        mPeers.updateStatus(config.deviceAddress, WifiP2pDevice.INVITED);
+                        sendPeersChangedBroadcast();
+                        replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    // TODO: figure out updating the status to declined when invitation is rejected
+                    break;
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                    P2pStatus status = (P2pStatus)message.obj;
+                    logd("===> INVITATION RESULT EVENT : " + status +
+                        ",\tis GO ? : " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress));
+                    ///M: ALPS00609781: remove 3rd phone on gc UI when 3rd is invited @{
+                    boolean inviteDone = false;
+                    if (status == P2pStatus.SUCCESS) {
+                        // invocation was succeeded.
+                        //break;
+                        inviteDone = true;
+                    }
+                    loge("Invitation result " + status +
+                        ",\tis GO ? : " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress));
+                    if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
+                        // target device has already removed the credential.
+                        // So, remove this credential accordingly.
+                        int netId = mGroup.getNetworkId();
+                        if (netId >= 0) {
+                            if (DBG) logd("Remove unknown client from the list");
+                            if (!removeClientFromList(netId,
+                                    mSavedPeerConfig.deviceAddress, false)) {
+                                // not found the client on the list
+                                loge("Already removed the client, ignore");
+                                break;
+                            }
+                            // try invitation.
+                            sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                        }
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        if (mMccSupport) {
+                            p2pSetCCMode(1);
+                        }
+                    ///@}
+                        inviteDone = true;
+                    } else {
+                        inviteDone = true;
+                    }
+
+                    if (inviteDone &&
+                        !mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress)) {
+                        if (mPeers.remove(mPeers.get(mSavedPeerConfig.deviceAddress))) {
+                              sendPeersChangedBroadcast();
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    if (!TextUtils.isEmpty(provDisc.device.deviceName)) {
+                        mPeers.update(provDisc.device);
+                    }
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    mSavedPeerConfig = new WifiP2pConfig();
+                    mSavedPeerConfig.deviceAddress = provDisc.device.deviceAddress;
+                    if (message.what == WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT) {
+                        mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
+                    } else if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
+                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        mSavedPeerConfig.wps.pin = provDisc.pin;
+                    } else {
+                        mSavedPeerConfig.wps.setup = WpsInfo.PBC;
+                    }
+                    transitionTo(mUserAuthorizingJoinState);
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    loge("Duplicate group creation event notice, ignore");
+                    break;
+                ///M:@{
+                //ALPS02238912
+                case WifiP2pManager.REMOVE_CLIENT:
+                    String mac = null;
+                    if (message.obj != null) {
+                        mac = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_CLIENT_MESSAGE);
+                    }
+                    logd("remove client, am I GO? " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress) +
+                        ", ths client is " + mac);
+
+                    if (!mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress)) {
+                        replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                                WifiP2pManager.ERROR);
+                    } else {
+                        if (p2pRemoveClient(mGroup.getInterface(), mac)) {
+                            replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_SUCCEEDED);
+                        } else {
+                            replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                                WifiP2pManager.ERROR);
+                        }
+                    }
+                    break;
+                case WifiMonitor.P2P_PEER_DISCONNECT_EVENT:
+                    /*M: ALPS00790492: handle P2P_PEER_DISCONNECT_EVENT frequency conflict error,
+                    //reason code is 99*/
+                    int IEEE802_11_ReasonCode = -1;
+                    if (message.obj != null) {
+                        try {
+                            IEEE802_11_ReasonCode = Integer.valueOf((String) message.obj);
+                            if (IEEE802_11_ReasonCode == 99) {
+                                mGroupRemoveReason = P2pStatus.NO_COMMON_CHANNEL;
+                            }
+                        } catch (NumberFormatException e) {
+                            loge("Error! Format unexpected");
+                        }
+                    }
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                    /* only GC will received this event */
+                    if (DBG)
+                        loge(getName() +
+                             " I'm GC and has been disconnected by GO. IEEE 802.11 reason code: " +
+                             IEEE802_11_ReasonCode +
+                        ", mP2pOperFreq: " + mP2pOperFreq);
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    handleGroupRemoved();
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice peerDevice = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(peerDevice.deviceAddress)) break;
+                    if (mGroup.contains(peerDevice)) {
+                        peerDevice.status = WifiP2pDevice.CONNECTED;
+                    }
+                    mPeers.update(peerDevice);
+                    sendPeersChangedBroadcast();
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (DBG) loge("Supplicant close unexpected, send fake Group Remove event");
+                    sendMessage(WifiMonitor.P2P_GROUP_REMOVED_EVENT);
+                    deferMessage(message);
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    // do not send service discovery request while normal find operation.
+                    clearSupplicantServiceRequest();
+                    if (mWifiNative.p2pFind(CONNECTED_DISCOVER_TIMEOUT_S)) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
+                        sendP2pDiscoveryChangedBroadcast(true);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        public void exit() {
+            updateThisDevice(WifiP2pDevice.AVAILABLE);
+            resetWifiP2pInfo();
+            mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
+            ///M: wfd sink & crossmount, label this broadcast due to 2nd GC connection comming  @{
+            if (mGroup != null) {
+                logd("[wfd sink/source] [crossmount] " +
+                    " {1} isGroupOwner: " + mGroup.isGroupOwner() +
+                    " {2} getClientAmount: " + mGroup.getClientAmount() +
+                    " {3} isGroupRemoved(): " + isGroupRemoved() +
+                    " {4} mCrossmountIEAdded: " + mCrossmountIEAdded);
+            }
+            // case 1: wfd sink && go & gc amount=1
+            if (isWfdSinkConnected()) {
+                //sendP2pConnectionChangedBroadcast(P2pStatus.MTK_EXPAND_01);
+                logd("[wfd sink/source] don't bother wfd framework, case 1");
+
+            // case 2: wfd source && group still formed
+            } else if (isWfdSourceConnected()) {
+                //sendP2pConnectionChangedBroadcast(P2pStatus.MTK_EXPAND_01);
+                logd("[wfd sink/source] don't bother wfd framework, case 2");
+
+            // case 3: crossmount && go && gc amount>0
+            } else if (isCrossMountGOwithMultiGC()) {
+                logd("[crossmount] don't bother crossmount framework, case 3");
+
+            } else
+            ///@}
+            /*M: ALPS00677009: broadcast the group removed reason*/
+            sendP2pConnectionChangedBroadcast(mGroupRemoveReason);
+        }
+    }
+
+    class UserAuthorizingJoinState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: for wfd sink, reject 2nd gc  @{
+            if (isWfdSinkEnabled()) {
+                sendMessage(PEER_CONNECTION_USER_REJECT);
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    //Ignore more client requests
+                    break;
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    ///M: crossmount, support PIN code from outside  @{
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER) {
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingJoinState",
+                            message.obj);
+                    }
+                    ///@
+                ///@}
+                    //Stop discovery to avoid failure due to channel switch
+                    mWifiNative.p2pStopFind();
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
+                        mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                    } else {
+                        mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
+                                mSavedPeerConfig.wps.pin);
+                    }
+                    //M: ALPS02215527: stay at UserAuthorizingJoinState,
+                    // wait connect result then going back to GroupCreatedState
+                    //transitionTo(mGroupCreatedState);
+                    ///@}
+                    break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected incoming request");
+                    transitionTo(mGroupCreatedState);
+                    break;
+                /*M: ALPS02215527: to fit P2P-PROV-DISC-PBC-REQ received twice*/
+                case WifiMonitor.AP_STA_CONNECTED_EVENT:
+                    if (DBG) logd("incoming request is connected!");
+                    deferMessage(message);
+                    transitionTo(mGroupCreatedState);
+                    break;
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case WifiMonitor.WPS_FAIL_EVENT:
+                case WifiMonitor.WPS_TIMEOUT_EVENT:
+                    if (DBG) logd("incoming request connect failed!");
+                    transitionTo(mGroupCreatedState);
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+    class OngoingGroupRemovalState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                // Group removal ongoing. Multiple calls
+                // end up removing persisted network. Do nothing.
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
+                    break;
+                ///M: REMOVE_CLIENT follow REMOVE_GROUP behavior  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_SUCCEEDED);
+                    break;
+                ///@}
+                // Parent state will transition out of this state
+                // when removal is complete
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        super.dump(fd, pw, args);
+        pw.println("mWifiP2pInfo " + mWifiP2pInfo);
+        pw.println("mGroup " + mGroup);
+        pw.println("mSavedPeerConfig " + mSavedPeerConfig);
+        pw.println();
+    }
+
+    private void sendP2pStateChangedBroadcast(boolean enabled) {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        if (enabled) {
+            intent.putExtra(WifiP2pManager.EXTRA_WIFI_STATE,
+                    WifiP2pManager.WIFI_P2P_STATE_ENABLED);
+        } else {
+            intent.putExtra(WifiP2pManager.EXTRA_WIFI_STATE,
+                    WifiP2pManager.WIFI_P2P_STATE_DISABLED);
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendP2pDiscoveryChangedBroadcast(boolean started) {
+        if (mDiscoveryStarted == started) return;
+        mDiscoveryStarted = started;
+
+        if (DBG) logd("discovery change broadcast " + started);
+
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiP2pManager.EXTRA_DISCOVERY_STATE, started ?
+                WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED :
+                WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendThisDeviceChangedBroadcast() {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE, new WifiP2pDevice(mThisDevice));
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendPeersChangedBroadcast() {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
+        intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST, new WifiP2pDeviceList(mPeers));
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        /*M: ALPS00541624, sticky broadcast to avoid apk miss peer information */
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendP2pConnectionChangedBroadcast() {
+        if (DBG) logd("sending p2p connection changed broadcast, mGroup: " + mGroup);
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO, new WifiP2pInfo(mWifiP2pInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP, new WifiP2pGroup(mGroup));
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        mWifiChannel.sendMessage(WifiP2pServiceImpl.P2P_CONNECTION_CHANGED,
+                new NetworkInfo(mNetworkInfo));
+    }
+
+    private void sendP2pPersistentGroupsChangedBroadcast() {
+        if (DBG) logd("sending p2p persistent groups changed broadcast");
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_PERSISTENT_GROUPS_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void startDhcpServer(String intf) {
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = mNwService.getInterfaceConfig(intf);
+            ifcg.setLinkAddress(new LinkAddress(NetworkUtils.numericToInetAddress(
+                        SERVER_ADDRESS), 24));
+            ifcg.setInterfaceUp();
+            mNwService.setInterfaceConfig(intf, ifcg);
+            /* This starts the dnsmasq server */
+            ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
+                    Context.CONNECTIVITY_SERVICE);
+            String[] tetheringDhcpRanges = cm.getTetheredDhcpRanges();
+            if (mNwService.isTetheringStarted()) {
+                if (DBG) logd("Stop existing tethering and restart it");
+                mNwService.stopTethering();
+            }
+            mNwService.tetherInterface(intf);
+            mNwService.startTethering(tetheringDhcpRanges);
+        } catch (Exception e) {
+            loge("Error configuring interface " + intf + ", :" + e);
+            return;
+        }
+
+        logd("Started Dhcp server on " + intf);
+   }
+
+    private void stopDhcpServer(String intf) {
+        try {
+            mNwService.untetherInterface(intf);
+            for (String temp : mNwService.listTetheredInterfaces()) {
+                logd("List all interfaces " + temp);
+                if (temp.compareTo(intf) != 0) {
+                    logd("Found other tethering interfaces, so keep tethering alive");
+                    return;
+                }
+            }
+            mNwService.stopTethering();
+        } catch (Exception e) {
+            loge("Error stopping Dhcp server" + e);
+            return;
+        } finally {
+            logd("Stopped Dhcp server");
+        }
+    }
+
+    private void notifyP2pEnableFailure() {
+        Resources r = Resources.getSystem();
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_dialog_title))
+            .setMessage(r.getString(R.string.wifi_p2p_failed_message))
+            .setPositiveButton(r.getString(R.string.ok), null)
+            .create();
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    private void addRowToDialog(ViewGroup group, int stringId, String value) {
+        Resources r = Resources.getSystem();
+        View row = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog_row,
+                group, false);
+        ((TextView) row.findViewById(R.id.name)).setText(r.getString(stringId));
+        ((TextView) row.findViewById(R.id.value)).setText(value);
+        group.addView(row);
+    }
+
+    private void notifyInvitationSent(String pin, String peerAddress) {
+        Resources r = Resources.getSystem();
+
+        final View textEntryView = LayoutInflater.from(mContext)
+                .inflate(R.layout.wifi_p2p_dialog, null);
+
+        ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
+        addRowToDialog(group, R.string.wifi_p2p_to_message, getDeviceName(peerAddress));
+        addRowToDialog(group, R.string.wifi_p2p_show_pin_message, pin);
+
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_invitation_sent_title))
+            .setView(textEntryView)
+            .setPositiveButton(r.getString(R.string.ok), null)
+            .create();
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    private void notifyInvitationReceived() {
+        Resources r = Resources.getSystem();
+        final WpsInfo wps = mSavedPeerConfig.wps;
+        final View textEntryView = LayoutInflater.from(mContext)
+                .inflate(R.layout.wifi_p2p_dialog, null);
+
+        ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
+        addRowToDialog(group, R.string.wifi_p2p_from_message, getDeviceName(
+                mSavedPeerConfig.deviceAddress));
+
+        final EditText pin = (EditText) textEntryView.findViewById(R.id.wifi_p2p_wps_pin);
+
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_invitation_to_connect_title))
+            .setView(textEntryView)
+            .setPositiveButton(r.getString(R.string.accept), new OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            if (wps.setup == WpsInfo.KEYPAD) {
+                                mSavedPeerConfig.wps.pin = pin.getText().toString();
+                            }
+                            if (DBG) logd(getName() + " accept invitation " + mSavedPeerConfig);
+                            sendMessage(PEER_CONNECTION_USER_ACCEPT);
+                        }
+                    })
+            .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            if (DBG) logd(getName() + " ignore connect");
+                            sendMessage(PEER_CONNECTION_USER_REJECT);
+                        }
+                    })
+            .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            if (DBG) logd(getName() + " ignore connect");
+                            sendMessage(PEER_CONNECTION_USER_REJECT);
+                        }
+                    })
+            .create();
+
+        //make the enter pin area or the display pin area visible
+        switch (wps.setup) {
+            case WpsInfo.KEYPAD:
+                if (DBG) logd("Enter pin section visible");
+                textEntryView.findViewById(R.id.enter_pin_section).setVisibility(View.VISIBLE);
+                break;
+            case WpsInfo.DISPLAY:
+                if (DBG) logd("Shown pin section visible");
+                addRowToDialog(group, R.string.wifi_p2p_show_pin_message, wps.pin);
+                break;
+            default:
+                break;
+        }
+
+        if ((r.getConfiguration().uiMode & Configuration.UI_MODE_TYPE_APPLIANCE) ==
+                Configuration.UI_MODE_TYPE_APPLIANCE) {
+            // For appliance devices, add a key listener which accepts.
+            dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
+
+                @Override
+                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
+                    // TODO: make the actual key come from a config value.
+                    if (keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
+                        sendMessage(PEER_CONNECTION_USER_ACCEPT);
+                        dialog.dismiss();
+                        return true;
+                    }
+                    return false;
+                }
+            });
+            // TODO: add timeout for this dialog.
+            // TODO: update UI in appliance mode to tell user what to do.
+        }
+
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    /**
+     * Synchronize the persistent group list between
+     * wpa_supplicant and mGroups.
+     */
+    private void updatePersistentNetworks(boolean reload) {
+        String listStr = mWifiNative.listNetworks();
+        if (listStr == null) return;
+
+        boolean isSaveRequired = false;
+        String[] lines = listStr.split("\n");
+        if (lines == null) return;
+
+        if (reload) mGroups.clear();
+
+        // Skip the first line, which is a header
+        for (int i = 1; i < lines.length; i++) {
+            String[] result = lines[i].split("\t");
+            if (result == null || result.length < 4) {
+                continue;
+            }
+            // network-id | ssid | bssid | flags
+            int netId = -1;
+            String ssid = result[1];
+            String bssid = result[2];
+            String flags = result[3];
+            try {
+                netId = Integer.parseInt(result[0]);
+            } catch(NumberFormatException e) {
+                e.printStackTrace();
+                continue;
+            }
+
+            if (flags.indexOf("[CURRENT]") != -1) {
+                continue;
+            }
+            if (flags.indexOf("[P2P-PERSISTENT]") == -1) {
+                /*
+                 * The unused profile is sometimes remained when the p2p group formation is failed.
+                 * So, we clean up the p2p group here.
+                 */
+                if (DBG) logd("clean up the unused persistent group. netId=" + netId);
+                mWifiNative.removeNetwork(netId);
+                isSaveRequired = true;
+                continue;
+            }
+
+            if (mGroups.contains(netId)) {
+                continue;
+            }
+
+            WifiP2pGroup group = new WifiP2pGroup();
+            group.setNetworkId(netId);
+            ///M: For UTF8 and GBK support
+            WifiSsid wifiSssid = WifiSsid.createFromAsciiEncoded(ssid);
+            group.setNetworkName(wifiSssid.toString());
+            String mode = mWifiNative.getNetworkVariable(netId, "mode");
+            if (mode != null && mode.equals("3")) {
+                group.setIsGroupOwner(true);
+            }
+            if (bssid.equalsIgnoreCase(mThisDevice.deviceAddress)) {
+                group.setOwner(mThisDevice);
+            } else {
+                WifiP2pDevice device = new WifiP2pDevice();
+                device.deviceAddress = bssid;
+                group.setOwner(device);
+            }
+            mGroups.add(group);
+            isSaveRequired = true;
+        }
+
+        if (reload || isSaveRequired) {
+            mWifiNative.saveConfig();
+            sendP2pPersistentGroupsChangedBroadcast();
+        }
+    }
+
+    /**
+     * A config is valid if it has a peer address that has already been
+     * discovered
+     * @return true if it is invalid, false otherwise
+     */
+    private boolean isConfigInvalid(WifiP2pConfig config) {
+        if (config == null) return true;
+        if (TextUtils.isEmpty(config.deviceAddress)) return true;
+        if (mPeers.get(config.deviceAddress) == null) return true;
+        return false;
+    }
+
+    /* TODO: The supplicant does not provide group capability changes as an event.
+     * Having it pushed as an event would avoid polling for this information right
+     * before a connection
+     */
+    private WifiP2pDevice fetchCurrentDeviceDetails(WifiP2pConfig config) {
+        /* Fetch & update group capability from supplicant on the device */
+        int gc = mWifiNative.getGroupCapability(config.deviceAddress);
+
+        // Don't use gc fatch data from supplicant if we ware invited,
+        // the GO address in config is set from invitation event, which is
+        // definitely a GO device.
+        if (getCurrentState() instanceof UserAuthorizingInviteRequestState) {
+            gc |= 1; //WifiP2pDevice.GROUP_CAPAB_GROUP_OWNER
+        }
+        mPeers.updateGroupCapability(config.deviceAddress, gc);
+        return mPeers.get(config.deviceAddress);
+    }
+
+    /**
+     * Start a p2p group negotiation and display pin if necessary
+     * @param config for the peer
+     */
+    private void p2pConnectWithPinDisplay(WifiP2pConfig config) {
+        WifiP2pDevice dev = fetchCurrentDeviceDetails(config);
+
+        String pin = mWifiNative.p2pConnect(config, dev.isGroupOwner());
+        try {
+            Integer.parseInt(pin);
+            notifyInvitationSent(pin, config.deviceAddress);
+        } catch (NumberFormatException ignore) {
+            // do nothing if p2pConnect did not return a pin
+        }
+    }
+
+    /**
+     * Reinvoke a persistent group.
+     *
+     * @param config for the peer
+     * @return true on success, false on failure
+     */
+    private boolean reinvokePersistentGroup(WifiP2pConfig config) {
+        ///M: App sets the hide variable for the connections need it's permmit @{
+        if (config.netId == WifiP2pGroup.TEMPORARY_NET_ID) {
+            return false;
+        }
+        ///@}
+
+        WifiP2pDevice dev = fetchCurrentDeviceDetails(config);
+
+        boolean join = dev.isGroupOwner();
+        String ssid = mWifiNative.p2pGetSsid(dev.deviceAddress);
+        if (DBG) logd("target ssid is " + ssid + " join:" + join);
+
+        if (join && dev.isGroupLimit()) {
+            if (DBG) logd("target device reaches group limit.");
+
+            // if the target group has reached the limit,
+            // try group formation.
+            join = false;
+        } else if (join) {
+            int netId = mGroups.getNetworkId(dev.deviceAddress, ssid);
+            if (netId >= 0) {
+                ///M: ALPS00605482+ALPS00657537: can't use p2pGroupAdd when peer is GO and had
+                // ever formed @{
+                // Skip WPS and start 4way handshake immediately.
+                //if (!mWifiNative.p2pGroupAdd(netId)) {
+                if (!mWifiNative.p2pReinvoke(netId, dev.deviceAddress)) {
+                    return false;
+                }
+                ///@}
+                return true;
+            }
+        }
+
+        if (!join && dev.isDeviceLimit()) {
+            loge("target device reaches the device limit.");
+            return false;
+        }
+
+        if (!join && dev.isInvitationCapable()) {
+            int netId = WifiP2pGroup.PERSISTENT_NET_ID;
+            if (config.netId >= 0) {
+                if (config.deviceAddress.equals(mGroups.getOwnerAddr(config.netId))) {
+                    netId = config.netId;
+                }
+            } else {
+                netId = mGroups.getNetworkId(dev.deviceAddress);
+            }
+            if (netId < 0) {
+                netId = getNetworkIdFromClientList(dev.deviceAddress);
+            }
+            if (DBG) logd("netId related with " + dev.deviceAddress + " = " + netId);
+            if (netId >= 0) {
+                // Invoke the persistent group.
+                if (mWifiNative.p2pReinvoke(netId, dev.deviceAddress)) {
+                    // Save network id. It'll be used when an invitation result event is received.
+                    config.netId = netId;
+                    return true;
+                } else {
+                    loge("p2pReinvoke() failed, update networks");
+                    updatePersistentNetworks(RELOAD);
+                    return false;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Return the network id of the group owner profile which has the p2p client with
+     * the specified device address in it's client list.
+     * If more than one persistent group of the same address is present in its client
+     * lists, return the first one.
+     *
+     * @param deviceAddress p2p device address.
+     * @return the network id. if not found, return -1.
+     */
+    private int getNetworkIdFromClientList(String deviceAddress) {
+        if (deviceAddress == null) return -1;
+
+        Collection<WifiP2pGroup> groups = mGroups.getGroupList();
+        for (WifiP2pGroup group : groups) {
+            int netId = group.getNetworkId();
+            String[] p2pClientList = getClientList(netId);
+            if (p2pClientList == null) continue;
+            for (String client : p2pClientList) {
+                if (deviceAddress.equalsIgnoreCase(client)) {
+                    return netId;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Return p2p client list associated with the specified network id.
+     * @param netId network id.
+     * @return p2p client list. if not found, return null.
+     */
+    private String[] getClientList(int netId) {
+        String p2pClients = mWifiNative.getNetworkVariable(netId, "p2p_client_list");
+        if (p2pClients == null) {
+            return null;
+        }
+        return p2pClients.split(" ");
+    }
+
+    /**
+     * Remove the specified p2p client from the specified profile.
+     * @param netId network id of the profile.
+     * @param addr p2p client address to be removed.
+     * @param isRemovable if true, remove the specified profile if its client list becomes empty.
+     * @return whether removing the specified p2p client is successful or not.
+     */
+    private boolean removeClientFromList(int netId, String addr, boolean isRemovable) {
+        StringBuilder modifiedClientList =  new StringBuilder();
+        String[] currentClientList = getClientList(netId);
+        boolean isClientRemoved = false;
+        if (currentClientList != null) {
+            for (String client : currentClientList) {
+                if (!client.equalsIgnoreCase(addr)) {
+                    modifiedClientList.append(" ");
+                    modifiedClientList.append(client);
+                } else {
+                    isClientRemoved = true;
+                }
+            }
+        }
+        if (modifiedClientList.length() == 0 && isRemovable) {
+            // the client list is empty. so remove it.
+            if (DBG) logd("Remove unknown network");
+            mGroups.remove(netId);
+            return true;
+        }
+
+        if (!isClientRemoved) {
+            // specified p2p client is not found. already removed.
+            return false;
+        }
+
+        if (DBG) logd("Modified client list: " + modifiedClientList);
+        if (modifiedClientList.length() == 0) {
+            modifiedClientList.append("\"\"");
+        }
+        mWifiNative.setNetworkVariable(netId,
+                "p2p_client_list", modifiedClientList.toString());
+        mWifiNative.saveConfig();
+        return true;
+    }
+
+    private void setWifiP2pInfoOnGroupFormation(InetAddress serverInetAddress) {
+        mWifiP2pInfo.groupFormed = true;
+        mWifiP2pInfo.isGroupOwner = mGroup.isGroupOwner();
+        mWifiP2pInfo.groupOwnerAddress = serverInetAddress;
+    }
+
+    private void resetWifiP2pInfo() {
+        mGcIgnoresDhcpReq = false;
+
+        ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+        /*try {
+            mNwService.disableIpv6(mInterface);
+        } catch (RemoteException re) {
+            loge("resetWifiP2pInfo() disableIpv6 RemoteException: " + re);
+        } catch (IllegalStateException ie) {
+            loge("resetWifiP2pInfo() disableIpv6 IllegalStateException: " + ie);
+        }*/
+        ///@}
+        mWifiP2pInfo.groupFormed = false;
+        mWifiP2pInfo.isGroupOwner = false;
+        mWifiP2pInfo.groupOwnerAddress = null;
+        ///M: ALPS01212893: for poor link, wifi p2p stop Tx all traffic @{
+        sendP2pTxBroadcast(false);
+        ///@}
+        ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL after receiving
+        //nego-request  @{
+        mNegoChannelConflict = false;
+        ///@}
+        /** M: ALPS01976478: SCC then MCC @{ */
+        if (mMccSupport) {
+            p2pSetCCMode(0);
+        }
+        mConnectToPeer = false;
+        ///@}
+        ///M: for crossmount @{
+        mCrossmountEventReceived = false;
+        mCrossmountSessionInfo = "";
+        ///@}
+        ///M: increase success rate for invitation @{
+        mUpdatePeerForInvited = false;
+        ///@}
+    }
+
+    private String getDeviceName(String deviceAddress) {
+        WifiP2pDevice d = mPeers.get(deviceAddress);
+        if (d != null) {
+                return d.deviceName;
+        }
+        //Treat the address as name if there is no match
+        return deviceAddress;
+    }
+
+    private String getPersistedDeviceName() {
+        String deviceName = Settings.Global.getString(mContext.getContentResolver(),
+                Settings.Global.WIFI_P2P_DEVICE_NAME);
+        if (deviceName == null) {
+            /* We use the 4 digits of the ANDROID_ID to have a friendly
+             * default that has low likelihood of collision with a peer */
+            String id = Settings.Secure.getString(mContext.getContentResolver(),
+                    Settings.Secure.ANDROID_ID);
+            return "3Prism XX";
+        }
+        return deviceName;
+    }
+
+    private boolean setAndPersistDeviceName(String devName) {
+        if (devName == null) return false;
+
+        if (!mWifiNative.setDeviceName(devName)) {
+            loge("Failed to set device name " + devName);
+            return false;
+        }
+
+        mThisDevice.deviceName = devName;
+        mWifiNative.setP2pSsidPostfix("-" + getSsidPostfix(mThisDevice.deviceName));
+
+        Settings.Global.putString(mContext.getContentResolver(),
+                Settings.Global.WIFI_P2P_DEVICE_NAME, devName);
+        sendThisDeviceChangedBroadcast();
+        return true;
+    }
+
+    private boolean setWfdInfo(WifiP2pWfdInfo wfdInfo) {
+        boolean success;
+
+        if (!wfdInfo.isWfdEnabled()) {
+            success = mWifiNative.setWfdEnable(false);
+        } else {
+            success =
+                mWifiNative.setWfdEnable(true)
+                && mWifiNative.setWfdDeviceInfo(wfdInfo.getDeviceInfoHex());
+        }
+
+        if (!success) {
+            loge("Failed to set wfd properties, Device Info part");
+            return false;
+        }
+
+        //M: ALPS01255052: UIBC in WFD IE
+        if (wfdInfo.getExtendedCapability() != 0) {
+            setWfdExtCapability(wfdInfo.getExtCapaHex());
+        }
+
+        mThisDevice.wfdInfo = wfdInfo;
+        sendThisDeviceChangedBroadcast();
+        return true;
+    }
+
+    private void initializeP2pSettings() {
+        mWifiNative.setPersistentReconnect(true);
+        mThisDevice.deviceName = getPersistedDeviceName();
+        mWifiNative.setDeviceName(mThisDevice.deviceName);
+        // DIRECT-XY-DEVICENAME (XY is randomly generated)
+        mWifiNative.setP2pSsidPostfix("-" + getSsidPostfix(mThisDevice.deviceName));
+        mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
+        // Supplicant defaults to using virtual display with display
+        // which refers to a remote display. Use physical_display
+        mWifiNative.setConfigMethods("virtual_push_button physical_display keypad");
+        // STA has higher priority over P2P
+        mWifiNative.setConcurrencyPriority("sta");
+
+        if (DBG) logd("old DeviceAddress: " + mThisDevice.deviceAddress);
+        mThisDevice.deviceAddress = mWifiNative.p2pGetDeviceAddress();
+        if (DBG) logd("new DeviceAddress: " + mThisDevice.deviceAddress);
+        updateThisDevice(WifiP2pDevice.AVAILABLE);
+        if (DBG) logd("DeviceAddress: " + mThisDevice.deviceAddress);
+
+        mClientInfoList.clear();
+        mWifiNative.p2pFlush();
+        mWifiNative.p2pServiceFlush();
+        mServiceTransactionId = 0;
+        mServiceDiscReqId = null;
+
+        updatePersistentNetworks(RELOAD);
+
+        /** M: ALPS01976478: SCC then MCC @{ */
+        mMccSupport = SystemProperties.get("ro.mtk_wifi_mcc_support").equals("1");
+        if (DBG) logd("is Mcc Supported: " + mMccSupport);
+        if (mMccSupport == true) {
+            p2pSetCCMode(0);
+        }
+        ///@}
+    }
+
+    private void updateThisDevice(int status) {
+        mThisDevice.status = status;
+        sendThisDeviceChangedBroadcast();
+    }
+
+    private void handleGroupCreationFailure() {
+        resetWifiP2pInfo();
+        mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.FAILED, null, null);
+
+        ///M: ALPS01472489: notify user decline channel conflict  @{
+        if (mGroupRemoveReason == P2pStatus.UNKNOWN) {
+            sendP2pConnectionChangedBroadcast();
+        } else {
+            sendP2pConnectionChangedBroadcast(mGroupRemoveReason);
+        }
+        ///@}
+
+        // Remove only the peer we failed to connect to so that other devices discovered
+        // that have not timed out still remain in list for connection
+        boolean peersChanged = mPeers.remove(mPeersLostDuringConnection);
+        if (TextUtils.isEmpty(mSavedPeerConfig.deviceAddress) == false &&
+                mPeers.remove(mSavedPeerConfig.deviceAddress) != null) {
+            peersChanged = true;
+        }
+        if (peersChanged) {
+            sendPeersChangedBroadcast();
+        }
+
+        mPeersLostDuringConnection.clear();
+        ///M: Google issue, reset mServiceDiscReqId would cause service discovery can't clear up @{
+        //mServiceDiscReqId = null;
+        clearSupplicantServiceRequest();
+        ///@}
+
+        /*M: ALPS01807734: wfd sink won't trigger normal scan, let scan request from user */
+        if (!isWfdSinkEnabled()) {
+            sendMessage(WifiP2pManager.DISCOVER_PEERS);
+        }
+
+        /*M: ALPS01000415: case #17-7,#18-1 -> Wifi AP not reconnect problem */
+        if (mTemporarilyDisconnectedWifi) {
+            mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
+            mTemporarilyDisconnectedWifi = false;
+        }
+    }
+
+    private void handleGroupRemoved() {
+        if (mGroup.isGroupOwner()) {
+            stopDhcpServer(mGroup.getInterface());
+            ///M: remove dhcp info. file  @{
+            boolean b;
+            File dhcpFile = new File(DHCP_INFO_FILE);
+            if (DBG) logd("DHCP file exists=" + dhcpFile.exists());
+            if (dhcpFile.exists()) {
+                b = dhcpFile.delete();
+                if (b) logd("Delete p2p0 dhcp info file OK!");
+            }
+            ///@}
+        } else {
+            if (DBG) logd("stop IpManager");
+            stopIpManager();
+            try {
+                mNwService.removeInterfaceFromLocalNetwork(mGroup.getInterface());
+            } catch (RemoteException e) {
+                loge("Failed to remove iface from local network " + e);
+            }
+        }
+
+        try {
+            mNwService.clearInterfaceAddresses(mGroup.getInterface());
+        } catch (Exception e) {
+            loge("Failed to clear addresses " + e);
+        }
+
+        // Clear any timeout that was set. This is essential for devices
+        // that reuse the main p2p interface for a created group.
+        mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
+
+        ////M: ALPS01593529: no p2p_invite in wfd source case, don't keep persistent group @{
+        if (!TextUtils.isEmpty(mWfdSourceAddr)) {
+            logd("wfd source case: mWfdSourceAddr = " + mWfdSourceAddr);
+            while (mGroups.contains(mGroups.getNetworkId(mWfdSourceAddr))) {
+                mGroups.remove(mGroups.getNetworkId(mWfdSourceAddr));
+            }
+            mWfdSourceAddr = null;
+        }
+        ///@}
+
+        boolean peersChanged = false;
+        // Remove only peers part of the group, so that other devices discovered
+        // that have not timed out still remain in list for connection
+        for (WifiP2pDevice d : mGroup.getClientList()) {
+            if (d != null) {
+                logd("handleGroupRemoved, call mPeers.remove - d.deviceName = " +
+                    d.deviceName + " d.deviceAddress = " + d.deviceAddress);
+            }
+            if (mPeers.remove(d)) peersChanged = true;
+        }
+        if (mPeers.remove(mGroup.getOwner())) peersChanged = true;
+        if (mPeers.remove(mPeersLostDuringConnection)) peersChanged = true;
+        if (peersChanged) {
+            sendPeersChangedBroadcast();
+        }
+
+        mGroup = null;
+        mPeersLostDuringConnection.clear();
+        ///M: Google issue, reset mServiceDiscReqId would cause service discovery can't clear up @{
+        //mServiceDiscReqId = null;
+        clearSupplicantServiceRequest();
+        ///@}
+
+        if (mTemporarilyDisconnectedWifi) {
+            mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
+            mTemporarilyDisconnectedWifi = false;
+        }
+
+        ///M: from supplicant owner's request:
+        //    -to fix waiting 36s to find out peer when auto reconnect
+        mWifiNative.p2pFlush();
+        ///@}
+    }
+
+    //State machine initiated requests can have replyTo set to null indicating
+    //there are no recipients, we ignore those reply actions
+    private void replyToMessage(Message msg, int what) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, int arg1) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.arg1 = arg1;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, Object obj) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.obj = obj;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    /* arg2 on the source message has a hash code that needs to be retained in replies
+     * see WifiP2pManager for details */
+    private Message obtainMessage(Message srcMsg) {
+        Message msg = Message.obtain();
+        msg.arg2 = srcMsg.arg2;
+        return msg;
+    }
+
+    @Override
+    protected void logd(String s) {
+        ///M: @{
+        //Slog.d(TAG, s);
+        Log.d(TAG, s);
+        ///@}
+    }
+
+    @Override
+    protected void loge(String s) {
+        ///M: @{
+        //Slog.e(TAG, s);
+        Log.e(TAG, s);
+        ///@}
+    }
+
+    /**
+     * Update service discovery request to wpa_supplicant.
+     */
+    private boolean updateSupplicantServiceRequest() {
+        clearSupplicantServiceRequest();
+
+        StringBuffer sb = new StringBuffer();
+        for (ClientInfo c: mClientInfoList.values()) {
+            int key;
+            WifiP2pServiceRequest req;
+            for (int i=0; i < c.mReqList.size(); i++) {
+                req = c.mReqList.valueAt(i);
+                if (req != null) {
+                    sb.append(req.getSupplicantQuery());
+                }
+            }
+        }
+
+        if (sb.length() == 0) {
+            return false;
+        }
+
+        mServiceDiscReqId = mWifiNative.p2pServDiscReq("00:00:00:00:00:00", sb.toString());
+        if (mServiceDiscReqId == null) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Clear service discovery request in wpa_supplicant
+     */
+    private void clearSupplicantServiceRequest() {
+        if (mServiceDiscReqId == null) return;
+
+        mWifiNative.p2pServDiscCancelReq(mServiceDiscReqId);
+        mServiceDiscReqId = null;
+    }
+
+    /* TODO: We could track individual service adds separately and avoid
+     * having to do update all service requests on every new request
+     */
+    private boolean addServiceRequest(Messenger m, WifiP2pServiceRequest req) {
+        clearClientDeadChannels();
+        ClientInfo clientInfo = getClientInfo(m, true);
+        if (clientInfo == null) {
+            return false;
+        }
+
+        ++mServiceTransactionId;
+        //The Wi-Fi p2p spec says transaction id should be non-zero
+        if (mServiceTransactionId == 0) ++mServiceTransactionId;
+        ///M: Google issue, cast from byte to int cause 0xffffff80 bug  @{
+        //req.setTransactionId(mServiceTransactionId);
+        //clientInfo.mReqList.put(mServiceTransactionId, req);
+        int localSevID = mServiceTransactionId & 0x000000ff;
+        req.setTransactionId(localSevID);
+        clientInfo.mReqList.put(localSevID, req);
+        ///@}
+
+        if (mServiceDiscReqId == null) {
+            return true;
+        }
+
+        return updateSupplicantServiceRequest();
+    }
+
+    private void removeServiceRequest(Messenger m, WifiP2pServiceRequest req) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        //Application does not have transaction id information
+        //go through stored requests to remove
+        boolean removed = false;
+        for (int i=0; i<clientInfo.mReqList.size(); i++) {
+            if (req.equals(clientInfo.mReqList.valueAt(i))) {
+                removed = true;
+                clientInfo.mReqList.removeAt(i);
+                break;
+            }
+        }
+
+        if (!removed) return;
+
+        if (clientInfo.mReqList.size() == 0 && clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+
+        if (mServiceDiscReqId == null) {
+            return;
+        }
+
+        updateSupplicantServiceRequest();
+    }
+
+    private void clearServiceRequests(Messenger m) {
+
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        if (clientInfo.mReqList.size() == 0) {
+            return;
+        }
+
+        clientInfo.mReqList.clear();
+
+        if (clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove channel information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+
+        if (mServiceDiscReqId == null) {
+            return;
+        }
+
+        updateSupplicantServiceRequest();
+    }
+
+    private boolean addLocalService(Messenger m, WifiP2pServiceInfo servInfo) {
+        clearClientDeadChannels();
+        ClientInfo clientInfo = getClientInfo(m, true);
+        if (clientInfo == null) {
+            return false;
+        }
+
+        if (!clientInfo.mServList.add(servInfo)) {
+            return false;
+        }
+
+        if (!mWifiNative.p2pServiceAdd(servInfo)) {
+            clientInfo.mServList.remove(servInfo);
+            return false;
+        }
+
+        return true;
+    }
+
+    private void removeLocalService(Messenger m, WifiP2pServiceInfo servInfo) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        mWifiNative.p2pServiceDel(servInfo);
+
+        clientInfo.mServList.remove(servInfo);
+        if (clientInfo.mReqList.size() == 0 && clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+    }
+
+    private void clearLocalServices(Messenger m) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        for (WifiP2pServiceInfo servInfo: clientInfo.mServList) {
+            mWifiNative.p2pServiceDel(servInfo);
+        }
+
+        clientInfo.mServList.clear();
+        if (clientInfo.mReqList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+    }
+
+    private void clearClientInfo(Messenger m) {
+        clearLocalServices(m);
+        clearServiceRequests(m);
+    }
+
+    /**
+     * Send the service response to the WifiP2pManager.Channel.
+     *
+     * @param resp
+     */
+    private void sendServiceResponse(WifiP2pServiceResponse resp) {
+        for (ClientInfo c : mClientInfoList.values()) {
+            WifiP2pServiceRequest req = c.mReqList.get(resp.getTransactionId());
+            if (req != null) {
+                Message msg = Message.obtain();
+                msg.what = WifiP2pManager.RESPONSE_SERVICE;
+                msg.arg1 = 0;
+                msg.arg2 = 0;
+                msg.obj = resp;
+                try {
+                    c.mMessenger.send(msg);
+                } catch (RemoteException e) {
+                    if (DBG) logd("detect dead channel");
+                    clearClientInfo(c.mMessenger);
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * We dont get notifications of clients that have gone away.
+     * We detect this actively when services are added and throw
+     * them away.
+     *
+     * TODO: This can be done better with full async channels.
+     */
+    private void clearClientDeadChannels() {
+        ArrayList<Messenger> deadClients = new ArrayList<Messenger>();
+
+        for (ClientInfo c : mClientInfoList.values()) {
+            Message msg = Message.obtain();
+            msg.what = WifiP2pManager.PING;
+            msg.arg1 = 0;
+            msg.arg2 = 0;
+            msg.obj = null;
+            try {
+                c.mMessenger.send(msg);
+            } catch (RemoteException e) {
+                if (DBG) logd("detect dead channel");
+                deadClients.add(c.mMessenger);
+            }
+        }
+
+        for (Messenger m : deadClients) {
+            clearClientInfo(m);
+        }
+    }
+
+    /**
+     * Return the specified ClientInfo.
+     * @param m Messenger
+     * @param createIfNotExist if true and the specified channel info does not exist,
+     * create new client info.
+     * @return the specified ClientInfo.
+     */
+    private ClientInfo getClientInfo(Messenger m, boolean createIfNotExist) {
+        ClientInfo clientInfo = mClientInfoList.get(m);
+
+        if (clientInfo == null && createIfNotExist) {
+            if (DBG) logd("add a new client");
+            clientInfo = new ClientInfo(m);
+            mClientInfoList.put(m, clientInfo);
+        }
+
+        return clientInfo;
+    }
+
+    ///M:@{
+    /*M: ALPS00677009: broadcast the group removed reason*/
+    private void sendP2pConnectionChangedBroadcast(P2pStatus reason) {
+        if (DBG) logd("sending p2p connection changed broadcast, reason = " + reason +
+            ", mGroup: " + mGroup +
+            ", mP2pOperFreq: " + mP2pOperFreq);
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO, new WifiP2pInfo(mWifiP2pInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP, new WifiP2pGroup(mGroup));
+        intent.putExtra("p2pOperFreq", mP2pOperFreq);
+
+        if (reason == P2pStatus.NO_COMMON_CHANNEL) {
+            intent.putExtra("reason=", 7);
+        } else if (reason == P2pStatus.MTK_EXPAND_02) {
+            if (DBG) logd("channel conflict, user decline, broadcast with reason=-3");
+            intent.putExtra("reason=", -3);
+        } else if (reason == P2pStatus.MTK_EXPAND_01) {
+            if (DBG) logd("[wfd sink/source] broadcast with reason=-2");
+            intent.putExtra("reason=", -2);
+        } else {
+            intent.putExtra("reason=", -1);
+        }
+
+        mGroupRemoveReason = P2pStatus.UNKNOWN;
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        mWifiChannel.sendMessage(WifiP2pServiceImpl.P2P_CONNECTION_CHANGED,
+                new NetworkInfo(mNetworkInfo));
+    }
+
+    //ALPS01212893: for poor link: wifi p2p Tx broadcast
+    private void sendP2pTxBroadcast(boolean bStart) {
+        if (DBG) logd("sending p2p Tx broadcast: " + bStart);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.Tx");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra("start", bStart);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: wfd sink support
+    private void sendP2pGOandGCRequestConnectBroadcast() {
+        if (DBG) logd("sendP2pGOandGCRequestConnectBroadcast");
+        Intent intent = new Intent("com.mediatek.wifi.p2p.GO.GCrequest.connect");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        WifiP2pDevice dev = mPeers.get(mSavedPeerConfig.deviceAddress);
+        if (dev != null && dev.deviceName != null) {
+            intent.putExtra("deviceName", dev.deviceName);
+        } else {
+            intent.putExtra("deviceName", "wifidisplay source");
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: enhance frequency conflict
+    private void sendP2pOPChannelBroadcast() {
+        if (DBG) logd("sendP2pOPChannelBroadcast: OperFreq = " + mP2pOperFreq);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.OP.channel");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        intent.putExtra("p2pOperFreq", mP2pOperFreq);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: frequency conflict notify
+    private void sendP2pFreqConflictBroadcast() {
+        if (DBG) logd("sendP2pFreqConflictBroadcast");
+        Intent intent = new Intent("com.mediatek.wifi.p2p.freq.conflict");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: crossmount wps dialog
+    private void sendP2pCrossmountIntentionBroadcast() {
+        if (DBG) logd("sendP2pCrossmountIntentionBroadcast, session info:" +
+            mCrossmountSessionInfo + ", wps method=" + mSavedPeerConfig.wps.setup);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.crossmount.intention");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        WifiP2pDevice dev = mPeers.get(mSavedPeerConfig.deviceAddress);
+        if (dev != null && dev.deviceName != null) {
+            intent.putExtra("deviceName", dev.deviceName);
+            intent.putExtra("deviceAddress", dev.deviceAddress);
+            intent.putExtra("sessionInfo", mCrossmountSessionInfo);
+        } else {
+            intent.putExtra("deviceName", "crossmount source");
+            intent.putExtra("deviceAddress", "crossmount source");
+            // hex string is "crossmount source"
+            intent.putExtra("sessionInfo", "63726f73736d6f756e7420736f75726365");
+        }
+        intent.putExtra("wpsMethod", Integer.toString(mSavedPeerConfig.wps.setup));
+
+        // sticky broadcast would cause application receive fake connection request
+        // when crossmount switch from off to on
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private WifiP2pDevice p2pGoGetSta(WifiP2pDevice p2pDev, String p2pMAC) {
+        if (p2pMAC == null || p2pDev == null) {
+            loge("gc or gc mac is null");
+            return null;
+        }
+
+        p2pDev.deviceAddress = p2pMAC;
+        String p2pSta = p2pGoGetSta(p2pMAC);
+        if (p2pSta == null)
+            return p2pDev;
+        logd("p2pGoGetSta() return: " + p2pSta);
+
+        String[] tokens = p2pSta.split("\n");
+        for (String token : tokens) {
+            if (token.startsWith("p2p_device_name=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.deviceName = nameValueAssign(nameValue, p2pDev.deviceName);
+            } else if (token.startsWith("p2p_primary_device_type=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.primaryDeviceType = nameValueAssign(nameValue, p2pDev.primaryDeviceType);
+            } else if (token.startsWith("p2p_group_capab=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.groupCapability = nameValueAssign(nameValue, p2pDev.groupCapability);
+            } else if (token.startsWith("p2p_dev_capab=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.deviceCapability = nameValueAssign(nameValue, p2pDev.deviceCapability);
+            }  else if (token.startsWith("p2p_config_methods=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.wpsConfigMethodsSupported =
+                        nameValueAssign(nameValue, p2pDev.wpsConfigMethodsSupported);
+            }
+        } //for
+
+        return p2pDev;
+    }
+
+    private String nameValueAssign(String[] nameValue, String string) {
+        if (nameValue == null || nameValue.length != 2) {
+            return null;
+        } else {
+            return nameValue[1];
+        }
+    }
+
+    private int nameValueAssign(String[] nameValue, int integer) {
+        if (nameValue == null || nameValue.length != 2) {
+            return 0;
+        } else {
+            if (nameValue[1] != null) {
+                return WifiP2pDevice.parseHex(nameValue[1]);
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    private int nameValueAssign(String[] nameValue, int integer, int base) {
+        if (nameValue == null || nameValue.length != 2) {
+            return 0;
+        } else {
+            if (nameValue[1] != null && base != 0) {
+                return Integer.parseInt(nameValue[1], base);
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    private void setWifiOn_WifiAPOff() {
+        if (mWifiManager == null) {
+            mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        }
+
+        int wifiApState = mWifiManager.getWifiApState();
+        if ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
+                (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
+            mWifiManager.setWifiApEnabled(null, false);
+        }
+
+        logd("call WifiManager.stopReconnectAndScan() and WifiManager.setWifiEnabled()");
+        mWifiManager.stopReconnectAndScan(true, 0);
+        mWifiManager.setWifiEnabled(true);
+    }
+
+    /**
+     * Return dynamic information about the current Wi-Fi connection, if any is active.
+     * @return the Wi-Fi information, contained in {@link WifiInfo}.
+     */
+    public WifiInfo getWifiConnectionInfo() {
+        if (mWifiManager == null) {
+            mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        }
+        return mWifiManager.getConnectionInfo();
+    }
+
+    /**
+     * Get interface address if peer provided in the current group
+     */
+    private String getInterfaceAddress(String deviceAddress) {
+        if (DBG) logd("getInterfaceAddress(): deviceAddress=" + deviceAddress);
+        WifiP2pDevice d = mPeers.get(deviceAddress);
+        if (d == null) {
+            // Assume got an interface address.
+            return deviceAddress;
+        } else {
+            if (deviceAddress.equals(d.interfaceAddress)) {
+                // Peer not imlpement interface address mechanism
+                return deviceAddress;
+            }
+            if (DBG) logd("getInterfaceAddress(): interfaceAddress=" + d.interfaceAddress);
+            return d.interfaceAddress;
+        }
+    }
+
+    /* get peer IP address */
+    public String getPeerIpAddress(String inputAddress) {
+        logd("getPeerIpAddress(): input address=" + inputAddress);
+        if (inputAddress == null) {
+            return null;
+        }
+
+        if (mGroup == null) {
+            loge("getPeerIpAddress(): mGroup is null!");
+            return null;
+        }
+
+        //logd("getPeerIpAddress(): mThisDevice.isGroupOwner()=" + mThisDevice.isGroupOwner());
+        if (!mGroup.isGroupOwner()) {
+            // case 01: input parameter is GO device address
+            if (mGroup.getOwner().deviceAddress != null &&
+                inputAddress.equals(mGroup.getOwner().deviceAddress)) {
+                logd("getPeerIpAddress(): GO device address case, goIpAddress=" +
+                    mGroup.getOwner().deviceIP);
+                return mGroup.getOwner().deviceIP;
+
+            // case 02: input parameter is GO interface address
+            } else if (mGroup.getOwner().interfaceAddress != null &&
+                inputAddress.equals(mGroup.getOwner().interfaceAddress)) {
+                logd("getPeerIpAddress(): GO interface address case, goIpAddress=" +
+                    mGroup.getOwner().deviceIP);
+                return mGroup.getOwner().deviceIP;
+
+            } else {
+                loge("getPeerIpAddress(): no match GO address case, goIpAddress is null");
+                return null;
+            }
+        }
+
+        String intrerfaceAddress = getInterfaceAddress(inputAddress);
+
+        /** DHCP_INFO_FILE
+         * Example:
+         *  1393274309 02:08:22:8c:8f:0c 192.168.49.67 android-64e4f3ae3c5378aa *
+         */
+        FileInputStream fileStream = null;
+        try {
+            fileStream =  new FileInputStream(DHCP_INFO_FILE);
+            DataInputStream in = new DataInputStream(fileStream);
+            BufferedReader br = new BufferedReader(new InputStreamReader(in));
+            String str = br.readLine();
+            String lastOneIP = null;
+
+            //logd("getPeerIpAddress(): getClientIp() Read Message = " + str);
+            while ((str != null) && (str.length() != 0)) {
+                //logd("getPeerIpAddress(): getClientIp() read a line ok str = " + str);
+                String[] fields = str.split(" ");
+                //for (String s : fields) {
+                    //logd("getPeerIpAddress(): getClientIp() fields = " + s);
+                //}
+                if (fields.length > 3) {
+                    //logd("getPeerIpAddress(): getClientIp() get IP address = " + fields[2]);
+                    str = fields[2];
+                } else {
+                    str = null;
+                }
+
+                if (str != null && fields[1] != null &&
+                    fields[1].indexOf(intrerfaceAddress) != -1) {
+                    logd("getPeerIpAddress(): getClientIp() mac matched, get IP address = " + str);
+                    return str;
+                } else {
+                    lastOneIP = str;
+                }
+                str = br.readLine();
+            } //while()
+
+            loge("getPeerIpAddress(): getClientIp() dhcp client " + intrerfaceAddress +
+                " had not connected up!");
+            return null;
+
+        } catch (IOException e) {
+            loge("getPeerIpAddress(): getClientIp(): " + e);
+        } finally {
+            if (fileStream != null) {
+                try {
+                    fileStream.close();
+                    //logd("getPeerIpAddress(): getClientIp() close file OK!");
+                } catch (IOException e) {
+                    loge("getPeerIpAddress(): getClientIp() close file met IOException: " + e);
+                }
+            }
+        }
+
+        loge("getPeerIpAddress(): found nothing");
+        return null;
+    }
+
+    public void setCrossMountIE(boolean isAdd, String hexData) {
+        mCrossmountIEAdded = isAdd;
+        setVendorElemIE(isAdd, VENDOR_IE_ALL_FRAME_TAG, hexData);
+    }
+
+    public String getCrossMountIE(String hexData) {
+        // "length field" is 1 byte=2 hex data
+        int indexCrossMountTag =
+            hexData.indexOf(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT);
+        if (indexCrossMountTag < (VENDOR_IE_TAG.length() + 2)) { //+2 means "length field"
+            if (DBG)
+                loge("getCrossMountIE(): bad index: indexCrossMountTag=" + indexCrossMountTag);
+            return "";
+        }
+
+        String strLenIE = hexData.substring(indexCrossMountTag - 2, indexCrossMountTag);
+        if (TextUtils.isEmpty(strLenIE)) {
+            if (DBG) loge("getCrossMountIE(): bad strLenIE: " + strLenIE);
+            return "";
+        }
+        int lenIE = Integer.valueOf(strLenIE, 16);
+        // (1) -4: IE len including "OUI" "OUI_TYPE" field: 4 bytes
+        // (2) *2: IE len are ascii string length, here are hex data
+        lenIE = (lenIE - 4) * 2;
+
+        // "OUI" "OUI_TYPE" field are 4 bytes=8 hex data
+        String hexCrossMountIE = hexData.substring(
+            indexCrossMountTag + 8,
+            indexCrossMountTag + 8 + lenIE);
+
+        if (DBG) loge("getCrossMountIE(): hexCrossMountIE=" + hexCrossMountIE);
+        return hexCrossMountIE;
+    }
+
+    private boolean isGroupRemoved() {
+        boolean removed = true;
+
+        for (WifiP2pDevice d : mPeers.getDeviceList()) {
+            if (!mThisDevice.deviceAddress.equals(d.deviceAddress) &&
+                d.status == WifiP2pDevice.CONNECTED) {
+                removed = false;
+            }
+        }
+        if (DBG) logd("isGroupRemoved(): " + removed);
+        return removed;
+    }
+
+    private void resetWifiP2pConn() {
+        //ALPS01807734: restore state for both Created and Creating case
+        if (mGroup != null) {
+            mWifiNative.p2pGroupRemove(mInterface);
+        } else if (getHandler().hasMessages(GROUP_CREATING_TIMED_OUT)) {
+            //mWifiNative.p2pCancelConnect();
+            sendMessage(WifiP2pManager.CANCEL_CONNECT);
+        }
+    }
+
+    private void p2pConfigWfdSink() {
+        resetWifiP2pConn();
+
+        mWifiNative.setDeviceType("8-0050F204-2");
+        //ALPS01511867: disable DEVICE_CAPAB_INVITATION_PROCEDURE
+        String result = p2pGetDeviceCapa();
+        if (result.startsWith("p2p_dev_capa=")) {
+            String[] nameValue = result.split("=");
+            mDeviceCapa = nameValueAssign(nameValue, mDeviceCapa, 10);
+        } else {
+            mDeviceCapa = -1;
+        }
+        if (DBG) logd("[wfd sink] p2pConfigWfdSink() ori deviceCapa = " + mDeviceCapa);
+
+        if (mDeviceCapa > 0) {
+            String DeviceCapa_local = (Integer.valueOf(mDeviceCapa) & 0xDF) + "";
+            p2pSetDeviceCapa(DeviceCapa_local);
+            if (DBG) logd("[wfd sink] p2pConfigWfdSink() after: " + p2pGetDeviceCapa());
+        }
+    }
+
+    private void p2pUnconfigWfdSink() {
+        resetWifiP2pConn();
+
+        mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
+        if (0 < mDeviceCapa) {
+            p2pSetDeviceCapa(mDeviceCapa + "");
+            if (DBG) logd("[wfd sink] p2pUnconfigWfdSink(): " + p2pGetDeviceCapa());
+        }
+    }
+
+    private boolean isWfdSinkEnabled() {
+        if (!SystemProperties.get("ro.mtk_wfd_sink_support").equals("1")) {
+            if (DBG) logd("[wfd sink] isWfdSinkEnabled, property unset");
+        } else if (mThisDevice.wfdInfo == null) {
+            if (DBG) logd("[wfd sink] isWfdSinkEnabled, device wfdInfo unset");
+        } else if (mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.PRIMARY_SINK &&
+                   mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK) {
+            if (DBG)
+                logd("[wfd sink] isWfdSinkEnabled, type :" + mThisDevice.wfdInfo.getDeviceType());
+        } else {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isWfdSinkConnected() {
+        boolean basicCondition = isWfdSinkEnabled() && (mGroup != null);
+
+        if (!basicCondition) {
+            return false;
+        }
+
+        if (!mGroup.isGroupOwner()) {
+            //wfd sink GC case
+            return true;
+        } else {
+            //wfd sink GO case
+            if (mGroup.getClientAmount() == 1) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isCrossMountGOwithMultiGC() {
+        boolean basicCondition = (mCrossmountIEAdded && (mGroup != null));
+
+        if (!basicCondition) {
+            return false;
+        }
+
+        if (!mGroup.isGroupOwner()) {
+            //GC case
+            return false;
+        } else {
+            //GO case
+            if (mGroup.getClientAmount() > 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isWfdSourceConnected() {
+        if (mThisDevice.wfdInfo == null) {
+            if (DBG) logd("[wfd source] isWfdSourceConnected, device wfdInfo unset");
+        } else if (mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.WFD_SOURCE &&
+                   mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK) {
+            if (DBG)
+                logd("[wfd source] isWfdSourceConnected, type :" +
+                    mThisDevice.wfdInfo.getDeviceType());
+        } else if (isGroupRemoved()) {
+            if (DBG) {
+                  logd("[wfd source] isWfdSourceConnected, GroupRemoved");
+            }
+        } else {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * -set IE for crossmount, format:
+     * Tag number: Vendor Specific, 221=0xdd, 1 byte
+     * Tag length: variable, 1 byte
+     * OUI: 00-0c-e7(Mediatek), 3 bytes
+     * Vendor Specific OUI Type: 0x33, 1 byte  //define via wifi p2p framework, for crossmount
+     * Vendor Specific Data: variable
+     *
+     * @param frameId    99(VENDOR_IE_ALL_FRAME_TAG) means for all frame,
+     *                   frame id list at WifiNative.java
+     */
+    private void setVendorElemIE(boolean isAdd, int frameId, String hexData) {
+        logd("setVendorElemIE(): isAdd=" + isAdd + ", frameId=" + frameId + ", hexData=" + hexData);
+
+        String ieBuf = VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT + hexData;
+        int len = ieBuf.length() / 2;
+        ieBuf = VENDOR_IE_TAG + String.format("%02x", len & 0xFF) + ieBuf;
+
+        if (isAdd) {
+            if (frameId == VENDOR_IE_ALL_FRAME_TAG) {
+                for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                    vendorIEAdd(i, ieBuf);
+                    //logd("dump IE, frame id=" + i + ", hex=" + mWifiNative.vendorIEGet(i));
+                } // for
+            } else {
+                vendorIEAdd(frameId, ieBuf);
+            }
+        } else {
+            if (frameId == VENDOR_IE_ALL_FRAME_TAG) {
+                for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                    vendorIERemove(i, null);
+                } // for
+            } else {
+                vendorIERemove(frameId, null);
+            }
+        }
+    }
+
+    private void updateCrossMountInfo(String peerAddress) {
+        if (DBG) {
+            logd("updateCrossMountInfo(), peerAddress=" + peerAddress);
+        }
+        String peerVendorIE = mWifiNative.p2pGetVendorElems(peerAddress);
+        // reset parameters to fix flow were not going to crossmount connect intention case
+        mCrossmountEventReceived = false;
+
+        if (!TextUtils.isEmpty(peerVendorIE) &&
+                !peerVendorIE.equals(UNKNOWN_COMMAND) &&
+                peerVendorIE.contains(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT)) {
+            mCrossmountEventReceived = true;
+            mCrossmountSessionInfo = getCrossMountIE(peerVendorIE);
+        } else {
+            /**
+             * NOTE:
+             * -(1) For 3rd device receiving P2P-INVITATION-RECEIVED:
+             *        it will trigger 3rd device to do P2P_CONNECT join.
+             * -(2) Then the 1st device(device doing p2p_invite) would receive
+             *        P2P-PROV-DISC-PBC-REQ.
+             * -(3) At this case, 3rd device's PD request won't attached crossmount IE.
+             * -(4) So, it needs check 1st device itself crossmount IE capability!
+             */
+            String myVendorIE = null;
+
+            if (DBG) {
+                logd("updateCrossMountInfo(): check crossmount IE myself!");
+            }
+            for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                myVendorIE = vendorIEGet(i);
+                if (!TextUtils.isEmpty(myVendorIE) &&
+                        !myVendorIE.equals(UNKNOWN_COMMAND) &&
+                        myVendorIE.contains(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT)) {
+                    mCrossmountEventReceived = true;
+                    //Can't attach crossmount IE myself as peer's!
+                    mCrossmountSessionInfo = "";
+                    return;
+                }
+            } // for
+        }
+    }
+
+    private void p2pUpdateScanList(String peerAddress) {
+        if (mThisDevice.deviceAddress.equals(peerAddress)) {
+            return;
+        }
+
+        if (mPeers.get(peerAddress) == null) {
+            String peerInfo = mWifiNative.p2pPeer(peerAddress);
+            if (TextUtils.isEmpty(peerInfo)) {
+                return;
+            }
+            logd("p2pUpdateScanList(): " + peerAddress +
+                "  isn't in framework scan list but existed in supplicant's list");
+
+            WifiP2pDevice device = new WifiP2pDevice();
+            device.deviceAddress = peerAddress;
+            String[] tokens = peerInfo.split("\n");
+            for (String token : tokens) {
+                if (token.startsWith("device_name=")) {
+                    device.deviceName = nameValueAssign(token.split("="), device.deviceName);
+                } else if (token.startsWith("pri_dev_type=")) {
+                    device.primaryDeviceType = nameValueAssign(token.split("="),
+                        device.primaryDeviceType);
+                } else if (token.startsWith("config_methods=")) {
+                    device.wpsConfigMethodsSupported = nameValueAssign(token.split("="),
+                        device.wpsConfigMethodsSupported);
+                } else if (token.startsWith("dev_capab=")) {
+                    device.deviceCapability = nameValueAssign(token.split("="),
+                        device.deviceCapability);
+                } else if (token.startsWith("group_capab=")) {
+                    device.groupCapability = nameValueAssign(token.split("="),
+                        device.groupCapability);
+                }
+            } //for
+            //loge("[debug] p2pUpdateScanList(): device: " + device);
+            mPeers.updateSupplicantDetails(device);
+            //loge("[debug] p2pUpdateScanList(): mPeers: " + mPeers);
+        }
+    }
+
+    private void p2pOverwriteWpsPin(String caller, Object obj) {
+        int pinMethod = 0;
+        String pinCode = null;
+        if (obj != null) {
+            pinMethod = ((Bundle) obj)
+                .getInt(WifiP2pManager.EXTRA_PIN_METHOD);
+            pinCode = ((Bundle) obj)
+                .getString(WifiP2pManager.EXTRA_PIN_CODE);
+            mSavedPeerConfig.wps.setup = pinMethod;
+            mSavedPeerConfig.wps.pin = pinCode;
+
+            if (DBG) {
+                logd("p2pOverwriteWpsPin(): " + caller + ", wps pin code: " + pinCode +
+                        ", pin method: " + pinMethod);
+            }
+        }
+    }
+
+    private void p2pUserAuthPreprocess(Message message) {
+        // follow wifiNative check rule
+        if (message.arg1 >= 0 && message.arg1 <= 15) {
+            mSavedPeerConfig.groupOwnerIntent = (int) message.arg1;
+        }
+        mSavedPeerConfig.netId = WifiP2pGroup.TEMPORARY_NET_ID;
+
+        ///support show PIN passively  @{
+        if (mSavedPeerConfig.wps.setup == WpsInfo.DISPLAY) {
+            if (!mCrossmountEventReceived) {
+                notifyInvitationSent(mSavedPeerConfig.wps.pin, mSavedPeerConfig.deviceAddress);
+            }
+        }
+        ///@}
+    }
+
+    private boolean isAppHandledConnection() {
+        return (isWfdSinkEnabled() || mCrossmountEventReceived);
+    }
+
+    private boolean p2pRemoveClient(String iface, String mac) {
+        String ret =
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + iface + " P2P_REMOVE_CLIENT " + mac);
+        return (!TextUtils.isEmpty(ret) && ret.startsWith("OK"));
+    }
+
+    /* Set the current mode of channel concurrent.
+         *  0 = SCC
+         *  1 = MCC
+         */
+    private String p2pSetCCMode(int ccMode) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_use_mcc=" + ccMode);
+    }
+
+    private String p2pGetDeviceCapa() {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_get_cap p2p_dev_capa");
+    }
+
+    private String p2pSetDeviceCapa(String strDecimal) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_set_cap p2p_dev_capa " +
+                strDecimal);
+    }
+
+    /*M: MTK power saving*/
+    private void setP2pPowerSaveMtk(String iface, int mode) {
+        mWifiNative.doCustomSupplicantCommand("DRIVER p2p_set_power_save " + mode);
+    }
+
+    private void setWfdExtCapability(String hex) {
+        mWifiNative.doCustomSupplicantCommand("WFD_SUBELEM_SET 7 " + hex);
+    }
+
+    private void p2pBeamPlusGO(int reserve) {
+        if (0 == reserve) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_GO_RESERVE_END");
+        } else if (1 == reserve) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_GO_RESERVE_START");
+        }
+    }
+
+    private void p2pBeamPlus(int state) {
+        if (0 == state) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_STOP");
+        } else if (1 == state) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_START");
+        }
+    }
+
+    private void p2pSetBssid(int id, String bssid) {
+        mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " SET_NETWORK " + id + " bssid " + bssid);
+    }
+
+    private String p2pLinkStatics(String interfaceAddress) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER GET_STA_STATISTICS " +
+                interfaceAddress);
+    }
+
+    private String p2pGoGetSta(String deviceAddress) {
+        return mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " " + "STA " + deviceAddress);
+    }
+
+    public void p2pAutoChannel(int enable) {
+        mWifiNative.doCustomSupplicantCommand("enable_channel_selection " + enable);
+    }
+
+    /* Add vendor ID.
+        * Frame id:
+        * 0    Probe Request frame in P2P device discovery
+        * 1    Probe Response frame from P2P Device rol
+        * 2    Probe Response frame from P2P GO
+        * 3    Beacon frame from P2P GO
+        * 4    PD Req
+        * 5    PD Resp
+        * 6    GO Neg Req
+        * 7    GO Neg Resp
+        * 8    GO Neg Conf
+        * 9    Invitation Request
+        * 10   Invitation Response
+        * 11   P2P Association Request
+        * 12   P2P Association Response
+        * 13   VENDOR_ELEM_ASSOC_REQ
+        */
+    //set FrameID with IE
+    private void vendorIEAdd(int frameId, String hex) {
+        mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " VENDOR_ELEM_ADD " + frameId + " " + hex);
+    }
+
+    //get vendor IE with FrameID
+    private String vendorIEGet(int frameId) {
+        return mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " VENDOR_ELEM_GET " + frameId);
+    }
+
+    //remove all/specific vendor IE with FrameID
+    private void vendorIERemove(int frameId, String hex) {
+        if (hex == null) {
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                    " VENDOR_ELEM_REMOVE " + frameId + " *");
+        } else {
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                    " VENDOR_ELEM_REMOVE " + frameId + " " + hex);
+        }
+    }
+
+    private WifiP2pGroup addPersistentGroup(HashMap<String, String> variables) {
+        if (DBG) {
+            logd("addPersistentGroup");
+        }
+        int netId = mWifiNative.addNetwork();
+        for (String key : variables.keySet()) {
+            if (DBG) {
+                logd("addPersistentGroup variable=" + key + " : " + variables.get(key));
+            }
+            mWifiNative.setNetworkVariable(netId, key, variables.get(key));
+        }
+        updatePersistentNetworks(true);
+        Collection<WifiP2pGroup> groups = mGroups.getGroupList();
+        for (WifiP2pGroup group : groups) {
+            if (netId == group.getNetworkId()) {
+                return group;
+            }
+        }
+        if (DBG) {
+            logd("addPersistentGroup failed.");
+        }
+        return null;
+    }
+
+    public void setBeamMode(int mode) {
+        if (DBG) {
+            logd("setBeamMode mode=" + mode);
+        }
+        switch (mode) {
+            case WifiP2pManager.BEAM_MODE_ENABLE:
+                p2pBeamPlus(1);
+                mGcIgnoresDhcpReq = true;
+                break;
+            case WifiP2pManager.BEAM_GO_MODE_ENABLE:
+                p2pBeamPlusGO(1);
+                break;
+            case WifiP2pManager.BEAM_MODE_DISABLE:
+                p2pBeamPlus(0);
+                mGcIgnoresDhcpReq = false;
+                break;
+            case WifiP2pManager.BEAM_GO_MODE_DISABLE:
+                p2pBeamPlusGO(0);
+                break;
+            default:
+                break;
+        }
+    }
+    } // end of class P2pStateMachine
+    ///@}
+
+    /**
+     * Information about a particular client and we track the service discovery requests
+     * and the local services registered by the client.
+     */
+    private class ClientInfo {
+
+        /*
+         * A reference to WifiP2pManager.Channel handler.
+         * The response of this request is notified to WifiP2pManager.Channel handler
+         */
+        private Messenger mMessenger;
+
+        /*
+         * A service discovery request list.
+         */
+        private SparseArray<WifiP2pServiceRequest> mReqList;
+
+        /*
+         * A local service information list.
+         */
+        private List<WifiP2pServiceInfo> mServList;
+
+        private ClientInfo(Messenger m) {
+            mMessenger = m;
+            mReqList = new SparseArray();
+            mServList = new ArrayList<WifiP2pServiceInfo>();
+        }
+    }
+
+    ///M: ALPS02475909: only 32 - 9  bytes is allowed for SSID postfix@{
+    // Calculate byte length for the UTF-8 string
+    private String getSsidPostfix(String deviceName) {
+        int utfCount = 0;
+        int strLen = 0;
+        // Default is UTF-8
+        byte[] bChar = deviceName.getBytes();
+
+        if (TextUtils.isEmpty(deviceName)) {
+            return deviceName;
+        } else if (bChar.length <= 22) {
+            return deviceName;
+        }
+
+        for (int i = 0 ; i <= deviceName.length() ; i++) {
+            // utfCount indicates the first byte of the next char
+            byte b0 = bChar[utfCount];
+            Log.d(TAG, "b0=" + b0 + ", i=" + i + ", utfCount=" + utfCount);
+            // To calculate the memory length of the next char
+            if ((b0 & 0x80) == 0) {
+                // ASCII encoding
+                // Range:  U-00000000 - U-0000007F
+                utfCount += 1;
+            } else {
+                // UTF8 encoding
+                if (b0 >= (byte) 0xFC && b0 <= (byte) 0xFD) {
+                    utfCount += 6;
+                } else if (b0 >= (byte) 0xF8) {
+                    utfCount += 5;
+                } else if (b0 >= (byte) 0xF0) {
+                    utfCount += 4;
+                } else if (b0 >= (byte) 0xE0) {
+                    utfCount += 3;
+                } else if (b0 >= (byte) 0xC0) {
+                    utfCount += 2;
+                }
+            }
+            // Memory length over 22 bytes with the next char (postfix limitation)
+            if (utfCount > 22) {
+                strLen = i;
+                Log.d(TAG, "break: utfCount=" + utfCount + ", strLen=" + strLen);
+                break;
+            }
+        }
+
+        return deviceName.substring(0, strLen);
+    }
+    ///@}
+}

Property changes on: vendor/branch/5058Y_ALIE/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_ALIE/kernel-4.4/drivers/usb/gadget/android.c
===================================================================
--- vendor/branch/5058Y_ALIE/kernel-4.4/drivers/usb/gadget/android.c	(revision 0)
+++ vendor/branch/5058Y_ALIE/kernel-4.4/drivers/usb/gadget/android.c	(revision 12585)
@@ -0,0 +1,2944 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *         Benoit Goby <benoit@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+/* Add for HW/SW connect */
+#include "mtk_gadget.h"
+/* Add for HW/SW connect */
+
+#include "u_fs.h"
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include "f_hid.c"
+#endif
+#ifdef CONFIG_SND_RAWMIDI
+#include "f_midi.c"
+#endif
+
+
+#include "f_accessory.c"
+#include "f_mass_storage.h"
+#include "f_mtp.c"
+#include "f_eem.c"
+#include "f_rndis.c"
+/* note ERROR macro both appear on cdev & u_ether, make sure what you want */
+#include "rndis.c"
+#include "u_ether.c"
+
+#include "mbim_ether.c"
+#include "f_mbim.c"
+
+USB_ETHERNET_MODULE_PARAMETERS();
+
+#ifdef CONFIG_MTK_ECCCI_C2K
+#include "viatel_rawbulk.h"
+#endif
+
+#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
+#include <mt-plat/mtk_usb2jtag.h>
+#endif
+
+MODULE_AUTHOR("Mike Lockwood");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+/* Default vendor and product IDs, overridden by userspace */
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include <mt-plat/mtk_boot_common.h>
+#define KPOC_USB_FUNC "hid"
+#define KPOC_USB_VENDOR_ID 0x0E8D
+#define KPOC_USB_PRODUCT_ID 0x20FF
+#endif
+
+#ifdef CONFIG_SND_RAWMIDI
+/* f_midi configuration */
+#define MIDI_INPUT_PORTS    1
+#define MIDI_OUTPUT_PORTS   1
+#define MIDI_BUFFER_SIZE    1024
+#define MIDI_QUEUE_LENGTH   32
+#endif
+#ifdef CONFIG_MTPROF
+#include "bootprof.h"
+#endif
+
+struct android_usb_function {
+	char *name;
+	void *config;
+
+	struct device *dev;
+	char *dev_name;
+	struct device_attribute **attributes;
+
+	/* for android_dev.enabled_functions */
+	struct list_head enabled_list;
+
+	/* Optional: initialization during gadget bind */
+	int (*init)(struct android_usb_function *, struct usb_composite_dev *);
+	/* Optional: cleanup during gadget unbind */
+	void (*cleanup)(struct android_usb_function *);
+	/* Optional: called when the function is added the list of
+	 *		enabled functions
+	 */
+	void (*enable)(struct android_usb_function *);
+	/* Optional: called when it is removed */
+	void (*disable)(struct android_usb_function *);
+
+	int (*bind_config)(struct android_usb_function *,
+			   struct usb_configuration *);
+
+	/* Optional: called when the configuration is removed */
+	void (*unbind_config)(struct android_usb_function *,
+			      struct usb_configuration *);
+	/* Optional: handle ctrl requests before the device is configured */
+	int (*ctrlrequest)(struct android_usb_function *,
+					struct usb_composite_dev *,
+					const struct usb_ctrlrequest *);
+};
+
+struct android_dev {
+	struct android_usb_function **functions;
+	struct list_head enabled_functions;
+	struct usb_composite_dev *cdev;
+	struct device *dev;
+
+	void (*setup_complete)(struct usb_ep *ep,
+				struct usb_request *req);
+
+	bool enabled;
+	int disable_depth;
+	struct mutex mutex;
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	char ffs_aliases[256];
+};
+
+static struct class *android_class;
+static struct android_dev *_android_dev;
+static int android_bind_config(struct usb_configuration *c);
+static void android_unbind_config(struct usb_configuration *c);
+static int android_setup_config(struct usb_configuration *c, const struct usb_ctrlrequest *ctrl);
+
+/* string IDs are assigned dynamically */
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+static char manufacturer_string[256];
+static char product_string[256];
+static char serial_string[256];
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = manufacturer_string,
+	[STRING_PRODUCT_IDX].s = product_string,
+	[STRING_SERIAL_IDX].s = serial_string,
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+#ifdef CONFIG_USB_MU3D_DRV
+	.bcdUSB               = cpu_to_le16(0x0300),
+#else
+	.bcdUSB               = cpu_to_le16(0x0200),
+#endif
+	.bDeviceClass         = USB_CLASS_PER_INTERFACE,
+	.idVendor             = cpu_to_le16(VENDOR_ID),
+	.idProduct            = cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = cpu_to_le16(0xffff),
+	.bNumConfigurations   = 1,
+};
+
+static struct usb_configuration android_config_driver = {
+	.label		= "android",
+	.setup		= android_setup_config,
+	.unbind		= android_unbind_config,
+	.bConfigurationValue = 1,
+#ifdef CONFIG_USBIF_COMPLIANCE
+	.bmAttributes	= USB_CONFIG_ATT_ONE,
+#else
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+#endif
+#ifdef CONFIG_USB_MU3D_DRV
+	.MaxPower	= 192, /* Only consume 192ma for passing USB30CV Descriptor Test [USB3.0 devices]*/
+#else
+	.MaxPower	= 500, /* 500ma */
+#endif
+};
+
+static void android_work(struct work_struct *data)
+{
+	struct android_dev *dev = container_of(data, struct android_dev, work);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
+	/* Add for HW/SW connect */
+	char *hwdisconnected[2] = { "USB_STATE=HWDISCONNECTED", NULL };
+	bool is_hwconnected = true;
+	char **uevent_envp = NULL;
+	unsigned long flags;
+
+	if (!cdev) {
+		pr_notice("android_work, !cdev\n");
+		return;
+	}
+
+	/* be aware this could not be used in non-sleep context */
+	if (usb_cable_connected())
+		is_hwconnected = true;
+	else
+		is_hwconnected = false;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		uevent_envp = configured;
+	else if (dev->connected != dev->sw_connected)
+		uevent_envp = dev->connected ? connected : disconnected;
+	dev->sw_connected = dev->connected;
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (uevent_envp) {
+		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, uevent_envp);
+		pr_notice("%s: sent uevent %s, is_hwconnected=%d\n", __func__, uevent_envp[0], is_hwconnected);
+#ifdef CONFIG_MTPROF
+		if (uevent_envp == configured) {
+			static int first_shot = 1;
+
+			if (first_shot) {
+				log_boot("USB configured");
+				first_shot = 0;
+			}
+		}
+#endif
+	} else {
+		pr_notice("%s: did not send uevent (%d %d %p), is_hwconnected=%d\n", __func__,
+			 dev->connected, dev->sw_connected, cdev->config, is_hwconnected);
+	}
+
+	if (!is_hwconnected) {
+		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, hwdisconnected);
+		pr_notice("[USB]%s: sent uevent %s\n", __func__, hwdisconnected[0]);
+	}
+}
+
+static void android_enable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+
+	if (WARN_ON(!dev->disable_depth))
+		return;
+
+	if (--dev->disable_depth == 0) {
+		usb_add_config(cdev, &android_config_driver,
+					android_bind_config);
+		usb_gadget_connect(cdev->gadget);
+	}
+}
+
+static void android_disable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+
+	if (dev->disable_depth++ == 0) {
+		usb_gadget_disconnect(cdev->gadget);
+		/* Cancel pending control requests */
+		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+		usb_remove_config(cdev, &android_config_driver);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+/* Supported functions initialization */
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+static int hid_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	return ghid_setup(cdev->gadget, 2);
+}
+static int hid_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return hidg_bind_config(c, NULL, 0);
+}
+static void hid_function_cleanup(struct android_usb_function *f)
+{
+	ghid_cleanup();
+}
+static struct android_usb_function hid_function = {
+	.name		= "hid",
+	.init		= hid_function_init,
+	.cleanup	= hid_function_cleanup,
+	.bind_config	= hid_function_bind_config,
+};
+#endif
+
+struct functionfs_config {
+	bool opened;
+	bool enabled;
+	struct usb_function *func;
+	struct usb_function_instance *fi;
+	struct ffs_data *data;
+};
+
+static int functionfs_ready_callback(struct ffs_data *ffs);
+static void functionfs_closed_callback(struct ffs_data *ffs);
+
+static int ffs_function_init(struct android_usb_function *f,
+			     struct usb_composite_dev *cdev)
+{
+	struct functionfs_config *config;
+	struct f_fs_opts *opts;
+
+	f->config = kzalloc(sizeof(struct functionfs_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	config = f->config;
+	config->fi = usb_get_function_instance("ffs");
+	if (IS_ERR(config->fi))
+		return PTR_ERR(config->fi);
+
+	opts = to_f_fs_opts(config->fi);
+	opts->dev->ffs_ready_callback = functionfs_ready_callback;
+	opts->dev->ffs_closed_callback = functionfs_closed_callback;
+	opts->no_configfs = true;
+
+	return ffs_single_dev(opts->dev);
+}
+
+static void ffs_function_cleanup(struct android_usb_function *f)
+{
+	struct functionfs_config *config = f->config;
+
+
+	if (config)
+		usb_put_function_instance(config->fi);
+
+	kfree(f->config);
+}
+
+static void ffs_function_enable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+
+	config->enabled = true;
+
+	/* Disable the gadget until the function is ready */
+	if (!config->opened)
+		android_disable(dev);
+}
+
+static void ffs_function_disable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+
+	config->enabled = false;
+
+	/* Balance the disable that was called in closed_callback */
+	if (!config->opened)
+		android_enable(dev);
+}
+
+static int ffs_function_bind_config(struct android_usb_function *f,
+				    struct usb_configuration *c)
+{
+	struct functionfs_config *config = f->config;
+	int ret;
+
+	config->func = usb_get_function(config->fi);
+	if (IS_ERR(config->func))
+		return PTR_ERR(config->func);
+
+	ret = usb_add_function(c, config->func);
+	if (ret) {
+		pr_err("%s(): usb_add_function() fails (err:%d) for ffs\n",
+							__func__, ret);
+
+		usb_put_function(config->func);
+		config->func = NULL;
+	}
+
+	return ret;
+}
+
+static ssize_t
+ffs_aliases_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	mutex_lock(&dev->mutex);
+	ret = sprintf(buf, "%s\n", dev->ffs_aliases);
+	mutex_unlock(&dev->mutex);
+
+	return ret;
+}
+
+static ssize_t
+ffs_aliases_store(struct device *pdev, struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct android_dev *dev = _android_dev;
+	char buff[256];
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	strlcpy(buff, buf, sizeof(buff));
+	strlcpy(dev->ffs_aliases, strim(buff), sizeof(dev->ffs_aliases));
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static DEVICE_ATTR(aliases, S_IRUGO | S_IWUSR, ffs_aliases_show,
+					       ffs_aliases_store);
+static struct device_attribute *ffs_function_attributes[] = {
+	&dev_attr_aliases,
+	NULL
+};
+
+static struct android_usb_function ffs_function = {
+	.name		= "ffs",
+	.init		= ffs_function_init,
+	.enable		= ffs_function_enable,
+	.disable	= ffs_function_disable,
+	.cleanup	= ffs_function_cleanup,
+	.bind_config	= ffs_function_bind_config,
+	.attributes	= ffs_function_attributes,
+};
+
+static int functionfs_ready_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+	int ret = 0;
+
+	mutex_lock(&dev->mutex);
+
+	config->data = ffs;
+	config->opened = true;
+
+	if (config->enabled)
+		android_enable(dev);
+
+	mutex_unlock(&dev->mutex);
+	return ret;
+}
+
+static void functionfs_closed_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+
+	mutex_lock(&dev->mutex);
+
+	if (config->enabled)
+		android_disable(dev);
+
+	config->opened = false;
+	config->data = NULL;
+
+	if (config->func) {
+		usb_put_function(config->func);
+		config->func = NULL;
+	}
+
+	mutex_unlock(&dev->mutex);
+}
+
+/* note all serial port number could not exceed MAX_U_SERIAL_PORTS */
+#define MAX_ACM_INSTANCES 4
+struct acm_function_config {
+	int instances;
+	int instances_on;
+	struct usb_function *f_acm[MAX_ACM_INSTANCES];
+	struct usb_function_instance *f_acm_inst[MAX_ACM_INSTANCES];
+	int port_index[MAX_ACM_INSTANCES];
+	int port_index_on[MAX_ACM_INSTANCES];
+};
+
+static int
+acm_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct acm_function_config *config;
+
+	config = kzalloc(sizeof(struct acm_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		config->f_acm_inst[i] = usb_get_function_instance("acm");
+		if (IS_ERR(config->f_acm_inst[i])) {
+			ret = PTR_ERR(config->f_acm_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_acm[i] = usb_get_function(config->f_acm_inst[i]);
+		if (IS_ERR(config->f_acm[i])) {
+			ret = PTR_ERR(config->f_acm[i]);
+			goto err_usb_get_function;
+		}
+	}
+	return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_acm[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_acm_inst[i]);
+	}
+	return ret;
+}
+
+static void acm_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct acm_function_config *config = f->config;
+
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		usb_put_function(config->f_acm[i]);
+		usb_put_function_instance(config->f_acm_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+acm_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int i;
+	int ret = 0;
+	struct acm_function_config *config = f->config;
+	/*1st:Modem, 2nd:Modem, 3rd:BT, 4th:MD logger*/
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		if (config->port_index[i] != 0) {
+			ret = usb_add_function(c, config->f_acm[i]);
+			if (ret) {
+				pr_err("Could not bind acm%u config\n", i);
+				goto err_usb_add_function;
+			}
+			pr_notice("%s Open /dev/ttyGS%d\n", __func__, i);
+			config->port_index[i] = 0;
+			config->port_index_on[i] = 1;
+			config->instances = 0;
+		}
+	}
+
+
+	config->instances_on = config->instances;
+	for (i = 0; i < config->instances_on; i++) {
+		ret = usb_add_function(c, config->f_acm[i]);
+		if (ret) {
+			pr_err("Could not bind acm%u config\n", i);
+			goto err_usb_add_function;
+		}
+	}
+
+	return 0;
+
+err_usb_add_function:
+	while (i-- > 0)
+		usb_remove_function(c, config->f_acm[i]);
+	return ret;
+}
+
+static void acm_function_unbind_config(struct android_usb_function *f,
+				       struct usb_configuration *c)
+{
+	struct acm_function_config *config = f->config;
+
+	config->instances_on = 0;
+}
+
+static ssize_t acm_instances_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->instances);
+}
+
+static ssize_t acm_instances_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	int value, ret;
+
+
+	ret = kstrtoint(buf, 0, &value);
+	if (value > MAX_ACM_INSTANCES)
+		value = MAX_ACM_INSTANCES;
+	config->instances = value;
+	return size;
+}
+
+static DEVICE_ATTR(instances, S_IRUGO | S_IWUSR, acm_instances_show,
+						 acm_instances_store);
+
+static ssize_t acm_port_index_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	return sprintf(buf, "%d,%d,%d,%d\n", config->port_index[0], config->port_index[1],
+		config->port_index[2], config->port_index[3]);
+}
+
+static ssize_t acm_port_index_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+	int val[MAX_ACM_INSTANCES] = {0};
+	int num = 0;
+	int tmp = 0;
+
+	num = sscanf(buf, "%d,%d,%d,%d", &(val[0]), &(val[1]), &(val[2]), &(val[3]));
+
+	pr_notice("%s [0]=%d,[1]=%d,[2]=%d,[3]=%d, num=%d\n", __func__, val[0], val[1], val[2], val[3], num);
+
+	/* Set all port_index as 0*/
+	for (tmp = 0; tmp < MAX_ACM_INSTANCES; tmp++)
+		config->port_index[tmp] = 0;
+
+	for (tmp = 0; tmp < num; tmp++) {
+		int port = (val[tmp] > MAX_ACM_INSTANCES || val[tmp] < 1) ? 0 : val[tmp]-1;
+
+		config->port_index[port] = 1;
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(port_index, S_IRUGO | S_IWUSR, acm_port_index_show,
+						 acm_port_index_store);
+
+static struct device_attribute *acm_function_attributes[] = {
+	&dev_attr_instances,
+	&dev_attr_port_index, /*Only open the specific port*/
+	NULL
+};
+
+static struct android_usb_function acm_function = {
+	.name		= "acm",
+	.init		= acm_function_init,
+	.cleanup	= acm_function_cleanup,
+	.bind_config	= acm_function_bind_config,
+	.unbind_config	= acm_function_unbind_config,
+	.attributes	= acm_function_attributes,
+};
+
+#ifdef CONFIG_USB_F_SS_LB
+#define MAX_LOOPBACK_INSTANCES 1
+
+struct loopback_function_config {
+	int port_num;
+	struct usb_function *f_lp[MAX_LOOPBACK_INSTANCES];
+	struct usb_function_instance *f_lp_inst[MAX_LOOPBACK_INSTANCES];
+};
+
+static int loopback_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct loopback_function_config *config;
+
+
+	config = kzalloc(sizeof(struct loopback_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_LOOPBACK_INSTANCES; i++) {
+		config->f_lp_inst[i] = usb_get_function_instance("Loopback");
+		if (IS_ERR(config->f_lp_inst[i])) {
+			ret = PTR_ERR(config->f_lp_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_lp[i] = usb_get_function(config->f_lp_inst[i]);
+		if (IS_ERR(config->f_lp[i])) {
+			ret = PTR_ERR(config->f_lp[i]);
+			goto err_usb_get_function;
+		}
+	}
+	return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_lp[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_lp_inst[i]);
+	}
+	return ret;
+}
+
+static void loopback_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct loopback_function_config *config = f->config;
+
+
+	for (i = 0; i < MAX_LOOPBACK_INSTANCES; i++) {
+		usb_put_function(config->f_lp[i]);
+		usb_put_function_instance(config->f_lp_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+loopback_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+{
+	int ret = 0;
+	struct loopback_function_config *config = f->config;
+
+
+	ret = usb_add_function(c, config->f_lp[config->port_num]);
+	if (ret) {
+		pr_err("Could not bind loopback%u config\n", config->port_num);
+		goto err_usb_add_function;
+	}
+	pr_notice("%s Open loopback\n", __func__);
+
+	return 0;
+
+err_usb_add_function:
+	usb_remove_function(c, config->f_lp[config->port_num]);
+	return ret;
+}
+
+static struct android_usb_function loopback_function = {
+	.name		= "loopback",
+	.init		= loopback_function_init,
+	.cleanup	= loopback_function_cleanup,
+	.bind_config	= loopback_function_bind_config,
+};
+#endif
+
+/* note all serial port number could not exceed MAX_U_SERIAL_PORTS */
+#define MAX_SERIAL_INSTANCES 4
+
+struct serial_function_config {
+	int port_num;
+	struct usb_function *f_ser[MAX_SERIAL_INSTANCES];
+	struct usb_function_instance *f_ser_inst[MAX_SERIAL_INSTANCES];
+};
+
+static int serial_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct serial_function_config *config;
+
+	config = kzalloc(sizeof(struct serial_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_SERIAL_INSTANCES; i++) {
+		config->f_ser_inst[i] = usb_get_function_instance("gser");
+		if (IS_ERR(config->f_ser_inst[i])) {
+			ret = PTR_ERR(config->f_ser_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_ser[i] = usb_get_function(config->f_ser_inst[i]);
+		if (IS_ERR(config->f_ser[i])) {
+			ret = PTR_ERR(config->f_ser[i]);
+			goto err_usb_get_function;
+		}
+	}
+		return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_ser[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_ser_inst[i]);
+	}
+	return ret;
+}
+
+static void serial_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct serial_function_config *config = f->config;
+
+	for (i = 0; i < MAX_SERIAL_INSTANCES; i++) {
+		usb_put_function(config->f_ser[i]);
+		usb_put_function_instance(config->f_ser_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+serial_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+{
+	int ret = 0;
+	struct serial_function_config *config = f->config;
+
+	ret = usb_add_function(c, config->f_ser[config->port_num]);
+	if (ret) {
+		pr_err("Could not bind ser%u config\n", config->port_num);
+		goto err_usb_add_function;
+	}
+	pr_notice("%s Open /dev/ttyGS%d\n", __func__, config->port_num);
+
+	return 0;
+
+err_usb_add_function:
+	usb_remove_function(c, config->f_ser[config->port_num]);
+	return ret;
+}
+
+static ssize_t serial_port_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct serial_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->port_num);
+}
+
+static ssize_t serial_port_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct serial_function_config *config = f->config;
+	int ret;
+	u32 value;
+
+	ret = kstrtou32(buf, 10, &value);
+	if (ret) {
+		pr_notice("serial_port_store err, ret:%d\n", ret);
+		return size;
+	}
+	if (value > MAX_SERIAL_INSTANCES)
+		value = MAX_SERIAL_INSTANCES;
+	config->port_num = value;
+	return size;
+}
+
+static DEVICE_ATTR(port, S_IRUGO | S_IWUSR, serial_port_show, serial_port_store);
+static struct device_attribute *serial_function_attributes[] = { &dev_attr_port, NULL };
+
+static struct android_usb_function serial_function = {
+	.name		= "gser",
+	.init		= serial_function_init,
+	.cleanup	= serial_function_cleanup,
+	.bind_config	= serial_function_bind_config,
+	.attributes	= serial_function_attributes,
+};
+
+
+static int
+mtp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	return mtp_setup();
+}
+
+static void mtp_function_cleanup(struct android_usb_function *f)
+{
+	mtp_cleanup();
+}
+
+static int
+mtp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, false);
+}
+
+static int
+ptp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	/* nothing to do - initialization is handled by mtp_function_init */
+	return 0;
+}
+
+static void ptp_function_cleanup(struct android_usb_function *f)
+{
+	/* nothing to do - cleanup is handled by mtp_function_cleanup */
+}
+
+static int
+ptp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, true);
+}
+
+static int mtp_function_ctrlrequest(struct android_usb_function *f,
+					struct usb_composite_dev *cdev,
+					const struct usb_ctrlrequest *c)
+{
+	return mtp_ctrlrequest(cdev, c);
+}
+
+static int cpumask_to_int(const struct cpumask *cpu_mask)
+{
+	int mask = 0;
+	int cpu;
+
+	for_each_cpu(cpu, cpu_mask) {
+		pr_debug("[USB]%d\n", cpu);
+		mask |= (1 << cpu);
+	}
+
+	return mask;
+}
+
+static ssize_t cpu_mask_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cpumask *cpu_mask = mtp_get_cpu_mask();
+
+	return sprintf(buf, "0x%X\n", (cpu_mask?cpumask_to_int(cpu_mask):0xFFFFFFFF));
+}
+
+static ssize_t cpu_mask_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	unsigned int mask;
+
+	if (kstrtouint(buf, 16, &mask) != 0)
+		return -EINVAL;
+
+	pr_info("Store => 0x%x\n", mask);
+
+	mtp_set_cpu_mask(mask);
+
+	return size;
+}
+
+static DEVICE_ATTR(cpu_mask, S_IRUGO | S_IWUSR, cpu_mask_show,
+					       cpu_mask_store);
+
+static ssize_t mtp_server_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", mtp_get_mtp_server());
+}
+
+static DEVICE_ATTR(mtp_server, S_IRUGO, mtp_server_show,
+					       NULL);
+
+static struct device_attribute *mtp_function_attributes[] = {
+	&dev_attr_cpu_mask,
+	&dev_attr_mtp_server,
+	NULL
+};
+
+static struct android_usb_function mtp_function = {
+	.name		= "mtp",
+	.init		= mtp_function_init,
+	.cleanup	= mtp_function_cleanup,
+	.bind_config	= mtp_function_bind_config,
+	.ctrlrequest	= mtp_function_ctrlrequest,
+	.attributes	= mtp_function_attributes,
+};
+
+/* PTP function is same as MTP with slightly different interface descriptor */
+static struct android_usb_function ptp_function = {
+	.name		= "ptp",
+	.init		= ptp_function_init,
+	.cleanup	= ptp_function_cleanup,
+	.bind_config	= ptp_function_bind_config,
+	.ctrlrequest	= mtp_function_ctrlrequest,
+};
+struct eem_function_config {
+	u8      ethaddr[ETH_ALEN];
+	char	manufacturer[256];
+	struct eth_dev *dev;
+};
+
+static int
+eem_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct eem_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+	return 0;
+}
+
+static void eem_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+eem_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int ret;
+	struct eth_dev *dev;
+	struct eem_function_config *eem = f->config;
+
+
+	pr_notice("[USB]%s:\n", __func__);
+
+	if (!eem) {
+		pr_err("%s: rndis_pdata\n", __func__);
+		return -1;
+	}
+
+	pr_notice("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
+		eem->ethaddr[0], eem->ethaddr[1], eem->ethaddr[2],
+		eem->ethaddr[3], eem->ethaddr[4], eem->ethaddr[5]);
+
+	dev = gether_setup_name(c->cdev->gadget, dev_addr, host_addr,
+			eem->ethaddr, qmult, "rndis");
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: gether_setup failed\n", __func__);
+		return ret;
+	}
+	eem->dev = dev;
+
+	return eem_bind_config(c, eem->dev);
+}
+
+static void eem_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct eem_function_config *eem = f->config;
+
+
+	gether_cleanup(eem->dev);
+}
+
+static ssize_t eem_ethaddr_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct eem_function_config *eem = f->config;
+
+
+	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		eem->ethaddr[0], eem->ethaddr[1], eem->ethaddr[2],
+		eem->ethaddr[3], eem->ethaddr[4], eem->ethaddr[5]);
+}
+
+static ssize_t eem_ethaddr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct eem_function_config *eem = f->config;
+
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    (int *)&eem->ethaddr[0], (int *)&eem->ethaddr[1],
+		    (int *)&eem->ethaddr[2], (int *)&eem->ethaddr[3],
+		    (int *)&eem->ethaddr[4], (int *)&eem->ethaddr[5]) == 6)
+		return size;
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(eem_ethaddr, S_IRUGO | S_IWUSR, eem_ethaddr_show,
+					       eem_ethaddr_store);
+
+static struct device_attribute *eem_function_attributes[] = {
+	&dev_attr_eem_ethaddr,
+	NULL
+};
+
+static struct android_usb_function eem_function = {
+	.name		= "eem",
+	.init		= eem_function_init,
+	.cleanup	= eem_function_cleanup,
+	.bind_config	= eem_function_bind_config,
+	.unbind_config	= eem_function_unbind_config,
+	.attributes	= eem_function_attributes,
+};
+
+struct rndis_function_config {
+	u8      ethaddr[ETH_ALEN];
+	u32     vendorID;
+	char	manufacturer[256];
+	/* "Wireless" RNDIS; auto-detected by Windows */
+	bool	wceis;
+	struct eth_dev *dev;
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+	bool	direct_feature_on;
+	u8      direct_value;
+#endif
+};
+
+static int
+rndis_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+	return 0;
+}
+
+static void rndis_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+rndis_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int ret;
+	struct eth_dev *dev;
+	struct rndis_function_config *rndis = f->config;
+
+	if (!rndis) {
+		pr_err("%s: rndis_pdata\n", __func__);
+		return -1;
+	}
+
+	pr_notice("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+
+	dev = gether_setup_name(c->cdev->gadget, dev_addr, host_addr,
+			rndis->ethaddr, qmult, "rndis");
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: gether_setup failed\n", __func__);
+		return ret;
+	}
+	rndis->dev = dev;
+
+	if (rndis->wceis) {
+		/* "Wireless" RNDIS; auto-detected by Windows */
+		rndis_iad_descriptor.bFunctionClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_iad_descriptor.bFunctionSubClass = 0x01;
+		rndis_iad_descriptor.bFunctionProtocol = 0x03;
+		rndis_control_intf.bInterfaceClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_control_intf.bInterfaceSubClass =	 0x01;
+		rndis_control_intf.bInterfaceProtocol =	 0x03;
+	}
+
+	return rndis_bind_config_vendor(c, rndis->ethaddr,
+				rndis->vendorID, rndis->manufacturer, rndis->dev);
+}
+
+static void rndis_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct rndis_function_config *rndis = f->config;
+
+
+	gether_cleanup(rndis->dev);
+}
+
+static ssize_t rndis_manufacturer_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	return sprintf(buf, "%s\n", config->manufacturer);
+}
+
+static ssize_t rndis_manufacturer_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	if (size >= sizeof(config->manufacturer))
+		return -EINVAL;
+	if (sscanf(buf, "%s", config->manufacturer) == 1)
+		return size;
+	return -1;
+}
+
+static DEVICE_ATTR(manufacturer, S_IRUGO | S_IWUSR, rndis_manufacturer_show,
+						    rndis_manufacturer_store);
+
+static ssize_t rndis_wceis_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	return sprintf(buf, "%d\n", config->wceis);
+}
+
+static ssize_t rndis_wceis_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+
+	if (kstrtoint(buf, 0, &value) == 0) {
+		config->wceis = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(wceis, S_IRUGO | S_IWUSR, rndis_wceis_show,
+					     rndis_wceis_store);
+
+static ssize_t rndis_ethaddr_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+
+
+	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+}
+
+static ssize_t rndis_ethaddr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    (int *)&rndis->ethaddr[0], (int *)&rndis->ethaddr[1],
+		    (int *)&rndis->ethaddr[2], (int *)&rndis->ethaddr[3],
+		    (int *)&rndis->ethaddr[4], (int *)&rndis->ethaddr[5]) == 6)
+		return size;
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(ethaddr, S_IRUGO | S_IWUSR, rndis_ethaddr_show,
+					       rndis_ethaddr_store);
+
+static ssize_t rndis_vendorID_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+	return sprintf(buf, "%04x\n", config->vendorID);
+}
+
+static ssize_t rndis_vendorID_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+	if (sscanf(buf, "%04x", &value) == 1) {
+		config->vendorID = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(vendorID, S_IRUGO | S_IWUSR, rndis_vendorID_show,
+						rndis_vendorID_store);
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+static ssize_t rndis_direct_feature_on_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->direct_feature_on);
+}
+
+static ssize_t rndis_direct_feature_on_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+
+	if (value > 0)
+		config->direct_feature_on = true;
+	else
+		config->direct_feature_on = false;
+	return size;
+}
+
+static DEVICE_ATTR(direct_feature_on, S_IRUGO | S_IWUSR, rndis_direct_feature_on_show,
+						rndis_direct_feature_on_store);
+
+static ssize_t rndis_direct_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *android_f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = android_f->config;
+
+	if (config != NULL)
+		return sprintf(buf, "%d\n", config->direct_value);
+	else
+		return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t rndis_direct_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *android_f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = android_f->config;
+	struct android_dev *pdev = _android_dev;
+	struct usb_composite_dev *cdev = pdev->cdev;
+	struct usb_function		*f;
+	int value;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &value);
+
+	if (ret)
+		return -EINVAL;
+
+	if (!config)
+		return -EFAULT;
+
+	if (config->direct_feature_on)
+		pr_info("%s value:%d->%d\n", __func__, config->direct_value, value);
+	else
+		pr_info("%s direct feature is false\n", __func__);
+
+	if (config->direct_feature_on && value != config->direct_value) {
+		config->direct_value = value;
+		if (cdev->config != NULL) {
+			list_for_each_entry(f, &cdev->config->functions, list) {
+				if (f != NULL && !strcmp(f->name, "rndis")) {
+					if (value == 0)
+						rndis_set_direct_tethering(f, false);
+					else if (value == 1)
+						rndis_set_direct_tethering(f, true);
+				}
+			}
+		}
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(direct, S_IRUGO | S_IWUSR, rndis_direct_show,
+						rndis_direct_store);
+#endif
+
+static struct device_attribute *rndis_function_attributes[] = {
+	&dev_attr_manufacturer,
+	&dev_attr_wceis,
+	&dev_attr_ethaddr,
+	&dev_attr_vendorID,
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+	&dev_attr_direct_feature_on,
+	&dev_attr_direct,
+#endif
+	NULL
+};
+
+static struct android_usb_function rndis_function = {
+	.name		= "rndis",
+	.init		= rndis_function_init,
+	.cleanup	= rndis_function_cleanup,
+	.bind_config	= rndis_function_bind_config,
+	.unbind_config	= rndis_function_unbind_config,
+	.attributes	= rndis_function_attributes,
+};
+
+
+
+struct mbim_function_config {
+	u8      ethaddr[ETH_ALEN];
+	char	manufacturer[256];
+	struct mbim_eth_dev *dev;
+};
+
+#define MAX_MBIM_INSTANCES 1
+
+static int mbim_function_init(struct android_usb_function *f,
+					 struct usb_composite_dev *cdev)
+{
+	int ret;
+
+	f->config = kzalloc(sizeof(struct mbim_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	ret = mbim_init(MAX_MBIM_INSTANCES);
+	if (ret)
+		kfree(f->config);
+
+	return ret;
+}
+
+static void mbim_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+	mbim_cleanup();
+}
+
+static int mbim_function_bind_config(struct android_usb_function *f,
+					  struct usb_configuration *c)
+{
+	int ret;
+	struct mbim_function_config *mbim = f->config;
+	struct mbim_eth_dev *dev;
+
+	dev = mbim_ether_setup_name(c->cdev->gadget);
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: mbim_gether_setup failed\n", __func__);
+		return ret;
+	}
+	mbim->dev = dev;
+	return mbim_bind_config(c, 0, mbim->dev);
+}
+static void mbim_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct mbim_function_config *mbim = f->config;
+
+	mbim_ether_cleanup(mbim->dev);
+}
+
+static struct android_usb_function mbim_function = {
+	.name		= "mbim",
+	.init		= mbim_function_init,
+	.cleanup	= mbim_function_cleanup,
+	.bind_config	= mbim_function_bind_config,
+	.unbind_config	= mbim_function_unbind_config,
+};
+
+
+
+struct mass_storage_function_config {
+	struct usb_function *f_ms;
+	struct usb_function_instance *f_ms_inst;
+};
+#define fsg_num_buffers	CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS
+static struct fsg_module_parameters fsg_mod_data;
+FSG_MODULE_PARAMETERS(/* no prefix */, fsg_mod_data);
+
+static int mass_storage_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct mass_storage_function_config *config;
+	int ret, i;
+	struct fsg_opts *fsg_opts;
+	struct fsg_config m_config;
+
+
+	pr_debug("%s(): Inside\n", __func__);
+	config = kzalloc(sizeof(struct mass_storage_function_config),
+								GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	config->f_ms_inst = usb_get_function_instance("mass_storage");
+	if (IS_ERR(config->f_ms_inst)) {
+		ret = PTR_ERR(config->f_ms_inst);
+		goto err_usb_get_function_instance;
+	}
+
+	config->f_ms = usb_get_function(config->f_ms_inst);
+	if (IS_ERR(config->f_ms)) {
+		ret = PTR_ERR(config->f_ms);
+		goto err_usb_get_function;
+	}
+#ifdef CONFIG_MTK_MULTI_STORAGE_SUPPORT
+#ifdef CONFIG_MTK_SHARED_SDCARD
+#define NLUN_STORAGE 1
+#else
+#define NLUN_STORAGE 2
+#endif
+#else
+#define NLUN_STORAGE 1
+#endif
+
+	fsg_mod_data.file_count = NLUN_STORAGE;
+	for (i = 0 ; i < fsg_mod_data.file_count; i++) {
+		fsg_mod_data.file[i] = "";
+		fsg_mod_data.removable[i] = true;
+		fsg_mod_data.nofua[i] = true;
+	}
+
+	fsg_config_from_params(&m_config, &fsg_mod_data, fsg_num_buffers);
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	/* note this is important for sysfs manipulation and this will be override when fsg_main_thread be created*/
+	ret = fsg_common_set_cdev(fsg_opts->common, cdev,
+						m_config.can_stall);
+	if (ret) {
+		pr_err("%s(): error(%d) for fsg_common_set_cdev\n",
+						__func__, ret);
+	}
+
+	/* this will affect lun create name */
+	fsg_common_set_sysfs(fsg_opts->common, true);
+	ret = fsg_common_create_luns(fsg_opts->common, &m_config);
+	if (ret) {
+		pr_err("%s(): error(%d) for fsg_common_create_luns\n",
+						__func__, ret);
+	}
+
+	/* use default one currently */
+	fsg_common_set_inquiry_string(fsg_opts->common, m_config.vendor_name,
+							m_config.product_name);
+
+	/* SYSFS create */
+	fsg_sysfs_update(fsg_opts->common, f->dev, true);
+
+	/* invoke thread */
+	/* ret = fsg_common_run_thread(fsg_opts->common); */
+	/*if (ret) */
+	/*	return ret; */
+
+	/* setup this to avoid create fsg thread in fsg_bind again */
+	fsg_opts->no_configfs = false;
+
+	return 0;
+
+
+err_usb_get_function:
+	usb_put_function_instance(config->f_ms_inst);
+
+err_usb_get_function_instance:
+	return ret;
+}
+
+static void mass_storage_function_cleanup(struct android_usb_function *f)
+{
+	struct mass_storage_function_config *config = f->config;
+
+	/* release what we required */
+	struct fsg_opts *fsg_opts;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+	fsg_sysfs_update(fsg_opts->common, f->dev, false);
+
+	usb_put_function(config->f_ms);
+	usb_put_function_instance(config->f_ms_inst);
+
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int mass_storage_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct mass_storage_function_config *config = f->config;
+	int ret = 0;
+
+
+	/* no_configfs :true, make fsg_bind skip for creating fsg thread */
+	ret = usb_add_function(c, config->f_ms);
+	if (ret)
+		pr_err("Could not bind config\n");
+
+	return 0;
+}
+
+static ssize_t mass_storage_inquiry_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fsg_opts *fsg_opts;
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+	return fsg_inquiry_show(fsg_opts->common, buf);
+}
+
+static ssize_t mass_storage_inquiry_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct fsg_opts *fsg_opts;
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+	return fsg_inquiry_store(fsg_opts->common, buf, size);
+}
+
+static DEVICE_ATTR(inquiry_string, S_IRUGO | S_IWUSR,
+					mass_storage_inquiry_show,
+					mass_storage_inquiry_store);
+
+static ssize_t mass_storage_bicr_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	struct fsg_opts *fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	return fsg_bicr_show(fsg_opts->common, buf);
+}
+
+static ssize_t mass_storage_bicr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	struct fsg_opts *fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	return fsg_bicr_store(fsg_opts->common, buf, size);
+}
+
+static DEVICE_ATTR(bicr, S_IRUGO | S_IWUSR,
+					mass_storage_bicr_show,
+					mass_storage_bicr_store);
+
+
+static struct device_attribute *mass_storage_function_attributes[] = {
+	&dev_attr_inquiry_string,
+	&dev_attr_bicr,
+	NULL
+};
+
+static struct android_usb_function mass_storage_function = {
+	.name		= "mass_storage",
+	.init		= mass_storage_function_init,
+	.cleanup	= mass_storage_function_cleanup,
+	.bind_config	= mass_storage_function_bind_config,
+	.attributes	= mass_storage_function_attributes,
+};
+
+
+static int accessory_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	return acc_setup();
+}
+
+static void accessory_function_cleanup(struct android_usb_function *f)
+{
+	acc_cleanup();
+}
+
+static int accessory_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	return acc_bind_config(c);
+}
+
+static int accessory_function_ctrlrequest(struct android_usb_function *f,
+						struct usb_composite_dev *cdev,
+						const struct usb_ctrlrequest *c)
+{
+	return acc_ctrlrequest(cdev, c);
+}
+
+static struct android_usb_function accessory_function = {
+	.name		= "accessory",
+	.init		= accessory_function_init,
+	.cleanup	= accessory_function_cleanup,
+	.bind_config	= accessory_function_bind_config,
+	.ctrlrequest	= accessory_function_ctrlrequest,
+};
+
+
+struct audio_source_function_config {
+	struct usb_function *f_aud;
+	struct usb_function_instance *f_aud_inst;
+};
+
+static int audio_source_function_init(struct android_usb_function *f,
+			struct usb_composite_dev *cdev)
+{
+	struct audio_source_function_config *config;
+
+	config = kzalloc(sizeof(*config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	config->f_aud_inst = usb_get_function_instance("audio_source");
+	if (IS_ERR(config->f_aud_inst))
+		return PTR_ERR(config->f_aud_inst);
+
+	config->f_aud = usb_get_function(config->f_aud_inst);
+	if (IS_ERR(config->f_aud)) {
+		usb_put_function_instance(config->f_aud_inst);
+		return PTR_ERR(config->f_aud);
+	}
+
+	f->config = config;
+	return 0;
+}
+
+static void audio_source_function_cleanup(struct android_usb_function *f)
+{
+	struct audio_source_function_config *config = f->config;
+
+
+	usb_put_function(config->f_aud);
+	usb_put_function_instance(config->f_aud_inst);
+
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int audio_source_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct audio_source_function_config *config = f->config;
+
+
+	return usb_add_function(c, config->f_aud);
+}
+
+static struct android_usb_function audio_source_function = {
+	.name		= "audio_source",
+	.init		= audio_source_function_init,
+	.cleanup	= audio_source_function_cleanup,
+	.bind_config	= audio_source_function_bind_config,
+};
+
+
+#ifdef CONFIG_MTK_ECCCI_C2K
+static int rawbulk_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	return 0;
+}
+
+static void rawbulk_function_cleanup(struct android_usb_function *f)
+{
+	;
+}
+
+static int rawbulk_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	char *i = f->name + strlen("via_");
+
+	if (!strncmp(i, "modem", 5))
+		return rawbulk_bind_config(c, RAWBULK_TID_MODEM);
+	else if (!strncmp(i, "ets", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_ETS);
+	else if (!strncmp(i, "atc", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_AT);
+	else if (!strncmp(i, "pcv", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_PCV);
+	else if (!strncmp(i, "gps", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_GPS);
+	return -EINVAL;
+}
+
+static int rawbulk_function_modem_ctrlrequest(struct android_usb_function *f,
+						struct usb_composite_dev *cdev,
+						const struct usb_ctrlrequest *c)
+{
+	if ((c->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE &&
+			(c->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {
+		struct rawbulk_function *fn = rawbulk_lookup_function(RAWBULK_TID_MODEM);
+
+		return rawbulk_function_setup(&fn->function, c);
+	}
+	return -1;
+}
+
+static struct android_usb_function rawbulk_modem_function = {
+	.name		= "via_modem",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+	.ctrlrequest	= rawbulk_function_modem_ctrlrequest,
+};
+
+static struct android_usb_function rawbulk_ets_function = {
+	.name		= "via_ets",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_atc_function = {
+	.name		= "via_atc",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_pcv_function = {
+	.name		= "via_pcv",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_gps_function = {
+	.name		= "via_gps",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+#endif
+
+#ifdef CONFIG_SND_RAWMIDI
+static int midi_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct midi_alsa_config *config;
+
+	config = kzalloc(sizeof(struct midi_alsa_config), GFP_KERNEL);
+	f->config = config;
+	if (!config)
+		return -ENOMEM;
+	config->card = -1;
+	config->device = -1;
+	return 0;
+}
+
+static void midi_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+}
+
+static int midi_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct midi_alsa_config *config = f->config;
+
+	return f_midi_bind_config(c, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			MIDI_INPUT_PORTS, MIDI_OUTPUT_PORTS, MIDI_BUFFER_SIZE,
+			MIDI_QUEUE_LENGTH, config);
+}
+
+static ssize_t midi_alsa_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct midi_alsa_config *config = f->config;
+
+	/* print ALSA card and device numbers */
+	return sprintf(buf, "%d %d\n", config->card, config->device);
+}
+
+static DEVICE_ATTR(alsa, S_IRUGO, midi_alsa_show, NULL);
+
+static struct device_attribute *midi_function_attributes[] = {
+	&dev_attr_alsa,
+	NULL
+};
+
+static struct android_usb_function midi_function = {
+	.name		= "midi",
+	.init		= midi_function_init,
+	.cleanup	= midi_function_cleanup,
+	.bind_config	= midi_function_bind_config,
+	.attributes	= midi_function_attributes,
+};
+#endif
+
+static struct android_usb_function *supported_functions[] = {
+	&ffs_function,
+	&mbim_function,
+	&acm_function,
+	&mtp_function,
+	&ptp_function,
+	&eem_function,
+	&serial_function,
+	&rndis_function,
+	&mass_storage_function,
+	&accessory_function,
+	&audio_source_function,
+#ifdef CONFIG_SND_RAWMIDI
+	&midi_function,
+#endif
+#ifdef CONFIG_MTK_ECCCI_C2K
+	&rawbulk_modem_function,
+	&rawbulk_ets_function,
+	&rawbulk_atc_function,
+	&rawbulk_pcv_function,
+	&rawbulk_gps_function,
+#endif
+#ifdef CONFIG_USB_F_SS_LB
+	&loopback_function,
+#endif
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	&hid_function,
+#endif
+	NULL
+};
+
+struct device *create_function_device(char *name)
+{
+	struct android_dev *dev = _android_dev;
+	struct android_usb_function **functions;
+	struct android_usb_function *f;
+
+	functions = dev->functions;
+
+
+	while ((f = *functions++))
+		if (!strcmp(name, f->dev_name))
+			return f->dev;
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int android_init_functions(struct android_usb_function **functions,
+				  struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct android_usb_function *f;
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	int err;
+#ifdef CONFIG_USBIF_COMPLIANCE
+	int index = 1;
+#else
+	int index = 0;
+#endif
+
+	for (; (f = *functions++); index++) {
+		f->dev_name = kasprintf(GFP_KERNEL, "f_%s", f->name);
+		pr_notice("[USB]%s: f->dev_name = %s, f->name = %s\n", __func__, f->dev_name, f->name);
+		f->dev = device_create(android_class, dev->dev,
+				MKDEV(0, index), f, f->dev_name);
+		if (IS_ERR(f->dev)) {
+			pr_err("%s: Failed to create dev %s", __func__,
+							f->dev_name);
+			err = PTR_ERR(f->dev);
+			goto err_create;
+		}
+
+		if (f->init) {
+			err = f->init(f, cdev);
+			if (err) {
+				pr_err("%s: Failed to init %s", __func__,
+								f->name);
+				goto err_out;
+			} else
+				pr_notice("[USB]%s: init %s success!!\n", __func__, f->name);
+		}
+
+		attrs = f->attributes;
+		if (attrs) {
+			while ((attr = *attrs++) && !err)
+				err = device_create_file(f->dev, attr);
+		}
+		if (err) {
+			pr_err("%s: Failed to create function %s attributes",
+					__func__, f->name);
+			goto err_out;
+		}
+	}
+	return 0;
+
+err_out:
+	device_destroy(android_class, f->dev->devt);
+err_create:
+	kfree(f->dev_name);
+	return err;
+}
+
+static void android_cleanup_functions(struct android_usb_function **functions)
+{
+	struct android_usb_function *f;
+
+
+	while (*functions) {
+		f = *functions++;
+
+		if (f->dev) {
+			device_destroy(android_class, f->dev->devt);
+			kfree(f->dev_name);
+		}
+
+		if (f->cleanup)
+			f->cleanup(f);
+	}
+}
+
+static int
+android_bind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+	int ret;
+
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		pr_notice("[USB]bind_config function '%s'/%p\n", f->name, f);
+		ret = f->bind_config(f, c);
+		if (ret) {
+			pr_err("%s: %s failed", __func__, f->name);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static void
+android_unbind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->unbind_config)
+			f->unbind_config(f, c);
+	}
+}
+
+static int android_enable_function(struct android_dev *dev, char *name)
+{
+	struct android_usb_function **functions = dev->functions;
+	struct android_usb_function *f;
+
+
+	while ((f = *functions++)) {
+		if (!strcmp(name, f->name)) {
+			list_add_tail(&f->enabled_list,
+						&dev->enabled_functions);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/*-------------------------------------------------------------------------*/
+/* /sys/class/android_usb/android%d/ interface */
+
+static ssize_t
+functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct android_usb_function *f;
+	char *buff = buf;
+
+	pr_notice("[USB]%s: ", __func__);
+	mutex_lock(&dev->mutex);
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list)
+		buff += sprintf(buff, "%s,", f->name);
+
+	mutex_unlock(&dev->mutex);
+
+	if (buff != buf)
+		*(buff-1) = '\n';
+	return buff - buf;
+}
+
+static ssize_t
+functions_store(struct device *pdev, struct device_attribute *attr,
+			       const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	char *name;
+	char buf[256], *b;
+	char aliases[256], *a;
+	int err;
+	int is_ffs;
+	int ffs_enabled = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	INIT_LIST_HEAD(&dev->enabled_functions);
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT || get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT) {
+		pr_notice("[USB]KPOC, func%s\n", KPOC_USB_FUNC);
+		err = android_enable_function(dev, KPOC_USB_FUNC);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+					KPOC_USB_FUNC, err);
+		mutex_unlock(&dev->mutex);
+		return size;
+	}
+#endif
+
+	strlcpy(buf, buff, sizeof(buf));
+	b = strim(buf);
+
+	while (b) {
+		name = strsep(&b, ",");
+		pr_notice("[USB]%s: name = %s\n", __func__, name);
+		if (!name)
+			continue;
+
+		is_ffs = 0;
+		strlcpy(aliases, dev->ffs_aliases, sizeof(aliases));
+		a = aliases;
+
+		while (a) {
+			char *alias = strsep(&a, ",");
+
+			if (alias && !strcmp(name, alias)) {
+				is_ffs = 1;
+				break;
+			}
+		}
+
+		if (is_ffs) {
+			if (ffs_enabled)
+				continue;
+			err = android_enable_function(dev, "ffs");
+			if (err)
+				pr_err("android_usb: Cannot enable ffs (%d)",
+									err);
+			else
+				ffs_enabled = 1;
+			continue;
+		}
+
+		err = android_enable_function(dev, name);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+							   name, err);
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static ssize_t enable_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+
+	return sprintf(buf, "%d\n", dev->enabled);
+}
+
+static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
+			    const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct android_usb_function *f;
+	int enabled = 0;
+	int ret;
+
+	if (!cdev)
+		return -ENODEV;
+
+
+	mutex_lock(&dev->mutex);
+
+	pr_notice("[USB]%s: device_attr->attr.name: %s\n", __func__, attr->attr.name);
+
+	ret = kstrtoint(buff, 0, &enabled);
+
+	if (enabled && !dev->enabled) {
+		/* ALPS01770952
+		 * Reset next_string_id to 0 before enabling the gadget driver.
+		 * Otherwise, after a large number of enable/disable cycles,
+		 * function bind will fail because we cannot allocate new string ids.
+		 * String ids cannot be larger than 254 per USB spec.
+		 * 0~15 are reserved for usb device descriptor
+		 * 16~254 are for functions.
+		 */
+		cdev->next_string_id = 0x10;
+
+		/*
+		 * Update values in composite driver's copy of
+		 * device descriptor.
+		 */
+		cdev->desc.idVendor = device_desc.idVendor;
+		cdev->desc.idProduct = device_desc.idProduct;
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+		if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+				|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT) {
+			pr_notice("[USB]KPOC, vid:%d, pid:%d\n", KPOC_USB_VENDOR_ID, KPOC_USB_PRODUCT_ID);
+			cdev->desc.idVendor = cpu_to_le16(KPOC_USB_VENDOR_ID);
+			cdev->desc.idProduct = cpu_to_le16(KPOC_USB_PRODUCT_ID);
+		}
+#endif
+		cdev->desc.bcdDevice = device_desc.bcdDevice;
+		cdev->desc.bDeviceClass = device_desc.bDeviceClass;
+		cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
+		cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
+
+		/* special case for meta mode */
+		if (serial_string[0] == 0x20)
+			cdev->desc.iSerialNumber = 0;
+		else
+			cdev->desc.iSerialNumber = device_desc.iSerialNumber;
+
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			if (f->enable)
+				f->enable(f);
+		}
+		android_enable(dev);
+		dev->enabled = true;
+		pr_notice("[USB]%s: enable 0->1 case, device_desc.idVendor = 0x%x, device_desc.idProduct = 0x%x\n",
+				__func__, device_desc.idVendor, device_desc.idProduct);
+#ifdef CONFIG_MTPROF
+		{
+			static int first_shot = 1;
+
+			if (first_shot) {
+				log_boot("USB ready");
+				first_shot = 0;
+			}
+		}
+#endif
+	} else if (!enabled && dev->enabled) {
+		pr_notice("[USB]%s: enable 1->0 case, device_desc.idVendor = 0x%x, device_desc.idProduct = 0x%x\n",
+				__func__, device_desc.idVendor, device_desc.idProduct);
+		android_disable(dev);
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			pr_notice("[USB]disable function '%s'/%p\n", f->name, f);
+			if (f->disable)
+				f->disable(f);
+		}
+		dev->enabled = false;
+	} else {
+		pr_err("android_usb: already %s\n",
+				dev->enabled ? "enabled" : "disabled");
+	}
+
+	mutex_unlock(&dev->mutex);
+	return size;
+}
+
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!cdev)
+		goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		state = "CONFIGURED";
+	else if (dev->connected)
+		state = "CONNECTED";
+	pr_warn("[USB]%s, state:%s\n", __func__, state);
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+#define LOG_BUG_SZ 2048
+static char log_buf[LOG_BUG_SZ];
+static int log_buf_idx;
+static ssize_t
+log_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	mutex_lock(&dev->mutex);
+
+	memcpy(buf, log_buf, log_buf_idx);
+
+	mutex_unlock(&dev->mutex);
+	return log_buf_idx;
+}
+
+static ssize_t
+log_store(struct device *pdev, struct device_attribute *attr,
+			       const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	char buf[256], n;
+
+	mutex_lock(&dev->mutex);
+
+	n = strlcpy(buf, buff, sizeof(buf));
+
+	if ((log_buf_idx + (n + 1)) > LOG_BUG_SZ)
+		log_buf_idx = 0;
+
+	memcpy(log_buf + log_buf_idx, buf, n);
+	log_buf_idx += n;
+	log_buf[log_buf_idx++] = ' ';
+	pr_warn("[USB]%s, <%s>, n:%d, log_buf_idx:%d\n", __func__, buf, n, log_buf_idx);
+
+	mutex_unlock(&dev->mutex);
+	return size;
+}
+
+#define DESCRIPTOR_ATTR(field, format_string)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, format_string, device_desc.field);		\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	int value;							\
+	if (sscanf(buf, format_string, &value) == 1) {			\
+		device_desc.field = value;				\
+		return size;						\
+	}								\
+	return -1;							\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store)
+
+#define DESCRIPTOR_STRING_ATTR(field, buffer)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, "%s", buffer);				\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	if (size >= sizeof(buffer))					\
+		return -EINVAL;						\
+	return strlcpy(buffer, buf, sizeof(buffer));			\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store)
+
+
+DESCRIPTOR_ATTR(idVendor, "%04x\n");
+DESCRIPTOR_ATTR(idProduct, "%04x\n");
+DESCRIPTOR_ATTR(bcdDevice, "%04x\n");
+DESCRIPTOR_ATTR(bDeviceClass, "%d\n");
+DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n");
+DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n");
+DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string);
+DESCRIPTOR_STRING_ATTR(iProduct, product_string);
+DESCRIPTOR_STRING_ATTR(iSerial, serial_string);
+
+static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
+						 functions_store);
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+static DEVICE_ATTR(log, S_IRUGO | S_IWUSR, log_show,
+						 log_store);
+
+static struct device_attribute *android_usb_attributes[] = {
+	&dev_attr_idVendor,
+	&dev_attr_idProduct,
+	&dev_attr_bcdDevice,
+	&dev_attr_bDeviceClass,
+	&dev_attr_bDeviceSubClass,
+	&dev_attr_bDeviceProtocol,
+	&dev_attr_iManufacturer,
+	&dev_attr_iProduct,
+	&dev_attr_iSerial,
+	&dev_attr_functions,
+	&dev_attr_enable,
+	&dev_attr_state,
+	&dev_attr_log,
+	NULL
+};
+
+/*-------------------------------------------------------------------------*/
+/* Composite driver */
+
+static int android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret = 0;
+
+	ret = android_bind_enabled_functions(dev, c);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void android_unbind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+
+
+	android_unbind_enabled_functions(dev, c);
+}
+
+static int android_setup_config(struct usb_configuration *c, const struct usb_ctrlrequest *ctrl)
+{
+	int handled = -EINVAL;
+	const u8 recip = ctrl->bRequestType & USB_RECIP_MASK;
+
+
+	pr_notice("%s bRequestType=%x, bRequest=%x, recip=%x\n", __func__, ctrl->bRequestType, ctrl->bRequest, recip);
+
+	if (!((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD))
+		return handled;
+
+	switch (ctrl->bRequest) {
+
+	case USB_REQ_CLEAR_FEATURE:
+		switch (recip) {
+		case USB_RECIP_DEVICE:
+			switch (ctrl->wValue) {
+			case USB_DEVICE_U1_ENABLE:
+				handled = 1;
+				pr_notice("Clear Feature->U1 Enable\n");
+				break;
+
+			case USB_DEVICE_U2_ENABLE:
+				handled = 1;
+				pr_notice("Clear Feature->U2 Enable\n");
+				break;
+
+			default:
+				handled = -EINVAL;
+				break;
+			}
+			break;
+		default:
+			handled = -EINVAL;
+			break;
+		}
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		switch (recip) {
+		case USB_RECIP_DEVICE:
+			switch (ctrl->wValue) {
+			case USB_DEVICE_U1_ENABLE:
+				pr_notice("Set Feature->U1 Enable\n");
+				handled = 1;
+				break;
+			case USB_DEVICE_U2_ENABLE:
+				pr_notice("Set Feature->U2 Enable\n");
+				handled = 1;
+				break;
+			default:
+				handled = -EINVAL;
+				break;
+			}
+			break;
+
+		default:
+			handled = -EINVAL;
+			break;
+		}
+		break;
+
+	default:
+		handled = -EINVAL;
+		break;
+	}
+
+	return handled;
+}
+
+static int android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			id, ret;
+
+	/* Save the default handler */
+	dev->setup_complete = cdev->req->complete;
+
+	/*
+	 * Start disconnected. Userspace will connect the gadget once
+	 * it is done configuring the functions.
+	 */
+	usb_gadget_disconnect(gadget);
+
+	ret = android_init_functions(dev->functions, cdev);
+	if (ret)
+		return ret;
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	/* Default strings - should be updated by userspace */
+	strncpy(manufacturer_string, "3Prism XX", sizeof(manufacturer_string)-1);
+	strncpy(product_string, "3Prism XX", sizeof(product_string) - 1);
+	strncpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
+
+#ifdef CONFIG_USBIF_COMPLIANCE
+	usb_gadget_clear_selfpowered(gadget);
+#else
+	usb_gadget_set_selfpowered(gadget);
+#endif
+	dev->cdev = cdev;
+
+	return 0;
+}
+
+static int android_usb_unbind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+
+
+	cancel_work_sync(&dev->work);
+	android_cleanup_functions(dev->functions);
+	return 0;
+}
+
+/* HACK: android needs to override setup for accessory to work */
+static int (*composite_setup_func)(struct usb_gadget *gadget, const struct usb_ctrlrequest *c);
+
+static int
+android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
+{
+	struct android_dev		*dev = _android_dev;
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_request		*req = cdev->req;
+	struct android_usb_function	*f;
+	int value = -EOPNOTSUPP;
+	unsigned long flags;
+
+
+	req->zero = 0;
+	req->length = 0;
+	/* req->complete = dev->setup_complete; */
+	req->complete = composite_setup_complete;
+	gadget->ep0->driver_data = cdev;
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->ctrlrequest) {
+			value = f->ctrlrequest(f, cdev, c);
+			if (value >= 0)
+				break;
+		}
+	}
+
+	/* Special case the accessory function.
+	 * It needs to handle control requests before it is enabled.
+	 */
+
+	if (value < 0)
+		value = acc_ctrlrequest(cdev, c);
+
+	if (value < 0)
+		value = composite_setup_func(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (!dev->connected) {
+		dev->connected = 1;
+		schedule_work(&dev->work);
+	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+						cdev->config) {
+		schedule_work(&dev->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+static void android_disconnect(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+
+	/* accessory HID support can be active while the
+	 * accessory function is not actually enabled,
+	 * so we need to inform it when we are disconnected.
+	 */
+
+	acc_disconnect();
+
+	dev->connected = 0;
+	schedule_work(&dev->work);
+	pr_notice("[USB]%s: dev->connected = %d\n", __func__, dev->connected);
+}
+
+static struct usb_composite_driver android_usb_driver = {
+	.name		= "android_usb",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= android_bind,
+	.unbind		= android_usb_unbind,
+	.disconnect	= android_disconnect,
+#ifdef CONFIG_USB_MU3D_DRV
+	.max_speed	= USB_SPEED_SUPER
+#else
+	.max_speed	= USB_SPEED_HIGH
+#endif
+};
+
+#define USB_STATE_MONITOR_DELAY 3000
+static struct delayed_work android_usb_state_monitor_work;
+static void do_android_usb_state_monitor_work(struct work_struct *work)
+{
+	struct android_dev *dev = _android_dev;
+	char *usb_state = "NO-DEV";
+
+	if (dev && dev->cdev)
+		usb_state = "DISCONNECTED";
+
+	if (dev && dev->cdev && dev->cdev->config)
+		usb_state = "CONFIGURED";
+
+	pr_warn("usb_state<%s>\n", usb_state);
+	schedule_delayed_work(&android_usb_state_monitor_work, msecs_to_jiffies(USB_STATE_MONITOR_DELAY));
+}
+void trigger_android_usb_state_monitor_work(void)
+{
+	static int inited;
+
+	if (!inited) {
+		/* TIMER_DEFERRABLE for not interfering with deep idle */
+		INIT_DEFERRABLE_WORK(&android_usb_state_monitor_work, do_android_usb_state_monitor_work);
+		inited = 1;
+	}
+	schedule_delayed_work(&android_usb_state_monitor_work, msecs_to_jiffies(USB_STATE_MONITOR_DELAY));
+
+};
+
+static int android_create_device(struct android_dev *dev)
+{
+	struct device_attribute **attrs = android_usb_attributes;
+	struct device_attribute *attr;
+	int err;
+
+
+	dev->dev = device_create(android_class, NULL,
+					MKDEV(0, 0), NULL, "android0");
+	if (IS_ERR(dev->dev))
+		return PTR_ERR(dev->dev);
+
+	dev_set_drvdata(dev->dev, dev);
+
+	while ((attr = *attrs++)) {
+		err = device_create_file(dev->dev, attr);
+		if (err) {
+			device_destroy(android_class, dev->dev->devt);
+			return err;
+		}
+	}
+#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
+	if (usb2jtag_mode())
+		pr_err("[USB2JTAG] in usb2jtag mode, not to initialize usb driver\n");
+	else
+		trigger_android_usb_state_monitor_work();
+#else
+		trigger_android_usb_state_monitor_work();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_USBIF_COMPLIANCE
+
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+
+
+static int andoid_usbif_driver_on;
+
+static int android_start(void)
+{
+	int err;
+
+	pr_notice("android_start ===>\n");
+
+	err = usb_composite_probe(&android_usb_driver);
+	if (err)
+		pr_err("%s: failed to probe driver %d", __func__, err);
+
+	/* HACK: exchange composite's setup with ours */
+	composite_setup_func = android_usb_driver.gadget_driver.setup;
+	android_usb_driver.gadget_driver.setup = android_setup;
+
+	pr_notice("android_start <===\n");
+
+	return err;
+}
+
+static int android_stop(void)
+{
+	pr_notice("android_stop ===>\n");
+
+	usb_composite_unregister(&android_usb_driver);
+
+	pr_notice("android_stop <===\n");
+	return 0;
+}
+
+static int andoid_usbif_proc_show(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "andoid_usbif_proc_show, andoid_usbif_driver_on is %d (on:1, off:0)\n", andoid_usbif_driver_on);
+	return 0;
+}
+
+static int andoid_usbif_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, andoid_usbif_proc_show, inode->i_private);
+}
+
+static ssize_t andoid_usbif_proc_write(struct file *file, const char __user *buf, size_t length, loff_t *ppos)
+{
+	char msg[32];
+
+	if (length >= sizeof(msg)) {
+		pr_notice("andoid_usbif_proc_write length error, the error len is %d\n", (unsigned int)length);
+		return -EINVAL;
+	}
+	if (copy_from_user(msg, buf, length))
+		return -EFAULT;
+
+	msg[length] = 0;
+
+	pr_notice("andoid_usbif_proc_write: %s, current driver on/off: %d\n", msg, andoid_usbif_driver_on);
+
+	if ((msg[0] == '1') && (andoid_usbif_driver_on == 0)) {
+		pr_notice("start usb android driver ===>\n");
+		pr_warn("start usb android driver ===>\n");
+		android_start();
+		andoid_usbif_driver_on = 1;
+		pr_notice("start usb android driver <===\n");
+	} else if ((msg[0] == '0') && (andoid_usbif_driver_on == 1)) {
+		pr_notice("stop usb android driver ===>\n");
+		pr_warn("stop usb android driver ===>\n");
+		andoid_usbif_driver_on = 0;
+		android_stop();
+
+		pr_notice("stop usb android driver <===\n");
+	}
+
+	return length;
+}
+
+static const struct file_operations andoid_usbif_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = andoid_usbif_proc_open,
+	.write = andoid_usbif_proc_write,
+	.read = seq_read,
+	.llseek = seq_lseek,
+
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int err;
+	struct proc_dir_entry *prEntry;
+
+
+
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err = -ENOMEM;
+		goto err_dev;
+	}
+
+	dev->disable_depth = 1;
+	dev->functions = supported_functions;
+	INIT_LIST_HEAD(&dev->enabled_functions);
+	INIT_WORK(&dev->work, android_work);
+	mutex_init(&dev->mutex);
+
+	err = android_create_device(dev);
+	if (err) {
+		pr_err("%s: failed to create android device %d", __func__, err);
+		goto err_create;
+	}
+
+	_android_dev = dev;
+
+	prEntry = proc_create("android_usbif_init", 0644, NULL, &andoid_usbif_proc_fops);
+
+	if (prEntry)
+		pr_warn("create the android_usbif_init proc OK!\n");
+	else
+		pr_warn("[ERROR] create the android_usbif_init proc FAIL\n");
+
+	/* set android up at boot up */
+	android_start();
+	andoid_usbif_driver_on = 1;
+
+	return 0;
+
+err_create:
+	kfree(dev);
+err_dev:
+	class_destroy(android_class);
+	return err;
+}
+
+late_initcall(init);
+
+
+static void __exit cleanup(void)
+{
+	pr_warn("[U3D] android cleanup ===>\n");
+	class_destroy(android_class);
+	kfree(_android_dev);
+	_android_dev = NULL;
+	pr_warn("[U3D] android cleanup <===\n");
+}
+module_exit(cleanup);
+
+#else
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int err;
+
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err = -ENOMEM;
+		goto err_dev;
+	}
+
+	dev->disable_depth = 1;
+	dev->functions = supported_functions;
+	INIT_LIST_HEAD(&dev->enabled_functions);
+	INIT_WORK(&dev->work, android_work);
+	mutex_init(&dev->mutex);
+
+	err = android_create_device(dev);
+	if (err) {
+		pr_err("%s: failed to create android device %d", __func__, err);
+		goto err_create;
+	}
+
+	_android_dev = dev;
+
+	err = usb_composite_probe(&android_usb_driver);
+	if (err) {
+		pr_err("%s: failed to probe driver %d", __func__, err);
+		_android_dev = NULL;
+		goto err_probe;
+	}
+
+	/* HACK: exchange composite's setup with ours */
+	composite_setup_func = android_usb_driver.gadget_driver.setup;
+	android_usb_driver.gadget_driver.setup = android_setup;
+
+	return 0;
+
+err_probe:
+	device_destroy(android_class, dev->dev->devt);
+err_create:
+	kfree(dev);
+err_dev:
+	class_destroy(android_class);
+	return err;
+}
+late_initcall(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	class_destroy(android_class);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
+#endif

Property changes on: vendor/branch/5058Y_ALIE/kernel-4.4/drivers/usb/gadget/android.c
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
