Index: vendor/branch/5058I_ALRU/frameworks/opt/net/ims/src/java/com/android/ims/ImsManager.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/net/ims/src/java/com/android/ims/ImsManager.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/net/ims/src/java/com/android/ims/ImsManager.java	(revision 6795)
@@ -0,0 +1,3197 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (c) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ims;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.PersistableBundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telecom.TelecomManager;
+import android.telephony.CarrierConfigManager;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.ims.internal.IImsCallSession;
+import com.android.ims.internal.IImsEcbm;
+import com.android.ims.internal.IImsMultiEndpoint;
+import com.android.ims.internal.IImsRegistrationListener;
+import com.android.ims.internal.IImsService;
+import com.android.ims.internal.IImsUt;
+import com.android.ims.internal.ImsCallSession;
+import com.android.ims.internal.IImsConfig;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.IPhoneSubInfo;
+
+
+import com.mediatek.ims.WfcReasonInfo;
+import com.mediatek.internal.telephony.ITelephonyEx;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.HashMap;
+
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.capability.CapabilityService;
+import org.gsma.joyn.chat.ChatService;
+import org.gsma.joyn.contacts.ContactsService;
+import org.gsma.joyn.ft.FileTransferService;
+import org.gsma.joyn.gsh.GeolocSharingService;
+import org.gsma.joyn.ish.ImageSharingService;
+import org.gsma.joyn.vsh.VideoSharingService;
+
+/// M: Extension for customization platform support status.
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.ims.IImsManagerExt;
+
+/**
+ * Provides APIs for IMS services, such as initiating IMS calls, and provides access to
+ * the operator's IMS network. This class is the starting point for any IMS actions.
+ * You can acquire an instance of it with {@link #getInstance getInstance()}.</p>
+ * <p>The APIs in this class allows you to:</p>
+ *
+ * @hide
+ */
+public class ImsManager {
+
+    /*
+     * Debug flag to override configuration flag
+     */
+    public static final String PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE = "persist.dbg.volte_avail_ovr";
+    public static final int PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE_DEFAULT = 0;
+    public static final String PROPERTY_DBG_VT_AVAIL_OVERRIDE = "persist.dbg.vt_avail_ovr";
+    public static final int PROPERTY_DBG_VT_AVAIL_OVERRIDE_DEFAULT = 0;
+    public static final String PROPERTY_DBG_WFC_AVAIL_OVERRIDE = "persist.dbg.wfc_avail_ovr";
+    public static final int PROPERTY_DBG_WFC_AVAIL_OVERRIDE_DEFAULT = 0;
+    public static final String PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE = "persist.dbg.allow_ims_off";
+    public static final int PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE_DEFAULT = 0;
+
+    /**
+     * For accessing the IMS related service.
+     * Internal use only.
+     * @hide
+     */
+    public static final String IMS_SERVICE = "ims";
+
+    /**
+     * The result code to be sent back with the incoming call {@link PendingIntent}.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     */
+    public static final int INCOMING_CALL_RESULT_CODE = 101;
+
+    /**
+     * Key to retrieve the call ID from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     */
+    public static final String EXTRA_CALL_ID = "android:imsCallID";
+
+    /// M: IMS VoLTE refactoring. @{
+    /**
+     * Key to retrieve the sequence number from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     * @hide
+     */
+    public static final String EXTRA_SEQ_NUM = "android:imsSeqNum";
+
+    /*
+     * Key to retrieve the sequence number from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     * @hide
+     */
+    public static final String EXTRA_DIAL_STRING = "android:imsDialString";
+    /// @}
+
+    /// M: IMS VoLTE refactoring. @{
+    /**
+     * Key to retrieve the call mode from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     * @hide
+     */
+    public static final String EXTRA_CALL_MODE = "android:imsCallMode";
+
+    /**
+     * Action to broadcast when ImsService is up.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_SERVICE_UP =
+            "com.android.ims.IMS_SERVICE_UP";
+
+    /**
+     * Action to broadcast when ImsService is down.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_SERVICE_DOWN =
+            "com.android.ims.IMS_SERVICE_DOWN";
+
+    /**
+     * Action to broadcast when ImsService registration fails.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_REGISTRATION_ERROR =
+            "com.android.ims.REGISTRATION_ERROR";
+
+    /// M: ALPS02261962. For IMS registration state and capability informaion. @{
+    public static final String ACTION_IMS_STATE_CHANGED =
+            "com.android.ims.IMS_STATE_CHANGED";
+    /// @}
+
+    /// M: For IMS deregister done notification. @{
+    public static final String ACTION_IMS_SERVICE_DEREGISTERED =
+            "com.android.ims.IMS_SERVICE_DEREGISTERED";
+    /// @}
+
+    /// M: For IMS RTP report notification. @{
+    public static final String ACTION_IMS_RTP_INFO =
+            "com.android.ims.IMS_RTP_INFO";
+    /// @}
+
+    /// M: For IMS radio change notification. @{
+    public static final String ACTION_IMS_RADIO_STATE_CHANGED =
+            "com.android.ims.IMS_RADIO_STATE_CHANGED";
+    /// @}
+
+    /// M: For IMS radio change notification. @{
+    public static final String EXTRA_IMS_RADIO_STATE = "android:imsRadioState";
+    /// @}
+
+    /**
+     * Part of the ACTION_IMS_SERVICE_UP or _DOWN intents.
+     * A long value; the phone ID corresponding to the IMS service coming up or down.
+     * Internal use only.
+     * @hide
+     */
+    public static final String EXTRA_PHONE_ID = "android:phone_id";
+
+    /**
+     * Action for the incoming call intent for the Phone app.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_INCOMING_CALL =
+            "com.android.ims.IMS_INCOMING_CALL";
+
+    /**
+     * Action for the incoming call indication intent for the Phone app.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_INCOMING_CALL_INDICATION =
+            "com.android.ims.IMS_INCOMING_CALL_INDICATION";
+
+    /**
+     * Part of the ACTION_IMS_INCOMING_CALL intents.
+     * An integer value; service identifier obtained from {@link ImsManager#open}.
+     * Internal use only.
+     * @hide
+     */
+    public static final String EXTRA_SERVICE_ID = "android:imsServiceId";
+
+    /**
+     * Part of the ACTION_IMS_INCOMING_CALL intents.
+     * An boolean value; Flag to indicate that the incoming call is a normal call or call for USSD.
+     * The value "true" indicates that the incoming call is for USSD.
+     * Internal use only.
+     * @hide
+     */
+    public static final String EXTRA_USSD = "android:ussd";
+
+    /**
+     * Part of the ACTION_IMS_INCOMING_CALL intents.
+     * A boolean value; Flag to indicate whether the call is an unknown
+     * dialing call. Such calls are originated by sending commands (like
+     * AT commands) directly to modem without Android involvement.
+     * Even though they are not incoming calls, they are propagated
+     * to Phone app using same ACTION_IMS_INCOMING_CALL intent.
+     * Internal use only.
+     * @hide
+     */
+    public static final String EXTRA_IS_UNKNOWN_CALL = "android:isUnknown";
+
+    /* M WFC */
+    public static final String EXTRA_IMS_REG_STATE_KEY = "android:regState";
+    public static final String EXTRA_IMS_ENABLE_CAP_KEY = "android:enablecap";
+    public static final String EXTRA_IMS_DISABLE_CAP_KEY = "android:disablecap";
+    public static final String EXTRA_IMS_REG_ERROR_KEY = "android:regError";
+    /* M WFC */
+
+    /// M: For IMS RTP report notification. @{
+    /**
+     * Part of the ACTION_IMS_RTP_INFO intents.
+     * @hide
+     */
+    public static final String EXTRA_RTP_PDN_ID = "android:rtpPdnId";
+    public static final String EXTRA_RTP_NETWORK_ID = "android:rtpNetworkId";
+    public static final String EXTRA_RTP_TIMER = "android:rtpTimer";
+    public static final String EXTRA_RTP_SEND_PKT_LOST = "android:rtpSendPktLost";
+    public static final String EXTRA_RTP_RECV_PKT_LOST = "android:rtpRecvPktLost";
+
+    /**
+     * M: Define IMS service support emergency event, extend by AOSP
+     * registrationServiceCapabilityChanged event parameter comment
+     */
+    public static final int SERVICE_REG_CAPABILITY_EVENT_REMOVED = 0;
+    public static final int SERVICE_REG_CAPABILITY_EVENT_ADDED = 1;
+    public static final int SERVICE_REG_CAPABILITY_EVENT_ECC_SUPPORT = 2;
+    public static final int SERVICE_REG_CAPABILITY_EVENT_ECC_NOT_SUPPORT = 4;
+    /** @}*/
+
+    private static final String TAG = "ImsManager";
+    private static final boolean DBG = true;
+
+    private static HashMap<Integer, ImsManager> sImsManagerInstances =
+            new HashMap<Integer, ImsManager>();
+
+    // ImsManager plugin instance
+    private static IImsManagerExt mImsManagerExt = null;
+
+    private Context mContext;
+    private int mPhoneId;
+    private IImsService mImsService = null;
+
+    // RCS Terminal API Services
+    private CapabilityService mCapabilitiesApi;
+    private ChatService mChatApi;
+    private ContactsService mContactsApi;
+    private FileTransferService mFileTransferApi;
+    private GeolocSharingService mGeolocSharingApi;
+    private VideoSharingService mVideoSharingApi;
+    private ImageSharingService mImageSharingApi;
+
+    private ImsServiceDeathRecipient mDeathRecipient = new ImsServiceDeathRecipient();
+    // Ut interface for the supplementary service configuration
+    private ImsUt mUt = null;
+    // Interface to get/set ims config items
+    private ImsConfig mConfig = null;
+    private boolean mConfigUpdated = false;
+
+    private ImsConfigListener mImsConfigListener;
+
+    // ECBM interface
+    private ImsEcbm mEcbm = null;
+
+    private ImsMultiEndpoint mMultiEndpoint = null;
+
+    /// M: Telephony global configuration
+    private static final String LTE_SUPPORT = "ro.boot.opt_lte_support";
+
+    private static final String MULTI_IMS_SUPPORT = "ro.mtk_multiple_ims_support";
+
+    /// M: Ims user setting keys
+    private static final String VOLTE_SETTING = "volte_setting";
+    private static final String TTY_MODE = "tty_mode";
+    private static final String VILTE_SETTING = "vilte_setting";
+    private static final String WFC_SETTING = "wfc_setting";
+    private static final String WFC_MODE_SETTING = "wfc_mode_setting";
+    private static final String WFC_ROAMING_MODE_SETTING = "wfc_roaming_mode_setting";
+    private static final String WFC_ROAMING_SETTING = "wfc_roaming_setting";
+
+    // SystemProperties used as cache
+    private static final String VOLTE_PROVISIONED_PROP = "net.lte.ims.volte.provisioned";
+    private static final String WFC_PROVISIONED_PROP = "net.lte.ims.wfc.provisioned";
+    private static final String VT_PROVISIONED_PROP = "net.lte.ims.vt.provisioned";
+    // Flag indicating data enabled or not. This flag should be in sync with
+    // DcTracker.isDataEnabled(). The flag will be set later during boot up.
+    private static final String[] DATA_ENABLED_PROP = {"net.lte.ims.data.enabled0","net.lte.ims.data.enabled1",
+                                                       "net.lte.ims.data.enabled2","net.lte.ims.data.enabled3"};
+
+    /// M: IMS EVS Setting
+    private static final String PROPERTY_IMS_EVS_ENABLE = "persist.radio.ims_evs_enable";
+
+    public static final String TRUE = "true";
+    public static final String FALSE = "false";
+
+    /**
+     * Gets a manager instance.
+     *
+     * @param context application context for creating the manager object
+     * @param phoneId the phone ID for the IMS Service
+     * @return the manager instance corresponding to the phoneId
+     */
+    public static ImsManager getInstance(Context context, int phoneId) {
+
+        log("getInstance() : phoneId" + phoneId);
+        synchronized (sImsManagerInstances) {
+            if (sImsManagerInstances.containsKey(phoneId))
+                return sImsManagerInstances.get(phoneId);
+
+            ImsManager mgr = new ImsManager(context, phoneId);
+            sImsManagerInstances.put(phoneId, mgr);
+
+            return mgr;
+        }
+    }
+
+    /**
+     * Returns the user configuration of Enhanced 4G LTE Mode setting
+     */
+    public static boolean isEnhanced4gLteModeSettingEnabledByUser(Context context) {
+        return isEnhanced4gLteModeSettingEnabledByUser(context,
+                getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of Enhanced 4G LTE Mode setting
+     */
+    public static boolean isEnhanced4gLteModeSettingEnabledByUser(Context context, int phoneId) {
+        // If user can't edit Enhanced 4G LTE Mode, it assumes Enhanced 4G LTE Mode is always true.
+        // If user changes SIM from editable mode to uneditable mode, need to return true.
+
+        int enabled = ImsConfig.FeatureValueConstants.OFF;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            if (!getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
+                return true;
+            }
+
+            enabled = android.provider.Settings.Global.getInt(
+                    context.getContentResolver(),
+                    android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED,
+                    (SystemProperties.get("persist.mtk_ct_volte_support").equals("1") &&
+                    !getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_DEFAULT_ENHANCED_4G_MODE_ENABLED_BOOL)) ?
+                            ImsConfig.FeatureValueConstants.OFF :
+                            ImsConfig.FeatureValueConstants.ON);
+        } else {
+            if (!getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL,
+                        phoneId)) {
+                return true;
+            }
+            enabled = getSettingValueByKey(context,VOLTE_SETTING,phoneId);
+        }
+
+        return (enabled == 1) ? true : false;
+    }
+
+    /**
+     * Change persistent Enhanced 4G LTE Mode setting
+     */
+    public static void setEnhanced4gLteModeSetting(Context context, boolean enabled) {
+        setEnhanced4gLteModeSetting(context, enabled,
+                getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent Enhanced 4G LTE Mode setting
+     */
+    public static void setEnhanced4gLteModeSetting(Context context, boolean enabled, int phoneId) {
+        int value = enabled ? 1 : 0;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+            android.provider.Settings.Global.putInt(
+                    context.getContentResolver(),
+                    android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
+        } else {
+            setSettingValueByKey(context, VOLTE_SETTING, value, phoneId);
+        }
+
+        if (isNonTtyOrTtyOnVolteEnabled(context,phoneId)) {
+            ImsManager imsManager = ImsManager.getInstance(context,
+                    phoneId);
+            if (imsManager != null) {
+                try {
+                    imsManager.setAdvanced4GMode(enabled);
+                } catch (ImsException ie) {
+                    // do nothing
+                }
+            }
+        }
+    }
+
+    /**
+     * Indicates whether the call is non-TTY or if TTY - whether TTY on VoLTE is
+     * supported.
+     */
+    public static boolean isNonTtyOrTtyOnVolteEnabled(Context context) {
+        return isNonTtyOrTtyOnVolteEnabled(context,getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Indicates whether the call is non-TTY or if TTY - whether TTY on VoLTE is
+     * supported.
+     */
+    public static boolean isNonTtyOrTtyOnVolteEnabled(Context context, int phoneId) {
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            if (getBooleanCarrierConfig(context,
+                    CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
+                return true;
+            }
+
+            return Settings.Secure.getInt(context.getContentResolver(),
+                    Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF)
+                    == TelecomManager.TTY_MODE_OFF;
+        } else {
+            if (getBooleanCarrierConfig(context,
+                    CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL,phoneId)) {
+                return true;
+            }
+            return getSettingValueByKey(context,TTY_MODE, phoneId)
+                    == TelecomManager.TTY_MODE_OFF;
+        }
+    }
+
+    /**
+     * Returns a platform configuration for VoLTE which may override the user setting.
+     */
+    public static boolean isVolteEnabledByPlatform(Context context) {
+        return isVolteEnabledByPlatform(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns a platform configuration for VoLTE which may override the user setting.
+     */
+    public static boolean isVolteEnabledByPlatform(Context context, int phoneId) {
+		
+        if (SystemProperties.getInt(PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE,
+                PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE_DEFAULT) == 1) {
+            return true;
+        }
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        /// M: Dynamic IMS Switch to support resource over multiple SIM.
+        boolean isResourceSupport = isImsResourceSupport(context,
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE,phoneId);
+
+        /// M: isFeatureEnabledByPlatformExt: Extension for customize platform support status
+        return (SystemProperties.getInt("persist.mtk_volte_support", 0) == 1)
+                && (SystemProperties.getInt(LTE_SUPPORT, 0) == 1)
+                && isResourceSupport
+                && getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_VOLTE_AVAILABLE_BOOL,phoneId)
+                && isGbaValid(context,phoneId)
+                && isFeatureEnabledByPlatformExt(context,
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE);
+    }
+
+    /**
+     * Indicates whether VoLTE is provisioned on device
+     */
+    public static boolean isVolteProvisionedOnDevice(Context context) {
+        if (getBooleanCarrierConfig(context,
+                    CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
+            ImsManager mgr = ImsManager.getInstance(context,
+                    SubscriptionManager.getDefaultVoicePhoneId());
+            if (mgr != null) {
+                return mgr.isVolteProvisioned();
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Indicates whether VoWifi is provisioned on device
+     */
+    public static boolean isWfcProvisionedOnDevice(Context context) {
+        if (getBooleanCarrierConfig(context,
+                CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
+            ImsManager mgr = ImsManager.getInstance(context,
+                    SubscriptionManager.getDefaultVoicePhoneId());
+            if (mgr != null) {
+                return mgr.isWfcProvisioned();
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Indicates whether VT is provisioned on device
+     */
+    public static boolean isVtProvisionedOnDevice(Context context) {
+        if (getBooleanCarrierConfig(context,
+                CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
+            ImsManager mgr = ImsManager.getInstance(context,
+                    SubscriptionManager.getDefaultVoicePhoneId());
+            if (mgr != null) {
+                return mgr.isVtProvisioned();
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Returns a platform configuration for VT which may override the user setting.
+     *
+     * Note: VT presumes that VoLTE is enabled (these are configuration settings
+     * which must be done correctly).
+     */
+    public static boolean isVtEnabledByPlatform(Context context) {
+        return isVtEnabledByPlatform(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns a platform configuration for VT which may override the user setting.
+     *
+     * Note: VT presumes that VoLTE is enabled (these are configuration settings
+     * which must be done correctly).
+     */
+    public static boolean isVtEnabledByPlatform(Context context, int phoneId) {
+        if (SystemProperties.getInt(PROPERTY_DBG_VT_AVAIL_OVERRIDE,
+                PROPERTY_DBG_VT_AVAIL_OVERRIDE_DEFAULT) == 1) {
+            return true;
+        }
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        /// M: Dynamic IMS Switch to support resource over multiple SIM.
+        boolean isResourceSupport = isImsResourceSupport(context,
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, phoneId);
+
+        /// M: isFeatureEnabledByPlatformExt: Extension for customize platform support status
+        return (!SystemProperties.get("ro.mtk_ims_video_call_support", "none").equals("none")) &&
+                (SystemProperties.getInt(LTE_SUPPORT, 0) == 1) &&
+                isResourceSupport &&
+                getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_VT_AVAILABLE_BOOL, phoneId) &&
+                isGbaValid(context,phoneId) &&
+                isFeatureEnabledByPlatformExt(context,
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE);
+    }
+
+    /**
+     * Returns the user configuration of VT setting
+     */
+    public static boolean isVtEnabledByUser(Context context) {
+        return isVtEnabledByUser(context,getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of VT setting
+     */
+    public static boolean isVtEnabledByUser(Context context, int phoneId) {
+
+        int enabled = ImsConfig.FeatureValueConstants.OFF;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            enabled = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                    android.provider.Settings.Global.VT_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.ON);
+        } else {
+            enabled = getSettingValueByKey(context, VILTE_SETTING, phoneId);
+        }
+        return (enabled == 1) ? true : false;
+    }
+
+    /**
+     * Change persistent VT enabled setting
+     */
+    public static void setVtSetting(Context context, boolean enabled) {
+        setVtSetting(context, enabled,getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent VT enabled setting
+     */
+    public static void setVtSetting(Context context, boolean enabled, int phoneId) {
+        int value = enabled ? 1 : 0;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.VT_IMS_ENABLED, value);
+        } else {
+            setSettingValueByKey(context, VILTE_SETTING, value, phoneId);
+        }
+
+        ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+        if (imsManager != null) {
+            try {
+                ImsConfig config = imsManager.getConfigInterface();
+                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE,
+                        TelephonyManager.NETWORK_TYPE_LTE,
+                        enabled ? ImsConfig.FeatureValueConstants.ON
+                                : ImsConfig.FeatureValueConstants.OFF,
+                        imsManager.mImsConfigListener);
+
+                if (enabled) {
+                    log("setVtSetting() : turnOnIms");
+                    imsManager.turnOnIms();
+                } else if (isTurnOffImsAllowedByPlatform(context)
+                        && (!isVolteEnabledByPlatform(context)
+                        || !isEnhanced4gLteModeSettingEnabledByUser(context))) {
+                    log("setVtSetting() : imsServiceAllowTurnOff -> turnOffIms");
+                    imsManager.turnOffIms();
+                }
+            } catch (ImsException e) {
+                loge("setVtSetting(): ", e);
+            }
+        }
+    }
+
+    /*
+     * Returns whether turning off ims is allowed by platform.
+     * The platform property may override the carrier config.
+     */
+    private static boolean isTurnOffImsAllowedByPlatform(Context context) {
+        if (SystemProperties.getInt(PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE,
+                PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE_DEFAULT) == 1) {
+            return true;
+        }
+        return getBooleanCarrierConfig(context,
+                CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL);
+    }
+
+    /**
+     * Returns the user configuration of WFC setting
+     */
+    public static boolean isWfcEnabledByUser(Context context) {
+        return isWfcEnabledByUser(context,getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of WFC setting
+     */
+    public static boolean isWfcEnabledByUser(Context context, int phoneId) {
+
+        int enabled = ImsConfig.FeatureValueConstants.OFF;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        int isDefaultWFCIMSEnabledByCarrier =
+                getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL,phoneId) ?
+                        ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            enabled = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_ENABLED,
+                    isDefaultWFCIMSEnabledByCarrier);
+        } else {
+            enabled = getSettingValueByKey(context, WFC_SETTING, phoneId);
+        }
+
+        if (DBG) {
+            log("isWfcEnabledByUser(), phoneId=" + phoneId +
+                    " isDefaultWFCIMSEnabledByCarrier=" + isDefaultWFCIMSEnabledByCarrier +
+                    " enable=" + enabled);
+        }
+        return (enabled == 1) ? true : false;
+    }
+
+    /**
+     * Change persistent WFC enabled setting
+     */
+    public static void setWfcSetting(Context context, boolean enabled) {
+        setWfcSetting(context, enabled, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent WFC enabled setting
+     */
+    public static void setWfcSetting(Context context, boolean enabled, int phoneId) {
+        int value = enabled ? 1 : 0;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_ENABLED, value);
+        } else {
+            setSettingValueByKey(context, WFC_SETTING, value, phoneId);
+        }
+
+        ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+        if (imsManager != null) {
+            try {
+                ImsConfig config = imsManager.getConfigInterface();
+                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI,
+                        TelephonyManager.NETWORK_TYPE_IWLAN,
+                        enabled ? ImsConfig.FeatureValueConstants.ON
+                                : ImsConfig.FeatureValueConstants.OFF,
+                        imsManager.mImsConfigListener);
+
+                if (enabled) {
+                    log("setWfcSetting(): turnOnIms, phoneId:" + phoneId);
+                    imsManager.turnOnIms();
+                } else if (isTurnOffImsAllowedByPlatform(context)
+                        && (!isVolteEnabledByPlatform(context)
+                        || !isEnhanced4gLteModeSettingEnabledByUser(context))) {
+                    log("setWfcSetting(): turnOffIms, phoneId:" + phoneId);
+                    imsManager.turnOffIms();
+                }
+
+                // Force IMS to register over LTE when turning off WFC
+                setWfcModeInternal(context, enabled
+                        ? getWfcMode(context)
+                        : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED,
+                        phoneId);
+            } catch (ImsException e) {
+                loge("setWfcSetting(): ", e);
+            }
+        }
+    }
+
+    /**
+     * Returns the user configuration of WFC preference setting
+     */
+    public static int getWfcMode(Context context) {
+        return getWfcMode(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of WFC modem setting
+     */
+    public static int getWfcMode(Context context, int phoneId) {
+        int setting = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        int defaultWFCIMSModeByCarrier =
+                getIntCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT, phoneId);
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            setting = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_MODE,
+                    defaultWFCIMSModeByCarrier);
+        } else {
+            setting = getSettingValueByKey(context, WFC_MODE_SETTING, phoneId);
+        }
+
+        if (DBG) {
+            log("getWfcMode(), phoneId:" + phoneId +
+                    ", defaultWFCIMSModeByCarrier:" + defaultWFCIMSModeByCarrier +
+                    ", result:" + setting);
+        }
+        return setting;
+    }
+
+    /**
+     * Change persistent WFC preference setting
+     */
+    public static void setWfcMode(Context context, int wfcMode) {
+        setWfcMode(context, wfcMode, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent WFC preference setting (MIMS)
+     */
+    public static void setWfcMode(Context context, int wfcMode, int phoneId) {
+        if (DBG) log("setWfcMode(), wfcMode: " + wfcMode + ", phoneId:" + phoneId);
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_MODE, wfcMode);
+        } else {
+            setSettingValueByKey(context, WFC_MODE_SETTING, wfcMode, phoneId);
+        }
+
+        setWfcModeInternal(context, wfcMode, phoneId);
+    }
+
+    /**
+     * Returns the user configuration of WFC preference setting
+     *
+     * @param roaming {@code false} for home network setting, {@code true} for roaming  setting
+     */
+    public static int getWfcMode(Context context, boolean roaming) {
+        return getWfcMode(context, roaming, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of WFC preference setting (MIMS)
+     *
+     * @param roaming {@code false} for home network setting, {@code true} for roaming  setting
+     */
+    public static int getWfcMode(Context context, boolean roaming, int phoneId) {
+        int setting = 0;
+        if (!roaming) {
+            return getWfcMode(context, phoneId);
+        } else {
+            if (SystemProperties.getInt(MULTI_IMS_SUPPORT, 1) == 1) {
+                phoneId = getMainCapabilityPhoneId(context);
+            }
+
+            int defaultWFCIMSRoamingModeByCarrier =
+                getIntCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT, phoneId);
+
+            if (SystemProperties.getInt(MULTI_IMS_SUPPORT, 1) == 1) {
+                setting = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE,
+                        defaultWFCIMSRoamingModeByCarrier);
+            } else {
+                setting = getSettingValueByKey(context, WFC_ROAMING_MODE_SETTING, phoneId);
+            }
+
+            if (DBG) {
+                log("getWfcMode(), phoneId:" + phoneId +
+                        ", defaultWFCIMSRoamingModeByCarrier:" + defaultWFCIMSRoamingModeByCarrier +
+                        ", result:" + setting);
+            }
+        }
+        return setting;
+    }
+
+    /**
+     * Change persistent WFC preference setting
+     *
+     * @param roaming {@code false} for home network setting, {@code true} for roaming setting
+     */
+    public static void setWfcMode(Context context, int wfcMode, boolean roaming) {
+        setWfcMode(context, wfcMode, roaming, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent WFC preference setting (MIMS)
+     *
+     * @param roaming {@code false} for home network setting, {@code true} for roaming setting
+     */
+    public static void setWfcMode(Context context, int wfcMode, boolean roaming, int phoneId) {
+        if (DBG) log("setWfcMode(), wfcMode: " + wfcMode +
+                     ", roaming:" + roaming + ", phoneId:" + phoneId);
+
+        if (!roaming) {
+            setWfcMode(context, wfcMode, phoneId);
+        } else {
+            if (SystemProperties.getInt(MULTI_IMS_SUPPORT, 1) == 1) {
+                phoneId = getMainCapabilityPhoneId(context);
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, wfcMode);
+            } else {
+                setSettingValueByKey(context, WFC_ROAMING_MODE_SETTING, wfcMode, phoneId);
+            }
+        }
+
+        /* Currently UI only displays Calling preference and doesn't display roaming preference
+           UI always call setWfcMode(roaming == false). We chooses to make Calling preference work
+           both in home and roaming environment, so always set Calling preference to Modem
+
+        TelephonyManager tm = (TelephonyManager)
+                context.getSystemService(Context.TELEPHONY_SERVICE);
+        if (roaming == tm.isNetworkRoaming()) {
+            setWfcModeInternal(context, wfcMode, phoneId);
+        }
+        */
+        setWfcModeInternal(context, wfcMode, phoneId);
+    }
+
+    private static void setWfcModeInternal(Context context, int wfcMode) {
+        setWfcModeInternal(context, wfcMode, getMainCapabilityPhoneId(context));
+    }
+
+    private static void setWfcModeInternal(Context context, int wfcMode, int phoneId) {
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        final ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+        if (imsManager != null) {
+            final int value = wfcMode;
+            // Sync wifi preferred mode to modem instead of via provisioning.
+            try {
+                imsManager.getConfigInterface().setWfcMode(wfcMode);
+            } catch (ImsException e) {
+                // do nothing
+            }
+            Thread thread = new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        imsManager.getConfigInterface().setProvisionedValue(
+                                ImsConfig.ConfigConstants.VOICE_OVER_WIFI_MODE,
+                                value);
+                    } catch (ImsException e) {
+                        // do nothing
+                    }
+                }
+            });
+            thread.start();
+        }
+    }
+
+    /**
+     * Returns the user configuration of WFC roaming setting
+     */
+    public static boolean isWfcRoamingEnabledByUser(Context context) {
+        return isWfcRoamingEnabledByUser(context,getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns the user configuration of WFC roaming setting
+     */
+    public static boolean isWfcRoamingEnabledByUser(Context context, int phoneId) {
+
+        int enabled = ImsConfig.FeatureValueConstants.OFF;
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        int isRoamingEnableByCarrier =
+                getBooleanCarrierConfig(context,
+                        CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL,
+                        phoneId) ?
+                        ImsConfig.FeatureValueConstants.ON :
+                        ImsConfig.FeatureValueConstants.OFF;
+
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            enabled = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                   android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED,
+                   isRoamingEnableByCarrier);
+        } else {
+            enabled = getSettingValueByKey(context, WFC_ROAMING_SETTING, phoneId);
+        }
+
+        if (DBG) {
+            log("isWfcRoamingEnabledByUser(), phoneId=" + phoneId +
+                    " isRoamingEnableByCarrier=" + isRoamingEnableByCarrier +
+                    " enable=" + enabled);
+        }
+        return (enabled == 1) ? true : false;
+    }
+
+    /**
+     * Change persistent WFC roaming enabled setting
+     */
+    public static void setWfcRoamingSetting(Context context, boolean enabled) {
+        setWfcRoamingSetting(context, enabled, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Change persistent WFC roaming enabled setting
+     */
+    public static void setWfcRoamingSetting(Context context, boolean enabled, int phoneId) {
+        if (DBG) log("setWfcRoamingSetting(), enabled: " + enabled + ", phoneId:" + phoneId);
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED,
+                    enabled ? ImsConfig.FeatureValueConstants.ON
+                            : ImsConfig.FeatureValueConstants.OFF);
+        } else {
+            int value = enabled ? 1 : 0;
+
+            setSettingValueByKey(context, WFC_ROAMING_SETTING, value, phoneId);
+        }
+
+        setWfcRoamingSettingInternal(context, enabled, phoneId);
+    }
+
+    private static void setWfcRoamingSettingInternal(Context context, boolean enabled) {
+        setWfcRoamingSettingInternal(context, enabled, getMainCapabilityPhoneId(context));
+    }
+
+    private static void setWfcRoamingSettingInternal(Context context, boolean enabled,
+            int phoneId) {
+        final ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+        if (imsManager != null) {
+            final int value = enabled
+                    ? ImsConfig.FeatureValueConstants.ON
+                    : ImsConfig.FeatureValueConstants.OFF;
+            Thread thread = new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        imsManager.getConfigInterface().setProvisionedValue(
+                                ImsConfig.ConfigConstants.VOICE_OVER_WIFI_ROAMING,
+                                value);
+                    } catch (ImsException e) {
+                        // do nothing
+                    }
+                }
+            });
+            thread.start();
+        }
+    }
+
+    /**
+     * Returns a platform configuration for WFC which may override the user
+     * setting. Note: WFC presumes that VoLTE is enabled (these are
+     * configuration settings which must be done correctly).
+     */
+    public static boolean isWfcEnabledByPlatform(Context context) {
+        return isWfcEnabledByPlatform(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Returns a platform configuration for WFC which may override the user
+     * setting. Note: WFC presumes that VoLTE is enabled (these are
+     * configuration settings which must be done correctly).
+     */
+    public static boolean isWfcEnabledByPlatform(Context context, int phoneId) {
+        if (SystemProperties.getInt(PROPERTY_DBG_WFC_AVAIL_OVERRIDE,
+                PROPERTY_DBG_WFC_AVAIL_OVERRIDE_DEFAULT) == 1) {
+            return true;
+        }
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        /// M: Dynamic IMS Switch to support resource over multiple SIM.
+        boolean isResourceSupport = isImsResourceSupport(context,
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI,
+                phoneId);
+
+        /// M: isFeatureEnabledByPlatformExt: Extension for customize platform support status
+        return (SystemProperties.getInt("persist.mtk_wfc_support", 0) == 1) &&
+               (SystemProperties.getInt(LTE_SUPPORT, 0) == 1) &&
+               isResourceSupport &&
+               getBooleanCarrierConfig(context,
+                       CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL,phoneId) &&
+               isGbaValid(context,phoneId) &&
+               isFeatureEnabledByPlatformExt(context,
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI);
+    }
+
+    /**
+     * If carrier requires that IMS is only available if GBA capable SIM is used,
+     * then this function checks GBA bit in EF IST.
+     *
+     * Format of EF IST is defined in 3GPP TS 31.103 (Section 4.2.7).
+     */
+    private static boolean isGbaValid(Context context) {
+        return isGbaValid(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * If carrier requires that IMS is only available if GBA capable SIM is used,
+     * then this function checks GBA bit in EF IST.
+     *
+     * Format of EF IST is defined in 3GPP TS 31.103 (Section 4.2.7).
+     */
+    private static boolean isGbaValid(Context context, int phoneId) {
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+
+        if (getBooleanCarrierConfig(context,
+                CarrierConfigManager.KEY_CARRIER_IMS_GBA_REQUIRED_BOOL, phoneId)) {
+            IPhoneSubInfo iSubInfo = getSubscriberInfo();
+            String efIst = null;
+            try {
+                efIst = iSubInfo.getIsimIstForSubscriber(subId);
+            } catch (RemoteException ex) {
+                loge("remote expcetion for getIsimIstForSubscriber");
+            }
+
+            if (efIst == null) {
+                loge("ISF is NULL");
+                return true;
+            }
+            boolean result = efIst != null && efIst.length() > 1 &&
+                    (0x02 & (byte)efIst.charAt(1)) != 0;
+            if (DBG) log("GBA capable=" + result + ", ISF=" + efIst);
+            return result;
+        }
+        return true;
+    }
+
+    /**
+     * This function should be called when ImsConfig.ACTION_IMS_CONFIG_CHANGED is received.
+     *
+     * We cannot register receiver in ImsManager because this would lead to resource leak.
+     * ImsManager can be created in different processes and it is not notified when that process
+     * is about to be terminated.
+     *
+     * @hide
+     * */
+    public static void onProvisionedValueChanged(Context context, int item, String value) {
+        if (DBG) Rlog.d(TAG, "onProvisionedValueChanged: item=" + item + " val=" + value);
+        ImsManager mgr = ImsManager.getInstance(context,
+                SubscriptionManager.getDefaultVoicePhoneId());
+
+        switch (item) {
+            case ImsConfig.ConfigConstants.VLT_SETTING_ENABLED:
+                mgr.setVolteProvisionedProperty(value.equals("1"));
+                if (DBG) Rlog.d(TAG,"isVoLteProvisioned = " + mgr.isVolteProvisioned());
+                break;
+
+            case ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED:
+                mgr.setWfcProvisionedProperty(value.equals("1"));
+                if (DBG) Rlog.d(TAG,"isWfcProvisioned = " + mgr.isWfcProvisioned());
+                break;
+
+            case ImsConfig.ConfigConstants.LVC_SETTING_ENABLED:
+                mgr.setVtProvisionedProperty(value.equals("1"));
+                if (DBG) Rlog.d(TAG,"isVtProvisioned = " + mgr.isVtProvisioned());
+                break;
+
+        }
+    }
+
+    private class AsyncUpdateProvisionedValues extends AsyncTask<Void, Void, Void> {
+        @Override
+        protected Void doInBackground(Void... params) {
+            // disable on any error
+            setVolteProvisionedProperty(false);
+            setWfcProvisionedProperty(false);
+            setVtProvisionedProperty(false);
+
+            try {
+                ImsConfig config = getConfigInterface();
+                if (config != null) {
+                    setVolteProvisionedProperty(getProvisionedBool(config,
+                            ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
+                    if (DBG) Rlog.d(TAG, "isVoLteProvisioned = " + isVolteProvisioned());
+
+                    setWfcProvisionedProperty(getProvisionedBool(config,
+                            ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
+                    if (DBG) Rlog.d(TAG, "isWfcProvisioned = " + isWfcProvisioned());
+
+                    setVtProvisionedProperty(getProvisionedBool(config,
+                            ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
+                    if (DBG) Rlog.d(TAG, "isVtProvisioned = " + isVtProvisioned());
+
+                }
+            } catch (ImsException ie) {
+                Rlog.e(TAG, "AsyncUpdateProvisionedValues error: ", ie);
+            }
+
+            return null;
+        }
+
+        private boolean getProvisionedBool(ImsConfig config, int item) throws ImsException {
+            return config.getProvisionedValue(item) == ImsConfig.FeatureValueConstants.ON;
+        }
+    }
+
+    /** Asynchronously get VoLTE, WFC, VT provisioning statuses */
+    private void updateProvisionedValues() {
+        if (getBooleanCarrierConfig(mContext,
+                CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
+
+            new AsyncUpdateProvisionedValues().execute();
+        }
+    }
+
+    /**
+     * Sync carrier config and user settings with ImsConfig.
+     *
+     * @param context for the manager object
+     * @param phoneId phone id
+     * @param force update
+     */
+    public static void updateImsServiceConfig(Context context, int phoneId, boolean force) {
+        if (!force) {
+            if (TelephonyManager.getDefault().getSimState() != TelephonyManager.SIM_STATE_READY) {
+                log("updateImsServiceConfig: SIM not ready");
+                // Don't disable IMS if SIM is not ready
+                return;
+            }
+        }
+
+        final ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+        if (imsManager != null && (!imsManager.mConfigUpdated || force)) {
+            log("updateImsServiceConfig() phoneId: " + phoneId + " force: " + force);
+            try {
+                imsManager.updateProvisionedValues();
+
+                // TODO: Extend ImsConfig API and set all feature values in single function call.
+
+                // Note: currently the order of updates is set to produce different order of
+                // setFeatureValue() function calls from setAdvanced4GMode(). This is done to
+                // differentiate this code path from vendor code perspective.
+                boolean isImsUsed = imsManager.updateVolteFeatureValue();
+                isImsUsed |= imsManager.updateWfcFeatureAndProvisionedValues();
+                isImsUsed |= imsManager.updateVideoCallFeatureValue();
+
+                if (isImsUsed || !isTurnOffImsAllowedByPlatform(context)) {
+                    // Turn on IMS if it is used.
+                    // Also, if turning off is not allowed for current carrier,
+                    // we need to turn IMS on because it might be turned off before
+                    // phone switched to current carrier.
+                    log("updateImsServiceConfig: turnOnIms");
+                    imsManager.turnOnIms();
+                } else {
+                    // Turn off IMS if it is not used AND turning off is allowed for carrier.
+                    log("updateImsServiceConfig: turnOffIms");
+                    imsManager.turnOffIms();
+                }
+
+                imsManager.mConfigUpdated = true;
+            } catch (ImsException e) {
+                loge("updateImsServiceConfig: ", e);
+                imsManager.mConfigUpdated = false;
+            }
+        }
+    }
+
+    /**
+     * Update VoLTE config
+     * @return whether feature is On
+     * @throws ImsException
+     */
+    private boolean updateVolteFeatureValue() throws ImsException {
+        boolean available = isVolteEnabledByPlatform(mContext,mPhoneId);
+        boolean enabled = isEnhanced4gLteModeSettingEnabledByUser(mContext,mPhoneId);
+        boolean isNonTty = isNonTtyOrTtyOnVolteEnabled(mContext,mPhoneId);
+        boolean isFeatureOn = available && enabled && isNonTty;
+
+        log("updateVolteFeatureValue: available = " + available
+                + ", enabled = " + enabled
+                + ", nonTTY = " + isNonTty);
+
+        getConfigInterface().setFeatureValue(
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE,
+                TelephonyManager.NETWORK_TYPE_LTE,
+                isFeatureOn ?
+                        ImsConfig.FeatureValueConstants.ON :
+                        ImsConfig.FeatureValueConstants.OFF,
+                mImsConfigListener);
+
+        return isFeatureOn;
+    }
+
+    /**
+     * Update video call over LTE config
+     * @return whether feature is On
+     * @throws ImsException
+     */
+    private boolean updateVideoCallFeatureValue() throws ImsException {
+        boolean available = isVtEnabledByPlatform(mContext, mPhoneId);
+        boolean enabled = (isEnhanced4gLteModeSettingEnabledByUser(mContext,mPhoneId) || isWfcEnabledByUser(mContext,mPhoneId)) &&
+                isVtEnabledByUser(mContext, mPhoneId);
+        boolean isNonTty = isNonTtyOrTtyOnVolteEnabled(mContext, mPhoneId);
+        boolean isDataEnabled = isDataEnabled();
+
+        /// M: VILTE enable not dependent on data enable for some operators
+        boolean isNonDepOnData = getBooleanCarrierConfig(mContext,
+                CarrierConfigManager.KEY_VILTE_ENABLE_NOT_DEPENDENT_ON_DATA_ENABLE_BOOL, mPhoneId);
+        boolean isFeatureOn = false;
+        if (isTestSim(mContext, mPhoneId) || isNonDepOnData) {
+            isFeatureOn = available && enabled && isNonTty;
+        } else {
+            isFeatureOn = available && enabled && isNonTty && isDataEnabled;
+        }
+
+        log("updateVideoCallFeatureValue: available = " + available
+                + ", enabled = " + enabled
+                + ", nonTTY = " + isNonTty
+                + ", data enabled = " + isDataEnabled
+                + ", nonDepOnData = " + isNonDepOnData);
+
+        getConfigInterface().setFeatureValue(
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE,
+                TelephonyManager.NETWORK_TYPE_LTE,
+                isFeatureOn ?
+                        ImsConfig.FeatureValueConstants.ON :
+                        ImsConfig.FeatureValueConstants.OFF,
+                mImsConfigListener);
+
+        return isFeatureOn;
+    }
+
+    /**
+     * Update WFC config
+     * @return whether feature is On
+     * @throws ImsException
+     */
+    private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
+        boolean isNetworkRoaming = TelephonyManager.getDefault().isNetworkRoaming();
+        boolean available = isWfcEnabledByPlatform(mContext, mPhoneId);
+        boolean enabled = isWfcEnabledByUser(mContext, mPhoneId);
+        int mode = getWfcMode(mContext, isNetworkRoaming, mPhoneId);
+        boolean roaming = isWfcRoamingEnabledByUser(mContext, mPhoneId);
+        boolean isFeatureOn = available && enabled;
+
+        log("updateWfcFeatureAndProvisionedValues: available = " + available
+                + ", enabled = " + enabled
+                + ", mode = " + mode
+                + ", roaming = " + roaming
+                + ", mPhoneId = " + mPhoneId);
+
+        getConfigInterface().setFeatureValue(
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI,
+                TelephonyManager.NETWORK_TYPE_IWLAN,
+                isFeatureOn ?
+                        ImsConfig.FeatureValueConstants.ON :
+                        ImsConfig.FeatureValueConstants.OFF,
+                mImsConfigListener);
+
+        if (!isFeatureOn) {
+            mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
+            roaming = false;
+        }
+        setWfcModeInternal(mContext, mode, mPhoneId);
+        setWfcRoamingSettingInternal(mContext, roaming, mPhoneId);
+
+        return isFeatureOn;
+    }
+
+    private ImsManager(Context context, int phoneId) {
+        mContext = context;
+        mPhoneId = phoneId;
+        createImsService(true);
+        createTerminalApiServices();
+    }
+
+    private static IPhoneSubInfo getSubscriberInfo() {
+        // get it each time because that process crashes a lot
+        return IPhoneSubInfo.Stub.asInterface(ServiceManager.getService("iphonesubinfo"));
+    }
+
+    private static int getSettingValueByKey(Context context, String key, int phoneId) {
+
+        if(key.equals(VOLTE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM2,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM3,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM4,
+                        ImsConfig.FeatureValueConstants.ON);
+            }
+        } else if (key.equals(TTY_MODE)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return Settings.Secure.getInt(context.getContentResolver(),
+                        Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return Settings.Secure.getInt(context.getContentResolver(),
+                        Settings.Secure.PREFERRED_TTY_MODE_SIM2, TelecomManager.TTY_MODE_OFF);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return Settings.Secure.getInt(context.getContentResolver(),
+                        Settings.Secure.PREFERRED_TTY_MODE_SIM3, TelecomManager.TTY_MODE_OFF);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return Settings.Secure.getInt(context.getContentResolver(),
+                        Settings.Secure.PREFERRED_TTY_MODE_SIM4, TelecomManager.TTY_MODE_OFF);
+            }
+        } else if (key.equals(VILTE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM2,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM3,
+                        ImsConfig.FeatureValueConstants.ON);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM4,
+                        ImsConfig.FeatureValueConstants.ON);
+            }
+        } else if (key.equals(WFC_SETTING)) {
+            int isDefaultWFCIMSEnabledByCarrier =
+                    getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL,phoneId) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF;
+
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED,
+                        isDefaultWFCIMSEnabledByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM2,
+                        isDefaultWFCIMSEnabledByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM3,
+                        isDefaultWFCIMSEnabledByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM4,
+                        isDefaultWFCIMSEnabledByCarrier);
+            }
+        }else if (key.equals(WFC_MODE_SETTING)) {
+            int defaultWFCIMSModeByCarrier =
+                    getIntCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT, phoneId);
+
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE,
+                        defaultWFCIMSModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM2,
+                        defaultWFCIMSModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM3,
+                        defaultWFCIMSModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM4,
+                        defaultWFCIMSModeByCarrier);
+            }
+        } else if (key.equals(WFC_ROAMING_MODE_SETTING)) {
+            int defaultWFCIMSRoamingModeByCarrier =
+                getIntCarrierConfig(context,
+                    CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT, phoneId);
+
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE,
+                        defaultWFCIMSRoamingModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM2,
+                        defaultWFCIMSRoamingModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM3,
+                        defaultWFCIMSRoamingModeByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM4,
+                        defaultWFCIMSRoamingModeByCarrier);
+            }
+        } else if (key.equals(WFC_ROAMING_SETTING)) {
+            int isRoamingEnableByCarrier =
+                    getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL,
+                            phoneId) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF;
+
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED,
+                        isRoamingEnableByCarrier );
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM2,
+                        isRoamingEnableByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM3,
+                        isRoamingEnableByCarrier);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                return android.provider.Settings.Global.getInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM4,
+                        isRoamingEnableByCarrier);
+            }
+        }
+        return -1;
+    }
+
+    private static void setSettingValueByKey(Context context, String key, int value, int phoneId) {
+
+        if(key.equals(VOLTE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM2, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM3, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(
+                        context.getContentResolver(),
+                        android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED_SIM4, value);
+            }
+        } else if (key.equals(VILTE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM2, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM3, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.VT_IMS_ENABLED_SIM4, value);
+            }
+        } else if (key.equals(WFC_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM2, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM3, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ENABLED_SIM4, value);
+            }
+        } else if (key.equals(WFC_MODE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM2, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM3, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_MODE_SIM4, value);
+            }
+        } else if (key.equals(WFC_ROAMING_MODE_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM2, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM3, value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_MODE_SIM4, value);
+            }
+        } else if (key.equals(WFC_ROAMING_SETTING)) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED,
+                        value);
+            } else if (phoneId == PhoneConstants.SIM_ID_2) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM2,
+                        value);
+            } else if (phoneId == PhoneConstants.SIM_ID_3) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM3,
+                        value);
+            } else if (phoneId == PhoneConstants.SIM_ID_4) {
+                android.provider.Settings.Global.putInt(context.getContentResolver(),
+                        android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED_SIM4,
+                        value);
+            }
+        }
+    }
+
+    private void createTerminalApiServices()
+    {
+        Log.d(TAG, "createTerminalApiServices entry");
+        mCapabilitiesApi = new CapabilityService(mContext,
+                new MyServiceListener());
+        mCapabilitiesApi.connect();
+        mChatApi = new ChatService(mContext,
+                new MyServiceListener());
+        mChatApi.connect();
+        mContactsApi = new ContactsService(mContext,
+                new MyServiceListener());
+        mContactsApi.connect();
+        mFileTransferApi = new FileTransferService(mContext,
+                new MyServiceListener());
+        mFileTransferApi.connect();
+        mGeolocSharingApi = new GeolocSharingService(mContext,
+                new MyServiceListener());
+        mGeolocSharingApi.connect();
+        mImageSharingApi = new ImageSharingService(mContext,
+                new MyServiceListener());
+        mImageSharingApi.connect();
+        mVideoSharingApi = new VideoSharingService(mContext,
+                new MyServiceListener());
+        mVideoSharingApi.connect();
+    }
+
+    /**
+     * Returns a Capabilities Service Terminal API to client.
+     */
+    public CapabilityService getCapabilitiesService() {
+        return mCapabilitiesApi;
+    }
+
+    /**
+     * Returns a Chat Service Terminal API to client.
+     */
+    public ChatService getChatService() {
+        return mChatApi;
+    }
+
+    /**
+     * Returns a File Sharing Terminal API to client.
+     */
+    public FileTransferService getFileTransferService() {
+        return mFileTransferApi;
+    }
+
+    /**
+     * Returns a Contacts Service Terminal API to client.
+     */
+    public ContactsService getContactsService() {
+        return mContactsApi;
+    }
+
+    /**
+     * Returns a Geoloc Sharing Terminal API to client.
+     */
+    public GeolocSharingService getGeolocSharingService() {
+        return mGeolocSharingApi;
+    }
+
+    /**
+     * Returns a Image Sharing Terminal API to client.
+     */
+    public ImageSharingService getImageSharingService() {
+        return mImageSharingApi;
+    }
+
+    /**
+     * Returns a Video Sharing Terminal API to client.
+     */
+    public VideoSharingService getVideoSharingService() {
+        return mVideoSharingApi;
+    }
+
+    /**
+     * MyServiceListener listen to connect/disconnect service events.
+     */
+    public class MyServiceListener implements JoynServiceListener {
+
+        /**
+         * On service connected.
+         */
+        @Override
+        public void onServiceConnected() {
+            Log.d(TAG, "onServiceConnected entry ");
+        }
+
+        /**
+         * On service disconnected.
+         *
+         * @param error the error
+         */
+        @Override
+        public void onServiceDisconnected(int error) {
+            Log.d(TAG, "onServiceDisconnected entry " + error);
+        }
+
+    }
+
+    /*
+     * Returns a flag indicating whether the IMS service is available.
+     */
+    public boolean isServiceAvailable() {
+        if (mImsService != null) {
+            return true;
+        }
+
+        IBinder binder = ServiceManager.checkService(getImsServiceName(mPhoneId));
+        if (binder != null) {
+            return true;
+        }
+
+        return false;
+    }
+
+    public void setImsConfigListener(ImsConfigListener listener) {
+        mImsConfigListener = listener;
+    }
+
+    /**
+     * Opens the IMS service for making calls and/or receiving generic IMS calls.
+     * The caller may make subsquent calls through {@link #makeCall}.
+     * The IMS service will register the device to the operator's network with the credentials
+     * (from ISIM) periodically in order to receive calls from the operator's network.
+     * When the IMS service receives a new call, it will send out an intent with
+     * the provided action string.
+     * The intent contains a call ID extra {@link getCallId} and it can be used to take a call.
+     *
+     * @param serviceClass a service class specified in {@link ImsServiceClass}
+     *      For VoLTE service, it MUST be a {@link ImsServiceClass#MMTEL}.
+     * @param incomingCallPendingIntent When an incoming call is received,
+     *        the IMS service will call {@link PendingIntent#send(Context, int, Intent)} to
+     *        send back the intent to the caller with {@link #INCOMING_CALL_RESULT_CODE}
+     *        as the result code and the intent to fill in the call ID; It cannot be null
+     * @param listener To listen to IMS registration events; It cannot be null
+     * @return identifier (greater than 0) for the specified service
+     * @throws NullPointerException if {@code incomingCallPendingIntent}
+     *      or {@code listener} is null
+     * @throws ImsException if calling the IMS service results in an error
+     * @see #getCallId
+     * @see #getServiceId
+     */
+    public int open(int serviceClass, PendingIntent incomingCallPendingIntent,
+            ImsConnectionStateListener listener) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        /// M: add for debug @{
+        if (DBG) log("open: phoneId=" + mPhoneId);
+        /// @}
+
+        if (incomingCallPendingIntent == null) {
+            throw new NullPointerException("incomingCallPendingIntent can't be null");
+        }
+
+        if (listener == null) {
+            throw new NullPointerException("listener can't be null");
+        }
+
+        int result = 0;
+
+        try {
+            result = mImsService.open(mPhoneId, serviceClass, incomingCallPendingIntent,
+                    createRegistrationListenerProxy(serviceClass, listener));
+            if (DBG) log("open: result=" + result);
+        } catch (RemoteException e) {
+            throw new ImsException("open()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+
+        if (result <= 0) {
+            // If the return value is a minus value,
+            // it means that an error occurred in the service.
+            // So, it needs to convert to the reason code specified in ImsReasonInfo.
+            throw new ImsException("open()", (result * (-1)));
+        }
+
+        return result;
+    }
+
+    /**
+     * Adds registration listener to the IMS service.
+     *
+     * @param serviceClass a service class specified in {@link ImsServiceClass}
+     *      For VoLTE service, it MUST be a {@link ImsServiceClass#MMTEL}.
+     * @param listener To listen to IMS registration events; It cannot be null
+     * @throws NullPointerException if {@code listener} is null
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public void addRegistrationListener(int serviceClass, ImsConnectionStateListener listener)
+            throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        if (listener == null) {
+            throw new NullPointerException("listener can't be null");
+        }
+
+        try {
+            mImsService.addRegistrationListener(mPhoneId, serviceClass,
+                    createRegistrationListenerProxy(serviceClass, listener));
+        } catch (RemoteException e) {
+            throw new ImsException("addRegistrationListener()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * Closes the specified service ({@link ImsServiceClass}) not to make/receive calls.
+     * All the resources that were allocated to the service are also released.
+     *
+     * @param serviceId a service id to be closed which is obtained from {@link ImsManager#open}
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public void close(int serviceId) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        /// M: add for debug @{
+        if (DBG) log("close");
+        /// @}
+
+        try {
+            mImsService.close(serviceId);
+        } catch (RemoteException e) {
+            throw new ImsException("close()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        } finally {
+            mUt = null;
+            mConfig = null;
+            mEcbm = null;
+            mMultiEndpoint = null;
+        }
+    }
+
+    /**
+     * Gets the configuration interface to provision / withdraw the supplementary service settings.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @return the Ut interface instance
+     * @throws ImsException if getting the Ut interface results in an error
+     */
+    public ImsUtInterface getSupplementaryServiceConfiguration(int serviceId)
+            throws ImsException {
+        // FIXME: manage the multiple Ut interfaces based on the service id
+        if (mUt == null) {
+            checkAndThrowExceptionIfServiceUnavailable();
+
+            try {
+                IImsUt iUt = mImsService.getUtInterface(serviceId);
+
+                if (iUt == null) {
+                    throw new ImsException("getSupplementaryServiceConfiguration()",
+                            ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
+                }
+
+                mUt = new ImsUt(iUt);
+            } catch (RemoteException e) {
+                throw new ImsException("getSupplementaryServiceConfiguration()", e,
+                        ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+            }
+        }
+        /// M: @{
+        if (mUt != null) {
+            mUt.updateListener();
+        }
+        /// @}
+        return mUt;
+    }
+
+    /**
+     * Checks if the IMS service has successfully registered to the IMS network
+     * with the specified service & call type.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param serviceType a service type that is specified in {@link ImsCallProfile}
+     *        {@link ImsCallProfile#SERVICE_TYPE_NORMAL}
+     *        {@link ImsCallProfile#SERVICE_TYPE_EMERGENCY}
+     * @param callType a call type that is specified in {@link ImsCallProfile}
+     *        {@link ImsCallProfile#CALL_TYPE_VOICE_N_VIDEO}
+     *        {@link ImsCallProfile#CALL_TYPE_VOICE}
+     *        {@link ImsCallProfile#CALL_TYPE_VT}
+     *        {@link ImsCallProfile#CALL_TYPE_VS}
+     * @return true if the specified service id is connected to the IMS network;
+     *        false otherwise
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public boolean isConnected(int serviceId, int serviceType, int callType)
+            throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            return mImsService.isConnected(serviceId, serviceType, callType);
+        } catch (RemoteException e) {
+            throw new ImsException("isServiceConnected()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * Checks if the specified IMS service is opend.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @return true if the specified service id is opened; false otherwise
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public boolean isOpened(int serviceId) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            return mImsService.isOpened(serviceId);
+        } catch (RemoteException e) {
+            throw new ImsException("isOpened()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * Creates a {@link ImsCallProfile} from the service capabilities & IMS registration state.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param serviceType a service type that is specified in {@link ImsCallProfile}
+     *        {@link ImsCallProfile#SERVICE_TYPE_NONE}
+     *        {@link ImsCallProfile#SERVICE_TYPE_NORMAL}
+     *        {@link ImsCallProfile#SERVICE_TYPE_EMERGENCY}
+     * @param callType a call type that is specified in {@link ImsCallProfile}
+     *        {@link ImsCallProfile#CALL_TYPE_VOICE}
+     *        {@link ImsCallProfile#CALL_TYPE_VT}
+     *        {@link ImsCallProfile#CALL_TYPE_VT_TX}
+     *        {@link ImsCallProfile#CALL_TYPE_VT_RX}
+     *        {@link ImsCallProfile#CALL_TYPE_VT_NODIR}
+     *        {@link ImsCallProfile#CALL_TYPE_VS}
+     *        {@link ImsCallProfile#CALL_TYPE_VS_TX}
+     *        {@link ImsCallProfile#CALL_TYPE_VS_RX}
+     * @return a {@link ImsCallProfile} object
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public ImsCallProfile createCallProfile(int serviceId,
+            int serviceType, int callType) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            return mImsService.createCallProfile(serviceId, serviceType, callType);
+        } catch (RemoteException e) {
+            throw new ImsException("createCallProfile()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * Creates a {@link ImsCall} to make a call.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param profile a call profile to make the call
+     *      (it contains service type, call type, media information, etc.)
+     * @param participants participants to invite the conference call
+     * @param listener listen to the call events from {@link ImsCall}
+     * @return a {@link ImsCall} object
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public ImsCall makeCall(int serviceId, ImsCallProfile profile, String[] callees,
+            ImsCall.Listener listener) throws ImsException {
+        if (DBG) {
+            log("makeCall :: serviceId=" + serviceId
+                    + ", profile=" + profile);
+        }
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        ImsCall call = new ImsCall(mContext, profile);
+
+        call.setListener(listener);
+        ImsCallSession session = createCallSession(serviceId, profile);
+
+        if ((callees != null) && (callees.length == 1) &&
+                /// M:  For VoLTE enhanced conference call. @{
+                !profile.getCallExtraBoolean(ImsCallProfile.EXTRA_CONFERENCE)) {
+                /// @}
+            call.start(session, callees[0]);
+        } else {
+            call.start(session, callees);
+        }
+
+        return call;
+    }
+
+    /**
+     * Creates a {@link ImsCall} to take an incoming call.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @param listener to listen to the call events from {@link ImsCall}
+     * @return a {@link ImsCall} object
+     * @throws ImsException if calling the IMS service results in an error
+     */
+    public ImsCall takeCall(int serviceId, Intent incomingCallIntent,
+            ImsCall.Listener listener) throws ImsException {
+        if (DBG) {
+            log("takeCall :: serviceId=" + serviceId
+                    + ", incomingCall=" + incomingCallIntent);
+        }
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        if (incomingCallIntent == null) {
+            throw new ImsException("Can't retrieve session with null intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        int incomingServiceId = getServiceId(incomingCallIntent);
+
+        if (serviceId != incomingServiceId) {
+            throw new ImsException("Service id is mismatched in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        String callId = getCallId(incomingCallIntent);
+
+        if (callId == null) {
+            throw new ImsException("Call ID missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        try {
+            IImsCallSession session = mImsService.getPendingCallSession(serviceId, callId);
+
+            if (session == null) {
+                throw new ImsException("No pending session for the call",
+                        ImsReasonInfo.CODE_LOCAL_NO_PENDING_CALL);
+            }
+
+            /// M: ALPS03555072,if the MT already terminated, do not notify call info to UI. @{
+            if (ImsCallSession.State.TERMINATED == session.getState() ||
+                    ImsCallSession.State.INVALID == session.getState()) {
+                throw new ImsException("The Call already terminated",
+                        ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED);
+            }
+            /// @}
+
+            ImsCall call = new ImsCall(mContext, session.getCallProfile());
+
+            call.attachSession(new ImsCallSession(session));
+            call.setListener(listener);
+
+            return call;
+        } catch (Throwable t) {
+            throw new ImsException("takeCall()", t, ImsReasonInfo.CODE_UNSPECIFIED);
+        }
+    }
+
+    /**
+     * Gets the config interface to get/set service/capability parameters.
+     *
+     * @return the ImsConfig instance.
+     * @throws ImsException if getting the setting interface results in an error.
+     */
+    public ImsConfig getConfigInterface() throws ImsException {
+
+        /// M: Remove cache of ImsConfig in AOSP, always get ImsConfig with mainCapability Id
+        // TODO: Follow AOSP, sync feature value with partial single instance in ImsConfig DB
+//      if (mConfig == null) {
+        /// @}
+            checkAndThrowExceptionIfServiceUnavailable();
+
+            try {
+                IImsConfig config = mImsService.getConfigInterface(mPhoneId);
+                if (config == null) {
+                    throw new ImsException("getConfigInterface()",
+                            ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
+                }
+                mConfig = new ImsConfig(config, mContext);
+            } catch (RemoteException e) {
+                throw new ImsException("getConfigInterface()", e,
+                        ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+            }
+//      }
+        if (DBG) log("getConfigInterface(), mConfig= " + mConfig);
+        return mConfig;
+    }
+
+    public void setUiTTYMode(Context context, int serviceId, int uiTtyMode, Message onComplete)
+            throws ImsException {
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        int phoneId = serviceId -1;
+        try {
+            mImsService.setUiTTYMode(serviceId, uiTtyMode, onComplete);
+        } catch (RemoteException e) {
+            throw new ImsException("setTTYMode()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+
+        if (!getBooleanCarrierConfig(context,
+                CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL,phoneId)) {
+            log("TTY over VoLTE not supported, ttyMode=" + uiTtyMode);
+            setAdvanced4GMode((uiTtyMode == TelecomManager.TTY_MODE_OFF) &&
+                    isEnhanced4gLteModeSettingEnabledByUser(context,phoneId));
+        }
+    }
+
+    /**
+     * Get the boolean config from carrier config manager.
+     *
+     * @param context the context to get carrier service
+     * @param key config key defined in CarrierConfigManager
+     * @return boolean value of corresponding key.
+     */
+    private static boolean getBooleanCarrierConfig(Context context, String key) {
+        return getBooleanCarrierConfig(context,key,
+                getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Get the boolean config for sub id from carrier config manager.
+     *
+     * @param context the context to get carrier service
+     * @param key config key defined in CarrierConfigManager
+     * @param phoneId phone id
+     * @return boolean value of corresponding key.
+     */
+    private static boolean getBooleanCarrierConfig(Context context, String key, int phoneId) {
+        CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(
+                Context.CARRIER_CONFIG_SERVICE);
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        log("getBooleanCarrierConfig: phoneId=" + phoneId + " subId=" + subId);
+        PersistableBundle b = null;
+        if (configManager != null) {
+            b = configManager.getConfigForSubId(subId);
+        }
+        if (b != null) {
+            return b.getBoolean(key);
+        } else {
+            // Return static default defined in CarrierConfigManager.
+            return CarrierConfigManager.getDefaultConfig().getBoolean(key);
+        }
+    }
+
+    /**
+     * Get the int config from carrier config manager.
+     *
+     * @param context the context to get carrier service
+     * @param key config key defined in CarrierConfigManager
+     * @return integer value of corresponding key.
+     */
+    private static int getIntCarrierConfig(Context context, String key) {
+        return getIntCarrierConfig(context, key,
+                getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Get the int config for sub id from carrier config manager.
+     *
+     * @param context the context to get carrier service
+     * @param key config key defined in CarrierConfigManager
+     * @param phoneId phone id
+     * @return boolean value of corresponding key.
+     */
+    private static int getIntCarrierConfig(Context context, String key, int phoneId) {
+        CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(
+                Context.CARRIER_CONFIG_SERVICE);
+        PersistableBundle b = null;
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        log("getIntCarrierConfig: phoneId=" + phoneId + " subId=" + subId);
+
+        if (configManager != null) {
+            b = configManager.getConfigForSubId(subId);
+        }
+        if (b != null) {
+            return b.getInt(key);
+        } else {
+            // Return static default defined in CarrierConfigManager.
+            return CarrierConfigManager.getDefaultConfig().getInt(key);
+        }
+    }
+
+    /**
+     * Gets the call ID from the specified incoming call broadcast intent.
+     *
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @return the call ID or null if the intent does not contain it
+     */
+    private static String getCallId(Intent incomingCallIntent) {
+        if (incomingCallIntent == null) {
+            return null;
+        }
+
+        return incomingCallIntent.getStringExtra(EXTRA_CALL_ID);
+    }
+
+    /**
+     * Gets the call Num from the specified incoming call broadcast intent.
+     *
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @return the call Num or null if the intent does not contain it
+     */
+    private static String getCallNum(Intent incomingCallIntent) {
+        if (incomingCallIntent == null) {
+            return null;
+        }
+
+        return incomingCallIntent.getStringExtra(EXTRA_DIAL_STRING);
+    }
+
+    /**
+     * Gets the sequence number from the specified incoming call broadcast intent.
+     *
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @return the sequence number or null if the intent does not contain it
+     * @hide
+     */
+    private static int getSeqNum(Intent incomingCallIntent) {
+        if (incomingCallIntent == null) {
+            return (-1);
+        }
+
+        return incomingCallIntent.getIntExtra(EXTRA_SEQ_NUM, -1);
+    }
+
+    /**
+     * Gets the service type from the specified incoming call broadcast intent.
+     *
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @return the service identifier or -1 if the intent does not contain it
+     */
+    private static int getServiceId(Intent incomingCallIntent) {
+        if (incomingCallIntent == null) {
+            return (-1);
+        }
+
+        return incomingCallIntent.getIntExtra(EXTRA_SERVICE_ID, -1);
+    }
+
+    /**
+     * Binds the IMS service only if the service is not created.
+     */
+    private void checkAndThrowExceptionIfServiceUnavailable()
+            throws ImsException {
+        if (mImsService == null) {
+            createImsService(true);
+
+            if (mImsService == null) {
+                throw new ImsException("Service is unavailable",
+                        ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+            }
+        }
+    }
+
+    private static String getImsServiceName(int phoneId) {
+        // Due to We only has one ImsService, we always return the value no matter which SIM.
+        return IMS_SERVICE;
+    }
+
+    /**
+     * Binds the IMS service to make/receive the call.
+     */
+    private void createImsService(boolean checkService) {
+        if (checkService) {
+            IBinder binder = ServiceManager.checkService(getImsServiceName(mPhoneId));
+
+            if (binder == null) {
+                /// M: add for debug @{
+                if (DBG) log("createImsService binder is null");
+                /// @}
+                return;
+            }
+        }
+
+        IBinder b = ServiceManager.getService(getImsServiceName(mPhoneId));
+
+        if (b != null) {
+            try {
+                b.linkToDeath(mDeathRecipient, 0);
+            } catch (RemoteException e) {
+            }
+        }
+
+        mImsService = IImsService.Stub.asInterface(b);
+        /// M: add for debug @{
+        if (DBG) log("mImsService = " + mImsService);
+        /// @}
+    }
+
+    /**
+     * Creates a {@link ImsCallSession} with the specified call profile.
+     * Use other methods, if applicable, instead of interacting with
+     * {@link ImsCallSession} directly.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param profile a call profile to make the call
+     */
+    private ImsCallSession createCallSession(int serviceId,
+            ImsCallProfile profile) throws ImsException {
+        try {
+            return new ImsCallSession(mImsService.createCallSession(serviceId, profile, null));
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    private ImsRegistrationListenerProxy createRegistrationListenerProxy(int serviceClass,
+            ImsConnectionStateListener listener) {
+        ImsRegistrationListenerProxy proxy =
+                new ImsRegistrationListenerProxy(serviceClass, listener);
+        return proxy;
+    }
+
+    private static void log(String s) {
+        Rlog.d(TAG, s);
+    }
+
+    private static void logw(String s) {
+        Rlog.w(TAG, s);
+    }
+
+    private static void loge(String s) {
+        Rlog.e(TAG, s);
+    }
+
+    private static void loge(String s, Throwable t) {
+        Rlog.e(TAG, s, t);
+    }
+
+    /**
+     * Used for turning on IMS.if its off already
+     */
+    private void turnOnIms() throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            mImsService.turnOnIms(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("turnOnIms() ", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    private boolean isImsTurnOffAllowed() {
+        log("CarrierConfig:" + getBooleanCarrierConfig(mContext,
+                CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL,mPhoneId) +
+                " wfcendablebyplateform:" + isWfcEnabledByPlatform(mContext) +
+                " wfcenablebyUser:" + isWfcEnabledByUser(mContext));
+        return isTurnOffImsAllowedByPlatform(mContext)
+                && (!isWfcEnabledByPlatform(mContext)
+                || !isWfcEnabledByUser(mContext,mPhoneId));
+    }
+
+    private void setLteFeatureValues(boolean turnOn) {
+        log("setLteFeatureValues: " + turnOn);
+        try {
+            ImsConfig config = getConfigInterface();
+            if (config != null) {
+                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE,
+                        TelephonyManager.NETWORK_TYPE_LTE, turnOn ? 1 : 0, mImsConfigListener);
+
+                if (isVtEnabledByPlatform(mContext, mPhoneId)) {
+                    /// M: VILTE enable not dependent on data enable for some operators
+                    boolean isNonDepOnData = getBooleanCarrierConfig(mContext,
+                        CarrierConfigManager.KEY_VILTE_ENABLE_NOT_DEPENDENT_ON_DATA_ENABLE_BOOL);
+                    boolean enableViLte = false;
+                    if (isNonDepOnData) {
+                        enableViLte = turnOn && isVtEnabledByUser(mContext, mPhoneId);
+                    } else {
+                        enableViLte = turnOn && isVtEnabledByUser(mContext, mPhoneId) &&
+                                isDataEnabled();
+                    }
+                    config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE,
+                            TelephonyManager.NETWORK_TYPE_LTE,
+                            enableViLte ? 1 : 0,
+                            mImsConfigListener);
+                }
+            }
+        } catch (ImsException e) {
+            loge("setLteFeatureValues: exception ", e);
+        }
+    }
+
+    private void setAdvanced4GMode(boolean turnOn) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        // if turnOn: first set feature values then call turnOnIms()
+        // if turnOff: only set feature values if IMS turn off is not allowed. If turn off is
+        // allowed, first call turnOffIms() then set feature values
+        if (turnOn) {
+            setLteFeatureValues(turnOn);
+            log("setAdvanced4GMode: turnOnIms");
+            turnOnIms();
+        } else {
+            if (isImsTurnOffAllowed()) {
+                log("setAdvanced4GMode: turnOffIms");
+                turnOffIms();
+            }
+            setLteFeatureValues(turnOn);
+        }
+    }
+
+    /**
+     * Used for turning off IMS completely in order to make the device CSFB'ed.
+     * Once turned off, all calls will be over CS.
+     */
+    private void turnOffIms() throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            mImsService.turnOffIms(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("turnOffIms() ", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * Death recipient class for monitoring IMS service.
+     */
+    private class ImsServiceDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            mImsService = null;
+            mUt = null;
+            mConfig = null;
+            mEcbm = null;
+            mMultiEndpoint = null;
+
+            if (mContext != null) {
+                Intent intent = new Intent(ACTION_IMS_SERVICE_DOWN);
+                intent.putExtra(EXTRA_PHONE_ID, mPhoneId);
+                mContext.sendBroadcast(new Intent(intent));
+            }
+        }
+    }
+
+    /**
+     * Adapter class for {@link IImsRegistrationListener}.
+     */
+    private class ImsRegistrationListenerProxy extends IImsRegistrationListener.Stub {
+        private int mServiceClass;
+        private ImsConnectionStateListener mListener;
+
+        public ImsRegistrationListenerProxy(int serviceClass,
+                ImsConnectionStateListener listener) {
+            mServiceClass = serviceClass;
+            mListener = listener;
+        }
+
+        public boolean isSameProxy(int serviceClass) {
+            return (mServiceClass == serviceClass);
+        }
+
+        @Deprecated
+        public void registrationConnected() {
+            if (DBG) {
+                log("registrationConnected ::");
+            }
+
+            if (mListener != null) {
+                mListener.onImsConnected();
+            }
+        }
+
+        @Deprecated
+        public void registrationProgressing() {
+            if (DBG) {
+                log("registrationProgressing ::");
+            }
+
+            if (mListener != null) {
+                mListener.onImsProgressing();
+            }
+        }
+
+        @Override
+        public void registrationConnectedWithRadioTech(int imsRadioTech) {
+            // Note: imsRadioTech value maps to RIL_RADIO_TECHNOLOGY
+            //       values in ServiceState.java.
+            if (DBG) {
+                log("registrationConnectedWithRadioTech :: imsRadioTech=" + imsRadioTech);
+            }
+
+            if (mListener != null) {
+                mListener.onImsConnected();
+            }
+        }
+
+        @Override
+        public void registrationProgressingWithRadioTech(int imsRadioTech) {
+            // Note: imsRadioTech value maps to RIL_RADIO_TECHNOLOGY
+            //       values in ServiceState.java.
+            if (DBG) {
+                log("registrationProgressingWithRadioTech :: imsRadioTech=" + imsRadioTech);
+            }
+
+            if (mListener != null) {
+                mListener.onImsProgressing();
+            }
+        }
+
+        @Override
+        public void registrationDisconnected(ImsReasonInfo imsReasonInfo) {
+            if (DBG) {
+                log("registrationDisconnected :: imsReasonInfo" + imsReasonInfo);
+            }
+
+            if (mListener != null) {
+                mListener.onImsDisconnected(imsReasonInfo);
+            }
+        }
+
+        @Override
+        public void registrationResumed() {
+            if (DBG) {
+                log("registrationResumed ::");
+            }
+
+            if (mListener != null) {
+                mListener.onImsResumed();
+            }
+        }
+
+        @Override
+        public void registrationSuspended() {
+            if (DBG) {
+                log("registrationSuspended ::");
+            }
+
+            if (mListener != null) {
+                mListener.onImsSuspended();
+            }
+        }
+
+        @Override
+        public void registrationServiceCapabilityChanged(int serviceClass, int event) {
+            log("registrationServiceCapabilityChanged :: serviceClass=" +
+                    serviceClass + ", event=" + event);
+
+            /// M: protect AOSP logic by add event type checking
+            if (mListener != null && event == SERVICE_REG_CAPABILITY_EVENT_ADDED) {
+                mListener.onImsConnected();
+            }
+            /// M: There is no use of this callback, Now, extend IMS emergency capability
+            /// event here. @{
+            if (mListener != null && event == SERVICE_REG_CAPABILITY_EVENT_ECC_SUPPORT) {
+                mListener.onImsEmergencyCapabilityChanged(true);
+            }
+            if (mListener != null && event == SERVICE_REG_CAPABILITY_EVENT_ECC_NOT_SUPPORT) {
+                mListener.onImsEmergencyCapabilityChanged(false);
+            }
+            /// @}
+        }
+
+        @Override
+        public void registrationFeatureCapabilityChanged(int serviceClass,
+                int[] enabledFeatures, int[] disabledFeatures) {
+            log("registrationFeatureCapabilityChanged :: serviceClass=" +
+                    serviceClass);
+            if (mListener != null) {
+                mListener.onFeatureCapabilityChanged(serviceClass,
+                        enabledFeatures, disabledFeatures);
+            }
+        }
+
+        @Override
+        public void voiceMessageCountUpdate(int count) {
+            log("voiceMessageCountUpdate :: count=" + count);
+
+            if (mListener != null) {
+                mListener.onVoiceMessageCountChanged(count);
+            }
+        }
+
+        @Override
+        public void registrationAssociatedUriChanged(Uri[] uris) {
+            if (DBG) log("registrationAssociatedUriChanged ::");
+
+            if (mListener != null) {
+                mListener.registrationAssociatedUriChanged(uris);
+            }
+        }
+    }
+
+    /**
+     * Gets the ECBM interface to request ECBM exit.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @return the ECBM interface instance
+     * @throws ImsException if getting the ECBM interface results in an error
+     */
+    public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
+        if (mEcbm == null) {
+            checkAndThrowExceptionIfServiceUnavailable();
+
+            try {
+                IImsEcbm iEcbm = mImsService.getEcbmInterface(serviceId);
+
+                if (iEcbm == null) {
+                    throw new ImsException("getEcbmInterface()",
+                            ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
+                }
+                mEcbm = new ImsEcbm(iEcbm);
+            } catch (RemoteException e) {
+                throw new ImsException("getEcbmInterface()", e,
+                        ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+            }
+        }
+        return mEcbm;
+    }
+
+    /**
+     * Gets the Multi-Endpoint interface to subscribe to multi-enpoint notifications..
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @return the multi-endpoint interface instance
+     * @throws ImsException if getting the multi-endpoint interface results in an error
+     */
+    public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
+        if (mMultiEndpoint == null) {
+            checkAndThrowExceptionIfServiceUnavailable();
+
+            try {
+                IImsMultiEndpoint iImsMultiEndpoint = mImsService.getMultiEndpointInterface(
+                        serviceId);
+
+                if (iImsMultiEndpoint == null) {
+                    throw new ImsException("getMultiEndpointInterface()",
+                            ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
+                }
+                mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
+            } catch (RemoteException e) {
+                throw new ImsException("getMultiEndpointInterface()", e,
+                        ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+            }
+        }
+        return mMultiEndpoint;
+    }
+
+    /**
+     * Resets ImsManager settings back to factory defaults.
+     *
+     * @hide
+     */
+    public static void factoryReset(Context context) {
+        factoryReset(context, getMainCapabilityPhoneId(context));
+    }
+
+    /**
+     * Resets ImsManager settings back to factory defaults for
+     * specific phone when MIMS is supported
+     *
+     * @hide
+     */
+    public static void factoryReset(Context context, int phoneId) {
+
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT,1) == 1) {
+            // Set VoLTE to default
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED,
+                    (SystemProperties.get("persist.mtk_ct_volte_support").equals("1") &&
+                    !getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_DEFAULT_ENHANCED_4G_MODE_ENABLED_BOOL)) ?
+                            ImsConfig.FeatureValueConstants.OFF :
+                            ImsConfig.FeatureValueConstants.ON);
+
+            // Set VoWiFi to default
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_ENABLED,
+                    getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF);
+
+            // Set VoWiFi mode to default
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_MODE,
+                    getIntCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
+
+            // Set VoWiFi roaming to default
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED,
+                    getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF);
+
+            // Set VT to default
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.VT_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.ON);
+
+            // Push settings to ImsConfig
+            ImsManager.updateImsServiceConfig(context,
+                    getMainCapabilityPhoneId(context), true);
+        } else {
+            // Set VoLTE to default
+            int defaultValue = (SystemProperties.get("persist.mtk_ct_volte_support").equals("1") &&
+                    !getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_DEFAULT_ENHANCED_4G_MODE_ENABLED_BOOL,
+                            phoneId)) ?
+                            ImsConfig.FeatureValueConstants.OFF :
+                            ImsConfig.FeatureValueConstants.ON;
+            setSettingValueByKey(context, VOLTE_SETTING,
+                    defaultValue, phoneId);
+
+            // Set VoWiFi to default
+            defaultValue = getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL,
+                            phoneId) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF;
+            setSettingValueByKey(context, WFC_SETTING, defaultValue, phoneId);
+
+            // Set VoWiFi mode to default
+            defaultValue = getIntCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT,
+                            phoneId);
+            setSettingValueByKey(context, WFC_MODE_SETTING, defaultValue, phoneId);
+
+            // Set VoWiFi roaming to default
+            defaultValue = getBooleanCarrierConfig(context,
+                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL,
+                            phoneId) ?
+                            ImsConfig.FeatureValueConstants.ON :
+                            ImsConfig.FeatureValueConstants.OFF;
+            setSettingValueByKey(context, WFC_ROAMING_SETTING, defaultValue, phoneId);
+
+           // Set VT to default
+            setSettingValueByKey(context, VILTE_SETTING,
+                    ImsConfig.FeatureValueConstants.ON, phoneId);
+
+            ImsManager.updateImsServiceConfig(context, phoneId, true);
+        }
+    }
+
+    private boolean isDataEnabled() {
+        return SystemProperties.getBoolean(DATA_ENABLED_PROP[mPhoneId], true);
+    }
+
+    /**
+     * Set data enabled/disabled flag.
+     * @param enabled True if data is enabled, otherwise disabled.
+     */
+    public void setDataEnabled(boolean enabled) {
+        log("[" + mPhoneId + "] setDataEnabled: " + enabled);
+        SystemProperties.set(DATA_ENABLED_PROP[mPhoneId], enabled ? TRUE : FALSE);
+    }
+
+    private boolean isVolteProvisioned() {
+        return SystemProperties.getBoolean(VOLTE_PROVISIONED_PROP, true);
+    }
+
+    private void setVolteProvisionedProperty(boolean provisioned) {
+        SystemProperties.set(VOLTE_PROVISIONED_PROP, provisioned ? TRUE : FALSE);
+    }
+
+    private boolean isWfcProvisioned() {
+        return SystemProperties.getBoolean(WFC_PROVISIONED_PROP, true);
+    }
+
+    private void setWfcProvisionedProperty(boolean provisioned) {
+        SystemProperties.set(WFC_PROVISIONED_PROP, provisioned ? TRUE : FALSE);
+    }
+
+    private boolean isVtProvisioned() {
+        return SystemProperties.getBoolean(VT_PROVISIONED_PROP, true);
+    }
+
+    private void setVtProvisionedProperty(boolean provisioned) {
+        SystemProperties.set(VT_PROVISIONED_PROP, provisioned ? TRUE : FALSE);
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("ImsManager:");
+        pw.println("  mPhoneId = " + mPhoneId);
+        pw.println("  mConfigUpdated = " + mConfigUpdated);
+        pw.println("  mImsService = " + mImsService);
+        pw.println("  mDataEnabled = " + isDataEnabled());
+
+        pw.println("  isGbaValid = " + isGbaValid(mContext));
+        pw.println("  isImsTurnOffAllowed = " + isImsTurnOffAllowed());
+        pw.println("  isNonTtyOrTtyOnVolteEnabled = " + isNonTtyOrTtyOnVolteEnabled(mContext));
+
+        pw.println("  isVolteEnabledByPlatform = " + isVolteEnabledByPlatform(mContext));
+        pw.println("  isVolteProvisionedOnDevice = " + isVolteProvisionedOnDevice(mContext));
+        pw.println("  isEnhanced4gLteModeSettingEnabledByUser = " +
+                isEnhanced4gLteModeSettingEnabledByUser(mContext));
+        pw.println("  isVtEnabledByPlatform = " + isVtEnabledByPlatform(mContext));
+        pw.println("  isVtEnabledByUser = " + isVtEnabledByUser(mContext));
+
+        pw.println("  isWfcEnabledByPlatform = " + isWfcEnabledByPlatform(mContext));
+        pw.println("  isWfcEnabledByUser = " + isWfcEnabledByUser(mContext));
+        pw.println("  getWfcMode = " + getWfcMode(mContext));
+        pw.println("  isWfcRoamingEnabledByUser = " + isWfcRoamingEnabledByUser(mContext));
+
+        pw.println("  isVtProvisionedOnDevice = " + isVtProvisionedOnDevice(mContext));
+        pw.println("  isWfcProvisionedOnDevice = " + isWfcProvisionedOnDevice(mContext));
+        pw.flush();
+    }
+
+    /**
+     * To Allow or refuse incoming call indication to send to App.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param incomingCallIndication the incoming call broadcast intent.
+     * @param isAllow to indication to allow or refuse the incoming call indication.
+     * @throws ImsException if set call indication results in an error.
+     * @hide
+     */
+    public void setCallIndication(int serviceId, Intent incomingCallIndication,
+            boolean isAllow) throws ImsException {
+        if (DBG) {
+            log("setCallIndication :: serviceId=" + serviceId
+                    + ", incomingCallIndication=" + incomingCallIndication);
+        }
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        if (incomingCallIndication == null) {
+            throw new ImsException("Can't retrieve session with null intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        int incomingServiceId = getServiceId(incomingCallIndication);
+
+        if (serviceId != incomingServiceId) {
+            throw new ImsException("Service id is mismatched in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        String callId = getCallId(incomingCallIndication);
+
+        if (callId == null) {
+            throw new ImsException("Call ID missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        String callNum = getCallNum(incomingCallIndication);
+
+        if (callNum == null) {
+            throw new ImsException("Call Num missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        int seqNum = getSeqNum(incomingCallIndication);
+
+        if (seqNum == -1) {
+            throw new ImsException("seqNum missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        try {
+            mImsService.setCallIndication(serviceId, callId, callNum, seqNum, isAllow);
+        } catch (RemoteException e) {
+            throw new ImsException("setCallIndication()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * To get IMS state.
+     *
+     * @return ims state - disabled, enabling, enable, disabling.
+     * @throws ImsException if getting the ims status result in an error.
+     * @hide
+     */
+    public int getImsState() throws ImsException {
+        int imsState = PhoneConstants.IMS_STATE_DISABLED;
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            imsState = mImsService.getImsState(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("getImsState()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return imsState;
+    }
+
+    /**
+    * To get IMS registration status.
+    *
+    * @return true if ims is registered or false if ims is unregistered.
+    * @throws ImsException if getting the ims registration result in an error.
+    * @hide
+    */
+    public boolean getImsRegInfo() throws ImsException {
+        boolean isImsReg = false;
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            isImsReg = mImsService.getImsRegInfo(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("getImsRegInfo", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return isImsReg;
+    }
+
+    /**
+    * To get IMS registration extension information.
+    *
+    * @return a string which is converted from the value of ims feature capability.
+    * @throws ImsException if getting the ims extension information result in an error.
+    * @hide
+    */
+    public String getImsExtInfo() throws ImsException {
+        String imsExtInfo = "0";
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            imsExtInfo = mImsService.getImsExtInfo(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("getImsExtInfo()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return imsExtInfo;
+    }
+
+    /**
+    * To get multiple IMS modem support count.
+    *
+    * @return integer indicate the platform MD support how many IMS protocols.
+    * 1: single IMS, 2 and more indicate multiple IMS. Other means error
+    * @throws ImsException if getting the ims extension information result in an error.
+    * @hide
+    */
+    public static int getModemMultiImsCount(Context context) throws ImsException {
+        ImsManager im = getInstance(context, getMainCapabilityPhoneId(context));
+        return im.getMultiImsCount();
+    }
+
+    protected int getMultiImsCount() throws ImsException {
+        int multiImsCount;
+        checkAndThrowExceptionIfServiceUnavailable();
+        try {
+            multiImsCount = mImsService.getModemMultiImsCount();
+        } catch (RemoteException e) {
+            throw new ImsException("getModemMultiImsCount()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return multiImsCount;
+    }
+
+    /**
+    * To hangup all calls.
+    * @throws ImsException if getting the ims status result in an error.
+    * @hide
+    */
+    public void hangupAllCall() throws ImsException {
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            mImsService.hangupAllCall();
+        } catch (RemoteException e) {
+            throw new ImsException("hangupAll()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+    * To get WFC stat.
+    *
+    * @return a value for wfc status.
+    * @throws ImsException if getting the ims status result in an error.
+    * @hide
+    */
+    public int getWfcStatusCode() /*throws RemoteException*/ {
+        /*if (mImsNotificationController == null) {
+            throw new RemoteException ("getWfcStatusCode:ImsNotificationController not ready");
+            }
+            return mImsNotificationController.getRegistrationStatus(); */
+        if (mImsService == null) {
+            return WfcReasonInfo.CODE_WFC_DEFAULT;
+        }
+        try {
+            return mImsService.getRegistrationStatus();
+        } catch (RemoteException e) {
+            return WfcReasonInfo.CODE_WFC_DEFAULT;
+        }
+    }
+
+    /// M: Dynamic IMS Switch @{
+    /**
+     * Returns a feature value by currently phone id's resource.
+     */
+    private static boolean isImsResourceSupport(Context context, int feature, int phoneId) {
+        // Don't care if Dynamic IMS Switch not enabled.
+        boolean support = true;
+
+        if ("1".equals(SystemProperties.get("persist.mtk_dynamic_ims_switch"))) {
+
+            if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+                loge("Invalid main phone " + phoneId + ", return true as don't care");
+                return support;
+            }
+            try {
+                ImsConfig config = getConfigInterface(phoneId, context);
+                if (config != null) {
+                    support = (config.getImsResCapability(feature) !=
+                            ImsConfig.FeatureValueConstants.ON)? false : true;
+                }
+            } catch (ImsException e) {
+                loge("isImsResourceSupport() failed!" + e);
+            }
+            if (DBG) {
+                log("isImsResourceSupport(" + feature + ") return " +
+                        support + " on phone: " + phoneId);
+            }
+        }
+
+        return support;
+    }
+
+    /**
+     * Static version API to get the config interface.
+     */
+    private static ImsConfig getConfigInterface(int phoneId,
+            Context context) throws ImsException {
+        ImsConfig config = null;
+        try {
+            IBinder b = ServiceManager.getService(getImsServiceName(phoneId));
+            if (b == null) {
+                throw new ImsException("getConfigInterface(), ImsService binder",
+                            ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
+            }
+            IImsService service = IImsService.Stub.asInterface(b);
+            IImsConfig binder = service.getConfigInterface(phoneId);
+            if (binder == null) {
+                throw new ImsException("getConfigInterface()",
+                            ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
+            }
+            config = new ImsConfig(binder, context);
+        } catch (RemoteException e) {
+            throw new ImsException("getConfigInterface()", e,
+                ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return config;
+    }
+
+    /**
+     * Get the phone id with main capability.
+     */
+    private static int getMainCapabilityPhoneId(Context context) {
+        int phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+        ITelephonyEx telephony = ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(context.TELEPHONY_SERVICE_EX));
+
+        if (telephony != null) {
+            try {
+                phoneId = telephony.getMainCapabilityPhoneId();
+            } catch (RemoteException e) {
+                loge("getMainCapabilityPhoneId: remote exception");
+            }
+        } else {
+            loge("ITelephonyEx service not ready!");
+            phoneId = SystemProperties.getInt(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, 1) - 1;
+            if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
+                phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+            }
+            Rlog.d(TAG, "getMainCapabilityPhoneId: phoneId = " + phoneId);
+        }
+        return phoneId;
+    }
+    /// @}
+
+    /**
+      * An API to customization platform enabled status.
+      * @param context The context for retrive plug-in.
+      * @param feature The IMS feature defined in ImsConfig.FeatureConstants.
+      *
+      * @return return enabled status.
+      */
+    private static boolean isFeatureEnabledByPlatformExt(Context context, int feature) {
+        boolean isEnabled = true;
+
+        if (context == null) {
+            logw("Invalid context, return " + isEnabled);
+            return isEnabled;
+        }
+
+        if (mImsManagerExt == null) {
+            mImsManagerExt = (IImsManagerExt) MPlugin.createInstance(
+                    IImsManagerExt.class.getName(), context);
+            if (mImsManagerExt == null) {
+                logw("Unable to create imsManagerPlugin, return " + isEnabled);
+                return isEnabled;
+            }
+        }
+        isEnabled = mImsManagerExt.isFeatureEnabledByPlatform(feature);
+        log("isFeatureEnabledByPlatformExt(), feature:" + feature + ", isEnabled:" + isEnabled);
+
+        return isEnabled;
+    }
+
+    /// M: VILTE enable not dependent on data enable @{
+    private static boolean isTestSim(Context context, int phoneId) {
+        if (SystemProperties.getInt(MULTI_IMS_SUPPORT, 1) == 1) {
+            phoneId = getMainCapabilityPhoneId(context);
+        }
+        boolean isTestSim = false;
+        switch (phoneId) {
+            case PhoneConstants.SIM_ID_1:
+                isTestSim = "1".equals(SystemProperties.get("gsm.sim.ril.testsim", "0"));
+                break;
+            case PhoneConstants.SIM_ID_2:
+                isTestSim = "1".equals(SystemProperties.get("gsm.sim.ril.testsim.2", "0"));
+                break;
+            case PhoneConstants.SIM_ID_3:
+                isTestSim = "1".equals(SystemProperties.get("gsm.sim.ril.testsim.3", "0"));
+                break;
+            case PhoneConstants.SIM_ID_4:
+                isTestSim = "1".equals(SystemProperties.get("gsm.sim.ril.testsim.4", "0"));
+                break;
+        }
+        return isTestSim;
+    }
+    /// @}
+
+    /// M: EVS Setting @{
+    /**
+    * get the user configuration of EVS setting.
+    *
+    * @param context context
+    * @return a value of EVS setting.
+    * @hide
+    */
+    public static boolean isEvsEnabledByUser(Context context) {
+        if (!isEvsSettingSupport()) {
+            return false;
+        }
+        return SystemProperties.getInt(PROPERTY_IMS_EVS_ENABLE, 0) == 1 ? true : false;
+    }
+
+    /**
+    *  Change persistent EVS setting.
+    *
+    * @param context the context to get ImsManager Instance
+    * @param enabled the EVS status
+    * @hide
+    */
+    public static void setEvsSetting(Context context, boolean enabled) {
+        if (!isEvsSettingSupport()) {
+            return;
+        }
+        int numPhones = TelephonyManager.getDefault().getPhoneCount();
+        for(int i = 0; i < numPhones; i++) {
+            int phoneId = i;
+            if (SystemProperties.getInt(MULTI_IMS_SUPPORT, 1) == 1) {
+                phoneId = getMainCapabilityPhoneId(context);
+                i = numPhones;
+            }
+            ImsManager imsManager = ImsManager.getInstance(context, phoneId);
+            if (imsManager != null) {
+                try {
+                    imsManager.setEvsEnabled(enabled);
+                } catch (ImsException ie) {
+                    // do nothing
+                }
+            }
+        }
+    }
+
+    private void setEvsEnabled(boolean enabled) throws ImsException {
+        checkAndThrowExceptionIfServiceUnavailable();
+        int value = enabled ? 1 : 0;
+
+        try {
+            mImsService.setEvsEnabled(value, mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("setEvsEnabled() ", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    private static boolean isEvsSettingSupport() {
+        if (SystemProperties.get("ro.cmcc_light_cust_support").equals("1") ||
+                SystemProperties.get("persist.operator.optr", "").equals("OP01")) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+}
