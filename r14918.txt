Index: vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
===================================================================
--- vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java	(revision 0)
+++ vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java	(revision 14918)
@@ -0,0 +1,296 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.content.Context;
+import android.content.Intent;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.Switch;
+
+import com.android.internal.logging.MetricsLogger;
+import com.android.internal.logging.MetricsProto.MetricsEvent;
+import com.android.settingslib.bluetooth.CachedBluetoothDevice;
+import com.android.systemui.R;
+import com.android.systemui.qs.QSDetailItems;
+import com.android.systemui.qs.QSDetailItems.Item;
+import com.android.systemui.qs.QSTile;
+import com.android.systemui.statusbar.policy.BluetoothController;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/** Quick settings tile: Bluetooth **/
+public class BluetoothTile extends QSTile<QSTile.BooleanState>  {
+    private static final Intent BLUETOOTH_SETTINGS = new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
+
+    private final BluetoothController mController;
+    private final BluetoothDetailAdapter mDetailAdapter;
+
+    public BluetoothTile(Host host) {
+        super(host);
+        mController = host.getBluetoothController();
+        mDetailAdapter = new BluetoothDetailAdapter();
+    }
+
+    @Override
+    public DetailAdapter getDetailAdapter() {
+        return mDetailAdapter;
+    }
+
+    @Override
+    public BooleanState newTileState() {
+        return new BooleanState();
+    }
+
+    @Override
+    public void setListening(boolean listening) {
+        if (listening) {
+            mController.addStateChangedCallback(mCallback);
+        } else {
+            mController.removeStateChangedCallback(mCallback);
+        }
+    }
+
+    @Override
+    protected void handleSecondaryClick() {
+        // Secondary clicks are header clicks, just toggle.
+        final boolean isEnabled = (Boolean)mState.value;
+        MetricsLogger.action(mContext, getMetricsCategory(), !isEnabled);
+        mController.setBluetoothEnabled(!isEnabled);
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
+    }
+
+    @Override
+    protected void handleClick() {
+        if (!mController.canConfigBluetooth()) {
+            mHost.startActivityDismissingKeyguard(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
+            return;
+        }
+        showDetail(true);
+        if (!mState.value) {
+            mState.value = true;
+            mController.setBluetoothEnabled(true);
+        }
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        return mContext.getString(R.string.quick_settings_bluetooth_label);
+    }
+
+    @Override
+    protected void handleUpdateState(BooleanState state, Object arg) {
+        final boolean enabled = mController.isBluetoothEnabled();
+        final boolean connected = mController.isBluetoothConnected();
+        final boolean connecting = mController.isBluetoothConnecting();
+        state.value = enabled;
+        state.autoMirrorDrawable = false;
+        state.minimalContentDescription =
+                mContext.getString(R.string.accessibility_quick_settings_bluetooth);
+        if (enabled) {
+            state.label = null;
+            if (connected) {
+                state.icon = ResourceIcon.get(R.drawable.ic_qs_bluetooth_connected);
+                state.label = mController.getLastDeviceName();
+                state.contentDescription = mContext.getString(
+                        R.string.accessibility_bluetooth_name, state.label);
+                state.minimalContentDescription = state.minimalContentDescription + ","
+                        + state.contentDescription;
+            } else if (connecting) {
+                state.icon = ResourceIcon.get(R.drawable.ic_qs_bluetooth_connecting);
+                state.contentDescription = mContext.getString(
+                        R.string.accessibility_quick_settings_bluetooth_connecting);
+                state.label = mContext.getString(R.string.quick_settings_bluetooth_label);
+                state.minimalContentDescription = state.minimalContentDescription + ","
+                        + state.contentDescription;
+            } else {
+                state.icon = ResourceIcon.get(R.drawable.ic_qs_bluetooth_on);
+                state.contentDescription = mContext.getString(
+                        R.string.accessibility_quick_settings_bluetooth_on) + ","
+                        + mContext.getString(R.string.accessibility_not_connected);
+                state.minimalContentDescription = state.minimalContentDescription + ","
+                        + mContext.getString(R.string.accessibility_not_connected);
+            }
+            if (TextUtils.isEmpty(state.label)) {
+                state.label = mContext.getString(R.string.quick_settings_bluetooth_label);
+            }
+        } else {
+            state.icon = ResourceIcon.get(R.drawable.ic_qs_bluetooth_off);
+            state.label = mContext.getString(R.string.quick_settings_bluetooth_label);
+            state.contentDescription = mContext.getString(
+                    R.string.accessibility_quick_settings_bluetooth_off);
+        }
+
+        CharSequence bluetoothName = state.label;
+        if (connected) {
+            bluetoothName = state.dualLabelContentDescription = mContext.getString(
+                    R.string.accessibility_bluetooth_name, state.label);
+        }
+        state.dualLabelContentDescription = bluetoothName;
+        state.contentDescription = state.contentDescription + "," + mContext.getString(
+                R.string.accessibility_quick_settings_open_settings, getTileLabel());
+        state.expandedAccessibilityClassName = Button.class.getName();
+        state.minimalAccessibilityClassName = Switch.class.getName();
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return MetricsEvent.QS_BLUETOOTH;
+    }
+
+    @Override
+    protected String composeChangeAnnouncement() {
+        if (mState.value) {
+            return mContext.getString(R.string.accessibility_quick_settings_bluetooth_changed_on);
+        } else {
+            return mContext.getString(R.string.accessibility_quick_settings_bluetooth_changed_off);
+        }
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mController.isBluetoothSupported();
+    }
+
+    private final BluetoothController.Callback mCallback = new BluetoothController.Callback() {
+        @Override
+        public void onBluetoothStateChange(boolean enabled) {
+            refreshState();
+        }
+
+        @Override
+        public void onBluetoothDevicesChanged() {
+            mUiHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    mDetailAdapter.updateItems();
+                }
+            });
+            refreshState();
+        }
+    };
+
+    private final class BluetoothDetailAdapter implements DetailAdapter, QSDetailItems.Callback {
+        private QSDetailItems mItems;
+
+        @Override
+        public CharSequence getTitle() {
+            return mContext.getString(R.string.quick_settings_bluetooth_label);
+        }
+
+        @Override
+        public Boolean getToggleState() {
+            return mState.value;
+        }
+
+        @Override
+        public boolean getToggleEnabled() {
+            return mController.getBluetoothState() == BluetoothAdapter.STATE_OFF
+                    || mController.getBluetoothState() == BluetoothAdapter.STATE_ON;
+        }
+
+        @Override
+        public Intent getSettingsIntent() {
+            return BLUETOOTH_SETTINGS;
+        }
+
+        @Override
+        public void setToggleState(boolean state) {
+            MetricsLogger.action(mContext, MetricsEvent.QS_BLUETOOTH_TOGGLE, state);
+            mController.setBluetoothEnabled(state);
+            showDetail(false);
+        }
+
+        @Override
+        public int getMetricsCategory() {
+            return MetricsEvent.QS_BLUETOOTH_DETAILS;
+        }
+
+        @Override
+        public View createDetailView(Context context, View convertView, ViewGroup parent) {
+            mItems = QSDetailItems.convertOrInflate(context, convertView, parent);
+            mItems.setTagSuffix("Bluetooth");
+            mItems.setEmptyState(R.drawable.ic_qs_bluetooth_detail_empty,
+                    R.string.quick_settings_bluetooth_detail_empty_text);
+            mItems.setCallback(this);
+            updateItems();
+            setItemsVisible(mState.value);
+            return mItems;
+        }
+
+        public void setItemsVisible(boolean visible) {
+            if (mItems == null) return;
+            mItems.setItemsVisible(visible);
+        }
+
+        private void updateItems() {
+            if (mItems == null) return;
+            ArrayList<Item> items = new ArrayList<Item>();
+            final Collection<CachedBluetoothDevice> devices = mController.getDevices();
+            if (devices != null) {
+                for (CachedBluetoothDevice device : devices) {
+                    if (device.getBondState() == BluetoothDevice.BOND_NONE) continue;
+                    final Item item = new Item();
+                    item.icon = R.drawable.ic_qs_bluetooth_on;
+                    item.line1 = device.getName();
+                    int state = device.getMaxConnectionState();
+                    if (state == BluetoothProfile.STATE_CONNECTED) {
+                        item.icon = R.drawable.ic_qs_bluetooth_connected;
+                        item.line2 = mContext.getString(R.string.quick_settings_connected);
+                        item.canDisconnect = true;
+                    } else if (state == BluetoothProfile.STATE_CONNECTING) {
+                        item.icon = R.drawable.ic_qs_bluetooth_connecting;
+                        item.line2 = mContext.getString(R.string.quick_settings_connecting);
+                    }
+                    item.tag = device;
+                    items.add(item);
+                }
+            }
+            mItems.setItems(items.toArray(new Item[items.size()]));
+        }
+
+        @Override
+        public void onDetailItemClick(Item item) {
+            if (item == null || item.tag == null) return;
+            final CachedBluetoothDevice device = (CachedBluetoothDevice) item.tag;
+            if (device != null && device.getMaxConnectionState()
+                    == BluetoothProfile.STATE_DISCONNECTED) {
+                mController.connect(device);
+            }
+        }
+
+        @Override
+        public void onDetailItemDisconnect(Item item) {
+            if (item == null || item.tag == null) return;
+            final CachedBluetoothDevice device = (CachedBluetoothDevice) item.tag;
+            if (device != null) {
+                mController.disconnect(device);
+            }
+        }
+    }
+}
Index: vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
===================================================================
--- vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java	(revision 0)
+++ vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java	(revision 14918)
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.Switch;
+
+import com.android.internal.logging.MetricsLogger;
+import com.android.internal.logging.MetricsProto.MetricsEvent;
+import com.android.settingslib.wifi.AccessPoint;
+import com.android.systemui.R;
+import com.android.systemui.qs.QSDetailItems;
+import com.android.systemui.qs.QSDetailItems.Item;
+import com.android.systemui.qs.QSIconView;
+import com.android.systemui.qs.QSTile;
+import com.android.systemui.qs.SignalTileView;
+import com.android.systemui.statusbar.policy.NetworkController;
+import com.android.systemui.statusbar.policy.NetworkController.AccessPointController;
+import com.android.systemui.statusbar.policy.NetworkController.IconState;
+import com.android.systemui.statusbar.policy.SignalCallbackAdapter;
+
+import java.util.List;
+
+/** Quick settings tile: Wifi **/
+public class WifiTile extends QSTile<QSTile.SignalState> {
+    private static final Intent WIFI_SETTINGS = new Intent(Settings.ACTION_WIFI_SETTINGS);
+
+    private final NetworkController mController;
+    private final AccessPointController mWifiController;
+    private final WifiDetailAdapter mDetailAdapter;
+    private final QSTile.SignalState mStateBeforeClick = newTileState();
+
+    protected final WifiSignalCallback mSignalCallback = new WifiSignalCallback();
+
+    public WifiTile(Host host) {
+        super(host);
+        mController = host.getNetworkController();
+        mWifiController = mController.getAccessPointController();
+        mDetailAdapter = new WifiDetailAdapter();
+    }
+
+    @Override
+    public SignalState newTileState() {
+        return new SignalState();
+    }
+
+    @Override
+    public void setListening(boolean listening) {
+        if (listening) {
+            mController.addSignalCallback(mSignalCallback);
+        } else {
+            mController.removeSignalCallback(mSignalCallback);
+        }
+    }
+
+    @Override
+    public void setDetailListening(boolean listening) {
+        if (listening) {
+            mWifiController.addAccessPointCallback(mDetailAdapter);
+        } else {
+            mWifiController.removeAccessPointCallback(mDetailAdapter);
+        }
+    }
+
+    @Override
+    public DetailAdapter getDetailAdapter() {
+        return mDetailAdapter;
+    }
+
+    @Override
+    public QSIconView createTileView(Context context) {
+        return new SignalTileView(context);
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return WIFI_SETTINGS;
+    }
+
+    @Override
+    protected void handleSecondaryClick() {
+        // Secondary clicks are header clicks, just toggle.
+        mState.copyTo(mStateBeforeClick);
+        MetricsLogger.action(mContext, getMetricsCategory(), !mState.value);
+        mController.setWifiEnabled(!mState.value);
+    }
+
+    @Override
+    protected void handleClick() {
+        if (!mWifiController.canConfigWifi()) {
+            mHost.startActivityDismissingKeyguard(new Intent(Settings.ACTION_WIFI_SETTINGS));
+            return;
+        }
+        showDetail(true);
+        if (!mState.value) {
+            mController.setWifiEnabled(true);
+            mState.value = true;
+        }
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        return mContext.getString(R.string.quick_settings_wifi_label);
+    }
+
+    @Override
+    protected void handleUpdateState(SignalState state, Object arg) {
+        if (DEBUG) Log.d(TAG, "handleUpdateState arg=" + arg);
+        CallbackInfo cb = (CallbackInfo) arg;
+        if (cb == null) {
+            cb = mSignalCallback.mInfo;
+        }
+
+        boolean wifiConnected = cb.enabled && (cb.wifiSignalIconId > 0) && (cb.enabledDesc != null);
+        boolean wifiNotConnected = (cb.wifiSignalIconId > 0) && (cb.enabledDesc == null);
+        boolean enabledChanging = state.value != cb.enabled;
+        if (enabledChanging) {
+            mDetailAdapter.setItemsVisible(cb.enabled);
+            fireToggleStateChanged(cb.enabled);
+        }
+        state.value = cb.enabled;
+        state.connected = wifiConnected;
+        state.activityIn = cb.enabled && cb.activityIn;
+        state.activityOut = cb.enabled && cb.activityOut;
+        state.filter = true;
+        final StringBuffer minimalContentDescription = new StringBuffer();
+        final StringBuffer expandedContentDescription = new StringBuffer();
+        final Resources r = mContext.getResources();
+        if (!state.value) {
+            state.icon = ResourceIcon.get(R.drawable.ic_qs_wifi_disabled);
+            state.label = r.getString(R.string.quick_settings_wifi_label);
+        } else if (wifiConnected) {
+            state.icon = ResourceIcon.get(cb.wifiSignalIconId);
+            state.label = removeDoubleQuotes(cb.enabledDesc);
+        } else if (wifiNotConnected) {
+            state.icon = ResourceIcon.get(R.drawable.ic_qs_wifi_disconnected);
+            state.label = r.getString(R.string.quick_settings_wifi_label);
+        } else {
+            state.icon = ResourceIcon.get(R.drawable.ic_qs_wifi_no_network);
+            state.label = r.getString(R.string.quick_settings_wifi_label);
+        }
+        minimalContentDescription.append(
+                mContext.getString(R.string.quick_settings_wifi_label)).append(",");
+        if (state.value) {
+            expandedContentDescription.append(
+                    r.getString(R.string.quick_settings_wifi_on_label)).append(",");
+            if (wifiConnected) {
+                minimalContentDescription.append(cb.wifiSignalContentDescription).append(",");
+                minimalContentDescription.append(removeDoubleQuotes(cb.enabledDesc));
+                expandedContentDescription.append(cb.wifiSignalContentDescription).append(",");
+                expandedContentDescription.append(removeDoubleQuotes(cb.enabledDesc));
+            }
+        } else {
+            expandedContentDescription.append(
+                    r.getString(R.string.quick_settings_wifi_off_label));
+        }
+        state.minimalContentDescription =  minimalContentDescription;
+        expandedContentDescription.append(",").append(
+                r.getString(R.string.accessibility_quick_settings_open_settings, getTileLabel()));
+        state.contentDescription = expandedContentDescription;
+        CharSequence wifiName = state.label;
+        if (state.connected) {
+            wifiName = r.getString(R.string.accessibility_wifi_name, state.label);
+        }
+        state.dualLabelContentDescription = wifiName;
+        state.expandedAccessibilityClassName = Button.class.getName();
+        state.minimalAccessibilityClassName = Switch.class.getName();
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return MetricsEvent.QS_WIFI;
+    }
+
+    @Override
+    protected boolean shouldAnnouncementBeDelayed() {
+        return mStateBeforeClick.value == mState.value;
+    }
+
+    @Override
+    protected String composeChangeAnnouncement() {
+        if (mState.value) {
+            return mContext.getString(R.string.accessibility_quick_settings_wifi_changed_on);
+        } else {
+            return mContext.getString(R.string.accessibility_quick_settings_wifi_changed_off);
+        }
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI);
+    }
+
+    private static String removeDoubleQuotes(String string) {
+        if (string == null) return null;
+        final int length = string.length();
+        if ((length > 1) && (string.charAt(0) == '"') && (string.charAt(length - 1) == '"')) {
+            return string.substring(1, length - 1);
+        }
+        return string;
+    }
+
+    protected static final class CallbackInfo {
+        boolean enabled;
+        boolean connected;
+        int wifiSignalIconId;
+        String enabledDesc;
+        boolean activityIn;
+        boolean activityOut;
+        String wifiSignalContentDescription;
+
+        @Override
+        public String toString() {
+            return new StringBuilder("CallbackInfo[")
+                .append("enabled=").append(enabled)
+                .append(",connected=").append(connected)
+                .append(",wifiSignalIconId=").append(wifiSignalIconId)
+                .append(",enabledDesc=").append(enabledDesc)
+                .append(",activityIn=").append(activityIn)
+                .append(",activityOut=").append(activityOut)
+                .append(",wifiSignalContentDescription=").append(wifiSignalContentDescription)
+                .append(']').toString();
+        }
+    }
+
+    protected final class WifiSignalCallback extends SignalCallbackAdapter {
+        final CallbackInfo mInfo = new CallbackInfo();
+
+        @Override
+        public void setWifiIndicators(boolean enabled, IconState statusIcon, IconState qsIcon,
+                boolean activityIn, boolean activityOut, String description) {
+            if (DEBUG) Log.d(TAG, "onWifiSignalChanged enabled=" + enabled);
+            mInfo.enabled = enabled;
+            mInfo.connected = qsIcon.visible;
+            mInfo.wifiSignalIconId = qsIcon.icon;
+            mInfo.enabledDesc = description;
+            mInfo.activityIn = activityIn;
+            mInfo.activityOut = activityOut;
+            mInfo.wifiSignalContentDescription = qsIcon.contentDescription;
+            refreshState(mInfo);
+        }
+    };
+
+    private final class WifiDetailAdapter implements DetailAdapter,
+            NetworkController.AccessPointController.AccessPointCallback, QSDetailItems.Callback {
+
+        private QSDetailItems mItems;
+        private AccessPoint[] mAccessPoints;
+
+        @Override
+        public CharSequence getTitle() {
+            return mContext.getString(R.string.quick_settings_wifi_label);
+        }
+
+        public Intent getSettingsIntent() {
+            return WIFI_SETTINGS;
+        }
+
+        @Override
+        public Boolean getToggleState() {
+            return mState.value;
+        }
+
+        @Override
+        public void setToggleState(boolean state) {
+            if (DEBUG) Log.d(TAG, "setToggleState " + state);
+            MetricsLogger.action(mContext, MetricsEvent.QS_WIFI_TOGGLE, state);
+            mController.setWifiEnabled(state);
+            showDetail(false);
+        }
+
+        @Override
+        public int getMetricsCategory() {
+            return MetricsEvent.QS_WIFI_DETAILS;
+        }
+
+        @Override
+        public View createDetailView(Context context, View convertView, ViewGroup parent) {
+            if (DEBUG) Log.d(TAG, "createDetailView convertView=" + (convertView != null));
+            mAccessPoints = null;
+            mWifiController.scanForAccessPoints();
+            fireScanStateChanged(true);
+            mItems = QSDetailItems.convertOrInflate(context, convertView, parent);
+            mItems.setTagSuffix("Wifi");
+            mItems.setCallback(this);
+            mItems.setEmptyState(R.drawable.ic_qs_wifi_detail_empty,
+                    R.string.quick_settings_wifi_detail_empty_text);
+            updateItems();
+            setItemsVisible(mState.value);
+            return mItems;
+        }
+
+        @Override
+        public void onAccessPointsChanged(final List<AccessPoint> accessPoints) {
+            mAccessPoints = accessPoints.toArray(new AccessPoint[accessPoints.size()]);
+            updateItems();
+            if (accessPoints != null && accessPoints.size() > 0) {
+                fireScanStateChanged(false);
+            }
+        }
+
+        @Override
+        public void onSettingsActivityTriggered(Intent settingsIntent) {
+            mHost.startActivityDismissingKeyguard(settingsIntent);
+        }
+
+        @Override
+        public void onDetailItemClick(Item item) {
+            if (item == null || item.tag == null) return;
+            final AccessPoint ap = (AccessPoint) item.tag;
+            if (!ap.isActive()) {
+                if (mWifiController.connect(ap)) {
+                    mHost.collapsePanels();
+                }
+            }
+            showDetail(false);
+        }
+
+        @Override
+        public void onDetailItemDisconnect(Item item) {
+            // noop
+        }
+
+        public void setItemsVisible(boolean visible) {
+            if (mItems == null) return;
+            mItems.setItemsVisible(visible);
+        }
+
+        private void updateItems() {
+            if (mItems == null) return;
+            Item[] items = null;
+            if (mAccessPoints != null) {
+                items = new Item[mAccessPoints.length];
+                for (int i = 0; i < mAccessPoints.length; i++) {
+                    final AccessPoint ap = mAccessPoints[i];
+                    final Item item = new Item();
+                    item.tag = ap;
+                    item.icon = mWifiController.getIcon(ap);
+                    item.line1 = ap.getSsid();
+                    item.line2 = ap.isActive() ? ap.getSummary() : null;
+                    item.overlay = ap.getSecurity() != AccessPoint.SECURITY_NONE
+                            ? mContext.getDrawable(R.drawable.qs_ic_wifi_lock)
+                            : null;
+                    items[i] = item;
+                }
+            }
+            mItems.setItems(items);
+        }
+    }
+}
Index: vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
===================================================================
--- vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java	(revision 0)
+++ vendor/branch/5058Y_ALGB/frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java	(revision 14918)
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.Switch;
+
+import com.android.internal.logging.MetricsLogger;
+import com.android.internal.logging.MetricsProto.MetricsEvent;
+import com.android.settingslib.net.DataUsageController;
+import com.android.systemui.R;
+import com.android.systemui.qs.QSIconView;
+import com.android.systemui.qs.QSTile;
+import com.android.systemui.qs.SignalTileView;
+import com.android.systemui.qs.QSTile.ResourceIcon;
+import com.android.systemui.statusbar.policy.NetworkController;
+import com.android.systemui.statusbar.policy.NetworkController.IconState;
+import com.android.systemui.statusbar.policy.SignalCallbackAdapter;
+
+/// M: add DataUsage in quicksetting @{
+import com.mediatek.systemui.ext.IQuickSettingsPlugin;
+import com.mediatek.systemui.PluginManager;
+/// add DataUsage in quicksetting @}
+
+import com.mediatek.systemui.statusbar.util.FeatureOptions;
+
+/** Quick settings tile: Cellular **/
+public class CellularTile extends QSTile<QSTile.SignalState> {
+
+    // / M: For debug @{
+    private static final String TAG = "CellularTile";
+    private static final boolean DBG = true;
+    // @}
+
+    static final Intent CELLULAR_SETTINGS = new Intent().setComponent(new ComponentName(
+            "com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
+
+    private final NetworkController mController;
+    private final DataUsageController mDataController;
+    private final CellularDetailAdapter mDetailAdapter;
+
+    /// M: add DataUsage for operator @{
+    private IQuickSettingsPlugin mQuickSettingsPlugin;
+    private boolean mDisplayDataUsage;
+    private Icon mIcon;
+    /// add DataUsage for operator @}
+
+    // M: Disable other sub's data when enable default sub's data
+    private TelephonyManager mTelephonyManager;
+
+    private final CellSignalCallback mSignalCallback = new CellSignalCallback();
+
+    public CellularTile(Host host) {
+        super(host);
+        mController = host.getNetworkController();
+        mDataController = mController.getMobileDataController();
+        mDetailAdapter = new CellularDetailAdapter();
+        /// M: add DataUsage for operator @{
+        mQuickSettingsPlugin = PluginManager
+                .getQuickSettingsPlugin(mContext);
+        mDisplayDataUsage = mQuickSettingsPlugin.customizeDisplayDataUsage(false);
+        mIcon = ResourceIcon.get(R.drawable.ic_qs_data_usage);
+        /// add DataUsage for operator @}
+
+        // M: Disable other sub's data when enable default sub's data
+        mTelephonyManager = TelephonyManager.from(mContext);
+    }
+
+    @Override
+    public SignalState newTileState() {
+        return new SignalState();
+    }
+
+    @Override
+    public DetailAdapter getDetailAdapter() {
+        return mDetailAdapter;
+    }
+
+    @Override
+    public void setListening(boolean listening) {
+        if (listening) {
+            mController.addSignalCallback(mSignalCallback);
+        } else {
+            mController.removeSignalCallback(mSignalCallback);
+        }
+    }
+
+    @Override
+    public QSIconView createTileView(Context context) {
+        return new SignalTileView(context);
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return CELLULAR_SETTINGS;
+    }
+
+    @Override
+    protected void handleClick() {
+        MetricsLogger.action(mContext, getMetricsCategory());
+        // M: Start setting activity when default SIM isn't set
+        if (mDataController.isMobileDataSupported() && isDefaultDataSimExist()) {
+            showDetail(true);
+        } else {
+            mHost.startActivityDismissingKeyguard(CELLULAR_SETTINGS);
+        }
+    }
+
+    @Override
+    protected void handleSecondaryClick() {
+        Log.d(TAG, "handleSecondaryClick()");
+        if (mDisplayDataUsage) {
+            handleClick();
+        } else {
+            // M: Don't turn on/off data when default SIM isn't set @{
+            if(!isDefaultDataSimExist()) return;
+            // @}
+            boolean dataEnabled = mDataController.isMobileDataSupported()
+                    && mDataController.isMobileDataEnabled();
+            MetricsLogger.action(mContext, MetricsEvent.QS_CELLULAR_TOGGLE, !dataEnabled);
+            mDataController.setMobileDataEnabled(!dataEnabled);
+            // M: Disable other sub's data when enable default sub's data @{
+            // M: [ALPS03525337] Exclude dual volte support
+            if ((!FeatureOptions.DUAL_VOLTE_SUPPORT && !dataEnabled) ||
+                    (mQuickSettingsPlugin.setDualSimDataSync() && !dataEnabled)) {
+                disableDataForOtherSubscriptions();
+            }
+            // @}
+        }
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        /// M: add DataUsage for operator @{
+        if (mDisplayDataUsage) {
+            return mContext.getString(R.string.data_usage);
+        }
+        /// add DataUsage for operator @}
+        return mContext.getString(R.string.quick_settings_cellular_detail_title);
+    }
+
+    @Override
+    protected void handleUpdateState(SignalState state, Object arg) {
+        /// M: add DataUsage for operator @{
+        if (mDisplayDataUsage) {
+            Log.i(TAG, "customize datausage, displayDataUsage = " + mDisplayDataUsage);
+            //state.visible = true;
+            state.icon = mIcon;
+            state.label = mContext.getString(R.string.data_usage);
+            state.contentDescription = mContext.getString(R.string.data_usage);
+            return;
+        }
+        /// add DataUsage for operator @}
+
+        CallbackInfo cb = (CallbackInfo) arg;
+        if (cb == null) {
+            cb = mSignalCallback.mInfo;
+        }
+
+        final Resources r = mContext.getResources();
+        final int iconId = cb.noSim ? R.drawable.ic_qs_no_sim
+                : !cb.enabled || cb.airplaneModeEnabled ? R.drawable.ic_qs_signal_disabled
+                : cb.mobileSignalIconId > 0 ? cb.mobileSignalIconId
+                : R.drawable.ic_qs_signal_no_signal;
+        state.icon = ResourceIcon.get(iconId);
+        state.isOverlayIconWide = cb.isDataTypeIconWide;
+        state.autoMirrorDrawable = !cb.noSim;
+        // M: Update roaming icon with airplane mode state
+        state.overlayIconId = cb.enabled && (cb.dataTypeIconId > 0)
+                && !cb.airplaneModeEnabled ? cb.dataTypeIconId : 0;
+        state.filter = iconId != R.drawable.ic_qs_no_sim;
+        state.activityIn = cb.enabled && cb.activityIn;
+        state.activityOut = cb.enabled && cb.activityOut;
+
+        state.label = cb.enabled
+                ? removeTrailingPeriod(cb.enabledDesc)
+                : r.getString(R.string.quick_settings_rssi_emergency_only);
+
+        final String signalContentDesc = cb.enabled && (cb.mobileSignalIconId > 0)
+                ? cb.signalContentDescription
+                : r.getString(R.string.accessibility_no_signal);
+
+        if (cb.noSim) {
+            state.contentDescription = state.label;
+        } else {
+            String enabledDesc = cb.enabled ? r.getString(R.string.accessibility_cell_data_on)
+                    : r.getString(R.string.accessibility_cell_data_off);
+
+            state.contentDescription = r.getString(
+                    R.string.accessibility_quick_settings_mobile,
+                    enabledDesc, signalContentDesc,
+                    state.label);
+            state.minimalContentDescription = r.getString(
+                    R.string.accessibility_quick_settings_mobile,
+                    r.getString(R.string.accessibility_cell_data), signalContentDesc,
+                    state.label);
+        }
+        state.contentDescription = state.contentDescription + "," + r.getString(
+                R.string.accessibility_quick_settings_open_settings, getTileLabel());
+        state.minimalAccessibilityClassName = state.expandedAccessibilityClassName
+                = Button.class.getName();
+        state.value = mDataController.isMobileDataSupported()
+                && mDataController.isMobileDataEnabled();
+
+        // /M: Change the icon/label when default SIM isn't set @{
+        if (mTelephonyManager.getNetworkOperator() != null
+                && !cb.noSim && !isDefaultDataSimExist()) {
+            Log.d(TAG, "handleUpdateState(), default data sim not exist");
+            state.icon = ResourceIcon.get(R.drawable.ic_qs_data_sim_not_set);
+            state.label = r.getString(R.string.quick_settings_data_sim_notset);
+            state.overlayIconId = 0;
+            state.filter = true;
+            state.activityIn = false;
+            state.activityOut = false;
+        }
+        // @}
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return MetricsEvent.QS_CELLULAR;
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mController.hasMobileDataFeature();
+    }
+
+    // Remove the period from the network name
+    public static String removeTrailingPeriod(String string) {
+        if (string == null) return null;
+        final int length = string.length();
+        if (string.endsWith(".")) {
+            return string.substring(0, length - 1);
+        }
+        return string;
+    }
+
+    private static final class CallbackInfo {
+        boolean enabled;
+        boolean wifiEnabled;
+        boolean airplaneModeEnabled;
+        int mobileSignalIconId;
+        String signalContentDescription;
+        int dataTypeIconId;
+        String dataContentDescription;
+        boolean activityIn;
+        boolean activityOut;
+        String enabledDesc;
+        boolean noSim;
+        boolean isDataTypeIconWide;
+    }
+
+    private final class CellSignalCallback extends SignalCallbackAdapter {
+        private final CallbackInfo mInfo = new CallbackInfo();
+        @Override
+        public void setWifiIndicators(boolean enabled, IconState statusIcon, IconState qsIcon,
+                boolean activityIn, boolean activityOut, String description) {
+            mInfo.wifiEnabled = enabled;
+            refreshState(mInfo);
+        }
+        /// M: Modify to support [Network Type and volte on Statusbar], change the implement methods
+        /// add one more parameter for network type.
+        @Override
+        public void setMobileDataIndicators(IconState statusIcon, IconState qsIcon, int statusType,
+                int networkIcon, int volteIcon, int qsType, boolean activityIn, boolean activityOut,
+                String typeContentDescription, String description, boolean isWide, int subId) {
+            if (qsIcon == null) {
+                // Not data sim, don't display.
+                Log.d(TAG, "setMobileDataIndicator qsIcon = null, Not data sim, don't display");
+                return;
+            }
+            mInfo.enabled = qsIcon.visible;
+            mInfo.mobileSignalIconId = qsIcon.icon;
+            mInfo.signalContentDescription = qsIcon.contentDescription;
+            mInfo.dataTypeIconId = qsType;
+            mInfo.dataContentDescription = typeContentDescription;
+            mInfo.activityIn = activityIn;
+            mInfo.activityOut = activityOut;
+            mInfo.enabledDesc = description;
+            mInfo.isDataTypeIconWide = qsType != 0 && isWide;
+            if (DBG) {
+                Log.d(TAG, "setMobileDataIndicators info.enabled = " + mInfo.enabled +
+                    " mInfo.mobileSignalIconId = " + mInfo.mobileSignalIconId +
+                    " mInfo.signalContentDescription = " + mInfo.signalContentDescription +
+                    " mInfo.dataTypeIconId = " + mInfo.dataTypeIconId +
+                    " mInfo.dataContentDescription = " + mInfo.dataContentDescription +
+                    " mInfo.activityIn = " + mInfo.activityIn +
+                    " mInfo.activityOut = " + mInfo.activityOut +
+                    " mInfo.enabledDesc = " + mInfo.enabledDesc +
+                    " mInfo.isDataTypeIconWide = " + mInfo.isDataTypeIconWide);
+            }
+            refreshState(mInfo);
+        }
+
+        @Override
+        public void setNoSims(boolean show) {
+            Log.d(TAG, "setNoSims, noSim = " + show);
+            mInfo.noSim = show;
+            if (mInfo.noSim) {
+                // Make sure signal gets cleared out when no sims.
+                mInfo.mobileSignalIconId = 0;
+                mInfo.dataTypeIconId = 0;
+                // Show a No SIMs description to avoid emergency calls message.
+                mInfo.enabled = true;
+                mInfo.enabledDesc = mContext.getString(
+                        R.string.keyguard_missing_sim_message_short);
+                mInfo.signalContentDescription = mInfo.enabledDesc;
+            }
+            refreshState(mInfo);
+        }
+
+        @Override
+        public void setIsAirplaneMode(IconState icon) {
+            mInfo.airplaneModeEnabled = icon.visible;
+            refreshState(mInfo);
+        }
+
+        @Override
+        public void setMobileDataEnabled(boolean enabled) {
+            mDetailAdapter.setMobileDataEnabled(enabled);
+        }
+    };
+
+    private final class CellularDetailAdapter implements DetailAdapter {
+
+        @Override
+        public CharSequence getTitle() {
+            return mContext.getString(R.string.quick_settings_cellular_detail_title);
+        }
+
+        @Override
+        public Boolean getToggleState() {
+            return mDataController.isMobileDataSupported()
+                    ? mDataController.isMobileDataEnabled()
+                    : null;
+        }
+
+        @Override
+        public Intent getSettingsIntent() {
+            return CELLULAR_SETTINGS;
+        }
+
+        @Override
+        public void setToggleState(boolean state) {
+            MetricsLogger.action(mContext, MetricsEvent.QS_CELLULAR_TOGGLE, state);
+            mDataController.setMobileDataEnabled(state);
+            // M: Disable other sub's data when enable default sub's data @{
+            // M: [ALPS03525337] Exclude dual volte support
+            if ((!FeatureOptions.DUAL_VOLTE_SUPPORT && state) ||
+                    (mQuickSettingsPlugin.setDualSimDataSync() && state)) {
+                disableDataForOtherSubscriptions();
+            }
+            // @}
+        }
+
+        @Override
+        public int getMetricsCategory() {
+            return MetricsEvent.QS_DATAUSAGEDETAIL;
+        }
+
+        @Override
+        public View createDetailView(Context context, View convertView, ViewGroup parent) {
+            final DataUsageDetailView v = (DataUsageDetailView) (convertView != null
+                    ? convertView
+                    : LayoutInflater.from(mContext).inflate(R.layout.data_usage, parent, false));
+            final DataUsageController.DataUsageInfo info = mDataController.getDataUsageInfo();
+            if (info == null) return v;
+            v.bind(info);
+            return v;
+        }
+
+        public void setMobileDataEnabled(boolean enabled) {
+            fireToggleStateChanged(enabled);
+        }
+    }
+
+    // /M: Change the label when default SIM isn't set @{
+    public boolean isDefaultDataSimExist() {
+        int[] subList = SubscriptionManager.from(mContext).getActiveSubscriptionIdList();
+        int defaultDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+        Log.d(TAG, "isDefaultDataSimExist, Default data sub id : " + defaultDataSubId);
+        for (int subId : subList) {
+            if (subId == defaultDataSubId) {
+                return true;
+            }
+        }
+        return false;
+    }
+    // @}
+
+    // /M: Disable other sub's data when enable default sub's data@{
+    private void disableDataForOtherSubscriptions() {
+        int[] subList = SubscriptionManager.from(mContext).getActiveSubscriptionIdList();
+        int defaultDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+        for (int subId : subList) {
+            if (subId != defaultDataSubId && mTelephonyManager.getDataEnabled(subId)) {
+                Log.d(TAG, "Disable other sub's data : " + subId);
+                mTelephonyManager.setDataEnabled(subId, false);
+            }
+        }
+    }
+    // @}
+}
