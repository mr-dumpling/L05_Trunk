Index: vendor/branch/5058A_Cable_Bahamas/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java
===================================================================
--- vendor/branch/5058A_Cable_Bahamas/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 0)
+++ vendor/branch/5058A_Cable_Bahamas/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 4573)
@@ -0,0 +1,3333 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+ /*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.data;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDiskIOException;
+import android.database.sqlite.SqliteWrapper;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.preference.PreferenceManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.provider.Telephony.Threads;
+import android.provider.Telephony.MmsSms.PendingMessages;
+import android.provider.Telephony.MmsSms.WordsTable;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.android.common.contacts.DataUsageStatUpdater;
+import com.android.common.userhappiness.UserHappinessSignals;
+import com.android.mms.ContentRestrictionException;
+import com.android.mms.ExceedMessageSizeException;
+import com.android.mms.LogTag;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.R;
+import com.android.mms.ResolutionException;
+import com.android.mms.RestrictedResolutionException;
+import com.android.mms.UnsupportContentTypeException;
+import com.android.mms.draft.DraftManager;
+import com.android.mms.draft.IDraftInterface;
+import com.android.mms.draft.MmsDraftData;
+import com.android.mms.model.AudioModel;
+import com.android.mms.model.ImageModel;
+import com.android.mms.model.MediaModel;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.model.VideoModel;
+import com.android.mms.model.SlideshowModel.MediaType;
+import com.android.mms.transaction.MessageSender;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.transaction.MmsMessageSender;
+import com.android.mms.transaction.SmsMessageSender;
+import com.android.mms.ui.ComposeMessageActivity;
+import com.android.mms.ui.MessageUtils;
+import com.android.mms.ui.SlideshowEditor;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.MmsLog;
+import com.android.mms.util.Recycler;
+import com.android.mms.util.ThumbnailManager;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.google.android.mms.ContentType;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.SendReq;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.mms.callback.IConversationCallback;
+import com.mediatek.mms.callback.ISplitToMmsAndSmsConversationCallback;
+import com.mediatek.mms.callback.IWorkingMessageCallback;
+import com.mediatek.mms.ext.IOpWorkingMessageExt;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.util.FileAttachmentUtils;
+import com.mediatek.mms.util.MmsSizeUtils;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.MmsPreferenceActivity;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Contains all state related to a message being edited by the user.
+ */
+public class WorkingMessage implements IWorkingMessageCallback {
+    private static final String TAG = "WorkingMessage";
+    private static final String TAG_DRAFT = "[Mms][Draft][WorkingMessage]";
+    private static final boolean DEBUG = false;
+
+    // Public intents
+    public static final String ACTION_SENDING_SMS = "android.intent.action.SENDING_SMS";
+
+    // Intent extras
+    public static final String EXTRA_SMS_MESSAGE = "android.mms.extra.MESSAGE";
+    public static final String EXTRA_SMS_RECIPIENTS = "android.mms.extra.RECIPIENTS";
+    public static final String EXTRA_SMS_THREAD_ID = "android.mms.extra.THREAD_ID";
+
+    //for save message uri when MMS is stoping, and when recreate MMS, it can be read
+    public static final String SAVE_MSG_URI_KEY = "pref_msg_uri_key";
+    public static final String SAVE_MSG_THREADID_KEY = "pref_msg_threadid_key";
+
+    // Database access stuff
+    private final Activity mActivity;
+    private final ContentResolver mContentResolver;
+
+    // States that can require us to save or send a message as MMS.
+    private static final int RECIPIENTS_REQUIRE_MMS = (1 << 0);     // 1
+    private static final int HAS_SUBJECT = (1 << 1);                // 2
+    private static final int HAS_ATTACHMENT = (1 << 2);             // 4
+    private static final int LENGTH_REQUIRES_MMS = (1 << 3);        // 8
+    private static final int FORCE_MMS = (1 << 4);                  // 16
+    /// M: google JB.MR1 patch, group mms
+    private static final int MULTIPLE_RECIPIENTS = (1 << 5);        // 32
+
+    // A bitmap of the above indicating different properties of the message;
+    // any bit set will require the message to be sent via MMS.
+    private int mMmsState;
+
+    // Errors from setAttachment()
+    public static final int OK = 0;
+    public static final int UNKNOWN_ERROR = -1;
+    public static final int MESSAGE_SIZE_EXCEEDED = -2;
+    public static final int UNSUPPORTED_TYPE = -3;
+    public static final int IMAGE_TOO_LARGE = -4;
+
+    // Attachment types
+    public static final int TEXT = 0;
+    public static final int IMAGE = 1;
+    public static final int VIDEO = 2;
+    public static final int AUDIO = 3;
+    public static final int SLIDESHOW = 4;
+
+    // Current attachment type of the message; one of the above values.
+    private int mAttachmentType;
+
+    // Conversation this message is targeting.
+    private Conversation mConversation;
+
+    // Text of the message.
+    private CharSequence mText;
+    // Slideshow for this message, if applicable.  If it's a simple attachment,
+    // i.e. not SLIDESHOW, it will contain only one slide.
+    private SlideshowModel mSlideshow;
+    // Data URI of an MMS message if we have had to save it.
+    private Uri mMessageUri;
+    // MMS subject line for this message
+    private CharSequence mSubject;
+
+    // Set to true if this message has been discarded.
+    private boolean mDiscarded = false;
+
+    // Track whether we have drafts
+    private volatile boolean mHasMmsDraft;
+    private volatile boolean mHasSmsDraft;
+
+    // Cached value of mms enabled flag
+    private static boolean sMmsEnabled = MmsConfig.getMmsEnabled();
+
+    // Our callback interface
+    private final MessageStatusListener mStatusListener;
+    private List<String> mWorkingRecipients;
+
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not send
+    /// MMS anymore after send several MMS fail . @{
+    private static final String[] MMS_OUTBOX_PROJECTION = {
+        Mms._ID,            // 0
+        Mms.MESSAGE_SIZE,   // 1
+        Mms.STATUS
+    };
+    /// @}
+
+    /// M: Modify @{
+    private static final String FDN_URI = "content://icc/fdn/subId/";
+    private static final String[] FDN_PROJECTION = new String[] {
+        "index",
+        "name",
+        "number"
+    };
+    private static final int FDN_COLUMN_INDEX = 0;
+    private static final int FDN_COLUMN_NAME = 1;
+    private static final int FDN_COLUMN_NUMBER = 2;
+    /// @}
+
+    private static final int MMS_MESSAGE_SIZE_INDEX  = 1;
+
+    /// M:
+    private static final String M_TAG = "Mms/WorkingMessage";
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public static final int ATTACHMENT = 5;
+    public static final int VCARD = 6;
+    /// @}
+    /// M: Code analyze 035, For new feature ALPS00249336,  add vCalendar support . @{
+    public static final int VCALENDAR = 7;
+    /// @}
+
+    /// M: Code analyze 036, For bug ALPS00270539, mms draft edit lock. at any
+    /// time, only one thread can modify a mms draft. here currently use a static
+    /// lock is ok, because WorkingMessage is only one at any time. if the condition
+    /// is changed this must be changed too . @{
+    public static Object sDraftMmsLock = new Object();
+    /// @}
+
+    private long mOldThreadId;
+
+    /// M: Fix CR : ALPS01012417 @{
+    private long mOldSmsSaveThreadId;
+    /// @}
+
+    /// M: Fix CR : ALPS01078057 @{
+    private long mOldMmsSaveThreadId = 0;
+    /// @}
+
+    /// M : FIX CR : ALPS01795853 @{
+    private boolean mIsTurnToChooseAttach;
+    /// @}
+
+    /// M: Fix CR: ALPS01234459 @{
+    private boolean mIsLoadingDraft;
+    /// @}
+
+    // Draft message stuff
+    private static final String[] MMS_DRAFT_PROJECTION = {
+        Mms._ID,                // 0
+        Mms.SUBJECT,            // 1
+        Mms.SUBJECT_CHARSET     // 2
+    };
+
+    private static final int MMS_ID_INDEX         = 0;
+    private static final int MMS_SUBJECT_INDEX    = 1;
+    private static final int MMS_SUBJECT_CS_INDEX = 2;
+
+    /// M: Code analyze 039, For new feature ALPS00233419, Creation mode . @{
+    private static final String CREATION_MODE_RESTRICTED = "RESTRICTED";
+    private static final String CREATION_MODE_WARNING    = "WARNING";
+    private static final String CREATION_MODE_FREE       = "FREE";
+
+    public static final int WARNING_TYPE    = -10;
+    public static final int RESTRICTED_TYPE = -11;
+    public static final int RESTRICTED_RESOLUTION = -12;
+
+    public static int sCreationMode  = 0;
+    /// @}
+
+    //Set resizedto true if the image is
+    private boolean mResizeImage = false;
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not
+    /// send MMS anymore after send several MMS fail . @{
+    private static final int MMS_MESSAGE_STATUS_INDEX  = 2;
+    /// @}
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft
+    /// when save Latest Mms message as draft . @{
+    private boolean mNeedDeleteOldMmsDraft;
+    /// @}
+
+    /// M: Code analyze 043, For bug ALPS00117913, Mms Basic Coding Convention Correction . @{
+    private static final String FILE_NOT_FOUND = "File not found.";
+
+    private static final String READ_WRITE_FAILURE = "Read or write file failure.";
+
+    private boolean mIsDeleteDraftWhenLoad = false;
+    /// @}
+
+    /// M: fix bug ALPS00513231, force update threadId @{
+    private boolean mForceUpdateThreadId = false;
+
+    public void setForceUpdateThreadId(boolean update) {
+        mForceUpdateThreadId = update;
+    }
+    /// @}
+
+    private Bundle mBundle;
+
+    public IOpWorkingMessageExt mOpWorkingMessageExt = null;
+
+    /**
+     * Callback interface for communicating important state changes back to
+     * ComposeMessageActivity.
+     */
+    public interface MessageStatusListener {
+        /**
+         * Called when the protocol for sending the message changes from SMS
+         * to MMS, and vice versa.
+         *
+         * @param mms If true, it changed to MMS.  If false, to SMS.
+         */
+        /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+        void onProtocolChanged(boolean mms, boolean needToast);
+        /// @}
+
+        /**
+         * Called when an attachment on the message has changed.
+         */
+        void onAttachmentChanged();
+
+        /**
+         * Called just before the process of sending a message.
+         */
+        void onPreMessageSent();
+
+        /**
+         * Called once the process of sending a message, triggered by
+         * {@link send} has completed. This doesn't mean the send succeeded,
+         * just that it has been dispatched to the network.
+         */
+        void onMessageSent();
+
+        /**
+         * Called if there are too many unsent messages in the queue and we're not allowing
+         * any more Mms's to be sent.
+         */
+        void onMaxPendingMessagesReached();
+
+        /**
+         * Called if there's an attachment error while resizing the images just before sending.
+         */
+        void onAttachmentError(int error);
+
+        /** M:Code analyze 045, For bug ALPS00241360, to solve White screen
+         * appears about 3 seconds when sending MMS. Called just before the
+         * process of sending a mms.
+         */
+        void onPreMmsSent();
+    }
+
+    private WorkingMessage(ComposeMessageActivity activity) {
+        MmsLog.d(TAG, "new WorkingMessage(Composer)");
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = activity;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        this.mInterface = new DraftInterface();
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    /**
+     * Creates a new working message.
+     */
+    public static WorkingMessage createEmpty(ComposeMessageActivity activity) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity);
+        return msg;
+    }
+
+    /**
+     * Create a new WorkingMessage from the specified data URI, which typically
+     * contains an MMS message.
+     */
+    public static WorkingMessage load(ComposeMessageActivity activity, Uri uri) {
+        // If the message is not already in the draft box, move it there.
+        if (!uri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+            PduPersister persister = PduPersister.getPduPersister(activity);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "load: moving %s to drafts" + uri);
+            }
+            try {
+                uri = persister.move(uri, Mms.Draft.CONTENT_URI);
+            } catch (MmsException e) {
+                MmsLog.epi(TAG, "Can't move %s to drafts" + uri);
+                return null;
+            }
+        }
+
+        WorkingMessage msg = new WorkingMessage(activity);
+        /// M: Code analyze 046, For bug ALPS00114670, to solve JE happen
+        /// when tap discard slidehsow . @{
+        msg.setConversation(activity.getConversation());
+        /// @}
+        long threadId = 0;
+        boolean noRecipientes = activity.getConversation().getRecipients().isEmpty();
+        if (!noRecipientes) {
+            threadId = activity.getConversation().ensureThreadId();
+        }
+
+        MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                threadId, uri, activity, null);
+        if (mdd == null) {
+            Log.d(TAG_DRAFT, "[load] load from DraftManager result is null!!");
+            return null;
+        }
+        Log.d(TAG_DRAFT, "[load] boolean result is : " + mdd.getBooleanResult());
+        if (mdd.getBooleanResult()) {
+            msg.mHasMmsDraft = true;
+            msg.mSlideshow = mdd.getSlideshow();
+            msg.mMessageUri = mdd.getMessageUri();
+            msg.syncTextFromSlideshow();
+            msg.correctAttachmentState();
+            MmsLog.dpi(TAG_DRAFT, "[load] message uri : " + msg.mMessageUri);
+            return msg;
+        }
+
+        return null;
+    }
+
+    public void correctAttachmentState() {
+        int slideCount = mSlideshow.size();
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        final int fileAttachCount = mSlideshow.sizeOfFilesAttach();
+        /// @}
+        // If we get an empty slideshow, tear down all MMS
+        // state and discard the unnecessary message Uri.
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        if (0 == fileAttachCount) {
+        /// @}
+            if (slideCount == 0 || isEmptySlide()) {
+                //add for attachment enhance
+                MmsLog.d(TAG, "WorkingMessage CorrectAttachmentState RemoveAttachment");
+                removeAttachment(true);
+            } else if (slideCount > 1) {
+                mAttachmentType = SLIDESHOW;
+            } else {
+                SlideModel slide = mSlideshow.get(0);
+                if (slide.hasImage()) {
+                    mAttachmentType = IMAGE;
+                } else if (slide.hasVideo()) {
+                    mAttachmentType = VIDEO;
+                } else if (slide.hasAudio()) {
+                    mAttachmentType = AUDIO;
+                }
+            }
+        } else { /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            mAttachmentType = ATTACHMENT;
+        }
+        /// @}
+
+        updateState(HAS_ATTACHMENT, hasAttachment(), false);
+    }
+
+//add for attachment enhance
+     private boolean isEmptySlide() {
+        int slideCount = mSlideshow.size();
+
+        if (slideCount == 1) {
+            if (mSlideshow != null) {
+                MmsLog.d(TAG, "mSlideshow != null");
+               if (mSlideshow.get(0) != null) {
+                    //Xlog.e(TAG, "contentType = " + mSlideshow.get(0).get(0).getContentType());
+                    MmsLog.d(TAG, "mAttachmentType = " + mAttachmentType);
+                    //MmsLog.e(TAG, "mSlideshow.get(0).get(0) "+ mSlideshow.get(0).get(0));
+
+                    if (mSlideshow.get(0).get(0) != null && mSlideshow.get(0).size() == 1) {
+                        MmsLog.d(TAG, "mSlideshow.get(0).get(0).size " + mSlideshow.get(0).size());
+                        if (mSlideshow.get(0).get(0).getContentType()
+                                .compareTo(ContentType.TEXT_PLAIN) == 0
+                        && (mAttachmentType == VCARD || mAttachmentType == VCALENDAR ||
+                        mAttachmentType == ATTACHMENT)) {
+                            MmsLog.d(TAG, "isEmptySlide return true");
+                            return true;
+                        }
+                    } else if (mSlideshow.get(0).size() == 0 || mSlideshow.get(0).get(0) == null) {
+                        ///M: Modify for ALPS01253847
+                        return true;
+                    }
+               }
+           }
+        }
+
+        MmsLog.d(TAG, "isEmptySlide return false");
+        return false;
+    }
+
+    /**
+     * Load the draft message for the specified conversation, or a new empty message if
+     * none exists.
+     */
+    public static WorkingMessage loadDraft(final ComposeMessageActivity activity,
+                                           final Conversation conv,
+                                           final Runnable onDraftLoaded) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "loadDraft " + conv);
+        }
+
+        final WorkingMessage msg = createEmpty(activity);
+        /// M: Code analyze 037, For bug ALPS00291328,  save conversation to avoid JE . @{
+        msg.setConversation(conv);
+        /// @}
+        if (conv.getThreadId() <= 0) {
+            if (onDraftLoaded != null) {
+                onDraftLoaded.run();
+            }
+            return msg;
+        }
+
+        final long threadId = conv.getThreadId();
+        msg.mOldThreadId = threadId;
+
+        /// M: modify for fix alps01194967  && alps01208583 &&
+        /// alps01224306, load sms draft in backGround. @{
+        new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                MmsLog.dpi(TAG_DRAFT, "[loadDraft] draftText : " + draftText);
+                if (TextUtils.isEmpty(draftText)) {
+                    msg.mInterface.loadRunnable = onDraftLoaded;
+                    /// M: Fix CR : ALPS01234459, while loading draft, can't set text @{
+                    msg.mIsLoadingDraft = true;
+                    /// @}
+                    DraftManager.getInstance().loadDraft(DraftManager.ASYNC_LOAD_ACTION,
+                            threadId, null, activity, msg.mInterface);
+                } else {
+                    msg.mHasSmsDraft = true;
+                    if (onDraftLoaded != null && activity != null) {
+                        activity.runOnUiThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                msg.setText(draftText);
+                                onDraftLoaded.run();
+                            }
+                        });
+                    }
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+        /// @}
+        return msg;
+    }
+
+    private DraftInterface mInterface;
+
+    private class DraftInterface implements IDraftInterface {
+        private Handler mHanlder;
+        DraftInterface() {
+            mHanlder = new Handler();
+        }
+
+        public Runnable loadRunnable;
+
+        public void loadFinished(MmsDraftData mdd) {
+            if (mdd != null) {
+                MmsLog.dpi(TAG_DRAFT, "[loadFinished] enter, and uri : "
+                        + mdd.getMessageUri() + ", subject : " + mdd.getSubject());
+
+                String subject = mdd.getSubject();
+                if (subject != null && subject.length() != 0) {
+                    mHasMmsDraft = true;
+                    setSubject(subject, false);
+                }
+
+                mOpWorkingMessageExt.opLoadFinished(mdd.mIOpMmsDraftDataExt);
+
+                Log.d(TAG_DRAFT, "[loadFinished] boolean result : " + mdd.getBooleanResult());
+                if (mdd.getBooleanResult()) {
+                    mHasMmsDraft = true;
+                    SlideshowModel slideshow = mdd.getSlideshow();
+                    mMessageUri = mdd.getMessageUri();
+
+                    mSlideshow = slideshow;
+                    syncTextFromSlideshow();
+                    correctAttachmentState();
+                    if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+                        Log.d(TAG_DRAFT, "[loadFinished] defualt sms, do delete mms draft");
+                        if (getSlideshow() != null && getSlideshow().size() == 1
+                                && !getSlideshow().get(0).hasAudio()
+                                && !getSlideshow().get(0).hasImage()
+                                && !getSlideshow().get(0).hasVideo()
+                                && getSlideshow().sizeOfFilesAttach() == 0
+                                && TextUtils.isEmpty(subject)
+                                && TextUtils.isEmpty(getText())) {
+                            Log.d(TAG_DRAFT, "[loadFinished] delete");
+                            asyncDeleteDraftMmsMessage(mConversation);
+                            removeAllFileAttaches();
+                            removeAttachment(false);
+                            setSubject(subject, false);
+                            if (mConversation.getMessageCount() <= 0) {
+                                mConversation.clearThreadId();
+                            }
+                        }
+                    }
+                }
+            }
+            /// M Fix CR : ALPS01234459 @{
+            mIsLoadingDraft = false;
+            /// M @}
+            if (loadRunnable != null) {
+                mHanlder.post(loadRunnable);
+            }
+            /// M Fix CR : ALPS01071659 @{
+            deleteGruoupMmsDraft();
+            /// @}
+        }
+
+        public void updateAfterSaveDraftFinished(final Uri msgUri,
+                final int create, final boolean result) {
+            MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] msgUri is : " + msgUri
+                   + ", create : " + create);
+            // use a thread to enhance the quit compose performance which can quit to
+            // conversation list quickly
+            try {
+                if (msgUri == null && create == 1 && !result) {
+                    Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + " MmsException happened, and save failed!");
+                    removeAllFileAttaches();
+                    removeAttachment(true);
+                    mActivity.runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            // TODO Auto-generated method stub
+                            MessageUtils.showErrorDialog(mActivity,
+                                    android.R.string.dialog_alert_title,
+                                    R.string.error_add_attachment, 0, R.string.type_common_file);
+                        }
+                    });
+                    return;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] before msg uri : "
+                                                   + mMessageUri);
+                if (msgUri != null) {
+                    mMessageUri = msgUri;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] after msg uri : "
+                                                   + mMessageUri);
+
+                // / which if the save req is create, quit compose and mms maybe
+                // be killed
+                // / so store the uri into bundle, and start MMs again, which
+                // can load from preference.xml @{
+                if (mMessageUri != null && mBundle != null && create == 1) {
+                    // /M: fix bug: ALPS00568220,
+                    // /M: save message Uri in preference, some times MMS
+                    // will be killed by system
+                    SharedPreferences sp = PreferenceManager
+                            .getDefaultSharedPreferences(mActivity);
+                    SharedPreferences.Editor editor = sp.edit();
+                    editor.putString(SAVE_MSG_URI_KEY, mMessageUri.toString());
+                    MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + "save message uri to preference : " + mMessageUri.toString());
+                    editor.apply();
+                }
+                // / @}
+                if (mMessageUri != null) {
+                    if (!mConversation.getRecipients().isEmpty()) {
+                        mConversation.ensureThreadId();
+                        if (mBundle != null) {
+                            SharedPreferences sp1 =
+                                PreferenceManager.getDefaultSharedPreferences(mActivity);
+                            SharedPreferences.Editor editor1 = sp1.edit();
+                            Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                                    + "save thread id to preference : "
+                                    + mConversation.getThreadId());
+                            editor1.putLong(SAVE_MSG_THREADID_KEY, mConversation.getThreadId());
+                            editor1.apply();
+                        }
+                    }
+                    mConversation.setDraftState(true);
+                } else {
+                    mConversation.setDraftState(false);
+                }
+                // / @}
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "updateAfterSaveDraftFinished conv: "
+                            + mConversation + " uri: " + mMessageUri);
+                }
+
+                // / @}
+
+                // Be paranoid and delete any SMS drafts that might be lying
+                // around. Must do
+                // this after ensureThreadId so conv has the correct thread
+                // id.
+                asyncDeleteDraftSmsMessage(mConversation);
+
+                /// M : Fix CR : ALPS01031682
+                /// press home key, will saveDraft(Sms), and after change the recipients saveMms
+                /// the draft will update to the old thread @{
+                if (mOldSmsSaveThreadId > 0) {
+                    if (mOldSmsSaveThreadId != mConversation.getThreadId()) {
+                        deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                        ///M: add for fix issue ALPS01078057. when delete the saved sms
+                        /// should update the old thread's draft state to false.
+                        DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+                    }
+                }
+                /// M Fix CR: ALPS01105564 two draft will show in the conversation list
+                /// because the sound recorder will finish itself, when lock the screnn.
+                /// under this situtation, will send 2 save req to draftmanager,
+                /// meanwhile the mMessageUri is null
+                /// which will create 2 pdu id in the DB and bind to the origin thread .
+                /// after change the recipients, the thread will not be deleted,
+                /// so 2 threads showed in the conversationlist @{
+                deleteOldMmsDraft(mMessageUri, mConversation.getThreadId());
+                /// @}
+
+                /// M: Fix CR : ALPS01078057. when the thread changed,
+                /// if the old thread saved Mms draft before,
+                /// should reset the old thread's draft state @{
+                if (mOldMmsSaveThreadId != 0
+                        && mOldMmsSaveThreadId != mConversation.getThreadId()) {
+                    asyncDeleteOldMmsDraft(mOldMmsSaveThreadId);
+                    DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+                }
+                mOldMmsSaveThreadId = mConversation.getThreadId();
+                /// @}
+
+                // / M: Code analyze 042, For bug ALPS00117913, Delete old
+                // Mms draft when save Latest
+                // / Mms message as draft . @{
+                if (mNeedDeleteOldMmsDraft) {
+                    mNeedDeleteOldMmsDraft = false;
+                    asyncDeleteOldMmsDraft(mConversation.getThreadId());
+                }
+            } finally {
+                Log.d(TAG, "updateAfterSaveDraftFinished setSavingDraft(false)");
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+        }
+    }
+
+    /**
+     * Sets the text of the message to the specified CharSequence.
+     */
+    public void setText(CharSequence s) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setText: s = " + s);
+        }
+        /// M Fix CR : ALPS01234459, while loading draft, no need to set text @{
+        if (mIsLoadingDraft) {
+            Log.d(TAG, "[setText] run loading draft, do not need to set text");
+            return;
+        }
+        /// M @}
+        mText = s;
+        /// M: @{
+        if (mText != null && TextUtils.getTrimmedLength(mText) >= 0) {
+            syncTextToSlideshow();
+        }
+        if (mText == null || mText.length() == 0) {
+            /// M: fix bug ALPS00945813, remove MmsDraft when Length_Mms_Text are deleted
+            if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                asyncDeleteDraftMmsMessage(mConversation);
+                clearConversation(mConversation, true);
+            }
+            /// @}
+            /// M Fix CR ALPS01141440, which still has mms draft after forward message @{
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                    asyncDelete(mMessageUri, null, null);
+                    clearConversation(mConversation, true);
+                    mMessageUri = null;
+                }
+            }
+            /// @}
+        }
+
+    }
+
+    /**
+     * Returns the current message text.
+     */
+    public CharSequence getText() {
+        return mText;
+    }
+
+    /**
+     * @return True if the message has any text. A message with just whitespace is not considered
+     * to have text.
+     */
+    public boolean hasText() {
+        if (requiresMms()) {
+            return mText != null && TextUtils.getTrimmedLength(mText) > 0;
+        } else {
+            return mText != null && !TextUtils.isEmpty(mText);
+        }
+    }
+
+    public void removeAttachment(boolean notify) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT,
+                    "[removeAttachment] not default sms, can't remove attachment,just return!!");
+            return;
+        }
+        MmsLog.d(TAG, "WorkingMessage RemoveAttachment");
+        removeThumbnailsFromCache(mSlideshow);
+        /// M: fix bug ALPS00956551, need clear mText when add attachment twice
+        if (hasSlideshow()) {
+            mText = "";
+        }
+        mAttachmentType = TEXT;
+        /// M: fix bug ALPS02141556 @{
+        synchronized (this) {
+            mSlideshow = null;
+        }
+        /// @}
+        if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+        // mark this message as no longer having an attachment
+        updateState(HAS_ATTACHMENT, false, notify);
+        if (notify) {
+            // Tell ComposeMessageActivity (or other listener) that the attachment has changed.
+            // In the case of ComposeMessageActivity, it will remove its attachment panel because
+            // this working message no longer has an attachment.
+            mStatusListener.onAttachmentChanged();
+        }
+
+        clearConversation(mConversation, true);
+    }
+
+    public static void removeThumbnailsFromCache(SlideshowModel slideshow) {
+        if (slideshow != null) {
+            ThumbnailManager thumbnailManager = MmsApp.getApplication().getThumbnailManager();
+            boolean removedSomething = false;
+            Iterator<SlideModel> iterator = slideshow.iterator();
+            while (iterator.hasNext()) {
+                SlideModel slideModel = iterator.next();
+                if (slideModel.hasImage()) {
+                    /// M: change thumbnail's uri @{
+                    ImageModel im = slideModel.getImage();
+                    Uri uri = ThumbnailManager.getThumbnailUri(im);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                } else if (slideModel.hasVideo()) {
+                    /// M: change thumbnail's uri @{
+                    VideoModel vm = slideModel.getVideo();
+                    Uri uri = ThumbnailManager.getThumbnailUri(vm);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                }
+            }
+            if (removedSomething) {
+                // HACK: the keys to the thumbnail cache are the part uris, such as mms/part/3
+                // Because the part table doesn't have auto-increment ids, the part ids are reused
+                // when a message or thread is deleted. For now, we're clearing the whole thumbnail
+                // cache so we don't retrieve stale images when part ids are reused. This will be
+                // fixed in the next release in the mms provider.
+                MmsApp.getApplication().getThumbnailManager().clearBackingStore();
+            }
+        }
+    }
+
+    /**
+     * Adds an attachment to the message, replacing an old one if it existed.
+     * @param type Type of this attachment, such as {@link IMAGE}
+     * @param dataUri Uri containing the attachment data (or null for {@link TEXT})
+     * @param append true if we should add the attachment to a new slide
+     * @return An error code such as {@link UNKNOWN_ERROR} or {@link OK} if successful
+     */
+    public int setAttachment(int type, Uri dataUri, boolean append) {
+        MmsLog.dpi(TAG, "setAttachment type = " + type + " uri = " + dataUri);
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setAttachment type= " + type + "uri " + dataUri);
+        }
+        int result = OK;
+        SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+
+        // Special case for deleting a slideshow. When ComposeMessageActivity gets told to
+        // remove an attachment (search for AttachmentEditor.MSG_REMOVE_ATTACHMENT), it calls
+        // this function setAttachment with a type of TEXT and a null uri. Basically, it's turning
+        // the working message from an MMS back to a simple SMS. The various attachment types
+        // use slide[0] as a special case. The call to ensureSlideshow below makes sure there's
+        // a slide zero. In the case of an already attached slideshow, ensureSlideshow will do
+        // nothing and the slideshow will remain so that if a user adds a slideshow again, they'll
+        // see their old slideshow they previously deleted. Here we really delete the slideshow.
+        if (type == TEXT && mAttachmentType == SLIDESHOW && mSlideshow != null && dataUri == null
+                && !append) {
+            slideShowEditor.removeAllSlides();
+        }
+
+        /// M: This is added for failed to share only one picture with message. @{
+        if (mSlideshow == null) {
+            append = true;
+        }
+        /// @}
+
+        // Make sure mSlideshow is set up and has a slide.
+        ensureSlideshow();      // mSlideshow can be null before this call, won't be afterwards
+        slideShowEditor.setSlideshow(mSlideshow);
+
+        // Change the attachment and translate the various underlying
+        // exceptions into useful error codes.
+        try {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (type >= ATTACHMENT) {
+                if (mSlideshow == null) {
+                    mSlideshow = SlideshowModel.createNew(mActivity);
+                }
+                new FileAttachmentUtils().setOrAppendFileAttachment(
+                        mActivity, mSlideshow, mText, type, dataUri, append);
+            } else { /// @}
+                if (append) {
+                    appendMedia(type, dataUri);
+                } else {
+                    changeMedia(type, dataUri);
+                }
+            }
+            /// @}
+        } catch (MmsException e) {
+            /// M:
+            MmsLog.e(TAG, e.getMessage() != null ? e.getMessage() : "setAttachment MmsException");
+            result = UNKNOWN_ERROR;
+        } catch (UnsupportContentTypeException e) {
+            /// M: fix bug ALPS604911, modify toast msg
+            result = UNSUPPORTED_TYPE;
+        } catch (ExceedMessageSizeException e) {
+            result = MESSAGE_SIZE_EXCEEDED;
+        } catch (ResolutionException e) {
+            result = IMAGE_TOO_LARGE;
+        /// M: @{
+        } catch (ContentRestrictionException e) {
+            result = sCreationMode;
+        } catch (RestrictedResolutionException e) {
+            result = RESTRICTED_RESOLUTION;
+        } catch (IllegalStateException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (IllegalArgumentException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (SecurityException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        }
+        /// @}
+
+        MmsLog.d(TAG, "setAttachment result = " + result);
+
+        // If we were successful, update mAttachmentType and notify
+        // the listener than there was a change.
+        if (result == OK) {
+            mAttachmentType = type;
+            /// M: @{
+            if (mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+            if (mSlideshow.size() > 1) {
+                mAttachmentType = SLIDESHOW;
+            }
+            /// @}
+        } else if (append) {
+            // We added a new slide and what we attempted to insert on the slide failed.
+            // Delete that slide, otherwise we could end up with a bunch of blank slides.
+//            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            /// M: @{
+            if (slideShowEditor == null || mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+             /// @}
+
+            /// M: Modify ALPS00566470 @{
+            if (!mOpWorkingMessageExt.setAttachment(type, ATTACHMENT,
+                    slideShowEditor)) {
+                slideShowEditor.removeSlide(mSlideshow.size() - 1);
+            }
+        }
+
+        // correctAttachmentState();
+        mIsUpdateAttachEditor = true;
+
+        if (mSlideshow != null && type == IMAGE) {
+            // Prime the image's cache; helps A LOT when the image is coming from the network
+            // (e.g. Picasa album). See b/5445690.
+            int numSlides = mSlideshow.size();
+            if (numSlides > 0) {
+                ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+                if (imgModel != null) {
+                    cancelThumbnailLoading();
+                    imgModel.loadThumbnailBitmap(null);
+                }
+            }
+        }
+        mStatusListener.onAttachmentChanged();  // have to call whether succeeded or failed,
+                                                // because a replace that fails, removes the slide
+
+        if (!MmsConfig.getMultipartSmsEnabled()) {
+            if (!append && mAttachmentType == TEXT && type == TEXT) {
+                int[] params = SmsMessage.calculateLength(getText(), false);
+                /* SmsMessage.calculateLength returns an int[4] with:
+                *   int[0] being the number of SMS's required,
+                *   int[1] the number of code units used,
+                *   int[2] is the number of code units remaining until the next message.
+                *   int[3] is the encoding type that should be used for the message.
+                */
+                int msgCount = params[0];
+                /** M; change 4.1 google default
+                // if (msgCount > 1) {
+                //    // The provider doesn't support multi-part sms's so as soon as the user types
+                //    // an sms longer than one segment, we have to turn the message into an mms.
+                 */
+                if (msgCount >= MmsConfig.getSmsToMmsTextThreshold()) {
+                    setLengthRequiresMms(true, false);
+                } else {
+                    updateState(HAS_ATTACHMENT, hasAttachment(), true);
+                }
+            } else {
+                updateState(HAS_ATTACHMENT, hasAttachment(), true);
+            }
+        } else {
+            // Set HAS_ATTACHMENT if we need it.
+            updateState(HAS_ATTACHMENT, hasAttachment(), true);
+        }
+        correctAttachmentState();
+        if (type != IMAGE && mActivity instanceof ComposeMessageActivity) {
+            ((ComposeMessageActivity) mActivity).setWaitingAttachment(false);
+        }
+        return result;
+    }
+
+    /**
+     * Returns true if this message contains anything worth saving.
+     */
+    public boolean isWorthSaving() {
+        /// M:
+        MmsLog.d(M_TAG, "isWorthSaving(): hasText()="
+                + hasText() + ", hasSubject()=" + hasSubject()
+                + ", hasAttachment()=" + hasAttachment() + ", hasSlideshow()=" + hasSlideshow());
+        // If it actually contains anything, it's of course not empty.
+        if (hasText() || hasSubject() || hasAttachment() || hasSlideshow()) {
+            return true;
+        }
+        // When saveAsMms() has been called, we set FORCE_MMS to represent
+        // sort of an "invisible attachment" so that the message isn't thrown
+        // away when we are shipping it off to other activities.
+        if (isFakeMmsForDraft()) {
+            return true;
+        }
+        return false;
+    }
+
+    private void cancelThumbnailLoading() {
+        int numSlides = mSlideshow != null ? mSlideshow.size() : 0;
+        if (numSlides > 0) {
+            ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+            if (imgModel != null) {
+                imgModel.cancelThumbnailLoading();
+            }
+        }
+    }
+
+    /**
+     * Returns true if FORCE_MMS is set.
+     * When saveAsMms() has been called, we set FORCE_MMS to represent
+     * sort of an "invisible attachment" so that the message isn't thrown
+     * away when we are shipping it off to other activities.
+     */
+    public boolean isFakeMmsForDraft() {
+        return (mMmsState & FORCE_MMS) > 0;
+    }
+
+    /**
+     * Makes sure mSlideshow is set up.
+     */
+    private void ensureSlideshow() {
+        if (mSlideshow != null) {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (mSlideshow.size() > 0) {
+                return;
+            } else {
+                ///M: Modify for ALPS01250908
+                try {
+                    mSlideshow.add(new SlideModel(mSlideshow));
+                } catch (ContentRestrictionException e) {
+                    Log.e(TAG, "throw a ContentRestrictionException in ensureSlideshow");
+                }
+                return;
+            }
+            /// @}
+        }
+
+        SlideshowModel slideshow = SlideshowModel.createNew(mActivity);
+        SlideModel slide = new SlideModel(slideshow);
+        slideshow.add(slide);
+
+        mSlideshow = slideshow;
+    }
+
+    /**
+     * Change the message's attachment to the data in the specified Uri.
+     * Used only for single-slide ("attachment mode") messages.
+     */
+    private void changeMedia(int type, Uri uri) throws MmsException {
+        SlideModel slide = mSlideshow.get(0);
+
+        MediaModel media;
+        Uri uriTemp = null;
+        if (slide == null) {
+            Log.w(LogTag.TAG, "[WorkingMessage] changeMedia: no slides!");
+            return;
+        }
+
+        /// M: add for attachment enhance @{
+        /// M: If we're changing to text, just bail out. @{
+        if (type == TEXT) {
+            if (mSlideshow != null && mSlideshow.size() > 0) {
+                /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support. @{
+                if (mOpWorkingMessageExt.removeAllAttachFiles()) {
+                    mSlideshow.removeAllAttachFiles();
+                }
+                mSlideshow.clear();
+                mSlideshow = null;
+                ensureSlideshow();
+                if (isResizeImage()) {
+                    // Delete our MMS message, if there is one.
+                    if (mMessageUri != null) {
+                        asyncDelete(mMessageUri, null, null);
+                        setResizeImage(false);
+                    }
+                }
+            }
+            return;
+        }
+        /// M: get thumbnail uri @{
+        if (slide.hasImage()) {
+            ImageModel imageModel = slide.getImage();
+            uriTemp = Uri.parse(imageModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + imageModel.getSrc());
+        } else if (slide.hasVideo()) {
+            VideoModel videoModel = slide.getVideo();
+            uriTemp = Uri.parse(videoModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + videoModel.getSrc());
+        }
+        /// @}
+
+        // Make a correct MediaModel for the type of attachment.
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+        /// M: Code analyze 041, For new feature , add drm support . @{
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        int increaseSize = media.getMediaPackagedSize()
+                + MmsSizeUtils.getSlideshowReserveSize()
+                - mSlideshow.getCurrentSlideshowSize();
+        // OP01
+        increaseSize = mOpWorkingMessageExt.changeMedia(increaseSize,
+                mSlideshow.getAttachFilesPackagedSize());
+        if (increaseSize > 0) {
+            mSlideshow.checkMessageSize(increaseSize);
+        }
+
+        // Remove any previous attachments.
+        removeSlideAttachments(slide);
+
+        slide.add(media);
+
+        if (uriTemp != null) {
+            MmsApp.getApplication().getThumbnailManager().removeThumbnail(uriTemp);
+        }
+        /// @}
+        // For video and audio, set the duration of the slide to that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Add the message's attachment to the data in the specified Uri to a new slide.
+     */
+    private void appendMedia(int type, Uri uri) throws MmsException {
+
+        // If we're changing to text, just bail out.
+        if (type == TEXT) {
+            return;
+        }
+
+        // The first time this method is called, mSlideshow.size() is going to be
+        // one (a newly initialized slideshow has one empty slide). The first time we
+        // attach the picture/video to that first empty slide. From then on when this
+        // function is called, we've got to create a new slide and add the picture/video
+        // to that new slide.
+        boolean addNewSlide = true;
+        if (mSlideshow.size() == 1 && !mSlideshow.isSimple()) {
+            addNewSlide = false;
+        }
+        if (mSlideshow.size() == 1 && mSlideshow.get(0) != null
+                && mSlideshow.get(0).hasAudio() && mSlideshow.get(0).hasImage()) {
+            addNewSlide = true;
+        }
+        if (addNewSlide) {
+            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            if (!slideShowEditor.addNewSlide()) {
+                return;
+            }
+        }
+        mIsUpdateAttachEditor = false;
+        // Make a correct MediaModel for the type of attachment.
+        MediaModel media;
+        SlideModel slide = mSlideshow.get(mSlideshow.size() - 1);
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.IMAGE);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.VIDEO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.AUDIO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        slide.add(media);
+
+        /// M: for vcard, since we append a media, remove vCard
+        removeAllFileAttaches();
+
+        // For video and audio, set the duration of the slide to
+        // that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Returns true if the message has an attachment (including slideshows).
+     */
+    public boolean hasAttachment() {
+        return (mAttachmentType > TEXT);
+    }
+
+    /**
+     * Returns the slideshow associated with this message.
+     */
+    public SlideshowModel getSlideshow() {
+        return mSlideshow;
+    }
+
+    /**
+     * Returns true if the message has a real slideshow, as opposed to just
+     * one image attachment, for example.
+     */
+    public boolean hasSlideshow() {
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        return (mSlideshow != null && mSlideshow.size() > 1);
+        /// @}
+    }
+
+    /**
+     * Sets the MMS subject of the message.  Passing null indicates that there
+     * is no subject.  Passing "" will result in an empty subject being added
+     * to the message, possibly triggering a conversion to MMS.  This extra
+     * bit of state is needed to support ComposeMessageActivity converting to
+     * MMS when the user adds a subject.  An empty subject will be removed
+     * before saving to disk or sending, however.
+     */
+    public void setSubject(CharSequence s, boolean notify) {
+        /// M: @{
+        boolean flag = ((s != null) && TextUtils.getTrimmedLength(s) > 0);
+        mSubject = s;
+        if (flag) {
+            updateState(HAS_SUBJECT, flag, notify);
+        } else {
+            updateState(HAS_SUBJECT, flag, notify);
+        }
+        /// @}
+        /// M Fix CR ALPS01141440 @{
+        if (mSubject == null || mSubject.length() == 0) {
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == 0) {
+                    asyncDelete(mMessageUri, null, null);
+                    if (mConversation != null) {
+                        clearConversation(mConversation, true);
+                    }
+                    mMessageUri = null;
+                }
+            }
+        }
+       /// @}
+    }
+
+    /**
+     * Returns the MMS subject of the message.
+     */
+    public CharSequence getSubject() {
+        return mSubject;
+    }
+
+    /**
+     * Returns true if this message has an MMS subject. A subject has to be more than just
+     * whitespace.
+     * @return
+     */
+    public boolean hasSubject() {
+        return mSubject != null && TextUtils.getTrimmedLength(mSubject) > 0;
+    }
+
+    /**
+     * Moves the message text into the slideshow.  Should be called any time
+     * the message is about to be sent or written to disk.
+     */
+    private synchronized void syncTextToSlideshow() {
+        /// M: Because progress run async, so get the value first.
+        boolean waitingAttachment = false;
+        if (mActivity instanceof ComposeMessageActivity) {
+            waitingAttachment = ((ComposeMessageActivity) mActivity).isWaitingAttachment();
+        }
+
+        /// M: fix bug ALPS01365426, must calculate mIsExceedSize
+        if (mSlideshow != null && !TextUtils.isEmpty(mText)
+                && TextUtils.getTrimmedLength(mText) >= 0) {
+            int currentSize = getCurrentMessageSize();
+            if (currentSize > MmsConfig.getUserSetMmsSizeLimit(true) && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+        }
+        /// @}
+
+        if (mSlideshow == null || mSlideshow.size() != 1)
+            return;
+        try {
+            SlideModel slide = mSlideshow.get(0);
+            TextModel text;
+            /// M: change google default. @{
+            TextModel oldText = null;
+            if (slide != null) {
+                oldText = slide.getText();
+            }
+            /// M: fix bug ALPS01013522, workaround avoiding mSlideshow NPE
+            MmsLog.d(TAG, "syncTextToSlideshow() mSlideshow = "
+                    + String.valueOf(mSlideshow == null));
+            // Add a TextModel to slide 0 if one doesn't already exist
+            text = new TextModel(mActivity, ContentType.TEXT_PLAIN, "text_0.txt",
+                    mSlideshow != null ? mSlideshow.getLayout().getTextRegion()
+                                   : SlideshowModel.createNew(mActivity)
+                                           .getLayout().getTextRegion(),
+                    (!TextUtils.isEmpty(mText) &&
+                            TextUtils.getTrimmedLength(mText) >= 0)
+                                    ? (mText.toString()).getBytes() : null);
+
+            //klocwork issue pid:18444
+            if (slide != null) {
+                int oldLength = (oldText != null && oldText.getText() != null)
+                                ? oldText.getText().getBytes().length : 0;
+                int newLength = mText != null ? mText.toString().getBytes().length : 0;
+                if (newLength - oldLength > 0) {
+                    if (getCurrentMessageSize() + (newLength - oldLength)
+                                > MmsConfig.getUserSetMmsSizeLimit(true)) {
+                        throw new ExceedMessageSizeException();
+                    }
+                }
+                slide.add(text);
+            }
+        } catch (ExceedMessageSizeException e) {
+            if (!TextUtils.isEmpty(mText) && TextUtils.getTrimmedLength(mText) >= 0
+                    && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+            return;
+        } catch (ArrayIndexOutOfBoundsException e) {
+            /// M: fix bug ALPS01659457
+            Log.e(TAG, "syncTextToSlideshow ArrayIndexOutOfBoundsException");
+            return;
+        }
+        /// @}
+    }
+
+    /**
+     * Sets the message text out of the slideshow.  Should be called any time
+     * a slideshow is loaded from disk.
+     */
+    private void syncTextFromSlideshow() {
+        // Don't sync text for real slideshows.
+        if (mSlideshow.size() != 1) {
+            return;
+        }
+
+        SlideModel slide = mSlideshow.get(0);
+        if (slide == null || !slide.hasText()) {
+            return;
+        }
+
+        mText = slide.getText().getText();
+    }
+
+    /**
+     * Removes the subject if it is empty, possibly converting back to SMS.
+     */
+    private void removeSubjectIfEmpty(boolean notify) {
+        if (!hasSubject()) {
+            setSubject(null, notify);
+        }
+    }
+
+    /**
+     * Gets internal message state ready for storage.  Should be called any
+     * time the message is about to be sent or written to disk.
+     */
+    private void prepareForSave(boolean notify) {
+        // Make sure our working set of recipients is resolved
+        // to first-class Contact objects before we save.
+        syncWorkingRecipients();
+
+        if (requiresMms()) {
+            ensureSlideshow();
+            syncTextToSlideshow();
+            /// M:
+            removeSubjectIfEmpty(notify);
+        }
+    }
+
+    /**
+     * Resolve the temporary working set of recipients to a ContactList.
+     */
+    public void syncWorkingRecipients() {
+        if (mWorkingRecipients != null) {
+            ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+            mConversation.setRecipients(recipients);    // resets the threadId to zero
+            /// M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(recipients.size() > 1, true);
+            mWorkingRecipients = null;
+        }
+    }
+
+    public void updateStateForGroupMmsChanged() {
+        ContactList recipients = mConversation.getRecipients();
+        setHasMultipleRecipients(recipients.size() > 1, false);
+    }
+
+    public String getWorkingRecipients() {
+        // this function is used for DEBUG only
+        if (mWorkingRecipients == null) {
+            return null;
+        }
+        ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+        return recipients.serialize();
+    }
+
+    // Call when we've returned from adding an attachment. We're no longer forcing the message
+    // into a Mms message. At this point we either have the goods to make the message a Mms
+    // or we don't. No longer fake it.
+    public void removeFakeMmsForDraft() {
+        updateState(FORCE_MMS, false, false);
+    }
+
+    /**
+     * Force the message to be saved as MMS and return the Uri of the message.
+     * Typically used when handing a message off to another activity.
+     */
+    /// M: add synchronized.
+    public synchronized Uri saveAsMms(boolean notify) {
+        if (DEBUG) LogTag.debug("saveAsMms mConversation=%s", mConversation);
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveAsMms] Non-default sms, cann't save,just return!!");
+            return mMessageUri;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG, "saveAsMms mDiscarded: true mConversation: " + mConversation +
+                    " returning NULL uri and bailing");
+            return null;
+        }
+
+        // FORCE_MMS behaves as sort of an "invisible attachment", making
+        // the message seem non-empty (and thus not discarded).  This bit
+        // is sticky until the last other MMS bit is removed, at which
+        // point the message will fall back to SMS.
+        updateState(FORCE_MMS, true, notify);
+
+        // Collect our state to be written to disk.
+        prepareForSave(true /* notify */);
+
+        try {
+            // Make sure we are saving to the correct thread ID.
+            DraftCache.getInstance().setSavingDraft(true);
+            if (!mConversation.getRecipients().isEmpty()) {
+                mConversation.ensureThreadId();
+            }
+            mConversation.setDraftState(true);
+
+            //PduPersister persister = PduPersister.getPduPersister(mActivity);
+            SendReq sendReq = makeSendReq(mConversation, mSubject);
+
+            sendReq = mOpWorkingMessageExt.opSaveAsMms(sendReq);
+
+            long threadId = mConversation.getThreadId();
+
+            Log.d(TAG_DRAFT, "[saveAsMms] threadId : " + threadId);
+
+            MmsDraftData mdd =
+                DraftManager.getInstance().saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mMessageUri, mSlideshow, sendReq, mActivity, null);
+            if (mdd != null) {
+//                if (mMessageUri == null) {
+                    mMessageUri = mdd.getMessageUri();
+                    if (mdd.getCreateOrUpdate() == 1) {
+                        if (mMessageUri == null && !mdd.getBooleanResult()) {
+                            Log.d(TAG_DRAFT, "[saveAsMms] MmsException happened,and save failed!");
+                            removeAllFileAttaches();
+                            removeAttachment(true);
+                            mActivity.runOnUiThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    // TODO Auto-generated method stub
+                                    MessageUtils.showErrorDialog(mActivity,
+                                                    android.R.string.dialog_alert_title,
+                                                    R.string.error_add_attachment, 0,
+                                                    R.string.type_common_file);
+                                }
+                            });
+                        }
+                    }
+                    MmsLog.dpi(TAG_DRAFT,
+                            "[saveAsMms] call draft manager return , and mMessageUri : "
+                            + mMessageUri);
+                    asyncDeleteDraftSmsMessage(mConversation);
+//                }
+            }
+
+            /// M: google jb.mr1 patch
+            // If we don't already have a Uri lying around, make a new one.  If we do
+            // have one already, make sure it is synced to disk.
+
+            mHasMmsDraft = true;
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+        return mMessageUri;
+    }
+
+    /// M : FIX CR : ALPS01795853
+    /// While exist A MMS draft, then create a new composer, input A phone number
+    /// and input some text, then add image from gallery, this will cause delete the
+    /// MMS draft whcih saved before
+    ///
+    /// Root cause : while enter the document UI, composer will enter the onStop,
+    ///              which will save the sms draft that the content is inputted text
+    ///              after save finished, will delete the MMS draft @{
+    public void setTruntoChooseAttach(boolean chooseOrNot) {
+        Log.d(TAG_DRAFT, "[setTruntoChooseAttach] set to be : " + chooseOrNot);
+        mIsTurnToChooseAttach = chooseOrNot;
+    }
+    /// @}
+
+    /**
+     * Save this message as a draft in the conversation previously specified
+     * to {@link setConversation}.
+     */
+    public void saveDraft(final boolean isStopping) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveDraft] not default sms, no need to save draft, just return!!");
+            return;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG_DRAFT, "saveDraft mDiscarded: true mConversation: " + mConversation +
+                " skipping saving draft and bailing");
+            return;
+        }
+
+        // Make sure setConversation was called.
+        if (mConversation == null) {
+            throw new IllegalStateException("saveDraft() called with no conversation");
+        }
+
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "saveDraft for mConversation " + mConversation);
+        }
+
+        // Get ready to write to disk. But don't notify message status when saving draft
+        prepareForSave(false /* notify */);
+
+        if (requiresMms()) {
+            asyncUpdateDraftMmsMessage(mConversation, isStopping, mInterface);
+            mHasMmsDraft = true;
+
+            /// M: Update state of the draft cache.
+            mConversation.setDraftState(true);
+        } else {
+            String content = mText.toString();
+
+            // bug 2169583: don't bother creating a thread id only to delete the thread
+            // because the content is empty. When we delete the thread in updateDraftSmsMessage,
+            // we didn't nullify conv.mThreadId, causing a temperary situation where conv
+            // is holding onto a thread id that isn't in the database. If a new message arrives
+            // and takes that thread id (because it's the next thread id to be assigned), the
+            // new message will be merged with the draft message thread, causing confusion!
+            if (!TextUtils.isEmpty(content)) {
+                asyncUpdateDraftSmsMessage(mConversation, content);
+                mHasSmsDraft = true;
+            } else {
+                // When there's no associated text message, we have to handle the case where there
+                // might have been a previous mms draft for this message. This can happen when a
+                // user turns an mms back into a sms, such as creating an mms draft with a picture,
+                // then removing the picture.
+                /// Which used to fix load draft from widget, the compose will flicker
+                /// while flicking, this will delete mms draft @{
+                //asyncDeleteDraftMmsMessage(mConversation);
+                /// @}
+                mMessageUri = null;
+            }
+        }
+        // Update state of the draft cache.
+        /// M: coomment google default.
+        // mConversation.setDraftState(true);
+
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    synchronized public void discard() {
+        discard(true);
+    }
+    /// @}
+
+    public void unDiscard() {
+        if (DEBUG) LogTag.debug("unDiscard");
+
+        mDiscarded = false;
+    }
+
+    /**
+     * Returns true if discard() has been called on this message.
+     */
+    public boolean isDiscarded() {
+        return mDiscarded;
+    }
+
+    /**
+     * To be called from our Activity's onSaveInstanceState() to give us a chance
+     * to stow our state away for later retrieval.
+     *
+     * @param bundle The Bundle passed in to onSaveInstanceState
+     */
+    public void writeStateToBundle(Bundle bundle) {
+        mBundle = bundle;
+        if (hasSubject()) {
+            bundle.putString("subject", mSubject.toString());
+        }
+
+        if (mMessageUri != null) {
+            bundle.putParcelable("msg_uri", mMessageUri);
+        } else if (hasText()) {
+            bundle.putString("sms_body", mText.toString());
+        }
+        /// M: fix bug ALPS00779871
+        if (mMessageUri == null) {
+            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+            SharedPreferences.Editor editor = sp.edit();
+            editor.putString(SAVE_MSG_URI_KEY, "");
+            editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+            editor.apply();
+        }
+    }
+
+    /**
+     * To be called from our Activity's onCreate() if the activity manager
+     * has given it a Bundle to reinflate
+     * @param bundle The Bundle passed in to onCreate
+     */
+    public void readStateFromBundle(Bundle bundle) {
+        if (bundle == null) {
+            return;
+        }
+
+        String subject = bundle.getString("subject");
+        setSubject(subject, false);
+
+        Uri uri = (Uri) bundle.getParcelable("msg_uri");
+        ///M: fix bug: ALPS00568220,
+        ///M: load message Uri from preference, because some times MMS will be killed by system
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+        long threadId = sp.getLong(SAVE_MSG_THREADID_KEY, -1);
+        if (uri == null && mConversation != null && mConversation.getThreadId() == threadId
+                && threadId != -1) {
+            String uriString = sp.getString(SAVE_MSG_URI_KEY, null);
+            if (uriString != null && !uriString.equals("")) {
+                uri = Uri.parse(uriString);
+            }
+        }
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(SAVE_MSG_URI_KEY, "");
+        editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+        editor.apply();
+
+        if (uri != null) {
+            threadId = 0L;
+            if (mConversation != null) {
+                threadId = mConversation.getThreadId();
+                if (threadId <= 0 && !mConversation.getRecipients().isEmpty()) {
+                    threadId = mConversation.ensureThreadId();
+                }
+            }
+
+            MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                    threadId, uri, mActivity, null);
+            if (mdd != null && mdd.getBooleanResult()) {
+                mSlideshow = mdd.getSlideshow();
+                mMessageUri = mdd.getMessageUri();
+                syncTextFromSlideshow();
+                correctAttachmentState();
+            }
+//            loadFromUri(uri);
+            /// M: fix bug ALPS00779135
+            if (mSlideshow != null) {
+                mHasMmsDraft = true;
+            }
+            return;
+        } else {
+            String body = bundle.getString("sms_body");
+            /// M: Code analyze 049, For bug ALPS00106234, to solve the
+            /// "JE" pops up after you press Back key . @{
+            if (body == null) {
+                mText = "";
+            } else {
+                mText = body;
+            }
+            /// @}
+        }
+    }
+
+    /**
+     * Update the temporary list of recipients, used when setting up a
+     * new conversation.  Will be converted to a ContactList on any
+     * save event (send, save draft, etc.)
+     */
+    public void setWorkingRecipients(List<String> numbers) {
+        mWorkingRecipients = numbers;
+        String s = null;
+        if (numbers != null) {
+            int size = numbers.size();
+            switch (size) {
+            case 1:
+                s = numbers.get(0);
+                break;
+            case 0:
+                s = "empty";
+                break;
+            default:
+                s = "{...} len=" + size;
+            }
+        }
+        /// M:
+        MmsLog.dpi(TAG, "setWorkingRecipients: numbers=" + s);
+    }
+
+    private void dumpWorkingRecipients() {
+        Log.i(TAG, "-- mWorkingRecipients:");
+
+        if (mWorkingRecipients != null) {
+            int count = mWorkingRecipients.size();
+            for (int i = 0; i < count; i++) {
+                Log.d(TAG, "   [" + i + "] " + mWorkingRecipients.get(i));
+            }
+            Log.i(TAG, "");
+        }
+    }
+
+    public void dump() {
+        Log.i(TAG, "WorkingMessage:");
+        dumpWorkingRecipients();
+        if (mConversation != null) {
+            MmsLog.dpi(TAG, "mConversation: " + mConversation.toString());
+        }
+    }
+
+    /**
+     * Set the conversation associated with this message.
+     */
+    public void setConversation(Conversation conv) {
+        if (DEBUG) {
+            MmsLog.dpi(TAG, "setConversation " + mConversation + " -> " + conv);
+        }
+
+        mConversation = conv;
+
+        // Convert to MMS if there are any email addresses in the recipient list.
+        if (conv != null) {
+            ContactList contactList = conv.getRecipients();
+            setHasEmail(contactList.containsEmail(), false);
+            // / M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(contactList.size() > 1, false);
+        }
+    }
+
+    public Conversation getConversation() {
+        return mConversation;
+    }
+
+    /**
+     * Hint whether or not this message will be delivered to an
+     * an email address.
+     */
+    public void setHasEmail(boolean hasEmail, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.setHasEmail(" + hasEmail + ", " + notify + ")");
+        if (MmsConfig.getEmailGateway() != null) {
+            updateState(RECIPIENTS_REQUIRE_MMS, false, notify);
+        } else {
+            updateState(RECIPIENTS_REQUIRE_MMS, hasEmail, notify);
+        }
+    }
+    /** google JB.MR1 patch, group mms
+     * Set whether this message will be sent to multiple recipients. This is a hint whether the
+     * message needs to be sent as an mms or not. If MmsConfig.getGroupMmsEnabled is false, then
+     * the fact that the message is sent to multiple recipients is not a factor in determining
+     * whether the message is sent as an mms, but the other factors (such as, "has a picture
+     * attachment") still hold true.
+     */
+    public void setHasMultipleRecipients(boolean hasMultipleRecipients, boolean notify) {
+        updateState(MULTIPLE_RECIPIENTS,
+                hasMultipleRecipients &&
+                MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity),
+                notify);
+    }
+
+    /**
+     * Returns true if this message would require MMS to send.
+     */
+    public boolean requiresMms() {
+        return (mMmsState > 0);
+    }
+
+    /**
+     * Set whether or not we want to send this message via MMS in order to
+     * avoid sending an excessive number of concatenated SMS messages.
+     * @param: mmsRequired is the value for the LENGTH_REQUIRES_MMS bit.
+     * @param: notify Whether or not to notify the user.
+     */
+    public void setLengthRequiresMms(boolean mmsRequired, boolean notify) {
+        updateState(LENGTH_REQUIRES_MMS, mmsRequired, notify);
+    }
+
+    private static String stateString(int state) {
+        if (state == 0)
+            return "<none>";
+
+        StringBuilder sb = new StringBuilder();
+        if ((state & RECIPIENTS_REQUIRE_MMS) > 0)
+            sb.append("RECIPIENTS_REQUIRE_MMS | ");
+        if ((state & HAS_SUBJECT) > 0)
+            sb.append("HAS_SUBJECT | ");
+        if ((state & HAS_ATTACHMENT) > 0)
+            sb.append("HAS_ATTACHMENT | ");
+        if ((state & LENGTH_REQUIRES_MMS) > 0)
+            sb.append("LENGTH_REQUIRES_MMS | ");
+        if ((state & FORCE_MMS) > 0)
+            sb.append("FORCE_MMS | ");
+        /// M: google JB.MR1 patch, group mms
+        if ((state & MULTIPLE_RECIPIENTS) > 0)
+            sb.append("MULTIPLE_RECIPIENTS | ");
+
+        if (sb.length() > 3) {
+            sb.delete(sb.length() - 3, sb.length());
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Sets the current state of our various "MMS required" bits.
+     *
+     * @param state The bit to change, such as {@link HAS_ATTACHMENT}
+     * @param on If true, set it; if false, clear it
+     * @param notify Whether or not to notify the user
+     */
+    private void updateState(int state, boolean on, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.updateState(" + state + ", " + on + ", " + notify + ")");
+        if (!sMmsEnabled) {
+            // If Mms isn't enabled, the rest of the Messaging UI should not be using any
+            // feature that would cause us to to turn on any Mms flag and show the
+            // "Converting to multimedia..." message.
+            return;
+        }
+        int oldState = mMmsState;
+        if (on) {
+            mMmsState |= state;
+            /// M: Code analyze 048, For bug ALPS00338410, The message only with recipients
+            /// should not be saved as draft display in the all
+            /// messages list after you press "Back" . @{
+            if ((mMmsState & ~FORCE_MMS) > 0) {
+                mMmsState = (mMmsState & ~FORCE_MMS);
+            }
+            /// @}
+        } else {
+            mMmsState &= ~state;
+        }
+
+        // If we are clearing the last bit that is not FORCE_MMS,
+        // expire the FORCE_MMS bit.
+        if (mMmsState == FORCE_MMS && ((oldState & ~FORCE_MMS) > 0)) {
+            mMmsState = 0;
+        }
+        /// M:
+        MmsLog.d(M_TAG, "updateState(): notify=" + notify
+                + ", oldState=" + oldState + ", mMmsState=" + mMmsState);
+        // Notify the listener if we are moving from SMS to MMS
+        // or vice versa.
+        if (notify) {
+            if (oldState == 0 && mMmsState != 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(true, true);
+                /// @}
+            } else if (oldState != 0 && mMmsState == 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(false, true);
+                /// @}
+            }
+        }
+
+        if (oldState != mMmsState) {
+            MmsLog.d(TAG, stateString(mMmsState) + mMmsState);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) LogTag.debug("updateState: %s%s = %s",
+                    on ? "+" : "-",
+                    stateString(state), stateString(mMmsState));
+        }
+    }
+
+    /**
+     * Send this message over the network.  Will call back with onMessageSent() once
+     * it has been dispatched to the telephony stack.  This WorkingMessage object is
+     * no longer useful after this method has been called.
+     *
+     * @throws ContentRestrictionException if sending an MMS and uaProfUrl is not defined
+     * in mms_config.xml.
+     * M: Code analyze 047, For new feature ALPS00316567,
+     * extend this method for msim, add a parameter for subId
+     */
+    public void send(final String recipientsInUI, final int subId) {
+        MmsLog.d(MmsApp.TXN_TAG, "Enter send(). subId = " + subId);
+        final long origThreadId = mConversation.getThreadId();
+
+        if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            LogTag.debug("send origThreadId: " + origThreadId);
+        }
+
+        removeSubjectIfEmpty(true /* notify */);
+
+        // Get ready to write to disk.
+        prepareForSave(true /* notify */);
+
+        // We need the recipient list for both SMS and MMS.
+        final Conversation conv = mConversation;
+        final String msgTxt = mText.toString();
+        final SplitToMmsAndSmsConversation spliter =
+            new SplitToMmsAndSmsConversation(conv, msgTxt);
+
+         if (spliter.getMMSConversation() != null) {
+            // uaProfUrl setting in mms_config.xml must be present to send an MMS.
+            // However, SMS service will still work in the absence of a uaProfUrl address.
+            if (MmsConfig.getUaProfUrl() == null) {
+                String err = "WorkingMessage.send MMS sending failure. mms_config.xml is " +
+                        "missing uaProfUrl setting.  uaProfUrl is required for MMS service, " +
+                        "but can be absent for SMS.";
+                RuntimeException ex = new NullPointerException(err);
+                Log.e(TAG, err, ex);
+                // now, let's just crash.
+                throw ex;
+            }
+
+            // Make local copies of the bits we need for sending a message,
+            // because we will be doing it off of the main thread, which will
+            // immediately continue on to resetting some of this state.
+            final Uri mmsUri = mMessageUri;
+            final PduPersister persister = PduPersister.getPduPersister(mActivity);
+
+            final SlideshowModel slideshow = mSlideshow;
+            final CharSequence subject = mSubject;
+
+            if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "Send mmsUri: " + mmsUri);
+            }
+
+            // Do the dirty work of sending the message off of the main UI thread.
+            new Thread(new Runnable() {
+                public void run() {
+                    SendReq sendReq = makeSendReq(spliter.getMMSConversation(), subject);
+
+                    sendReq = mOpWorkingMessageExt.opSendThreadRun(sendReq);
+
+                    // Make sure the text in slide 0 is no longer holding onto a reference to
+                    // the text in the message text box.
+                    slideshow.prepareForSend();
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for gemini . @{
+                    if (spliter.getSMSConversation() != null) {
+                        ///M: Message got split into SMS & MMS. Need to
+                        /// set the mmsuri as NULL to again update it.
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                null, persister, slideshow, sendReq, subId);
+                    }
+                    else {
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                mmsUri, persister, slideshow, sendReq, subId);
+                    }
+                    /// @}
+
+                    updateSendStats(spliter.getMMSConversation());
+
+                    if (origThreadId > 0 && origThreadId != conv.getThreadId()) {
+                        boolean isHasDraft = DraftCache.refreshDraft(mActivity, origThreadId);
+                        Log.d(TAG,
+                                "[send] origThreadId : " + origThreadId
+                                + " isHasDraft : " + isHasDraft);
+                        DraftCache.getInstance().setDraftState(origThreadId, isHasDraft);
+                    }
+                }
+            }, "WorkingMessage.send MMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getMMSConversation().getThreadId(),
+                    spliter.getMMSConversation().getRecipients());
+        }
+        if (spliter.getSMSConversation() != null) {
+            new Thread(new Runnable() {
+                public void run() {
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for msim . @{
+                    preSendSmsWorker(spliter.getSMSConversation(), msgTxt, recipientsInUI, subId,
+                            (spliter.getMMSConversation() != null) ? true : false);
+                    /// @}
+                    updateSendStats(spliter.getSMSConversation());
+                }
+            }, "WorkingMessage.send SMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getSMSConversation().getThreadId(),
+                    spliter.getSMSConversation().getRecipients());
+        }
+
+        // Mark the message as discarded because it is "off the market" after being sent.\
+        /// M: comment google default.
+        // mDiscarded = true;
+    }
+
+    // Check for the Partial Compliant conditions
+    private boolean isPartiallySMSCompliant() {
+         boolean result = false;
+         if (((mMmsState & FORCE_MMS) == 0)
+             // NO slideshow that will convert the whole message for the whole
+             // recipients into MMS
+         && ((mMmsState & LENGTH_REQUIRES_MMS) == 0)
+             // DO NOT exceed a particular threshold of SMS truncation that
+             // will convert the whole message for the whole recipients into
+             // MMS
+         && ((mMmsState & HAS_ATTACHMENT) == 0)
+             // NO attachment that will convert the whole message for the
+             // whole recipients into MMS
+         && ((mMmsState & HAS_SUBJECT) == 0)) {
+             // NO subject that will convert the whole message for the whole
+             // recipients into MMS
+             // DO NOT check RECIPIENTS_REQUIRE_MMS to allow email & alias as
+             // recipients
+            result = true;
+             // Conversation where MMS could not be mandatory for some
+             // recipients : aka phone numbers.
+        }
+        return result;
+    }
+
+    // set conversation and split it into SMS & MMS conversation
+    private class SplitToMmsAndSmsConversation implements ISplitToMmsAndSmsConversationCallback {
+        private Conversation mSmsConv;
+
+        private Conversation mMmsConv;
+
+        private ContactList listSms;
+
+        private ContactList listMms;
+
+        // Split if necessary the initial conversation in one MMS conversation
+        // or/and one SMS conversation
+        // Allow to send SMS with phone numbers recipients when the conversation
+        // is still SMS compliant.
+
+        public SplitToMmsAndSmsConversation(final Conversation conv, final String msgTxt) {
+            mMmsConv = null;
+            mSmsConv = null;
+            Log.d(TAG, "setConversationToSplitAsSmsMms");
+
+            if (!mOpWorkingMessageExt.onCreateSplitToMmsAndSmsConv(this, conv)) {
+                if (requiresMms() || addressContainsEmailToMms(conv, msgTxt)) {
+                    mMmsConv = conv;
+                } else {
+                    mSmsConv = conv;
+                }
+                return;
+            }
+        }
+
+        private void splitConv(final Conversation conv) {
+            ContactList list = null;
+            Contact contact = null;
+            String number = null;
+            listSms = null;
+            listMms = null;
+
+            // Conversation with SMS/MMS Split is supported
+            if (conv != null) {
+                list = conv.getRecipients();
+                if (list != null) {
+                    if (requiresMms()) {
+                        if (isPartiallySMSCompliant()) {
+                            for (int i = 0; i < list.size(); i++) {
+                                contact = list.get(i);
+                                if (contact != null) {
+                                    number = contact.getNumber();
+                                    if (!TextUtils.isEmpty(number)) {
+                                        if (Mms.isPhoneNumber(number)) {
+                                            addContactAsSms(contact);
+                                        } else {
+                                            addContactAsMms(contact);
+                                        }
+                                    } else {
+                                        addContactAsMms(contact);
+                                    }
+                                } // contact
+                            }
+                        } else {
+                            listMms = list;
+                        } // isPartiallySMSCompliant
+                    } else {
+                        listSms = list;
+                    } // requiresMms
+
+                    if (listMms != null) {
+                        mMmsConv = conv;
+                        mMmsConv.setRecipients(listMms);
+                        if (listSms != null) {
+                            mSmsConv = Conversation.createNew(mActivity.getApplicationContext());
+                            mSmsConv.setRecipients(listSms);
+                        }
+                    } else if (listSms != null) {
+                        mSmsConv = conv;
+                        mSmsConv.setRecipients(listSms);
+                    }
+                }
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsMms(Contact contact) {
+            if (listMms == null) {
+                listMms = new ContactList();
+            }
+            if (!listMms.contains(contact)) {
+                listMms.add(contact);
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsSms(Contact contact) {
+            if (listSms == null) {
+                listSms = new ContactList();
+            }
+            if (!listSms.contains(contact)) {
+                listSms.add(contact);
+            }
+        }
+
+        protected Conversation getSMSConversation() {
+            return mSmsConv;
+        }
+
+        protected Conversation getMMSConversation() {
+            return mMmsConv;
+        }
+
+        /// M: @{
+        public void splitConvCallback(final IConversationCallback conv) {
+            splitConv((Conversation) conv);
+        }
+        /// @}
+    }
+
+    // Be sure to only call this on a background thread.
+    private void updateSendStats(final Conversation conv) {
+        String[] dests = conv.getRecipients().getNumbers();
+        final ArrayList<String> phoneNumbers = new ArrayList<String>(Arrays.asList(dests));
+
+        DataUsageStatUpdater updater = new DataUsageStatUpdater(mActivity);
+        updater.updateWithPhoneNumber(phoneNumbers);
+    }
+
+    private boolean addressContainsEmailToMms(Conversation conv, String text) {
+        if (MmsConfig.getEmailGateway() != null) {
+            String[] dests = conv.getRecipients().getNumbers();
+            int length = dests.length;
+            for (int i = 0; i < length; i++) {
+                if (Mms.isEmailAddress(dests[i]) || MessageUtils.isAlias(dests[i])) {
+                    String mtext = dests[i] + " " + text;
+                    int[] params = SmsMessage.calculateLength(mtext, false);
+                    if (params[0] > 1) {
+                        updateState(RECIPIENTS_REQUIRE_MMS, true, true);
+                        ensureSlideshow();
+                        syncTextToSlideshow();
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    // Message sending stuff
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void preSendSmsWorker(Conversation conv, String msgText, String recipientsInUI,
+            int subId, boolean hasBeenSplit) {
+    /// @}
+        // If user tries to send the message, it's a signal the inputted text is what they wanted.
+        UserHappinessSignals.userAcceptedImeText(mActivity);
+
+        mStatusListener.onPreMessageSent();
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        long origThreadId = conv.getThreadId();
+
+        if (mForceUpdateThreadId) {
+            conv.setNeedForceUpdateThreadId(true);
+            mForceUpdateThreadId = false;
+        }
+
+        // Make sure we are still using the correct thread ID for our recipient set.
+        long threadId = conv.ensureThreadId();
+
+        String semiSepRecipients = conv.getRecipients().serialize();
+
+        // recipientsInUI can be empty when the user types in a number and hits send
+        if (LogTag.SEVERE_WARNING && ((origThreadId != 0 && origThreadId != threadId) ||
+               ((!hasBeenSplit) && (!semiSepRecipients.equals(recipientsInUI))
+                       && !TextUtils.isEmpty(recipientsInUI)))) {
+            String msg = origThreadId != 0 && origThreadId != threadId ?
+                    "WorkingMessage.preSendSmsWorker threadId changed or " +
+                    "recipients changed. origThreadId: " +
+                    origThreadId + " new threadId: " + threadId +
+                    " also mConversation.getThreadId(): " +
+                    mConversation.getThreadId()
+                :
+                    "Recipients in window: \"" +
+                    recipientsInUI + "\" differ from recipients from conv: \"" +
+                    semiSepRecipients + "\"";
+
+            //LogTag.warnPossibleRecipientMismatch(msg, mActivity);
+        }
+
+        // just do a regular send. We're already on a non-ui thread so no need to fire
+        // off another thread to do this work.
+        /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+        sendSmsWorker(msgText, semiSepRecipients, threadId, subId);
+        /// @}
+
+        // Be paranoid and clean any draft SMS up.
+        deleteDraftSmsMessage(threadId);
+        /// M Fix CR:ALPS01268191 which is google issue. while save a mms draft, enter the
+        /// draft, change the recipients to be phone number, and send the sms. @{
+        Log.d(TAG_DRAFT, "[preSendSmsWorker] mOldThreadId : " + mOldThreadId);
+        if (mOldThreadId != 0) {
+//            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+                DraftCache.getInstance().setDraftState(mOldThreadId, false);
+//            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendSmsWorker(String msgText,
+            String semiSepRecipients, long threadId, int subId) {
+    /// @}
+        String[] dests = TextUtils.split(semiSepRecipients, ";");
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            MmsLog.dpi(LogTag.TRANSACTION, "sendSmsWorker sending message: recipients=" +
+                    semiSepRecipients + ", threadId=" + threadId);
+        }
+        MessageSender sender = new SmsMessageSender(mActivity, dests, msgText, threadId, subId);
+
+        try {
+            sender.sendMessage(threadId);
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getSmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send SMS message, threadId=" + threadId, e);
+        }
+
+        mStatusListener.onMessageSent();
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendMmsWorker(Conversation conv, Uri mmsUri, PduPersister persister,
+            SlideshowModel slideshow, SendReq sendReq, int subId) {
+    /// @}
+        long threadId = 0;
+        Cursor cursor = null;
+        boolean newMessage = false;
+        try {
+            // Put a placeholder message in the database first
+            DraftCache.getInstance().setSavingDraft(true);
+            mStatusListener.onPreMessageSent();
+
+            // Make sure we are still using the correct thread ID for our
+            // recipient set.
+            if (mForceUpdateThreadId) {
+                conv.setNeedForceUpdateThreadId(true);
+                mForceUpdateThreadId = false;
+            }
+            threadId = conv.ensureThreadId();
+            conv.setNeedForceUpdateThreadId(false);
+
+            MmsLog.dpi(TAG, "sendMmsWorker: update draft MMS message " + mmsUri +
+                        " threadId: " + threadId);
+
+            // One last check to verify the address of the recipient.
+            String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+            if (dests.length == 1) {
+                // verify the single address matches what's in the database. If we get a different
+                // address back, jam the new value back into the SendReq.
+                String newAddress =
+                    Conversation.verifySingleRecipient(mActivity, conv.getThreadId(), dests[0]);
+
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "sendMmsWorker: newAddress " + newAddress +
+                            " dests[0]: " + dests[0]);
+                }
+
+                if (!newAddress.equals(dests[0])) {
+                    dests[0] = newAddress;
+                    EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+                    if (encodedNumbers != null) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("sendMmsWorker: REPLACING number!!!");
+                        }
+                        sendReq.setTo(encodedNumbers);
+                    }
+                }
+            }
+            newMessage = mmsUri == null;
+            if (newMessage) {
+                // check if a draft is already present for current thread
+                final String selection = Mms.THREAD_ID + " = " + threadId;
+                cursor = SqliteWrapper.query(mActivity, mContentResolver, Mms.Draft.CONTENT_URI,
+                        MMS_DRAFT_PROJECTION, selection, null, null);
+                if (cursor == null) {
+                    Log.d(TAG, "[readDraftMmsMessage] cursor is null");
+                }
+                try {
+                    if (cursor != null) {
+                        if (cursor.moveToFirst()) {
+                            Uri uri = ContentUris.withAppendedId(Mms.Draft.CONTENT_URI,
+                                    cursor.getLong(MMS_ID_INDEX));
+                            Log.d(TAG, "retrieved uri = " + uri);
+                            mMessageUri = mmsUri = uri;
+                            newMessage = mmsUri == null;
+                        }
+                    }
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+
+            }
+            if (newMessage) {
+                // Write something in the database so the new message will appear as sending
+                ContentValues values = new ContentValues();
+                values.put(Mms.MESSAGE_BOX, Mms.MESSAGE_BOX_OUTBOX);
+                values.put(Mms.THREAD_ID, threadId);
+                values.put(Mms.MESSAGE_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim. @{
+                values.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+                /// @}
+                mmsUri = SqliteWrapper.insert(mActivity, mContentResolver, Mms.Outbox.CONTENT_URI,
+                        values);
+            }
+//            mStatusListener.onMessageSent();
+
+            // If user tries to send the message, it's a signal the inputted text is
+            // what they wanted.
+            UserHappinessSignals.userAcceptedImeText(mActivity);
+
+            // First make sure we don't have too many outstanding unsent message.
+            cursor = SqliteWrapper.query(mActivity, mContentResolver,
+                    Mms.Outbox.CONTENT_URI, MMS_OUTBOX_PROJECTION, null, null, null);
+            if (cursor != null) {
+                long maxMessageSize = MmsConfig.getMaxSizeScaleForPendingMmsAllowed() *
+                    /// M: change google default. @{
+                    MmsConfig.getUserSetMmsSizeLimit(true);
+                    /// @}
+                long totalPendingSize = 0;
+                while (cursor.moveToNext()) {
+                      /// M: change google default. @{
+                    if (PduHeaders.STATUS_UNREACHABLE
+                            != cursor.getLong(MMS_MESSAGE_STATUS_INDEX)) {
+                        totalPendingSize += cursor.getLong(MMS_MESSAGE_SIZE_INDEX);
+                    }
+                    /// @}
+                }
+                if (totalPendingSize >= maxMessageSize) {
+                    unDiscard();    // it wasn't successfully sent. Allow it to be saved as a draft.
+                    mStatusListener.onMaxPendingMessagesReached();
+                    markMmsMessageWithError(mmsUri, subId);
+
+                    /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+                    /// the conversation message count will set to be 0, and the threadid will be
+                    /// set to be 0, so while unlock the screen, the message
+                    /// will not show in the message list @{
+                    mStatusListener.onMessageSent();
+                    /// M @}
+
+                    MmsLog.d(MmsApp.TXN_TAG,
+                            "totalPendingSize >= maxMessageSize, totalPendingSize = "
+                            + totalPendingSize);
+                    return;
+                }
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        try {
+            MmsDraftData res = DraftManager.getInstance()
+                    .saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mmsUri, slideshow, sendReq, mActivity, null);
+            if (res != null) {
+                if (res.getMessageUri() != null) {
+                    MmsLog.dpi(TAG_DRAFT, "[sendMmsWorker] mmsUir : " + mmsUri);
+                    mmsUri = res.getMessageUri();
+                }
+            }
+            /*if (newMessage) {
+                // Create a new MMS message if one hasn't been made yet.
+                mmsUri = createDraftMmsMessage(persister, sendReq, slideshow, mmsUri,
+                        mActivity);
+            } else {
+                // Otherwise, sync the MMS message in progress to disk.
+                updateDraftMmsMessage(mmsUri, persister, slideshow, sendReq);
+            }*/
+
+            // Be paranoid and clean any draft SMS up.
+            deleteDraftSmsMessage(threadId);
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+
+        if (isAbortSendingMmsByFdnList(conv, subId)) {
+            MmsLog.d(TAG, "Abort Sending By FDN");
+            if (!mmsUri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+                ContentValues values = new ContentValues();
+                values.put(PendingMessages.PROTO_TYPE, MmsSms.MMS_PROTO);
+                values.put(PendingMessages.MSG_ID, ContentUris.parseId(mmsUri));
+                values.put(PendingMessages.MSG_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                values.put(PendingMessages.ERROR_TYPE, 0);
+                values.put(PendingMessages.ERROR_CODE, 0);
+                values.put(PendingMessages.RETRY_INDEX, 0);
+                values.put(PendingMessages.DUE_TIME, 0);
+
+                SqliteWrapper.insert(mActivity, mActivity.getContentResolver(),
+                        PendingMessages.CONTENT_URI, values);
+            }
+            markMmsMessageWithError(mmsUri, subId);
+            MessagingNotification.notifySendFailed(mActivity, true);
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            new Thread() {
+                public void run() {
+                    Looper.prepare();
+                    Toast.makeText(mActivity, mActivity.getString(R.string.fdn_check_failure),
+                            Toast.LENGTH_SHORT).show();
+                    Looper.loop();
+                };
+            } .start();
+            return;
+        }
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        try {
+            MessageSender sender = new MmsMessageSender(mActivity, mmsUri,
+                    slideshow.getCurrentSlideshowSize(), subId);
+            if (!sender.sendMessage(threadId)) {
+                // The message was sent through SMS protocol, we should
+                // delete the copy which was previously saved in MMS drafts.
+                SqliteWrapper.delete(mActivity, mContentResolver, mmsUri, null, null);
+            }
+            /// M: add for fix issue ALPS00804679 @{
+            else {
+                Log.d(TAG, "sendMmsWorker: sendMessage success, mark draft false. threadId = "
+                        + threadId);
+                DraftCache.getInstance().setSavingDraft(true);
+                conv.setDraftState(false);
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+            ///@}
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getMmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send message: " + mmsUri + ", threadId=" + threadId, e);
+        }
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    private boolean isAbortSendingMmsByFdnList(Conversation conv, int subId) {
+    	return false;
+        /*boolean isFdnEnabled = false;
+        try {
+            ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(ServiceManager
+                    .getService("phoneEx"));
+            if (telephonyEx != null && telephonyEx.isFdnEnabled(subId)) {
+                isFdnEnabled = true;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "[isAbortSendingMmsByFdnList]catch exception:");
+            e.printStackTrace();
+            isFdnEnabled = false;
+        }
+        Log.d(TAG, "isAbortSendingMmsByFdnList, isFdnEnabled = " + isFdnEnabled);
+        if (!isFdnEnabled) {
+            return false;
+        } else {
+            Uri uri = null;
+            ContactList contactlist = conv.getRecipients();
+            String[] numbers = contactlist.getNumbers();
+            uri = Uri.parse(FDN_URI + subId);
+
+            Cursor cursor = SqliteWrapper.query(mActivity, mActivity.getContentResolver(),
+                    uri, FDN_PROJECTION, null, null, null);
+            ArrayList<String> fdnList = new ArrayList<String>();
+            if (cursor != null) {
+                try {
+                    while (cursor.moveToNext()) {
+                        String number = cursor.getString(FDN_COLUMN_NUMBER);
+                        if (number != null) {
+                            fdnList.add(number);
+                        }
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+            for (String contactNumber : numbers) {
+                MmsLog.dpi(TAG, "isAbortSending, contactNumber = " + contactNumber);
+                if (!isInStringArray(contactNumber, fdnList)) {
+                    return true;
+                }
+            }
+            return false;
+        }*/
+    }
+
+    private boolean isInStringArray(String string, ArrayList<String> arrayList) {
+        for (String oneString : arrayList) {
+            if (string.equals(oneString)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void markMmsMessageWithError(Uri mmsUri, int subId) {
+        try {
+            PduPersister p = PduPersister.getPduPersister(mActivity);
+            // Move the message into MMS Outbox. A trigger will create an entry in
+            // the "pending_msgs" table.
+            p.move(mmsUri, Mms.Outbox.CONTENT_URI);
+
+            // Now update the pending_msgs table with an error for that new item.
+            /// M Fix CR ALPS00584603
+            /// update pending_sim_id column which in pending_msgs table @{
+            ContentValues valuePendingTable = new ContentValues(2);
+            valuePendingTable.put(PendingMessages.ERROR_TYPE, MmsSms.ERR_TYPE_GENERIC_PERMANENT);
+            valuePendingTable.put(Telephony.MmsSms.PendingMessages.SUBSCRIPTION_ID, subId);
+            long msgId = ContentUris.parseId(mmsUri);
+            SqliteWrapper.update(mActivity, mContentResolver,
+                    PendingMessages.CONTENT_URI,
+                    valuePendingTable, PendingMessages.MSG_ID + "=" + msgId, null);
+            /// @}
+            /// M update sim_id column in pdu table @{
+            ContentValues valuePduTable = new ContentValues(1);
+            valuePduTable.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+            valuePduTable.put(Mms.READ, 0);
+            SqliteWrapper.update(mActivity, mContentResolver, mmsUri, valuePduTable, null, null);
+            /// @}
+        } catch (MmsException e) {
+            // Not much we can do here. If the p.move throws an exception, we'll just
+            // leave the message in the draft box.
+            Log.e(TAG, "Failed to move message to outbox and mark as error: " + mmsUri, e);
+        }
+    }
+
+    /**
+     * makeSendReq should always return a non-null SendReq, whether the dest addresses are
+     * valid or not.
+     */
+    private static SendReq makeSendReq(Conversation conv, CharSequence subject) {
+        /// M: change google default, @{
+        // String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+        String[] dests = conv.getRecipients().getNumbers(false /*don't scrub for MMS address */);
+        // @}
+
+        SendReq req = new SendReq();
+        EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+        if (encodedNumbers != null) {
+            req.setTo(encodedNumbers);
+        }
+
+        if (!TextUtils.isEmpty(subject)) {
+            req.setSubject(new EncodedStringValue(subject.toString()));
+        }
+
+        req.setDate(System.currentTimeMillis() / 1000L);
+
+        return req;
+    }
+
+    private void asyncUpdateDraftMmsMessage(final Conversation conv,
+            final boolean isStopping, final IDraftInterface callback) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncUpdateDraftMmsMessage conv= " + conv + " mMessageUri= "
+                                + mMessageUri);
+        }
+
+        DraftCache.getInstance().setSavingDraft(true);
+
+        SendReq sendReq = makeSendReq(conv, mSubject);
+
+        sendReq = mOpWorkingMessageExt.opAsyncUpdateDraftMmsMessage(sendReq);
+
+        long threadId = conv.getThreadId();
+
+        Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] before thread id : " + threadId);
+        if (threadId <= 0 && !conv.getRecipients().isEmpty()) {
+            threadId = conv.ensureThreadId();
+            Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] after thread id : " + threadId);
+        }
+
+        DraftManager.getInstance().saveDraft(DraftManager.ASYNC_SAVE_ACTION, threadId,
+                mMessageUri, mSlideshow, sendReq, mActivity, callback);
+    }
+
+    private static final String SMS_DRAFT_WHERE = Sms.TYPE + "=" + Sms.MESSAGE_TYPE_DRAFT;
+    private static final String[] SMS_BODY_PROJECTION = { Sms.BODY };
+    private static final int SMS_BODY_INDEX = 0;
+
+    /**
+     * Reads a draft message for the given thread ID from the database,
+     * if there is one, deletes it from the database, and returns it.
+     * @return The draft message or an empty string.
+     */
+    private String readDraftSmsMessage(Conversation conv) {
+        long thread_id = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "readDraftSmsMessage conv: " + conv);
+        }
+        // If it's an invalid thread or we know there's no draft, don't bother.
+        if (thread_id <= 0/* || !conv.hasDraft()*/) {
+            return "";
+        }
+
+        Uri thread_uri = ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, thread_id);
+        String body = "";
+
+        Cursor c = SqliteWrapper.query(mActivity, mContentResolver,
+                        thread_uri, SMS_BODY_PROJECTION, SMS_DRAFT_WHERE, null, null);
+        boolean haveDraft = false;
+        if (c != null) {
+            try {
+                if (c.moveToFirst()) {
+                    body = c.getString(SMS_BODY_INDEX);
+                    haveDraft = true;
+                }
+            } finally {
+                c.close();
+            }
+        }
+
+        // We found a draft, and if there are no messages in the conversation,
+        // that means we deleted the thread, too. Must reset the thread id
+        // so we'll eventually create a new thread.
+        if (haveDraft && (conv.getMessageCount() == 0 || FolderModeUtils.getMmsDirMode())) {
+            asyncDeleteDraftSmsMessage(conv);
+
+            // Clean out drafts for this thread -- if the recipient set changes,
+            // we will lose track of the original draft and be unable to delete
+            // it later.  The message will be re-saved if necessary upon exit of
+            // the activity.
+            clearConversation(conv, true);
+        }
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("readDraftSmsMessage haveDraft: ", !TextUtils.isEmpty(body));
+        }
+
+        return body;
+    }
+
+    public void clearConversation(final Conversation conv, boolean resetThreadId) {
+        /// M: Code analyze 052, For bug ALPS00047256, to solve shows a wrong thread . @{
+        int messageCount = 0;
+        final Uri sAllThreadsUri =
+            Threads.CONTENT_URI.buildUpon().appendQueryParameter("simple", "true").build();
+
+        if (conv.getMessageCount() == 0) {
+            Cursor cursor = SqliteWrapper.query(
+                mActivity,
+                mContentResolver,
+                sAllThreadsUri,
+                new String[] {Threads.MESSAGE_COUNT, Threads._ID} ,
+                Threads._ID + "=" + conv.getThreadId(), null, null);
+            if (cursor != null) {
+                try {
+                    if (cursor.moveToFirst()) {
+                        messageCount =
+                            cursor.getInt(cursor.getColumnIndexOrThrow(Threads.MESSAGE_COUNT));
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+        }
+        if (resetThreadId && conv.getMessageCount() == 0 && messageCount == 0) {
+            LogTag.debug("clearConversation calling clearThreadId");
+            conv.clearThreadId();
+        }
+
+        conv.setDraftState(false);
+    }
+
+    private void asyncUpdateDraftSmsMessage(final Conversation conv, final String contents) {
+        new Thread(new Runnable() {
+            public void run() {
+                try {
+                    DraftCache.getInstance().setSavingDraft(true);
+                    if (conv.getRecipients().isEmpty()) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("asyncUpdateDraftSmsMessage no recipients, not saving");
+                        }
+                        return;
+                    }
+                    /// M: Code analyze 054, For bug ALPS00120202, Message]can't save draft
+                    /// if enter message from messageDirect widget Sometimes thread id is
+                    /// deleted as obsolete thread, so need to guarantee it exists . @{
+                    conv.guaranteeThreadId();
+                    /// @}
+                    conv.setDraftState(true);
+                    updateDraftSmsMessage(conv, contents);
+                } finally {
+                    DraftCache.getInstance().setSavingDraft(false);
+                }
+            }
+        }, "WorkingMessage.asyncUpdateDraftSmsMessage").start();
+    }
+
+    private void updateDraftSmsMessage(final Conversation conv, String contents) {
+        final long threadId = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "updateDraftSmsMessage tid=" + threadId + ", contents= " + contents);
+        }
+        // If we don't have a valid thread, there's nothing to do.
+        if (threadId <= 0) {
+            return;
+        }
+
+        ContentValues values = new ContentValues(3);
+        values.put(Sms.THREAD_ID, threadId);
+        values.put(Sms.BODY, contents);
+        values.put(Sms.TYPE, Sms.MESSAGE_TYPE_DRAFT);
+        SqliteWrapper.insert(mActivity, mContentResolver, Sms.CONTENT_URI, values);
+        Log.d(TAG_DRAFT,
+                "[updateDraftSmsMessage] mIsTurnToChooseAttach : " + mIsTurnToChooseAttach);
+        if (!mIsTurnToChooseAttach) {
+            asyncDeleteDraftMmsMessage(conv);
+        }
+
+        if (mOldThreadId != 0) {
+            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+            }
+        }
+        /// M : Fix CR : ALPS01012417  Two threads showed in ConversationList
+        /// new message, input phone number, content, press home key, press message icon
+        /// will load the last sms message, change phone number,back to conversationlist. @{
+        if (mOldSmsSaveThreadId > 0) {
+            if (mOldSmsSaveThreadId != threadId) {
+                deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                ///M: add for fix issue ALPS01078057. when delete the saved sms, should update the
+                /// old thread's draft state to false.
+                DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+            }
+        }
+        mOldSmsSaveThreadId = threadId;
+        /// @}
+
+        /// M: Fix CR : ALPS01078057. when the thread changed,
+        /// if the old thread saved Mms draft before,
+        /// should reset the old thread's draft state @{
+        if (mOldMmsSaveThreadId != 0 && mOldMmsSaveThreadId != threadId) {
+            asyncDeleteDraftMmsMessage(mOldMmsSaveThreadId);
+            DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+            mOldMmsSaveThreadId = 0;
+        }
+        /// @}
+        mMessageUri = null;
+    }
+
+    private void asyncDelete(final Uri uri, final String selection, final String[] selectionArgs) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncDelete " + uri + " where " + selection);
+        }
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+            }
+        }, "WorkingMessage.asyncDelete").start();
+    }
+
+    public void checkDraftSmsMessage(final Conversation conv) {
+        final WorkingMessage msg = this;
+          new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                Log.d(TAG_DRAFT, "checkDraftSmsMessage draftText : " + draftText);
+                if (!TextUtils.isEmpty(draftText)) {
+                    msg.mHasSmsDraft = true;
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+    }
+
+    public void asyncDeleteDraftSmsMessage(Conversation conv) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+        }
+    }
+
+    //M: Add for modify issue ALPS01812929
+    public void asyncDeleteDraftSmsMessage(Conversation conv, final Runnable r) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null, r);
+        }
+    }
+
+    private void deleteDraftSmsMessage(long threadId) {
+        SqliteWrapper.delete(mActivity, mContentResolver,
+                ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+    }
+
+    public void asyncDeleteDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+        /// M: Reset MMS's message URI because the MMS is deleted */
+        mMessageUri = null;
+
+        }
+    }
+
+    public void asyncDeleteDraftMmsMessage(final long threadId) {
+        mHasMmsDraft = false;
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+            /// M: Reset MMS's message URI because the MMS is deleted */
+            mMessageUri = null;
+        }
+    }
+
+    /// M:
+    public int getCurrentMessageSize() {
+        if (mSlideshow != null) {
+            int currentMessageSize = mSlideshow.getCurrentSlideshowSize();
+            return currentMessageSize;
+        }
+        return 0;
+    }
+
+    /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't take
+    /// effect immediately after modify in settings Should update static variable
+    /// after peference is changed . @{
+    public static void updateCreationMode(Context context) {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
+        String creationMode =
+            sp.getString(MmsPreferenceActivity.CREATION_MODE, CREATION_MODE_FREE);
+        if (creationMode.equals(CREATION_MODE_WARNING)) {
+            sCreationMode = WARNING_TYPE;
+        } else if (creationMode.equals(CREATION_MODE_RESTRICTED)) {
+            sCreationMode = RESTRICTED_TYPE;
+        } else {
+            sCreationMode = OK;
+        }
+    }
+    /// @}
+
+    public boolean isResizeImage() {
+        return mResizeImage;
+    }
+
+    public void setResizeImage(boolean resizeImage) {
+        this.mResizeImage = resizeImage;
+    }
+
+    public Uri getMessageUri() {
+        return this.mMessageUri;
+    }
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft when save
+    /// Latest Mms message as draft . @{
+    public void  setNeedDeleteOldMmsDraft(Boolean delete) {
+        mNeedDeleteOldMmsDraft = delete;
+    }
+    /// @}
+
+    /**
+    * Fix CR : ALPS01105564
+    *  which used to delete the thread which has 2 mms drafts. only remain the last draft(pdu)
+    */
+    private void deleteOldMmsDraft(Uri msgUri, long tid) {
+        if (msgUri != null && tid > 0) {
+            String pduId = msgUri.getLastPathSegment();
+            final String where = Mms.THREAD_ID + "=" + tid + " and " + WordsTable.ID
+                 + " < " + pduId;
+            Log.d(TAG, "deleteOldMmsDraft where : " + where);
+            delete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+
+    /// M: Code analyze 055, For bug ALPS00234739, Remove old Mms draft in
+    /// conversation list instead of compose view . @}
+    private void asyncDeleteOldMmsDraft(final long threadId) {
+        MessageUtils.addRemoveOldMmsThread(new Runnable() {
+            public void run() {
+                if (mMessageUri != null && threadId > 0) {
+                    String pduId = mMessageUri.getLastPathSegment();
+                    final String where = Mms.THREAD_ID + "=" + threadId + " and " + WordsTable.ID
+                            + " != " + pduId;
+                    delete(Mms.Draft.CONTENT_URI, where, null);
+                }
+            }
+        });
+    }
+    /// @}
+
+    /**
+     * Delete all drafts of current thread by threadId.
+     *
+     * @param threadId
+     */
+    public void asyncDeleteAllMmsDraft(final long threadId) {
+        if (threadId > 0) {
+            MmsLog.d(TAG, "asyncDeleteAllMmsDraft");
+            final String where = Mms.THREAD_ID + "=" + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+    private WorkingMessage(Activity activity, MessageStatusListener l) {
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = l;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    public static WorkingMessage createEmpty(Activity activity, MessageStatusListener l) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity, l);
+        return msg;
+    }
+
+    public void setHasMmsDraft(boolean hasMmsDraft) {
+        mHasMmsDraft = hasMmsDraft;
+    }
+
+    public boolean checkSizeBeforeAppend() {
+        if (mSlideshow == null) {
+            return true;
+        }
+        mSlideshow.checkMessageSize(0);
+        return true;
+    }
+
+    private void removeSlideAttachments(SlideModel slide) {
+        slide.removeImage();
+        slide.removeVideo();
+        slide.removeAudio();
+
+        /// M: add for attachment enhance, For new feature ALPS00231349, add vCard support. @{
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public void removeAllFileAttaches() {
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    public boolean hasMediaAttachments() {
+        if (mSlideshow == null) {
+            return false;
+        }
+        if (hasSlideshow()) {
+            return true;
+        }
+        final SlideModel slide = mSlideshow.get(0);
+        return (slide != null) && (slide.hasAudio() || slide.hasVideo() || slide.hasImage());
+    }
+
+
+
+    public boolean hasAttachedFiles() {
+        return mSlideshow != null && mSlideshow.sizeOfFilesAttach() > 0;
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    public synchronized void discard(boolean isDiscard) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[discard] not default sms, cann't discard, just return!!");
+            return;
+        }
+
+        MmsLog.d(M_TAG, "discard(): Start. mConversation.ThreadId=" + mConversation.getThreadId()
+                + ", MessageCount=" + mConversation.getMessageCount());
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("[WorkingMessage] discard");
+        }
+
+        if (mDiscarded) {
+            return;
+        }
+
+        // Mark this message as discarded in order to make saveDraft() no-op.
+        mDiscarded = isDiscard;
+        cancelThumbnailLoading();
+
+        // Delete any associated drafts if there are any.
+        if (mHasMmsDraft) {
+            asyncDeleteCurrentDraftMmsMessage(mConversation);
+        }
+        if (mHasSmsDraft) {
+            /// M: fix bug ALPS01471051, ensureThreadId before discard sms draft
+            if (mConversation.getThreadId() == 0) {
+                mConversation.ensureThreadId();
+                Log.d(TAG_DRAFT, "[discard] ensureThreadId before discard sms draft");
+            }
+            //M: Add for modify issue ALPS01812929
+            asyncDeleteDraftSmsMessage(mConversation, new Runnable() {
+                            public void run() {
+                                if (mConversation != null) {
+                                    mConversation.setDraftState(false);
+                                }
+                            }
+                        });
+        }
+        if (mConversation.getThreadId() > 0) {
+            clearConversation(mConversation, true);
+        }
+    }
+    /// @}
+
+    private void delete(final Uri uri, final String selection, final String[] selectionArgs) {
+        /// M: Code analyze 056, For bug ALPS00094352, to solve JE
+        /// of MMS occured when I received serveral SM  . @}
+        if (uri != null) {
+            int result = -1; // if delete is unsuccessful, the delete()
+            // method will return -1
+            int retryCount = 0;
+            int maxRetryCount = 10;
+            while (result == -1 && retryCount < maxRetryCount) {
+                try {
+                    result = SqliteWrapper.delete(mActivity,
+                            mContentResolver, uri, selection, selectionArgs);
+
+                } catch (SQLiteDiskIOException e) {
+                    MmsLog.e(TAG, "asyncDelete(): SQLiteDiskIOException:"
+                            + " delete thread unsuccessful! Try time=" + retryCount);
+                } finally {
+                    retryCount++;
+                }
+            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 057, For bug ALPS00234653, to solve Can't continue
+    /// to play the vedio after share a video in mms . @}
+    private void asyncDeleteCurrentDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+
+            asyncDelete(mMessageUri, where, null, new Runnable() {
+                public void run() {
+                    if (mConversation != null) {
+                        mConversation.setDraftState(false);
+                    }
+                }
+            });
+
+            // / @}
+            mMessageUri = null;
+        } else if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+    }
+    /// @}
+
+    ///M: add for fix ALPS00452425 @{
+    private void asyncDelete(final Uri uri, final String selection,
+            final String[] selectionArgs, final Runnable r) {
+
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+                MmsLog.dpi(TAG, "delete finish, uri = " + uri);
+                if (r != null) {
+                    r.run();
+                }
+            }
+        }, "WorkingMessage.asyncDelete2").start();
+    }
+    /// @}
+
+    /// M Fix CR : ALPS01071659
+    /// First group message, save a mms draft,which only contain text,
+    /// back to conversationlist ,change to not normal message,
+    /// the enter the mms draft send the message,
+    /// back to conversationlist, the group mms draft still there
+    /// when loafFinished, call this to delete the mms draft
+    /// which is not group message, and only contains text @{
+    public void deleteGruoupMmsDraft() {
+        if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+            if (!MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity)
+                    && mConversation.getRecipients().size() > 1
+                    && mMmsState != RECIPIENTS_REQUIRE_MMS) {
+                if (!hasAttachedFiles() && !hasSlideshow() && !hasAttachment()
+                         && !hasMediaAttachments() && !hasSubject()) {
+                    asyncDeleteDraftMmsMessage(mConversation);
+                    clearConversation(mConversation, true);
+                }
+            }
+        }
+    }
+    /// @}
+
+    /// M: fix bug ALPS00712509, show toast when paste many word and > 300k
+    private boolean mIsExceedSize;
+
+    public boolean isExceedSize() {
+        return mIsExceedSize;
+    }
+
+    public void setIsExceedSize(boolean isExceedSize) {
+        mIsExceedSize = isExceedSize;
+    }
+    /// @}
+
+    private boolean mIsUpdateAttachEditor = true;
+
+    public boolean getIsUpdateAttachEditor() {
+        if (!mIsUpdateAttachEditor) {
+            MmsLog.d(TAG, "mIsUpdateAttachEditor == false");
+        }
+        return mIsUpdateAttachEditor;
+    }
+
+    public void setIsUpdateAttachEditor(boolean update) {
+        mIsUpdateAttachEditor = update;
+    }
+
+    /// M: fix bug ALPS01265824, need remove FileAttachment when text + attachmentSize > limit
+    public boolean isRemoveFileAttachment() {
+        if (mSlideshow != null
+                && mSlideshow.getCurrentSlideshowSize() > MmsConfig.getUserSetMmsSizeLimit(true)) {
+            return true;
+        }
+        return false;
+    }
+
+    // Add for IpMessage callback
+    public boolean requiresIpMms() {
+        return requiresMms();
+    }
+
+    public void setIpText(CharSequence s) {
+        setText(s);
+    }
+
+    public CharSequence getIpText() {
+        return getText();
+    }
+
+    public void syncWorkingIpRecipients() {
+        syncWorkingRecipients();
+    }
+
+    public void setIpSubject(CharSequence s, boolean notify) {
+        setSubject(s, notify);
+    }
+
+    public boolean hasDrmMedia() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMedia();
+    }
+
+    public boolean hasDrmMediaRight() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMediaRight();
+    }
+
+    public IWorkingMessageCallback loadCallback(Object activity, Uri uri) {
+        return load((ComposeMessageActivity) activity, uri);
+    }
+
+    public boolean hasMediaAttachmentsCallback() {
+        return hasMediaAttachments();
+    }
+
+    public void removeAllFileAttachesCallback() {
+        removeAllFileAttaches();
+    }
+
+    public int getState() {
+        return mMmsState;
+    }
+
+    public void correctAttachmentStateCallback() {
+        correctAttachmentState();
+    }
+
+    public boolean isIpWorthSaving() {
+        return isWorthSaving();
+    }
+
+    public CharSequence getIpSubject() {
+        return getSubject();
+    }
+
+    public void onAttachmentChangedCallback() {
+        mStatusListener.onAttachmentChanged();
+    }
+
+    public void discardCallback() {
+        discard();
+    }
+
+    public void updateStateExt(int state, boolean on, boolean notify) {
+        updateState(state, on, notify);
+    }
+
+    public void setLengthRequiresMmsCallback(boolean mmsRequired, boolean notify) {
+        setLengthRequiresMms(mmsRequired, notify);
+    }
+}

Property changes on: vendor/branch/5058A_Cable_Bahamas/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058A_Cable_Bahamas/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
===================================================================
--- vendor/branch/5058A_Cable_Bahamas/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java	(revision 0)
+++ vendor/branch/5058A_Cable_Bahamas/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java	(revision 4573)
@@ -0,0 +1,7602 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ * Modification based on code covered by the mentioned copyright
+ * and/or permission notice(s).
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.dataconnection;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.ProgressDialog;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.ConnectivityManager;
+import android.net.LinkProperties;
+import android.net.NetworkCapabilities;
+import android.net.NetworkConfig;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.net.NetworkUtils;
+import android.net.ProxyInfo;
+import android.net.TrafficStats;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.AsyncResult;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RegistrantList;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.preference.PreferenceManager;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
+import android.provider.Telephony;
+import android.telephony.CellLocation;
+import android.telephony.PcoData;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.text.TextUtils;
+import android.util.EventLog;
+import android.util.LocalLog;
+import android.util.Pair;
+import android.util.SparseArray;
+import android.view.WindowManager;
+
+import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.GsmCdmaPhone;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandException.Error;
+import com.android.internal.telephony.DctConstants;
+import com.android.internal.telephony.EventLogTags;
+import com.android.internal.telephony.GsmCdmaPhone;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.metrics.TelephonyMetrics;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.util.ArrayUtils;
+import com.android.internal.util.AsyncChannel;
+
+import com.android.ims.ImsManager;
+
+/** M: start */
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.telephony.IGsmDCTExt;
+import com.mediatek.common.telephony.ITelephonyExt;
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.dataconnection.DataSubSelector;
+import com.mediatek.internal.telephony.dataconnection.DcFailCauseManager;
+import com.mediatek.internal.telephony.dataconnection.FdManager;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.dataconnection.DataConnectionHelper;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+/** M: end */
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.PriorityQueue;
+import java.util.Set;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.lang.StringBuilder;
+
+import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.TelephonyDevController;
+
+/**
+ * {@hide}
+ */
+public class DcTracker extends Handler {
+    private static final String LOG_TAG = "DCT";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = android.util.Log.isLoggable(LOG_TAG,
+            android.util.Log.DEBUG); // STOPSHIP if true
+    private static final boolean VDBG_STALL = android.util.Log.isLoggable(LOG_TAG,
+            android.util.Log.DEBUG); // STOPSHIP if true
+    private static final int TEL_DBG = SystemProperties.getInt("persist.log.tag.tel_dbg", 0);
+    private static final boolean RADIO_TESTS = false;
+
+    public AtomicBoolean isCleanupRequired = new AtomicBoolean(false);
+
+    private final AlarmManager mAlarmManager;
+
+    /* Currently requested APN type (TODO: This should probably be a parameter not a member) */
+    private String mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+    // All data enabling/disabling related settings
+    private final DataEnabledSettings mDataEnabledSettings = new DataEnabledSettings();
+
+    // Sync data settings part.
+    private static final int MOBILE_DATA_IDX        = 0;
+    private static final int ROAMING_DATA_IDX       = 1;
+    private static final int DEFAULT_DATA_SIM_IDX   = 2;
+    private static final int SKIP_DATA_SETTINGS     = -2;
+
+    /**
+     * After detecting a potential connection problem, this is the max number
+     * of subsequent polls before attempting recovery.
+     */
+    // 1 sec. default polling interval when screen is on.
+    private static final int POLL_NETSTAT_MILLIS = 1000;
+    // 10 min. default polling interval when screen is off.
+    private static final int POLL_NETSTAT_SCREEN_OFF_MILLIS = 1000*60*10;
+    // Default sent packets without ack which triggers initial recovery steps
+    private static final int NUMBER_SENT_PACKETS_OF_HANG = 10;
+
+    // Default for the data stall alarm while non-aggressive stall detection
+    private static final int DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT = 1000 * 60 * 6;
+    // Default for the data stall alarm for aggressive stall detection
+    private static final int DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT = 1000 * 60;
+    // Tag for tracking stale alarms
+    private static final String DATA_STALL_ALARM_TAG_EXTRA = "data.stall.alram.tag";
+
+    // M: Check data stall alarm if is needed to skip for testing
+    private static final String SKIP_DATA_STALL_ALARM = "persist.skip.data.stall.alarm";
+
+    private static final boolean DATA_STALL_SUSPECTED = true;
+    private static final boolean DATA_STALL_NOT_SUSPECTED = false;
+
+    private String RADIO_RESET_PROPERTY = "gsm.radioreset";
+
+    private static final String INTENT_RECONNECT_ALARM =
+            "com.android.internal.telephony.data-reconnect";
+    private static final String INTENT_RECONNECT_ALARM_EXTRA_TYPE = "reconnect_alarm_extra_type";
+    private static final String INTENT_RECONNECT_ALARM_EXTRA_REASON =
+            "reconnect_alarm_extra_reason";
+
+    private static final String INTENT_DATA_STALL_ALARM =
+            "com.android.internal.telephony.data-stall";
+
+    @VisibleForTesting
+    public static class DataAllowFailReason {
+        private HashSet<DataAllowFailReasonType> mDataAllowFailReasonSet = new HashSet<>();
+
+        public void addDataAllowFailReason(DataAllowFailReasonType type) {
+            mDataAllowFailReasonSet.add(type);
+        }
+
+        public String getDataAllowFailReason() {
+            StringBuilder failureReason = new StringBuilder();
+            failureReason.append("isDataAllowed: No");
+            for(DataAllowFailReasonType reason : mDataAllowFailReasonSet) {
+                failureReason.append(reason.mFailReasonStr);
+            }
+            return failureReason.toString();
+        }
+
+        public boolean isFailForSingleReason(DataAllowFailReasonType failReasonType) {
+            return (mDataAllowFailReasonSet.size() == 1) &&
+                    (mDataAllowFailReasonSet.contains(failReasonType));
+        }
+
+        public boolean isFailForReason(DataAllowFailReasonType failReasonType) {
+            return mDataAllowFailReasonSet.contains(failReasonType);
+        }
+
+        public void clearAllReasons() {
+            mDataAllowFailReasonSet.clear();
+        }
+
+        public boolean isFailed() {
+            return mDataAllowFailReasonSet.size() > 0;
+        }
+
+        public int getSizeOfFailReason() {
+            return mDataAllowFailReasonSet.size();
+        }
+    }
+
+    @VisibleForTesting
+    public enum DataAllowFailReasonType {
+        NOT_ATTACHED(" - Not attached"),
+        RECORD_NOT_LOADED(" - SIM not loaded"),
+        ROAMING_DISABLED(" - Roaming and data roaming not enabled"),
+        INVALID_PHONE_STATE(" - PhoneState is not idle"),
+        CONCURRENT_VOICE_DATA_NOT_ALLOWED(" - Concurrent voice and data not allowed"),
+        PS_RESTRICTED(" - mIsPsRestricted= true"),
+        UNDESIRED_POWER_STATE(" - desiredPowerState= false"),
+        INTERNAL_DATA_DISABLED(" - mInternalDataEnabled= false"),
+        DEFAULT_DATA_UNSELECTED(" - defaultDataSelected= false"),
+        RADIO_DISABLED_BY_CARRIER(" - powerStateFromCarrier= false"),
+        FDN_ENABLED(" - FDN enabled"),
+        // Multi-PS attach
+        NOT_ALLOWED(" - Not allowed");
+
+        public String mFailReasonStr;
+
+        DataAllowFailReasonType(String reason) {
+            mFailReasonStr = reason;
+        }
+    }
+
+    private DcTesterFailBringUpAll mDcTesterFailBringUpAll;
+    private DcController mDcc;
+
+    /** kept in sync with mApnContexts
+     * Higher numbers are higher priority and sorted so highest priority is first */
+   /*ALPS01555724: The implementation of PriorityQueue is incorrect, use arraylist to sort priority.
+    private final PriorityQueue<ApnContext>mPrioritySortedApnContexts =
+            new PriorityQueue<ApnContext>(5,
+            new Comparator<ApnContext>() {
+                public int compare(ApnContext c1, ApnContext c2) {
+                    return c2.priority - c1.priority;
+                }
+            } );
+     */
+    ArrayList <ApnContext> mPrioritySortedApnContexts = new ArrayList<ApnContext>();
+
+
+    /** allApns holds all apns */
+    private ArrayList<ApnSetting> mAllApnSettings = null;
+
+    /** preferred apn */
+    private ApnSetting mPreferredApn = null;
+
+    /** Is packet service restricted by network */
+    private boolean mIsPsRestricted = false;
+
+    /** emergency apn Setting*/
+    private ApnSetting mEmergencyApn = null;
+
+    /* Once disposed dont handle any messages */
+    private boolean mIsDisposed = false;
+
+    private ContentResolver mResolver;
+
+    /* Set to true with CMD_ENABLE_MOBILE_PROVISIONING */
+    private boolean mIsProvisioning = false;
+
+    /* The Url passed as object parameter in CMD_ENABLE_MOBILE_PROVISIONING */
+    private String mProvisioningUrl = null;
+
+    /* Intent for the provisioning apn alarm */
+    private static final String INTENT_PROVISIONING_APN_ALARM =
+            "com.android.internal.telephony.provisioning_apn_alarm";
+
+    /* Tag for tracking stale alarms */
+    private static final String PROVISIONING_APN_ALARM_TAG_EXTRA = "provisioning.apn.alarm.tag";
+
+    /* Debug property for overriding the PROVISIONING_APN_ALARM_DELAY_IN_MS */
+    private static final String DEBUG_PROV_APN_ALARM = "persist.debug.prov_apn_alarm";
+
+    /* Default for the provisioning apn alarm timeout */
+    private static final int PROVISIONING_APN_ALARM_DELAY_IN_MS_DEFAULT = 1000 * 60 * 15;
+
+    /* The provision apn alarm intent used to disable the provisioning apn */
+    private PendingIntent mProvisioningApnAlarmIntent = null;
+
+    /* Used to track stale provisioning apn alarms */
+    private int mProvisioningApnAlarmTag = (int) SystemClock.elapsedRealtime();
+
+    // VOLTE [start]
+    private static final boolean MTK_IMS_SUPPORT = SystemProperties.get("persist.mtk_ims_support")
+                                                            .equals("1") ? true : false;
+
+    // VZW feature suppport
+    private static final boolean VZW_FEATURE = SystemProperties.get("persist.operator.optr")
+                                                            .equals("OP12") ? true : false;
+
+    private AsyncChannel mReplyAc = new AsyncChannel();
+
+    /** M: start */
+    protected static final String PROPERTY_MOBILE_DATA_ENABLE = "persist.radio.mobile.data";
+
+    /// M: Default data customization.
+    private static final String PROPERTY_OPERATOR = "persist.operator.optr";
+    private static final String OPERATOR_OM = "OM";
+
+    protected ApnSetting mInitialAttachApnSetting;
+    private static final String NO_SIM_VALUE = "N/A";
+    private String[] PROPERTY_ICCID = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+    /** M: end */
+
+    // M: OP12 hplmn support
+    private static final String PLMN_OP12 = "311480";
+
+    private static final boolean MTK_APNSYNC_TEST_SUPPORT =
+            SystemProperties.getInt("persist.apnsync.test.support", 0) == 1;
+
+    protected static boolean MTK_CC33_SUPPORT =
+            SystemProperties.getInt("persist.data.cc33.support", 0) == 1 ? true : false;
+
+    private static final boolean MTK_DUAL_APN_SUPPORT =
+            SystemProperties.get("ro.mtk_dtag_dual_apn_support").equals("1") ? true : false;
+
+    /**
+     * M: IA- for IMS test mode and change attach APN for OP12.
+     *    Enable : Set Attach PDN to VZWINTERNET
+     *    Disable: Set Attach PDN to VZWIMS (Default)
+     */
+    protected static final boolean MTK_IMS_TESTMODE_SUPPORT =
+            SystemProperties.getInt("persist.imstestmode.support", 0) == 1;
+
+    /* M: Set to true if IMS pdn handover to WIFI(EPDG) and used for change attach APN */
+    private boolean mIsImsHandover = false;
+    /* M: Vzw IMS hand over
+       Value:
+           0: reset
+           1: handover start
+           2: handover end
+    */
+    protected String PROP_IMS_HANDOVER = "ril.imshandover";
+
+    // M: IA-change attach APN from modem.
+    private ApnSetting mMdChangedAttachApn = null;
+    private static final int APN_CLASS_0 = 0;
+    private static final int APN_CLASS_1 = 1;
+    private static final int APN_CLASS_2 = 2;
+    private static final int APN_CLASS_3 = 3;
+    private static final int APN_CLASS_4 = 4;
+    private static final int APN_CLASS_5 = 5;
+    private static final String VZW_EMERGENCY_NI = "VZWEMERGENCY";
+    private static final String VZW_IMS_NI = "VZWIMS";
+    private static final String VZW_ADMIN_NI = "VZWADMIN";
+    private static final String VZW_INTERNET_NI = "VZWINTERNET";
+    private static final String VZW_APP_NI = "VZWAPP";
+    private static final String VZW_800_NI = "VZW800";
+    private static final String PROP_APN_CLASS_ICCID = "ril.md_changed_apn_class.iccid";
+    private static final String PROP_APN_CLASS = "ril.md_changed_apn_class";
+
+    // M: For IMS pdn handover to WIFI
+    private static final String NETWORK_TYPE_WIFI = "WIFI";
+    private static final String NETWORK_TYPE_MOBILE_IMS = "MOBILEIMS";
+
+    // M: For sync APN table
+    private static final String PROPERTY_THROTTLING_TIME = "persist.radio.throttling_time";
+    private static final int THROTTLING_TIME_DEFAULT = 900;
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    private String mLteAccessStratumDataState = PhoneConstants.LTE_ACCESS_STRATUM_STATE_UNKNOWN;
+    private static final int LTE_AS_CONNECTED = 1;
+    private int mNetworkType = -1;
+    private boolean mIsLte = false;
+    private boolean mIsSharedDefaultApn = false;
+    private int mDefaultRefCount = 0;
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // M: JPN IA Start
+    protected int mSuspendId = 0;
+    protected static final String[] MCC_TABLE_TEST = {
+        "001"
+    };
+    protected static final String[] MCC_TABLE_DOMESTIC = {
+        "440"
+    };
+    protected static final int REGION_UNKNOWN  = 0;
+    protected static final int REGION_DOMESTIC = 1;
+    protected static final int REGION_FOREIGN  = 2;
+    protected int mRegion = REGION_UNKNOWN;
+    protected Object mNeedsResumeModemLock = new Object();
+    protected boolean mNeedsResumeModem = false;
+    // M: JPN IA End
+
+    // M: Attach APN is assigned empty but need to raise P-CSCF discovery flag
+    // 26201 DTAG D1(T-Mobile)
+    // 44010 DOCOMO
+    private String[] PLMN_EMPTY_APN_PCSCF_SET = {
+        "26201",
+        "44010"
+    };
+
+    private String[] MCCMNC_OP18 = {
+        "405840", "405854", "405855", "405856", "405857",
+        "405858", "405859", "405860", "405861", "405862",
+        "405863", "405864", "405865", "405866", "405867",
+        "405868", "405869", "405870", "405871", "405872",
+        "405873", "405874"
+    };
+
+    // M: Query modem hardware capability
+    private TelephonyDevController mTelDevController = TelephonyDevController.getInstance();
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver () {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                if (DBG) log("screen on");
+                mIsScreenOn = true;
+                stopNetStatPoll();
+                startNetStatPoll();
+                restartDataStallAlarm();
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                if (DBG) log("screen off");
+                mIsScreenOn = false;
+                stopNetStatPoll();
+                startNetStatPoll();
+                restartDataStallAlarm();
+            } else if (action.startsWith(INTENT_RECONNECT_ALARM)) {
+                if (DBG) log("Reconnect alarm. Previous state was " + mState);
+                onActionIntentReconnectAlarm(intent);
+            } else if (action.equals(INTENT_DATA_STALL_ALARM)) {
+                if (DBG) log("Data stall alarm");
+                onActionIntentDataStallAlarm(intent);
+            } else if (action.equals(INTENT_PROVISIONING_APN_ALARM)) {
+                if (DBG) log("Provisioning apn alarm");
+                onActionIntentProvisioningApnAlarm(intent);
+            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
+                final android.net.NetworkInfo networkInfo = (NetworkInfo)
+                        intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
+                mIsWifiConnected = (networkInfo != null && networkInfo.isConnected());
+                if (DBG) log("NETWORK_STATE_CHANGED_ACTION: mIsWifiConnected=" + mIsWifiConnected);
+            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
+                if (DBG) log("Wifi state changed");
+                final boolean enabled = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
+                        WifiManager.WIFI_STATE_UNKNOWN) == WifiManager.WIFI_STATE_ENABLED;
+                if (!enabled) {
+                    // when WiFi got disabled, the NETWORK_STATE_CHANGED_ACTION
+                    // quit and won't report disconnected until next enabling.
+                    mIsWifiConnected = false;
+                }
+                if (DBG) {
+                    log("WIFI_STATE_CHANGED_ACTION: enabled=" + enabled
+                            + " mIsWifiConnected=" + mIsWifiConnected);
+                }
+            } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+                if (false == hasOperatorIaCapability()) {
+                    // M:For OP12, in EPDG handover case to change initial attach APN.
+                    final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(
+                            ConnectivityManager.EXTRA_NETWORK_INFO);
+                    int apnType = networkInfo.getType();
+                    String typeName = networkInfo.getTypeName();
+                    logd("onReceive: ConnectivityService action change apnType = " +
+                            apnType + " typename =" + typeName);
+
+                    // The case of IMS handover to WIFI
+                    // Note: EPDG is implemented on CS framework
+                    if (apnType == ConnectivityManager.TYPE_MOBILE_IMS
+                            && typeName.equals(NETWORK_TYPE_WIFI)) {
+                        onAttachApnChangedByHandover(true);
+                    } else if (apnType == ConnectivityManager.TYPE_MOBILE_IMS &&
+                            typeName.equals(NETWORK_TYPE_MOBILE_IMS)) {
+                        onAttachApnChangedByHandover(false);
+                    }
+                }
+            } else {
+                if (DBG) log("onReceive: Unknown action=" + action);
+            }
+        }
+    };
+
+    private final Runnable mPollNetStat = new Runnable() {
+        @Override
+        public void run() {
+            updateDataActivity();
+
+            if (mIsScreenOn) {
+                mNetStatPollPeriod = Settings.Global.getInt(mResolver,
+                        Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS, POLL_NETSTAT_MILLIS);
+            } else {
+                mNetStatPollPeriod = Settings.Global.getInt(mResolver,
+                        Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS,
+                        POLL_NETSTAT_SCREEN_OFF_MILLIS);
+            }
+
+            if (mNetStatPollEnabled) {
+                mDataConnectionTracker.postDelayed(this, mNetStatPollPeriod);
+            }
+        }
+    };
+
+    private SubscriptionManager mSubscriptionManager;
+    private final OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
+            new OnSubscriptionsChangedListener() {
+                public final AtomicInteger mPreviousSubId =
+                        new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+                /**
+                 * Callback invoked when there is any change to any SubscriptionInfo. Typically
+                 * this method invokes {@link SubscriptionManager#getActiveSubscriptionInfoList}
+                 */
+                @Override
+                public void onSubscriptionsChanged() {
+                    if (DBG) log("SubscriptionListener.onSubscriptionInfoChanged start");
+                    // Set the network type, in case the radio does not restore it.
+                    int subId = mPhone.getSubId();
+                    if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                        registerSettingsObserver();
+                    }
+                    IccRecords r = mIccRecords.get();
+                    String operatorNumericIcc = (r != null) ? r.getOperatorNumeric() : "";
+                    String operatorNumericProp = TelephonyManager.getDefault()
+                            .getSimOperatorNumericForPhone(mPhone.getPhoneId());
+                    if (mPreviousSubId.getAndSet(subId) != subId &&
+                            SubscriptionManager.isValidSubscriptionId(subId) &&
+                            !TextUtils.isEmpty(operatorNumericIcc) &&
+                            !TextUtils.isEmpty(operatorNumericProp)) {
+                        onRecordsLoadedOrSubIdChanged();
+                    }
+                }
+            };
+
+    private static class SettingsObserver extends ContentObserver {
+        final private HashMap<Uri, Integer> mUriEventMap;
+        final private Context mContext;
+        final private Handler mHandler;
+        final private static String TAG = "DcTracker.SettingsObserver";
+
+        SettingsObserver(Context context, Handler handler) {
+            super(null);
+            mUriEventMap = new HashMap<Uri, Integer>();
+            mContext = context;
+            mHandler = handler;
+        }
+
+        void observe(Uri uri, int what) {
+            mUriEventMap.put(uri, what);
+            final ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(uri, false, this);
+        }
+
+        void unobserve() {
+            final ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            Rlog.e(TAG, "Should never be reached.");
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            final Integer what = mUriEventMap.get(uri);
+            if (what != null) {
+                mHandler.obtainMessage(what.intValue()).sendToTarget();
+            } else {
+                Rlog.e(TAG, "No matching event to send for URI=" + uri);
+            }
+
+        }
+    }
+
+    private final SettingsObserver mSettingsObserver;
+
+    private void registerSettingsObserver() {
+        mSettingsObserver.unobserve();
+        String simSuffix = "";
+        if (TelephonyManager.getDefault().getSimCount() > 1) {
+            simSuffix = Integer.toString(mPhone.getSubId());
+        }
+
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DATA_ROAMING + simSuffix),
+                DctConstants.EVENT_ROAMING_ON);
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED),
+                DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE);
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED),
+                DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE);
+    }
+
+    /**
+     * Maintain the sum of transmit and receive packets.
+     *
+     * The packet counts are initialized and reset to -1 and
+     * remain -1 until they can be updated.
+     */
+    public static class TxRxSum {
+        public long txPkts;
+        public long rxPkts;
+
+        public TxRxSum() {
+            reset();
+        }
+
+        public TxRxSum(long txPkts, long rxPkts) {
+            this.txPkts = txPkts;
+            this.rxPkts = rxPkts;
+        }
+
+        public TxRxSum(TxRxSum sum) {
+            txPkts = sum.txPkts;
+            rxPkts = sum.rxPkts;
+        }
+
+        public void reset() {
+            txPkts = -1;
+            rxPkts = -1;
+        }
+
+        @Override
+        public String toString() {
+            return "{txSum=" + txPkts + " rxSum=" + rxPkts + "}";
+        }
+
+        public void updateTxRxSum() {
+            this.txPkts = TrafficStats.getMobileTcpTxPackets();
+            this.rxPkts = TrafficStats.getMobileTcpRxPackets();
+        }
+    }
+
+    private void onActionIntentReconnectAlarm(Intent intent) {
+        String reason = intent.getStringExtra(INTENT_RECONNECT_ALARM_EXTRA_REASON);
+        String apnType = intent.getStringExtra(INTENT_RECONNECT_ALARM_EXTRA_TYPE);
+
+        int phoneSubId = mPhone.getSubId();
+        int currSubId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+        log("onActionIntentReconnectAlarm: currSubId = " + currSubId + " phoneSubId=" + phoneSubId);
+
+        // Stop reconnect if not current subId is not correct.
+        // FIXME STOPSHIP - phoneSubId is coming up as -1 way after boot and failing this?
+        if (!SubscriptionManager.isValidSubscriptionId(currSubId) || (currSubId != phoneSubId)) {
+            log("receive ReconnectAlarm but subId incorrect, ignore");
+            return;
+        }
+
+        ApnContext apnContext = mApnContexts.get(apnType);
+
+        if (DBG) {
+            log("onActionIntentReconnectAlarm: mState=" + mState + " reason=" + reason +
+                    " apnType=" + apnType + " apnContext=" + apnContext +
+                    " mDataConnectionAsyncChannels=" + mDataConnectionAcHashMap);
+        }
+
+        if ((apnContext != null) && (apnContext.isEnabled())) {
+            apnContext.setReason(reason);
+            DctConstants.State apnContextState = apnContext.getState();
+            if (DBG) {
+                log("onActionIntentReconnectAlarm: apnContext state=" + apnContextState);
+            }
+            if ((apnContextState == DctConstants.State.FAILED)
+                    || (apnContextState == DctConstants.State.IDLE)) {
+                if (DBG) {
+                    log("onActionIntentReconnectAlarm: state is FAILED|IDLE, disassociate");
+                }
+                DcAsyncChannel dcac = apnContext.getDcAc();
+                if (dcac != null) {
+                    if (DBG) {
+                        log("onActionIntentReconnectAlarm: tearDown apnContext=" + apnContext);
+                    }
+                    dcac.tearDown(apnContext, "", null);
+                }
+                apnContext.setDataConnectionAc(null);
+                apnContext.setState(DctConstants.State.IDLE);
+            } else {
+                if (DBG) log("onActionIntentReconnectAlarm: keep associated");
+            }
+            // TODO: IF already associated should we send the EVENT_TRY_SETUP_DATA???
+            sendMessage(obtainMessage(DctConstants.EVENT_TRY_SETUP_DATA, apnContext));
+
+            apnContext.setReconnectIntent(null);
+        }
+    }
+
+    private void onActionIntentDataStallAlarm(Intent intent) {
+        if (VDBG_STALL) log("onActionIntentDataStallAlarm: action=" + intent.getAction());
+        Message msg = obtainMessage(DctConstants.EVENT_DATA_STALL_ALARM,
+                intent.getAction());
+        msg.arg1 = intent.getIntExtra(DATA_STALL_ALARM_TAG_EXTRA, 0);
+        sendMessage(msg);
+    }
+
+    private final ConnectivityManager mCm;
+
+    /**
+     * List of messages that are waiting to be posted, when data call disconnect
+     * is complete
+     */
+    private ArrayList<Message> mDisconnectAllCompleteMsgList = new ArrayList<Message>();
+
+    private RegistrantList mAllDataDisconnectedRegistrants = new RegistrantList();
+
+    // member variables
+    private final Phone mPhone;
+    private final UiccController mUiccController;
+    private final AtomicReference<IccRecords> mIccRecords = new AtomicReference<IccRecords>();
+    protected AtomicReference<UiccCardApplication> mUiccCardApplication
+            = new AtomicReference<UiccCardApplication>();
+    private DctConstants.Activity mActivity = DctConstants.Activity.NONE;
+    private DctConstants.State mState = DctConstants.State.IDLE;
+    private final Handler mDataConnectionTracker;
+
+    private long mTxPkts;
+    private long mRxPkts;
+    private int mNetStatPollPeriod;
+    private boolean mNetStatPollEnabled = false;
+
+    private TxRxSum mDataStallTxRxSum = new TxRxSum(0, 0);
+    // Used to track stale data stall alarms.
+    private int mDataStallAlarmTag = (int) SystemClock.elapsedRealtime();
+    // The current data stall alarm intent
+    private PendingIntent mDataStallAlarmIntent = null;
+    // Number of packets sent since the last received packet
+    private long mSentSinceLastRecv;
+    // Controls when a simple recovery attempt it to be tried
+    private int mNoRecvPollCount = 0;
+    // Reference counter for enabling fail fast
+    private static int sEnableFailFastRefCounter = 0;
+    // True if data stall detection is enabled
+    private volatile boolean mDataStallDetectionEnabled = true;
+
+    private volatile boolean mFailFast = false;
+
+    // True when in voice call
+    private boolean mInVoiceCall = false;
+
+    // wifi connection status will be updated by sticky intent
+    private boolean mIsWifiConnected = false;
+
+    /** Intent sent when the reconnect alarm fires. */
+    private PendingIntent mReconnectIntent = null;
+
+    // When false we will not auto attach and manually attaching is required.
+    private boolean mAutoAttachOnCreationConfig = false;
+    private AtomicBoolean mAutoAttachOnCreation = new AtomicBoolean(false);
+
+    // State of screen
+    // (TODO: Reconsider tying directly to screen, maybe this is
+    //        really a lower power mode")
+    private boolean mIsScreenOn = true;
+
+    // Indicates if we found mvno-specific APNs in the full APN list.
+    // used to determine if we can accept mno-specific APN for tethering.
+    private boolean mMvnoMatched = false;
+
+    /** Allows the generation of unique Id's for DataConnection objects */
+    private AtomicInteger mUniqueIdGenerator = new AtomicInteger(0);
+
+    /** The data connections. */
+    private HashMap<Integer, DataConnection> mDataConnections =
+            new HashMap<Integer, DataConnection>();
+
+    /** The data connection async channels */
+    private HashMap<Integer, DcAsyncChannel> mDataConnectionAcHashMap =
+            new HashMap<Integer, DcAsyncChannel>();
+
+    /** Convert an ApnType string to Id (TODO: Use "enumeration" instead of String for ApnType) */
+    private HashMap<String, Integer> mApnToDataConnectionId = new HashMap<String, Integer>();
+
+    /** Phone.APN_TYPE_* ===> ApnContext */
+    private final ConcurrentHashMap<String, ApnContext> mApnContexts =
+            new ConcurrentHashMap<String, ApnContext>();
+
+    private final SparseArray<ApnContext> mApnContextsById = new SparseArray<ApnContext>();
+
+    private int mDisconnectPendingCount = 0;
+
+    /** Indicate if metered APNs are disabled.
+     *  set to block all the metered APNs from continuously sending requests, which causes
+     *  undesired network load */
+    private boolean mMeteredApnDisabled = false;
+
+    // M: Multi-PS attach Start
+    private boolean mAllowConfig = false;
+    // M: Multi-PS attach End
+
+    /**
+     * Handles changes to the APN db.
+     */
+    private class ApnChangeObserver extends ContentObserver {
+        public ApnChangeObserver () {
+            super(mDataConnectionTracker);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            removeMessages(DctConstants.EVENT_APN_CHANGED);
+            // M: De-bound the onApnChanged in threads trigger in the same time
+            sendMessageDelayed(obtainMessage(DctConstants.EVENT_APN_CHANGED), APN_CHANGE_MILLIS);
+            //sendMessage(obtainMessage(DctConstants.EVENT_APN_CHANGED));
+        }
+    }
+
+    // M: JPN IA Start
+    /**
+    * Handles changes to the settings of IMS switch db.
+    */
+    private ContentObserver mImsSwitchChangeObserver  = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            if (DBG) {
+                log("mImsSwitchChangeObserver: onChange=" + selfChange);
+            }
+            if (isOp17IaSupport()) {
+                log("IA : OP17, set IA");
+                setInitialAttachApn();
+            }
+        }
+    };
+    // M: JPN IA End
+
+    //***** Instance Variables
+
+    private boolean mReregisterOnReconnectFailure = false;
+
+
+    //***** Constants
+
+    // Used by puppetmaster/*/radio_stress.py
+    private static final String PUPPET_MASTER_RADIO_STRESS_TEST = "gsm.defaultpdpcontext.active";
+
+    private static final int POLL_PDP_MILLIS = 5 * 1000;
+    private static final int APN_CHANGE_MILLIS = 1 * 1000;
+
+    private static final int PROVISIONING_SPINNER_TIMEOUT_MILLIS = 120 * 1000;
+
+    static final Uri PREFERAPN_NO_UPDATE_URI_USING_SUBID =
+                        Uri.parse("content://telephony/carriers/preferapn_no_update/subId/");
+    static final String APN_ID = "apn_id";
+
+    private boolean mCanSetPreferApn = false;
+
+    private AtomicBoolean mAttached = new AtomicBoolean(false);
+
+    /** Watches for changes to the APN db. */
+    private ApnChangeObserver mApnObserver;
+
+    private final String mProvisionActionName;
+    private BroadcastReceiver mProvisionBroadcastReceiver;
+    private ProgressDialog mProvisioningSpinner;
+
+    public boolean mImsRegistrationState = false;
+
+    // M: Data connection fail cause manager
+    protected DcFailCauseManager mDcFcMgr;
+
+    // M: Fast Dormancy
+    protected FdManager mFdMgr;
+
+    // M: For Plug in
+    private static final boolean BSP_PACKAGE =
+            SystemProperties.getBoolean("ro.mtk_bsp_package", false);
+    private IGsmDCTExt mGsmDctExt;
+    private ITelephonyExt mTelephonyExt;
+
+    // M: Vsim
+    private static final String PROPERTY_VSIM_ENABLE =
+            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED;
+
+    private static final String PROPERTY_FORCE_APN_CHANGE = "ril.force_apn_change";
+
+    // M: start of throttling APN
+    private static final boolean THROTTLING_APN_ENABLED =
+            SystemProperties.get("persist.mtk_volte_support").equals("1");
+    private static final String PROPERTY_THROTTLING_APN_ENABLED = "ril.throttling.enabled";
+    private static final String HIGH_THROUGHPUT_APN[] = {
+        PhoneConstants.APN_TYPE_ALL,
+        PhoneConstants.APN_TYPE_DEFAULT,
+        PhoneConstants.APN_TYPE_DUN,
+        PhoneConstants.APN_TYPE_HIPRI,
+        PhoneConstants.APN_TYPE_TETHERING
+    };
+
+    // VOLTE
+    private static final String IMS_APN[] = {
+        PhoneConstants.APN_TYPE_IMS,
+        PhoneConstants.APN_TYPE_EMERGENCY,
+    };
+
+    private static final int PDP_CONNECTION_POOL_SIZE = 3;
+    private static final int THROTTLING_MAX_PDP_SIZE = 8;
+
+    private static final int MIN_ID_HIGH_TROUGHPUT = 0;
+    private static final int MAX_ID_HIGH_TROUGHPUT = 1;
+    private static final int MIN_ID_OTHERS_TROUGHPUT = 2;
+    private static final int MAX_ID_OTHERS_TROUGHPUT = 3;
+    private static final int MIN_ID_IMS_TROUGHPUT = 4;
+    private static final int MAX_ID_IMS_TROUGHPUT = 6;
+
+    private AtomicInteger mHighThroughputIdGenerator = new AtomicInteger(0);
+    private AtomicInteger mOthersUniqueIdGenerator = new AtomicInteger(2);
+    private AtomicInteger mImsUniqueIdGenerator = new AtomicInteger(4);
+    // M: end of throttling APN
+
+    // M: Google issue, this thread should quit when DcTracker dispose,
+    //    otherwise memory leak will happen.
+    private HandlerThread mDcHandlerThread;
+
+    //***** Constructor
+    public DcTracker(Phone phone) {
+        super();
+        mPhone = phone;
+
+        if (DBG) log("DCT.constructor");
+
+        mResolver = mPhone.getContext().getContentResolver();
+        mUiccController = UiccController.getInstance();
+        mUiccController.registerForIccChanged(this, DctConstants.EVENT_ICC_CHANGED, null);
+        mAlarmManager =
+                (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
+        mCm = (ConnectivityManager) mPhone.getContext().getSystemService(
+                Context.CONNECTIVITY_SERVICE);
+
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(INTENT_DATA_STALL_ALARM);
+        filter.addAction(INTENT_PROVISIONING_APN_ALARM);
+        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+
+        // TODO - redundent with update call below?
+        mDataEnabledSettings.setUserDataEnabled(getDataEnabled());
+
+        mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mPhone.getContext());
+        mAutoAttachOnCreation.set(sp.getBoolean(Phone.DATA_DISABLED_ON_BOOT_KEY, false));
+
+        mSubscriptionManager = SubscriptionManager.from(mPhone.getContext());
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+
+        mDcHandlerThread = new HandlerThread("DcHandlerThread");
+        mDcHandlerThread.start();
+        Handler dcHandler = new Handler(mDcHandlerThread.getLooper());
+        mDcc = DcController.makeDcc(mPhone, this, dcHandler);
+        mDcTesterFailBringUpAll = new DcTesterFailBringUpAll(mPhone, dcHandler);
+
+        logd("DualApnSupport = " + MTK_DUAL_APN_SUPPORT);
+
+        mDataConnectionTracker = this;
+        registerForAllEvents();
+        update();
+
+        mApnObserver = new ApnChangeObserver();
+        phone.getContext().getContentResolver().registerContentObserver(
+                Telephony.Carriers.CONTENT_URI, true, mApnObserver);
+
+        if (false == hasOperatorIaCapability()){
+            phone.getContext().getContentResolver().registerContentObserver(
+                    Settings.Global.getUriFor(Settings.Global.ENHANCED_4G_MODE_ENABLED), true,
+                    mImsSwitchChangeObserver);
+        }
+
+        initApnContexts();
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            // Register the reconnect and restart actions.
+            filter = new IntentFilter();
+            filter.addAction(INTENT_RECONNECT_ALARM + '.' + apnContext.getApnType());
+            mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
+        }
+
+        // M: Initialize data connection fail cause manager
+        mDcFcMgr = DcFailCauseManager.getInstance(mPhone);
+
+        // Add Emergency APN to APN setting list by default to support EPDN in sim absent cases
+        initEmergencyApnSetting();
+        addEmergencyApnSetting();
+
+        // M: Fast Dormancy init
+        mFdMgr = FdManager.getInstance(phone);
+
+        //MTK START: Add Plug in
+        if (!BSP_PACKAGE) {
+            try {
+                mGsmDctExt =
+                    MPlugin.createInstance(IGsmDCTExt.class.getName(), mPhone.getContext());
+
+                mTelephonyExt =
+                    MPlugin.createInstance(ITelephonyExt.class.getName(), mPhone.getContext());
+                mTelephonyExt.init(mPhone.getContext());
+                mTelephonyExt.startDataRoamingStrategy(mPhone);
+            } catch (Exception e) {
+                logw("mGsmDctExt or mTelephonyExt init fail");
+                e.printStackTrace();
+            }
+        }
+        //MTK END
+
+        mProvisionActionName = "com.android.internal.telephony.PROVISION" + phone.getPhoneId();
+
+        mSettingsObserver = new SettingsObserver(mPhone.getContext(), this);
+        registerSettingsObserver();
+    }
+
+    @VisibleForTesting
+    public DcTracker() {
+        mAlarmManager = null;
+        mCm = null;
+        mPhone = null;
+        mUiccController = null;
+        mDataConnectionTracker = null;
+        mProvisionActionName = null;
+        mSettingsObserver = new SettingsObserver(null, this);
+    }
+
+    public void registerServiceStateTrackerEvents() {
+        mPhone.getServiceStateTracker().registerForDataConnectionAttached(this,
+                DctConstants.EVENT_DATA_CONNECTION_ATTACHED, null);
+        mPhone.getServiceStateTracker().registerForDataConnectionDetached(this,
+                DctConstants.EVENT_DATA_CONNECTION_DETACHED, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingOn(this,
+                DctConstants.EVENT_ROAMING_ON, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingOff(this,
+                DctConstants.EVENT_ROAMING_OFF, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingTypeChange(this,
+                DctConstants.EVENT_ROAMING_TYPE_CHANGED, null);
+        mPhone.getServiceStateTracker().registerForPsRestrictedEnabled(this,
+                DctConstants.EVENT_PS_RESTRICT_ENABLED, null);
+        mPhone.getServiceStateTracker().registerForPsRestrictedDisabled(this,
+                DctConstants.EVENT_PS_RESTRICT_DISABLED, null);
+        mPhone.getServiceStateTracker().registerForDataRegStateOrRatChanged(this,
+                DctConstants.EVENT_DATA_RAT_CHANGED, null);
+    }
+
+    public void unregisterServiceStateTrackerEvents() {
+        mPhone.getServiceStateTracker().unregisterForDataConnectionAttached(this);
+        mPhone.getServiceStateTracker().unregisterForDataConnectionDetached(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingOn(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingOff(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingTypeChange(this);
+        mPhone.getServiceStateTracker().unregisterForPsRestrictedEnabled(this);
+        mPhone.getServiceStateTracker().unregisterForPsRestrictedDisabled(this);
+        mPhone.getServiceStateTracker().unregisterForDataRegStateOrRatChanged(this);
+    }
+
+    private void registerForAllEvents() {
+        logd("registerForAllEvents: mPhone = " + mPhone);
+        mPhone.mCi.registerForAvailable(this, DctConstants.EVENT_RADIO_AVAILABLE, null);
+        mPhone.mCi.registerForOffOrNotAvailable(this,
+                DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
+        mPhone.mCi.registerForDataNetworkStateChanged(this,
+                DctConstants.EVENT_DATA_STATE_CHANGED, null);
+        // Note, this is fragile - the Phone is now presenting a merged picture
+        // of PS (volte) & CS and by diving into its internals you're just seeing
+        // the CS data.  This works well for the purposes this is currently used for
+        // but that may not always be the case.  Should probably be redesigned to
+        // accurately reflect what we're really interested in (registerForCSVoiceCallEnded).
+
+        // M: Remove below section for the reason that new PS/CS design has been applied.
+        //mPhone.getCallTracker().registerForVoiceCallEnded(this,
+        //        DctConstants.EVENT_VOICE_CALL_ENDED, null);
+        //mPhone.getCallTracker().registerForVoiceCallStarted(this,
+        //        DctConstants.EVENT_VOICE_CALL_STARTED, null);
+        // M: End
+        registerServiceStateTrackerEvents();
+     //   SubscriptionManager.registerForDdsSwitch(this,
+     //          DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS, null);
+        mPhone.mCi.registerForPcoData(this, DctConstants.EVENT_PCO_DATA_RECEIVED, null);
+
+        // M: cc33
+        mPhone.mCi.registerForRemoveRestrictEutran(this, DctConstants.EVENT_REMOVE_RESTRICT_EUTRAN
+                ,null);
+        // M: Data Retry
+        mPhone.mCi.registerForMdDataRetryCountReset(this,
+                DctConstants.EVENT_MD_DATA_RETRY_COUNT_RESET, null);
+
+        if (false == hasOperatorIaCapability()) {
+            // M: JPN IA
+            if (!WorldPhoneUtil.isWorldPhoneSupport() &&
+                    !("OP01".equals(SystemProperties.get("ro.operator.optr")))) {
+                mPhone.mCi.setOnPlmnChangeNotification(this,
+                        DctConstants.EVENT_REG_PLMN_CHANGED, null);
+                mPhone.mCi.setOnRegistrationSuspended(this, DctConstants.EVENT_REG_SUSPENDED, null);
+            }
+            // M: JPN IA End
+
+            //M: Reset Attach Apn
+            mPhone.mCi.registerForResetAttachApn(this, DctConstants.EVENT_RESET_ATTACH_APN, null);
+
+            // M: IA-change attach APN
+            mPhone.mCi.registerForAttachApnChanged(this,
+                    DctConstants.EVENT_ATTACH_APN_CHANGED, null);
+        }
+
+        mPhone.mCi.registerForPcoStatus(this, DctConstants.EVENT_PCO_STATUS, null);
+
+        // M: [LTE][Low Power][UL traffic shaping]
+        // TODO: Should this move to NW frameworks to handle?
+        mPhone.mCi.registerForLteAccessStratumState(this,
+                DctConstants.EVENT_LTE_ACCESS_STRATUM_STATE, null);
+
+        // M: Multi-PS Attach Start
+        mPhone.mCi.registerSetDataAllowed(this, DctConstants.EVENT_DATA_ALLOWED, null);
+        // M: Multi-PS Attach End
+
+        // M: Register for the change of mDataEnabledSettings
+        registerForDataEnabledChanged(this, DctConstants.EVENT_DATA_ENABLED_SETTINGS, null);
+    }
+
+    public void dispose() {
+        if (DBG) log("DCT.dispose");
+
+        /// M: To stop data customization strategy @{
+        if (mTelephonyExt != null) {
+            mTelephonyExt.stopDataRoamingStrategy();
+        }
+
+        if (mProvisionBroadcastReceiver != null) {
+            mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
+            mProvisionBroadcastReceiver = null;
+        }
+        if (mProvisioningSpinner != null) {
+            mProvisioningSpinner.dismiss();
+            mProvisioningSpinner = null;
+        }
+
+        cleanUpAllConnections(true, null);
+
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            dcac.disconnect();
+        }
+        mDataConnectionAcHashMap.clear();
+        mIsDisposed = true;
+        mPhone.getContext().unregisterReceiver(mIntentReceiver);
+        mUiccController.unregisterForIccChanged(this);
+        mSettingsObserver.unobserve();
+
+        mSubscriptionManager
+                .removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+        mDcc.dispose();
+        mDcTesterFailBringUpAll.dispose();
+
+        mPhone.getContext().getContentResolver().unregisterContentObserver(mApnObserver);
+
+        mPhone.getContext().getContentResolver().unregisterContentObserver(
+                mImsSwitchChangeObserver);
+
+        unregisterForAllEvents();
+
+        mApnContexts.clear();
+        mApnContextsById.clear();
+        mPrioritySortedApnContexts.clear();
+        unregisterForAllEvents();
+
+        destroyDataConnections();
+
+        if (mDcHandlerThread != null) {
+            mDcHandlerThread.quitSafely();
+        }
+
+        // M: dispose data connection fail cause manager
+        mDcFcMgr.dispose();
+    }
+
+    private void unregisterForAllEvents() {
+        logd("unregisterForAllEvents: mPhone = " + mPhone);
+         //Unregister for all events
+        mPhone.mCi.unregisterForAvailable(this);
+        mPhone.mCi.unregisterForOffOrNotAvailable(this);
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            r.unregisterForRecordsLoaded(this);
+            mIccRecords.set(null);
+        }
+        mPhone.mCi.unregisterForDataNetworkStateChanged(this);
+        // M: Remove below section for the reason that new PS/CS design has been applied.
+        //mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
+        //mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
+        // M: End
+        unregisterServiceStateTrackerEvents();
+        //SubscriptionManager.unregisterForDdsSwitch(this);
+        mPhone.mCi.unregisterForPcoData(this);
+
+        // M: cc33
+        mPhone.mCi.unregisterForRemoveRestrictEutran(this);
+        // M: Data Retry
+        mPhone.mCi.unregisterForMdDataRetryCountReset(this);
+
+        if (false == hasOperatorIaCapability()) {
+            // M: JPN IA Start
+            if (!WorldPhoneUtil.isWorldPhoneSupport() &&
+                    !("OP01".equals(SystemProperties.get("ro.operator.optr")))) {
+                mPhone.mCi.unSetOnPlmnChangeNotification(this);
+                mPhone.mCi.unSetOnRegistrationSuspended(this);
+            }
+            // M: JPN IA End
+            // M: Reset Attach Apn
+            mPhone.mCi.unregisterForResetAttachApn(this);
+
+            // M: IA-change attach APN from modem.
+            mPhone.mCi.unregisterForAttachApnChanged(this);
+        }
+
+        mPhone.mCi.unregisterForPcoStatus(this);
+
+        // M: [LTE][Low Power][UL traffic shaping]
+        // TODO: Should this move to NW frameworks to handle?
+        mPhone.mCi.unregisterForLteAccessStratumState(this);
+
+        // M: Multi-PS Attach Start
+        mPhone.mCi.unregisterSetDataAllowed(this);
+        // M: Multi-PS Attach End
+
+        // M: Unregister for the change of mDataEnabledSettings
+        unregisterForDataEnabledChanged(this);
+    }
+
+    /**
+     * Called when EVENT_RESET_DONE is received so goto
+     * IDLE state and send notifications to those interested.
+     *
+     * TODO - currently unused.  Needs to be hooked into DataConnection cleanup
+     * TODO - needs to pass some notion of which connection is reset..
+     */
+    private void onResetDone(AsyncResult ar) {
+        if (DBG) log("EVENT_RESET_DONE");
+        String reason = null;
+        if (ar.userObj instanceof String) {
+            reason = (String) ar.userObj;
+        }
+        gotoIdleAndNotifyDataConnection(reason);
+    }
+
+    /**
+     * Modify {@link android.provider.Settings.Global#MOBILE_DATA} value.
+     */
+    public void setDataEnabled(boolean enable) {
+        Message msg = obtainMessage(DctConstants.CMD_SET_USER_DATA_ENABLE);
+        msg.arg1 = enable ? 1 : 0;
+        if (DBG) log("setDataEnabled: sendMessage: enable=" + enable);
+        sendMessage(msg);
+    }
+
+    private void onSetUserDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            if (mDataEnabledSettings.isUserDataEnabled() != enabled) {
+                mDataEnabledSettings.setUserDataEnabled(enabled);
+
+                //TODO: We should move the followings into DataEnabledSettings class.
+                // For single SIM phones, this is a per phone property.
+                if (TelephonyManager.getDefault().getSimCount() == 1) {
+                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
+                } else {
+                    int phoneSubId = mPhone.getSubId();
+                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId,
+                            enabled ? 1 : 0);
+                }
+
+                // M:
+                setUserDataProperty(enabled);
+                notifyMobileDataChange(enabled ? 1 : 0);
+                // M: }@
+            }
+        }
+    }
+
+    /**
+     * Handle reverting restricted networks back to unrestricted.
+     * If we're changing user data to enabled and this makes data
+     * truely enabled (not disabled by other factors) we need to
+     * tear down any metered apn type that was enabled anyway by
+     * a privileged request.  This allows us to reconnect
+     * to it in an unrestricted way.
+     */
+    private void teardownRestrictedMeteredConnections() {
+        if (mDataEnabledSettings.isDataEnabled(true)) {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                if (apnContext.isConnectedOrConnecting() &&
+                        apnContext.getApnSetting().isMetered(mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming())) {
+
+                    final DcAsyncChannel dataConnectionAc = apnContext.getDcAc();
+                    if (dataConnectionAc != null) {
+                        final NetworkCapabilities nc =
+                                dataConnectionAc.getNetworkCapabilitiesSync();
+                        if (nc != null && nc.hasCapability(NetworkCapabilities.
+                              NET_CAPABILITY_NOT_RESTRICTED)) {
+                            if (DBG) log("not tearing down unrestricted metered net:" + apnContext);
+                            continue;
+                        }
+                    }
+                    if (DBG) log("tearing down restricted metered net: " + apnContext);
+                    apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                    cleanUpConnection(true, apnContext);
+                }
+            }
+        }
+    }
+
+    private void onDeviceProvisionedChange() {
+        if (getDataEnabled()) {
+            mDataEnabledSettings.setUserDataEnabled(true);
+            teardownRestrictedMeteredConnections();
+            onTrySetupData(Phone.REASON_DATA_ENABLED);
+        } else {
+            mDataEnabledSettings.setUserDataEnabled(false);
+            onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+        }
+    }
+
+
+    public long getSubId() {
+        return mPhone.getSubId();
+    }
+
+    public DctConstants.Activity getActivity() {
+        return mActivity;
+    }
+
+    private void setActivity(DctConstants.Activity activity) {
+        log("setActivity = " + activity);
+        mActivity = activity;
+        mPhone.notifyDataActivity();
+    }
+
+    public void requestNetwork(NetworkRequest networkRequest, LocalLog log) {
+        final int apnId = ApnContext.apnIdForNetworkRequest(networkRequest);
+        final ApnContext apnContext = mApnContextsById.get(apnId);
+        log.log("DcTracker.requestNetwork for " + networkRequest + " found " + apnContext);
+        if (apnContext != null) apnContext.requestNetwork(networkRequest, log);
+    }
+
+    public void releaseNetwork(NetworkRequest networkRequest, LocalLog log) {
+        final int apnId = ApnContext.apnIdForNetworkRequest(networkRequest);
+        final ApnContext apnContext = mApnContextsById.get(apnId);
+        log.log("DcTracker.releaseNetwork for " + networkRequest + " found " + apnContext);
+        if (apnContext != null) apnContext.releaseNetwork(networkRequest, log);
+    }
+
+    public boolean isApnSupported(String name) {
+        if (name == null) {
+            loge("isApnSupported: name=null");
+            return false;
+        }
+        ApnContext apnContext = mApnContexts.get(name);
+        if (apnContext == null) {
+            loge("Request for unsupported mobile name: " + name);
+            return false;
+        }
+        return true;
+    }
+
+    public int getApnPriority(String name) {
+        ApnContext apnContext = mApnContexts.get(name);
+        if (apnContext == null) {
+            loge("Request for unsupported mobile name: " + name);
+        }
+        return apnContext.priority;
+    }
+
+    // Turn telephony radio on or off.
+    private void setRadio(boolean on) {
+        final ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
+        try {
+            phone.setRadio(on);
+        } catch (Exception e) {
+            // Ignore.
+        }
+    }
+
+    // Class to handle Intent dispatched with user selects the "Sign-in to network"
+    // notification.
+    private class ProvisionNotificationBroadcastReceiver extends BroadcastReceiver {
+        private final String mNetworkOperator;
+        // Mobile provisioning URL.  Valid while provisioning notification is up.
+        // Set prior to notification being posted as URL contains ICCID which
+        // disappears when radio is off (which is the case when notification is up).
+        private final String mProvisionUrl;
+
+        public ProvisionNotificationBroadcastReceiver(String provisionUrl, String networkOperator) {
+            mNetworkOperator = networkOperator;
+            mProvisionUrl = provisionUrl;
+        }
+
+        private void setEnableFailFastMobileData(int enabled) {
+            sendMessage(obtainMessage(DctConstants.CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA, enabled, 0));
+        }
+
+        private void enableMobileProvisioning() {
+            final Message msg = obtainMessage(DctConstants.CMD_ENABLE_MOBILE_PROVISIONING);
+            msg.setData(Bundle.forPair(DctConstants.PROVISIONING_URL_KEY, mProvisionUrl));
+            sendMessage(msg);
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // Turning back on the radio can take time on the order of a minute, so show user a
+            // spinner so they know something is going on.
+            mProvisioningSpinner = new ProgressDialog(context);
+            mProvisioningSpinner.setTitle(mNetworkOperator);
+            mProvisioningSpinner.setMessage(
+                    // TODO: Don't borrow "Connecting..." i18n string; give Telephony a version.
+                    context.getText(com.android.internal.R.string.media_route_status_connecting));
+            mProvisioningSpinner.setIndeterminate(true);
+            mProvisioningSpinner.setCancelable(true);
+            // Allow non-Activity Service Context to create a View.
+            mProvisioningSpinner.getWindow().setType(
+                    WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
+            mProvisioningSpinner.show();
+            // After timeout, hide spinner so user can at least use their device.
+            // TODO: Indicate to user that it is taking an unusually long time to connect?
+            sendMessageDelayed(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER,
+                    mProvisioningSpinner), PROVISIONING_SPINNER_TIMEOUT_MILLIS);
+            // This code is almost identical to the old
+            // ConnectivityService.handleMobileProvisioningAction code.
+            setRadio(true);
+            setEnableFailFastMobileData(DctConstants.ENABLED);
+            enableMobileProvisioning();
+        }
+    }
+
+    public boolean isDataPossible(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext == null) {
+            return false;
+        }
+        boolean apnContextIsEnabled = apnContext.isEnabled();
+        DctConstants.State apnContextState = apnContext.getState();
+        boolean apnTypePossible = !(apnContextIsEnabled &&
+                (apnContextState == DctConstants.State.FAILED));
+        boolean isEmergencyApn = apnContext.getApnType().equals(PhoneConstants.APN_TYPE_EMERGENCY);
+        // Set the emergency APN availability status as TRUE irrespective of conditions checked in
+        // isDataAllowed() like IN_SERVICE, MOBILE DATA status etc.
+        boolean dataAllowed = isEmergencyApn || isDataAllowed(null);
+        boolean possible = dataAllowed && apnTypePossible;
+
+        if ((apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    || apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IA))
+                && (mPhone.getServiceState().getRilDataRadioTechnology()
+                == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+            log("Default data call activation not possible in iwlan.");
+            possible = false;
+        }
+
+        if (VDBG) {
+            log(String.format("isDataPossible(%s): possible=%b isDataAllowed=%b " +
+                            "apnTypePossible=%b apnContextisEnabled=%b apnContextState()=%s",
+                    apnType, possible, dataAllowed, apnTypePossible,
+                    apnContextIsEnabled, apnContextState));
+        }
+        return possible;
+    }
+
+    @Override
+    protected void finalize() {
+        if(DBG && mPhone != null) log("finalize");
+    }
+
+    private ApnContext addApnContext(String type, NetworkConfig networkConfig) {
+        ApnContext apnContext = new ApnContext(mPhone, type, LOG_TAG, networkConfig, this);
+        mApnContexts.put(type, apnContext);
+        mApnContextsById.put(ApnContext.apnIdForApnName(type), apnContext);
+        mPrioritySortedApnContexts.add(apnContext);
+        return apnContext;
+    }
+
+    private void initApnContexts() {
+        log("initApnContexts: E");
+        // Load device network attributes from resources
+        String[] networkConfigStrings = mPhone.getContext().getResources().getStringArray(
+                com.android.internal.R.array.networkAttributes);
+        for (String networkConfigString : networkConfigStrings) {
+            NetworkConfig networkConfig = new NetworkConfig(networkConfigString);
+            ApnContext apnContext = null;
+
+            switch (networkConfig.type) {
+            case ConnectivityManager.TYPE_MOBILE:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DEFAULT, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_MMS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_MMS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_SUPL:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_SUPL, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_DUN:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DUN, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_HIPRI:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_HIPRI, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_FOTA:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_FOTA, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_IMS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_IMS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_CBS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_CBS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_IA:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_IA, networkConfig);
+                break;
+            /** M: start */
+            case ConnectivityManager.TYPE_MOBILE_DM:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DM, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_NET:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_NET, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_WAP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_WAP, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_CMMAIL:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_CMMAIL, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_RCSE:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_RCSE, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_XCAP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_XCAP, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_RCS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_RCS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_BIP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_BIP, networkConfig);
+                break;
+            /** M: end*/
+            case ConnectivityManager.TYPE_MOBILE_EMERGENCY:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_EMERGENCY, networkConfig);
+                break;
+            default:
+                log("initApnContexts: skipping unknown type=" + networkConfig.type);
+                continue;
+            }
+            log("initApnContexts: apnContext=" + apnContext);
+        }
+
+        //The implement of priorityQueue class is incorrect, we sort the list by ourself
+        Collections.sort(mPrioritySortedApnContexts, new Comparator<ApnContext>() {
+            public int compare(ApnContext c1, ApnContext c2) {
+                return c2.priority - c1.priority;
+            }
+        });
+        logd("initApnContexts: mPrioritySortedApnContexts=" + mPrioritySortedApnContexts);
+        if (VDBG) log("initApnContexts: X mApnContexts=" + mApnContexts);
+    }
+
+    public LinkProperties getLinkProperties(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            DcAsyncChannel dcac = apnContext.getDcAc();
+            if (dcac != null) {
+                if (DBG) log("return link properites for " + apnType);
+                return dcac.getLinkPropertiesSync();
+            }
+        }
+        if (DBG) log("return new LinkProperties");
+        return new LinkProperties();
+    }
+
+    public NetworkCapabilities getNetworkCapabilities(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext!=null) {
+            DcAsyncChannel dataConnectionAc = apnContext.getDcAc();
+            if (dataConnectionAc != null) {
+                if (DBG) {
+                    log("get active pdp is not null, return NetworkCapabilities for " + apnType);
+                }
+                return dataConnectionAc.getNetworkCapabilitiesSync();
+            }
+        }
+        if (DBG) log("return new NetworkCapabilities");
+        return new NetworkCapabilities();
+    }
+
+    // Return all active apn types
+    public String[] getActiveApnTypes() {
+        if (DBG) log("get all active apn types");
+        ArrayList<String> result = new ArrayList<String>();
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (mAttached.get() && apnContext.isReady()) {
+                result.add(apnContext.getApnType());
+            }
+        }
+
+        return result.toArray(new String[0]);
+    }
+
+    // Return active apn of specific apn type
+    public String getActiveApnString(String apnType) {
+        if (VDBG) logv("get active apn string for type:" + apnType);
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            ApnSetting apnSetting = apnContext.getApnSetting();
+            if (apnSetting != null) {
+                return apnSetting.apn;
+            }
+        }
+        return null;
+    }
+
+    // Return state of specific apn type
+    public DctConstants.State getState(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            return apnContext.getState();
+        }
+        return DctConstants.State.FAILED;
+    }
+
+    // Return if apn type is a provisioning apn.
+    private boolean isProvisioningApn(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            return apnContext.isProvisioningApn();
+        }
+        return false;
+    }
+
+    // Return state of overall
+    public DctConstants.State getOverallState() {
+        boolean isConnecting = false;
+        boolean isFailed = true; // All enabled Apns should be FAILED.
+        boolean isAnyEnabled = false;
+
+        //M: For debug, dump overall state.
+        StringBuilder builder = new StringBuilder();
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext != null) {
+                builder.append(apnContext.toString() + ", ");
+            }
+        }
+        logd("overall state is " + builder);
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.isEnabled()) {
+                isAnyEnabled = true;
+                switch (apnContext.getState()) {
+                case CONNECTED:
+                case DISCONNECTING:
+                    if (VDBG) log("overall state is CONNECTED");
+                    return DctConstants.State.CONNECTED;
+                case RETRYING:
+                case CONNECTING:
+                    isConnecting = true;
+                    isFailed = false;
+                    break;
+                case IDLE:
+                case SCANNING:
+                    isFailed = false;
+                    break;
+                default:
+                    isAnyEnabled = true;
+                    break;
+                }
+            }
+        }
+
+        if (!isAnyEnabled) { // Nothing enabled. return IDLE.
+            if (VDBG) log( "overall state is IDLE");
+            return DctConstants.State.IDLE;
+        }
+
+        if (isConnecting) {
+            if (VDBG) log( "overall state is CONNECTING");
+            return DctConstants.State.CONNECTING;
+        } else if (!isFailed) {
+            if (VDBG) log( "overall state is IDLE");
+            return DctConstants.State.IDLE;
+        } else {
+            if (VDBG) log( "overall state is FAILED");
+            return DctConstants.State.FAILED;
+        }
+    }
+
+    public boolean isApnTypeAvailable(String type) {
+        if ((type.equals(PhoneConstants.APN_TYPE_DUN) && fetchDunApn() != null) ||
+             type.equals(PhoneConstants.APN_TYPE_EMERGENCY)) {
+            logd("isApnTypeAvaiable, apn: " + type);
+            return true;
+        }
+
+        if (mAllApnSettings != null) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(type)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Report on whether data connectivity is enabled for any APN.
+     * @return {@code false} if data connectivity has been explicitly disabled,
+     * {@code true} otherwise.
+     */
+    public boolean getAnyDataEnabled() {
+        if (!mDataEnabledSettings.isDataEnabled(true)) return false;
+        DataAllowFailReason failureReason = new DataAllowFailReason();
+        if (!isDataAllowed(failureReason)) {
+            if (DBG) log(failureReason.getDataAllowFailReason());
+            return false;
+        }
+        for (ApnContext apnContext : mApnContexts.values()) {
+            // Make sure we don't have a context that is going down
+            // and is explicitly disabled.
+            if (isDataAllowedForApn(apnContext)) {
+                logd("getAnyDataEnabled1 return true, apn=" + apnContext.getApnType());
+                return true;
+            }
+        }
+        log("getAnyDataEnabled1 return false");
+        return false;
+    }
+
+    @VisibleForTesting
+    public boolean isDataEnabled(boolean checkUserDataEnabled) {
+        return mDataEnabledSettings.isDataEnabled(checkUserDataEnabled);
+    }
+
+    private boolean isDataAllowedForApn(ApnContext apnContext) {
+        //If RAT is iwlan then dont allow default/IA PDP at all.
+        //Rest of APN types can be evaluated for remaining conditions.
+        if ((apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    || apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IA))
+                && (mPhone.getServiceState().getRilDataRadioTechnology()
+                == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+            log("Default data call activation not allowed in iwlan.");
+            return false;
+        }
+
+        return apnContext.isReady();
+    }
+
+    //****** Called from ServiceStateTracker
+    /**
+     * Invoked when ServiceStateTracker observes a transition from GPRS
+     * attach to detach.
+     */
+    private void onDataConnectionDetached() {
+        /*
+         * We presently believe it is unnecessary to tear down the PDP context
+         * when GPRS detaches, but we should stop the network polling.
+         */
+        if (DBG) log ("onDataConnectionDetached: stop polling and notify detached");
+        stopNetStatPoll();
+        stopDataStallAlarm();
+        notifyDataConnection(Phone.REASON_DATA_DETACHED);
+        mAttached.set(false);
+
+        // M: To avoid trying setup data call before PS attach.
+        if (mAutoAttachOnCreationConfig) {
+            mAutoAttachOnCreation.set(false);
+        }
+    }
+
+    private void onDataConnectionAttached() {
+        if (DBG) log("onDataConnectionAttached");
+        mAttached.set(true);
+        if (getOverallState() == DctConstants.State.CONNECTED) {
+            if (DBG) log("onDataConnectionAttached: start polling notify attached");
+            startNetStatPoll();
+            startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+            notifyDataConnection(Phone.REASON_DATA_ATTACHED);
+        } else {
+            // update APN availability so that APN can be enabled.
+            notifyOffApnsOfAvailability(Phone.REASON_DATA_ATTACHED);
+        }
+        if (mAutoAttachOnCreationConfig) {
+            mAutoAttachOnCreation.set(true);
+        }
+        setupDataOnConnectableApns(Phone.REASON_DATA_ATTACHED);
+    }
+
+    private boolean isDataAllowed(DataAllowFailReason failureReason) {
+        final boolean internalDataEnabled;
+        internalDataEnabled = mDataEnabledSettings.isInternalDataEnabled();
+
+        boolean attachedState = mAttached.get();
+        boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
+        boolean radioStateFromCarrier = mPhone.getServiceStateTracker().getPowerStateFromCarrier();
+        int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+        if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+            desiredPowerState = true;
+            radioStateFromCarrier = true;
+        }
+
+        IccRecords r = mIccRecords.get();
+        boolean recordsLoaded = false;
+        if (r != null) {
+            recordsLoaded = r.getRecordsLoaded();
+            if (DBG && !recordsLoaded) log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
+        }
+
+        boolean bIsFdnEnabled = isFdnEnabled();
+
+        int dataSub = SubscriptionManager.getDefaultDataSubscriptionId();
+        boolean defaultDataSelected = SubscriptionManager.isValidSubscriptionId(dataSub);
+
+        PhoneConstants.State state = PhoneConstants.State.IDLE;
+        // Note this is explicitly not using mPhone.getState.  See b/19090488.
+        // mPhone.getState reports the merge of CS and PS (volte) voice call state
+        // but we only care about CS calls here for data/voice concurrency issues.
+        // Calling getCallTracker currently gives you just the CS side where the
+        // ImsCallTracker is held internally where applicable.
+        // This should be redesigned to ask explicitly what we want:
+        // voiceCallStateAllowDataCall, or dataCallAllowed or something similar.
+        if (mPhone.getCallTracker() != null) {
+            state = mPhone.getCallTracker().getState();
+        }
+
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (failureReason != null) failureReason.clearAllReasons();
+        if (!(attachedState || mAutoAttachOnCreation.get())) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.NOT_ATTACHED);
+        }
+        if (!recordsLoaded) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.RECORD_NOT_LOADED);
+        }
+        if (!dcHelper.isAllCallingStateIdle() &&
+                !dcHelper.isDataSupportConcurrent(mPhone.getPhoneId())) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.INVALID_PHONE_STATE);
+            failureReason.addDataAllowFailReason(
+                    DataAllowFailReasonType.CONCURRENT_VOICE_DATA_NOT_ALLOWED);
+        }
+        if (!internalDataEnabled) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.INTERNAL_DATA_DISABLED);
+        }
+        if (!defaultDataSelected) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(
+                    DataAllowFailReasonType.DEFAULT_DATA_UNSELECTED);
+        }
+        if ((mPhone.getServiceState().getDataRoaming() ||
+                mPhone.getServiceStateTracker().isPsRegStateRoamByUnsol()) &&
+                !getDataOnRoamingEnabled()) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.ROAMING_DISABLED);
+        }
+        if (mIsPsRestricted) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.PS_RESTRICTED);
+        }
+        if (!desiredPowerState) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.UNDESIRED_POWER_STATE);
+        }
+        if (!radioStateFromCarrier) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.RADIO_DISABLED_BY_CARRIER);
+        }
+        if (bIsFdnEnabled) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.FDN_ENABLED);
+        }
+
+        if (!getAllowConfig()) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.NOT_ALLOWED);
+        }
+
+        return failureReason == null || !failureReason.isFailed();
+    }
+
+    private boolean isDataAllowedExt(DataAllowFailReason failureReason, String apnType) {
+        int nFailReasonSize = failureReason.getSizeOfFailReason();
+        boolean allow = false;
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.DEFAULT_DATA_UNSELECTED)) {
+            if (ignoreDefaultDataUnselected(apnType)) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.ROAMING_DISABLED)) {
+            if (ignoreDataRoaming(apnType) || getDomesticRoamingEnabled()) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.NOT_ALLOWED)) {
+            if (ignoreDataAllow(apnType)) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (nFailReasonSize == 0) {
+            allow = true;
+        }
+
+        if (VDBG) log("isDataAllowedExt: " + allow);
+
+        return allow;
+    }
+
+    // arg for setupDataOnConnectableApns
+    private enum RetryFailures {
+        // retry failed networks always (the old default)
+        ALWAYS,
+        // retry only when a substantial change has occurred.  Either:
+        // 1) we were restricted by voice/data concurrency and aren't anymore
+        // 2) our apn list has change
+        ONLY_ON_CHANGE
+    };
+
+    private void setupDataOnConnectableApns(String reason) {
+        setupDataOnConnectableApns(reason, RetryFailures.ALWAYS);
+    }
+
+    private void setupDataOnConnectableApns(String reason, RetryFailures retryFailures) {
+        if (VDBG) log("setupDataOnConnectableApns: " + reason);
+
+        if (DBG && !VDBG) {
+            StringBuilder sb = new StringBuilder(120);
+            for (ApnContext apnContext : mPrioritySortedApnContexts) {
+                sb.append(apnContext.getApnType());
+                sb.append(":[state=");
+                sb.append(apnContext.getState());
+                sb.append(",enabled=");
+                sb.append(apnContext.isEnabled());
+                sb.append("] ");
+            }
+            log("setupDataOnConnectableApns: " + reason + " " + sb);
+        }
+
+        ArrayList<ApnContext> aryApnContext = new ArrayList<ApnContext>();
+        String strTempIA = SystemProperties.get("ril.radio.ia-apn");
+
+        for (ApnContext tmpApnContext : mPrioritySortedApnContexts) {
+            if ((TextUtils.equals(strTempIA, "VZWIMS")
+                    && TextUtils.equals(tmpApnContext.getApnType(), PhoneConstants.APN_TYPE_IMS))
+                    || (TextUtils.equals(strTempIA, "VZWINTERNET")
+                    && TextUtils.equals(tmpApnContext.getApnType(),
+                        PhoneConstants.APN_TYPE_DEFAULT))) {
+                aryApnContext.add(0, tmpApnContext);
+            } else {
+                aryApnContext.add(tmpApnContext);
+            }
+        }
+
+        for (ApnContext apnContext : aryApnContext) {
+            ArrayList<ApnSetting> waitingApns = null;
+
+            if (VDBG) logv("setupDataOnConnectableApns: apnContext " + apnContext);
+
+            if (mTelDevController.getModem(0) != null &&
+                    mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false) {
+                    if (PhoneConstants.APN_TYPE_IMS.equals(apnContext.getApnType()) ||
+                            PhoneConstants.APN_TYPE_EMERGENCY.equals(apnContext.getApnType())) {
+                        logd("setupDataOnConnectableApns: ignore apnContext " + apnContext);
+                        continue;
+                    }
+            }
+
+            if (apnContext.getState() == DctConstants.State.SCANNING) {
+                // M: The SCANNING state of ApnContext is meant to be RETRYING state currently,
+                // TODO: Should pay attention to the meaning of SCANNING state.
+                if (mDcFcMgr != null && mDcFcMgr.canIgnoredReason(reason)) {
+                    continue;
+                }
+            }
+
+            if (apnContext.getState() == DctConstants.State.FAILED
+                    || apnContext.getState() == DctConstants.State.SCANNING) {
+                if (retryFailures == RetryFailures.ALWAYS) {
+                    apnContext.releaseDataConnection(reason);
+                } else if (apnContext.isConcurrentVoiceAndDataAllowed() == false &&
+                        mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
+                    // RetryFailures.ONLY_ON_CHANGE - check if voice concurrency has changed
+                    apnContext.releaseDataConnection(reason);
+                } else {
+                    // RetryFailures.ONLY_ON_CHANGE - check if the apns have changed
+                    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+                    ArrayList<ApnSetting> originalApns = apnContext.getWaitingApns();
+                    if (originalApns != null && originalApns.isEmpty() == false) {
+                        waitingApns = buildWaitingApns(apnContext.getApnType(), radioTech);
+                        if (originalApns.size() != waitingApns.size() ||
+                                originalApns.containsAll(waitingApns) == false) {
+                            apnContext.releaseDataConnection(reason);
+                        } else {
+                            continue;
+                        }
+                        continue;
+                    }
+                }
+            }
+            if (TextUtils.equals(apnContext.getApnType(), PhoneConstants.APN_TYPE_DEFAULT)
+                    && TextUtils.equals(strTempIA, "VZWIMS")) {
+                ApnContext apnContextIms = mApnContexts.get(PhoneConstants.APN_TYPE_IMS);
+                if (apnContextIms != null && !apnContextIms.isEnabled()
+                        && !TextUtils.equals(reason, Phone.REASON_DATA_ATTACHED)
+                            && !TextUtils.equals(reason, Phone.REASON_DATA_ENABLED)
+                        && !TextUtils.equals(reason, Phone.REASON_APN_CHANGED)
+                        && !TextUtils.equals(reason, Phone.REASON_VOICE_CALL_ENDED)
+                        && !TextUtils.equals(reason, Phone.REASON_SIM_LOADED)) {
+                    log("setupDataOnConnectableApns: ignore default pdn setup");
+                    continue;
+                }
+            }
+            if (apnContext.isConnectable()) {
+                log("setupDataOnConnectableApns: isConnectable() call trySetupData");
+                apnContext.setReason(reason);
+                trySetupData(apnContext, waitingApns);
+            }
+        }
+    }
+
+    boolean isEmergency() {
+        final boolean result = mPhone.isInEcm() || mPhone.isInEmergencyCall();
+        log("isEmergency: result=" + result);
+        return result;
+    }
+
+    private boolean trySetupData(ApnContext apnContext) {
+        return trySetupData(apnContext, null);
+    }
+
+    private boolean trySetupData(ApnContext apnContext, ArrayList<ApnSetting> waitingApns) {
+        // M: For debug
+        if (DBG) {
+            logi("trySetupData for type:" + apnContext.getApnType() +
+                    " due to " + apnContext.getReason() + ", mIsPsRestricted=" + mIsPsRestricted);
+        }
+        apnContext.requestLog("trySetupData due to " + apnContext.getReason());
+
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            apnContext.setState(DctConstants.State.CONNECTED);
+            mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+            log("trySetupData: X We're on the simulator; assuming connected retValue=true");
+            return true;
+        }
+
+        // Allow SETUP_DATA request for E-APN to be completed during emergency call
+        // and MOBILE DATA On/Off cases as well.
+        boolean isEmergencyApn = apnContext.getApnType().equals(PhoneConstants.APN_TYPE_EMERGENCY);
+        final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+
+        // set to false if apn type is non-metered or if we have a restricted (priveleged)
+        // request for the network.
+        // TODO - may want restricted requests to only apply to carrier-limited data access
+        //        rather than applying to user limited as well.
+        // Exclude DUN for the purposes of the override until we get finer grained
+        // intention in NetworkRequests
+        boolean checkUserDataEnabled =
+                ApnSetting.isMeteredApnType(apnContext.getApnType(), mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming()) &&
+                        /** M: enable MMS and SUPL even if data is disabled */
+                        !isDataAllowedAsOff(apnContext.getApnType()) &&
+                        apnContext.hasNoRestrictedRequests(true /*exclude DUN */);
+
+        DataAllowFailReason failureReason = new DataAllowFailReason();
+
+        // allow data if currently in roaming service, roaming setting disabled
+        // and requested apn type is non-metered for roaming.
+        boolean isDataAllowed = isDataAllowed(failureReason) ||
+                (failureReason.isFailForSingleReason(DataAllowFailReasonType.ROAMING_DISABLED) &&
+                !(ApnSetting.isMeteredApnType(apnContext.getApnType(), mPhone.getContext(),
+                mPhone.getSubId(), mPhone.getServiceState().getDataRoaming()))) ||
+                // M: extend the logics of isDataAllowed()
+                isDataAllowedExt(failureReason, apnContext.getApnType());
+
+        if (apnContext.isConnectable() && (isEmergencyApn ||
+                (isDataAllowed && isDataAllowedForApn(apnContext) &&
+                        mDataEnabledSettings.isDataEnabled(checkUserDataEnabled) && !isEmergency()))) {
+            if (apnContext.getState() == DctConstants.State.FAILED) {
+                String str = "trySetupData: make a FAILED ApnContext IDLE so its reusable";
+                if (DBG) log(str);
+                apnContext.requestLog(str);
+                apnContext.setState(DctConstants.State.IDLE);
+            }
+            int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+            apnContext.setConcurrentVoiceAndDataAllowed(sst.isConcurrentVoiceAndDataAllowed());
+            if (apnContext.getState() == DctConstants.State.IDLE) {
+
+                if (waitingApns == null) {
+                    if (mTelDevController.getModem(0) != null &&
+                            mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false) {
+                        // M: ECC w/o SIM {
+                        if (TextUtils.equals(apnContext.getApnType(),
+                            PhoneConstants.APN_TYPE_EMERGENCY)) {
+                            if (mAllApnSettings == null) {
+                                logi("mAllApnSettings is null, create first and add emergency one");
+                                createAllApnList();
+                            } else if (mAllApnSettings.isEmpty()) {
+                                logi("add mEmergencyApn: " + mEmergencyApn + " to mAllApnSettings");
+                                addEmergencyApnSetting();
+                            }
+                        }
+                        // M: ECC w/o SIM }
+                    }
+                    waitingApns = buildWaitingApns(apnContext.getApnType(), radioTech);
+                }
+                if (waitingApns.isEmpty()) {
+                    notifyNoData(DcFailCause.MISSING_UNKNOWN_APN, apnContext);
+                    notifyOffApnsOfAvailability(apnContext.getReason());
+                    String str = "trySetupData: X No APN found retValue=false";
+                    if (DBG) log(str);
+                    apnContext.requestLog(str);
+                    return false;
+                } else {
+                    apnContext.setWaitingApns(waitingApns);
+                    // M: VDF MMS over ePDG @{
+                    apnContext.setWifiApns(buildWifiApns(apnContext.getApnType()));
+                    /// @}
+                    if (DBG) {
+                        log ("trySetupData: Create from mAllApnSettings : "
+                                    + apnListToString(mAllApnSettings));
+                    }
+                }
+            }
+
+            logd("trySetupData: call setupData, waitingApns : "
+                    + apnListToString(apnContext.getWaitingApns())
+                    + ", wifiApns : " // VDF MMS over ePDG
+                    + apnListToString(apnContext.getWifiApns()));
+
+            boolean retValue = setupData(apnContext, radioTech);
+            notifyOffApnsOfAvailability(apnContext.getReason());
+
+            if (DBG) log("trySetupData: X retValue=" + retValue);
+            return retValue;
+        } else {
+            if (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    && apnContext.isConnectable()) {
+                if (apnContext.getApnType().equals(PhoneConstants.APN_TYPE_MMS)
+                        && TelephonyManager.getDefault().isMultiSimEnabled() && !mAttached.get()) {
+                    log("Wait for attach");
+                    return true;
+                } else {
+                    mPhone.notifyDataConnectionFailed(apnContext.getReason(),
+                            apnContext.getApnType());
+                }
+            }
+            notifyOffApnsOfAvailability(apnContext.getReason());
+
+            StringBuilder str = new StringBuilder();
+
+            str.append("trySetupData failed. apnContext = [type=" + apnContext.getApnType() +
+                    ", mState=" + apnContext.getState() + ", mDataEnabled=" +
+                    apnContext.isEnabled() + ", mDependencyMet=" +
+                    apnContext.getDependencyMet() + "] ");
+
+            if (!apnContext.isConnectable()) {
+                str.append("isConnectable = false. ");
+            }
+            if (!isDataAllowed) {
+                str.append("data not allowed: " + failureReason.getDataAllowFailReason() + ". ");
+            }
+            if (!isDataAllowedForApn(apnContext)) {
+                str.append("isDataAllowedForApn = false. RAT = " +
+                        mPhone.getServiceState().getRilDataRadioTechnology());
+            }
+            if (!mDataEnabledSettings.isDataEnabled(checkUserDataEnabled)) {
+                str.append("isDataEnabled(" + checkUserDataEnabled + ") = false. " +
+                        "isInternalDataEnabled = " + mDataEnabledSettings.isInternalDataEnabled() +
+                        ", userDataEnabled = " + mDataEnabledSettings.isUserDataEnabled() +
+                        ", isPolicyDataEnabled = " + mDataEnabledSettings.isPolicyDataEnabled() +
+                        ", isCarrierDataEnabled = " +
+                        mDataEnabledSettings.isCarrierDataEnabled());
+            }
+            if (isEmergency()) {
+                str.append("emergency = true");
+            }
+
+            // M: For debug
+            if (DBG) logi(str.toString());
+            apnContext.requestLog(str.toString());
+
+            return false;
+        }
+    }
+
+    // Disabled apn's still need avail/unavail notifications - send them out
+    private void notifyOffApnsOfAvailability(String reason) {
+        if (DBG) {
+            DataAllowFailReason failureReason = new DataAllowFailReason();
+            if (!isDataAllowed(failureReason)) {
+                log(failureReason.getDataAllowFailReason());
+            }
+        }
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if ((!mAttached.get() || !apnContext.isReady()) && apnContext.isNeedNotify()) {
+                String apnType = apnContext.getApnType();
+                if (VDBG) {
+                    logv("notifyOffApnOfAvailability type:" + apnType + " reason: " + reason);
+                }
+                mPhone.notifyDataConnection(reason != null ? reason : apnContext.getReason(),
+                                            apnType, PhoneConstants.DataState.DISCONNECTED);
+            } else {
+                if (VDBG) {
+                    logv("notifyOffApnsOfAvailability skipped apn due to attached && isReady " +
+                            apnContext.toString());
+                }
+            }
+        }
+    }
+
+    /**
+     * If tearDown is true, this only tears down a CONNECTED session. Presently,
+     * there is no mechanism for abandoning an CONNECTING session,
+     * but would likely involve cancelling pending async requests or
+     * setting a flag or new state to ignore them when they came in
+     * @param tearDown true if the underlying DataConnection should be
+     * disconnected.
+     * @param reason reason for the clean up.
+     * @return boolean - true if we did cleanup any connections, false if they
+     *                   were already all disconnected.
+     */
+    private boolean cleanUpAllConnections(boolean tearDown, String reason) {
+        if (DBG) log("cleanUpAllConnections: tearDown=" + tearDown + " reason=" + reason);
+        boolean didDisconnect = false;
+        boolean disableMeteredOnly = false;
+
+        // reasons that only metered apn will be torn down
+        if (!TextUtils.isEmpty(reason)) {
+            disableMeteredOnly = reason.equals(Phone.REASON_DATA_SPECIFIC_DISABLED) ||
+                    reason.equals(Phone.REASON_ROAMING_ON) ||
+                    reason.equals(Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
+            // /Ignore IMS PDN deactivation when Radio turned off or PDP Recovery @{
+            disableMeteredOnly =
+                    disableMeteredOnly ||
+                    reason.equals(Phone.REASON_RADIO_TURNED_OFF) ||
+                    reason.equals(Phone.REASON_PDP_RESET);
+            // /@}
+        }
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.isDisconnected() == false) didDisconnect = true;
+            if (disableMeteredOnly) {
+                // Use ApnSetting to decide metered or non-metered.
+                // Tear down all metered data connections.
+                ApnSetting apnSetting = apnContext.getApnSetting();
+                if (apnSetting != null && apnSetting.isMetered(mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming())) {
+                    if (DBG) log("clean up metered ApnContext Type: " + apnContext.getApnType());
+                    apnContext.setReason(reason);
+                    cleanUpConnection(tearDown, apnContext);
+                }
+            } else {
+                if (reason != null && reason.equals(Phone.REASON_ROAMING_ON)
+                        && ignoreDataRoaming(apnContext.getApnType())) {
+                    log("cleanUpConnection: Ignore Data Roaming for apnType = "
+                            + apnContext.getApnType());
+                } else {
+                    // TODO - only do cleanup if not disconnected
+                    apnContext.setReason(reason);
+                    cleanUpConnection(tearDown, apnContext);
+                }
+            }
+        }
+
+        stopNetStatPoll();
+        stopDataStallAlarm();
+
+        // TODO: Do we need mRequestedApnType?
+        mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+        log("cleanUpConnection: mDisconnectPendingCount = " + mDisconnectPendingCount);
+        if (tearDown && mDisconnectPendingCount == 0) {
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+
+        return didDisconnect;
+    }
+
+    /**
+     * Cleanup all connections.
+     *
+     * TODO: Cleanup only a specified connection passed as a parameter.
+     *       Also, make sure when you clean up a conn, if it is last apply
+     *       logic as though it is cleanupAllConnections
+     *
+     * @param cause for the clean up.
+     */
+    private void onCleanUpAllConnections(String cause) {
+        cleanUpAllConnections(true, cause);
+    }
+
+    void sendCleanUpConnection(boolean tearDown, ApnContext apnContext) {
+        if (DBG) log("sendCleanUpConnection: tearDown=" + tearDown + " apnContext=" + apnContext);
+        Message msg = obtainMessage(DctConstants.EVENT_CLEAN_UP_CONNECTION);
+        msg.arg1 = tearDown ? 1 : 0;
+        msg.arg2 = 0;
+        msg.obj = apnContext;
+        sendMessage(msg);
+    }
+
+    private void cleanUpConnection(boolean tearDown, ApnContext apnContext) {
+        if (apnContext == null) {
+            if (DBG) log("cleanUpConnection: apn context is null");
+            return;
+        }
+
+        DcAsyncChannel dcac = apnContext.getDcAc();
+        String str = "cleanUpConnection: tearDown=" + tearDown + " reason=" +
+                apnContext.getReason();
+        if (VDBG) log(str + " apnContext=" + apnContext);
+        apnContext.requestLog(str);
+        if (tearDown) {
+            if (apnContext.isDisconnected()) {
+                // The request is tearDown and but ApnContext is not connected.
+                // If apnContext is not enabled anymore, break the linkage to the DCAC/DC.
+                apnContext.setState(DctConstants.State.IDLE);
+                if (!apnContext.isReady()) {
+                    if (dcac != null) {
+                        str = "cleanUpConnection: teardown, disconnected, !ready";
+                        // M: For debug
+                        if (DBG) logi(str + " apnContext=" + apnContext);
+                        apnContext.requestLog(str);
+                        dcac.tearDown(apnContext, "", null);
+                    }
+                    apnContext.setDataConnectionAc(null);
+                }
+            } else {
+                // Connection is still there. Try to clean up.
+                if (dcac != null) {
+                    if (apnContext.getState() != DctConstants.State.DISCONNECTING) {
+                        boolean disconnectAll = false;
+                        if (PhoneConstants.APN_TYPE_DUN.equals(apnContext.getApnType())) {
+                            // CAF_MSIM is this below condition required.
+                            // if (PhoneConstants.APN_TYPE_DUN.equals(PhoneConstants.APN_TYPE_DEFAULT)) {
+                            if (teardownForDun()) {
+                                if (DBG) {
+                                    log("cleanUpConnection: disconnectAll DUN connection");
+                                }
+                                // we need to tear it down - we brought it up just for dun and
+                                // other people are camped on it and now dun is done.  We need
+                                // to stop using it and let the normal apn list get used to find
+                                // connections for the remaining desired connections
+                                disconnectAll = true;
+                            }
+                        }
+                        final int generation = apnContext.getConnectionGeneration();
+                        str = "cleanUpConnection: tearing down" + (disconnectAll ? " all" : "") +
+                                " using gen#" + generation;
+                        // M: For debug
+                        if (DBG) logi(str + "apnContext=" + apnContext);
+                        apnContext.requestLog(str);
+                        Pair<ApnContext, Integer> pair =
+                                new Pair<ApnContext, Integer>(apnContext, generation);
+                        Message msg = obtainMessage(DctConstants.EVENT_DISCONNECT_DONE, pair);
+                        if (disconnectAll) {
+                            apnContext.getDcAc().tearDownAll(apnContext.getReason(), msg);
+                        } else {
+                            apnContext.getDcAc()
+                                .tearDown(apnContext, apnContext.getReason(), msg);
+                        }
+                        apnContext.setState(DctConstants.State.DISCONNECTING);
+                        mDisconnectPendingCount++;
+                    }
+                } else {
+                    // apn is connected but no reference to dcac.
+                    // Should not be happen, but reset the state in case.
+                    apnContext.setState(DctConstants.State.IDLE);
+                    apnContext.requestLog("cleanUpConnection: connected, bug no DCAC");
+                    if (apnContext.isNeedNotify()) {
+                        mPhone.notifyDataConnection(apnContext.getReason(),
+                                apnContext.getApnType());
+                    }
+                }
+            }
+        } else {
+            boolean needNotify = true;
+            //TODO: remove phone count.
+            int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+            if (apnContext.isDisconnected() && phoneCount > 2) {
+                needNotify = false;
+            }
+            // force clean up the data connection.
+            if (dcac != null) dcac.reqReset();
+            apnContext.setState(DctConstants.State.IDLE);
+            if (apnContext.isNeedNotify() && needNotify) {
+                mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+            }
+            apnContext.setDataConnectionAc(null);
+        }
+
+        // Make sure reconnection alarm is cleaned up if there is no ApnContext
+        // associated to the connection.
+        if (dcac != null) {
+            cancelReconnectAlarm(apnContext);
+        }
+        str = "cleanUpConnection: X tearDown=" + tearDown + " reason=" + apnContext.getReason();
+        if (DBG && apnContext.isNeedNotify()) {
+            log(str + " apnContext=" + apnContext + " dcac=" + apnContext.getDcAc());
+        }
+        apnContext.requestLog(str);
+    }
+
+    ApnSetting fetchDunApn() {
+        if (SystemProperties.getBoolean("net.tethering.noprovisioning", false)) {
+            log("fetchDunApn: net.tethering.noprovisioning=true ret: null");
+            return null;
+        }
+        int bearer = mPhone.getServiceState().getRilDataRadioTechnology();
+        ApnSetting retDunSetting = null;
+        String apnData = Settings.Global.getString(mResolver, Settings.Global.TETHER_DUN_APN);
+        List<ApnSetting> dunSettings = ApnSetting.arrayFromString(apnData);
+        IccRecords r = mIccRecords.get();
+        for (ApnSetting dunSetting : dunSettings) {
+            String operator = (r != null) ? r.getOperatorNumeric() : "";
+            if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer)) continue;
+            if (dunSetting.numeric.equals(operator)) {
+                if (dunSetting.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType,
+                            dunSetting.mvnoMatchData)) {
+                        if (VDBG) {
+                            log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
+                        }
+                        return dunSetting;
+                    }
+                } else if (mMvnoMatched == false) {
+                    if (VDBG) log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
+                    return dunSetting;
+                }
+            }
+        }
+
+        Context c = mPhone.getContext();
+        //String[] apnArrayData = c.getResources().getStringArray(R.array.config_tether_apndata);
+        String[] apnArrayData = getDunApnByMccMnc(c);
+        for (String apn : apnArrayData) {
+            ApnSetting dunSetting = ApnSetting.fromString(apn);
+            if (dunSetting != null) {
+                if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer)) continue;
+                if (dunSetting.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType,
+                            dunSetting.mvnoMatchData)) {
+                        if (VDBG) {
+                            log("fetchDunApn: config_tether_apndata mvno dunSetting=" + dunSetting);
+                        }
+                        return dunSetting;
+                    }
+                } else if (mMvnoMatched == false) {
+                    retDunSetting = dunSetting;
+                }
+            }
+        }
+
+        if (VDBG) log("fetchDunApn: config_tether_apndata dunSetting=" + retDunSetting);
+        return retDunSetting;
+    }
+
+    public boolean hasMatchedTetherApnSetting() {
+        ApnSetting matched = fetchDunApn();
+        log("hasMatchedTetherApnSetting: APN=" + matched);
+        return matched != null;
+    }
+
+    // M: Fixed google DUN only one resource problem
+    private String[] getDunApnByMccMnc(Context context){
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+        int mcc = 0;
+        int mnc = 0;
+        if (operator != null && operator.length() > 3) {
+            mcc = Integer.parseInt(operator.substring(0, 3));
+            mnc = Integer.parseInt(operator.substring(3, operator.length()));
+        }
+
+        Resources sysResource = context.getResources();
+        int sysMcc = sysResource.getConfiguration().mcc;
+        int sysMnc = sysResource.getConfiguration().mnc;
+        logd("fetchDunApn: Resource mccmnc=" + sysMcc + "," + sysMnc +
+                "; OperatorNumeric mccmnc=" + mcc + "," + mnc);
+        Resources resource = null;
+        try {
+            Configuration configuration = new Configuration();
+            configuration = context.getResources().getConfiguration();
+            configuration.mcc = mcc;
+            configuration.mnc = mnc;
+            Context resc = context.createConfigurationContext(configuration);
+            resource = resc.getResources();
+        } catch (Exception e) {
+            e.printStackTrace();
+            loge("getResourcesUsingMccMnc fail");
+        }
+
+        // If single sim, configuration numeric == sysNumeric or resourse
+        if ((TelephonyManager.getDefault().getSimCount() == 1)
+                || (mcc == sysMcc && mnc == sysMnc) || resource == null) {
+            return sysResource.getStringArray(R.array.config_tether_apndata);
+        } else {
+            logd("fetchDunApn: get resource from mcc=" + mcc + ", mnc=" + mnc);
+            return resource.getStringArray(R.array.config_tether_apndata);
+        }
+    }
+
+    /**
+     * Determine if DUN connection is special and we need to teardown on start/stop
+     */
+    private boolean teardownForDun() {
+        // CDMA always needs to do this the profile id is correct
+        final int rilRat = mPhone.getServiceState().getRilDataRadioTechnology();
+        if (ServiceState.isCdma(rilRat)) return true;
+
+        return (fetchDunApn() != null);
+    }
+
+    /**
+     * Cancels the alarm associated with apnContext.
+     *
+     * @param apnContext on which the alarm should be stopped.
+     */
+    private void cancelReconnectAlarm(ApnContext apnContext) {
+        if (apnContext == null) return;
+
+        PendingIntent intent = apnContext.getReconnectIntent();
+
+        if (intent != null) {
+                AlarmManager am =
+                    (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
+                am.cancel(intent);
+                apnContext.setReconnectIntent(null);
+        }
+    }
+
+    /**
+     * @param types comma delimited list of APN types
+     * @return array of APN types
+     */
+    private String[] parseTypes(String types) {
+        String[] result;
+        // If unset, set to DEFAULT.
+        if (types == null || types.equals("")) {
+            result = new String[1];
+            result[0] = PhoneConstants.APN_TYPE_ALL;
+        } else {
+            result = types.split(",");
+        }
+        return result;
+    }
+
+    boolean isPermanentFail(DcFailCause dcFailCause) {
+        // For OP129
+        if (129 == DataConnectionHelper.getInstance().getSbpIdFromNetworkOperator(
+                mPhone.getPhoneId())) {
+            return (dcFailCause.isPermanentFail()
+                    || dcFailCause == DcFailCause.TCM_ESM_TIMER_TIMEOUT)
+                    && (mAttached.get() == false || dcFailCause != DcFailCause.SIGNAL_LOST);
+        }
+        return (dcFailCause.isPermanentFail() &&
+                isPermanentFailByOp(dcFailCause) &&
+                (mAttached.get() == false || dcFailCause != DcFailCause.SIGNAL_LOST));
+    }
+
+    private ApnSetting makeApnSetting(Cursor cursor) {
+        // M: Inactive timer for Sprint
+        int inactiveTimer = 0;
+        try {
+            inactiveTimer = cursor.getInt(
+                    cursor.getColumnIndexOrThrow(Telephony.Carriers.INACTIVE_TIMER));
+        } catch (IllegalArgumentException e) {
+            log("makeApnSetting: parsing inactive timer failed. " + e);
+        }
+
+        String[] types = parseTypes(
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.TYPE)));
+        ApnSetting apn = new ApnSetting(
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.NUMERIC)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.NAME)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.APN)),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.PROXY))),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PORT)),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSC))),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSPROXY))),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSPORT)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.USER)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PASSWORD)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.AUTH_TYPE)),
+                types,
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PROTOCOL)),
+                cursor.getString(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.ROAMING_PROTOCOL)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.CARRIER_ENABLED)) == 1,
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.BEARER)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.BEARER_BITMASK)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.PROFILE_ID)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.MODEM_COGNITIVE)) == 1,
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MAX_CONNS)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.WAIT_TIME)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MAX_CONNS_TIME)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MTU)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MVNO_TYPE)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MVNO_MATCH_DATA)),
+                inactiveTimer);
+        return apn;
+    }
+
+    private ArrayList<ApnSetting> createApnList(Cursor cursor) {
+        ArrayList<ApnSetting> mnoApns = new ArrayList<ApnSetting>();
+        ArrayList<ApnSetting> mvnoApns = new ArrayList<ApnSetting>();
+        IccRecords r = mIccRecords.get();
+
+        if (cursor.moveToFirst()) {
+            do {
+                ApnSetting apn = makeApnSetting(cursor);
+                if (apn == null) {
+                    continue;
+                }
+
+                if (apn.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, apn.mvnoType, apn.mvnoMatchData)) {
+                        mvnoApns.add(apn);
+                    }
+                } else {
+                    mnoApns.add(apn);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        ArrayList<ApnSetting> result;
+        if (mvnoApns.isEmpty()) {
+            result = mnoApns;
+            mMvnoMatched = false;
+        } else {
+            result = mvnoApns;
+            mMvnoMatched = true;
+        }
+        if (DBG) log("createApnList: X result=" + result);
+        return result;
+    }
+
+    private boolean dataConnectionNotInUse(DcAsyncChannel dcac) {
+        if (DBG) log("dataConnectionNotInUse: check if dcac is inuse dcac=" + dcac);
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.getDcAc() == dcac) {
+                if (DBG) log("dataConnectionNotInUse: in use by apnContext=" + apnContext);
+                return false;
+            }
+        }
+        /* To prevent that DataConnection is going to disconnect
+        /* and we still need its information, not to do teardown here
+        // TODO: Fix retry handling so free DataConnections have empty apnlists.
+        // Probably move retry handling into DataConnections and reduce complexity
+        // of DCT.
+        if (DBG) log("dataConnectionNotInUse: tearDownAll");
+        dcac.tearDownAll("No connection", null);
+        */
+        if (DBG) log("dataConnectionNotInUse: not in use return true");
+        return true;
+    }
+
+    private DcAsyncChannel findFreeDataConnection(String reqApnType, ApnSetting apnSetting) {
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            if (dcac.isInactiveSync() && dataConnectionNotInUse(dcac)) {
+                DcAsyncChannel dcacForTeardown = dcac;
+                if (isSupportThrottlingApn()) {
+                    for (String apn : HIGH_THROUGHPUT_APN) {
+                        if (apnSetting != null && apnSetting.canHandleType(apn)
+                                && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                                && !apnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS)
+                                && dcac != null) {
+                            int id = dcac.getDataConnectionIdSync();
+                            if (id < MIN_ID_HIGH_TROUGHPUT || id > MAX_ID_HIGH_TROUGHPUT) {
+                                dcac = null;
+                            }
+                        }
+                    }
+                    if(Arrays.asList(IMS_APN).indexOf(reqApnType) > -1){
+                        if (apnSetting != null && apnSetting.canHandleType(reqApnType)
+                                && dcac != null) {
+                            int id = dcac.getDataConnectionIdSync();
+                            logi("Data connection's interface is: " + id);
+                            if ((id) == MIN_ID_IMS_TROUGHPUT
+                                    && PhoneConstants.APN_TYPE_IMS.equals(reqApnType) ||
+                                    id == (MAX_ID_IMS_TROUGHPUT - 1)
+                                    && PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)) {
+                                logd("findFreeDataConnection: find connection to handle: "
+                                        + reqApnType);
+                            } else {
+                                dcac = null;
+                            }
+                        }
+                    }
+                    if (!PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                            && !PhoneConstants.APN_TYPE_IMS.equals(reqApnType)
+                            && dcac != null) {
+                        int id = dcac.getDataConnectionIdSync();
+                        if (id >= MIN_ID_IMS_TROUGHPUT && id <= MAX_ID_IMS_TROUGHPUT) {
+                            log("findFreeDataConnection: free dcac for non-IMS APN");
+                            dcac = null;
+                        }
+                    }
+                }
+
+                if (dcac != null) {
+                    log("findFreeDataConnection: found free DataConnection="
+                            + " dcac=" + dcac);
+                    return dcac;
+                }
+            }
+        }
+        log("findFreeDataConnection: NO free DataConnection");
+        return null;
+    }
+
+    private boolean setupData(ApnContext apnContext, int radioTech) {
+        if (DBG) log("setupData: apnContext=" + apnContext);
+        apnContext.requestLog("setupData");
+        ApnSetting apnSetting;
+        DcAsyncChannel dcac = null;
+
+        apnSetting = apnContext.getNextApnSetting();
+
+        if (apnSetting == null) {
+            log("setupData: return for no apn found!");
+            return false;
+        }
+
+        int profileId = apnSetting.profileId;
+        // M: VDF MMS over ePDG @{
+        //if (profileId == 0) {
+            profileId = getApnProfileID(apnContext.getApnType());
+        //}
+        /// @}
+        // On CDMA, if we're explicitly asking for DUN, we need have
+        // a dun-profiled connection so we can't share an existing one
+        // On GSM/LTE we can share existing apn connections provided they support
+        // this type.
+        if (apnContext.getApnType() != PhoneConstants.APN_TYPE_DUN ||
+                teardownForDun() == false) {
+            dcac = checkForCompatibleConnectedApnContext(apnContext);
+            if (dcac != null) {
+                // Get the dcacApnSetting for the connection we want to share.
+                ApnSetting dcacApnSetting = dcac.getApnSettingSync();
+                if (dcacApnSetting != null) {
+                    // Setting is good, so use it.
+                    apnSetting = dcacApnSetting;
+                }
+            }
+        }
+        if (dcac == null) {
+            if (isOnlySingleDcAllowed(radioTech)) {
+                if (isHigherPriorityApnContextActive(apnContext)) {
+                    if (DBG) {
+                        log("setupData: Higher priority ApnContext active.  Ignoring call");
+                    }
+                    return false;
+                }
+
+                // Only lower priority calls left.  Disconnect them all in this single PDP case
+                // so that we can bring up the requested higher priority call (once we receive
+                // response for deactivate request for the calls we are about to disconnect
+                if (cleanUpAllConnections(true, Phone.REASON_SINGLE_PDN_ARBITRATION)) {
+                    // If any call actually requested to be disconnected, means we can't
+                    // bring up this connection yet as we need to wait for those data calls
+                    // to be disconnected.
+                    if (DBG) log("setupData: Some calls are disconnecting first.  Wait and retry");
+                    return false;
+                }
+
+                // No other calls are active, so proceed
+                if (DBG) log("setupData: Single pdp. Continue setting up data call.");
+            }
+
+            /** M: throttling/high throughput APN start **/
+            if (!isSupportThrottlingApn() && !isOnlySingleDcAllowed(radioTech)) {
+                boolean isHighThroughputApn = false;
+                for (String apn : HIGH_THROUGHPUT_APN) {
+                    if (apnSetting.canHandleType(apn)) {
+                        isHighThroughputApn = true;
+                        break;
+                    }
+                }
+
+                if (!isHighThroughputApn) {
+                    boolean lastDcAlreadyInUse = false;
+                    for (DcAsyncChannel asyncChannel : mDataConnectionAcHashMap.values()) {
+                        if (asyncChannel.getDataConnectionIdSync() == getPdpConnectionPoolSize()) {
+                            if (asyncChannel.isInactiveSync() &&
+                                    dataConnectionNotInUse(asyncChannel)) {
+                                logd("setupData: find the last dc for non-high-throughput apn, " +
+                                        "execute tearDownAll to the dc");
+                                dcac = asyncChannel;
+                                asyncChannel.tearDownAll("No connection", null);
+                            } else {
+                                log("setupData: the last data connection is already in-use");
+                                lastDcAlreadyInUse = true;
+                            }
+                        }
+                    }
+                    if (dcac == null && !lastDcAlreadyInUse) {
+                        DataConnection conn = DataConnection.makeDataConnection(mPhone,
+                                getPdpConnectionPoolSize(), this, mDcTesterFailBringUpAll, mDcc);
+                        mDataConnections.put(getPdpConnectionPoolSize(), conn);
+                        dcac = new DcAsyncChannel(conn, LOG_TAG);
+                        int status = dcac.fullyConnectSync(mPhone.getContext(),
+                                this, conn.getHandler());
+                        if (status == AsyncChannel.STATUS_SUCCESSFUL) {
+                            logd("setupData: create the last data connection");
+                            mDataConnectionAcHashMap.put(dcac.getDataConnectionIdSync(), dcac);
+                        } else {
+                            loge("setupData: createDataConnection (last) could not connect to dcac="
+                                    + dcac + " status=" + status);
+                        }
+                    }
+                }
+            }
+            /** M: throttling/high throughput APN end start **/
+
+            if (dcac == null) {
+                log("setupData: No ready DataConnection found!");
+                // TODO: When allocating you are mapping type to id. If more than 1 free,
+                // then could findFreeDataConnection get the wrong one??
+                dcac = findFreeDataConnection(apnContext.getApnType(), apnSetting);
+
+            }
+
+            // M: Reuse DCAC if there is remain DCAC for the ApnContext.
+            if (dcac == null) {
+                if (apnContext.getApnType() == PhoneConstants.APN_TYPE_DEFAULT
+                        || apnContext.getApnType() == PhoneConstants.APN_TYPE_MMS) {
+                    DcAsyncChannel prevDcac = apnContext.getDcAc();
+                    // There is already an inactive dcac, try to reuse it.
+                    if (prevDcac != null && prevDcac.isInactiveSync()) {
+                        dcac = prevDcac;
+                        ApnSetting dcacApnSetting = dcac.getApnSettingSync();
+                        log("setupData: reuse previous DCAC: dcacApnSetting = "
+                                + dcacApnSetting);
+                        if (dcacApnSetting != null) {
+                            // Setting is good, so use it.
+                            apnSetting = dcacApnSetting;
+                        }
+                    }
+                }
+            }
+
+            if (dcac == null) {
+                dcac = createDataConnection(apnContext.getApnType(), apnSetting);
+            }
+
+            if (dcac == null) {
+                if (DBG) log("setupData: No free DataConnection and couldn't create one, WEIRD");
+                return false;
+            }
+        }
+        final int generation = apnContext.incAndGetConnectionGeneration();
+        if (DBG) {
+            log("setupData: dcac=" + dcac + " apnSetting=" + apnSetting + " gen#=" + generation);
+        }
+
+        apnContext.setDataConnectionAc(dcac);
+        apnContext.setApnSetting(apnSetting);
+        apnContext.setState(DctConstants.State.CONNECTING);
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+        Message msg = obtainMessage();
+        msg.what = DctConstants.EVENT_DATA_SETUP_COMPLETE;
+        msg.obj = new Pair<ApnContext, Integer>(apnContext, generation);
+        dcac.bringUp(apnContext, profileId, radioTech, msg, generation);
+
+        if (DBG) log("setupData: initing!");
+        return true;
+    }
+
+    // M: IA-change attach APN
+    private void onMdChangedAttachApn(AsyncResult ar) {
+        logv("onMdChangedAttachApn");
+        int[] ints = (int[]) ar.result;
+        int apnId = ints[0];
+
+        if (apnId != APN_CLASS_1 && apnId != APN_CLASS_3) {
+            logw("onMdChangedAttachApn: Not handle APN Class:" + apnId);
+            return;
+        }
+
+        // Save MD requested APN class in property, for cases that DCT object disposed.
+        int phoneId = mPhone.getPhoneId();
+        if (SubscriptionManager.isValidPhoneId(phoneId)) {
+            String iccId = SystemProperties.get(PROPERTY_ICCID[phoneId], "");
+            SystemProperties.set(PROP_APN_CLASS_ICCID + phoneId, iccId);
+            SystemProperties.set(PROP_APN_CLASS + phoneId, String.valueOf(apnId));
+            log("onMdChangedAttachApn, set " + iccId + ", " + apnId);
+        }
+
+        updateMdChangedAttachApn(apnId);
+
+        if (mMdChangedAttachApn != null) {
+            setInitialAttachApn();
+        } else {
+            // Before createAllApnList, the mMdChangedAttachApn will be null
+            // after updateMdChangedAttachApn(), it will be set in
+            // onRecordsLoaded->setInitialAttachApn()
+            logw("onMdChangedAttachApn: MdChangedAttachApn is null, not found APN");
+        }
+    }
+
+    // M: IA-change attach APN
+    private void updateMdChangedAttachApn(int apnId) {
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apnId == APN_CLASS_1 &&
+                        ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IMS)) {
+                    mMdChangedAttachApn = apn;
+                    log("updateMdChangedAttachApn: MdChangedAttachApn=" + apn);
+                    break;
+                } else if (apnId == APN_CLASS_3 &&
+                        ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_DEFAULT)) {
+                    mMdChangedAttachApn = apn;
+                    log("updateMdChangedAttachApn: MdChangedAttachApn=" + apn);
+                    break;
+                }
+            }
+        }
+    }
+
+    // M: IA-change attach APN
+    private boolean isMdChangedAttachApnEnabled() {
+        if (mMdChangedAttachApn != null && mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (TextUtils.equals(mMdChangedAttachApn.apn, apn.apn)) {
+                    log("isMdChangedAttachApnEnabled: " + apn);
+                    return apn.carrierEnabled;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void setInitialAttachApn() {
+        if (hasOperatorIaCapability() == false) {
+            // MD not support OP IA, so need to handle legacy platform logics.
+            log("setInitialApn: MD Not support OP IA, do setInitialAttachApnExt");
+            setInitialAttachApnExt();
+            return;
+        }
+
+        ApnSetting iaApnSetting = null;
+        ApnSetting defaultApnSetting = null;
+        ApnSetting firstApnSetting = null;
+
+        log("setInitialApn: E mPreferredApn=" + mPreferredApn);
+
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            firstApnSetting = mAllApnSettings.get(0);
+            log("setInitialApn: firstApnSetting=" + firstApnSetting);
+
+            // Search for Initial APN setting and the first apn that can handle default
+            for (ApnSetting apn : mAllApnSettings) {
+                // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) &&
+                        apn.carrierEnabled) {
+                    // The Initial Attach APN is highest priority so use it if there is one
+                    log("setInitialApn: iaApnSetting=" + apn);
+                    iaApnSetting = apn;
+                    break;
+                } else if ((defaultApnSetting == null)
+                        && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
+                    // Use the first default apn if no better choice
+                    log("setInitialApn: defaultApnSetting=" + apn);
+                    defaultApnSetting = apn;
+                }
+            }
+        }
+
+        // The priority of apn candidates from highest to lowest is:
+        //   1) APN_TYPE_IA (Initial Attach)
+        //   2) mPreferredApn, i.e. the current preferred apn
+        //   3) The first apn that than handle APN_TYPE_DEFAULT
+        //   4) The first APN we can find.
+
+        ApnSetting initialAttachApnSetting = null;
+        if (iaApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using iaApnSetting");
+            initialAttachApnSetting = iaApnSetting;
+        } else if (mPreferredApn != null) {
+            if (DBG) log("setInitialAttachApn: using mPreferredApn");
+            initialAttachApnSetting = mPreferredApn;
+        } else if (defaultApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using defaultApnSetting");
+            initialAttachApnSetting = defaultApnSetting;
+        } else if (firstApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using firstApnSetting");
+            initialAttachApnSetting = firstApnSetting;
+        }
+
+        if (initialAttachApnSetting == null) {
+            if (DBG) log("setInitialAttachApn: X There in no available apn");
+        } else {
+            if (DBG) log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
+
+            mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn,
+                    initialAttachApnSetting.protocol, initialAttachApnSetting.authType,
+                    initialAttachApnSetting.user, initialAttachApnSetting.password, null);
+        }
+    }
+
+    private void setInitialAttachApnExt() {
+        // M: JPN IA Start
+        boolean needsResumeModem = false;
+        String currentMcc;
+        // M: JPN IA End
+
+        boolean isIaApn = false;
+        ApnSetting previousAttachApn = mInitialAttachApnSetting;
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (operatorNumeric == null || operatorNumeric.length() == 0) {
+            log("setInitialApn: but no operator numeric");
+            return;
+        } else {
+            // M: JPN IA Start
+            synchronized (mNeedsResumeModemLock) {
+                if (mNeedsResumeModem) {
+                    mNeedsResumeModem = false;
+                    needsResumeModem = true;
+                }
+            }
+            currentMcc = operatorNumeric.substring(0, 3);
+            log("setInitialApn: currentMcc = " + currentMcc + ", needsResumeModem = "
+                    + needsResumeModem);
+            // M: JPN IA End
+        }
+
+        String[] dualApnPlmnList = null;
+        if (MTK_DUAL_APN_SUPPORT == true) {
+            dualApnPlmnList = mPhone.getContext().getResources()
+                        .getStringArray(com.mediatek.internal.R.array.dtag_dual_apn_plmn_list);
+        }
+
+        log("setInitialAttachApnExt: current attach Apn [" + mInitialAttachApnSetting + "]");
+
+        ApnSetting iaApnSetting = null;
+        ApnSetting defaultApnSetting = null;
+        ApnSetting firstApnSetting = null;
+        ApnSetting manualChangedAttachApn = null;
+
+        log("setInitialApn: E mPreferredApn=" + mPreferredApn);
+
+        // M: change attach APN for MD changed APN and handover to WIFI
+        if (mIsImsHandover || MTK_IMS_TESTMODE_SUPPORT) {
+            // In those case should change attach APN to  class3 APN (VZWINTERNET)
+            // The use of getClassTypeApn will return the ApnSetting of specify class APN.
+            // Need to make sure the class number is valid (e.g. class1~4) for OP12 APN.
+            manualChangedAttachApn = getClassTypeApn(APN_CLASS_3);
+
+            if (manualChangedAttachApn != null) {
+                log("setInitialAttachApn: manualChangedAttachApn = " + manualChangedAttachApn);
+            }
+        }
+
+        if (mMdChangedAttachApn == null) {
+            // Restore MD requested APN class from property, for cases that DCT object disposed.
+            // Don't restore if card changed.
+            int phoneId = mPhone.getPhoneId();
+            if (SubscriptionManager.isValidPhoneId(phoneId)) {
+                int apnClass = SystemProperties.getInt(PROP_APN_CLASS + phoneId, -1);
+                if (apnClass >= 0) {
+                    String iccId = SystemProperties.get(PROPERTY_ICCID[phoneId], "");
+                    String apnClassIccId = SystemProperties.get(PROP_APN_CLASS_ICCID + phoneId, "");
+                    log("setInitialAttachApn: " + iccId + " , " + apnClassIccId + ", " + apnClass);
+                    if (TextUtils.equals(iccId, apnClassIccId)) {
+                        updateMdChangedAttachApn(apnClass);
+                    } else {
+                        SystemProperties.set(PROP_APN_CLASS_ICCID + phoneId, "");
+                        SystemProperties.set(PROP_APN_CLASS + phoneId, "");
+                    }
+                }
+            }
+        }
+
+        // M: IA-change attach APN
+        // VZW required to detach when disabling VZWIMS. So when VZWIMS is MD changed APN
+        // but disabling VZWIMS, follow AOSP logic to change IA.
+        ApnSetting mdChangedAttachApn = mMdChangedAttachApn;
+        if (mMdChangedAttachApn != null && getClassType(mMdChangedAttachApn) == APN_CLASS_1
+                && !isMdChangedAttachApnEnabled()) {
+            mdChangedAttachApn = null;
+        }
+
+        if (mdChangedAttachApn == null && manualChangedAttachApn == null &&
+                mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            firstApnSetting = mAllApnSettings.get(0);
+            log("setInitialApn: firstApnSetting=" + firstApnSetting);
+
+            // Search for Initial APN setting and the first apn that can handle default
+            for (ApnSetting apn : mAllApnSettings) {
+                // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) &&
+                        apn.carrierEnabled && checkIfDomesticInitialAttachApn(currentMcc)) {
+                    // The Initial Attach APN is highest priority so use it if there is one
+                    log("setInitialApn: iaApnSetting=" + apn);
+                    iaApnSetting = apn;
+                    if (ArrayUtils.contains(PLMN_EMPTY_APN_PCSCF_SET, operatorNumeric)) {
+                        isIaApn = true;
+                    }
+                    break;
+                } else if ((defaultApnSetting == null)
+                        && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
+                    // Use the first default apn if no better choice
+                    log("setInitialApn: defaultApnSetting=" + apn);
+                    defaultApnSetting = apn;
+                }
+            }
+        }
+        // M: end of change attach APN
+
+        // The priority of apn candidates from highest to lowest is:
+        //   1) APN_TYPE_IA (Initial Attach)
+        //   2) mPreferredApn, i.e. the current preferred apn
+        //   3) The first apn that than handle APN_TYPE_DEFAULT
+        //   4) The first APN we can find.
+
+        mInitialAttachApnSetting = null;
+        // M: change attach APN for MD changed APN and handover to WIFI
+        if (manualChangedAttachApn != null) {
+            log("setInitialAttachApn: using manualChangedAttachApn");
+            mInitialAttachApnSetting = manualChangedAttachApn;
+        } else if (mdChangedAttachApn != null) {
+            log("setInitialAttachApn: using mMdChangedAttachApn");
+            mInitialAttachApnSetting = mdChangedAttachApn;
+        } else if (iaApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using iaApnSetting");
+            mInitialAttachApnSetting = iaApnSetting;
+        } else if (mPreferredApn != null) {
+            if (DBG) log("setInitialAttachApn: using mPreferredApn");
+            mInitialAttachApnSetting = mPreferredApn;
+        } else if (defaultApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using defaultApnSetting");
+            mInitialAttachApnSetting = defaultApnSetting;
+        } else if (firstApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using firstApnSetting");
+            mInitialAttachApnSetting = firstApnSetting;
+        }
+
+        if (mInitialAttachApnSetting == null) {
+            if (DBG) log("setInitialAttachApn: X There in no available apn, use empty");
+            IaExtendParam param = new IaExtendParam(operatorNumeric, dualApnPlmnList,
+                    RILConstants.SETUP_DATA_PROTOCOL_IPV4V6);
+            mPhone.mCi.setInitialAttachApn("", RILConstants.SETUP_DATA_PROTOCOL_IPV4V6,
+                    -1, "", "", (Object) param, null);
+        } else {
+            if (DBG) log("setInitialAttachApn: X selected Apn=" + mInitialAttachApnSetting);
+            String iaApn = mInitialAttachApnSetting.apn;
+            if (isIaApn) {
+                if (DBG) log("setInitialAttachApn: ESM flag false, change IA APN to empty");
+                iaApn = "";
+            }
+
+            Message msg = null;
+            // M: JPN IA Start
+            if (needsResumeModem) {
+                if (DBG) log("setInitialAttachApn: DCM IA support");
+                msg = obtainMessage(DctConstants.EVENT_SET_RESUME);
+            }
+            // M: JPN IA End
+            String iaApnProtocol = mInitialAttachApnSetting.protocol;
+            if (isOp18Sim()) {
+                if (mPhone.getServiceState().getDataRoaming()) {
+                    iaApnProtocol = mInitialAttachApnSetting.roamingProtocol;
+                }
+            }
+            IaExtendParam param = new IaExtendParam(operatorNumeric,
+                    mInitialAttachApnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS),
+                    dualApnPlmnList, mInitialAttachApnSetting.roamingProtocol);
+
+            mPhone.mCi.setInitialAttachApn(iaApn, iaApnProtocol,
+                    mInitialAttachApnSetting.authType, mInitialAttachApnSetting.user,
+                    mInitialAttachApnSetting.password, (Object) param, msg);
+        }
+        if (DBG) log("setInitialAttachApn: new attach Apn [" + mInitialAttachApnSetting + "]");
+    }
+
+    /**
+     * Handles changes to the APN database.
+     */
+    private void onApnChanged() {
+        if (mPhone instanceof GsmCdmaPhone) {
+            // The "current" may no longer be valid.  MMS depends on this to send properly. TBD
+            ((GsmCdmaPhone)mPhone).updateCurrentCarrierInProvider();
+        }
+
+        /** M: onApnChanged optimization
+         *  keep current settings before create new apn list
+         */
+        ArrayList<ApnSetting> prevAllApns = mAllApnSettings;
+        ApnSetting prevPreferredApn = mPreferredApn;
+        if (DBG) log("onApnChanged: createAllApnList and set initial attach APN");
+        createAllApnList();
+
+        ApnSetting previousAttachApn = mInitialAttachApnSetting;
+
+        // check if EM force update APN
+        if (SystemProperties.getInt(PROPERTY_FORCE_APN_CHANGE, 0) == 0) {
+            /// M: we will do nothing if the apn is not changed or only the APN name
+            /// is changed. Generally speaking, if PreferredApn and AttachApns are
+            /// both not changed, it will be considered that APN not changed. But if both
+            /// of them are not changed but any of them is null, then we double confirm it
+            /// by compare preAllApns and curAllApns.
+            /// VZW test case [SuppSig][02.17]: change APN name should trigger reattach
+            boolean ignoreName = !VZW_FEATURE;
+
+            final String prevPreferredApnString = (prevPreferredApn == null) ?
+                    "" : prevPreferredApn.toStringIgnoreName(ignoreName);
+            final String curPreferredApnString = (mPreferredApn == null) ?
+                    "" : mPreferredApn.toStringIgnoreName(ignoreName);
+            final String prevAttachApnSettingString = (previousAttachApn == null) ?
+                    "" : previousAttachApn.toStringIgnoreName(ignoreName);
+            final String curAttachApnSettingString = (mInitialAttachApnSetting == null) ?
+                    "" : mInitialAttachApnSetting.toStringIgnoreName(ignoreName);
+            if (TextUtils.equals(prevPreferredApnString, curPreferredApnString)
+                    && isApnSettingExist(previousAttachApn)) {
+                // If preferred APN or preferred initial APN is null, we need to check all APNs.
+                if ((prevPreferredApn == null || previousAttachApn == null) && !TextUtils.equals(
+                        ApnSetting.toStringIgnoreNameForList(prevAllApns, ignoreName),
+                        ApnSetting.toStringIgnoreNameForList(mAllApnSettings, ignoreName))) {
+                    log("onApnChanged: all APN setting changed.");
+                } else {
+                    if (MTK_IMS_SUPPORT) {
+                        if (isIMSApnSettingChanged(prevAllApns, mAllApnSettings)) {
+                            sendOnApnChangedDone(true);
+                            log("onApnChanged: IMS apn setting changed!!");
+                            return;
+                        }
+                    }
+                    log("onApnChanged: not changed");
+                    return;
+                }
+            }
+        }
+
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+        if (operator != null && operator.length() > 0) {
+            // M: update initial attach APN only in the case of valid numeric
+            setInitialAttachApn();
+        } else {
+            log("onApnChanged: but no operator numeric");
+        }
+
+        logd("onApnChanged: cleanUpAllConnections and setup connectable APN");
+        sendOnApnChangedDone(false);
+    }
+
+    private void sendOnApnChangedDone(boolean bImsApnChanged) {
+        Message msg = obtainMessage(DctConstants.EVENT_APN_CHANGED_DONE);
+        msg.arg1 = bImsApnChanged ? 1 : 0;
+        sendMessage(msg);
+    }
+
+    private void onApnChangedDone() {
+        //Fixed:[ALPS01670132] Data iocn cannot shows and data service cannot work
+        //after change default APN some times.
+        DctConstants.State overallState = getOverallState();
+        boolean isDisconnected = (overallState == DctConstants.State.IDLE ||
+                overallState == DctConstants.State.FAILED);
+
+        cleanUpConnectionsOnUpdatedApns(!isDisconnected);
+
+        logd("onApnChanged: phone.getsubId=" + mPhone.getSubId()
+                + "getDefaultDataSubscriptionId()" +
+                + SubscriptionManager.getDefaultDataSubscriptionId());
+        // FIXME: See bug 17426028 maybe no conditional is needed.
+        if (mPhone.getSubId() == SubscriptionManager.getDefaultDataSubscriptionId()) {
+            setupDataOnConnectableApns(Phone.REASON_APN_CHANGED);
+        }
+    }
+
+    /**
+     * @param cid Connection id provided from RIL.
+     * @return DataConnectionAc associated with specified cid.
+     */
+    private DcAsyncChannel findDataConnectionAcByCid(int cid) {
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            if (dcac.getCidSync() == cid) {
+                return dcac;
+            }
+        }
+        return null;
+    }
+
+    // TODO: For multiple Active APNs not exactly sure how to do this.
+    private void gotoIdleAndNotifyDataConnection(String reason) {
+        if (DBG) log("gotoIdleAndNotifyDataConnection: reason=" + reason);
+        notifyDataConnection(reason);
+    }
+
+    /**
+     * "Active" here means ApnContext isEnabled() and not in FAILED state
+     * @param apnContext to compare with
+     * @return true if higher priority active apn found
+     */
+    private boolean isHigherPriorityApnContextActive(ApnContext apnContext) {
+        for (ApnContext otherContext : mPrioritySortedApnContexts) {
+            if (apnContext.getApnType().equalsIgnoreCase(otherContext.getApnType())) return false;
+            if (otherContext.isEnabled() && otherContext.getState() != DctConstants.State.FAILED) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Reports if we support multiple connections or not.
+     * This is a combination of factors, based on carrier and RAT.
+     * @param rilRadioTech the RIL Radio Tech currently in use
+     * @return true if only single DataConnection is allowed
+     */
+    private boolean isOnlySingleDcAllowed(int rilRadioTech) {
+        int[] singleDcRats = mPhone.getContext().getResources().getIntArray(
+                com.android.internal.R.array.config_onlySingleDcAllowed);
+        boolean onlySingleDcAllowed = false;
+
+        // MTK START [ALPS01540105]
+        if (!BSP_PACKAGE && mTelephonyExt != null) {
+            try {
+                onlySingleDcAllowed = mTelephonyExt.isOnlySingleDcAllowed(); // default is false
+                if (onlySingleDcAllowed == true) {
+                    log("isOnlySingleDcAllowed: " + onlySingleDcAllowed);
+                    return true;
+                }
+            } catch (Exception ex) {
+                loge("Fail to create or use plug-in");
+                ex.printStackTrace();
+            }
+        }
+        // MTK END [ALPS01540105]
+
+        if (Build.IS_DEBUGGABLE &&
+                SystemProperties.getBoolean("persist.telephony.test.singleDc", false)) {
+            onlySingleDcAllowed = true;
+        }
+        if (singleDcRats != null) {
+            for (int i=0; i < singleDcRats.length && onlySingleDcAllowed == false; i++) {
+                if (rilRadioTech == singleDcRats[i]) onlySingleDcAllowed = true;
+            }
+        }
+
+        if (DBG) log("isOnlySingleDcAllowed(" + rilRadioTech + "): " + onlySingleDcAllowed);
+        return onlySingleDcAllowed;
+    }
+
+    void sendRestartRadio() {
+        if (DBG)log("sendRestartRadio:");
+        Message msg = obtainMessage(DctConstants.EVENT_RESTART_RADIO);
+        sendMessage(msg);
+    }
+
+    private void restartRadio() {
+        if (DBG) log("restartRadio: ************TURN OFF RADIO**************");
+        cleanUpAllConnections(true, Phone.REASON_RADIO_TURNED_OFF);
+        mPhone.getServiceStateTracker().powerOffRadioSafely(this);
+        /* Note: no need to call setRadioPower(true).  Assuming the desired
+         * radio power state is still ON (as tracked by ServiceStateTracker),
+         * ServiceStateTracker will call setRadioPower when it receives the
+         * RADIO_STATE_CHANGED notification for the power off.  And if the
+         * desired power state has changed in the interim, we don't want to
+         * override it with an unconditional power on.
+         */
+
+        int reset = Integer.parseInt(SystemProperties.get("net.ppp.reset-by-timeout", "0"));
+        SystemProperties.set("net.ppp.reset-by-timeout", String.valueOf(reset + 1));
+    }
+
+    /**
+     * Return true if data connection need to be setup after disconnected due to
+     * reason.
+     *
+     * @param apnContext APN context
+     * @return true if try setup data connection is need for this reason
+     */
+    private boolean retryAfterDisconnected(ApnContext apnContext) {
+        boolean retry = true;
+        String reason = apnContext.getReason();
+
+        if ( Phone.REASON_RADIO_TURNED_OFF.equals(reason) ||
+                Phone.REASON_FDN_ENABLED.equals(reason) ||
+                (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())
+                 && isHigherPriorityApnContextActive(apnContext))) {
+            retry = false;
+        }
+        return retry;
+    }
+
+    private void startAlarmForReconnect(long delay, ApnContext apnContext) {
+        String apnType = apnContext.getApnType();
+
+        Intent intent = new Intent(INTENT_RECONNECT_ALARM + "." + apnType);
+        intent.putExtra(INTENT_RECONNECT_ALARM_EXTRA_REASON, apnContext.getReason());
+        intent.putExtra(INTENT_RECONNECT_ALARM_EXTRA_TYPE, apnType);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+
+        // Get current sub id.
+        //int subId = SubscriptionManager.getDefaultDataSubscriptionId();
+
+        /**
+         * Fix Google default issue.
+         * Enable retry mechanism if the current SIM is non default data SIM.
+         * Ex, SIM1 is default data SIM, use SIM2 to send MMS, if setup data
+         * fail, need enable retry mechanism to setup MMS connect.
+         */
+        int subId = mPhone.getSubId();
+        intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
+
+        if (DBG) {
+            log("startAlarmForReconnect: delay=" + delay + " action=" + intent.getAction()
+                    + " apn=" + apnContext + " subId = " + subId);
+        }
+
+        PendingIntent alarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0,
+                                        intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        apnContext.setReconnectIntent(alarmIntent);
+
+        // Use the exact timer instead of the inexact one to provide better user experience.
+        // In some extreme cases, we saw the retry was delayed for few minutes.
+        // Note that if the stated trigger time is in the past, the alarm will be triggered
+        // immediately.
+        mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + delay, alarmIntent);
+    }
+
+    private void notifyNoData(DcFailCause lastFailCauseCode,
+                              ApnContext apnContext) {
+        if (DBG) log( "notifyNoData: type=" + apnContext.getApnType());
+        if (isPermanentFail(lastFailCauseCode)
+            && (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT))) {
+            mPhone.notifyDataConnectionFailed(apnContext.getReason(), apnContext.getApnType());
+        }
+    }
+
+    public boolean getAutoAttachOnCreation() {
+        return mAutoAttachOnCreation.get();
+    }
+
+    private void onRecordsLoadedOrSubIdChanged() {
+        if (DBG) log("onRecordsLoadedOrSubIdChanged: createAllApnList");
+        mAutoAttachOnCreationConfig = mPhone.getContext().getResources()
+                .getBoolean(com.android.internal.R.bool.config_auto_attach_data_on_creation);
+
+        // M: cc33.
+        if (MTK_CC33_SUPPORT) {
+            mPhone.mCi.setRemoveRestrictEutranMode(true, null);
+        }
+        // M: Sync data setting to modem
+        syncDataSettingsToMd(new int[]{ getDataEnabled() ? 1 : 0,
+                                        getDataOnRoamingEnabled() ? 1 : 0,
+                                        SKIP_DATA_SETTINGS});
+
+        int defaultSubId = SubscriptionController.getInstance().getDefaultDataSubId();
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+        dcHelper.syncDefaultDataSubId(defaultSubId);
+
+        createAllApnList();
+        setInitialAttachApn();
+        if (mPhone.mCi.getRadioState().isOn()) {
+            if (DBG) log("onRecordsLoadedOrSubIdChanged: notifying data availability");
+            notifyOffApnsOfAvailability(Phone.REASON_SIM_LOADED);
+        }
+
+        setupDataOnConnectableApns(Phone.REASON_SIM_LOADED);
+    }
+
+    //MTK START: FDN Support
+    private boolean isFdnEnableSupport() {
+        boolean isFdnEnableSupport = false;
+        if (!BSP_PACKAGE && mGsmDctExt != null) {
+            isFdnEnableSupport = mGsmDctExt.isFdnEnableSupport();
+        }
+        return isFdnEnableSupport;
+    }
+
+    private boolean isFdnEnabled() {
+        boolean bIsFdnEnabled = false;
+        if (isFdnEnableSupport()) {
+            bIsFdnEnabled = getFdnStatus();
+        }
+        return bIsFdnEnabled;
+    }
+
+    private boolean getFdnStatus() {
+        boolean bIsFdnEnabled = false;
+        ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+
+        if (telephonyEx != null) {
+            try {
+                bIsFdnEnabled = telephonyEx.isFdnEnabled(mPhone.getSubId());
+            } catch (RemoteException ex) {
+                ex.printStackTrace();
+            }
+        } else {
+            loge("getFdnStatus get telephonyEx failed!!");
+        }
+
+        return bIsFdnEnabled;
+    }
+
+    private void onFdnChanged() {
+        if (isFdnEnableSupport()) {
+            logd("onFdnChanged");
+            if (getFdnStatus()) {
+                logd("fdn enabled, cleanUpAllConnections!");
+                //cleanUpAllConnections(true, Phone.REASON_FDN_ENABLED);
+                setupDataOnConnectableApns(Phone.REASON_FDN_DISABLED);
+            } else {
+                logd("fdn disabled, setupDataOnConnectableApns!");
+                setupDataOnConnectableApns(Phone.REASON_FDN_DISABLED);
+            }
+        } else {
+            logd("not support fdn enabled, skip onFdnChanged");
+        }
+    }
+    //MTK END: Support FDN
+
+    public void setApnsEnabledByCarrier(boolean enabled) {
+        Message msg = obtainMessage(DctConstants.EVENT_SET_CARRIER_DATA_ENABLED);
+        msg.arg1 = (enabled ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    /**
+     * Action set from carrier signalling broadcast receivers to enable/disable metered apns.
+     */
+    private void onSetCarrierDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            if (enabled != mDataEnabledSettings.isCarrierDataEnabled()) {
+                if (DBG) {
+                    log("carrier Action: set metered apns enabled: " + enabled);
+                }
+
+                // Disable/enable all metered apns
+                mDataEnabledSettings.setCarrierDataEnabled(enabled);
+
+                if (!enabled) {
+                    // Send otasp_sim_unprovisioned so that SuW is able to proceed and notify users
+                    mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED);
+                    // Tear down all metered apns
+                    cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
+                } else {
+                    teardownRestrictedMeteredConnections();
+                    setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED);
+                }
+            }
+        }
+    }
+
+    /**
+     * Action set from carrier signalling broadcast receivers to enable/disable radio
+     */
+    public void carrierActionSetRadioEnabled(boolean enabled) {
+        if (DBG) {
+            log("carrier Action: set radio enabled: " + enabled);
+        }
+        final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+        sst.setRadioPowerFromCarrier(enabled);
+    }
+
+    private void onSimNotReady() {
+        if (DBG) log("onSimNotReady");
+
+        cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY);
+        if (mAllApnSettings != null) {
+            mAllApnSettings.clear();
+        }
+        mAutoAttachOnCreationConfig = false;
+    }
+
+    private void onSetDependencyMet(String apnType, boolean met) {
+        // don't allow users to tweak hipri to work around default dependency not met
+        if (PhoneConstants.APN_TYPE_HIPRI.equals(apnType)) return;
+
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext == null) {
+            loge("onSetDependencyMet: ApnContext not found in onSetDependencyMet(" +
+                    apnType + ", " + met + ")");
+            return;
+        }
+        applyNewState(apnContext, apnContext.isEnabled(), met);
+        if (PhoneConstants.APN_TYPE_DEFAULT.equals(apnType)) {
+            // tie actions on default to similar actions on HIPRI regarding dependencyMet
+            apnContext = mApnContexts.get(PhoneConstants.APN_TYPE_HIPRI);
+            if (apnContext != null) applyNewState(apnContext, apnContext.isEnabled(), met);
+        }
+    }
+
+    public void setPolicyDataEnabled(boolean enabled) {
+        if (DBG) log("setPolicyDataEnabled: " + enabled);
+        Message msg = obtainMessage(DctConstants.CMD_SET_POLICY_DATA_ENABLE);
+        msg.arg1 = (enabled ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    private void onSetPolicyDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            final boolean prevEnabled = getAnyDataEnabled();
+            if (mDataEnabledSettings.isPolicyDataEnabled() != enabled) {
+                mDataEnabledSettings.setPolicyDataEnabled(enabled);
+                // TODO: We should register for DataEnabledSetting's data enabled/disabled event and
+                // handle the rest from there.
+                if (prevEnabled != getAnyDataEnabled()) {
+                    if (!prevEnabled) {
+                        teardownRestrictedMeteredConnections();
+                        onTrySetupData(Phone.REASON_DATA_ENABLED);
+                    } else {
+                        onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                    }
+                }
+            }
+        }
+    }
+
+    private void applyNewState(ApnContext apnContext, boolean enabled, boolean met) {
+        boolean cleanup = false;
+        boolean trySetup = false;
+        String str ="applyNewState(" + apnContext.getApnType() + ", " + enabled +
+                "(" + apnContext.isEnabled() + "), " + met + "(" +
+                apnContext.getDependencyMet() +"))";
+        if (DBG) log(str);
+        apnContext.requestLog(str);
+
+        if (apnContext.isReady()) {
+            cleanup = true;
+            if (enabled && met) {
+                DctConstants.State state = apnContext.getState();
+                switch(state) {
+                    case CONNECTING:
+                    case SCANNING:
+                    case CONNECTED:
+                    case DISCONNECTING:
+                        // We're "READY" and active so just return
+                        if (DBG) log("applyNewState: 'ready' so return");
+                        apnContext.requestLog("applyNewState state=" + state + ", so return");
+                        return;
+                    case IDLE:
+                        // fall through: this is unexpected but if it happens cleanup and try setup
+                    case FAILED:
+                    case RETRYING: {
+                        // We're "READY" but not active so disconnect (cleanup = true) and
+                        // connect (trySetup = true) to be sure we retry the connection.
+                        trySetup = true;
+                        apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                        break;
+                    }
+                }
+            //TODO: Need handle dependency met and data not enable case
+            } else if (!enabled) {
+                cleanup = true;
+                apnContext.setReason(Phone.REASON_DATA_DISABLED);
+/*
+            } else if (met) {
+                apnContext.setReason(Phone.REASON_DATA_DISABLED);
+                // If ConnectivityService has disabled this network, stop trying to bring
+                // it up, but do not tear it down - ConnectivityService will do that
+                // directly by talking with the DataConnection.
+                //
+                // This doesn't apply to DUN, however.  Those connections have special
+                // requirements from carriers and we need stop using them when the dun
+                // request goes away.  This applies to both CDMA and GSM because they both
+                // can declare the DUN APN sharable by default traffic, thus still satisfying
+                // those requests and not torn down organically.
+                if (apnContext.getApnType() == PhoneConstants.APN_TYPE_DUN && teardownForDun()) {
+                    cleanup = true;
+                } else {
+                    cleanup = false;
+                }
+*/
+            } else {
+                apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_UNMET);
+            }
+        } else {
+            if (enabled && met) {
+                if (apnContext.isEnabled()) {
+                    apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_MET);
+                } else {
+                    apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                }
+                if (apnContext.getState() == DctConstants.State.FAILED) {
+                    apnContext.setState(DctConstants.State.IDLE);
+                }
+                trySetup = true;
+            }
+        }
+        apnContext.setEnabled(enabled);
+        apnContext.setDependencyMet(met);
+        if (cleanup) cleanUpConnection(true, apnContext);
+        if (trySetup) {
+            apnContext.resetErrorCodeRetries();
+            trySetupData(apnContext);
+        }
+    }
+
+    private DcAsyncChannel checkForCompatibleConnectedApnContext(ApnContext apnContext) {
+        String apnType = apnContext.getApnType();
+        ApnSetting dunSetting = null;
+
+        if (PhoneConstants.APN_TYPE_DUN.equals(apnType)) {
+            dunSetting = fetchDunApn();
+        }
+        if (DBG) {
+            log("checkForCompatibleConnectedApnContext: apnContext=" + apnContext );
+        }
+
+        DcAsyncChannel potentialDcac = null;
+        ApnContext potentialApnCtx = null;
+        for (ApnContext curApnCtx : mApnContexts.values()) {
+            DcAsyncChannel curDcac = curApnCtx.getDcAc();
+            if (curDcac != null) {
+                ApnSetting apnSetting = curApnCtx.getApnSetting();
+                log("apnSetting: " + apnSetting);
+                if (dunSetting != null) {
+                    if (dunSetting.equals(apnSetting)) {
+                        switch (curApnCtx.getState()) {
+                            case CONNECTED:
+                                if (DBG) {
+                                    log("checkForCompatibleConnectedApnContext:"
+                                            + " found dun conn=" + curDcac
+                                            + " curApnCtx=" + curApnCtx);
+                                }
+                                return curDcac;
+                            case RETRYING:
+                            case CONNECTING:
+                                potentialDcac = curDcac;
+                                potentialApnCtx = curApnCtx;
+                            default:
+                                // Not connected, potential unchanged
+                                break;
+                        }
+                    }
+                } else if (apnSetting != null && apnSetting.canHandleType(apnType)) {
+                    switch (curApnCtx.getState()) {
+                        case CONNECTED:
+                            if (DBG) {
+                                log("checkForCompatibleConnectedApnContext:"
+                                        + " found canHandle conn=" + curDcac
+                                        + " curApnCtx=" + curApnCtx);
+                            }
+                            return curDcac;
+                        case RETRYING:
+                        case CONNECTING:
+                        case SCANNING:
+                            potentialDcac = curDcac;
+                            potentialApnCtx = curApnCtx;
+                        default:
+                            // Not connected, potential unchanged
+                            break;
+                    }
+                }
+            } else {
+                if (VDBG) {
+                    log("checkForCompatibleConnectedApnContext: not conn curApnCtx=" + curApnCtx);
+                }
+            }
+        }
+        if (potentialDcac != null) {
+            if (DBG) {
+                log("checkForCompatibleConnectedApnContext: found potential conn=" + potentialDcac
+                        + " curApnCtx=" + potentialApnCtx);
+            }
+            return potentialDcac;
+        }
+
+        if (DBG) log("checkForCompatibleConnectedApnContext: NO conn apnContext=" + apnContext);
+        return null;
+    }
+
+    public void setEnabled(int id, boolean enable) {
+        Message msg = obtainMessage(DctConstants.EVENT_ENABLE_NEW_APN);
+        msg.arg1 = id;
+        msg.arg2 = (enable ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    private void onEnableApn(int apnId, int enabled) {
+        ApnContext apnContext = mApnContextsById.get(apnId);
+        if (apnContext == null) {
+            loge("onEnableApn(" + apnId + ", " + enabled + "): NO ApnContext");
+            return;
+        }
+        // TODO change our retry manager to use the appropriate numbers for the new APN
+        if (DBG) log("onEnableApn: apnContext=" + apnContext + " call applyNewState");
+        applyNewState(apnContext, enabled == DctConstants.ENABLED, apnContext.getDependencyMet());
+    }
+
+    // TODO: We shouldnt need this.
+    private boolean onTrySetupData(String reason) {
+        if (DBG) log("onTrySetupData: reason=" + reason);
+        setupDataOnConnectableApns(reason);
+        return true;
+    }
+
+    private boolean onTrySetupData(ApnContext apnContext) {
+        if (DBG) log("onTrySetupData: apnContext=" + apnContext);
+        return trySetupData(apnContext);
+    }
+
+    /**
+     * Return current {@link android.provider.Settings.Global#MOBILE_DATA} value.
+     */
+    //TODO: Merge this into DataSettings. And probably should rename to getUserDataEnabled().
+    public boolean getDataEnabled() {
+        final int device_provisioned =
+                Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONED, 0);
+
+        boolean retVal = "true".equalsIgnoreCase(SystemProperties.get(
+                "ro.com.android.mobiledata", "true"));
+        if (TelephonyManager.getDefault().getSimCount() == 1) {
+            retVal = Settings.Global.getInt(mResolver, Settings.Global.MOBILE_DATA,
+                    retVal ? 1 : 0) != 0;
+        } else {
+            int phoneSubId = mPhone.getSubId();
+            try {
+                retVal = TelephonyManager.getIntWithSubId(mResolver,
+                        Settings.Global.MOBILE_DATA, phoneSubId) != 0;
+            } catch (SettingNotFoundException e) {
+                // use existing retVal
+            }
+        }
+        logd("getDataEnabled: retVal=" + retVal);
+        if (device_provisioned == 0) {
+            // device is still getting provisioned - use whatever setting they
+            // want during this process
+            //
+            // use the normal data_enabled setting (retVal, determined above)
+            // as the default if nothing else is set
+            final String prov_property = SystemProperties.get("ro.com.android.prov_mobiledata",
+                  retVal ? "true" : "false");
+            retVal = "true".equalsIgnoreCase(prov_property);
+
+            final int prov_mobile_data = Settings.Global.getInt(mResolver,
+                    Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED,
+                    retVal ? 1 : 0);
+            retVal = prov_mobile_data != 0;
+            log("getDataEnabled during provisioning retVal=" + retVal + " - (" + prov_property +
+                    ", " + prov_mobile_data + ")");
+        }
+
+        return retVal;
+    }
+
+    /**
+     * Modify {@link android.provider.Settings.Global#DATA_ROAMING} value.
+     */
+    public void setDataOnRoamingEnabled(boolean enabled) {
+        final int phoneSubId = mPhone.getSubId();
+        if (getDataOnRoamingEnabled() != enabled) {
+            int roaming = enabled ? 1 : 0;
+
+            // For single SIM phones, this is a per phone property.
+            if (TelephonyManager.getDefault().getSimCount() == 1) {
+                Settings.Global.putInt(mResolver, Settings.Global.DATA_ROAMING, roaming);
+            } else {
+                Settings.Global.putInt(mResolver, Settings.Global.DATA_ROAMING +
+                         phoneSubId, roaming);
+            }
+
+            // M: Sync data setting to modem
+            syncDataSettingsToMd(new int[] { getDataEnabled() ? 1 : 0,
+                                             enabled ? 1 : 0,
+                                             SKIP_DATA_SETTINGS});
+
+            mSubscriptionManager.setDataRoaming(roaming, phoneSubId);
+            // will trigger handleDataOnRoamingChange() through observer
+            if (DBG) {
+               log("setDataOnRoamingEnabled: set phoneSubId=" + phoneSubId
+                       + " isRoaming=" + enabled);
+            }
+        } else {
+            if (DBG) {
+                log("setDataOnRoamingEnabled: unchanged phoneSubId=" + phoneSubId
+                        + " isRoaming=" + enabled);
+             }
+        }
+    }
+
+    /**
+     * Return current {@link android.provider.Settings.Global#DATA_ROAMING} value.
+     */
+    public boolean getDataOnRoamingEnabled() {
+        boolean isDataRoamingEnabled = "true".equalsIgnoreCase(SystemProperties.get(
+                "ro.com.android.dataroaming", "false"));
+        final int phoneSubId = mPhone.getSubId();
+
+        try {
+            // For single SIM phones, this is a per phone property.
+            if (TelephonyManager.getDefault().getSimCount() == 1) {
+                isDataRoamingEnabled = Settings.Global.getInt(mResolver,
+                        Settings.Global.DATA_ROAMING, isDataRoamingEnabled ? 1 : 0) != 0;
+            } else {
+                isDataRoamingEnabled = TelephonyManager.getIntWithSubId(mResolver,
+                        Settings.Global.DATA_ROAMING, phoneSubId) != 0;
+            }
+        } catch (SettingNotFoundException snfe) {
+            if (DBG) log("getDataOnRoamingEnabled: SettingNofFoundException snfe=" + snfe);
+        }
+        if (VDBG) {
+            logTel("getDataOnRoamingEnabled: phoneSubId=" + phoneSubId +
+                    " isDataRoamingEnabled=" + isDataRoamingEnabled);
+        }
+        return isDataRoamingEnabled;
+    }
+
+    private boolean ignoreDataRoaming(String apnType) {
+        logd("ignoreDataRoaming: apnType = " + apnType);
+        boolean ignoreDataRoaming = false;
+        try {
+            ignoreDataRoaming = mTelephonyExt.ignoreDataRoaming(apnType);
+        } catch (Exception e) {
+            loge("get ignoreDataRoaming fail!");
+            e.printStackTrace();
+        }
+        if (ignoreDataRoaming) {
+            logd("ignoreDataRoaming: " + ignoreDataRoaming + ", apnType = " + apnType);
+        }
+        return ignoreDataRoaming;
+    }
+
+    private boolean getDomesticRoamingEnabled() {
+        boolean isDomesticRoaming = isDomesticRoaming();
+        // No matter whether register on domestic roaming, check if is allowed by specific SIM.
+        boolean bDomesticRoamingEnabled = getDomesticRoamingEnabledBySim();
+
+        if (DBG) {
+            log("getDomesticRoamingEnabled: isDomesticRoaming=" + isDomesticRoaming
+                    + ", bDomesticRoamingEnabled=" + bDomesticRoamingEnabled);
+        }
+        return (isDomesticRoaming && bDomesticRoamingEnabled);
+    }
+
+    private boolean isDomesticRoaming() {
+        return mPhone.getServiceState().getDataRoamingType() ==
+                ServiceState.ROAMING_TYPE_DOMESTIC;
+    }
+
+    private boolean isInternationalRoaming() {
+        return mPhone.getServiceState().getDataRoamingType() ==
+                ServiceState.ROAMING_TYPE_INTERNATIONAL;
+    }
+
+    private boolean ignoreDataAllow(String apnType) {
+        boolean ignoreDataAllow = false;
+        if (PhoneConstants.APN_TYPE_IMS.equals(apnType)) {
+            ignoreDataAllow = true;
+        }
+
+        return ignoreDataAllow;
+    }
+
+    private boolean ignoreDefaultDataUnselected(String apnType) {
+        boolean ignoreDefaultDataUnselected = false;
+
+        try {
+            ignoreDefaultDataUnselected = mTelephonyExt.ignoreDefaultDataUnselected(apnType);
+        } catch (Exception e) {
+            loge("get ignoreDefaultDataUnselected fail!");
+            e.printStackTrace();
+        }
+
+        // M: Vsim
+        if (!ignoreDefaultDataUnselected
+                && TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)
+                && isVsimActive(mPhone.getPhoneId())) {
+            logd("Vsim is enabled, set ignoreDefaultDataUnselected as true");
+            ignoreDefaultDataUnselected = true;
+        }
+
+        if (ignoreDefaultDataUnselected) {
+            logd("ignoreDefaultDataUnselected: " + ignoreDefaultDataUnselected
+                    + ", apnType = " + apnType);
+        }
+        return ignoreDefaultDataUnselected;
+    }
+
+    private void onRoamingOff() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+
+        logd("onRoamingOff bDataOnRoamingEnabled=" + bDataOnRoamingEnabled);
+
+        if (!mDataEnabledSettings.isUserDataEnabled()) return;
+        if (false == hasOperatorIaCapability()) {
+            if (isOp18Sim()) {
+                setInitialAttachApn();
+            }
+        }
+        if (!bDataOnRoamingEnabled) {
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
+        } else {
+            notifyDataConnection(Phone.REASON_ROAMING_OFF);
+        }
+    }
+
+    private void onRoamingOn() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+        boolean bDomesticRoamingEnabled = getDomesticRoamingEnabled();
+
+        if (DBG) {
+            log("onRoamingOn bDataOnRoamingEnabled=" + bDataOnRoamingEnabled);
+        }
+
+        if (!mDataEnabledSettings.isUserDataEnabled()) {
+            if (getDomesticRoamingEnabledBySim()) {
+                if (isDomesticRoaming()) {
+                    if (DBG) log("data not enabled by specific SIM");
+                    return;
+                }
+            } else {
+                if (DBG) log("data not enabled by user");
+                return;
+            }
+        }
+        // Check if the device is actually data roaming
+        if (!mPhone.getServiceState().getDataRoaming()) {
+            if (DBG) log("device is not roaming. ignored the request.");
+            return;
+        }
+        if (false == hasOperatorIaCapability()) {
+            if (isOp18Sim()) {
+                setInitialAttachApn();
+            }
+        }
+        if (bDataOnRoamingEnabled || bDomesticRoamingEnabled) {
+            if (DBG) log("onRoamingOn: setup data on roaming");
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
+            notifyDataConnection(Phone.REASON_ROAMING_ON);
+        } else {
+            if (DBG) log("onRoamingOn: Tear down data connection on roaming.");
+            cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+        }
+    }
+
+    private void onRoamingTypeChanged() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+        boolean bUserDataEnabled = mDataEnabledSettings.isUserDataEnabled();
+        int roamingType = mPhone.getServiceState().getDataRoamingType();
+
+        if (DBG) {
+            log("onRoamingTypeChanged: bDataOnRoamingEnabled=" + bDataOnRoamingEnabled
+                    + ", bUserDataEnabled=" + bUserDataEnabled
+                    + ", roamingType=" + roamingType);
+        }
+
+        if (!getDomesticRoamingEnabledBySim()) {
+            if (DBG) log("onRoamingTypeChanged: is not specific SIM. ignored the request.");
+            return;
+        }
+
+        // Check if the device is actually data roaming
+        if (!mPhone.getServiceState().getDataRoaming()) {
+            if (DBG) log("onRoamingTypeChanged: device is not roaming. ignored the request.");
+            return;
+        }
+
+        // Only the roaming types changed between DOMESTIC and INTERNATIONAL is expected here,
+        // if NOT, there might be something wrong with NW, suggest to discuss with them.
+        if ((roamingType == ServiceState.ROAMING_TYPE_DOMESTIC && bUserDataEnabled) ||
+                (roamingType == ServiceState.ROAMING_TYPE_INTERNATIONAL && bDataOnRoamingEnabled)) {
+            if (DBG) log("onRoamingTypeChanged: setup data on roaming");
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
+            notifyDataConnection(Phone.REASON_ROAMING_ON);
+        } else {
+            if (DBG) log("onRoamingTypeChanged: Tear down data connection on roaming.");
+            cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+        }
+    }
+
+    private void onRadioAvailable() {
+        if (DBG) log("onRadioAvailable");
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            // setState(DctConstants.State.CONNECTED);
+            notifyDataConnection(null);
+
+            log("onRadioAvailable: We're on the simulator; assuming data is connected");
+        }
+
+        IccRecords r = mIccRecords.get();
+        if (r != null && r.getRecordsLoaded()) {
+            notifyOffApnsOfAvailability(null);
+        }
+
+        if (getOverallState() != DctConstants.State.IDLE) {
+            cleanUpConnection(true, null);
+        }
+    }
+
+    private void onRadioOffOrNotAvailable() {
+        // Make sure our reconnect delay starts at the initial value
+        // next time the radio comes on
+
+        mReregisterOnReconnectFailure = false;
+
+        // M: To avoid trying setup data call before PS attach.
+        mAutoAttachOnCreation.set(false);
+        // Clear MD changed APN
+        mMdChangedAttachApn = null;
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            log("We're on the simulator; assuming radio off is meaningless");
+            notifyOffApnsOfAvailability(null);
+        } else {
+            logd("onRadioOffOrNotAvailable: is off and clean up all connections");
+            cleanUpAllConnections(false, Phone.REASON_RADIO_TURNED_OFF);
+        }
+        //ALPS01769896: We don't notify off twice.
+        //notifyOffApnsOfAvailability(null);
+    }
+
+    private void completeConnection(ApnContext apnContext) {
+
+        if (DBG) log("completeConnection: successful, notify the world apnContext=" + apnContext);
+
+        if (mIsProvisioning && !TextUtils.isEmpty(mProvisioningUrl)) {
+            if (DBG) {
+                log("completeConnection: MOBILE_PROVISIONING_ACTION url="
+                        + mProvisioningUrl);
+            }
+            Intent newIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,
+                    Intent.CATEGORY_APP_BROWSER);
+            newIntent.setData(Uri.parse(mProvisioningUrl));
+            newIntent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT |
+                    Intent.FLAG_ACTIVITY_NEW_TASK);
+            try {
+                mPhone.getContext().startActivity(newIntent);
+            } catch (ActivityNotFoundException e) {
+                loge("completeConnection: startActivityAsUser failed" + e);
+            }
+        }
+        mIsProvisioning = false;
+        mProvisioningUrl = null;
+        if (mProvisioningSpinner != null) {
+            sendMessage(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER,
+                    mProvisioningSpinner));
+        }
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+        startNetStatPoll();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+    }
+
+    /**
+     * A SETUP (aka bringUp) has completed, possibly with an error. If
+     * there is an error this method will call {@link #onDataSetupCompleteError}.
+     */
+    private void onDataSetupComplete(AsyncResult ar) {
+
+        DcFailCause cause = DcFailCause.UNKNOWN;
+        boolean handleError = false;
+        ApnContext apnContext = getValidApnContext(ar, "onDataSetupComplete");
+
+        if (apnContext == null) return;
+
+        if (ar.exception == null) {
+            DcAsyncChannel dcac = apnContext.getDcAc();
+
+            if (RADIO_TESTS) {
+                // Note: To change radio.test.onDSC.null.dcac from command line you need to
+                // adb root and adb remount and from the command line you can only change the
+                // value to 1 once. To change it a second time you can reboot or execute
+                // adb shell stop and then adb shell start. The command line to set the value is:
+                // adb shell sqlite3 /data/data/com.android.providers.settings/databases/settings.db "insert into system (name,value) values ('radio.test.onDSC.null.dcac', '1');"
+                ContentResolver cr = mPhone.getContext().getContentResolver();
+                String radioTestProperty = "radio.test.onDSC.null.dcac";
+                if (Settings.System.getInt(cr, radioTestProperty, 0) == 1) {
+                    log("onDataSetupComplete: " + radioTestProperty +
+                            " is true, set dcac to null and reset property to false");
+                    dcac = null;
+                    Settings.System.putInt(cr, radioTestProperty, 0);
+                    log("onDataSetupComplete: " + radioTestProperty + "=" +
+                            Settings.System.getInt(mPhone.getContext().getContentResolver(),
+                                    radioTestProperty, -1));
+                }
+            }
+            if (dcac == null) {
+                log("onDataSetupComplete: no connection to DC, handle as error");
+                cause = DcFailCause.CONNECTION_TO_DATACONNECTIONAC_BROKEN;
+                // M: Bug fixed.
+                apnContext.setState(DctConstants.State.FAILED);
+                handleError = true;
+            } else {
+                ApnSetting apn = apnContext.getApnSetting();
+                if (DBG) {
+                    log("onDataSetupComplete: success apn=" + (apn == null ? "unknown" : apn.apn));
+                }
+                if (apn != null && apn.proxy != null && apn.proxy.length() != 0) {
+                    try {
+                        String port = apn.port;
+                        if (TextUtils.isEmpty(port)) port = "8080";
+                        ProxyInfo proxy = new ProxyInfo(apn.proxy,
+                                Integer.parseInt(port), null);
+                        dcac.setLinkPropertiesHttpProxySync(proxy);
+                    } catch (NumberFormatException e) {
+                        loge("onDataSetupComplete: NumberFormatException making ProxyProperties (" +
+                                apn.port + "): " + e);
+                    }
+                }
+
+                // everything is setup
+                if(TextUtils.equals(apnContext.getApnType(),PhoneConstants.APN_TYPE_DEFAULT)) {
+                    try {
+                        SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "true");
+                    } catch (RuntimeException ex) {
+                        log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to true");
+                    }
+                    if (mCanSetPreferApn && mPreferredApn == null) {
+                        if (DBG) log("onDataSetupComplete: PREFERRED APN is null");
+                        mPreferredApn = apn;
+                        if (mPreferredApn != null) {
+                            setPreferredApn(mPreferredApn.id);
+                        }
+                    }
+                } else {
+                    try {
+                        SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
+                    } catch (RuntimeException ex) {
+                        loge("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
+                    }
+                }
+
+                // A connection is setup
+                apnContext.setState(DctConstants.State.CONNECTED);
+
+                boolean isProvApn = apnContext.isProvisioningApn();
+                final ConnectivityManager cm = ConnectivityManager.from(mPhone.getContext());
+                if (mProvisionBroadcastReceiver != null) {
+                    mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
+                    mProvisionBroadcastReceiver = null;
+                }
+                if ((!isProvApn) || mIsProvisioning) {
+                    // Hide any provisioning notification.
+                    cm.setProvisioningNotificationVisible(false, ConnectivityManager.TYPE_MOBILE,
+                            mProvisionActionName);
+                    // Complete the connection normally notifying the world we're connected.
+                    // We do this if this isn't a special provisioning apn or if we've been
+                    // told its time to provision.
+                    completeConnection(apnContext);
+                } else {
+                    // This is a provisioning APN that we're reporting as connected. Later
+                    // when the user desires to upgrade this to a "default" connection,
+                    // mIsProvisioning == true, we'll go through the code path above.
+                    // mIsProvisioning becomes true when CMD_ENABLE_MOBILE_PROVISIONING
+                    // is sent to the DCT.
+                    if (DBG) {
+                        log("onDataSetupComplete: successful, BUT send connected to prov apn as"
+                                + " mIsProvisioning:" + mIsProvisioning + " == false"
+                                + " && (isProvisioningApn:" + isProvApn + " == true");
+                    }
+
+                    // While radio is up, grab provisioning URL.  The URL contains ICCID which
+                    // disappears when radio is off.
+                    mProvisionBroadcastReceiver = new ProvisionNotificationBroadcastReceiver(
+                            cm.getMobileProvisioningUrl(),
+                            TelephonyManager.getDefault().getNetworkOperatorName());
+                    mPhone.getContext().registerReceiver(mProvisionBroadcastReceiver,
+                            new IntentFilter(mProvisionActionName));
+                    // Put up user notification that sign-in is required.
+                    cm.setProvisioningNotificationVisible(true, ConnectivityManager.TYPE_MOBILE,
+                            mProvisionActionName);
+                    // Turn off radio to save battery and avoid wasting carrier resources.
+                    // The network isn't usable and network validation will just fail anyhow.
+                    setRadio(false);
+                }
+                if (DBG) {
+                    log("onDataSetupComplete: SETUP complete type=" + apnContext.getApnType()
+                        + ", reason:" + apnContext.getReason());
+                }
+                if (Build.IS_DEBUGGABLE) {
+                    // adb shell setprop persist.radio.test.pco [pco_val]
+                    String radioTestProperty = "persist.radio.test.pco";
+                    int pcoVal = SystemProperties.getInt(radioTestProperty, -1);
+                    if (pcoVal != -1) {
+                        log("PCO testing: read pco value from persist.radio.test.pco " + pcoVal);
+                        final byte[] value = new byte[1];
+                        value[0] = (byte) pcoVal;
+                        final Intent intent =
+                                new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
+                        intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, "default");
+                        intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, "IPV4V6");
+                        intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, 0xFF00);
+                        intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, value);
+                        mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+                    }
+                }
+            }
+        } else {
+            cause = (DcFailCause) (ar.result);
+            if (DBG) {
+                ApnSetting apn = apnContext.getApnSetting();
+                log(String.format("onDataSetupComplete: error apn=%s cause=%s",
+                        (apn == null ? "unknown" : apn.apn), cause));
+            }
+            if (cause.isEventLoggable()) {
+                // Log this failure to the Event Logs.
+                int cid = getCellLocationId();
+                EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,
+                        cause.ordinal(), cid, TelephonyManager.getDefault().getNetworkType());
+            }
+            ApnSetting apn = apnContext.getApnSetting();
+            mPhone.notifyPreciseDataConnectionFailed(apnContext.getReason(),
+                    apnContext.getApnType(), apn != null ? apn.apn : "unknown", cause.toString());
+
+            // Compose broadcast intent send to the specific carrier signaling receivers
+            Intent intent = new Intent(TelephonyIntents
+                    .ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED);
+            intent.putExtra(TelephonyIntents.EXTRA_ERROR_CODE_KEY, cause.getErrorCode());
+            intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnContext.getApnType());
+            mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+
+            if (cause.isRestartRadioFail() || apnContext.restartOnError(cause.getErrorCode())) {
+                if (DBG) log("Modem restarted.");
+                sendRestartRadio();
+            }
+
+            // If the data call failure cause is a permanent failure, we mark the APN as permanent
+            // failed.
+            if (isPermanentFail(cause) ||
+                    (mGsmDctExt != null && mGsmDctExt.isIgnoredCause(cause))) {
+                log("cause = " + cause + ", mark apn as permanent failed. apn = " + apn);
+                apnContext.markApnPermanentFailed(apn);
+            }
+
+            handleError = true;
+        }
+
+        if (handleError) {
+            onDataSetupCompleteError(ar);
+        }
+
+        /* If flag is set to false after SETUP_DATA_CALL is invoked, we need
+         * to clean data connections.
+         */
+        if (!mDataEnabledSettings.isInternalDataEnabled()) {
+            cleanUpAllConnections(Phone.REASON_DATA_DISABLED);
+        }
+
+    }
+
+    /**
+     * check for obsolete messages.  Return ApnContext if valid, null if not
+     */
+    private ApnContext getValidApnContext(AsyncResult ar, String logString) {
+        if (ar != null && ar.userObj instanceof Pair) {
+            Pair<ApnContext, Integer>pair = (Pair<ApnContext, Integer>)ar.userObj;
+            ApnContext apnContext = pair.first;
+            if (apnContext != null) {
+                final int generation = apnContext.getConnectionGeneration();
+                if (DBG) {
+                    log("getValidApnContext (" + logString + ") on " + apnContext + " got " +
+                            generation + " vs " + pair.second);
+                }
+                if (generation == pair.second) {
+                    return apnContext;
+                } else {
+                    log("ignoring obsolete " + logString);
+                    return null;
+                }
+            }
+        }
+        throw new RuntimeException(logString + ": No apnContext");
+    }
+
+    /**
+     * Error has occurred during the SETUP {aka bringUP} request and the DCT
+     * should either try the next waiting APN or start over from the
+     * beginning if the list is empty. Between each SETUP request there will
+     * be a delay defined by {@link #getApnDelay()}.
+     */
+    private void onDataSetupCompleteError(AsyncResult ar) {
+
+        ApnContext apnContext = getValidApnContext(ar, "onDataSetupCompleteError");
+
+        if (apnContext == null) return;
+
+        long delay = apnContext.getDelayForNextApn(mFailFast);
+
+        // Check if we need to retry or not.
+        if (delay >= 0) {
+            if (DBG) log("onDataSetupCompleteError: Try next APN. delay = " + delay);
+            apnContext.setState(DctConstants.State.SCANNING);
+            // Wait a bit before trying the next APN, so that
+            // we're not tying up the RIL command channel
+            startAlarmForReconnect(delay, apnContext);
+        } else {
+            // If we are not going to retry any APN, set this APN context to failed state.
+            // This would be the final state of a data connection.
+            apnContext.setState(DctConstants.State.FAILED);
+            mPhone.notifyDataConnection(Phone.REASON_APN_FAILED, apnContext.getApnType());
+            apnContext.setDataConnectionAc(null);
+            log("onDataSetupCompleteError: Stop retrying APNs.");
+        }
+    }
+
+    /**
+     * Called when EVENT_REDIRECTION_DETECTED is received.
+     */
+    private void onDataConnectionRedirected(String redirectUrl) {
+        if (!TextUtils.isEmpty(redirectUrl)) {
+            Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_REDIRECTED);
+            intent.putExtra(TelephonyIntents.EXTRA_REDIRECTION_URL_KEY, redirectUrl);
+            if(mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent)) {
+                log("Notify carrier signal receivers with redirectUrl: " + redirectUrl);
+            }
+        }
+    }
+
+    /**
+     * Called when EVENT_DISCONNECT_DONE is received.
+     */
+    private void onDisconnectDone(AsyncResult ar) {
+        ApnContext apnContext = getValidApnContext(ar, "onDisconnectDone");
+        if (apnContext == null) return;
+
+        if(DBG) log("onDisconnectDone: EVENT_DISCONNECT_DONE apnContext=" + apnContext);
+        apnContext.setState(DctConstants.State.IDLE);
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+        // if all data connection are gone, check whether Airplane mode request was
+        // pending. (ignore only IMS or EIMS is connected)
+        if (isDisconnected() || isOnlyIMSorEIMSPdnConnected()) {
+            if (mPhone.getServiceStateTracker().processPendingRadioPowerOffAfterDataOff()) {
+                if (DBG) log("onDisconnectDone: radio will be turned off, no retries");
+                // Radio will be turned off. No need to retry data setup
+                apnContext.setApnSetting(null);
+                apnContext.setDataConnectionAc(null);
+
+                // Need to notify disconnect as well, in the case of switching Airplane mode.
+                // Otherwise, it would cause 30s delayed to turn on Airplane mode.
+                if (mDisconnectPendingCount > 0) {
+                    mDisconnectPendingCount--;
+                }
+
+                if (mDisconnectPendingCount == 0) {
+                    notifyDataDisconnectComplete();
+                    notifyAllDataDisconnected();
+                }
+                return;
+            }
+        }
+        // If APN is still enabled, try to bring it back up automatically
+        if (mAttached.get() && apnContext.isReady() && retryAfterDisconnected(apnContext)) {
+            try {
+                SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
+            } catch (RuntimeException ex) {
+                log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
+            }
+
+            if (mTelDevController.getModem(0) != null &&
+                    mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false) {
+                if (PhoneConstants.APN_TYPE_IMS.equals(apnContext.getApnType()) ||
+                        PhoneConstants.APN_TYPE_EMERGENCY.equals(apnContext.getApnType())) {
+                    logd("onDisconnectDone: not to retry for " + apnContext.getApnType() + " PDN");
+                    return;
+                }
+            }
+
+            // Wait a bit before trying the next APN, so that
+            // we're not tying up the RIL command channel.
+            // This also helps in any external dependency to turn off the context.
+            if (DBG) log("onDisconnectDone: attached, ready and retry after disconnect");
+            long delay = apnContext.getInterApnDelay(mFailFast);
+            delay = getDisconnectDoneRetryTimer(apnContext.getReason(), delay);
+            if (delay > 0) {
+                // Data connection is in IDLE state, so when we reconnect later, we'll rebuild
+                // the waiting APN list, which will also reset/reconfigure the retry manager.
+                startAlarmForReconnect(delay, apnContext);
+            }
+        } else {
+            boolean restartRadioAfterProvisioning = mPhone.getContext().getResources().getBoolean(
+                    com.android.internal.R.bool.config_restartRadioAfterProvisioning);
+
+            if (apnContext.isProvisioningApn() && restartRadioAfterProvisioning) {
+                log("onDisconnectDone: restartRadio after provisioning");
+                restartRadio();
+            }
+            apnContext.setApnSetting(null);
+            apnContext.setDataConnectionAc(null);
+            if (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())) {
+                if(DBG) log("onDisconnectDone: isOnlySigneDcAllowed true so setup single apn");
+                setupDataOnConnectableApns(Phone.REASON_SINGLE_PDN_ARBITRATION);
+            } else {
+                if(DBG) log("onDisconnectDone: not retrying");
+            }
+        }
+
+        if (mDisconnectPendingCount > 0)
+            mDisconnectPendingCount--;
+
+        if (mDisconnectPendingCount == 0) {
+            apnContext.setConcurrentVoiceAndDataAllowed(
+                    mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed());
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+    }
+
+    /**
+     * M: Called when EVENT_DISCONNECT_DONE is received.
+     * Get retry timer for onDisconnectDone.
+     */
+    private long getDisconnectDoneRetryTimer(String reason, long delay) {
+        long timer = delay;
+        if (Phone.REASON_APN_CHANGED.equals(reason)) {
+            // M: onApnChanged need retry quickly
+            timer = 3000;
+        } else if (!BSP_PACKAGE && mGsmDctExt != null) {
+            // M: for other specific reason
+            try {
+                timer = mGsmDctExt.getDisconnectDoneRetryTimer(reason, timer);
+            } catch (Exception e) {
+                loge("GsmDCTExt.getDisconnectDoneRetryTimer fail!");
+                e.printStackTrace();
+            }
+        }
+
+        return timer;
+    }
+
+    /**
+     * Called when EVENT_DISCONNECT_DC_RETRYING is received.
+     */
+    private void onDisconnectDcRetrying(AsyncResult ar) {
+        // We could just do this in DC!!!
+        ApnContext apnContext = getValidApnContext(ar, "onDisconnectDcRetrying");
+        if (apnContext == null) return;
+
+        apnContext.setState(DctConstants.State.RETRYING);
+        if(DBG) log("onDisconnectDcRetrying: apnContext=" + apnContext);
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+    }
+
+    public void onVoiceCallStarted() {
+        mInVoiceCall = true;
+
+        boolean isSupportConcurrent =
+                DataConnectionHelper.getInstance().isDataSupportConcurrent(mPhone.getPhoneId());
+        logd("onVoiceCallStarted:isDataSupportConcurrent = " + isSupportConcurrent);
+
+        if (isConnected() && !isSupportConcurrent) {
+            logd("onVoiceCallStarted stop polling");
+            stopNetStatPoll();
+            stopDataStallAlarm();
+            notifyDataConnection(Phone.REASON_VOICE_CALL_STARTED);
+        }
+        notifyVoiceCallEventToDataConnection(mInVoiceCall, isSupportConcurrent);
+    }
+
+    public void onVoiceCallEnded() {
+        mInVoiceCall = false;
+
+        boolean isSupportConcurrent =
+                DataConnectionHelper.getInstance().isDataSupportConcurrent(mPhone.getPhoneId());
+        logd("onVoiceCallEnded:isDataSupportConcurrent = " + isSupportConcurrent);
+
+        if (!getDataEnabled()) {
+            logd("onVoiceCallEnded: default data disable, cleanup default apn.");
+            onCleanUpConnection(true, DctConstants.APN_DEFAULT_ID, Phone.REASON_DATA_DISABLED);
+        }
+
+        if (isConnected()) {
+            if (!isSupportConcurrent) {
+                startNetStatPoll();
+                startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
+            } else {
+                // clean slate after call end.
+                resetPollStats();
+            }
+        }
+        // reset reconnect timer
+        setupDataOnConnectableApns(Phone.REASON_VOICE_CALL_ENDED);
+
+        notifyVoiceCallEventToDataConnection(mInVoiceCall, isSupportConcurrent);
+    }
+
+    private void onCleanUpConnection(boolean tearDown, int apnId, String reason) {
+        if (DBG) log("onCleanUpConnection");
+        ApnContext apnContext = mApnContextsById.get(apnId);
+        if (apnContext != null) {
+            apnContext.setReason(reason);
+            cleanUpConnection(tearDown, apnContext);
+        }
+    }
+
+    private boolean isConnected() {
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.getState() == DctConstants.State.CONNECTED) {
+                // At least one context is connected, return true
+                return true;
+            }
+        }
+        // There are not any contexts connected, return false
+        return false;
+    }
+
+    public boolean isDisconnected() {
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (!apnContext.isDisconnected()) {
+                // At least one context was not disconnected return false
+                return false;
+            }
+        }
+        // All contexts were disconnected so return true
+        return true;
+    }
+
+    private void notifyDataConnection(String reason) {
+        if (DBG) log("notifyDataConnection: reason=" + reason);
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (mAttached.get() && apnContext.isReady() && apnContext.isNeedNotify()) {
+                // M: Check need notify or not in order to avoid ANR issue
+                if (DBG) log("notifyDataConnection: type:" + apnContext.getApnType());
+                mPhone.notifyDataConnection(reason != null ? reason : apnContext.getReason(),
+                        apnContext.getApnType());
+            }
+        }
+        notifyOffApnsOfAvailability(reason);
+    }
+
+    private void setDataProfilesAsNeeded() {
+        if (DBG) log("setDataProfilesAsNeeded");
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.modemCognitive) {
+                    DataProfile dp = new DataProfile(apn,
+                            mPhone.getServiceState().getDataRoaming());
+                    boolean isDup = false;
+                    for(DataProfile dpIn : dps) {
+                        if (dp.equals(dpIn)) {
+                            isDup = true;
+                            break;
+                        }
+                    }
+                    if (!isDup) {
+                        dps.add(dp);
+                    }
+                }
+            }
+            if(dps.size() > 0) {
+                mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), null);
+            }
+        }
+    }
+
+    /**
+     * Based on the sim operator numeric, create a list for all possible
+     * Data Connections and setup the preferredApn.
+     */
+    private void createAllApnList() {
+        mMvnoMatched = false;
+        mAllApnSettings = new ArrayList<ApnSetting>();
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        /// M: for plug-in @{
+        // use mcc&mnc in IMPI to query apn.
+        if (DBG) log("createAllApnList: operator = " + operator);
+        if (mTelephonyExt != null) {
+            operator = mTelephonyExt.getOperatorNumericFromImpi(operator, mPhone.getPhoneId());
+        }
+        /// @}
+
+        if (operator != null) {
+            String selection = "numeric = '" + operator + "'";
+            String orderBy = "_id";
+            // query only enabled apn.
+            // carrier_enabled : 1 means enabled apn, 0 disabled apn.
+            // selection += " and carrier_enabled = 1";
+            if (DBG) log("createAllApnList: selection=" + selection);
+
+            Cursor cursor = mPhone.getContext().getContentResolver().query(
+                    Telephony.Carriers.CONTENT_URI, null, selection, null, orderBy);
+
+            if (cursor != null) {
+                if (cursor.getCount() > 0) {
+                    mAllApnSettings = createApnList(cursor);
+                }
+                cursor.close();
+            }
+        }
+
+        // Try to load default emergency again
+        initEmergencyApnSetting();
+        addEmergencyApnSetting();
+
+        dedupeApnSettings();
+
+        if (mAllApnSettings.isEmpty()) {
+            if (DBG) log("createAllApnList: No APN found for carrier: " + operator);
+            mPreferredApn = null;
+            // TODO: What is the right behavior?
+            //notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
+        } else {
+            mPreferredApn = getPreferredApn();
+            if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
+                mPreferredApn = null;
+                setPreferredApn(-1);
+            }
+            if (DBG) log("createAllApnList: mPreferredApn=" + mPreferredApn);
+        }
+        // M: For debug
+        if (DBG) logi("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
+
+        setDataProfilesAsNeeded();
+
+        // M: sync apn table to md
+        if (operator != null) {
+            syncApnToMd();
+        }
+
+        // M: VDF MMS over ePDG @{
+        syncApnTableToRds(mAllApnSettings);
+        /// @}
+    }
+
+    private void dedupeApnSettings() {
+        ArrayList<ApnSetting> resultApns = new ArrayList<ApnSetting>();
+
+        // coalesce APNs if they are similar enough to prevent
+        // us from bringing up two data calls with the same interface
+        int i = 0;
+        while (i < mAllApnSettings.size() - 1) {
+            ApnSetting first = mAllApnSettings.get(i);
+            ApnSetting second = null;
+            int j = i + 1;
+            while (j < mAllApnSettings.size()) {
+                second = mAllApnSettings.get(j);
+                if (apnsSimilar(first, second)) {
+                    ApnSetting newApn = mergeApns(first, second);
+                    mAllApnSettings.set(i, newApn);
+                    first = newApn;
+                    mAllApnSettings.remove(j);
+                } else {
+                    j++;
+                }
+            }
+            i++;
+        }
+    }
+
+    //check whether the types of two APN same (even only one type of each APN is same)
+    private boolean apnTypeSameAny(ApnSetting first, ApnSetting second) {
+        if(VDBG) {
+            StringBuilder apnType1 = new StringBuilder(first.apn + ": ");
+            for(int index1 = 0; index1 < first.types.length; index1++) {
+                apnType1.append(first.types[index1]);
+                apnType1.append(",");
+            }
+
+            StringBuilder apnType2 = new StringBuilder(second.apn + ": ");
+            for(int index1 = 0; index1 < second.types.length; index1++) {
+                apnType2.append(second.types[index1]);
+                apnType2.append(",");
+            }
+            log("APN1: is " + apnType1);
+            log("APN2: is " + apnType2);
+        }
+
+        for(int index1 = 0; index1 < first.types.length; index1++) {
+            for(int index2 = 0; index2 < second.types.length; index2++) {
+                if(first.types[index1].equals(PhoneConstants.APN_TYPE_ALL) ||
+                        second.types[index2].equals(PhoneConstants.APN_TYPE_ALL) ||
+                        first.types[index1].equals(second.types[index2])) {
+                    if(VDBG)log("apnTypeSameAny: return true");
+                    return true;
+                }
+            }
+        }
+
+        if(VDBG)log("apnTypeSameAny: return false");
+        return false;
+    }
+
+    // Check if neither mention DUN and are substantially similar
+    private boolean apnsSimilar(ApnSetting first, ApnSetting second) {
+        return (first.canHandleType(PhoneConstants.APN_TYPE_DUN) == false &&
+                second.canHandleType(PhoneConstants.APN_TYPE_DUN) == false &&
+                Objects.equals(first.apn, second.apn) &&
+                !apnTypeSameAny(first, second) &&
+                xorEquals(first.proxy, second.proxy) &&
+                xorEquals(first.port, second.port) &&
+                first.carrierEnabled == second.carrierEnabled &&
+                first.bearerBitmask == second.bearerBitmask &&
+                first.profileId == second.profileId &&
+                Objects.equals(first.mvnoType, second.mvnoType) &&
+                Objects.equals(first.mvnoMatchData, second.mvnoMatchData) &&
+                xorEquals(first.mmsc, second.mmsc) &&
+                xorEquals(first.mmsProxy, second.mmsProxy) &&
+                xorEquals(first.mmsPort, second.mmsPort));
+    }
+
+    // equal or one is not specified
+    private boolean xorEquals(String first, String second) {
+        return (Objects.equals(first, second) ||
+                TextUtils.isEmpty(first) ||
+                TextUtils.isEmpty(second));
+    }
+
+    private ApnSetting mergeApns(ApnSetting dest, ApnSetting src) {
+        int id = dest.id;
+        ArrayList<String> resultTypes = new ArrayList<String>();
+        resultTypes.addAll(Arrays.asList(dest.types));
+        for (String srcType : src.types) {
+            if (resultTypes.contains(srcType) == false) resultTypes.add(srcType);
+            if (srcType.equals(PhoneConstants.APN_TYPE_DEFAULT)) id = src.id;
+        }
+        String mmsc = (TextUtils.isEmpty(dest.mmsc) ? src.mmsc : dest.mmsc);
+        String mmsProxy = (TextUtils.isEmpty(dest.mmsProxy) ? src.mmsProxy : dest.mmsProxy);
+        String mmsPort = (TextUtils.isEmpty(dest.mmsPort) ? src.mmsPort : dest.mmsPort);
+        String proxy = (TextUtils.isEmpty(dest.proxy) ? src.proxy : dest.proxy);
+        String port = (TextUtils.isEmpty(dest.port) ? src.port : dest.port);
+        String protocol = src.protocol.equals("IPV4V6") ? src.protocol : dest.protocol;
+        String roamingProtocol = src.roamingProtocol.equals("IPV4V6") ? src.roamingProtocol :
+                dest.roamingProtocol;
+        int bearerBitmask = (dest.bearerBitmask == 0 || src.bearerBitmask == 0) ?
+                0 : (dest.bearerBitmask | src.bearerBitmask);
+
+        return new ApnSetting(id, dest.numeric, dest.carrier, dest.apn,
+                proxy, port, mmsc, mmsProxy, mmsPort, dest.user, dest.password,
+                dest.authType, resultTypes.toArray(new String[0]), protocol,
+                roamingProtocol, dest.carrierEnabled, 0, bearerBitmask, dest.profileId,
+                (dest.modemCognitive || src.modemCognitive), dest.maxConns, dest.waitTime,
+                dest.maxConnsTime, dest.mtu, dest.mvnoType, dest.mvnoMatchData, dest.inactiveTimer);
+    }
+
+    /** Return the DC AsyncChannel for the new data connection */
+    private DcAsyncChannel createDataConnection(String reqApnType, ApnSetting apnSetting) {
+        if (DBG) log("createDataConnection E");
+
+        int id = 0;
+        if (isSupportThrottlingApn()) {
+            id = generateDataConnectionId(reqApnType, apnSetting);
+            if (id < 0) {
+                return null;
+            }
+        } else {
+            id = mUniqueIdGenerator.getAndIncrement();
+            if (id >= getPdpConnectionPoolSize()) {
+                loge("Max PDP count is " + getPdpConnectionPoolSize() + ",but request " + (id + 1));
+                mUniqueIdGenerator.getAndDecrement();
+                return null;
+            }
+        }
+
+        DataConnection conn = DataConnection.makeDataConnection(mPhone, id,
+                                                this, mDcTesterFailBringUpAll, mDcc);
+        mDataConnections.put(id, conn);
+        DcAsyncChannel dcac = new DcAsyncChannel(conn, LOG_TAG);
+        int status = dcac.fullyConnectSync(mPhone.getContext(), this, conn.getHandler());
+        if (status == AsyncChannel.STATUS_SUCCESSFUL) {
+            mDataConnectionAcHashMap.put(dcac.getDataConnectionIdSync(), dcac);
+        } else {
+            loge("createDataConnection: Could not connect to dcac=" + dcac + " status=" + status);
+        }
+
+        if (DBG) log("createDataConnection() X id=" + id + " dc=" + conn);
+        return dcac;
+    }
+
+    private void destroyDataConnections() {
+        if(mDataConnections != null) {
+            if (DBG) log("destroyDataConnections: clear mDataConnectionList");
+            mDataConnections.clear();
+        } else {
+            if (DBG) log("destroyDataConnections: mDataConnecitonList is empty, ignore");
+        }
+    }
+
+    /**
+     * Build a list of APNs to be used to create PDP's.
+     *
+     * @param requestedApnType
+     * @return waitingApns list to be used to create PDP
+     *          error when waitingApns.isEmpty()
+     */
+    private ArrayList<ApnSetting> buildWaitingApns(String requestedApnType, int radioTech) {
+        if (DBG) log("buildWaitingApns: E requestedApnType=" + requestedApnType);
+        ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
+
+        if (requestedApnType.equals(PhoneConstants.APN_TYPE_DUN)) {
+            ApnSetting dun = fetchDunApn();
+            if (dun != null) {
+                apnList.add(dun);
+                if (DBG) log("buildWaitingApns: X added APN_TYPE_DUN apnList=" + apnList);
+                return apnList;
+            }
+        }
+
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        // This is a workaround for a bug (7305641) where we don't failover to other
+        // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
+        // failover to a provisioning APN, but once we've used their default data
+        // connection we are locked to it for life.  This change allows ATT devices
+        // to say they don't want to use preferred at all.
+        boolean usePreferred = true;
+        try {
+            usePreferred = ! mPhone.getContext().getResources().getBoolean(com.android.
+                    internal.R.bool.config_dontPreferApn);
+        } catch (Resources.NotFoundException e) {
+            if (DBG) log("buildWaitingApns: usePreferred NotFoundException set to true");
+            usePreferred = true;
+        }
+        if (usePreferred) {
+            mPreferredApn = getPreferredApn();
+        }
+        if (DBG) {
+            log("buildWaitingApns: usePreferred=" + usePreferred
+                    + " canSetPreferApn=" + mCanSetPreferApn
+                    + " mPreferredApn=" + mPreferredApn
+                    + " operator=" + operator + " radioTech=" + radioTech
+                    + " IccRecords r=" + r);
+        }
+
+        if (usePreferred && mCanSetPreferApn && mPreferredApn != null &&
+                mPreferredApn.canHandleType(requestedApnType)) {
+            if (DBG) {
+                log("buildWaitingApns: Preferred APN:" + operator + ":"
+                        + mPreferredApn.numeric + ":" + mPreferredApn);
+            }
+            if (mPreferredApn.numeric.equals(operator)) {
+                if (ServiceState.bitmaskHasTech(mPreferredApn.bearerBitmask, radioTech)) {
+                    apnList.add(mPreferredApn);
+                    if (DBG) log("buildWaitingApns: X added preferred apnList=" + apnList);
+                    return apnList;
+                } else {
+                    if (DBG) log("buildWaitingApns: no preferred APN");
+                    setPreferredApn(-1);
+                    mPreferredApn = null;
+                }
+            } else {
+                if (DBG) log("buildWaitingApns: no preferred APN");
+                setPreferredApn(-1);
+                mPreferredApn = null;
+            }
+        }
+        if (mAllApnSettings != null) {
+            if (DBG) log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(requestedApnType)) {
+                    if (ServiceState.bitmaskHasTech(apn.bearerBitmask, radioTech)) {
+                        if (DBG) log("buildWaitingApns: adding apn=" + apn);
+                        apnList.add(apn);
+                    } else {
+                        if (DBG) {
+                            log("buildWaitingApns: bearerBitmask:" + apn.bearerBitmask + " does " +
+                                    "not include radioTech:" + radioTech);
+                        }
+                    }
+                } else if (DBG) {
+                    log("buildWaitingApns: couldn't handle requested ApnType="
+                            + requestedApnType);
+                }
+            }
+        } else {
+            loge("mAllApnSettings is null!");
+        }
+        if (DBG) log("buildWaitingApns: " + apnList.size() + " APNs in the list: " + apnList);
+        return apnList;
+    }
+
+    // M: VDF MMS over ePDG @{
+    private ArrayList<ApnSetting> buildWifiApns(String requestedApnType) {
+        if (DBG) log("buildWifiApns: E requestedApnType=" + requestedApnType);
+        ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
+
+        if (mAllApnSettings != null) {
+            if (DBG) log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(requestedApnType)) {
+                    if (isWifiOnlyApn(apn.bearerBitmask)) {
+                        apnList.add(apn);
+                    }
+                }
+            }
+        }
+        if (DBG) log("buildWifiApns: X apnList=" + apnList);
+        return apnList;
+    }
+    /// @}
+    private String apnListToString (ArrayList<ApnSetting> apns) {
+        StringBuilder result = new StringBuilder();
+        try {
+            for (int i = 0, size = apns.size(); i < size; i++) {
+                result.append('[')
+                  .append(apns.get(i).toString())
+                  .append(']');
+            }
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+        return result.toString();
+    }
+
+    private void setPreferredApn(int pos) {
+        if (!mCanSetPreferApn) {
+            log("setPreferredApn: X !canSEtPreferApn");
+            return;
+        }
+
+        String subId = Long.toString(mPhone.getSubId());
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        log("setPreferredApn: delete subId=" + subId);
+        ContentResolver resolver = mPhone.getContext().getContentResolver();
+        resolver.delete(uri, null, null);
+
+        if (pos >= 0) {
+            log("setPreferredApn: insert pos=" + pos + ", subId=" + subId);
+            ContentValues values = new ContentValues();
+            values.put(APN_ID, pos);
+            resolver.insert(uri, values);
+        }
+    }
+
+    private ApnSetting getPreferredApn() {
+        if (mAllApnSettings == null || mAllApnSettings.isEmpty()) {
+            log("getPreferredApn: mAllApnSettings is " + ((mAllApnSettings == null)?"null":"empty"));
+            return null;
+        }
+
+        String subId = Long.toString(mPhone.getSubId());
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        Cursor cursor = mPhone.getContext().getContentResolver().query(
+                uri, new String[] { "_id", "name", "apn" },
+                null, null, Telephony.Carriers.DEFAULT_SORT_ORDER);
+
+        if (cursor != null) {
+            mCanSetPreferApn = true;
+        } else {
+            mCanSetPreferApn = false;
+        }
+        log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor=" + cursor
+                + " cursor.count=" + ((cursor != null) ? cursor.getCount() : 0)
+                + " subId=" + subId);
+
+        if (mCanSetPreferApn && cursor.getCount() > 0) {
+            int pos;
+            cursor.moveToFirst();
+            pos = cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID));
+            for(ApnSetting p : mAllApnSettings) {
+                log("getPreferredApn: apnSetting=" + p + ", pos=" + pos + ", subId=" + subId);
+                if (p.id == pos && p.canHandleType(mRequestedApnType)) {
+                    log("getPreferredApn: X found apnSetting" + p);
+                    cursor.close();
+                    return p;
+                }
+            }
+        }
+
+        if (cursor != null) {
+            cursor.close();
+        }
+
+        log("getPreferredApn: X not found");
+        return null;
+    }
+
+    @Override
+    public void handleMessage (Message msg) {
+        if (VDBG) log("handleMessage msg=" + msg);
+        AsyncResult ar;
+
+        switch (msg.what) {
+            case DctConstants.EVENT_RECORDS_LOADED:
+                // If onRecordsLoadedOrSubIdChanged() is not called here, it should be called on
+                // onSubscriptionsChanged() when a valid subId is available.
+                int subId = mPhone.getSubId();
+                if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                    onRecordsLoadedOrSubIdChanged();
+                } else {
+                    log("Ignoring EVENT_RECORDS_LOADED as subId is not valid: " + subId);
+                }
+                break;
+
+            case DctConstants.EVENT_DATA_CONNECTION_DETACHED:
+                onDataConnectionDetached();
+                break;
+
+            case DctConstants.EVENT_DATA_CONNECTION_ATTACHED:
+                onDataConnectionAttached();
+                break;
+
+            case DctConstants.EVENT_DO_RECOVERY:
+                doRecovery();
+                break;
+
+            case DctConstants.EVENT_APN_CHANGED:
+                onApnChanged();
+                break;
+
+            case DctConstants.EVENT_APN_CHANGED_DONE:
+                boolean bImsApnChanged = (msg.arg1 == 0) ? false : true;
+                logd("EVENT_APN_CHANGED_DONE");
+                if (bImsApnChanged) {
+                    log("ims apn changed");
+                    ApnContext apnContext = mApnContexts.get(PhoneConstants.APN_TYPE_IMS);
+                    cleanUpConnection(true, apnContext);
+                } else {
+                    // default changed
+                    onApnChangedDone();
+                }
+                break;
+
+            case DctConstants.EVENT_PS_RESTRICT_ENABLED:
+                /**
+                 * We don't need to explicitly to tear down the PDP context
+                 * when PS restricted is enabled. The base band will deactive
+                 * PDP context and notify us with PDP_CONTEXT_CHANGED.
+                 * But we should stop the network polling and prevent reset PDP.
+                 */
+                if (DBG) log("EVENT_PS_RESTRICT_ENABLED " + mIsPsRestricted);
+                stopNetStatPoll();
+                stopDataStallAlarm();
+                mIsPsRestricted = true;
+                break;
+
+            case DctConstants.EVENT_PS_RESTRICT_DISABLED:
+                /**
+                 * When PS restrict is removed, we need setup PDP connection if
+                 * PDP connection is down.
+                 */
+                // M: Wifi only
+                ConnectivityManager cnnm = (ConnectivityManager) mPhone.getContext()
+                        .getSystemService(Context.CONNECTIVITY_SERVICE);
+
+                if (DBG) log("EVENT_PS_RESTRICT_DISABLED " + mIsPsRestricted);
+                mIsPsRestricted  = false;
+                if (isConnected()) {
+                    startNetStatPoll();
+                    startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                } else {
+                    // TODO: Should all PDN states be checked to fail?
+                    if (mState == DctConstants.State.FAILED) {
+                        cleanUpAllConnections(false, Phone.REASON_PS_RESTRICT_ENABLED);
+                        mReregisterOnReconnectFailure = false;
+                    }
+                    ApnContext apnContext = mApnContextsById.get(DctConstants.APN_DEFAULT_ID);
+                    if (apnContext != null) {
+                        // M: Fix dual DataConnection issue. For the case that PS is detached but
+                        //    the EVENT_DATA_CONNECTION_DETACHED haven't received yet. In this case,
+                        //    isDataAllow returns true and will try to setup data. Then, the detach
+                        //    message received and set mAttached as false. After this,
+                        //    onDisconnectDone() called and will set ApnContext idle and DCAC null.
+                        //    It will make DCAC can not re-use when setup data at the second time.
+                        if (mPhone.getServiceStateTracker().getCurrentDataConnectionState()
+                                == ServiceState.STATE_IN_SERVICE) {
+                            apnContext.setReason(Phone.REASON_PS_RESTRICT_ENABLED);
+                            trySetupData(apnContext);
+                        } else {
+                            log("EVENT_PS_RESTRICT_DISABLED, data not attached, skip.");
+                        }
+                    } else {
+                        loge("**** Default ApnContext not found ****");
+                        // M: Wifi only
+                        if (Build.IS_DEBUGGABLE && cnnm.isNetworkSupported(
+                                ConnectivityManager.TYPE_MOBILE)) {
+                            throw new RuntimeException("Default ApnContext not found");
+                        }
+                    }
+                }
+                break;
+
+            case DctConstants.EVENT_TRY_SETUP_DATA:
+                if (msg.obj instanceof ApnContext) {
+                    onTrySetupData((ApnContext)msg.obj);
+                } else if (msg.obj instanceof String) {
+                    onTrySetupData((String)msg.obj);
+                } else {
+                    loge("EVENT_TRY_SETUP request w/o apnContext or String");
+                }
+                break;
+
+            case DctConstants.EVENT_CLEAN_UP_CONNECTION:
+                boolean tearDown = (msg.arg1 == 0) ? false : true;
+                if (DBG) log("EVENT_CLEAN_UP_CONNECTION tearDown=" + tearDown);
+                if (msg.obj instanceof ApnContext) {
+                    cleanUpConnection(tearDown, (ApnContext)msg.obj);
+                } else {
+                    onCleanUpConnection(tearDown, msg.arg2, (String) msg.obj);
+                }
+                break;
+            case DctConstants.EVENT_SET_INTERNAL_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                onSetInternalDataEnabled(enabled, (Message) msg.obj);
+                break;
+            }
+            case DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS:
+                if ((msg.obj != null) && (msg.obj instanceof String == false)) {
+                    msg.obj = null;
+                }
+                onCleanUpAllConnections((String) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DATA_RAT_CHANGED:
+                //May new Network allow setupData, so try it here
+                setupDataOnConnectableApns(Phone.REASON_NW_TYPE_CHANGED,
+                        RetryFailures.ONLY_ON_CHANGE);
+                break;
+
+            case DctConstants.CMD_CLEAR_PROVISIONING_SPINNER:
+                // Check message sender intended to clear the current spinner.
+                if (mProvisioningSpinner == msg.obj) {
+                    mProvisioningSpinner.dismiss();
+                    mProvisioningSpinner = null;
+                }
+                break;
+
+            // M: IA-change attach APN
+            case DctConstants.EVENT_ATTACH_APN_CHANGED:
+                onMdChangedAttachApn((AsyncResult) msg.obj);
+                break;
+
+            //M: FDN Support
+            case DctConstants.EVENT_FDN_CHANGED:
+                onFdnChanged();
+                break;
+
+            case DctConstants.EVENT_RESET_PDP_DONE:
+                logd("EVENT_RESET_PDP_DONE cid=" + msg.arg1);
+                break;
+
+            case DctConstants.EVENT_REMOVE_RESTRICT_EUTRAN:
+                if (MTK_CC33_SUPPORT) {
+                    logd("EVENT_REMOVE_RESTRICT_EUTRAN");
+                    mReregisterOnReconnectFailure = false;
+                    setupDataOnConnectableApns(Phone.REASON_PS_RESTRICT_DISABLED);
+                }
+                break;
+
+            case DctConstants.EVENT_MD_DATA_RETRY_COUNT_RESET:
+                logd("EVENT_MD_DATA_RETRY_COUNT_RESET");
+                setupDataOnConnectableApns(Phone.REASON_MD_DATA_RETRY_COUNT_RESET);
+                break;
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            // TODO: Should this move to NW frameworks to handle?
+            case DctConstants.EVENT_LTE_ACCESS_STRATUM_STATE:
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception == null) {
+                    int[] ints = (int[]) ar.result;
+                    int lteAccessStratumDataState = ints.length > 0 ? ints[0]
+                            : DctConstants.INVALID;
+                    int networkType = ints.length > 1 ? ints[1] : DctConstants.INVALID;
+                    if (lteAccessStratumDataState != LTE_AS_CONNECTED) { // LTE AS Disconnected
+                        notifyPsNetworkTypeChanged(networkType);
+                    } else { // LTE AS Connected
+                        mPhone.notifyPsNetworkTypeChanged(TelephonyManager.NETWORK_TYPE_LTE);
+                    }
+                    logd("EVENT_LTE_ACCESS_STRATUM_STATE lteAccessStratumDataState = "
+                            + lteAccessStratumDataState + ", networkType = " + networkType);
+                    notifyLteAccessStratumChanged(lteAccessStratumDataState);
+                } else {
+                    loge("LteAccessStratumState exception: " + ar.exception);
+                }
+                break;
+
+            case DctConstants.EVENT_DEFAULT_APN_REFERENCE_COUNT_CHANGED: {
+                int newDefaultRefCount = msg.arg1;
+                onSharedDefaultApnState(newDefaultRefCount);
+                break;
+            }
+            // M: [LTE][Low Power][UL traffic shaping] End
+
+            // M: JPN IA Start
+            case DctConstants.EVENT_REG_PLMN_CHANGED:
+                log("handleMessage : <EVENT_REG_PLMN_CHANGED>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    handlePlmnChange((AsyncResult) msg.obj);
+                }
+                break;
+            case DctConstants.EVENT_REG_SUSPENDED:
+                log("handleMessage : <EVENT_REG_SUSPENDED>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    if (isNeedToResumeMd()) {
+                        handleRegistrationSuspend((AsyncResult) msg.obj);
+                    }
+                }
+                break;
+            case DctConstants.EVENT_SET_RESUME:
+                log("handleMessage : <EVENT_SET_RESUME>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    handleSetResume();
+                }
+                break;
+            // M: JPN IA End
+
+            case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                log("DISCONNECTED_CONNECTED: msg=" + msg);
+                DcAsyncChannel dcac = (DcAsyncChannel) msg.obj;
+                mDataConnectionAcHashMap.remove(dcac.getDataConnectionIdSync());
+                dcac.disconnected();
+                break;
+            }
+            case DctConstants.EVENT_ENABLE_NEW_APN:
+                onEnableApn(msg.arg1, msg.arg2);
+                break;
+
+            case DctConstants.EVENT_DATA_STALL_ALARM:
+                onDataStallAlarm(msg.arg1);
+                break;
+
+            case DctConstants.EVENT_ROAMING_OFF:
+                onRoamingOff();
+                break;
+
+            case DctConstants.EVENT_ROAMING_ON:
+                onRoamingOn();
+                break;
+
+            case DctConstants.EVENT_ROAMING_TYPE_CHANGED:
+                onRoamingTypeChanged();
+                break;
+
+            case DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE:
+                onDeviceProvisionedChange();
+                break;
+
+            case DctConstants.EVENT_REDIRECTION_DETECTED:
+                String url = (String) msg.obj;
+                log("dataConnectionTracker.handleMessage: EVENT_REDIRECTION_DETECTED=" + url);
+                onDataConnectionRedirected(url);
+
+            case DctConstants.EVENT_RADIO_AVAILABLE:
+                onRadioAvailable();
+                break;
+
+            case DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                onRadioOffOrNotAvailable();
+                break;
+
+            case DctConstants.EVENT_DATA_SETUP_COMPLETE:
+                onDataSetupComplete((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DATA_SETUP_COMPLETE_ERROR:
+                onDataSetupCompleteError((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DISCONNECT_DONE:
+                log("DataConnectionTracker.handleMessage: EVENT_DISCONNECT_DONE msg=" + msg);
+                onDisconnectDone((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DISCONNECT_DC_RETRYING:
+                log("DataConnectionTracker.handleMessage: EVENT_DISCONNECT_DC_RETRYING msg=" + msg);
+                onDisconnectDcRetrying((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_VOICE_CALL_STARTED:
+                onVoiceCallStarted();
+                break;
+
+            case DctConstants.EVENT_VOICE_CALL_ENDED:
+                onVoiceCallEnded();
+                break;
+
+            case DctConstants.EVENT_RESET_DONE: {
+                if (DBG) log("EVENT_RESET_DONE");
+                onResetDone((AsyncResult) msg.obj);
+                break;
+            }
+            case DctConstants.CMD_SET_USER_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                if (DBG) log("CMD_SET_USER_DATA_ENABLE enabled=" + enabled);
+                onSetUserDataEnabled(enabled);
+                break;
+            }
+            // TODO - remove
+            case DctConstants.CMD_SET_DEPENDENCY_MET: {
+                boolean met = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                if (DBG) log("CMD_SET_DEPENDENCY_MET met=" + met);
+                Bundle bundle = msg.getData();
+                if (bundle != null) {
+                    String apnType = (String)bundle.get(DctConstants.APN_TYPE_KEY);
+                    if (apnType != null) {
+                        onSetDependencyMet(apnType, met);
+                    }
+                }
+                break;
+            }
+            case DctConstants.CMD_SET_POLICY_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                onSetPolicyDataEnabled(enabled);
+                break;
+            }
+            case DctConstants.CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: {
+                sEnableFailFastRefCounter += (msg.arg1 == DctConstants.ENABLED) ? 1 : -1;
+                if (DBG) {
+                    log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: "
+                            + " sEnableFailFastRefCounter=" + sEnableFailFastRefCounter);
+                }
+                if (sEnableFailFastRefCounter < 0) {
+                    final String s = "CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: "
+                            + "sEnableFailFastRefCounter:" + sEnableFailFastRefCounter + " < 0";
+                    loge(s);
+                    sEnableFailFastRefCounter = 0;
+                }
+                final boolean enabled = sEnableFailFastRefCounter > 0;
+                if (DBG) {
+                    log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: enabled=" + enabled
+                            + " sEnableFailFastRefCounter=" + sEnableFailFastRefCounter);
+                }
+                if (mFailFast != enabled) {
+                    mFailFast = enabled;
+
+                    mDataStallDetectionEnabled = !enabled;
+                    if (mDataStallDetectionEnabled
+                            && (getOverallState() == DctConstants.State.CONNECTED)
+                            && (!mInVoiceCall ||
+                                    mPhone.getServiceStateTracker()
+                                        .isConcurrentVoiceAndDataAllowed())) {
+                        if (DBG) log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: start data stall");
+                        stopDataStallAlarm();
+                        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                    } else {
+                        if (DBG) log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: stop data stall");
+                        stopDataStallAlarm();
+                    }
+                }
+
+                break;
+            }
+            case DctConstants.CMD_ENABLE_MOBILE_PROVISIONING: {
+                Bundle bundle = msg.getData();
+                if (bundle != null) {
+                    try {
+                        mProvisioningUrl = (String)bundle.get(DctConstants.PROVISIONING_URL_KEY);
+                    } catch(ClassCastException e) {
+                        loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioning url not a string" + e);
+                        mProvisioningUrl = null;
+                    }
+                }
+                if (TextUtils.isEmpty(mProvisioningUrl)) {
+                    loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioning url is empty, ignoring");
+                    mIsProvisioning = false;
+                    mProvisioningUrl = null;
+                } else {
+                    loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioningUrl=" + mProvisioningUrl);
+                    mIsProvisioning = true;
+                    startProvisioningApnAlarm();
+                }
+                break;
+            }
+            case DctConstants.EVENT_PROVISIONING_APN_ALARM: {
+                if (DBG) log("EVENT_PROVISIONING_APN_ALARM");
+                ApnContext apnCtx = mApnContextsById.get(DctConstants.APN_DEFAULT_ID);
+                if (apnCtx.isProvisioningApn() && apnCtx.isConnectedOrConnecting()) {
+                    if (mProvisioningApnAlarmTag == msg.arg1) {
+                        if (DBG) log("EVENT_PROVISIONING_APN_ALARM: Disconnecting");
+                        mIsProvisioning = false;
+                        mProvisioningUrl = null;
+                        stopProvisioningApnAlarm();
+                        sendCleanUpConnection(true, apnCtx);
+                    } else {
+                        if (DBG) {
+                            log("EVENT_PROVISIONING_APN_ALARM: ignore stale tag,"
+                                    + " mProvisioningApnAlarmTag:" + mProvisioningApnAlarmTag
+                                    + " != arg1:" + msg.arg1);
+                        }
+                    }
+                } else {
+                    if (DBG) log("EVENT_PROVISIONING_APN_ALARM: Not connected ignore");
+                }
+                break;
+            }
+            case DctConstants.CMD_IS_PROVISIONING_APN: {
+                if (DBG) log("CMD_IS_PROVISIONING_APN");
+                boolean isProvApn;
+                try {
+                    String apnType = null;
+                    Bundle bundle = msg.getData();
+                    if (bundle != null) {
+                        apnType = (String)bundle.get(DctConstants.APN_TYPE_KEY);
+                    }
+                    if (TextUtils.isEmpty(apnType)) {
+                        loge("CMD_IS_PROVISIONING_APN: apnType is empty");
+                        isProvApn = false;
+                    } else {
+                        isProvApn = isProvisioningApn(apnType);
+                    }
+                } catch (ClassCastException e) {
+                    loge("CMD_IS_PROVISIONING_APN: NO provisioning url ignoring");
+                    isProvApn = false;
+                }
+                if (DBG) log("CMD_IS_PROVISIONING_APN: ret=" + isProvApn);
+                mReplyAc.replyToMessage(msg, DctConstants.CMD_IS_PROVISIONING_APN,
+                        isProvApn ? DctConstants.ENABLED : DctConstants.DISABLED);
+                break;
+            }
+            case DctConstants.EVENT_ICC_CHANGED: {
+                onUpdateIcc();
+                break;
+            }
+            case DctConstants.EVENT_RESTART_RADIO: {
+                restartRadio();
+                break;
+            }
+            case DctConstants.CMD_NET_STAT_POLL: {
+                if (msg.arg1 == DctConstants.ENABLED) {
+                    handleStartNetStatPoll((DctConstants.Activity)msg.obj);
+                } else if (msg.arg1 == DctConstants.DISABLED) {
+                    handleStopNetStatPoll((DctConstants.Activity)msg.obj);
+                }
+                break;
+            }
+            case DctConstants.EVENT_DATA_STATE_CHANGED: {
+                // no longer do anything, but still registered - clean up log
+                // TODO - why are we still registering?
+                break;
+            }
+            case DctConstants.EVENT_PCO_DATA_RECEIVED: {
+                handlePcoData((AsyncResult)msg.obj);
+                break;
+            }
+            case DctConstants.EVENT_SET_CARRIER_DATA_ENABLED:
+                onSetCarrierDataEnabled(msg.arg1 == DctConstants.ENABLED);
+                break;
+
+            // M: Multi-PS Attach Start
+            case DctConstants.EVENT_DATA_ALLOWED:
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.result != null) {
+                    int[] ints = (int[]) ar.result;
+                    boolean allowed = ints[0] == 1 ? true : false;
+                    onAllowChanged(allowed);
+                } else {
+                    loge("Parameter error: ret should not be NULL");
+                }
+                break;
+            // M: Multi-PS Attach End
+
+            //Reset Attach Apn
+            case DctConstants.EVENT_RESET_ATTACH_APN: {
+                if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+                    setInitialAttachApn();
+                } else {
+                    if (DBG) {
+                        log("EVENT_RESET_ATTACH_APN: Ignore due to null APN list");
+                    }
+                }
+                break;
+            }
+            case DctConstants.EVENT_PCO_STATUS:
+                onPcoStatus((AsyncResult) msg.obj);
+                break;
+            // M: Handle the event EVENT_DATA_ENABLED_SETTINGS
+            case DctConstants.EVENT_DATA_ENABLED_SETTINGS:
+                ar = (AsyncResult) msg.obj;
+                if (ar.result instanceof Pair) {
+                    Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
+                    onDataEnabledSettings(p.first, p.second);
+                }
+                break;
+            default:
+                Rlog.e("DcTracker", "Unhandled event=" + msg);
+                break;
+
+        }
+    }
+
+    private int getApnProfileID(String apnType) {
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
+            return RILConstants.DATA_PROFILE_IMS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_FOTA)) {
+            return RILConstants.DATA_PROFILE_FOTA;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CBS)) {
+            return RILConstants.DATA_PROFILE_CBS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IA)) {
+            return RILConstants.DATA_PROFILE_DEFAULT; // DEFAULT for now
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
+            return RILConstants.DATA_PROFILE_TETHERED;
+        // M: VDF MMS over ePDG @{
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) {
+            return RILConstants.DATA_PROFILE_MMS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_SUPL)) {
+            return RILConstants.DATA_PROFILE_SUPL;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_HIPRI)) {
+            return RILConstants.DATA_PROFILE_HIPRI;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DM)) {
+            return RILConstants.DATA_PROFILE_DM;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_WAP)) {
+            return RILConstants.DATA_PROFILE_WAP;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_NET)) {
+            return RILConstants.DATA_PROFILE_NET;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CMMAIL)) {
+            return RILConstants.DATA_PROFILE_CMMAIL;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_RCSE)) {
+            return RILConstants.DATA_PROFILE_RCSE;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_EMERGENCY)) {
+            return RILConstants.DATA_PROFILE_EMERGENCY;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_XCAP)) {
+            return RILConstants.DATA_PROFILE_XCAP;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_RCS)) {
+            return RILConstants.DATA_PROFILE_RCS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)) {
+            return RILConstants.DATA_PROFILE_DEFAULT;
+        } else {
+        /// @}
+            return RILConstants.DATA_PROFILE_INVALID;
+        }
+    }
+
+    private int getCellLocationId() {
+        int cid = -1;
+        CellLocation loc = mPhone.getCellLocation();
+
+        if (loc != null) {
+            if (loc instanceof GsmCellLocation) {
+                cid = ((GsmCellLocation)loc).getCid();
+            } else if (loc instanceof CdmaCellLocation) {
+                cid = ((CdmaCellLocation)loc).getBaseStationId();
+            }
+        }
+        return cid;
+    }
+
+    private IccRecords getUiccRecords(int appFamily) {
+        return mUiccController.getIccRecords(mPhone.getPhoneId(), appFamily);
+    }
+
+
+    private void onUpdateIcc() {
+        if (mUiccController == null ) {
+            return;
+        }
+
+        IccRecords newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
+
+        // M: Fix AOSP always get 3GPP when Phone is CDMA.
+        if (newIccRecords == null && mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+            // M:  CDMALTEPhone gets 3GPP above, pure CDMA card gets 3GPP2 here.
+            newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP2);
+        }
+
+        IccRecords r = mIccRecords.get();
+
+        // As UiccController always notify 2 SIMs, If only have 1 SIM, no need print this log
+        if (newIccRecords != null || r != null) {
+            logd("onUpdateIcc: newIccRecords=" + newIccRecords + ", r=" + r);
+        }
+
+        if (r != newIccRecords) {
+            if (r != null) {
+                log("Removing stale icc objects.");
+                r.unregisterForRecordsLoaded(this);
+                mIccRecords.set(null);
+            }
+            if (newIccRecords != null) {
+                if (SubscriptionManager.isValidSubscriptionId(mPhone.getSubId())) {
+                    log("New records found.");
+                    mIccRecords.set(newIccRecords);
+                    newIccRecords.registerForRecordsLoaded(
+                            this, DctConstants.EVENT_RECORDS_LOADED, null);
+                    // reset carrier actions on sim loaded
+                    final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+                    sst.setRadioPowerFromCarrier(true);
+                    mDataEnabledSettings.setCarrierDataEnabled(true);
+                    mPhone.getCarrierSignalAgent().reset();
+                }
+            } else {
+                onSimNotReady();
+            }
+        }
+
+        if (mAllApnSettings != null && r == null && newIccRecords == null) {
+            // M: clear mAllApnSettings in main thread to avoid concurrent access exception.
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    if (VDBG) {
+                        logTel("onUpdateIcc: clear mAllApnSettings, " +
+                                (mAllApnSettings != null));
+                    }
+                    if (mAllApnSettings != null) {
+                        mAllApnSettings.clear();
+                    }
+                }
+            });
+        }
+
+        //MTK START: FDN Support
+        UiccCardApplication app = mUiccCardApplication.get();
+        UiccCardApplication newUiccCardApp = mUiccController.getUiccCardApplication(
+                mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA ?
+                UiccController.APP_FAM_3GPP2 : UiccController.APP_FAM_3GPP);
+
+        if (app != newUiccCardApp) {
+            if (app != null) {
+                log("Removing stale UiccCardApplication objects.");
+                app.unregisterForFdnChanged(this);
+                mUiccCardApplication.set(null);
+            }
+
+            if (newUiccCardApp != null) {
+                log("New UiccCardApplication found");
+                newUiccCardApp.registerForFdnChanged(this, DctConstants.EVENT_FDN_CHANGED, null);
+                mUiccCardApplication.set(newUiccCardApp);
+            }
+        }
+        //MTK END: FDN Support
+    }
+
+    public void update() {
+        log("update sub = " + mPhone.getSubId());
+        onUpdateIcc();
+        synchronized (mDataEnabledSettings) {
+            mDataEnabledSettings.setUserDataEnabled(getDataEnabled());
+        }
+        mAutoAttachOnCreation.set(false);
+
+        ((GsmCdmaPhone)mPhone).updateCurrentCarrierInProvider();
+    }
+
+    public void cleanUpAllConnections(String cause) {
+        cleanUpAllConnections(cause, null);
+    }
+
+    public void updateRecords() {
+        onUpdateIcc();
+    }
+
+    public void cleanUpAllConnections(String cause, Message disconnectAllCompleteMsg) {
+        log("cleanUpAllConnections");
+        if (disconnectAllCompleteMsg != null) {
+            mDisconnectAllCompleteMsgList.add(disconnectAllCompleteMsg);
+        }
+
+        Message msg = obtainMessage(DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS);
+        msg.obj = cause;
+        sendMessage(msg);
+    }
+
+    private void notifyDataDisconnectComplete() {
+        log("notifyDataDisconnectComplete");
+        for (Message m: mDisconnectAllCompleteMsgList) {
+            m.sendToTarget();
+        }
+        mDisconnectAllCompleteMsgList.clear();
+    }
+
+
+    private void notifyAllDataDisconnected() {
+        sEnableFailFastRefCounter = 0;
+        mFailFast = false;
+        mAllDataDisconnectedRegistrants.notifyRegistrants();
+    }
+
+    public void registerForAllDataDisconnected(Handler h, int what, Object obj) {
+        mAllDataDisconnectedRegistrants.addUnique(h, what, obj);
+
+        if (isDisconnected()) {
+            log("notify All Data Disconnected");
+            notifyAllDataDisconnected();
+        }
+    }
+
+    public void unregisterForAllDataDisconnected(Handler h) {
+        mAllDataDisconnectedRegistrants.remove(h);
+    }
+
+    public void registerForDataEnabledChanged(Handler h, int what, Object obj) {
+        mDataEnabledSettings.registerForDataEnabledChanged(h, what, obj);
+    }
+
+    public void unregisterForDataEnabledChanged(Handler h) {
+        mDataEnabledSettings.unregisterForDataEnabledChanged(h);
+    }
+
+    private void onSetInternalDataEnabled(boolean enabled, Message onCompleteMsg) {
+        synchronized (mDataEnabledSettings) {
+            if (DBG) log("onSetInternalDataEnabled: enabled=" + enabled);
+            boolean sendOnComplete = true;
+
+            mDataEnabledSettings.setInternalDataEnabled(enabled);
+            if (enabled) {
+                log("onSetInternalDataEnabled: changed to enabled, try to setup data call");
+                onTrySetupData(Phone.REASON_DATA_ENABLED);
+            } else {
+                sendOnComplete = false;
+                log("onSetInternalDataEnabled: changed to disabled, cleanUpAllConnections");
+                cleanUpAllConnections(Phone.REASON_DATA_DISABLED, onCompleteMsg);
+            }
+
+            if (sendOnComplete) {
+                if (onCompleteMsg != null) {
+                    onCompleteMsg.sendToTarget();
+                }
+            }
+        }
+    }
+
+    public boolean setInternalDataEnabled(boolean enable) {
+        return setInternalDataEnabled(enable, null);
+    }
+
+    public boolean setInternalDataEnabled(boolean enable, Message onCompleteMsg) {
+        if (DBG) log("setInternalDataEnabled(" + enable + ")");
+
+        Message msg = obtainMessage(DctConstants.EVENT_SET_INTERNAL_DATA_ENABLE, onCompleteMsg);
+        msg.arg1 = (enable ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+        return true;
+    }
+
+    private void log(String s) {
+        // AOSP by default using Rlog.d()
+        logd(s);
+    }
+
+    private void loge(String s) {
+        Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logw(String s) {
+        Rlog.w(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logi(String s) {
+        // default user/userdebug debug level set as INFO
+        Rlog.i(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logd(String s) {
+        // default eng debug level set as DEBUG
+        Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logv(String s) {
+        Rlog.v(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logTel(String s) {
+        if (TEL_DBG > 0) {
+            logd(s);
+        } else {
+            logv(s);
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("DcTracker:");
+        pw.println(" RADIO_TESTS=" + RADIO_TESTS);
+        pw.println(" isInternalDataEnabled=" + mDataEnabledSettings.isInternalDataEnabled());
+        pw.println(" isUserDataEnabled=" + mDataEnabledSettings.isUserDataEnabled());
+        pw.println(" isPolicyDataEnabled=" + mDataEnabledSettings.isPolicyDataEnabled());
+        pw.flush();
+        pw.println(" mRequestedApnType=" + mRequestedApnType);
+        pw.println(" mPhone=" + mPhone.getPhoneName());
+        pw.println(" mActivity=" + mActivity);
+        pw.println(" mState=" + mState);
+        pw.println(" mTxPkts=" + mTxPkts);
+        pw.println(" mRxPkts=" + mRxPkts);
+        pw.println(" mNetStatPollPeriod=" + mNetStatPollPeriod);
+        pw.println(" mNetStatPollEnabled=" + mNetStatPollEnabled);
+        pw.println(" mDataStallTxRxSum=" + mDataStallTxRxSum);
+        pw.println(" mDataStallAlarmTag=" + mDataStallAlarmTag);
+        pw.println(" mDataStallDetectionEnabled=" + mDataStallDetectionEnabled);
+        pw.println(" mSentSinceLastRecv=" + mSentSinceLastRecv);
+        pw.println(" mNoRecvPollCount=" + mNoRecvPollCount);
+        pw.println(" mResolver=" + mResolver);
+        pw.println(" mIsWifiConnected=" + mIsWifiConnected);
+        pw.println(" mReconnectIntent=" + mReconnectIntent);
+        pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation.get());
+        pw.println(" mIsScreenOn=" + mIsScreenOn);
+        pw.println(" mUniqueIdGenerator=" + mUniqueIdGenerator);
+        pw.flush();
+        pw.println(" ***************************************");
+        DcController dcc = mDcc;
+        if (dcc != null) {
+            dcc.dump(fd, pw, args);
+        } else {
+            pw.println(" mDcc=null");
+        }
+        pw.println(" ***************************************");
+        HashMap<Integer, DataConnection> dcs = mDataConnections;
+        if (dcs != null) {
+            Set<Entry<Integer, DataConnection> > mDcSet = mDataConnections.entrySet();
+            pw.println(" mDataConnections: count=" + mDcSet.size());
+            for (Entry<Integer, DataConnection> entry : mDcSet) {
+                pw.printf(" *** mDataConnection[%d] \n", entry.getKey());
+                entry.getValue().dump(fd, pw, args);
+            }
+        } else {
+            pw.println("mDataConnections=null");
+        }
+        pw.println(" ***************************************");
+        pw.flush();
+        HashMap<String, Integer> apnToDcId = mApnToDataConnectionId;
+        if (apnToDcId != null) {
+            Set<Entry<String, Integer>> apnToDcIdSet = apnToDcId.entrySet();
+            pw.println(" mApnToDataConnectonId size=" + apnToDcIdSet.size());
+            for (Entry<String, Integer> entry : apnToDcIdSet) {
+                pw.printf(" mApnToDataConnectonId[%s]=%d\n", entry.getKey(), entry.getValue());
+            }
+        } else {
+            pw.println("mApnToDataConnectionId=null");
+        }
+        pw.println(" ***************************************");
+        pw.flush();
+        ConcurrentHashMap<String, ApnContext> apnCtxs = mApnContexts;
+        if (apnCtxs != null) {
+            Set<Entry<String, ApnContext>> apnCtxsSet = apnCtxs.entrySet();
+            pw.println(" mApnContexts size=" + apnCtxsSet.size());
+            for (Entry<String, ApnContext> entry : apnCtxsSet) {
+                entry.getValue().dump(fd, pw, args);
+            }
+            pw.println(" ***************************************");
+        } else {
+            pw.println(" mApnContexts=null");
+        }
+        pw.flush();
+        ArrayList<ApnSetting> apnSettings = mAllApnSettings;
+        if (apnSettings != null) {
+            pw.println(" mAllApnSettings size=" + apnSettings.size());
+            for (int i=0; i < apnSettings.size(); i++) {
+                pw.printf(" mAllApnSettings[%d]: %s\n", i, apnSettings.get(i));
+            }
+            pw.flush();
+        } else {
+            pw.println(" mAllApnSettings=null");
+        }
+        pw.println(" mPreferredApn=" + mPreferredApn);
+        pw.println(" mIsPsRestricted=" + mIsPsRestricted);
+        pw.println(" mIsDisposed=" + mIsDisposed);
+        pw.println(" mIntentReceiver=" + mIntentReceiver);
+        pw.println(" mReregisterOnReconnectFailure=" + mReregisterOnReconnectFailure);
+        pw.println(" canSetPreferApn=" + mCanSetPreferApn);
+        pw.println(" mApnObserver=" + mApnObserver);
+        pw.println(" getOverallState=" + getOverallState());
+        pw.println(" mDataConnectionAsyncChannels=%s\n" + mDataConnectionAcHashMap);
+        pw.println(" mAttached=" + mAttached.get());
+        pw.flush();
+    }
+
+    public String[] getPcscfAddress(String apnType) {
+        log("getPcscfAddress()");
+        ApnContext apnContext = null;
+
+        if(apnType == null){
+            log("apnType is null, return null");
+            return null;
+        }
+
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_EMERGENCY)) {
+            apnContext = mApnContextsById.get(DctConstants.APN_EMERGENCY_ID);
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
+            apnContext = mApnContextsById.get(DctConstants.APN_IMS_ID);
+        } else {
+            log("apnType is invalid, return null");
+            return null;
+        }
+
+        if (apnContext == null) {
+            log("apnContext is null, return null");
+            return null;
+        }
+
+        DcAsyncChannel dcac = apnContext.getDcAc();
+        String[] result = null;
+
+        if (dcac != null) {
+            result = dcac.getPcscfAddr();
+
+            for (int i = 0; i < result.length; i++) {
+                log("Pcscf[" + i + "]: " + result[i]);
+            }
+            return result;
+        }
+        return null;
+    }
+
+    /**
+     * Read APN configuration from Telephony.db for Emergency APN
+     * All opertors recognize the connection request for EPDN based on APN type
+     * PLMN name,APN name are not mandatory parameters
+     */
+    private void initEmergencyApnSetting() {
+        if (mEmergencyApn == null) {
+            // Operator Numeric is not available when sim records are not loaded.
+            // Query Telephony.db with APN type as EPDN request does not
+            // require APN name, plmn and all operators support same APN config.
+            // DB will contain only one entry for Emergency APN
+            /// M: We cannot get common emergency apn at first place in cursor, add empty numeric
+            //     as selection, can get only one emergency
+            String selection = "type=\"emergency\" and numeric=''";
+            Cursor cursor = mPhone.getContext().getContentResolver().query(
+                    Telephony.Carriers.CONTENT_URI, null, selection, null, null);
+            if (cursor != null) {
+                if (cursor.getCount() > 0) {
+                    if (cursor.moveToFirst()) {
+                        mEmergencyApn = makeApnSetting(cursor);
+                        log("Loaded default emergency APN: " + mEmergencyApn);
+                    }
+                } else {
+                    log("No record for emergency APN");
+                }
+                cursor.close();
+            } else {
+                log("No emergency APN found in DB");
+            }
+        } else {
+            log("mEmergencyApn already loaded: " + mEmergencyApn);
+        }
+    }
+
+    /**
+     * Add the Emergency APN settings to APN settings list
+     */
+    private void addEmergencyApnSetting() {
+        if(mEmergencyApn != null) {
+            if(mAllApnSettings == null) {
+                mAllApnSettings = new ArrayList<ApnSetting>();
+            } else {
+                boolean hasEmergencyApn = false;
+                for (ApnSetting apn : mAllApnSettings) {
+                    if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)) {
+                        hasEmergencyApn = true;
+                        break;
+                    }
+                }
+
+                if(hasEmergencyApn == false) {
+                    mAllApnSettings.add(mEmergencyApn);
+                } else {
+                    log("addEmergencyApnSetting - E-APN setting is already present");
+                }
+            }
+        }
+    }
+
+    private void cleanUpConnectionsOnUpdatedApns(boolean tearDown) {
+        if (DBG) log("cleanUpConnectionsOnUpdatedApns: tearDown=" + tearDown);
+        if (mAllApnSettings.isEmpty()) {
+            cleanUpAllConnections(tearDown, Phone.REASON_APN_CHANGED);
+        } else {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                if (VDBG) log("cleanUpConnectionsOnUpdatedApns for "+ apnContext);
+
+                boolean cleanUpApn = true;
+                ArrayList<ApnSetting> currentWaitingApns = apnContext.getWaitingApns();
+
+                if ((currentWaitingApns != null) && (!apnContext.isDisconnected())) {
+                    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+                    ArrayList<ApnSetting> waitingApns = buildWaitingApns(
+                            apnContext.getApnType(), radioTech);
+                    if (VDBG) log("new waitingApns:" + waitingApns);
+                    if (waitingApns.size() == currentWaitingApns.size()) {
+                        cleanUpApn = false;
+                        for (int i = 0; i < waitingApns.size(); i++) {
+                            final String currentWaitingApn =
+                                    currentWaitingApns.get(i).toStringIgnoreName(!VZW_FEATURE);
+                            final String waitingApn = waitingApns.get(i).toStringIgnoreName(
+                                    !VZW_FEATURE);
+                            if (!TextUtils.equals(currentWaitingApn, waitingApn)) {
+                                if (VDBG) log("new waiting apn is different at " + i);
+                                cleanUpApn = true;
+                                apnContext.setWaitingApns(waitingApns);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                if (cleanUpApn) {
+                    apnContext.setReason(Phone.REASON_APN_CHANGED);
+                    cleanUpConnection(true, apnContext);
+                }
+            }
+        }
+
+        if (!isConnected()) {
+            stopNetStatPoll();
+            stopDataStallAlarm();
+        }
+
+        mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+        if (DBG) log("mDisconnectPendingCount = " + mDisconnectPendingCount);
+        if (tearDown && mDisconnectPendingCount == 0) {
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+    }
+
+    /** M: throttling/high throughput
+     *  Used to specified the maximum concurrent data connections
+     */
+    protected int getPdpConnectionPoolSize() {
+        //here we keep the last DataConnection for low throughput APN
+        //so the pool size is the maximum value - 1
+        if (isSupportThrottlingApn()) {
+            return THROTTLING_MAX_PDP_SIZE;
+        } else {
+            //here we keep the last DataConnection for low throughput APN
+            //so the pool size is the maximum value - 1
+            return PDP_CONNECTION_POOL_SIZE - 1 > 0 ? PDP_CONNECTION_POOL_SIZE - 1 : 1;
+        }
+    }
+
+    private boolean isSupportThrottlingApn() {
+        return (THROTTLING_APN_ENABLED || (SystemProperties.getInt(
+                PROPERTY_THROTTLING_APN_ENABLED, 0) == 1));
+    }
+
+    private int generateDataConnectionId(String reqApnType, ApnSetting apnSetting) {
+        int id = -1;
+        // 0: internet, 1: tethering, 2~3: others, 4~6: IMS (non-throttling), 7: eMBMS
+        AtomicInteger idGenerator = mOthersUniqueIdGenerator;
+        for (String apn : HIGH_THROUGHPUT_APN) {
+            if (apnSetting != null && apnSetting.canHandleType(apn)
+                    && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                    && !apnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS)) {
+                idGenerator = mHighThroughputIdGenerator;
+                logd("generateDataConnectionId use high throughput DataConnection id generator");
+                break;
+            }
+        }
+        if (idGenerator != mHighThroughputIdGenerator) {
+            for (String apn : IMS_APN) {
+                if (PhoneConstants.APN_TYPE_EMERGENCY.equals(apn)
+                        && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)) {
+                    //skip since not request emergency apn
+                } else {
+                    if (apnSetting != null && apnSetting.canHandleType(apn)) {
+                        int idStart = MIN_ID_IMS_TROUGHPUT;
+                        if (PhoneConstants.APN_TYPE_EMERGENCY.equals(apn)) {
+                            idStart += 1;
+                        }
+                        // Set IMS: 4, EIMS: 5 for interface (fixed the interface)
+                        mImsUniqueIdGenerator.set(idStart);
+                        idGenerator = mImsUniqueIdGenerator;
+                        logd("generateDataConnectionId use ims DataConnection id generator");
+                        break;
+                    }
+                }
+            }
+        }
+
+        id = idGenerator.getAndIncrement();
+        if (idGenerator == mHighThroughputIdGenerator && id > MAX_ID_HIGH_TROUGHPUT) {
+            loge("Max id of highthrouthput is " + MAX_ID_HIGH_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        } else if (idGenerator == mOthersUniqueIdGenerator && id > MAX_ID_OTHERS_TROUGHPUT) {
+            loge("Max id of others is " + MAX_ID_OTHERS_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        } else if (idGenerator == mImsUniqueIdGenerator && id > MAX_ID_IMS_TROUGHPUT) {
+            loge("Max id of others is " + MAX_ID_IMS_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        }
+        log("generateDataConnectionId id = " + id);
+        return id;
+    }
+
+    // MTK
+    public void deactivatePdpByCid(int cid) {
+        mPhone.mCi.deactivateDataCall(cid, RILConstants.DEACTIVATE_REASON_PDP_RESET,
+                                      obtainMessage(DctConstants.EVENT_RESET_PDP_DONE, cid, 0));
+    }
+
+    // M: isVsimActive.
+    public boolean isVsimActive(int phoneId) {
+        int phoneNum = TelephonyManager.getDefault().getPhoneCount();
+        String vsimEnabled = null;
+        int act = 0 ;
+
+        for (int id = 0 ; id < phoneNum ; id++) {
+            if (id != phoneId) {
+                vsimEnabled = TelephonyManager.getDefault().getTelephonyProperty(
+                        id, PROPERTY_VSIM_ENABLE, "0");
+                act = ((vsimEnabled.isEmpty()) ? 0 : Integer.parseInt(vsimEnabled));
+                if (act == 2) {
+                    logd("Remote Vsim enabled on phone " + id +
+                            " and downloaded by phone" + phoneId);
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * M: syncApnToMd. Request for sync APN table to MD.
+     * apn;user;password;type(default,mms,...);protocol;roaming_protocol;
+     * authtype;carrier_enabled;max_conns;max_conns_time;wait_time;bearer_bitmask;inactive_timer
+     */
+    private void syncApnToMd() {
+        ArrayList<String> aryApn = null;
+        StringBuilder sb = null;
+        ArrayList<ApnSetting> tmpAllApnSettings = new ArrayList<ApnSetting>();
+        ApnSetting dunApnSetting = fetchDunApn();
+        boolean bAddDunApnSettingToList = true;
+
+        // create a temp 'tmpAllApnSettings' to copy from 'mAllApnSettings'
+        if (mAllApnSettings != null) {
+            tmpAllApnSettings.addAll(mAllApnSettings);
+        }
+
+        // check fetchDunApn() if return null, if not,
+        // then check the apn name if exist, if not, add it to 'tmpAllApnSettings'
+        if (dunApnSetting != null) {
+            for (ApnSetting apn : tmpAllApnSettings) {
+                if (TextUtils.equals(apn.apn, dunApnSetting.apn)) {
+                    bAddDunApnSettingToList = false;
+                    break;
+                }
+            }
+            log("syncApnToMd: bAddToApnSettingList = " + bAddDunApnSettingToList);
+            if (bAddDunApnSettingToList) {
+                tmpAllApnSettings.add(dunApnSetting);
+            }
+        }
+
+        if (!tmpAllApnSettings.isEmpty()) {
+            aryApn = new ArrayList<String>();
+            for (ApnSetting apn : tmpAllApnSettings) {
+                sb = new StringBuilder();
+                // Replace ";" with "/3B" to prevent the misjudgement of delimiter
+                String tmp = null;
+                if (apn.apn != null) {
+                    tmp = apn.apn.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (apn.user != null) {
+                    tmp = apn.user.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (apn.password != null) {
+                    tmp = apn.password.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_ALL)) {
+                    for (int j = 0; j < PhoneConstants.APN_TYPES.length; j++) {
+                        sb.append(PhoneConstants.APN_TYPES[j]);
+                        if (j < (PhoneConstants.APN_TYPES.length - 1)) {
+                            sb.append(",");
+                        }
+                    }
+                } else {
+                    for (int j = 0; j < apn.types.length; j++) {
+                        sb.append(apn.types[j]);
+                        if (j < (apn.types.length - 1)) {
+                            sb.append(",");
+                        }
+                    }
+                }
+                sb.append(";");
+                sb.append(apn.protocol);
+                sb.append(";");
+                sb.append(apn.roamingProtocol);
+                sb.append(";");
+                int authType = apn.authType;
+                if (authType == -1) {
+                    authType = TextUtils.isEmpty(apn.user) ? RILConstants.SETUP_DATA_AUTH_NONE
+                            : RILConstants.SETUP_DATA_AUTH_PAP_CHAP;
+                }
+                sb.append(authType);
+                sb.append(";");
+                sb.append(apn.carrierEnabled ? 1 : 0);
+                sb.append(";");
+                sb.append(apn.maxConns);
+                sb.append(";");
+                sb.append(apn.maxConnsTime);
+                sb.append(";");
+                sb.append(apn.waitTime);
+                sb.append(";");
+                sb.append(apn.bearerBitmask);
+                sb.append(";");
+                sb.append(apn.inactiveTimer);
+                log("syncApnToMd: apn: " + sb.toString());
+                aryApn.add(sb.toString());
+            }
+            if (aryApn.size() > 0) {
+                mPhone.mCi.syncApnTable(aryApn.toArray(new String[aryApn.size()]), null);
+            }
+        } else {
+            log("syncApnToMd: tmpAllApnSettings is empty!");
+        }
+    }
+
+    /**
+     * M: getClassType.
+     *
+     * @param apn ApnSetting
+     * @return int for class type
+     */
+    public int getClassType(ApnSetting apn) {
+        int classType = APN_CLASS_3;
+
+        if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)
+            || VZW_EMERGENCY_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_0;
+        } else if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IMS)
+            || VZW_IMS_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_1;
+        } else if (VZW_ADMIN_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_2;
+        } else if (VZW_APP_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_4;
+        } else if (VZW_800_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_5;
+        } else if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_DEFAULT)) {
+            classType = APN_CLASS_3;
+        } else {
+            log("getClassType: set to default class 3");
+        }
+
+        logd("getClassType:" + classType);
+        return classType;
+    }
+
+    /**
+     * M: getClassTypeApn.
+     *
+     * @param classType APN class type
+     * @return ApnSetting for class type apn
+     */
+    public ApnSetting getClassTypeApn(int classType) {
+        ApnSetting classTypeApn = null;
+        String apnName = "";
+
+        if (APN_CLASS_0 == classType) {
+            apnName = VZW_EMERGENCY_NI;
+        } else if (APN_CLASS_1 == classType) {
+            apnName = VZW_IMS_NI;
+        } else if (APN_CLASS_2 == classType) {
+            apnName = VZW_ADMIN_NI;
+        } else if (APN_CLASS_3 == classType) {
+            apnName = VZW_INTERNET_NI;
+        } else if (APN_CLASS_4 == classType) {
+            apnName = VZW_APP_NI;
+        } else if (APN_CLASS_5 == classType) {
+            apnName = VZW_800_NI;
+        } else {
+            log("getClassTypeApn: can't handle class:" + classType);
+            return null;
+        }
+
+        if (mAllApnSettings != null) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apnName.compareToIgnoreCase(apn.apn) == 0) {
+                    classTypeApn = apn;
+                }
+            }
+        }
+
+        logd("getClassTypeApn:" + classTypeApn + ", class:" + classType);
+        return classTypeApn;
+    }
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    private void onSharedDefaultApnState(int newDefaultRefCount) {
+        logd("onSharedDefaultApnState: newDefaultRefCount = " + newDefaultRefCount
+                + ", curDefaultRefCount = " + mDefaultRefCount);
+
+        if(newDefaultRefCount != mDefaultRefCount) {
+            if (newDefaultRefCount > 1) {
+                mIsSharedDefaultApn = true;
+            } else {
+                mIsSharedDefaultApn = false;
+            }
+            mDefaultRefCount = newDefaultRefCount;
+            logd("onSharedDefaultApnState: mIsSharedDefaultApn = " + mIsSharedDefaultApn);
+            notifySharedDefaultApn(mIsSharedDefaultApn);
+        }
+    }
+
+    public void onSetLteAccessStratumReport(boolean enabled, Message response) {
+        mPhone.mCi.setLteAccessStratumReport(enabled, response);
+    }
+
+    public void onSetLteUplinkDataTransfer(int timeMillis, Message response) {
+        for(ApnContext apnContext : mApnContexts.values()) {
+            if(PhoneConstants.APN_TYPE_DEFAULT.equals(apnContext.getApnType())) {
+                try {
+                    int interfaceId = apnContext.getDcAc().getCidSync();
+                    mPhone.mCi.setLteUplinkDataTransfer(timeMillis, interfaceId, response);
+                } catch (Exception e) {
+                    loge("getDcAc fail!");
+                    e.printStackTrace();
+                    if (response != null) {
+                        AsyncResult.forMessage(response, null,
+                                new CommandException(CommandException.Error.GENERIC_FAILURE));
+                        response.sendToTarget();
+                    }
+                }
+            }
+        }
+    }
+
+    private void notifySharedDefaultApn(boolean isSharedDefaultApn) {
+        mPhone.notifySharedDefaultApnStateChanged(isSharedDefaultApn);
+    }
+
+    // TODO: Should this move to NW frameworks to handle?
+    private void notifyLteAccessStratumChanged(int lteAccessStratumDataState) {
+        mLteAccessStratumDataState = (lteAccessStratumDataState == LTE_AS_CONNECTED) ?
+                PhoneConstants.LTE_ACCESS_STRATUM_STATE_CONNECTED :
+                PhoneConstants.LTE_ACCESS_STRATUM_STATE_IDLE;
+        logd("notifyLteAccessStratumChanged mLteAccessStratumDataState = "
+                + mLteAccessStratumDataState);
+        mPhone.notifyLteAccessStratumChanged(mLteAccessStratumDataState);
+    }
+
+    // TODO: Should this move to NW frameworks to handle?
+    private void notifyPsNetworkTypeChanged(int newRilNwType) {
+        int newNwType = mPhone.getServiceState().rilRadioTechnologyToNetworkTypeEx(newRilNwType);
+        logd("notifyPsNetworkTypeChanged mNetworkType = " + mNetworkType
+                + ", newNwType = " + newNwType
+                + ", newRilNwType = " + newRilNwType);
+        if (newNwType != mNetworkType) {
+            mNetworkType = newNwType;
+            mPhone.notifyPsNetworkTypeChanged(mNetworkType);
+        }
+    }
+
+    public String getLteAccessStratumState() {
+        return mLteAccessStratumDataState;
+    }
+
+    public boolean isSharedDefaultApn() {
+        return mIsSharedDefaultApn;
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Polling stuff
+     */
+    private void resetPollStats() {
+        mTxPkts = -1;
+        mRxPkts = -1;
+        mNetStatPollPeriod = POLL_NETSTAT_MILLIS;
+    }
+
+    private void startNetStatPoll() {
+        if (getOverallState() == DctConstants.State.CONNECTED
+                && mNetStatPollEnabled == false) {
+            if (DBG) {
+                log("startNetStatPoll");
+            }
+            resetPollStats();
+            mNetStatPollEnabled = true;
+            mPollNetStat.run();
+        }
+        if (mPhone != null) {
+            mPhone.notifyDataActivity();
+        }
+    }
+
+    private void stopNetStatPoll() {
+        mNetStatPollEnabled = false;
+        removeCallbacks(mPollNetStat);
+        if (DBG) {
+            log("stopNetStatPoll");
+        }
+
+        // To sync data activity icon in the case of switching data connection to send MMS.
+        if (mPhone != null) {
+            mPhone.notifyDataActivity();
+        }
+    }
+
+    public void sendStartNetStatPoll(DctConstants.Activity activity) {
+        Message msg = obtainMessage(DctConstants.CMD_NET_STAT_POLL);
+        msg.arg1 = DctConstants.ENABLED;
+        msg.obj = activity;
+        sendMessage(msg);
+    }
+
+    private void handleStartNetStatPoll(DctConstants.Activity activity) {
+        startNetStatPoll();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+        setActivity(activity);
+    }
+
+    public void sendStopNetStatPoll(DctConstants.Activity activity) {
+        Message msg = obtainMessage(DctConstants.CMD_NET_STAT_POLL);
+        msg.arg1 = DctConstants.DISABLED;
+        msg.obj = activity;
+        sendMessage(msg);
+    }
+
+    private void handleStopNetStatPoll(DctConstants.Activity activity) {
+        stopNetStatPoll();
+        stopDataStallAlarm();
+        setActivity(activity);
+    }
+
+    private void updateDataActivity() {
+        long sent, received;
+
+        DctConstants.Activity newActivity;
+
+        TxRxSum preTxRxSum = new TxRxSum(mTxPkts, mRxPkts);
+        TxRxSum curTxRxSum = new TxRxSum();
+        curTxRxSum.updateTxRxSum();
+        mTxPkts = curTxRxSum.txPkts;
+        mRxPkts = curTxRxSum.rxPkts;
+
+        if (VDBG) {
+            log("updateDataActivity: curTxRxSum=" + curTxRxSum + " preTxRxSum=" + preTxRxSum);
+        }
+
+        if (mNetStatPollEnabled && (preTxRxSum.txPkts > 0 || preTxRxSum.rxPkts > 0)) {
+            sent = mTxPkts - preTxRxSum.txPkts;
+            received = mRxPkts - preTxRxSum.rxPkts;
+
+            if (VDBG)
+                log("updateDataActivity: sent=" + sent + " received=" + received);
+            if (sent > 0 && received > 0) {
+                newActivity = DctConstants.Activity.DATAINANDOUT;
+            } else if (sent > 0 && received == 0) {
+                newActivity = DctConstants.Activity.DATAOUT;
+            } else if (sent == 0 && received > 0) {
+                newActivity = DctConstants.Activity.DATAIN;
+            } else {
+                newActivity = (mActivity == DctConstants.Activity.DORMANT) ?
+                        mActivity : DctConstants.Activity.NONE;
+            }
+
+            if (mActivity != newActivity && mIsScreenOn) {
+                if (VDBG)
+                    log("updateDataActivity: newActivity=" + newActivity);
+                mActivity = newActivity;
+                mPhone.notifyDataActivity();
+            }
+        }
+    }
+
+    private void handlePcoData(AsyncResult ar) {
+        if (ar.exception != null) {
+            Rlog.e(LOG_TAG, "PCO_DATA exception: " + ar.exception);
+            return;
+        }
+        PcoData pcoData = (PcoData)(ar.result);
+        ArrayList<DataConnection> dcList = new ArrayList<>();
+        DataConnection temp = mDcc.getActiveDcByCid(pcoData.cid);
+        if (temp != null) {
+            dcList.add(temp);
+        }
+        if (dcList.size() == 0) {
+            Rlog.e(LOG_TAG, "PCO_DATA for unknown cid: " + pcoData.cid + ", inferring");
+            for (DataConnection dc : mDataConnections.values()) {
+                final int cid = dc.getCid();
+                if (cid == pcoData.cid) {
+                    if (VDBG) Rlog.d(LOG_TAG, "  found " + dc);
+                    dcList.clear();
+                    dcList.add(dc);
+                    break;
+                }
+                // check if this dc is still connecting
+                if (cid == -1) {
+                    for (ApnContext apnContext : dc.mApnContexts.keySet()) {
+                        if (apnContext.getState() == DctConstants.State.CONNECTING) {
+                            if (VDBG) Rlog.d(LOG_TAG, "  found potential " + dc);
+                            dcList.add(dc);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (dcList.size() == 0) {
+            Rlog.e(LOG_TAG, "PCO_DATA - couldn't infer cid");
+            return;
+        }
+        for (DataConnection dc : dcList) {
+            if (dc.mApnContexts.size() == 0) {
+                break;
+            }
+            // send one out for each apn type in play
+            for (ApnContext apnContext : dc.mApnContexts.keySet()) {
+                String apnType = apnContext.getApnType();
+
+                final Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
+                intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnType);
+                intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, pcoData.bearerProto);
+                intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, pcoData.pcoId);
+                intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, pcoData.contents);
+                mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+            }
+        }
+    }
+
+    /**
+     * Data-Stall
+     */
+    // Recovery action taken in case of data stall
+    private static class RecoveryAction {
+        public static final int GET_DATA_CALL_LIST      = 0;
+        public static final int CLEANUP                 = 1;
+        public static final int REREGISTER              = 2;
+        public static final int RADIO_RESTART           = 3;
+        public static final int RADIO_RESTART_WITH_PROP = 4;
+
+        private static boolean isAggressiveRecovery(int value) {
+            return ((value == RecoveryAction.CLEANUP) ||
+                    (value == RecoveryAction.REREGISTER) ||
+                    (value == RecoveryAction.RADIO_RESTART) ||
+                    (value == RecoveryAction.RADIO_RESTART_WITH_PROP));
+        }
+    }
+
+    private int getRecoveryAction() {
+        ///M: Make data stall mechanism support multiple phone @{
+        //int action = Settings.System.getInt(mResolver,
+        //        "radio.data.stall.recovery.action", RecoveryAction.GET_DATA_CALL_LIST);
+        String actionName = "radio.data.stall.recovery.action" + String.valueOf(mPhone.getPhoneId());
+        int action = Settings.System.getInt(mResolver,
+                actionName, RecoveryAction.GET_DATA_CALL_LIST);
+        /// @}
+        if (VDBG_STALL) log("getRecoveryAction: " + action);
+        return action;
+    }
+
+    private void putRecoveryAction(int action) {
+        ///M: Make data stall mechanism support multiple phone @{
+        //Settings.System.putInt(mResolver, "radio.data.stall.recovery.action", action);
+        String actionName = "radio.data.stall.recovery.action" + String.valueOf(mPhone.getPhoneId());
+        Settings.System.putInt(mResolver, actionName, action);
+        /// @}
+        if (VDBG_STALL) log("putRecoveryAction: " + action);
+    }
+
+    private void doRecovery() {
+        if (getOverallState() == DctConstants.State.CONNECTED) {
+            // Go through a series of recovery steps, each action transitions to the next action
+            final int recoveryAction = getRecoveryAction();
+            TelephonyMetrics.getInstance().writeDataStallEvent(mPhone.getPhoneId(), recoveryAction);
+            switch (recoveryAction) {
+            case RecoveryAction.GET_DATA_CALL_LIST:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_GET_DATA_CALL_LIST,
+                        mSentSinceLastRecv);
+                if (DBG) log("doRecovery() get data call list");
+                mPhone.mCi.getDataCallList(obtainMessage(DctConstants.EVENT_DATA_STATE_CHANGED));
+                putRecoveryAction(RecoveryAction.CLEANUP);
+                break;
+            case RecoveryAction.CLEANUP:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_CLEANUP, mSentSinceLastRecv);
+                /* M: Start - abnormal event logging for logger */
+                Intent intent = new Intent(TelephonyIntents.ACTION_EXCEPTION_HAPPENED);
+                intent.putExtra("Reason", "SmartLogging");
+                intent.putExtra("from_where", "DCT");
+                mPhone.getContext().sendBroadcast(intent);
+                log("Broadcast for SmartLogging - NO DATA");
+                /* M: End - abnormal event logging for logger */
+                if (DBG) log("doRecovery() cleanup all connections");
+                cleanUpAllConnections(Phone.REASON_PDP_RESET);
+                putRecoveryAction(RecoveryAction.REREGISTER);
+                break;
+            case RecoveryAction.REREGISTER:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_REREGISTER,
+                        mSentSinceLastRecv);
+                if (DBG) log("doRecovery() re-register");
+                mPhone.getServiceStateTracker().reRegisterNetwork(null); // AOSP
+                // M: re-register PS domain only
+                //   Not to use mPhone.getServiceStateTracker().reRegisterNetwork
+                //   Re-register may not be triggered by it and both CS and PS could be impacted
+                //   FIXME: To choose AOSP or use MTK soltuion.
+                /// DataConnectionHelper.getInstance().reRegisterPsNetwork();
+                putRecoveryAction(RecoveryAction.RADIO_RESTART);
+                break;
+            case RecoveryAction.RADIO_RESTART:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART,
+                        mSentSinceLastRecv);
+                if (DBG) log("restarting radio");
+                putRecoveryAction(RecoveryAction.RADIO_RESTART_WITH_PROP);
+                restartRadio();
+                break;
+            case RecoveryAction.RADIO_RESTART_WITH_PROP:
+                // This is in case radio restart has not recovered the data.
+                // It will set an additional "gsm.radioreset" property to tell
+                // RIL or system to take further action.
+                // The implementation of hard reset recovery action is up to OEM product.
+                // Once RADIO_RESET property is consumed, it is expected to set back
+                // to false by RIL.
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART_WITH_PROP, -1);
+                if (DBG) log("restarting radio with gsm.radioreset to true");
+                SystemProperties.set(RADIO_RESET_PROPERTY, "true");
+                // give 1 sec so property change can be notified.
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {}
+                restartRadio();
+                putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+                break;
+            default:
+                throw new RuntimeException("doRecovery: Invalid recoveryAction=" +
+                    recoveryAction);
+            }
+            mSentSinceLastRecv = 0;
+        }
+    }
+
+    private void updateDataStallInfo() {
+        long sent, received;
+
+        TxRxSum preTxRxSum = new TxRxSum(mDataStallTxRxSum);
+        mDataStallTxRxSum.updateTxRxSum();
+
+        if (VDBG_STALL) {
+            log("updateDataStallInfo: mDataStallTxRxSum=" + mDataStallTxRxSum +
+                    " preTxRxSum=" + preTxRxSum);
+        }
+
+        sent = mDataStallTxRxSum.txPkts - preTxRxSum.txPkts;
+        received = mDataStallTxRxSum.rxPkts - preTxRxSum.rxPkts;
+
+        if (RADIO_TESTS) {
+            if (SystemProperties.getBoolean("radio.test.data.stall", false)) {
+                log("updateDataStallInfo: radio.test.data.stall true received = 0;");
+                received = 0;
+            }
+        }
+        if ( sent > 0 && received > 0 ) {
+            if (VDBG_STALL) log("updateDataStallInfo: IN/OUT");
+            mSentSinceLastRecv = 0;
+            putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+        } else if (sent > 0 && received == 0) {
+            if (mPhone.getState() == PhoneConstants.State.IDLE) {
+                mSentSinceLastRecv += sent;
+            } else {
+                mSentSinceLastRecv = 0;
+            }
+            if (DBG) {
+                log("updateDataStallInfo: OUT sent=" + sent +
+                        " mSentSinceLastRecv=" + mSentSinceLastRecv);
+            }
+        } else if (sent == 0 && received > 0) {
+            if (VDBG_STALL) log("updateDataStallInfo: IN");
+            mSentSinceLastRecv = 0;
+            putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+        } else {
+            if (VDBG_STALL) log("updateDataStallInfo: NONE");
+        }
+    }
+
+    private void onDataStallAlarm(int tag) {
+        if (mDataStallAlarmTag != tag) {
+            if (DBG) {
+                log("onDataStallAlarm: ignore, tag=" + tag + " expecting " + mDataStallAlarmTag);
+            }
+            return;
+        }
+        updateDataStallInfo();
+
+        int hangWatchdogTrigger = Settings.Global.getInt(mResolver,
+                Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT,
+                NUMBER_SENT_PACKETS_OF_HANG);
+
+        boolean suspectedStall = DATA_STALL_NOT_SUSPECTED;
+        if (mSentSinceLastRecv >= hangWatchdogTrigger) {
+            if (DBG) {
+                log("onDataStallAlarm: tag=" + tag + " do recovery action=" + getRecoveryAction());
+            }
+            if (isOnlyIMSorEIMSPdnConnected() || skipDataStallAlarm()) {
+                log("onDataStallAlarm: only IMS or EIMS Connected, or switch data-stall off, "
+                        + "skip it!");
+            } else {
+                suspectedStall = DATA_STALL_SUSPECTED;
+                sendMessage(obtainMessage(DctConstants.EVENT_DO_RECOVERY));
+            }
+        } else {
+            if (VDBG_STALL) {
+                log("onDataStallAlarm: tag=" + tag + " Sent " + String.valueOf(mSentSinceLastRecv) +
+                    " pkts since last received, < watchdogTrigger=" + hangWatchdogTrigger);
+            }
+        }
+        startDataStallAlarm(suspectedStall);
+    }
+
+    private void startDataStallAlarm(boolean suspectedStall) {
+        int nextAction = getRecoveryAction();
+        int delayInMs;
+
+        if (mDataStallDetectionEnabled && getOverallState() == DctConstants.State.CONNECTED) {
+            // If screen is on or data stall is currently suspected, set the alarm
+            // with an aggressive timeout.
+            if (mIsScreenOn || suspectedStall || RecoveryAction.isAggressiveRecovery(nextAction)) {
+                delayInMs = Settings.Global.getInt(mResolver,
+                        Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
+                        DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
+            } else {
+                delayInMs = Settings.Global.getInt(mResolver,
+                        Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
+                        DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
+            }
+
+            mDataStallAlarmTag += 1;
+            if (VDBG_STALL) {
+                log("startDataStallAlarm: tag=" + mDataStallAlarmTag +
+                        " delay=" + (delayInMs / 1000) + "s");
+            }
+            Intent intent = new Intent(INTENT_DATA_STALL_ALARM);
+            intent.putExtra(DATA_STALL_ALARM_TAG_EXTRA, mDataStallAlarmTag);
+            ///M: Make data stall mechanism support multiple phone @{
+            //mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent,
+            //          PendingIntent.FLAG_UPDATE_CURRENT);
+            mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(),
+                    mPhone.getPhoneId(), intent, PendingIntent.FLAG_UPDATE_CURRENT);
+            /// @}
+            mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    SystemClock.elapsedRealtime() + delayInMs, mDataStallAlarmIntent);
+        } else {
+            if (VDBG_STALL) {
+                log("startDataStallAlarm: NOT started, no connection tag=" + mDataStallAlarmTag);
+            }
+        }
+    }
+
+    private void stopDataStallAlarm() {
+        if (VDBG_STALL) {
+            log("stopDataStallAlarm: current tag=" + mDataStallAlarmTag +
+                    " mDataStallAlarmIntent=" + mDataStallAlarmIntent);
+        }
+        mDataStallAlarmTag += 1;
+        if (mDataStallAlarmIntent != null) {
+            mAlarmManager.cancel(mDataStallAlarmIntent);
+            mDataStallAlarmIntent = null;
+        }
+    }
+
+    private void restartDataStallAlarm() {
+        if (isConnected() == false) return;
+        // To be called on screen status change.
+        // Do not cancel the alarm if it is set with aggressive timeout.
+        int nextAction = getRecoveryAction();
+
+        if (RecoveryAction.isAggressiveRecovery(nextAction)) {
+            if (DBG) log("restartDataStallAlarm: action is pending. not resetting the alarm.");
+            return;
+        }
+        if (VDBG_STALL) log("restartDataStallAlarm: stop then start.");
+        stopDataStallAlarm();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+    }
+
+    /**
+     * Provisioning APN
+     */
+    private void onActionIntentProvisioningApnAlarm(Intent intent) {
+        if (DBG) log("onActionIntentProvisioningApnAlarm: action=" + intent.getAction());
+        Message msg = obtainMessage(DctConstants.EVENT_PROVISIONING_APN_ALARM,
+                intent.getAction());
+        msg.arg1 = intent.getIntExtra(PROVISIONING_APN_ALARM_TAG_EXTRA, 0);
+        sendMessage(msg);
+    }
+
+    private void startProvisioningApnAlarm() {
+        int delayInMs = Settings.Global.getInt(mResolver,
+                                Settings.Global.PROVISIONING_APN_ALARM_DELAY_IN_MS,
+                                PROVISIONING_APN_ALARM_DELAY_IN_MS_DEFAULT);
+        if (Build.IS_DEBUGGABLE) {
+            // Allow debug code to use a system property to provide another value
+            String delayInMsStrg = Integer.toString(delayInMs);
+            delayInMsStrg = System.getProperty(DEBUG_PROV_APN_ALARM, delayInMsStrg);
+            try {
+                delayInMs = Integer.parseInt(delayInMsStrg);
+            } catch (NumberFormatException e) {
+                loge("startProvisioningApnAlarm: e=" + e);
+            }
+        }
+        mProvisioningApnAlarmTag += 1;
+        if (DBG) {
+            log("startProvisioningApnAlarm: tag=" + mProvisioningApnAlarmTag +
+                    " delay=" + (delayInMs / 1000) + "s");
+        }
+        Intent intent = new Intent(INTENT_PROVISIONING_APN_ALARM);
+        intent.putExtra(PROVISIONING_APN_ALARM_TAG_EXTRA, mProvisioningApnAlarmTag);
+        mProvisioningApnAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent,
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + delayInMs, mProvisioningApnAlarmIntent);
+    }
+
+    private void stopProvisioningApnAlarm() {
+        if (DBG) {
+            log("stopProvisioningApnAlarm: current tag=" + mProvisioningApnAlarmTag +
+                    " mProvsioningApnAlarmIntent=" + mProvisioningApnAlarmIntent);
+        }
+        mProvisioningApnAlarmTag += 1;
+        if (mProvisioningApnAlarmIntent != null) {
+            mAlarmManager.cancel(mProvisioningApnAlarmIntent);
+            mProvisioningApnAlarmIntent = null;
+        }
+    }
+
+    public boolean isOnlyIMSorEIMSPdnConnected() {
+        if (mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == true) {
+            logd("ignore IMS/EIMS special handle on 93MD");
+            return false;
+        }
+
+        boolean bIsOnlyIMSorEIMSConnected = false;
+        if (MTK_IMS_SUPPORT) {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                String apnType = apnContext.getApnType();
+                if (!apnContext.isDisconnected()) {
+                    if (apnType.equals(PhoneConstants.APN_TYPE_IMS) == false &&
+                        apnType.equals(PhoneConstants.APN_TYPE_EMERGENCY) == false) {
+                        logd("apnType: " + apnType + " is still conntected!!");
+                    // At least one context (not ims or Emergency) was not disconnected return false
+                        bIsOnlyIMSorEIMSConnected = false;
+                        break;
+                    } else { //IMS or/and Emergency is/are still connected
+                        bIsOnlyIMSorEIMSConnected = true;
+                    }
+                }
+            }
+        }
+        return bIsOnlyIMSorEIMSConnected;
+    }
+
+    /**
+    * M: get the string of ims ApnSetting in the list.
+    *
+    * @param apnSettings
+    * @return
+    */
+    private String getIMSApnSetting(ArrayList<ApnSetting> apnSettings) {
+        if (apnSettings == null || apnSettings.size() == 0) {
+            return "";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        for (ApnSetting t : apnSettings) {
+            if (t.canHandleType("ims")) {
+                sb.append(apnToStringIgnoreName(t));
+            }
+        }
+        logd("getIMSApnSetting, apnsToStringIgnoreName: sb = " + sb.toString());
+        return sb.toString();
+    }
+
+    private boolean isIMSApnSettingChanged(ArrayList<ApnSetting> prevApnList,
+                                        ArrayList<ApnSetting> currApnList) {
+        boolean bImsApnChanged = false;
+        String prevIMSApn = getIMSApnSetting(prevApnList);
+        String currIMSApn = getIMSApnSetting(currApnList);
+
+        if (!prevIMSApn.isEmpty()) {
+            if (!TextUtils.equals(prevIMSApn, currIMSApn)) {
+                bImsApnChanged = true;
+            }
+        }
+
+        return bImsApnChanged;
+    }
+
+    /**
+     * M: Similar as ApnSetting.toString except the carrier is not considerred
+     * because some operator need to change the APN name when locale changed.
+     *
+     * @param apnSetting
+     * @return
+     */
+    private String apnToStringIgnoreName(ApnSetting apnSetting) {
+        if (apnSetting == null) {
+            return null;
+        }
+
+        StringBuilder sb = new StringBuilder();
+        sb.append(apnSetting.id)
+        .append(", ").append(apnSetting.numeric)
+        .append(", ").append(apnSetting.apn)
+        .append(", ").append(apnSetting.proxy)
+        .append(", ").append(apnSetting.mmsc)
+        .append(", ").append(apnSetting.mmsProxy)
+        .append(", ").append(apnSetting.mmsPort)
+        .append(", ").append(apnSetting.port)
+        .append(", ").append(apnSetting.authType).append(", ");
+        for (int i = 0; i < apnSetting.types.length; i++) {
+            sb.append(apnSetting.types[i]);
+            if (i < apnSetting.types.length - 1) {
+                sb.append(" | ");
+            }
+        }
+        sb.append(", ").append(apnSetting.protocol);
+        sb.append(", ").append(apnSetting.roamingProtocol);
+        sb.append(", ").append(apnSetting.carrierEnabled);
+        sb.append(", ").append(apnSetting.bearerBitmask);
+        logd("apnToStringIgnoreName: sb = " + sb.toString());
+        return sb.toString();
+    }
+
+    // M: Is data allowed even if mobile data off
+    private boolean isDataAllowedAsOff(String apnType) {
+        boolean isDataAllowedAsOff = false;
+        if (!BSP_PACKAGE && mGsmDctExt != null) {
+            isDataAllowedAsOff = mGsmDctExt.isDataAllowedAsOff(apnType);
+        }
+
+        // M: Vsim
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)
+                && isVsimActive(mPhone.getPhoneId())) {
+            logd("Vsim is enabled, set isDataAllowedAsOff true");
+            isDataAllowedAsOff = true;
+        }
+
+        if (getDomesticRoamingEnabledBySim()) {
+            boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+            boolean bIsInternationalRoaming = isInternationalRoaming();
+            if (DBG) {
+                log("isDataAllowedAsOff: bDataOnRoamingEnabled=" + bDataOnRoamingEnabled
+                        + ", bIsInternationalRoaming=" + bIsInternationalRoaming);
+            }
+
+            if (bIsInternationalRoaming && bDataOnRoamingEnabled) {
+                // M: International data roaming is allowed even if mobile data off.
+                isDataAllowedAsOff = true;
+            }
+        }
+
+        return isDataAllowedAsOff;
+    }
+
+    // M: Notify mobile data change
+    protected void notifyMobileDataChange(int enabled) {
+        logd("notifyMobileDataChange, enable = " + enabled);
+        Intent intent = new Intent(DataSubSelector.ACTION_MOBILE_DATA_ENABLE);
+        intent.putExtra(DataSubSelector.EXTRA_MOBILE_DATA_ENABLE_REASON, enabled);
+        mPhone.getContext().sendBroadcast(intent);
+    }
+
+    // M: Set mobile data property
+    private void setUserDataProperty(boolean enabled) {
+        int phoneId = mPhone.getPhoneId();
+        String dataOnIccid = "0";
+
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            log("invalid phone id, don't update");
+            return;
+        }
+
+        if (enabled) {
+            dataOnIccid = SystemProperties.get(PROPERTY_ICCID[phoneId], "0");
+        }
+
+        logd("setUserDataProperty:" + dataOnIccid);
+        TelephonyManager.getDefault().setTelephonyProperty(phoneId, PROPERTY_MOBILE_DATA_ENABLE,
+                dataOnIccid);
+    }
+
+    // M: JPN IA Start
+    private void handleSetResume() {
+        if (!SubscriptionManager.isValidPhoneId(mPhone.getPhoneId())) return;
+        mPhone.mCi.setResumeRegistration(mSuspendId, null);
+    }
+
+    private void handleRegistrationSuspend(AsyncResult ar) {
+        if (ar.exception == null && ar.result != null) {
+            if (DBG) log("handleRegistrationSuspend: createAllApnList and set initial attach APN");
+            mSuspendId = ((int[]) ar.result)[0];
+            log("handleRegistrationSuspend: suspending with Id=" + mSuspendId);
+            synchronized (mNeedsResumeModemLock) {
+                mNeedsResumeModem = true;
+            }
+            createAllApnList();
+            setInitialAttachApn();
+        } else {
+            log("handleRegistrationSuspend: AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+
+    private void handlePlmnChange(AsyncResult ar) {
+        if (ar.exception == null && ar.result != null) {
+            String[] plmnString = (String[]) ar.result;
+
+            for (int i = 0; i < plmnString.length; i++) {
+                logd("plmnString[" + i + "]=" + plmnString[i]);
+            }
+            mRegion = getRegion(plmnString[0]);
+
+            IccRecords r = mIccRecords.get();
+            String operator = (r != null) ? r.getOperatorNumeric() : "";
+            if (!TextUtils.isEmpty(operator) &&
+                    isNeedToResumeMd() == false &&
+                    mPhone.getPhoneId() ==
+                            SubscriptionManager.getPhoneId(
+                            SubscriptionController.getInstance().getDefaultDataSubId())){
+                logd("handlePlmnChange: createAllApnList and set initial attach APN");
+                createAllApnList();
+                setInitialAttachApn();
+            } else {
+                logd("No need to update APN for Operator");
+            }
+        } else {
+            log("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private int getRegion(String plmn) {
+        String currentMcc;
+        if (plmn == null || plmn.equals("") || plmn.length() < 5) {
+            logd("[getRegion] Invalid PLMN");
+            return REGION_UNKNOWN;
+        }
+
+        currentMcc = plmn.substring(0, 3);
+        for (String mcc : MCC_TABLE_TEST) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] Test PLMN");
+                return REGION_UNKNOWN;
+            }
+        }
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] REGION_DOMESTIC");
+                return REGION_DOMESTIC;
+            } else {
+                logd("[getRegion] REGION_FOREIGN");
+                return REGION_FOREIGN;
+            }
+        }
+        logd("[getRegion] REGION_UNKNOWN");
+        return REGION_UNKNOWN;
+    }
+
+    public boolean getImsEnabled() {
+        boolean isImsEnabled = (ImsManager.isVolteEnabledByPlatform(mPhone.getContext()) &&
+                ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext()));
+        logd("getImsEnabled: getInt isImsEnabled=" + isImsEnabled);
+        return isImsEnabled;
+    }
+
+    /* M: VDF syncApnTableToRds. Request for two cmds as follow:
+     * (apn;apn_type(profile_id|profile_id);rat;protocol)
+     * @param ArrayList<ApnSetting> apnlist
+     * @return void
+     */
+    private void syncApnTableToRds(ArrayList<ApnSetting> apnlist) {
+        log("syncApnTableToRds: E");
+        ApnSetting apn;
+        ArrayList<String> aryApn = null;
+        StringBuilder sb = null;
+        int numOfProfileId = 0;
+        int rat = 1;
+
+        if (apnlist != null && apnlist.size() > 0) {
+            aryApn = new ArrayList<String>();
+            for (int i = 0; i < apnlist.size(); i++) {
+                apn = apnlist.get(i);
+                if (TextUtils.isEmpty(apn.apn)) {
+                    log("syncApnTableToRds: apn name is empty");
+                    continue;
+                }
+                sb = new StringBuilder();
+                sb.append(apn.apn);
+                sb.append(";");
+                numOfProfileId = 0;
+                for (int j = 0; j < apn.types.length; j++) {
+                    int profileId = getApnProfileID(apn.types[j]);
+                    if (profileId != RILConstants.DATA_PROFILE_INVALID) {
+                        if (numOfProfileId > 0) {
+                            sb.append("|");
+                        }
+                        sb.append(profileId);
+                        numOfProfileId++;
+                    }
+                }
+                sb.append(";");
+                rat = getApnRatByBearer(apn.bearerBitmask);
+                log("apn.rat: " + rat);
+                sb.append(rat);
+                sb.append(";");
+                sb.append(apn.protocol);
+                log("syncApnTableToRds: apn: " + sb.toString());
+                aryApn.add(sb.toString());
+            }
+            if (aryApn.size() > 0) {
+                mPhone.mCi.syncApnTableToRds(aryApn.toArray(new String[aryApn.size()]), null);
+            }
+        }
+        log("syncApnTableToRds: X");
+    }
+    // M: VDF MMS over ePDG @{
+    private int getApnRatByBearer(int bearerBitMask) {
+        int invertIWLANBitMask = 0;
+        log("getApnRatByBearer: " + bearerBitMask);
+
+        if (bearerBitMask == 0) {
+            return PhoneConstants.APN_RAT_CELLULAR_ONLY;
+        } else {
+            if (ServiceState.bitmaskHasTech(bearerBitMask,
+                    ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+                invertIWLANBitMask = ~(1 << (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN - 1))
+                        & 0xffffff;
+                if (isWifiOnlyApn(bearerBitMask)) {
+                    return PhoneConstants.APN_RAT_WIFI_ONLY;
+                } else {
+                    return PhoneConstants.APN_RAT_CELLULAR_WIFI;
+                }
+            } else {
+                return PhoneConstants.APN_RAT_CELLULAR_ONLY;
+            }
+        }
+    }
+
+    private boolean isWifiOnlyApn(int bearerBitMask) {
+        int invertIWLANBitMask = ~(1 << (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN - 1)) & 0xffffff;
+
+        if (bearerBitMask == 0) {
+            return false;
+        }
+        return ((bearerBitMask & invertIWLANBitMask) == 0);
+    }
+    /// @}
+
+    public boolean checkIfDomesticInitialAttachApn(String currentMcc) {
+        boolean isMccDomestic = false;
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (currentMcc.equals(mcc)) {
+                isMccDomestic = true;
+                break;
+            }
+        }
+        if (isOp17IaSupport()&& isMccDomestic) {
+            if (getImsEnabled()) {
+                return mRegion == REGION_DOMESTIC;
+            } else {
+                return false;
+            }
+        }
+        if (enableOpIA()) {
+            return mRegion == REGION_DOMESTIC;
+        }
+
+        if (DBG) {
+            log("checkIfDomesticInitialAttachApn: Not OP129 or MCC is not in domestic for OP129");
+        }
+
+        return true;
+    }
+
+    public boolean enableOpIA() {
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (TextUtils.isEmpty(operatorNumeric)) {
+            return false;
+        }
+        String simOperator = operatorNumeric.substring(0, 3);
+        log("enableOpIA: currentMcc = " + simOperator);
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (simOperator.equals(mcc)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void onPcoStatus(AsyncResult ar) {
+        if (ar.exception == null) {
+            int[] aryPcoStatus = (int[]) ar.result;
+            if (aryPcoStatus != null && aryPcoStatus.length == 6) {
+                log("onPcoStatus: PCO_MCC = " + aryPcoStatus[0]
+                        + ", PCO_MNC = " + aryPcoStatus[1]
+                        + ", PCO_VAL = " + aryPcoStatus[2]
+                        + ", PCO_TECH = " + aryPcoStatus[3]
+                        + ", PCO_PDN_ID = " + aryPcoStatus[5]);
+
+                DcAsyncChannel dcac = mDataConnectionAcHashMap.get(aryPcoStatus[5]);
+                if (dcac != null) {
+                    String[] aryApnType = dcac.getApnTypeSync();
+                    if (aryApnType != null) {
+                        for (String apnType: aryApnType) {
+                            Intent intent = new Intent(TelephonyIntents.ACTION_PCO_STATUS);
+                            intent.putExtra(PhoneConstants.DATA_APN_TYPE_KEY, apnType);
+                            intent.putExtra(TelephonyIntents.EXTRA_PCO_TYPE, aryPcoStatus[2]);
+                            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+                        }
+                    } else {
+                        logw("onPcoStatus: dcac.getApnTypeSync() return null");
+                    }
+                }
+            } else {
+                logw("onPcoStatus: pco status is null");
+            }
+        } else {
+            loge("onPcoStatus exception: " + ar.exception);
+        }
+    }
+
+    // M: Multi-PS Attach Start
+    private void onAllowChanged(boolean allow) {
+        if (DBG) {
+            log("onAllowChanged: Allow = " + allow);
+        }
+
+        mAllowConfig = allow;
+        if (allow) {
+            setupDataOnConnectableApns(Phone.REASON_DATA_ALLOWED);
+        }
+    }
+
+    private boolean getAllowConfig() {
+        if(!DataConnectionHelper.getInstance().isMultiPsAttachSupport()) {
+            return true;
+        } else {
+            return hasModemDeactPdnCapabilityForMultiPS() ? true : mAllowConfig;
+        }
+    }
+    // M: Multi-PS Attach End
+
+    // M: Customize fallback retry
+    private boolean isPermanentFailByOp(DcFailCause dcFailCause) {
+        boolean isPermanent = true;
+        if (mDcFcMgr == null) {
+            loge("mDcFcMgr should not be null, something wrong");
+        } else {
+            isPermanent = mDcFcMgr.isPermanentFailByOp(dcFailCause);
+        }
+        return isPermanent;
+    }
+
+    // M: Set Default data SIM to RILD {
+    public void syncDefaultDataSlotId(int slotId) {
+        log("syncDefaultDataSlotId slot: " + slotId);
+
+        syncDataSettingsToMd(new int[] { SKIP_DATA_SETTINGS, SKIP_DATA_SETTINGS, slotId});
+    }
+    // }
+
+    /**
+     * M: Sync data setting to modem.
+     */
+    private void syncDataSettingsToMd(int[] dataSettings) {
+        logd("syncDataSettingsToMd(), "
+            + dataSettings[MOBILE_DATA_IDX]
+            + ", " + dataSettings[ROAMING_DATA_IDX]
+            + ", " + dataSettings[DEFAULT_DATA_SIM_IDX]);
+        mPhone.mCi.syncDataSettingsToMd(dataSettings, null);
+    }
+
+    private boolean skipDataStallAlarm() {
+        boolean skipStall = true;
+        boolean isTestSim = false;
+        int phoneId = mPhone.getPhoneId();
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (SubscriptionManager.isValidPhoneId(phoneId) &&
+                dcHelper != null && dcHelper.isTestIccCard(phoneId)) {
+            isTestSim = true;
+        }
+
+        if (isTestSim) {
+            if (SystemProperties.get(SKIP_DATA_STALL_ALARM).equals("0")) {
+                skipStall = false;
+            } else {
+                // majority behavior
+                skipStall = true;
+            }
+        } else {
+            if (SystemProperties.get(SKIP_DATA_STALL_ALARM).equals("1")) {
+                skipStall = true;
+            } else {
+                // majority behavior
+                skipStall = false;
+            }
+        }
+
+        return skipStall;
+    }
+
+    private void notifyVoiceCallEventToDataConnection(boolean bInVoiceCall,
+            boolean bSupportConcurrent) {
+        logd("notifyVoiceCallEventToDataConnection: bInVoiceCall = " + bInVoiceCall
+                + ", bSupportConcurrent = " + bSupportConcurrent);
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+                dcac.notifyVoiceCallEvent(bInVoiceCall, bSupportConcurrent);
+        }
+    }
+
+    private boolean isApnSettingExist(ApnSetting apnSetting) {
+        if (apnSetting != null && mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (TextUtils.equals(apnSetting.toStringIgnoreName(false),
+                        apn.toStringIgnoreName(false))) {
+                    log("isApnSettingExist: " + apn);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * M: VzW feature, change IA in EPDG handover case.
+     */
+    private void onAttachApnChangedByHandover(boolean isImsHandover) {
+        mIsImsHandover = isImsHandover;
+        log("onAttachApnChangedByHandover: mIsImsHandover = " + mIsImsHandover);
+        /* Set ril.imshandover which will be used in RILD to decide APN control mode
+           1: handover start
+           2: handover end
+        */
+        SystemProperties.set(PROP_IMS_HANDOVER, mIsImsHandover ? "1" : "2");
+        setInitialAttachApn();
+    }
+
+    private boolean isOp17IaSupport() {
+        String value = TelephonyManager.getTelephonyProperty(
+                mPhone.getPhoneId(), "gsm.ril.sim.op17", "0");
+        return value.equals("1") ? true : false;
+    }
+
+    private boolean isOp129IaSupport() {
+        return SystemProperties.get("gsm.ril.sim.op129").equals("1") ? true : false;
+    }
+
+    private boolean isNeedToResumeMd() {
+        return SystemProperties.get("gsm.ril.data.op.suspendmd").equals("1") ? true : false;
+    }
+
+    private boolean isOp18Sim() {
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        if (operator != null) {
+            for (int i = 0; i < MCCMNC_OP18.length; i++) {
+                if (operator.startsWith(MCCMNC_OP18[i])) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean getDomesticRoamingEnabledBySim() {
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (dcHelper == null) {
+            loge("getDomesticRoamingEnabledBySim: dcHelper is null");
+            return false;
+        }
+
+        boolean bDomesticRoamingEnabled =
+                dcHelper.getDomesticRoamingEnabledBySim(mPhone.getPhoneId());
+
+        if (DBG) {
+            log("getDomesticRoamingEnabledBySim: bDomesticRoamingEnabled="
+                    + bDomesticRoamingEnabled);
+        }
+
+        return bDomesticRoamingEnabled;
+    }
+
+    private boolean hasOperatorIaCapability() {
+        if (mTelDevController != null &&
+                mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasOperatorIaCapability() == true) {
+            log("hasOpIaCapability: true");
+            return true;
+        }
+        return false;
+    }
+
+    private boolean hasModemDeactPdnCapabilityForMultiPS() {
+        if (mTelDevController != null &&
+                mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasModemDeactPdnCapabilityForMultiPS() == true) {
+            log("hasModemDeactPdnCapabilityForMultiPS: true");
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * M: Handler of data enabled changed event
+     * @param enabled True if data is enabled, otherwise disabled.
+     * @param reason Reason for data enabled/disabled (see {@code REASON_*} in
+     *      {@link DataEnabledSettings}.
+     */
+    private void onDataEnabledSettings(boolean enabled, int reason) {
+        log("onDataEnabledSettings: enabled=" + enabled + ", reason=" + reason);
+
+        if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
+            if (getDataOnRoamingEnabled() == false &&
+                    mPhone.getServiceState().getDataRoaming() == true) {
+                if (enabled) {
+                    notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+                } else {
+                    notifyOffApnsOfAvailability(Phone.REASON_DATA_DISABLED);
+                }
+            }
+
+            // M: Sync data setting to modem
+            syncDataSettingsToMd(new int[]{ enabled ? 1 : 0,
+                                            getDataOnRoamingEnabled() ? 1 : 0,
+                                            SKIP_DATA_SETTINGS});
+
+            if (enabled) {
+                teardownRestrictedMeteredConnections();
+                onTrySetupData(Phone.REASON_DATA_ENABLED);
+            } else {
+                if (BSP_PACKAGE) {
+                    onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                } else {
+                     for (ApnContext apnContext : mApnContexts.values()) {
+                        if (!isDataAllowedAsOff(apnContext.getApnType())) {
+                            apnContext.setReason(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                            onCleanUpConnection(true
+                                    , apnContext.apnIdForApnName(apnContext.getApnType())
+                                    , Phone.REASON_DATA_SPECIFIC_DISABLED);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}

Property changes on: vendor/branch/5058A_Cable_Bahamas/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
