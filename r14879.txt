Index: vendor/branch/5058A_Bitel_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java
===================================================================
--- vendor/branch/5058A_Bitel_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java	(revision 0)
+++ vendor/branch/5058A_Bitel_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java	(revision 14879)
@@ -0,0 +1,1027 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.incallui;
+
+import static com.android.incallui.CallButtonFragment.Buttons.*;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.UserHandle;
+import android.telecom.CallAudioState;
+import android.telecom.InCallService.VideoCall;
+import android.telecom.VideoProfile;
+import android.telephony.PhoneNumberUtils;
+import android.text.TextUtils;
+
+import com.android.contacts.common.compat.CallSdkCompat;
+import com.android.contacts.common.compat.SdkVersionOverride;
+import com.android.dialer.compat.UserManagerCompat;
+import com.android.incallui.AudioModeProvider.AudioModeListener;
+import com.android.incallui.InCallCameraManager.Listener;
+import com.android.incallui.InCallPresenter.CanAddCallListener;
+import com.android.incallui.InCallPresenter.InCallDetailsListener;
+import com.android.incallui.InCallPresenter.InCallState;
+import com.android.incallui.InCallPresenter.InCallStateListener;
+import com.android.incallui.InCallPresenter.IncomingCallListener;
+import com.android.incallui.InCallPresenter.InCallDetailsListener;
+/// M: add for phone record. @{
+import com.android.incallui.InCallPresenter.PhoneRecorderListener;
+/// @}
+/// M: add for cancel upgrade. @{
+import com.mediatek.incallui.videocall.VideoSessionController;
+/// @}
+
+/// M: DMLock @{
+import com.mediatek.incallui.InCallUtils;
+import com.mediatek.incallui.blindect.AddTransferNumberScreenController;
+/// @}
+/// M: add for plug in. @{
+import com.mediatek.incallui.ext.ExtensionManager;
+/// @}
+import com.mediatek.incallui.wrapper.FeatureOptionWrapper;
+
+/**
+ * Logic for call buttons.
+ */
+public class CallButtonPresenter extends Presenter<CallButtonPresenter.CallButtonUi>
+        implements InCallStateListener, AudioModeListener, IncomingCallListener,
+        InCallDetailsListener, CanAddCallListener, Listener, PhoneRecorderListener,
+        CallList.CallUpdateListener {
+
+    private static final String KEY_AUTOMATICALLY_MUTED = "incall_key_automatically_muted";
+    private static final String KEY_PREVIOUS_MUTE_STATE = "incall_key_previous_mute_state";
+
+    private Call mCall;
+    private boolean mAutomaticallyMuted = false;
+    private boolean mPreviousMuteState = false;
+
+    /// M: Add for blind ECT testcase
+    public static boolean mShowBlindECT = false;
+
+    public CallButtonPresenter() {
+    }
+
+    @Override
+    public void onUiReady(CallButtonUi ui) {
+        super.onUiReady(ui);
+
+        AudioModeProvider.getInstance().addListener(this);
+
+        // register for call state changes last
+        final InCallPresenter inCallPresenter = InCallPresenter.getInstance();
+        inCallPresenter.addListener(this);
+        inCallPresenter.addIncomingCallListener(this);
+        inCallPresenter.addDetailsListener(this);
+        inCallPresenter.addCanAddCallListener(this);
+        inCallPresenter.getInCallCameraManager().addCameraSelectionListener(this);
+
+        /// M: [Voice Record] add Phone Record listener
+        InCallPresenter.getInstance().addPhoneRecorderListener(this);
+
+        // Update the buttons state immediately for the current call
+        onStateChange(InCallState.NO_CALLS, inCallPresenter.getInCallState(),
+                CallList.getInstance());
+    }
+
+    @Override
+    public void onUiUnready(CallButtonUi ui) {
+        super.onUiUnready(ui);
+
+        InCallPresenter.getInstance().removeListener(this);
+        AudioModeProvider.getInstance().removeListener(this);
+        InCallPresenter.getInstance().removeIncomingCallListener(this);
+        InCallPresenter.getInstance().removeDetailsListener(this);
+        InCallPresenter.getInstance().getInCallCameraManager().removeCameraSelectionListener(this);
+        InCallPresenter.getInstance().removeCanAddCallListener(this);
+        /// M: [Voice Record]remove Phone Record listener
+        InCallPresenter.getInstance().removePhoneRecorderListener(this);
+        /// M: [Video call] when UI unready, must remove the listener.
+        /// otherwise, if rotation happened, the Listener would not change to
+        /// the new CallButtonPresenter instance @{
+        if (mCall != null) {
+            CallList.getInstance().removeCallUpdateListener(mCall.getId(), this);
+        }
+        /// @}
+        /// M: for blind ECT @{
+        AddTransferNumberScreenController.getInstance().dismissAddTransferNumberDialog();
+        /// @}
+        ExtensionManager.getVilteAutoTestHelperExt().unregisterReceiverForUpgradeAndDowngrade();
+    }
+
+    @Override
+    public void onStateChange(InCallState oldState, InCallState newState, CallList callList) {
+        CallButtonUi ui = getUi();
+
+        /// M: [Video Call] for tracking the CallUpdateListener.
+        Call previousCall = mCall;
+
+        if (newState == InCallState.OUTGOING) {
+            mCall = callList.getOutgoingCall();
+            /// M: For ALPS01940714, force set mute false if emergency call. @{
+            if (isEmergencyCall(mCall)) {
+                muteClicked(false);
+            }
+            /// @}
+        } else if (newState == InCallState.INCALL) {
+            mCall = callList.getActiveOrBackgroundCall();
+
+            // When connected to voice mail, automatically shows the dialpad.
+            // (On previous releases we showed it when in-call shows up, before waiting for
+            // OUTGOING.  We may want to do that once we start showing "Voice mail" label on
+            // the dialpad too.)
+            if (ui != null) {
+                if (oldState == InCallState.OUTGOING && mCall != null) {
+                    if (CallerInfoUtils.isVoiceMailNumber(ui.getContext(), mCall)) {
+                        ui.displayDialpad(true /* show */, true /* animate */);
+                    }
+                }
+            }
+        } else if (newState == InCallState.INCOMING) {
+            if (ui != null) {
+                ui.displayDialpad(false /* show */, true /* animate */);
+            }
+            mCall = callList.getIncomingCall();
+        } else {
+            mCall = null;
+        }
+
+        /// [VideoCall] for all "primary call"(disconnected not included)
+        /// add callUpdateListener for the session event. @{
+        if (!Call.areSame(previousCall, mCall)) {
+            if (previousCall != null) {
+                CallList.getInstance().removeCallUpdateListener(previousCall.getId(), this);
+            }
+            if (mCall != null) {
+                CallList.getInstance().addCallUpdateListener(mCall.getId(), this);
+            }
+        }
+        /// @}
+        updateUi(newState, mCall);
+
+        /// M: Plug-in. @{
+        ExtensionManager.getRCSeCallButtonExt().onStateChange(mCall != null ?
+                        mCall.getTelecomCall() : null,
+                callList.getCallMap());
+        /// @}
+
+        ///M: you can refer the method to InCallVideoCallCallback onSessionModifyRequestReceived
+        updateVideoCallSessionState(mCall);
+    }
+
+    /**
+     * Updates the user interface in response to a change in the details of a call.
+     * Currently handles changes to the call buttons in response to a change in the details for a
+     * call.  This is important to ensure changes to the active call are reflected in the available
+     * buttons.
+     *
+     * @param call The active call.
+     * @param details The call details.
+     */
+    @Override
+    public void onDetailsChanged(Call call, android.telecom.Call.Details details) {
+        // Only update if the changes are for the currently active call
+        if (getUi() != null && call != null && call.equals(mCall)) {
+            updateButtonsState(call);
+        }
+    }
+
+    @Override
+    public void onIncomingCall(InCallState oldState, InCallState newState, Call call) {
+
+        onStateChange(oldState, newState, CallList.getInstance());
+    }
+
+    @Override
+    public void onCanAddCallChanged(boolean canAddCall) {
+        if (getUi() != null && mCall != null) {
+            updateButtonsState(mCall);
+        }
+    }
+
+    @Override
+    public void onAudioMode(int mode) {
+        if (getUi() != null) {
+            getUi().setAudio(mode);
+        }
+    }
+
+    @Override
+    public void onSupportedAudioMode(int mask) {
+        if (getUi() != null) {
+            getUi().setSupportedAudio(mask);
+        }
+    }
+
+    @Override
+    public void onMute(boolean muted) {
+        if (getUi() != null && !mAutomaticallyMuted) {
+            getUi().setMute(muted);
+        }
+    }
+
+    public int getAudioMode() {
+        return AudioModeProvider.getInstance().getAudioMode();
+    }
+
+    public int getSupportedAudio() {
+        return AudioModeProvider.getInstance().getSupportedModes();
+    }
+
+    public void setAudioMode(int mode) {
+
+        // TODO: Set a intermediate state in this presenter until we get
+        // an update for onAudioMode().  This will make UI response immediate
+        // if it turns out to be slow
+
+        Log.d(this, "Sending new Audio Mode: " + CallAudioState.audioRouteToString(mode));
+        TelecomAdapter.getInstance().setAudioRoute(mode);
+    }
+
+    /**
+     * Function assumes that bluetooth is not supported.
+     */
+    public void toggleSpeakerphone() {
+        // this function should not be called if bluetooth is available
+        if (0 != (CallAudioState.ROUTE_BLUETOOTH & getSupportedAudio())) {
+
+            // It's clear the UI is wrong, so update the supported mode once again.
+            Log.e(this, "toggling speakerphone not allowed when bluetooth supported.");
+            getUi().setSupportedAudio(getSupportedAudio());
+            return;
+        }
+
+        int newMode = CallAudioState.ROUTE_SPEAKER;
+
+        // if speakerphone is already on, change to wired/earpiece
+        if (getAudioMode() == CallAudioState.ROUTE_SPEAKER) {
+            newMode = CallAudioState.ROUTE_WIRED_OR_EARPIECE;
+        }
+
+        setAudioMode(newMode);
+    }
+
+    public void muteClicked(boolean checked) {
+        Log.d(this, "turning on mute: " + checked);
+        TelecomAdapter.getInstance().mute(checked);
+    }
+
+    public void holdClicked(boolean checked) {
+        if (mCall == null) {
+            return;
+        }
+        if (checked) {
+            Log.i(this, "Putting the call on hold: " + mCall);
+            /// M: [log optimize]
+            Log.op(mCall, Log.CcOpAction.HOLD, "hold button clicked.");
+            TelecomAdapter.getInstance().holdCall(mCall.getId());
+        } else {
+            Log.i(this, "Removing the call from hold: " + mCall);
+            /// M: [log optimize]
+            Log.op(mCall, Log.CcOpAction.UNHOLD, "unhold button clicked.");
+            TelecomAdapter.getInstance().unholdCall(mCall.getId());
+        }
+    }
+
+    public void swapClicked() {
+        if (mCall == null) {
+            return;
+        }
+
+        Log.i(this, "Swapping the call: " + mCall);
+        /// M: [log optimize]
+        Log.op(mCall, Log.CcOpAction.SWAP, "swap key clicked.");
+        TelecomAdapter.getInstance().swap(mCall.getId());
+    }
+
+    public void mergeClicked() {
+        /// M: [log optimize]
+        Log.op(mCall, Log.CcOpAction.MERGE, "Merge to be a conference");
+        /// M: fix NPE issue ALPS02509623. @{
+        if (mCall == null) {
+            return;
+        }
+        /// @}
+        TelecomAdapter.getInstance().merge(mCall.getId());
+    }
+
+    public void addCallClicked() {
+        // Automatically mute the current call
+        mAutomaticallyMuted = true;
+        mPreviousMuteState = AudioModeProvider.getInstance().getMute();
+        // Simulate a click on the mute button
+        muteClicked(true);
+        TelecomAdapter.getInstance().addCall();
+    }
+
+    public void changeToVoiceClicked() {
+        // M: fix CR:ALPS02550278,NullPointerException.
+        if (mCall == null) {
+            return;
+        }
+        VideoCall videoCall = mCall.getVideoCall();
+        if (videoCall == null) {
+            return;
+        }
+
+        VideoProfile videoProfile = new VideoProfile(
+                VideoProfile.STATE_AUDIO_ONLY, VideoProfile.QUALITY_DEFAULT);
+        videoCall.sendSessionModifyRequest(videoProfile);
+        ///M: add new state for downgrade and updateVideoBtnUi @{
+        mCall.setSessionModificationState(Call.SessionModificationState.
+                WAITING_FOR_DOWNGRADE_RESPONSE);
+        //show message for downgrade
+        InCallPresenter.getInstance().showMessage(R.string.video_call_downgrade_request);
+
+        //@}
+    }
+
+    public void showDialpadClicked(boolean checked) {
+        Log.v(this, "Show dialpad " + String.valueOf(checked));
+        getUi().displayDialpad(checked /* show */, true /* animate */);
+    }
+
+     /// M:send cancel upgrade request and if the timer of cancel upgrade has started ,should
+     ///stop the timer . @{
+    public void cancelUpgradeClicked() {
+            if (mCall == null) {
+                return;
+            }
+            VideoCall videoCall = mCall.getVideoCall();
+            if (videoCall == null) {
+                return;
+            }
+
+            if (mCall.getSessionModificationState() ==
+                Call.SessionModificationState.WAITING_FOR_CANCEL_UPGRADE_RESPONSE) {
+                return;
+            }
+
+            VideoProfile videoProfile = new VideoProfile(
+            VideoProfile.STATE_CANCEL_UPGRADE, VideoProfile.QUALITY_DEFAULT);
+            videoCall.sendSessionModifyRequest(videoProfile);
+            mCall.setSessionModificationState(Call.SessionModificationState.
+                    WAITING_FOR_CANCEL_UPGRADE_RESPONSE);
+
+            VideoSessionController.getInstance().stopTiming();
+            Log.d(this, "cancel Upgrade request send");
+    }
+    ///@}
+
+    public void changeToVideoClicked() {
+        // M: fix CR:ALPS02550278,NullPointerException.
+        if (mCall == null) {
+            return;
+        }
+        VideoCall videoCall = mCall.getVideoCall();
+        if (videoCall == null) {
+            return;
+        }
+        /// M: fix CR:ALPS02499779,can not use upgrade anymore.
+        /// [Video call] when receive upgrade to video request
+        /// and click video call button, no response. @{
+        if (mCall.getSessionModificationState() ==
+            Call.SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST) {
+            return;
+        }
+        /// @}
+        int currVideoState = mCall.getVideoState();
+        int currUnpausedVideoState = VideoUtils.getUnPausedVideoState(currVideoState);
+        currUnpausedVideoState |= VideoProfile.STATE_BIDIRECTIONAL;
+
+        VideoProfile videoProfile = new VideoProfile(currUnpausedVideoState);
+        videoCall.sendSessionModifyRequest(videoProfile);
+        mCall.setSessionModificationState(Call.SessionModificationState.
+                WAITING_FOR_UPGRADE_RESPONSE);
+    }
+
+    /**
+     * Switches the camera between the front-facing and back-facing camera.
+     * @param useFrontFacingCamera True if we should switch to using the front-facing camera, or
+     *     false if we should switch to using the back-facing camera.
+     */
+    public void switchCameraClicked(boolean useFrontFacingCamera) {
+        InCallCameraManager cameraManager = InCallPresenter.getInstance().getInCallCameraManager();
+        cameraManager.setUseFrontFacingCamera(useFrontFacingCamera);
+        // M: fix CR:ALPS02550278,NullPointerException.
+        if (mCall == null) {
+            return;
+        }
+        VideoCall videoCall = mCall.getVideoCall();
+        if (videoCall == null) {
+            return;
+        }
+
+        String cameraId = cameraManager.getActiveCameraId();
+        if (cameraId != null) {
+            final int cameraDir = cameraManager.isUsingFrontFacingCamera()
+                    ? Call.VideoSettings.CAMERA_DIRECTION_FRONT_FACING
+                    : Call.VideoSettings.CAMERA_DIRECTION_BACK_FACING;
+            mCall.getVideoSettings().setCameraDir(cameraDir);
+            videoCall.setCamera(cameraId);
+            videoCall.requestCameraCapabilities();
+        }
+    }
+
+
+    /**
+     * Stop or start client's video transmission.
+     * @param pause True if pausing the local user's video, or false if starting the local user's
+     *    video.
+     */
+    public void pauseVideoClicked(boolean pause) {
+        // M: fix CR:ALPS02550278,NullPointerException.
+        if (mCall == null) {
+            return;
+        }
+        VideoCall videoCall = mCall.getVideoCall();
+        if (videoCall == null) {
+            return;
+        }
+
+        final int currUnpausedVideoState = VideoUtils.getUnPausedVideoState(mCall.getVideoState());
+        if (pause) {
+            /**
+             * M: not set camera null, until the call updated as RX only as the showVideoUI flow
+             * close camera. Some case chenge to Rx only may failed, e.g peer in hold state.
+             * videoCall.setCamera(null);
+             */
+            VideoProfile videoProfile = new VideoProfile(currUnpausedVideoState
+                    & ~VideoProfile.STATE_TX_ENABLED);
+            videoCall.sendSessionModifyRequest(videoProfile);
+            /// M: when close camera set the session state @{
+            mCall.setSessionModificationState(Call.SessionModificationState.
+                    WAITING_FOR_PAUSE_VIDEO_RESPONSE);
+            /// @}
+        } else {
+            InCallCameraManager cameraManager = InCallPresenter.getInstance().
+                    getInCallCameraManager();
+            videoCall.setCamera(cameraManager.getActiveCameraId());
+            VideoProfile videoProfile = new VideoProfile(currUnpausedVideoState
+                    | VideoProfile.STATE_TX_ENABLED);
+            videoCall.sendSessionModifyRequest(videoProfile);
+            mCall.setSessionModificationState(Call.SessionModificationState.
+                    WAITING_FOR_UPGRADE_RESPONSE);
+        }
+    }
+
+    private void updateUi(InCallState state, Call call) {
+        Log.d(this, "Updating call UI for call: ", call);
+        /// M: DMLock @{
+        if (InCallUtils.isDMLocked()) {
+            updateInCallControlsDuringDMLocked(call);
+            return;
+        }
+        /// @}
+
+        final CallButtonUi ui = getUi();
+        if (ui == null) {
+            return;
+        }
+
+        final boolean isEnabled =
+                state.isConnectingOrConnected() &&!state.isIncoming() && call != null;
+        ui.setEnabled(isEnabled);
+
+        /// M: for ALPS01945830. Redraw callbuttons. @{
+        ui.updateColors();
+        /// @}
+
+        if (call == null) {
+            return;
+        }
+        /// M: fix CR:ALPS02259658,"hang up active,answer waiting call"not display in 1A+1W @{
+        if (call.getState() == Call.State.INCOMING
+                && CallList.getInstance().getActiveAndHoldCallsCount() != 0) {
+            ui.enableOverflowButton();
+        }
+        /// @}
+        updateButtonsState(call);
+
+        //M: for ALPS02501750. update hide button for rotation.
+        if (mCall != null && mCall.isHidePreview()) {
+            ui.updateHideButtonStatus(true);
+        } else {
+            ui.updateHideButtonStatus(false);
+        }
+    }
+
+    /**
+     * Updates the buttons applicable for the UI.
+     *
+     * @param call The active call.
+     */
+    private void updateButtonsState(Call call) {
+        Log.v(this, "updateButtonsState");
+        final CallButtonUi ui = getUi();
+        final boolean isVideo = VideoUtils.isVideoCall(call);
+
+        // Common functionality (audio, hold, etc).
+        // Show either HOLD or SWAP, but not both. If neither HOLD or SWAP is available:
+        //     (1) If the device normally can hold, show HOLD in a disabled state.
+        //     (2) If the device doesn't have the concept of hold/swap, remove the button.
+        final boolean showSwap = call.can(
+                android.telecom.Call.Details.CAPABILITY_SWAP_CONFERENCE);
+        /// M: [Video Call]move show hold controller to updateVideoButtonUI  @{
+        /*boolean showHold = !showSwap
+              //&& call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD)
+              //&& call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
+        if (isVideo) {
+            showHold &= call.getVideoFeatures().supportsHold();
+        }*/
+        ///@}
+        final boolean isCallOnHold = call.getState() == Call.State.ONHOLD;
+
+        final boolean showAddCall = TelecomAdapter.getInstance().canAddCall()
+                && UserManagerCompat.isUserUnlocked(ui.getContext());
+        final boolean showMerge = call.can(
+                android.telecom.Call.Details.CAPABILITY_MERGE_CONFERENCE);
+        /* google code,move to updateVideoButtonUI.
+        final boolean showUpgradeToVideo = !isVideo && hasVideoCallCapabilities(call);
+        final boolean showDowngradeToAudio = isVideo && isDowngradeToAudioSupported(call);
+        */
+        final boolean showMute = call.can(android.telecom.Call.Details.CAPABILITY_MUTE);
+        /// M: add other feature. (eg:bilind ECT)@{
+        boolean canBlindEct = mShowBlindECT;
+        if (!mShowBlindECT) {
+            canBlindEct = call.can(android.telecom.Call.Details.CAPABILITY_BLIND_ASSURED_ECT);
+        }
+        final boolean canSetEct = InCallUtils.canSetEct();
+        final boolean canHangupAllCalls = InCallUtils.canHangupAllCalls()
+                && FeatureOptionWrapper.isSupportHangupAll();
+        final boolean canHangupAllHoldCalls = InCallUtils.canHangupAllHoldCalls()
+                && FeatureOptionWrapper.isSupportHangupAll();
+        final boolean canHangupActiveAndAnswerWaiting = InCallUtils
+                .canHangupActiveAndAnswerWaiting()
+                && FeatureOptionWrapper.isSupportHangupAll();
+        Log.d(this, "[updateButtonsState] Swap:" + showSwap + " OnHold:"
+                + isCallOnHold + " AddCall:" + showAddCall + " Merge:"
+                + showMerge + " Mute:" + showMute + " SetEct:" + canSetEct
+                + " Hangup[AllCalls:" + canHangupAllCalls + " AllHoldCalls:"
+                + canHangupAllHoldCalls + " ActiveAndAnswerWaiting:"
+                + canHangupActiveAndAnswerWaiting + "canBlindEct:"
+                + canBlindEct+ "]");
+        /// @}
+
+        ui.showButton(BUTTON_AUDIO, true);
+        ui.showButton(BUTTON_SWAP, showSwap);
+        /// M: [Video Call]move show hold controller to updateVideoButtonUI  @{
+        //ui.showButton(BUTTON_HOLD, showHold);
+        //ui.setHold(isCallOnHold);
+        ui.showButton(BUTTON_MUTE, showMute);
+        ui.showButton(BUTTON_ADD_CALL, showAddCall);
+        updateVideoButtonUI(call, isVideo);
+        ui.setHold(isCallOnHold);
+        /// @}
+        /* google code,move to updateVideoButtonUI.
+        ui.showButton(BUTTON_UPGRADE_TO_VIDEO, showUpgradeToVideo);
+        ui.showButton(BUTTON_DOWNGRADE_TO_AUDIO, showDowngradeToAudio);
+        ui.showButton(BUTTON_SWITCH_CAMERA, isVideo);
+        ui.showButton(BUTTON_PAUSE_VIDEO, isVideo);
+        if (isVideo) {
+            getUi().setVideoPaused(!VideoUtils.isTransmissionEnabled(call));
+        }
+        */
+        ui.showButton(BUTTON_DIALPAD, true);
+        ui.showButton(BUTTON_MERGE, showMerge);
+
+        /// M: add other feature. @{
+        ui.showButton(BUTTON_SET_ECT, canSetEct);
+        ui.enableButton(BUTTON_SET_ECT,canSetEct);
+        ui.showButton(BUTTON_HANGUP_ALL_CALLS, canHangupAllCalls);
+        ui.enableButton(BUTTON_HANGUP_ALL_CALLS, canHangupAllCalls);
+        ui.showButton(BUTTON_HANGUP_ALL_HOLD_CALLS, canHangupAllHoldCalls);
+        ui.enableButton(BUTTON_HANGUP_ALL_HOLD_CALLS, canHangupAllHoldCalls);
+        ui.showButton(BUTTON_HANGUP_ACTIVE_AND_ANSWER_WAITING, canHangupActiveAndAnswerWaiting);
+        ui.enableButton(BUTTON_HANGUP_ACTIVE_AND_ANSWER_WAITING, canHangupActiveAndAnswerWaiting);
+        /// @}
+
+        /// M: add for blind ECT
+        ui.showButton(BUTTON_BLIND_ECT, canBlindEct);
+        ui.enableButton(BUTTON_BLIND_ECT, canBlindEct);
+
+        ui.updateButtonStates();
+
+    }
+
+    private boolean hasVideoCallCapabilities(Call call) {
+        if (SdkVersionOverride.getSdkVersion(Build.VERSION_CODES.M) >= Build.VERSION_CODES.M) {
+            return call.can(android.telecom.Call.Details.CAPABILITY_SUPPORTS_VT_LOCAL_TX)
+                    && call.can(android.telecom.Call.Details.CAPABILITY_SUPPORTS_VT_REMOTE_RX);
+        }
+        // In L, this single flag represents both video transmitting and receiving capabilities
+        return call.can(android.telecom.Call.Details.CAPABILITY_SUPPORTS_VT_LOCAL_TX);
+    }
+
+    /**
+     * Determines if downgrading from a video call to an audio-only call is supported.  In order to
+     * support downgrade to audio, the SDK version must be >= N and the call should NOT have the
+     * {@link android.telecom.Call.Details#CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO}.
+     * @param call The call.
+     * @return {@code true} if downgrading to an audio-only call from a video call is supported.
+     */
+    private boolean isDowngradeToAudioSupported(Call call) {
+        return !call.can(CallSdkCompat.Details.CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO);
+    }
+
+    public void refreshMuteState() {
+        // Restore the previous mute state
+        if (mAutomaticallyMuted &&
+                AudioModeProvider.getInstance().getMute() != mPreviousMuteState) {
+            if (getUi() == null) {
+                return;
+            }
+            muteClicked(mPreviousMuteState);
+        }
+        mAutomaticallyMuted = false;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(KEY_AUTOMATICALLY_MUTED, mAutomaticallyMuted);
+        outState.putBoolean(KEY_PREVIOUS_MUTE_STATE, mPreviousMuteState);
+    }
+
+    @Override
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        mAutomaticallyMuted =
+                savedInstanceState.getBoolean(KEY_AUTOMATICALLY_MUTED, mAutomaticallyMuted);
+        mPreviousMuteState =
+                savedInstanceState.getBoolean(KEY_PREVIOUS_MUTE_STATE, mPreviousMuteState);
+        super.onRestoreInstanceState(savedInstanceState);
+    }
+
+    public interface CallButtonUi extends Ui {
+        void showButton(int buttonId, boolean show);
+        void enableButton(int buttonId, boolean enable);
+        void setEnabled(boolean on);
+        void setMute(boolean on);
+        void setHold(boolean on);
+        void setCameraSwitched(boolean isBackFacingCamera);
+        void setVideoPaused(boolean isPaused);
+        void setAudio(int mode);
+        void setSupportedAudio(int mask);
+        void displayDialpad(boolean on, boolean animate);
+        boolean isDialpadVisible();
+
+        /**
+         * Once showButton() has been called on each of the individual buttons in the UI, call
+         * this to configure the overflow menu appropriately.
+         */
+        void updateButtonStates();
+        Context getContext();
+
+        /// M: for ALPS01945830. Redraw callbuttons. @{
+        void updateColors();
+        /// @}
+
+        /// M: Voice recording
+        void configRecordingButton();
+        /// M: fix CR:ALPS02259658,"hang up active,answer waiting call"not display in 1A+1W @{
+        void enableOverflowButton();
+        /// @}
+
+        void updateHideButtonStatus(boolean hide);
+    }
+
+    @Override
+    public void onActiveCameraSelectionChanged(boolean isUsingFrontFacingCamera) {
+        if (getUi() == null) {
+            return;
+        }
+        getUi().setCameraSwitched(!isUsingFrontFacingCamera);
+    }
+
+    //---------------------------------------Mediatek-----------------------------------
+    /**
+     * M: [DM Lock] update incall UI button states when DM Lock enabled.
+     * @param call used to set call button states.
+     */
+    void updateInCallControlsDuringDMLocked(Call call) {
+        final CallButtonUi ui = getUi();
+        if (ui == null) {
+            Log.d(this, "just return ui:" + ui);
+            return;
+        }
+        Context context = ui.getContext();
+        if (context == null) {
+            Log.d(this, "just return context:" + context);
+            return;
+        }
+        if (call == null) {
+            Log.d(this, "just return call:" + call);
+            return;
+        }
+        ui.setEnabled(false);
+        ui.showButton(BUTTON_MERGE, false);
+        ui.showButton(BUTTON_SWITCH_VOICE_RECORD, false);
+        ui.showButton(BUTTON_ADD_CALL, true);
+        ui.enableButton(BUTTON_ADD_CALL, false);
+        final boolean canHold = call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
+        ui.displayDialpad(getUi().isDialpadVisible(), true);
+        ui.showButton(BUTTON_HOLD, canHold);
+    }
+
+    /**
+     * Instructs Telecom to disconnect all the calls.
+     */
+    public void hangupAllClicked() {
+        Log.d(this, "Hangup all calls");
+        TelecomAdapter.getInstance().hangupAll();
+    }
+
+    /**
+     * Instructs Telecom to disconnect all the HOLDING calls.
+     */
+    public void hangupAllHoldCallsClicked() {
+        Log.d(this, "Hangup all hold calls");
+        TelecomAdapter.getInstance().hangupAllHoldCalls();
+    }
+
+    /**
+     * Instructs Telecom to disconnect active call and answer waiting call.
+     */
+    public void hangupActiveAndAnswerWaitingClicked() {
+        Log.d(this, "Hangup active and answer waiting");
+        TelecomAdapter.getInstance().hangupActiveAndAnswerWaiting();
+    }
+
+    /**
+     * M: Check whether the call is ECC.
+     * @param call current call
+     * @return true if is ECC call
+     */
+    private boolean isEmergencyCall(Call call) {
+        if (call != null) {
+            Uri handle = call.getHandle();
+            if (handle != null) {
+                String number = handle.getSchemeSpecificPart();
+                if (!TextUtils.isEmpty(number)) {
+                    return PhoneNumberUtils.isEmergencyNumber(number);
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * M: get the ECT capable call.
+     * For ECT, we just check the hold call.
+     */
+    private Call getTheCallWithEctCapable() {
+        final Call call = CallList.getInstance().getBackgroundCall();
+        if (call != null && call.can(android.telecom.Call.Details.CAPABILITY_ECT)) {
+            return call;
+        }
+        return null;
+    }
+
+    /**
+     * M: Instructs Telecom to select Ect Menu.
+     */
+    public void onEctMenuSelected() {
+        final Call call = getTheCallWithEctCapable();
+        if (call != null) {
+            TelecomAdapter.getInstance().explicitCallTransfer(call.getTelecomCall().getCallId());
+        }
+    }
+
+    /**
+     * M: Start transfer dialog to input or select transfer number
+     */
+    public void onBlindEctMenuSelected() {
+        if (mCall == null) {
+            return;
+        }
+        if (getUi().getContext() != null) {
+            AddTransferNumberScreenController.getInstance().showAddTransferNumberDialog(
+                    getUi().getContext(), mCall.getId());
+        }
+    }
+
+    /** M: [Voice Record] switch the state of voice recording @{ */
+    public void voiceRecordClicked() {
+        TelecomAdapter.getInstance().startVoiceRecording();
+    }
+
+    public void stopRecordClicked() {
+        TelecomAdapter.getInstance().stopVoiceRecording();
+    }
+
+    @Override
+    public void onUpdateRecordState(int state, int customValue) {
+        if (FeatureOptionWrapper.isSupportPhoneVoiceRecording()) {
+            final CallButtonUi ui = getUi();
+            if (ui != null) {
+                ui.configRecordingButton();
+            }
+        }
+    }
+    /** @} */
+
+    /**
+     * M: update VideoButtonUi
+     *
+     * @param call
+     * @param isVideo indicate current call is video call or not.
+     */
+    public void updateVideoButtonUI(Call call, boolean isVideo) {
+        final CallButtonUi ui = getUi();
+        //only call is active, can show video button can operate camera.
+        int callState = call.getState();
+        boolean isCallActive = callState == Call.State.ACTIVE;
+
+        // find whether it's held state, when held state can't do video operation
+        boolean currentHeldState = false;
+        android.telecom.Call.Details details = call.getDetails();
+        if (details == null) {
+            currentHeldState = false;
+        }
+        currentHeldState = call.isHeld();
+
+        final boolean showUpgradeToVideoEx = (!isVideo
+                && ExtensionManager.getInCallButtonExt().isVideoCallCapable(call.getNumber()));
+        /// FIXME: bug here!!! should not use "||" to combine these conditions.
+        /// Plugin should be able to no show even if Host said yet.
+        final boolean showUpgradeToVideo = showUpgradeToVideoEx
+                || (!isVideo
+                    && hasVideoCallCapabilities(call)
+                    && call.getVideoFeatures().canUpgradeToVideoCall());
+
+        Log.d(this, "[updateVideoButtonUI] showUpgradeToVideo:" + showUpgradeToVideo
+                + "callState:" + callState);
+
+        final boolean showUpgradeBtn = (showUpgradeToVideo
+                || call.getVideoFeatures().forceEnableVideo())
+                && isCallActive && !currentHeldState;
+        final boolean showSwitchBtn = isVideo && isCallActive && !currentHeldState;
+        final boolean showPauseVideoBtn = isVideo
+                && call.getVideoFeatures().supportsPauseVideo()
+                && isCallActive && !currentHeldState
+                /// M: we should not show pause button if no peer video from remote.
+                && VideoProfile.isReceptionEnabled(call.getVideoState());
+        final boolean showHideLocalVideoBtn = isVideo
+                && call.getVideoFeatures().supportsHidePreview()
+                && isCallActive && !currentHeldState;
+          final boolean showDowngradBtn = isVideo && isDowngradeToAudioSupported(call)
+                && call.getVideoFeatures().supportsDowngrade()
+                && isCallActive && !currentHeldState;
+        final boolean showManageVideoConBtn = isVideo
+                && call.can(android.telecom.Call.Details.CAPABILITY_MANAGE_CONFERENCE)
+                && isCallActive;
+        //we will set VideoBtn Enable except the instantaneous state
+        final boolean canEnableVideoBtn =
+                call.getSessionModificationState()
+                != Call.SessionModificationState.WAITING_FOR_UPGRADE_RESPONSE
+            && call.getSessionModificationState()
+                != Call.SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST
+            && call.getSessionModificationState()
+                != Call.SessionModificationState.WAITING_FOR_DOWNGRADE_RESPONSE
+            && call.getSessionModificationState()
+                != Call.SessionModificationState.WAITING_FOR_PAUSE_VIDEO_RESPONSE
+            && call.getSessionModificationState()
+                != Call.SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST_ONE_WAY
+            && call.getSessionModificationState()
+                != Call.SessionModificationState.WAITING_FOR_CANCEL_UPGRADE_RESPONSE;
+
+
+         /// M:show cancel button after upgrade request is sent @{
+       final boolean showCancelUpgrade = !isVideo && isCallActive
+           && call.getVideoFeatures().supportsCancelUpgradeVideo()
+           &&(call.getSessionModificationState()
+               == Call.SessionModificationState.WAITING_FOR_UPGRADE_RESPONSE );
+
+       Log.d(this, "[updateVideoButtonUI] showCancelUpgrade: " + showCancelUpgrade
+                       + ", session_state: " + call.getSessionModificationState());
+       ///@}
+
+        // when pause video make one way  and only can receive video, we can't show
+        // switch camera button
+        final boolean isCameraOff = call.getVideoState() == VideoProfile.STATE_RX_ENABLED;
+        /// M: fix CR:ALPS02847667 to support show both hold and swap
+        boolean showHold = call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD)
+              && call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
+        if (isVideo) {
+            showHold &= call.getVideoFeatures().supportsHold();
+        }
+
+        // M: fix CR:ALPS02698355,don't show voice record when receive upgrade request.
+        // [Voice Record] check if should display record
+        final boolean canRecordVoice = call
+                .can(android.telecom.Call.Details.CAPABILITY_VOICE_RECORD)
+                && !InCallUtils.isDMLocked()
+                && !VideoUtils.isVideoCall(call)
+                && UserManagerCompat.isUserUnlocked(ui.getContext());
+
+        //add canEnableVideoBtn flag to control showing hold button is avoid this case:
+        //when there was a volte call, we can do some video action, during this action,
+        //we can't show hold button. by another way if there was a voice call, it's
+        //SessionModificationState  always is no_request, so meet the requestment.
+        ui.showButton(BUTTON_HOLD, showHold && canEnableVideoBtn);
+        ui.showButton(BUTTON_UPGRADE_TO_VIDEO, showUpgradeBtn && canEnableVideoBtn);
+        ui.showButton(BUTTON_SWITCH_CAMERA, showSwitchBtn && canEnableVideoBtn && !isCameraOff);
+        ui.showButton(BUTTON_PAUSE_VIDEO, showPauseVideoBtn && canEnableVideoBtn);
+        /// M:add hide Local preview button and downgrade button
+        ui.showButton(BUTTON_HIDE_LOCAL_VIDEO, showHideLocalVideoBtn && canEnableVideoBtn);
+        ui.showButton(BUTTON_DOWNGRADE_TO_AUDIO, showDowngradBtn && canEnableVideoBtn);
+        /// end add local preview and downgrade button @}
+
+        /// M:add show Video manage conference button
+        ui.showButton(BUTTON_MANAGE_VIDEO_CONFERENCE, showManageVideoConBtn && canEnableVideoBtn);
+
+        /// M:add show cancel upgrade button
+        //ui.showButton(BUTTON_CANCEL_UPGRADE, showCancelUpgrade);
+
+        /// end add manage conference button @}
+        /// end only call state is active  can show video button @}
+        if (!canEnableVideoBtn) {
+            ui.showButton(BUTTON_ADD_CALL, false);
+        }
+
+        if (showPauseVideoBtn && canEnableVideoBtn) {
+            /// Rx only: already set to paused state
+            /// Bidirectional: normal case, didn't press pause
+            /// Tx only / voice: the pause button would hide, no need update
+            ui.setVideoPaused(!VideoProfile.isBidirectional(call.getVideoState()));
+        }
+        /** M: fix CR:ALPS02698355,don't show voice record when receive upgrade request.
+         * [Voice Record] support voice recording @{ */
+        final boolean showRecording = UserHandle.myUserId()
+                == UserHandle.USER_OWNER && canRecordVoice && canEnableVideoBtn;
+        ui.showButton(BUTTON_SWITCH_VOICE_RECORD, showRecording);
+        if (showRecording) {
+            ui.configRecordingButton();
+        }
+        /** @} */
+    }
+
+    @Override
+    public void onCallChanged(Call call) {
+        // no op
+    }
+
+    @Override
+    public void onSessionModificationStateChange(int sessionModificationState) {
+        if(mCall == null) {
+            return;
+        }
+        updateButtonsState(mCall);
+    }
+    /// end update VideoButtonUi @}
+
+    /**
+     * M: when ony way remote side set SessionModificationState,
+     * we change to default according to videostate
+     *
+     * @param call
+     */
+    private void updateVideoCallSessionState(Call call) {
+        if (call == null) {
+            return;
+        }
+        /// M: Toggle Speaker when video state changes.
+        ExtensionManager.getVideoCallExt().onVideoStateChange(call, this);
+        if (call.getSessionModificationState()
+                == Call.SessionModificationState.WAITING_FOR_DOWNGRADE_RESPONSE) {
+            if (call.getVideoState() == VideoProfile.STATE_AUDIO_ONLY) {
+                call.setSessionModificationState(Call.SessionModificationState.NO_REQUEST);
+            }
+        } else if (call.getSessionModificationState()
+                == Call.SessionModificationState.WAITING_FOR_PAUSE_VIDEO_RESPONSE) {
+            if (call.getVideoState() == VideoProfile.STATE_TX_ENABLED) {
+                call.setSessionModificationState(Call.SessionModificationState.NO_REQUEST);
+            }
+        } else if (call.getSessionModificationState()
+                == Call.SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST_ONE_WAY) {
+            if (call.getVideoState() == VideoProfile.STATE_BIDIRECTIONAL) {
+                call.setSessionModificationState(Call.SessionModificationState.NO_REQUEST);
+            }
+        }
+    }
+
+    @Override
+    public void onLastForwardedNumberChange() {
+        // no-op
+    }
+
+    @Override
+    public void onChildNumberChange() {
+        // no-op
+    }
+}
Index: vendor/branch/5058A_Bitel_Peru/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
===================================================================
--- vendor/branch/5058A_Bitel_Peru/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	(revision 0)
+++ vendor/branch/5058A_Bitel_Peru/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	(revision 14879)
@@ -0,0 +1,863 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.phone;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.ActivityOptions;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Bundle;
+import android.os.PersistableBundle;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telephony.CarrierConfigManager;
+import android.telephony.PhoneStateListener;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsException;
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.phone.PhoneGlobals.SubInfoUpdateListener;
+import com.android.phone.common.util.SettingsUtil;
+import com.android.phone.settings.AccountSelectionPreference;
+import com.android.phone.settings.PhoneAccountSettingsFragment;
+import com.android.phone.settings.VoicemailSettingsActivity;
+import com.android.phone.settings.fdn.FdnSetting;
+import com.android.services.telephony.sip.SipUtil;
+
+import com.mediatek.ims.config.ImsConfigContract;
+import com.mediatek.phone.ext.DefaultCallFeaturesSettingExt;
+import com.mediatek.phone.ext.ExtensionManager;
+import com.mediatek.phone.ext.ICallFeaturesSettingExt;
+import com.mediatek.settings.CallBarring;
+import com.mediatek.settings.IpPrefixPreference;
+import com.mediatek.settings.TelephonyUtils;
+import com.mediatek.settings.cdg.CdgCallSettings;
+import com.mediatek.settings.cdg.CdgUtils;
+import com.mediatek.settings.cdma.CdmaCallForwardOptions;
+import com.mediatek.settings.cdma.CdmaCallWaitOptions;
+import com.mediatek.settings.vtss.GsmUmtsVTCBOptions;
+import com.mediatek.settings.vtss.GsmUmtsVTCFOptions;
+import com.mediatek.settings.cdma.CdmaCallWaitingUtOptions;
+import com.mediatek.settings.cdma.TelephonyUtilsEx;
+
+import java.lang.String;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Top level "Call settings" UI; see res/xml/call_feature_setting.xml
+ *
+ * This preference screen is the root of the "Call settings" hierarchy available from the Phone
+ * app; the settings here let you control various features related to phone calls (including
+ * voicemail settings, the "Respond via SMS" feature, and others.)  It's used only on
+ * voice-capable phone devices.
+ *
+ * Note that this activity is part of the package com.android.phone, even
+ * though you reach it from the "Phone" app (i.e. DialtactsActivity) which
+ * is from the package com.android.contacts.
+ *
+ * For the "Mobile network settings" screen under the main Settings app,
+ * See {@link MobileNetworkSettings}.
+ *
+ * @see com.android.phone.MobileNetworkSettings
+ */
+public class CallFeaturesSetting extends PreferenceActivity
+        implements Preference.OnPreferenceChangeListener,
+                SubInfoUpdateListener {
+    private static final String LOG_TAG = "CallFeaturesSetting";
+    private static final boolean DBG = true;//(PhoneGlobals.DBG_LEVEL >= 2);
+
+    // String keys for preference lookup
+    // TODO: Naming these "BUTTON_*" is confusing since they're not actually buttons(!)
+    // TODO: Consider moving these strings to strings.xml, so that they are not duplicated here and
+    // in the layout files. These strings need to be treated carefully; if the setting is
+    // persistent, they are used as the key to store shared preferences and the name should not be
+    // changed unless the settings are also migrated.
+    private static final String VOICEMAIL_SETTING_SCREEN_PREF_KEY = "button_voicemail_category_key";
+    private static final String BUTTON_FDN_KEY   = "button_fdn_key";
+    private static final String BUTTON_RETRY_KEY       = "button_auto_retry_key";
+    private static final String BUTTON_GSM_UMTS_OPTIONS = "button_gsm_more_expand_key";
+    private static final String BUTTON_CDMA_OPTIONS = "button_cdma_more_expand_key";
+
+    /// M: add for call private voice feature @{
+    private static final String BUTTON_CP_KEY          = "button_voice_privacy_key";
+    /// @}
+
+    private static final String CALL_FORWARDING_KEY = "call_forwarding_key";
+    private static final String ADDITIONAL_GSM_SETTINGS_KEY = "additional_gsm_call_settings_key";
+    /// M: GSM type phone call settings item --> call barring
+    private static final String BUTTON_CB_EXPAND = "button_cb_expand_key";
+
+    /// M: CDMA type phone call settings item --> call forward & call wait
+    private static final String KEY_CALL_FORWARD = "button_cf_expand_key";
+    private static final String KEY_CALL_WAIT = "button_cw_key";
+    private static final String KEY_CALLER_ID = "button_caller_id";
+
+    private static final String IP_PREFIX_KEY = "button_ip_prefix_key";
+
+    private static final String PHONE_ACCOUNT_SETTINGS_KEY =
+            "phone_account_settings_preference_screen";
+
+    private static final String ENABLE_VIDEO_CALLING_KEY = "button_enable_video_calling";
+
+    private Phone mPhone;
+    private SubscriptionInfoHelper mSubscriptionInfoHelper;
+    private TelecomManager mTelecomManager;
+
+    private CheckBoxPreference mButtonAutoRetry;
+    private PreferenceScreen mVoicemailSettingsScreen;
+    private CheckBoxPreference mEnableVideoCalling;
+
+    /*
+     * Click Listeners, handle click based on objects attached to UI.
+     */
+
+    // Click listener for all toggle events
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
+        /// M: Add for our inner features @{
+        if (onPreferenceTreeClickMTK(preferenceScreen, preference)) {
+            return true;
+        }
+        /// @}
+        if (preference == mButtonAutoRetry) {
+            android.provider.Settings.Global.putInt(getApplicationContext().getContentResolver(),
+                    android.provider.Settings.Global.CALL_AUTO_RETRY,
+                    mButtonAutoRetry.isChecked() ? 1 : 0);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Implemented to support onPreferenceChangeListener to look for preference
+     * changes.
+     *
+     * @param preference is the preference to be changed
+     * @param objValue should be the value of the selection, NOT its localized
+     * display value.
+     */
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object objValue) {
+        if (DBG) log("onPreferenceChange: \"" + preference + "\" changed to \"" + objValue + "\"");
+
+        if (preference == mEnableVideoCalling) {
+            int phoneId = TelephonyUtils.getMainCapabilityPhoneId(mPhone.getContext());
+            if (TelephonyUtils.isSupportMims()) {
+               phoneId = SubscriptionManager.getPhoneId(mPhone.getSubId());
+            }
+            int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+            log("onPreferenceChange phoneId:" + phoneId + " subId:" + subId);
+            if (ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext(), phoneId)) {
+                PhoneGlobals.getInstance().phoneMgrEx.enableVideoCalling((boolean) objValue, subId);
+                ///M: For Plugin to get updated video Preference
+                ExtensionManager.getCallFeaturesSettingExt()
+                                .videoPreferenceChange((boolean) objValue);
+            } else {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                DialogInterface.OnClickListener networkSettingsClickListener =
+                        new Dialog.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                startActivity(new Intent(mPhone.getContext(),
+                                        com.android.phone.MobileNetworkSettings.class));
+                            }
+                        };
+                builder.setMessage(getResources().getString(
+                                R.string.enable_video_calling_dialog_msg))
+                        .setNeutralButton(getResources().getString(
+                                R.string.enable_video_calling_dialog_settings),
+                                networkSettingsClickListener)
+                        .setPositiveButton(android.R.string.ok, null)
+                        .show();
+                return false;
+            }
+        }
+
+        // Always let the preference setting proceed.
+        return true;
+    }
+
+    @Override
+    protected void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+        if (DBG) log("onCreate: Intent is " + getIntent());
+
+        // Make sure we are running as an admin user.
+        if (!UserManager.get(this).isAdminUser()) {
+            Toast.makeText(this, R.string.call_settings_admin_user_only,
+                    Toast.LENGTH_SHORT).show();
+            finish();
+            return;
+        }
+
+        mSubscriptionInfoHelper = new SubscriptionInfoHelper(this, getIntent());
+        mSubscriptionInfoHelper.setActionBarTitle(
+                getActionBar(), getResources(), R.string.call_settings_with_label);
+        mPhone = mSubscriptionInfoHelper.getPhone();
+        mTelecomManager = TelecomManager.from(this);
+        /// M: Register related listeners & events.
+        registerEventCallbacks();
+        /// M: Add for MTK hotswap
+        if (mPhone == null) {
+            log("onCreate: mPhone is null, finish!!!");
+            finish();
+            return;
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        TelephonyManager telephonyManager =
+                (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_NONE);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        PreferenceScreen preferenceScreen = getPreferenceScreen();
+        if (preferenceScreen != null) {
+            preferenceScreen.removeAll();
+        }
+
+        addPreferencesFromResource(R.xml.call_feature_setting);
+
+        TelephonyManager telephonyManager =
+                (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
+
+        Preference phoneAccountSettingsPreference = findPreference(PHONE_ACCOUNT_SETTINGS_KEY);
+        if (telephonyManager.isMultiSimEnabled() || !SipUtil.isVoipSupported(mPhone.getContext())) {
+            getPreferenceScreen().removePreference(phoneAccountSettingsPreference);
+        }
+
+        PreferenceScreen prefSet = getPreferenceScreen();
+        mVoicemailSettingsScreen =
+                (PreferenceScreen) findPreference(VOICEMAIL_SETTING_SCREEN_PREF_KEY);
+        Intent voiceMailIntent = new Intent(this, VoicemailSettingsActivity.class);
+        SubscriptionInfoHelper.addExtrasToIntent(voiceMailIntent, SubscriptionManager
+                                        .from(this).getSubscriptionInfo(mPhone.getSubId()));
+        mVoicemailSettingsScreen.setIntent(voiceMailIntent);
+
+        mButtonAutoRetry = (CheckBoxPreference) findPreference(BUTTON_RETRY_KEY);
+
+        mEnableVideoCalling = (CheckBoxPreference) findPreference(ENABLE_VIDEO_CALLING_KEY);
+
+        PersistableBundle carrierConfig =
+                PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
+
+        if (carrierConfig.getBoolean(CarrierConfigManager.KEY_AUTO_RETRY_ENABLED_BOOL)) {
+            mButtonAutoRetry.setOnPreferenceChangeListener(this);
+            int autoretry = Settings.Global.getInt(
+                    getContentResolver(), Settings.Global.CALL_AUTO_RETRY, 0);
+            mButtonAutoRetry.setChecked(autoretry != 0);
+        } else {
+            prefSet.removePreference(mButtonAutoRetry);
+            mButtonAutoRetry = null;
+        }
+        Intent fdnIntent = new Intent(this, FdnSetting.class);
+        SubscriptionInfoHelper.addExtrasToIntent(fdnIntent, SubscriptionManager
+                                        .from(this).getSubscriptionInfo(mPhone.getSubId()));
+        Preference cdmaOptions = prefSet.findPreference(BUTTON_CDMA_OPTIONS);
+        Preference gsmOptions = prefSet.findPreference(BUTTON_GSM_UMTS_OPTIONS);
+        if (carrierConfig.getBoolean(CarrierConfigManager.KEY_WORLD_PHONE_BOOL)) {
+            cdmaOptions.setIntent(mSubscriptionInfoHelper.getIntent(CdmaCallOptions.class));
+            gsmOptions.setIntent(mSubscriptionInfoHelper.getIntent(GsmUmtsCallOptions.class));
+        } else {
+            prefSet.removePreference(cdmaOptions);
+            prefSet.removePreference(gsmOptions);
+
+            int phoneType = mPhone.getPhoneType();
+            Preference fdnButton = prefSet.findPreference(BUTTON_FDN_KEY);
+            if (carrierConfig.getBoolean(
+                    CarrierConfigManager.KEY_HIDE_CARRIER_NETWORK_SETTINGS_BOOL)) {
+                prefSet.removePreference(fdnButton);
+            } else {
+                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA
+                        /// M: [CT VOLTE]
+                        || (TelephonyUtilsEx.isCtVolteEnabled() && TelephonyUtilsEx
+                            .isCtSim(mPhone.getSubId())) || TelephonyUtilsEx
+                            .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+
+                    /// Add for CDG OMH, show fdn when CDG OMH SIM card. @{
+                    if(CdgUtils.isCdgOmhSimCard(mPhone.getSubId())) {
+                        fdnButton.setIntent(fdnIntent);
+                    } else {
+                    /// @}
+                        prefSet.removePreference(fdnButton);
+                    }
+
+                    if (!carrierConfig.getBoolean(
+                            CarrierConfigManager.KEY_VOICE_PRIVACY_DISABLE_UI_BOOL)) {
+                        addPreferencesFromResource(R.xml.cdma_call_privacy);
+                        /// M: for ALPS02087723, get the right cdma phone instance @{
+                        CdmaVoicePrivacyCheckBoxPreference ccp =
+                                (CdmaVoicePrivacyCheckBoxPreference)findPreference(BUTTON_CP_KEY);
+                        if (ccp != null) {
+                            /// M: [CT VOLTE]
+                            if ((TelephonyUtilsEx.isCtVolteEnabled() && TelephonyUtilsEx
+                                .isCtSim(mPhone.getSubId())) || TelephonyUtilsEx
+                                .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+                                log("Voice privacy option removed");
+                                prefSet.removePreference(ccp);
+                            } else {
+                               ccp.setPhone(mPhone);
+                            }
+                        }
+                        /// @}
+                    }
+                    /// M: For C2K project to group GSM and C2K Call Settings @{
+                    log("isCdmaSupport = " + TelephonyUtils.isCdmaSupport());
+                    if (TelephonyUtils.isCdmaSupport()) {
+                        addPreferencesFromResource(R.xml.mtk_cdma_call_options);
+                    if (!TelephonyUtilsEx
+                                   .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+                             Preference callerIDPreference = prefSet.findPreference(KEY_CALLER_ID);
+                             log("No SmartFren SIM, so remove Caller ID pref for CDMA");
+                             prefSet.removePreference(callerIDPreference);
+                         }
+                    }
+                    /// @}
+                } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
+                    fdnButton.setIntent(fdnIntent);
+
+                    if (carrierConfig.getBoolean(
+                            CarrierConfigManager.KEY_ADDITIONAL_CALL_SETTING_BOOL)) {
+                        addPreferencesFromResource(R.xml.gsm_umts_call_options);
+                        GsmUmtsCallOptions.init(prefSet, mSubscriptionInfoHelper);
+                    }
+                } else {
+                    throw new IllegalStateException("Unexpected phone type: " + phoneType);
+                }
+            }
+        }
+
+        /// M: VILTE enable not dependent on data enable for some operators @{
+        boolean isNonDepOnData = carrierConfig.getBoolean(
+                        CarrierConfigManager.KEY_VILTE_ENABLE_NOT_DEPENDENT_ON_DATA_ENABLE_BOOL);
+        /// @}
+        int phoneId = TelephonyUtils.getMainCapabilityPhoneId(mPhone.getContext());
+        if (TelephonyUtils.isSupportMims()) {
+            phoneId = SubscriptionManager.getPhoneId(mPhone.getSubId());
+        }
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        log("Get VT Setting for phoneId:" + phoneId + " subId:" + subId);
+        if (ImsManager.isVtEnabledByPlatform(mPhone.getContext(), phoneId) &&
+                ImsManager.isVtProvisionedOnDevice(mPhone.getContext()) &&
+                (mPhone.mDcTracker.isDataEnabled(true) || isNonDepOnData)) {
+            boolean currentValue =
+                    ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext(), phoneId)
+                    ? PhoneGlobals.getInstance().phoneMgrEx.isVideoCallingEnabled(
+                            getOpPackageName(), subId) : false;
+            mEnableVideoCalling.setChecked(currentValue);
+            mEnableVideoCalling.setOnPreferenceChangeListener(this);
+        } else {
+            prefSet.removePreference(mEnableVideoCalling);
+        }
+
+        if (ImsManager.isVolteEnabledByPlatform(this) &&
+                !carrierConfig.getBoolean(
+                        CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
+            TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+            /* tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); */
+        }
+        PersistableBundle carrierConfigBundle = PhoneGlobals.getInstance()
+                                                            .getCarrierConfigForSubId(subId);
+        boolean removeWfcPrefMode = carrierConfigBundle.getBoolean(
+                         CarrierConfigManager.KEY_WFC_REMOVE_PREFERENCE_MODE_BOOL);
+        Log.d(LOG_TAG, "removeWfcPrefMode:" + removeWfcPrefMode);
+        Preference wifiCallingSettings = findPreference(
+                getResources().getString(R.string.wifi_calling_settings_key));
+
+        final PhoneAccountHandle simCallManager = mTelecomManager.getSimCallManager();
+        if (simCallManager != null) {
+            Intent intent = PhoneAccountSettingsFragment.buildPhoneAccountConfigureIntent(
+                    this, simCallManager);
+            Log.d(LOG_TAG, "--- simCallManager is not null ---");
+            if (intent != null) {
+                PackageManager pm = mPhone.getContext().getPackageManager();
+                List<ResolveInfo> resolutions = pm.queryIntentActivities(intent, 0);
+                if (!resolutions.isEmpty()) {
+                    Log.d(LOG_TAG, "--- set wfc ---");
+                    wifiCallingSettings.setTitle(resolutions.get(0).loadLabel(pm));
+                    wifiCallingSettings.setSummary(null);
+                    wifiCallingSettings.setIntent(intent);
+                } else {
+                    Log.d(LOG_TAG, "Remove WFC Preference since resolutions is empty");
+                    prefSet.removePreference(wifiCallingSettings);
+                }
+            } else {
+                Log.d(LOG_TAG, "Remove WFC Preference since PhoneAccountConfigureIntent is null");
+                prefSet.removePreference(wifiCallingSettings);
+            }
+        } else if (!TelephonyUtils.isSupportMims() &&
+                   (!ImsManager.isWfcEnabledByPlatform(mPhone.getContext()) ||
+                    !ImsManager.isWfcProvisionedOnDevice(mPhone.getContext()))) {
+            Log.d(LOG_TAG, "--- remove wfc,platform support : "
+                    + ImsManager.isWfcEnabledByPlatform(mPhone.getContext()));
+            prefSet.removePreference(wifiCallingSettings);
+        } else {
+            if (TelephonyUtils.isSupportMims() || removeWfcPrefMode) {
+                wifiCallingSettings.setSummary("");
+                Log.d(LOG_TAG, "Multi IMS support so no wfc summary");
+            } else {
+            int resId = com.android.internal.R.string.wifi_calling_off_summary;
+                if (ImsManager.isWfcEnabledByUser(mPhone.getContext())) {
+                    int wfcMode = ImsManager.getWfcMode(mPhone.getContext());
+                    switch (wfcMode) {
+                        case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
+                           resId = com.android.internal.R.string.wfc_mode_wifi_only_summary;
+                           break;
+                        case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
+                           resId = com.android.internal.R.string
+                                               .wfc_mode_cellular_preferred_summary;
+                           break;
+                        case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
+                           resId = com.android.internal.R.string.wfc_mode_wifi_preferred_summary;
+                           break;
+                        default:
+                           if (DBG) log("Unexpected WFC mode value: " + wfcMode);
+                    }
+                }
+                wifiCallingSettings.setSummary(resId);
+            }
+        }
+
+        ///M: [OMH]
+        updateOmhItems();
+
+        /// M: [IP-prefix]
+        setIpFunction();
+
+        /// M: update screen status
+        updateScreenStatus();
+
+        /// M: WFC @{
+        ExtensionManager.getCallFeaturesSettingExt().initOtherCallFeaturesSetting(this);
+        ExtensionManager.getCallFeaturesSettingExt()
+                .onCallFeatureSettingsEvent(DefaultCallFeaturesSettingExt.RESUME);
+        /// @}
+    }
+
+    @Override
+    protected void onNewIntent(Intent newIntent) {
+        setIntent(newIntent);
+
+        mSubscriptionInfoHelper = new SubscriptionInfoHelper(this, getIntent());
+        mSubscriptionInfoHelper.setActionBarTitle(
+                getActionBar(), getResources(), R.string.call_settings_with_label);
+        mPhone = mSubscriptionInfoHelper.getPhone();
+    }
+
+    private static void log(String msg) {
+        Log.d(LOG_TAG, msg);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        final int itemId = item.getItemId();
+        if (itemId == android.R.id.home) {  // See ActionBar#setDisplayHomeAsUpEnabled()
+            onBackPressed();
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * Finish current Activity and go up to the top level Settings ({@link CallFeaturesSetting}).
+     * This is useful for implementing "HomeAsUp" capability for second-level Settings.
+     */
+    public static void goUpToTopLevelSetting(
+            Activity activity, SubscriptionInfoHelper subscriptionInfoHelper) {
+        Intent intent = subscriptionInfoHelper.getIntent(CallFeaturesSetting.class);
+        intent.setAction(Intent.ACTION_MAIN);
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        activity.startActivity(intent);
+        activity.finish();
+    }
+
+    // -------------------- Mediatek ---------------------
+    /// M: Add for plug-in @{
+    private ICallFeaturesSettingExt mExt;
+    /// Add for CDG OMH
+    private CdgCallSettings mCdgCallSettings = null;
+    private static final String ACTION_OMH = "com.mediatek.internal.omh.cardcheck";
+
+
+    /**
+     * Add for IMS provisioning
+     */
+    private void updateVtOption() {
+        new Thread() {
+
+            // TODO: to check this API, should not be using another thread in UI code
+            @Override
+            public void run() {
+                try{
+                    ImsManager ims = ImsManager.getInstance(
+                            mPhone.getContext(), mPhone.getPhoneId());
+                    ImsConfig imsCfg = ims.getConfigInterface();
+                    /// getVtProvisioned api contains two cases:
+                    /// 1. Don't support provision, it will return true, so that
+                    ///    the provision value will not affect the decision(show/not)
+                    /// 2. Support provision, it will return the current status.
+                    int phoneId = TelephonyUtils.getMainCapabilityPhoneId(mPhone.getContext());
+                    if (TelephonyUtils.isSupportMims()) {
+                        phoneId = SubscriptionManager.getPhoneId(mPhone.getSubId());
+                    }
+                    boolean enableProvision = imsCfg.getVtProvisioned();
+                    boolean enablePlatform = ImsManager.isVtEnabledByPlatform(
+                            mPhone.getContext(), phoneId);
+                    log("updateVtOption enableProvision = " + enableProvision
+                            + "enablePlatform = " + enablePlatform);
+
+                    PreferenceScreen prefSet = getPreferenceScreen();
+                    if (enableProvision && enablePlatform) {
+                        if (prefSet != null && mEnableVideoCalling == null) {
+                            prefSet.addPreference(mEnableVideoCalling);
+                        }
+                    }
+                } catch (ImsException e) {
+                    e.printStackTrace();
+                }
+            }
+        }.start();
+    }
+    /// @}
+
+    private void updateOmhItems() {
+        if (CdgUtils.isCdgOmhSimCard(mSubscriptionInfoHelper.getSubId())) {
+            log("new CdgCallSettings.");
+            mCdgCallSettings = new CdgCallSettings(this, mSubscriptionInfoHelper);
+            Preference callForwardPreference = this.findPreference(KEY_CALL_FORWARD);
+            if (callForwardPreference != null) {
+                this.getPreferenceScreen().removePreference(callForwardPreference);
+            }
+
+            Preference callWaitPreference = this.findPreference(KEY_CALL_WAIT);
+            if (callWaitPreference != null) {
+                this.getPreferenceScreen().removePreference(callWaitPreference);
+            }
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        if (UserManager.get(this).isAdminUser()) {
+            /// M: WFC @{
+            ExtensionManager.getCallFeaturesSettingExt()
+                    .onCallFeatureSettingsEvent(DefaultCallFeaturesSettingExt.DESTROY);
+            /// @}
+            unregisterEventCallbacks();
+        }
+        /// M: add for dual volte feature @{
+        TelephonyUtils.setParameters(null, null, null);
+        /// @}
+        super.onDestroy();
+    }
+
+    @Override
+    public void handleSubInfoUpdate() {
+        finish();
+    }
+
+    /**
+     * For internal features
+     * @param preferenceScreen
+     * @param preference
+     * @return
+     */
+    private boolean onPreferenceTreeClickMTK(
+            PreferenceScreen preferenceScreen, Preference preference) {
+
+        log("onPreferenceTreeClickMTK" + preference.getKey());
+        /// M: add for dual volte feature @{
+        TelephonyUtils.setParameters(preferenceScreen, preference, mSubscriptionInfoHelper);
+        /// @}
+        /// Add for [VoLTE_SS] @{
+        if (preference == preferenceScreen.findPreference(CALL_FORWARDING_KEY) ||
+            preference == preferenceScreen.findPreference(ADDITIONAL_GSM_SETTINGS_KEY) ||
+            preference == preferenceScreen.findPreference(BUTTON_CB_EXPAND)) {
+
+            if (TelephonyUtils.shouldShowOpenMobileDataDialog(
+                    this, mPhone.getSubId())) {
+                TelephonyUtils.showOpenMobileDataDialog(this, mPhone.getSubId());
+            } else {
+                Intent intent;
+                if (preference == preferenceScreen.findPreference(CALL_FORWARDING_KEY)) {
+                    if (ExtensionManager.getCallFeaturesSettingExt().openVtCf()) {
+                        intent = mSubscriptionInfoHelper.getIntent(GsmUmtsVTCFOptions.class);
+                    } else {
+                        intent = mSubscriptionInfoHelper.getIntent(GsmUmtsCallForwardOptions.class);
+                    }
+
+                } else if (preference == preferenceScreen.findPreference(BUTTON_CB_EXPAND)) {
+                    if (ExtensionManager.getCallFeaturesSettingExt().openVtCb()) {
+                        intent = mSubscriptionInfoHelper.getIntent(GsmUmtsVTCBOptions.class);
+                    } else {
+                        intent = mSubscriptionInfoHelper.getIntent(CallBarring.class);
+                    }
+                } else {
+                    intent = mSubscriptionInfoHelper.getIntent(GsmUmtsAdditionalCallOptions.class);
+                }
+                SubscriptionInfoHelper.addExtrasToIntent(intent, SubscriptionManager
+                                      .from(this).getSubscriptionInfo(mPhone.getSubId()));
+                startActivity(intent);
+            }
+            return true;
+        }
+        /// @}
+        /// M: CDMA type phone call setting item click handling
+        if (preference == preferenceScreen.findPreference(KEY_CALL_FORWARD) ||
+            preference == preferenceScreen.findPreference(KEY_CALL_WAIT) ||
+            preference == preferenceScreen.findPreference(KEY_CALLER_ID)) {
+            /// M: [CT VOLTE] @{
+            if (((TelephonyUtilsEx.isCtVolteEnabled() && TelephonyUtilsEx
+                        .isCt4gSim(mPhone.getSubId())) || TelephonyUtilsEx
+                        .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId()))
+                    && TelephonyUtils.shouldShowOpenMobileDataDialog(this, mPhone.getSubId())) {
+                TelephonyUtils.showOpenMobileDataDialog(this, mPhone.getSubId());
+            } else {
+            /// @}
+                if (preference == preferenceScreen.findPreference(KEY_CALL_FORWARD)) {
+                    Intent intent;
+                    /// M:[CT VOLTE] @{
+                    if ((TelephonyUtilsEx.isCtVolteEnabled() && TelephonyUtilsEx
+                            .isCt4gSim(mPhone.getSubId())) || TelephonyUtilsEx
+                            .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+                        intent = mSubscriptionInfoHelper.getIntent(GsmUmtsCallForwardOptions.class);
+                    } else {
+                    /// @}
+                        intent = mSubscriptionInfoHelper.getIntent(CdmaCallForwardOptions.class);
+                    }
+                    SubscriptionInfoHelper.addExtrasToIntent(intent, SubscriptionManager
+                                          .from(this).getSubscriptionInfo(mPhone.getSubId()));
+                    startActivity(intent);
+                } else if (preference == preferenceScreen.findPreference(KEY_CALLER_ID)) {
+                    Intent intent
+                         = mSubscriptionInfoHelper.getIntent(GsmUmtsAdditionalCallOptions.class);
+                    SubscriptionInfoHelper.addExtrasToIntent(intent, SubscriptionManager
+                                          .from(this).getSubscriptionInfo(mPhone.getSubId()));
+                    startActivity(intent);
+                } else { // (preference ==
+                         // preferenceScreen.findPreference(KEY_CALL_WAIT))
+                    /// M: remove CNIR and move CW option to cdma call option.
+                    /// TODO: Check whether need mForeground
+                    boolean isImsOn = TelephonyUtils.isImsServiceAvailable(this, mPhone.getSubId());
+                    if ((TelephonyUtilsEx.isCtVolteEnabled() && TelephonyUtilsEx
+                            .isCt4gSim(mPhone.getSubId()) && isImsOn) || TelephonyUtilsEx
+                            .isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+                        Intent intent = mSubscriptionInfoHelper
+                                .getIntent(CdmaCallWaitingUtOptions.class);
+                        startActivity(intent);
+                    } else {
+                        showDialog(CdmaCallWaitOptions.CW_MODIFY_DIALOG);
+                    }
+                }
+            }
+            return true;
+        }
+        /// Add for CDG OMH @{
+        if (mCdgCallSettings != null && mCdgCallSettings.onPreferenceTreeClick(
+                preferenceScreen, preference)) {
+            log("onPreferenceTreeClickMTK, handled by CDG call settings.");
+            return true;
+        }
+        /// @}
+        return false;
+    }
+
+    private void updateScreenStatus() {
+        PreferenceScreen pres = getPreferenceScreen();
+
+        boolean isAirplaneModeEnabled = TelephonyUtils.isAirplaneModeOn(
+                PhoneGlobals.getInstance());
+        boolean hasSubId = SubscriptionManager.isValidSubscriptionId(mPhone.getSubId());
+        log("updateScreenStatus, hasSubId: " + hasSubId + " isAirplaneModeEnabled: " +
+                 isAirplaneModeEnabled);
+
+        for (int i = 0; i < pres.getPreferenceCount(); i++) {
+            Preference pref = pres.getPreference(i);
+            pref.setEnabled(!isAirplaneModeEnabled && hasSubId);
+        }
+
+        /// M: The CF UI will be disabled when air plane mode is on.
+        /// but SS should be still workable when IMS is registered,
+        /// So Enable the CF UI when IMS is registered. {@
+        if (hasSubId) {
+            boolean isImsOn = TelephonyUtils.isImsServiceAvailable(this, mPhone.getSubId());
+            Preference prefCf = getPreferenceScreen().findPreference(CALL_FORWARDING_KEY);
+            Preference prefCb = getPreferenceScreen().findPreference(BUTTON_CB_EXPAND);
+            Preference prefCw = getPreferenceScreen().findPreference(ADDITIONAL_GSM_SETTINGS_KEY);
+            if (prefCf != null) {
+                if (isImsOn) {
+                    log(" --- set SS item enabled when IMS is registered ---");
+                    prefCf.setEnabled(true);
+                    prefCb.setEnabled(true);
+                    prefCw.setEnabled(true);
+                }
+            }
+            if (TelephonyUtilsEx.isSmartFren4gSim(mPhone.getContext(), mPhone.getSubId())) {
+                Preference prefCdmaCf = getPreferenceScreen().findPreference(KEY_CALL_FORWARD);
+                Preference prefCdmaCw = getPreferenceScreen().findPreference(KEY_CALL_WAIT);
+                Preference prefCdmaCi = getPreferenceScreen().findPreference(KEY_CALLER_ID);
+                log(" -- set CDMA SS item enabled when IMS is registered for SmartFren only --");
+                if (prefCdmaCf != null) {
+                    prefCdmaCf.setEnabled(true);
+                }
+                if (prefCdmaCw != null) {
+                    prefCdmaCw.setEnabled(true);
+                }
+                if (prefCdmaCi != null) {
+                    prefCdmaCi.setEnabled(true);
+                }
+            }
+        }
+
+        updateVtEnableStatus();
+    }
+
+    private void setIpFunction() {
+        Preference prefIp = getPreferenceScreen().findPreference(IP_PREFIX_KEY);
+        Intent intent = new Intent(this, IpPrefixPreference.class);
+        SubscriptionInfoHelper.addExtrasToIntent(intent, SubscriptionManager
+                                        .from(this).getSubscriptionInfo(mPhone.getSubId()));
+        if (prefIp != null) {
+            prefIp.setIntent(intent);
+        }
+    }
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            log("onReceive, action = " + action);
+            if (Intent.ACTION_AIRPLANE_MODE_CHANGED.equals(action) ||
+                    ImsManager.ACTION_IMS_STATE_CHANGED.equals(action)) {
+                updateScreenStatus();
+            } else if (ACTION_OMH.equals(action)) {
+                log("update omh items");
+                updateOmhItems();
+            //  When IMS Configuration Provisioning value changed,
+            // remove/add mEnableVideoCalling item.@{
+            } else if (ImsConfigContract.ACTION_IMS_CONFIG_CHANGED == action) {
+                int actionId = intent.getIntExtra(ImsConfigContract.EXTRA_CHANGED_ITEM, -1);
+                log("EXTRA_CHANGED_ITEM actionId = " + actionId);
+                if (ImsConfig.ConfigConstants.LVC_SETTING_ENABLED == actionId) {
+                    updateVtOption();
+                }
+            }
+        }
+    };
+
+    // dialog creation method, called by showDialog()
+    @Override
+    protected Dialog onCreateDialog(int dialogId) {
+        /// M: remove CNIR and move CW option to cdma call option.
+        if (dialogId == CdmaCallWaitOptions.CW_MODIFY_DIALOG) {
+            return new CdmaCallWaitOptions(this, mPhone).createDialog();
+        }
+
+        /// Add for CDG OMH @{
+        if (mCdgCallSettings != null) {
+            return mCdgCallSettings.onCreateDialog(dialogId);
+        }
+        /// @}
+        return null;
+    }
+
+    /**
+     * Add call status listener, for VT items(should be disable during calling)
+     */
+    private final PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
+        @Override
+        public void onCallStateChanged(int state, String incomingNumber) {
+            boolean enabled = (state == TelephonyManager.CALL_STATE_IDLE);
+            log("[onCallStateChanged] enabled = " + enabled);
+            updateVtEnableStatus();
+        }
+    };
+
+    /**
+     * 1. Listen sim hot swap related change.
+     * 2. ACTION_AIRPLANE_MODE_CHANGED
+     * 3. ACTION_IMS_STATE_CHANGED
+     * 4. Call Status for VT item
+     */
+    private void registerEventCallbacks() {
+        PhoneGlobals.getInstance().addSubInfoUpdateListener(this);
+        /// register airplane mode
+        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        intentFilter.addAction(ImsManager.ACTION_IMS_STATE_CHANGED);
+        intentFilter.addAction(ACTION_OMH);
+        intentFilter.addAction(ImsConfigContract.ACTION_IMS_CONFIG_CHANGED);
+        registerReceiver(mReceiver, intentFilter);
+    }
+
+    private void unregisterEventCallbacks() {
+        PhoneGlobals.getInstance().removeSubInfoUpdateListener(this);
+        unregisterReceiver(mReceiver);
+    }
+
+    /**
+     * This is for VT option, when during call, disable it.
+     */
+    private void updateVtEnableStatus() {
+        boolean hasSubId = mPhone != null
+                && SubscriptionManager.isValidSubscriptionId(mPhone.getSubId());
+        log("[updateVtEnableStatus] isInCall = " + TelephonyUtils.isInCall(this) + ", hasSubId = "
+                + hasSubId);
+        if (mEnableVideoCalling != null) {
+            mEnableVideoCalling.setEnabled(hasSubId && !TelephonyUtils.isInCall(this));
+        }
+    }
+}
