Index: vendor/branch/5058I_ALRU/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	(revision 8051)
+++ vendor/branch/5058I_ALRU/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	(revision 8052)
@@ -121,6 +121,9 @@
     //String keys for preference lookup
     public static final String BUTTON_PREFERED_NETWORK_MODE = "preferred_network_mode_key";
     private static final String BUTTON_ROAMING_KEY = "button_roaming_key";
+    private static final String BUTTON_ROAMING_KEY2 = "preferred_roaming_key";
+    private static final String BUTTON_SHOW_ROAMING_REMINDER_KEY =
+        "preferred_show_roaming_reminder_key";
     private static final String BUTTON_CDMA_LTE_DATA_SERVICE_KEY = "cdma_lte_data_service_key";
     public static final String BUTTON_ENABLED_NETWORKS_KEY = "enabled_networks_key";
     private static final String BUTTON_4G_LTE_KEY = "enhanced_4g_lte";
@@ -152,6 +155,8 @@
     private RestrictedSwitchPreference mButtonDataRoam;
     private SwitchPreference mButton4glte;
     private Preference mLteDataServicePref;
+    private ListPreference mButtonPreferredDataRoam;
+    private ListPreference mButtonPreferredShowDataRoamReminder;
 
     private static final String iface = "rmnet0"; //TODO: this will go away
     private List<SubscriptionInfo> mActiveSubInfos;
@@ -160,8 +165,20 @@
     private Phone mPhone;
     private MyHandler mHandler;
     private boolean mOkClicked;
-	
 
+    // The roaming choices.
+    public static final int ROAMING_DISABLE = 0;
+    public static final int ROAMING_NATIONAL_NETWORK_ONLY = 1;
+    public static final int ROAMING_ALL_NETWORK = 2;
+    public static final int DEF_ROAMING_CHOICE = ROAMING_DISABLE;
+    // The show roaming reminder choices.
+    public static final int SHOW_ROAMING_REMINDER_ALWAYS = 0;
+    public static final int SHOW_ROAMING_REMINDER_ONCE = 1;
+    public static final int SHOW_ROAMING_REMINDER_NEVER = 2;
+    public static final int DEF_SHOW_ROAMING_REMINDER_CHOICE = SHOW_ROAMING_REMINDER_ALWAYS;
+    // Current roaming choice.
+    private int mRoamingChoice;
+
     // We assume the the value returned by mTabHost.getCurrentTab() == slotId
     private TabHost mTabHost;
 
@@ -220,7 +237,7 @@
     //  Used to dismiss the dialogs when they come up.
     public void onClick(DialogInterface dialog, int which) {
         if (which == DialogInterface.BUTTON_POSITIVE) {
-            mPhone.setDataRoamingEnabled(true);
+            onRoamingChanged(mRoamingChoice);
             mOkClicked = true;
         } else {
             // Reset the toggle
@@ -311,7 +328,8 @@
             mButtonEnabledNetworks.setValue(Integer.toString(settingsNetworkMode));
              */
             return true;
-        } else if (preference == mButtonDataRoam) {
+        } else if (preference == mButtonDataRoam || preference == mButtonPreferredDataRoam
+                || preference == mButtonPreferredShowDataRoamReminder) {
             // Do not disable the preference screen if the user clicks Data roaming.
             return true;
         } else {
@@ -550,6 +568,13 @@
                 BUTTON_ENABLED_NETWORKS_KEY);
         mButtonDataRoam.setOnPreferenceChangeListener(this);
 
+        mButtonPreferredDataRoam = (ListPreference) prefSet.findPreference(BUTTON_ROAMING_KEY2);
+        mButtonPreferredDataRoam.setOnPreferenceChangeListener(this);
+
+        mButtonPreferredShowDataRoamReminder =
+            (ListPreference) prefSet.findPreference(BUTTON_SHOW_ROAMING_REMINDER_KEY);
+        mButtonPreferredShowDataRoamReminder.setOnPreferenceChangeListener(this);
+
         mLteDataServicePref = prefSet.findPreference(BUTTON_CDMA_LTE_DATA_SERVICE_KEY);
 
         // Initialize mActiveSubInfo
@@ -648,6 +673,13 @@
             updatePreferredNetworkUIFromDb();
         }
 
+        if (getPreferenceScreen().findPreference(BUTTON_ROAMING_KEY2) != null) {
+            updatePreferredRoamingFromDb();
+        }
+
+        if (getPreferenceScreen().findPreference(BUTTON_SHOW_ROAMING_REMINDER_KEY) != null) {
+            updatePreferredShowRoamingReminderFromDb();
+        }
         /** M: Add For [MTK_Enhanced4GLTE]
         if (ImsManager.isVolteEnabledByPlatform(this)
                 && ImsManager.isVolteProvisionedOnDevice(this)) {
@@ -682,6 +714,101 @@
         super.onPause();
     }
 
+    private void onRoamingChanged(int roamingChoice) {
+        storePreferredRoamingToDb(roamingChoice);
+        updatePreferredRoamingFromDb();
+
+        final int phoneSubId = mPhone.getSubId();
+        String simOp = TelephonyManager.getDefault().getSimOperator(phoneSubId);
+        String srvOp = mPhone.getServiceState().getOperatorNumeric();
+        boolean nationRegion = (simOp != null && srvOp != null
+                && simOp.substring(0, 3).equals(srvOp.substring(0, 3)));
+        if (DBG) {
+            log("simOp=" + simOp + ", srvOp=" + srvOp + ", nationRegion=" + nationRegion
+                    + ", roamingChoice=" + roamingChoice);
+        }
+
+        if (ROAMING_DISABLE == roamingChoice ||
+                (ROAMING_NATIONAL_NETWORK_ONLY == roamingChoice && !nationRegion)) {
+            mPhone.setDataRoamingEnabled(false);
+        } else {
+            mPhone.setDataRoamingEnabled(true);
+        }
+    }
+
+    private void updatePreferredRoamingFromDb() {
+        final int phoneSubId = mPhone.getSubId();
+        int roamingChoice = android.provider.Settings.Global.getInt(
+                mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                PREFERRED_ROAMING + phoneSubId, DEF_ROAMING_CHOICE);
+        if (DBG) {
+            log("phoneSubId=" + phoneSubId + ", roamingChoice=" + roamingChoice);
+        }
+
+        switch (roamingChoice) {
+            case ROAMING_DISABLE:
+                mButtonPreferredDataRoam.setSummary(R.string.roaming_option_disable);
+                break;
+            case ROAMING_NATIONAL_NETWORK_ONLY:
+                mButtonPreferredDataRoam.setSummary(R.string.roaming_option_national_roaming_only);
+                break;
+            case ROAMING_ALL_NETWORK:
+                mButtonPreferredDataRoam.setSummary(R.string.roaming_option_all_networks);
+                break;
+            default:
+                if (DBG) {
+                    log("Unknown roaming choice " + roamingChoice);
+                }
+                break;
+        }
+    }
+
+    private void updatePreferredShowRoamingReminderFromDb() {
+        final int phoneSubId = mPhone.getSubId();
+        int showRoamingReminderChoice = android.provider.Settings.Global.getInt(
+                mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                PREFERRED_SHOW_ROAMING_REMINDER + phoneSubId, DEF_SHOW_ROAMING_REMINDER_CHOICE);
+        if (DBG) {
+            log("phoneSubId=" + phoneSubId + ", reminderChoice=" + showRoamingReminderChoice);
+        }
+
+        switch (showRoamingReminderChoice) {
+            case SHOW_ROAMING_REMINDER_ALWAYS:
+                mButtonPreferredShowDataRoamReminder
+                    .setSummary(R.string.show_roaming_reminder_option_always);
+                break;
+
+            case SHOW_ROAMING_REMINDER_ONCE:
+                mButtonPreferredShowDataRoamReminder
+                    .setSummary(R.string.show_roaming_reminder_option_once);
+                break;
+
+            case SHOW_ROAMING_REMINDER_NEVER:
+                mButtonPreferredShowDataRoamReminder
+                    .setSummary(R.string.show_roaming_reminder_option_never);
+                break;
+
+            default:
+                if (DBG) {
+                    log("Unknown show roaming reminder choice " + showRoamingReminderChoice);
+                }
+                break;
+        }
+    }
+
+    private void storePreferredRoamingToDb(int roamingChoice) {
+        final int phoneSubId = mPhone.getSubId();
+         android.provider.Settings.Global.putInt(mPhone.getContext().getContentResolver(),
+                 android.provider.Settings.Global.PREFERRED_ROAMING + phoneSubId, roamingChoice);
+    }
+
+    private void storePreferredShowRoamingReminderToDb(int showRoamingReminderChoice) {
+        final int phoneSubId = mPhone.getSubId();
+         android.provider.Settings.Global.putInt(mPhone.getContext().getContentResolver(),
+                 android.provider.Settings.Global.PREFERRED_SHOW_ROAMING_REMINDER + phoneSubId
+                 , showRoamingReminderChoice);
+    }
+
     private boolean hasActiveSubscriptions() {
         return mActiveSubInfos.size() > 0;
     }
@@ -696,12 +823,16 @@
 
         if (prefSet != null) {
             prefSet.removeAll();
-            prefSet.addPreference(mButtonDataRoam);
+            prefSet.addPreference(mButtonPreferredDataRoam);
+            prefSet.addPreference(mButtonPreferredShowDataRoamReminder);
             prefSet.addPreference(mButtonPreferredNetworkMode);
             prefSet.addPreference(mButtonEnabledNetworks);
             prefSet.addPreference(mButton4glte);
         }
 
+        updatePreferredRoamingFromDb();
+        updatePreferredShowRoamingReminderFromDb();
+
         int settingsNetworkMode = android.provider.Settings.Global.getInt(
                 mPhone.getContext().getContentResolver(),
                 android.provider.Settings.Global.PREFERRED_NETWORK_MODE + phoneSubId,
@@ -1139,12 +1270,14 @@
             boolean enhanced4gMode = !enhanced4gModePref.isChecked();
             enhanced4gModePref.setChecked(enhanced4gMode);
             ImsManager.setEnhanced4gLteModeSetting(this, enhanced4gModePref.isChecked());
-        } else if (preference == mButtonDataRoam) {
+        } else if (preference == mButtonDataRoam || preference == mButtonPreferredDataRoam) {
             if (DBG) {
                 log("onPreferenceTreeClick: preference == mButtonDataRoam.");
             }
+            mRoamingChoice = Integer.valueOf((String)objValue);
+
             //normally called on the toggle click
-            if (!mButtonDataRoam.isChecked()) {
+            if (mRoamingChoice != ROAMING_DISABLE) {
                 // First confirm with a warning dialog about charges
                 mOkClicked = false;
                 /// M:Add for plug-in @{
@@ -1157,8 +1290,8 @@
                     return true;
                 }
                 AlertDialog.Builder builder = new AlertDialog.Builder(this);
-                builder.setMessage(getResources().getString(R.string.roaming_warning))
-                        .setTitle(android.R.string.dialog_alert_title);
+                builder.setMessage(getResources().getString(R.string.roaming_warning2))
+                        .setTitle(R.string.dialog_alert_title_with_punc);
                 mExt.customizeAlertDialog(mButtonDataRoam, builder);
                 builder.setIconAttribute(android.R.attr.alertDialogIcon)
                         .setPositiveButton(android.R.string.yes, this)
@@ -1167,9 +1300,15 @@
                         .setOnDismissListener(this);
                 /// @}
             } else {
-                mPhone.setDataRoamingEnabled(false);
+                onRoamingChanged(mRoamingChoice);
             }
             return true;
+        } else if (preference == mButtonPreferredShowDataRoamReminder) {
+            int showRoamingReminderChoice = Integer.valueOf((String)objValue);
+            Log.d(LOG_TAG, "choose roaming reminder = " + showRoamingReminderChoice);
+            storePreferredShowRoamingReminderToDb(showRoamingReminderChoice);
+            updatePreferredShowRoamingReminderFromDb();
+            return true;
         }
 
         /// Add for Plug-in @{
Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java	(revision 8052)
@@ -0,0 +1,7612 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ * Modification based on code covered by the mentioned copyright
+ * and/or permission notice(s).
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.dataconnection;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.ProgressDialog;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.ConnectivityManager;
+import android.net.LinkProperties;
+import android.net.NetworkCapabilities;
+import android.net.NetworkConfig;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.net.NetworkUtils;
+import android.net.ProxyInfo;
+import android.net.TrafficStats;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.AsyncResult;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RegistrantList;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.preference.PreferenceManager;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
+import android.provider.Telephony;
+import android.telephony.CellLocation;
+import android.telephony.PcoData;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.text.TextUtils;
+import android.util.EventLog;
+import android.util.LocalLog;
+import android.util.Pair;
+import android.util.SparseArray;
+import android.view.WindowManager;
+
+import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.GsmCdmaPhone;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandException.Error;
+import com.android.internal.telephony.DctConstants;
+import com.android.internal.telephony.EventLogTags;
+import com.android.internal.telephony.GsmCdmaPhone;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.metrics.TelephonyMetrics;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.util.ArrayUtils;
+import com.android.internal.util.AsyncChannel;
+
+import com.android.ims.ImsManager;
+
+/** M: start */
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.telephony.IGsmDCTExt;
+import com.mediatek.common.telephony.ITelephonyExt;
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.dataconnection.DataSubSelector;
+import com.mediatek.internal.telephony.dataconnection.DcFailCauseManager;
+import com.mediatek.internal.telephony.dataconnection.FdManager;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.dataconnection.DataConnectionHelper;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+/** M: end */
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.PriorityQueue;
+import java.util.Set;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.lang.StringBuilder;
+
+import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.TelephonyDevController;
+
+/**
+ * {@hide}
+ */
+public class DcTracker extends Handler {
+    private static final String LOG_TAG = "DCT";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = android.util.Log.isLoggable(LOG_TAG,
+            android.util.Log.DEBUG); // STOPSHIP if true
+    private static final boolean VDBG_STALL = android.util.Log.isLoggable(LOG_TAG,
+            android.util.Log.DEBUG); // STOPSHIP if true
+    private static final int TEL_DBG = SystemProperties.getInt("persist.log.tag.tel_dbg", 0);
+    private static final boolean RADIO_TESTS = false;
+
+    public AtomicBoolean isCleanupRequired = new AtomicBoolean(false);
+
+    private final AlarmManager mAlarmManager;
+
+    /* Currently requested APN type (TODO: This should probably be a parameter not a member) */
+    private String mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+    // All data enabling/disabling related settings
+    private final DataEnabledSettings mDataEnabledSettings = new DataEnabledSettings();
+
+    // Sync data settings part.
+    private static final int MOBILE_DATA_IDX        = 0;
+    private static final int ROAMING_DATA_IDX       = 1;
+    private static final int DEFAULT_DATA_SIM_IDX   = 2;
+    private static final int SKIP_DATA_SETTINGS     = -2;
+
+    /**
+     * After detecting a potential connection problem, this is the max number
+     * of subsequent polls before attempting recovery.
+     */
+    // 1 sec. default polling interval when screen is on.
+    private static final int POLL_NETSTAT_MILLIS = 1000;
+    // 10 min. default polling interval when screen is off.
+    private static final int POLL_NETSTAT_SCREEN_OFF_MILLIS = 1000*60*10;
+    // Default sent packets without ack which triggers initial recovery steps
+    private static final int NUMBER_SENT_PACKETS_OF_HANG = 10;
+
+    // Default for the data stall alarm while non-aggressive stall detection
+    private static final int DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT = 1000 * 60 * 6;
+    // Default for the data stall alarm for aggressive stall detection
+    private static final int DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT = 1000 * 60;
+    // Tag for tracking stale alarms
+    private static final String DATA_STALL_ALARM_TAG_EXTRA = "data.stall.alram.tag";
+
+    // M: Check data stall alarm if is needed to skip for testing
+    private static final String SKIP_DATA_STALL_ALARM = "persist.skip.data.stall.alarm";
+
+    private static final boolean DATA_STALL_SUSPECTED = true;
+    private static final boolean DATA_STALL_NOT_SUSPECTED = false;
+
+    private String RADIO_RESET_PROPERTY = "gsm.radioreset";
+
+    private static final String INTENT_RECONNECT_ALARM =
+            "com.android.internal.telephony.data-reconnect";
+    private static final String INTENT_RECONNECT_ALARM_EXTRA_TYPE = "reconnect_alarm_extra_type";
+    private static final String INTENT_RECONNECT_ALARM_EXTRA_REASON =
+            "reconnect_alarm_extra_reason";
+
+    private static final String INTENT_DATA_STALL_ALARM =
+            "com.android.internal.telephony.data-stall";
+
+    @VisibleForTesting
+    public static class DataAllowFailReason {
+        private HashSet<DataAllowFailReasonType> mDataAllowFailReasonSet = new HashSet<>();
+
+        public void addDataAllowFailReason(DataAllowFailReasonType type) {
+            mDataAllowFailReasonSet.add(type);
+        }
+
+        public String getDataAllowFailReason() {
+            StringBuilder failureReason = new StringBuilder();
+            failureReason.append("isDataAllowed: No");
+            for(DataAllowFailReasonType reason : mDataAllowFailReasonSet) {
+                failureReason.append(reason.mFailReasonStr);
+            }
+            return failureReason.toString();
+        }
+
+        public boolean isFailForSingleReason(DataAllowFailReasonType failReasonType) {
+            return (mDataAllowFailReasonSet.size() == 1) &&
+                    (mDataAllowFailReasonSet.contains(failReasonType));
+        }
+
+        public boolean isFailForReason(DataAllowFailReasonType failReasonType) {
+            return mDataAllowFailReasonSet.contains(failReasonType);
+        }
+
+        public void clearAllReasons() {
+            mDataAllowFailReasonSet.clear();
+        }
+
+        public boolean isFailed() {
+            return mDataAllowFailReasonSet.size() > 0;
+        }
+
+        public int getSizeOfFailReason() {
+            return mDataAllowFailReasonSet.size();
+        }
+    }
+
+    @VisibleForTesting
+    public enum DataAllowFailReasonType {
+        NOT_ATTACHED(" - Not attached"),
+        RECORD_NOT_LOADED(" - SIM not loaded"),
+        ROAMING_DISABLED(" - Roaming and data roaming not enabled"),
+        INVALID_PHONE_STATE(" - PhoneState is not idle"),
+        CONCURRENT_VOICE_DATA_NOT_ALLOWED(" - Concurrent voice and data not allowed"),
+        PS_RESTRICTED(" - mIsPsRestricted= true"),
+        UNDESIRED_POWER_STATE(" - desiredPowerState= false"),
+        INTERNAL_DATA_DISABLED(" - mInternalDataEnabled= false"),
+        DEFAULT_DATA_UNSELECTED(" - defaultDataSelected= false"),
+        RADIO_DISABLED_BY_CARRIER(" - powerStateFromCarrier= false"),
+        FDN_ENABLED(" - FDN enabled"),
+        // Multi-PS attach
+        NOT_ALLOWED(" - Not allowed");
+
+        public String mFailReasonStr;
+
+        DataAllowFailReasonType(String reason) {
+            mFailReasonStr = reason;
+        }
+    }
+
+    private DcTesterFailBringUpAll mDcTesterFailBringUpAll;
+    private DcController mDcc;
+
+    /** kept in sync with mApnContexts
+     * Higher numbers are higher priority and sorted so highest priority is first */
+   /*ALPS01555724: The implementation of PriorityQueue is incorrect, use arraylist to sort priority.
+    private final PriorityQueue<ApnContext>mPrioritySortedApnContexts =
+            new PriorityQueue<ApnContext>(5,
+            new Comparator<ApnContext>() {
+                public int compare(ApnContext c1, ApnContext c2) {
+                    return c2.priority - c1.priority;
+                }
+            } );
+     */
+    ArrayList <ApnContext> mPrioritySortedApnContexts = new ArrayList<ApnContext>();
+
+
+    /** allApns holds all apns */
+    private ArrayList<ApnSetting> mAllApnSettings = null;
+
+    /** preferred apn */
+    private ApnSetting mPreferredApn = null;
+
+    /** Is packet service restricted by network */
+    private boolean mIsPsRestricted = false;
+
+    /** emergency apn Setting*/
+    private ApnSetting mEmergencyApn = null;
+
+    /* Once disposed dont handle any messages */
+    private boolean mIsDisposed = false;
+
+    private ContentResolver mResolver;
+
+    /* Set to true with CMD_ENABLE_MOBILE_PROVISIONING */
+    private boolean mIsProvisioning = false;
+
+    /* The Url passed as object parameter in CMD_ENABLE_MOBILE_PROVISIONING */
+    private String mProvisioningUrl = null;
+
+    /* Intent for the provisioning apn alarm */
+    private static final String INTENT_PROVISIONING_APN_ALARM =
+            "com.android.internal.telephony.provisioning_apn_alarm";
+
+    /* Tag for tracking stale alarms */
+    private static final String PROVISIONING_APN_ALARM_TAG_EXTRA = "provisioning.apn.alarm.tag";
+
+    /* Debug property for overriding the PROVISIONING_APN_ALARM_DELAY_IN_MS */
+    private static final String DEBUG_PROV_APN_ALARM = "persist.debug.prov_apn_alarm";
+
+    /* Default for the provisioning apn alarm timeout */
+    private static final int PROVISIONING_APN_ALARM_DELAY_IN_MS_DEFAULT = 1000 * 60 * 15;
+
+    /* The provision apn alarm intent used to disable the provisioning apn */
+    private PendingIntent mProvisioningApnAlarmIntent = null;
+
+    /* Used to track stale provisioning apn alarms */
+    private int mProvisioningApnAlarmTag = (int) SystemClock.elapsedRealtime();
+
+    // VOLTE [start]
+    private static final boolean MTK_IMS_SUPPORT = SystemProperties.get("persist.mtk_ims_support")
+                                                            .equals("1") ? true : false;
+
+    // VZW feature suppport
+    private static final boolean VZW_FEATURE = SystemProperties.get("persist.operator.optr")
+                                                            .equals("OP12") ? true : false;
+
+    private AsyncChannel mReplyAc = new AsyncChannel();
+
+    /** M: start */
+    protected static final String PROPERTY_MOBILE_DATA_ENABLE = "persist.radio.mobile.data";
+
+    /// M: Default data customization.
+    private static final String PROPERTY_OPERATOR = "persist.operator.optr";
+    private static final String OPERATOR_OM = "OM";
+
+    protected ApnSetting mInitialAttachApnSetting;
+    private static final String NO_SIM_VALUE = "N/A";
+    private String[] PROPERTY_ICCID = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+    /** M: end */
+
+    // M: OP12 hplmn support
+    private static final String PLMN_OP12 = "311480";
+
+    private static final boolean MTK_APNSYNC_TEST_SUPPORT =
+            SystemProperties.getInt("persist.apnsync.test.support", 0) == 1;
+
+    protected static boolean MTK_CC33_SUPPORT =
+            SystemProperties.getInt("persist.data.cc33.support", 0) == 1 ? true : false;
+
+    private static final boolean MTK_DUAL_APN_SUPPORT =
+            SystemProperties.get("ro.mtk_dtag_dual_apn_support").equals("1") ? true : false;
+
+    /**
+     * M: IA- for IMS test mode and change attach APN for OP12.
+     *    Enable : Set Attach PDN to VZWINTERNET
+     *    Disable: Set Attach PDN to VZWIMS (Default)
+     */
+    protected static final boolean MTK_IMS_TESTMODE_SUPPORT =
+            SystemProperties.getInt("persist.imstestmode.support", 0) == 1;
+
+    /* M: Set to true if IMS pdn handover to WIFI(EPDG) and used for change attach APN */
+    private boolean mIsImsHandover = false;
+    /* M: Vzw IMS hand over
+       Value:
+           0: reset
+           1: handover start
+           2: handover end
+    */
+    protected String PROP_IMS_HANDOVER = "ril.imshandover";
+
+    // M: IA-change attach APN from modem.
+    private ApnSetting mMdChangedAttachApn = null;
+    private static final int APN_CLASS_0 = 0;
+    private static final int APN_CLASS_1 = 1;
+    private static final int APN_CLASS_2 = 2;
+    private static final int APN_CLASS_3 = 3;
+    private static final int APN_CLASS_4 = 4;
+    private static final int APN_CLASS_5 = 5;
+    private static final String VZW_EMERGENCY_NI = "VZWEMERGENCY";
+    private static final String VZW_IMS_NI = "VZWIMS";
+    private static final String VZW_ADMIN_NI = "VZWADMIN";
+    private static final String VZW_INTERNET_NI = "VZWINTERNET";
+    private static final String VZW_APP_NI = "VZWAPP";
+    private static final String VZW_800_NI = "VZW800";
+    private static final String PROP_APN_CLASS_ICCID = "ril.md_changed_apn_class.iccid";
+    private static final String PROP_APN_CLASS = "ril.md_changed_apn_class";
+
+    // M: For IMS pdn handover to WIFI
+    private static final String NETWORK_TYPE_WIFI = "WIFI";
+    private static final String NETWORK_TYPE_MOBILE_IMS = "MOBILEIMS";
+
+    // M: For sync APN table
+    private static final String PROPERTY_THROTTLING_TIME = "persist.radio.throttling_time";
+    private static final int THROTTLING_TIME_DEFAULT = 900;
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    private String mLteAccessStratumDataState = PhoneConstants.LTE_ACCESS_STRATUM_STATE_UNKNOWN;
+    private static final int LTE_AS_CONNECTED = 1;
+    private int mNetworkType = -1;
+    private boolean mIsLte = false;
+    private boolean mIsSharedDefaultApn = false;
+    private int mDefaultRefCount = 0;
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // M: JPN IA Start
+    protected int mSuspendId = 0;
+    protected static final String[] MCC_TABLE_TEST = {
+        "001"
+    };
+    protected static final String[] MCC_TABLE_DOMESTIC = {
+        "440"
+    };
+    protected static final int REGION_UNKNOWN  = 0;
+    protected static final int REGION_DOMESTIC = 1;
+    protected static final int REGION_FOREIGN  = 2;
+    protected int mRegion = REGION_UNKNOWN;
+    protected Object mNeedsResumeModemLock = new Object();
+    protected boolean mNeedsResumeModem = false;
+    // M: JPN IA End
+
+    // M: Attach APN is assigned empty but need to raise P-CSCF discovery flag
+    // 26201 DTAG D1(T-Mobile)
+    // 44010 DOCOMO
+    private String[] PLMN_EMPTY_APN_PCSCF_SET = {
+        "26201",
+        "44010"
+    };
+
+    private String[] MCCMNC_OP18 = {
+        "405840", "405854", "405855", "405856", "405857",
+        "405858", "405859", "405860", "405861", "405862",
+        "405863", "405864", "405865", "405866", "405867",
+        "405868", "405869", "405870", "405871", "405872",
+        "405873", "405874"
+    };
+
+    // M: Query modem hardware capability
+    private TelephonyDevController mTelDevController = TelephonyDevController.getInstance();
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver () {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                if (DBG) log("screen on");
+                mIsScreenOn = true;
+                stopNetStatPoll();
+                startNetStatPoll();
+                restartDataStallAlarm();
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                if (DBG) log("screen off");
+                mIsScreenOn = false;
+                stopNetStatPoll();
+                startNetStatPoll();
+                restartDataStallAlarm();
+            } else if (action.startsWith(INTENT_RECONNECT_ALARM)) {
+                if (DBG) log("Reconnect alarm. Previous state was " + mState);
+                onActionIntentReconnectAlarm(intent);
+            } else if (action.equals(INTENT_DATA_STALL_ALARM)) {
+                if (DBG) log("Data stall alarm");
+                onActionIntentDataStallAlarm(intent);
+            } else if (action.equals(INTENT_PROVISIONING_APN_ALARM)) {
+                if (DBG) log("Provisioning apn alarm");
+                onActionIntentProvisioningApnAlarm(intent);
+            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
+                final android.net.NetworkInfo networkInfo = (NetworkInfo)
+                        intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
+                mIsWifiConnected = (networkInfo != null && networkInfo.isConnected());
+                if (DBG) log("NETWORK_STATE_CHANGED_ACTION: mIsWifiConnected=" + mIsWifiConnected);
+            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
+                if (DBG) log("Wifi state changed");
+                final boolean enabled = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
+                        WifiManager.WIFI_STATE_UNKNOWN) == WifiManager.WIFI_STATE_ENABLED;
+                if (!enabled) {
+                    // when WiFi got disabled, the NETWORK_STATE_CHANGED_ACTION
+                    // quit and won't report disconnected until next enabling.
+                    mIsWifiConnected = false;
+                }
+                if (DBG) {
+                    log("WIFI_STATE_CHANGED_ACTION: enabled=" + enabled
+                            + " mIsWifiConnected=" + mIsWifiConnected);
+                }
+            } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+                if (false == hasOperatorIaCapability()) {
+                    // M:For OP12, in EPDG handover case to change initial attach APN.
+                    final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(
+                            ConnectivityManager.EXTRA_NETWORK_INFO);
+                    int apnType = networkInfo.getType();
+                    String typeName = networkInfo.getTypeName();
+                    logd("onReceive: ConnectivityService action change apnType = " +
+                            apnType + " typename =" + typeName);
+
+                    // The case of IMS handover to WIFI
+                    // Note: EPDG is implemented on CS framework
+                    if (apnType == ConnectivityManager.TYPE_MOBILE_IMS
+                            && typeName.equals(NETWORK_TYPE_WIFI)) {
+                        onAttachApnChangedByHandover(true);
+                    } else if (apnType == ConnectivityManager.TYPE_MOBILE_IMS &&
+                            typeName.equals(NETWORK_TYPE_MOBILE_IMS)) {
+                        onAttachApnChangedByHandover(false);
+                    }
+                }
+            } else {
+                if (DBG) log("onReceive: Unknown action=" + action);
+            }
+        }
+    };
+
+    private final Runnable mPollNetStat = new Runnable() {
+        @Override
+        public void run() {
+            updateDataActivity();
+
+            if (mIsScreenOn) {
+                mNetStatPollPeriod = Settings.Global.getInt(mResolver,
+                        Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS, POLL_NETSTAT_MILLIS);
+            } else {
+                mNetStatPollPeriod = Settings.Global.getInt(mResolver,
+                        Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS,
+                        POLL_NETSTAT_SCREEN_OFF_MILLIS);
+            }
+
+            if (mNetStatPollEnabled) {
+                mDataConnectionTracker.postDelayed(this, mNetStatPollPeriod);
+            }
+        }
+    };
+
+    private SubscriptionManager mSubscriptionManager;
+    private final OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
+            new OnSubscriptionsChangedListener() {
+                public final AtomicInteger mPreviousSubId =
+                        new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+                /**
+                 * Callback invoked when there is any change to any SubscriptionInfo. Typically
+                 * this method invokes {@link SubscriptionManager#getActiveSubscriptionInfoList}
+                 */
+                @Override
+                public void onSubscriptionsChanged() {
+                    if (DBG) log("SubscriptionListener.onSubscriptionInfoChanged start");
+                    // Set the network type, in case the radio does not restore it.
+                    int subId = mPhone.getSubId();
+                    if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                        registerSettingsObserver();
+                    }
+                    IccRecords r = mIccRecords.get();
+                    String operatorNumericIcc = (r != null) ? r.getOperatorNumeric() : "";
+                    String operatorNumericProp = TelephonyManager.getDefault()
+                            .getSimOperatorNumericForPhone(mPhone.getPhoneId());
+                    if (mPreviousSubId.getAndSet(subId) != subId &&
+                            SubscriptionManager.isValidSubscriptionId(subId) &&
+                            !TextUtils.isEmpty(operatorNumericIcc) &&
+                            !TextUtils.isEmpty(operatorNumericProp)) {
+                        onRecordsLoadedOrSubIdChanged();
+                    }
+                }
+            };
+
+    private static class SettingsObserver extends ContentObserver {
+        final private HashMap<Uri, Integer> mUriEventMap;
+        final private Context mContext;
+        final private Handler mHandler;
+        final private static String TAG = "DcTracker.SettingsObserver";
+
+        SettingsObserver(Context context, Handler handler) {
+            super(null);
+            mUriEventMap = new HashMap<Uri, Integer>();
+            mContext = context;
+            mHandler = handler;
+        }
+
+        void observe(Uri uri, int what) {
+            mUriEventMap.put(uri, what);
+            final ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(uri, false, this);
+        }
+
+        void unobserve() {
+            final ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            Rlog.e(TAG, "Should never be reached.");
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            final Integer what = mUriEventMap.get(uri);
+            if (what != null) {
+                mHandler.obtainMessage(what.intValue()).sendToTarget();
+            } else {
+                Rlog.e(TAG, "No matching event to send for URI=" + uri);
+            }
+
+        }
+    }
+
+    private final SettingsObserver mSettingsObserver;
+
+    private void registerSettingsObserver() {
+        mSettingsObserver.unobserve();
+        String simSuffix = "";
+        if (TelephonyManager.getDefault().getSimCount() > 1) {
+            simSuffix = Integer.toString(mPhone.getSubId());
+        }
+
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DATA_ROAMING + simSuffix),
+                DctConstants.EVENT_ROAMING_ON);
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED),
+                DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE);
+        mSettingsObserver.observe(
+                Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED),
+                DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE);
+    }
+
+    /**
+     * Maintain the sum of transmit and receive packets.
+     *
+     * The packet counts are initialized and reset to -1 and
+     * remain -1 until they can be updated.
+     */
+    public static class TxRxSum {
+        public long txPkts;
+        public long rxPkts;
+
+        public TxRxSum() {
+            reset();
+        }
+
+        public TxRxSum(long txPkts, long rxPkts) {
+            this.txPkts = txPkts;
+            this.rxPkts = rxPkts;
+        }
+
+        public TxRxSum(TxRxSum sum) {
+            txPkts = sum.txPkts;
+            rxPkts = sum.rxPkts;
+        }
+
+        public void reset() {
+            txPkts = -1;
+            rxPkts = -1;
+        }
+
+        @Override
+        public String toString() {
+            return "{txSum=" + txPkts + " rxSum=" + rxPkts + "}";
+        }
+
+        public void updateTxRxSum() {
+            this.txPkts = TrafficStats.getMobileTcpTxPackets();
+            this.rxPkts = TrafficStats.getMobileTcpRxPackets();
+        }
+    }
+
+    private void onActionIntentReconnectAlarm(Intent intent) {
+        String reason = intent.getStringExtra(INTENT_RECONNECT_ALARM_EXTRA_REASON);
+        String apnType = intent.getStringExtra(INTENT_RECONNECT_ALARM_EXTRA_TYPE);
+
+        int phoneSubId = mPhone.getSubId();
+        int currSubId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+        log("onActionIntentReconnectAlarm: currSubId = " + currSubId + " phoneSubId=" + phoneSubId);
+
+        // Stop reconnect if not current subId is not correct.
+        // FIXME STOPSHIP - phoneSubId is coming up as -1 way after boot and failing this?
+        if (!SubscriptionManager.isValidSubscriptionId(currSubId) || (currSubId != phoneSubId)) {
+            log("receive ReconnectAlarm but subId incorrect, ignore");
+            return;
+        }
+
+        ApnContext apnContext = mApnContexts.get(apnType);
+
+        if (DBG) {
+            log("onActionIntentReconnectAlarm: mState=" + mState + " reason=" + reason +
+                    " apnType=" + apnType + " apnContext=" + apnContext +
+                    " mDataConnectionAsyncChannels=" + mDataConnectionAcHashMap);
+        }
+
+        if ((apnContext != null) && (apnContext.isEnabled())) {
+            apnContext.setReason(reason);
+            DctConstants.State apnContextState = apnContext.getState();
+            if (DBG) {
+                log("onActionIntentReconnectAlarm: apnContext state=" + apnContextState);
+            }
+            if ((apnContextState == DctConstants.State.FAILED)
+                    || (apnContextState == DctConstants.State.IDLE)) {
+                if (DBG) {
+                    log("onActionIntentReconnectAlarm: state is FAILED|IDLE, disassociate");
+                }
+                DcAsyncChannel dcac = apnContext.getDcAc();
+                if (dcac != null) {
+                    if (DBG) {
+                        log("onActionIntentReconnectAlarm: tearDown apnContext=" + apnContext);
+                    }
+                    dcac.tearDown(apnContext, "", null);
+                }
+                apnContext.setDataConnectionAc(null);
+                apnContext.setState(DctConstants.State.IDLE);
+            } else {
+                if (DBG) log("onActionIntentReconnectAlarm: keep associated");
+            }
+            // TODO: IF already associated should we send the EVENT_TRY_SETUP_DATA???
+            sendMessage(obtainMessage(DctConstants.EVENT_TRY_SETUP_DATA, apnContext));
+
+            apnContext.setReconnectIntent(null);
+        }
+    }
+
+    private void onActionIntentDataStallAlarm(Intent intent) {
+        if (VDBG_STALL) log("onActionIntentDataStallAlarm: action=" + intent.getAction());
+        Message msg = obtainMessage(DctConstants.EVENT_DATA_STALL_ALARM,
+                intent.getAction());
+        msg.arg1 = intent.getIntExtra(DATA_STALL_ALARM_TAG_EXTRA, 0);
+        sendMessage(msg);
+    }
+
+    private final ConnectivityManager mCm;
+
+    /**
+     * List of messages that are waiting to be posted, when data call disconnect
+     * is complete
+     */
+    private ArrayList<Message> mDisconnectAllCompleteMsgList = new ArrayList<Message>();
+
+    private RegistrantList mAllDataDisconnectedRegistrants = new RegistrantList();
+
+    // member variables
+    private final Phone mPhone;
+    private final UiccController mUiccController;
+    private final AtomicReference<IccRecords> mIccRecords = new AtomicReference<IccRecords>();
+    protected AtomicReference<UiccCardApplication> mUiccCardApplication
+            = new AtomicReference<UiccCardApplication>();
+    private DctConstants.Activity mActivity = DctConstants.Activity.NONE;
+    private DctConstants.State mState = DctConstants.State.IDLE;
+    private final Handler mDataConnectionTracker;
+
+    private long mTxPkts;
+    private long mRxPkts;
+    private int mNetStatPollPeriod;
+    private boolean mNetStatPollEnabled = false;
+
+    private TxRxSum mDataStallTxRxSum = new TxRxSum(0, 0);
+    // Used to track stale data stall alarms.
+    private int mDataStallAlarmTag = (int) SystemClock.elapsedRealtime();
+    // The current data stall alarm intent
+    private PendingIntent mDataStallAlarmIntent = null;
+    // Number of packets sent since the last received packet
+    private long mSentSinceLastRecv;
+    // Controls when a simple recovery attempt it to be tried
+    private int mNoRecvPollCount = 0;
+    // Reference counter for enabling fail fast
+    private static int sEnableFailFastRefCounter = 0;
+    // True if data stall detection is enabled
+    private volatile boolean mDataStallDetectionEnabled = true;
+
+    private volatile boolean mFailFast = false;
+
+    // True when in voice call
+    private boolean mInVoiceCall = false;
+
+    // wifi connection status will be updated by sticky intent
+    private boolean mIsWifiConnected = false;
+
+    /** Intent sent when the reconnect alarm fires. */
+    private PendingIntent mReconnectIntent = null;
+
+    // When false we will not auto attach and manually attaching is required.
+    private boolean mAutoAttachOnCreationConfig = false;
+    private AtomicBoolean mAutoAttachOnCreation = new AtomicBoolean(false);
+
+    // State of screen
+    // (TODO: Reconsider tying directly to screen, maybe this is
+    //        really a lower power mode")
+    private boolean mIsScreenOn = true;
+
+    // Indicates if we found mvno-specific APNs in the full APN list.
+    // used to determine if we can accept mno-specific APN for tethering.
+    private boolean mMvnoMatched = false;
+
+    /** Allows the generation of unique Id's for DataConnection objects */
+    private AtomicInteger mUniqueIdGenerator = new AtomicInteger(0);
+
+    /** The data connections. */
+    private HashMap<Integer, DataConnection> mDataConnections =
+            new HashMap<Integer, DataConnection>();
+
+    /** The data connection async channels */
+    private HashMap<Integer, DcAsyncChannel> mDataConnectionAcHashMap =
+            new HashMap<Integer, DcAsyncChannel>();
+
+    /** Convert an ApnType string to Id (TODO: Use "enumeration" instead of String for ApnType) */
+    private HashMap<String, Integer> mApnToDataConnectionId = new HashMap<String, Integer>();
+
+    /** Phone.APN_TYPE_* ===> ApnContext */
+    private final ConcurrentHashMap<String, ApnContext> mApnContexts =
+            new ConcurrentHashMap<String, ApnContext>();
+
+    private final SparseArray<ApnContext> mApnContextsById = new SparseArray<ApnContext>();
+
+    private int mDisconnectPendingCount = 0;
+
+    /** Indicate if metered APNs are disabled.
+     *  set to block all the metered APNs from continuously sending requests, which causes
+     *  undesired network load */
+    private boolean mMeteredApnDisabled = false;
+
+    // M: Multi-PS attach Start
+    private boolean mAllowConfig = false;
+    // M: Multi-PS attach End
+
+    /**
+     * Handles changes to the APN db.
+     */
+    private class ApnChangeObserver extends ContentObserver {
+        public ApnChangeObserver () {
+            super(mDataConnectionTracker);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            removeMessages(DctConstants.EVENT_APN_CHANGED);
+            // M: De-bound the onApnChanged in threads trigger in the same time
+            sendMessageDelayed(obtainMessage(DctConstants.EVENT_APN_CHANGED), APN_CHANGE_MILLIS);
+            //sendMessage(obtainMessage(DctConstants.EVENT_APN_CHANGED));
+        }
+    }
+
+    // M: JPN IA Start
+    /**
+    * Handles changes to the settings of IMS switch db.
+    */
+    private ContentObserver mImsSwitchChangeObserver  = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            if (DBG) {
+                log("mImsSwitchChangeObserver: onChange=" + selfChange);
+            }
+            if (isOp17IaSupport()) {
+                log("IA : OP17, set IA");
+                setInitialAttachApn();
+            }
+        }
+    };
+    // M: JPN IA End
+
+    //***** Instance Variables
+
+    private boolean mReregisterOnReconnectFailure = false;
+
+
+    //***** Constants
+
+    // Used by puppetmaster/*/radio_stress.py
+    private static final String PUPPET_MASTER_RADIO_STRESS_TEST = "gsm.defaultpdpcontext.active";
+
+    private static final int POLL_PDP_MILLIS = 5 * 1000;
+    private static final int APN_CHANGE_MILLIS = 1 * 1000;
+
+    private static final int PROVISIONING_SPINNER_TIMEOUT_MILLIS = 120 * 1000;
+
+    static final Uri PREFERAPN_NO_UPDATE_URI_USING_SUBID =
+                        Uri.parse("content://telephony/carriers/preferapn_no_update/subId/");
+    static final String APN_ID = "apn_id";
+
+    private boolean mCanSetPreferApn = false;
+
+    private AtomicBoolean mAttached = new AtomicBoolean(false);
+
+    /** Watches for changes to the APN db. */
+    private ApnChangeObserver mApnObserver;
+
+    private final String mProvisionActionName;
+    private BroadcastReceiver mProvisionBroadcastReceiver;
+    private ProgressDialog mProvisioningSpinner;
+
+    public boolean mImsRegistrationState = false;
+
+    // M: Data connection fail cause manager
+    protected DcFailCauseManager mDcFcMgr;
+
+    // M: Fast Dormancy
+    protected FdManager mFdMgr;
+
+    // M: For Plug in
+    private static final boolean BSP_PACKAGE =
+            SystemProperties.getBoolean("ro.mtk_bsp_package", false);
+    private IGsmDCTExt mGsmDctExt;
+    private ITelephonyExt mTelephonyExt;
+
+    // M: Vsim
+    private static final String PROPERTY_VSIM_ENABLE =
+            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED;
+
+    private static final String PROPERTY_FORCE_APN_CHANGE = "ril.force_apn_change";
+
+    // M: start of throttling APN
+    private static final boolean THROTTLING_APN_ENABLED =
+            SystemProperties.get("persist.mtk_volte_support").equals("1");
+    private static final String PROPERTY_THROTTLING_APN_ENABLED = "ril.throttling.enabled";
+    private static final String HIGH_THROUGHPUT_APN[] = {
+        PhoneConstants.APN_TYPE_ALL,
+        PhoneConstants.APN_TYPE_DEFAULT,
+        PhoneConstants.APN_TYPE_DUN,
+        PhoneConstants.APN_TYPE_HIPRI,
+        PhoneConstants.APN_TYPE_TETHERING
+    };
+
+    // VOLTE
+    private static final String IMS_APN[] = {
+        PhoneConstants.APN_TYPE_IMS,
+        PhoneConstants.APN_TYPE_EMERGENCY,
+    };
+
+    private static final int PDP_CONNECTION_POOL_SIZE = 3;
+    private static final int THROTTLING_MAX_PDP_SIZE = 8;
+
+    private static final int MIN_ID_HIGH_TROUGHPUT = 0;
+    private static final int MAX_ID_HIGH_TROUGHPUT = 1;
+    private static final int MIN_ID_OTHERS_TROUGHPUT = 2;
+    private static final int MAX_ID_OTHERS_TROUGHPUT = 3;
+    private static final int MIN_ID_IMS_TROUGHPUT = 4;
+    private static final int MAX_ID_IMS_TROUGHPUT = 6;
+
+    private AtomicInteger mHighThroughputIdGenerator = new AtomicInteger(0);
+    private AtomicInteger mOthersUniqueIdGenerator = new AtomicInteger(2);
+    private AtomicInteger mImsUniqueIdGenerator = new AtomicInteger(4);
+    // M: end of throttling APN
+
+    // M: Google issue, this thread should quit when DcTracker dispose,
+    //    otherwise memory leak will happen.
+    private HandlerThread mDcHandlerThread;
+
+    //***** Constructor
+    public DcTracker(Phone phone) {
+        super();
+        mPhone = phone;
+
+        if (DBG) log("DCT.constructor");
+
+        mResolver = mPhone.getContext().getContentResolver();
+        mUiccController = UiccController.getInstance();
+        mUiccController.registerForIccChanged(this, DctConstants.EVENT_ICC_CHANGED, null);
+        mAlarmManager =
+                (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
+        mCm = (ConnectivityManager) mPhone.getContext().getSystemService(
+                Context.CONNECTIVITY_SERVICE);
+
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(INTENT_DATA_STALL_ALARM);
+        filter.addAction(INTENT_PROVISIONING_APN_ALARM);
+        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+
+        // TODO - redundent with update call below?
+        mDataEnabledSettings.setUserDataEnabled(getDataEnabled());
+
+        mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mPhone.getContext());
+        mAutoAttachOnCreation.set(sp.getBoolean(Phone.DATA_DISABLED_ON_BOOT_KEY, false));
+
+        mSubscriptionManager = SubscriptionManager.from(mPhone.getContext());
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+
+        mDcHandlerThread = new HandlerThread("DcHandlerThread");
+        mDcHandlerThread.start();
+        Handler dcHandler = new Handler(mDcHandlerThread.getLooper());
+        mDcc = DcController.makeDcc(mPhone, this, dcHandler);
+        mDcTesterFailBringUpAll = new DcTesterFailBringUpAll(mPhone, dcHandler);
+
+        logd("DualApnSupport = " + MTK_DUAL_APN_SUPPORT);
+
+        mDataConnectionTracker = this;
+        registerForAllEvents();
+        update();
+
+        mApnObserver = new ApnChangeObserver();
+        phone.getContext().getContentResolver().registerContentObserver(
+                Telephony.Carriers.CONTENT_URI, true, mApnObserver);
+
+        if (false == hasOperatorIaCapability()){
+            phone.getContext().getContentResolver().registerContentObserver(
+                    Settings.Global.getUriFor(Settings.Global.ENHANCED_4G_MODE_ENABLED), true,
+                    mImsSwitchChangeObserver);
+        }
+
+        initApnContexts();
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            // Register the reconnect and restart actions.
+            filter = new IntentFilter();
+            filter.addAction(INTENT_RECONNECT_ALARM + '.' + apnContext.getApnType());
+            mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
+        }
+
+        // M: Initialize data connection fail cause manager
+        mDcFcMgr = DcFailCauseManager.getInstance(mPhone);
+
+        // Add Emergency APN to APN setting list by default to support EPDN in sim absent cases
+        initEmergencyApnSetting();
+        addEmergencyApnSetting();
+
+        // M: Fast Dormancy init
+        mFdMgr = FdManager.getInstance(phone);
+
+        //MTK START: Add Plug in
+        if (!BSP_PACKAGE) {
+            try {
+                mGsmDctExt =
+                    MPlugin.createInstance(IGsmDCTExt.class.getName(), mPhone.getContext());
+
+                mTelephonyExt =
+                    MPlugin.createInstance(ITelephonyExt.class.getName(), mPhone.getContext());
+                mTelephonyExt.init(mPhone.getContext());
+                mTelephonyExt.startDataRoamingStrategy(mPhone);
+            } catch (Exception e) {
+                logw("mGsmDctExt or mTelephonyExt init fail");
+                e.printStackTrace();
+            }
+        }
+        //MTK END
+
+        mProvisionActionName = "com.android.internal.telephony.PROVISION" + phone.getPhoneId();
+
+        mSettingsObserver = new SettingsObserver(mPhone.getContext(), this);
+        registerSettingsObserver();
+    }
+
+    @VisibleForTesting
+    public DcTracker() {
+        mAlarmManager = null;
+        mCm = null;
+        mPhone = null;
+        mUiccController = null;
+        mDataConnectionTracker = null;
+        mProvisionActionName = null;
+        mSettingsObserver = new SettingsObserver(null, this);
+    }
+
+    public void registerServiceStateTrackerEvents() {
+        mPhone.getServiceStateTracker().registerForDataConnectionAttached(this,
+                DctConstants.EVENT_DATA_CONNECTION_ATTACHED, null);
+        mPhone.getServiceStateTracker().registerForDataConnectionDetached(this,
+                DctConstants.EVENT_DATA_CONNECTION_DETACHED, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingOn(this,
+                DctConstants.EVENT_ROAMING_ON, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingOff(this,
+                DctConstants.EVENT_ROAMING_OFF, null);
+        mPhone.getServiceStateTracker().registerForDataRoamingTypeChange(this,
+                DctConstants.EVENT_ROAMING_TYPE_CHANGED, null);
+        mPhone.getServiceStateTracker().registerForPsRestrictedEnabled(this,
+                DctConstants.EVENT_PS_RESTRICT_ENABLED, null);
+        mPhone.getServiceStateTracker().registerForPsRestrictedDisabled(this,
+                DctConstants.EVENT_PS_RESTRICT_DISABLED, null);
+        mPhone.getServiceStateTracker().registerForDataRegStateOrRatChanged(this,
+                DctConstants.EVENT_DATA_RAT_CHANGED, null);
+    }
+
+    public void unregisterServiceStateTrackerEvents() {
+        mPhone.getServiceStateTracker().unregisterForDataConnectionAttached(this);
+        mPhone.getServiceStateTracker().unregisterForDataConnectionDetached(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingOn(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingOff(this);
+        mPhone.getServiceStateTracker().unregisterForDataRoamingTypeChange(this);
+        mPhone.getServiceStateTracker().unregisterForPsRestrictedEnabled(this);
+        mPhone.getServiceStateTracker().unregisterForPsRestrictedDisabled(this);
+        mPhone.getServiceStateTracker().unregisterForDataRegStateOrRatChanged(this);
+    }
+
+    private void registerForAllEvents() {
+        logd("registerForAllEvents: mPhone = " + mPhone);
+        mPhone.mCi.registerForAvailable(this, DctConstants.EVENT_RADIO_AVAILABLE, null);
+        mPhone.mCi.registerForOffOrNotAvailable(this,
+                DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
+        mPhone.mCi.registerForDataNetworkStateChanged(this,
+                DctConstants.EVENT_DATA_STATE_CHANGED, null);
+        // Note, this is fragile - the Phone is now presenting a merged picture
+        // of PS (volte) & CS and by diving into its internals you're just seeing
+        // the CS data.  This works well for the purposes this is currently used for
+        // but that may not always be the case.  Should probably be redesigned to
+        // accurately reflect what we're really interested in (registerForCSVoiceCallEnded).
+
+        // M: Remove below section for the reason that new PS/CS design has been applied.
+        //mPhone.getCallTracker().registerForVoiceCallEnded(this,
+        //        DctConstants.EVENT_VOICE_CALL_ENDED, null);
+        //mPhone.getCallTracker().registerForVoiceCallStarted(this,
+        //        DctConstants.EVENT_VOICE_CALL_STARTED, null);
+        // M: End
+        registerServiceStateTrackerEvents();
+     //   SubscriptionManager.registerForDdsSwitch(this,
+     //          DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS, null);
+        mPhone.mCi.registerForPcoData(this, DctConstants.EVENT_PCO_DATA_RECEIVED, null);
+
+        // M: cc33
+        mPhone.mCi.registerForRemoveRestrictEutran(this, DctConstants.EVENT_REMOVE_RESTRICT_EUTRAN
+                ,null);
+        // M: Data Retry
+        mPhone.mCi.registerForMdDataRetryCountReset(this,
+                DctConstants.EVENT_MD_DATA_RETRY_COUNT_RESET, null);
+
+        if (false == hasOperatorIaCapability()) {
+            // M: JPN IA
+            if (!WorldPhoneUtil.isWorldPhoneSupport() &&
+                    !("OP01".equals(SystemProperties.get("ro.operator.optr")))) {
+                mPhone.mCi.setOnPlmnChangeNotification(this,
+                        DctConstants.EVENT_REG_PLMN_CHANGED, null);
+                mPhone.mCi.setOnRegistrationSuspended(this, DctConstants.EVENT_REG_SUSPENDED, null);
+            }
+            // M: JPN IA End
+
+            //M: Reset Attach Apn
+            mPhone.mCi.registerForResetAttachApn(this, DctConstants.EVENT_RESET_ATTACH_APN, null);
+
+            // M: IA-change attach APN
+            mPhone.mCi.registerForAttachApnChanged(this,
+                    DctConstants.EVENT_ATTACH_APN_CHANGED, null);
+        }
+
+        mPhone.mCi.registerForPcoStatus(this, DctConstants.EVENT_PCO_STATUS, null);
+
+        // M: [LTE][Low Power][UL traffic shaping]
+        // TODO: Should this move to NW frameworks to handle?
+        mPhone.mCi.registerForLteAccessStratumState(this,
+                DctConstants.EVENT_LTE_ACCESS_STRATUM_STATE, null);
+
+        // M: Multi-PS Attach Start
+        mPhone.mCi.registerSetDataAllowed(this, DctConstants.EVENT_DATA_ALLOWED, null);
+        // M: Multi-PS Attach End
+
+        // M: Register for the change of mDataEnabledSettings
+        registerForDataEnabledChanged(this, DctConstants.EVENT_DATA_ENABLED_SETTINGS, null);
+    }
+
+    public void dispose() {
+        if (DBG) log("DCT.dispose");
+
+        /// M: To stop data customization strategy @{
+        if (mTelephonyExt != null) {
+            mTelephonyExt.stopDataRoamingStrategy();
+        }
+
+        if (mProvisionBroadcastReceiver != null) {
+            mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
+            mProvisionBroadcastReceiver = null;
+        }
+        if (mProvisioningSpinner != null) {
+            mProvisioningSpinner.dismiss();
+            mProvisioningSpinner = null;
+        }
+
+        cleanUpAllConnections(true, null);
+
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            dcac.disconnect();
+        }
+        mDataConnectionAcHashMap.clear();
+        mIsDisposed = true;
+        mPhone.getContext().unregisterReceiver(mIntentReceiver);
+        mUiccController.unregisterForIccChanged(this);
+        mSettingsObserver.unobserve();
+
+        mSubscriptionManager
+                .removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+        mDcc.dispose();
+        mDcTesterFailBringUpAll.dispose();
+
+        mPhone.getContext().getContentResolver().unregisterContentObserver(mApnObserver);
+
+        mPhone.getContext().getContentResolver().unregisterContentObserver(
+                mImsSwitchChangeObserver);
+
+        unregisterForAllEvents();
+
+        mApnContexts.clear();
+        mApnContextsById.clear();
+        mPrioritySortedApnContexts.clear();
+        unregisterForAllEvents();
+
+        destroyDataConnections();
+
+        if (mDcHandlerThread != null) {
+            mDcHandlerThread.quitSafely();
+        }
+
+        // M: dispose data connection fail cause manager
+        mDcFcMgr.dispose();
+    }
+
+    private void unregisterForAllEvents() {
+        logd("unregisterForAllEvents: mPhone = " + mPhone);
+         //Unregister for all events
+        mPhone.mCi.unregisterForAvailable(this);
+        mPhone.mCi.unregisterForOffOrNotAvailable(this);
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            r.unregisterForRecordsLoaded(this);
+            mIccRecords.set(null);
+        }
+        mPhone.mCi.unregisterForDataNetworkStateChanged(this);
+        // M: Remove below section for the reason that new PS/CS design has been applied.
+        //mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
+        //mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
+        // M: End
+        unregisterServiceStateTrackerEvents();
+        //SubscriptionManager.unregisterForDdsSwitch(this);
+        mPhone.mCi.unregisterForPcoData(this);
+
+        // M: cc33
+        mPhone.mCi.unregisterForRemoveRestrictEutran(this);
+        // M: Data Retry
+        mPhone.mCi.unregisterForMdDataRetryCountReset(this);
+
+        if (false == hasOperatorIaCapability()) {
+            // M: JPN IA Start
+            if (!WorldPhoneUtil.isWorldPhoneSupport() &&
+                    !("OP01".equals(SystemProperties.get("ro.operator.optr")))) {
+                mPhone.mCi.unSetOnPlmnChangeNotification(this);
+                mPhone.mCi.unSetOnRegistrationSuspended(this);
+            }
+            // M: JPN IA End
+            // M: Reset Attach Apn
+            mPhone.mCi.unregisterForResetAttachApn(this);
+
+            // M: IA-change attach APN from modem.
+            mPhone.mCi.unregisterForAttachApnChanged(this);
+        }
+
+        mPhone.mCi.unregisterForPcoStatus(this);
+
+        // M: [LTE][Low Power][UL traffic shaping]
+        // TODO: Should this move to NW frameworks to handle?
+        mPhone.mCi.unregisterForLteAccessStratumState(this);
+
+        // M: Multi-PS Attach Start
+        mPhone.mCi.unregisterSetDataAllowed(this);
+        // M: Multi-PS Attach End
+
+        // M: Unregister for the change of mDataEnabledSettings
+        unregisterForDataEnabledChanged(this);
+    }
+
+    /**
+     * Called when EVENT_RESET_DONE is received so goto
+     * IDLE state and send notifications to those interested.
+     *
+     * TODO - currently unused.  Needs to be hooked into DataConnection cleanup
+     * TODO - needs to pass some notion of which connection is reset..
+     */
+    private void onResetDone(AsyncResult ar) {
+        if (DBG) log("EVENT_RESET_DONE");
+        String reason = null;
+        if (ar.userObj instanceof String) {
+            reason = (String) ar.userObj;
+        }
+        gotoIdleAndNotifyDataConnection(reason);
+    }
+
+    /**
+     * Modify {@link android.provider.Settings.Global#MOBILE_DATA} value.
+     */
+    public void setDataEnabled(boolean enable) {
+        Message msg = obtainMessage(DctConstants.CMD_SET_USER_DATA_ENABLE);
+        msg.arg1 = enable ? 1 : 0;
+        if (DBG) log("setDataEnabled: sendMessage: enable=" + enable);
+        sendMessage(msg);
+    }
+
+    private void onSetUserDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            if (mDataEnabledSettings.isUserDataEnabled() != enabled) {
+                mDataEnabledSettings.setUserDataEnabled(enabled);
+
+                //TODO: We should move the followings into DataEnabledSettings class.
+                // For single SIM phones, this is a per phone property.
+                if (TelephonyManager.getDefault().getSimCount() == 1) {
+                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
+                } else {
+                    int phoneSubId = mPhone.getSubId();
+                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId,
+                            enabled ? 1 : 0);
+                }
+
+                // M:
+                setUserDataProperty(enabled);
+                notifyMobileDataChange(enabled ? 1 : 0);
+                // M: }@
+            }
+        }
+    }
+
+    /**
+     * Handle reverting restricted networks back to unrestricted.
+     * If we're changing user data to enabled and this makes data
+     * truely enabled (not disabled by other factors) we need to
+     * tear down any metered apn type that was enabled anyway by
+     * a privileged request.  This allows us to reconnect
+     * to it in an unrestricted way.
+     */
+    private void teardownRestrictedMeteredConnections() {
+        if (mDataEnabledSettings.isDataEnabled(true)) {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                if (apnContext.isConnectedOrConnecting() &&
+                        apnContext.getApnSetting().isMetered(mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming())) {
+
+                    final DcAsyncChannel dataConnectionAc = apnContext.getDcAc();
+                    if (dataConnectionAc != null) {
+                        final NetworkCapabilities nc =
+                                dataConnectionAc.getNetworkCapabilitiesSync();
+                        if (nc != null && nc.hasCapability(NetworkCapabilities.
+                              NET_CAPABILITY_NOT_RESTRICTED)) {
+                            if (DBG) log("not tearing down unrestricted metered net:" + apnContext);
+                            continue;
+                        }
+                    }
+                    if (DBG) log("tearing down restricted metered net: " + apnContext);
+                    apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                    cleanUpConnection(true, apnContext);
+                }
+            }
+        }
+    }
+
+    private void onDeviceProvisionedChange() {
+        if (getDataEnabled()) {
+            mDataEnabledSettings.setUserDataEnabled(true);
+            teardownRestrictedMeteredConnections();
+            onTrySetupData(Phone.REASON_DATA_ENABLED);
+        } else {
+            mDataEnabledSettings.setUserDataEnabled(false);
+            onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+        }
+    }
+
+
+    public long getSubId() {
+        return mPhone.getSubId();
+    }
+
+    public DctConstants.Activity getActivity() {
+        return mActivity;
+    }
+
+    private void setActivity(DctConstants.Activity activity) {
+        log("setActivity = " + activity);
+        mActivity = activity;
+        mPhone.notifyDataActivity();
+    }
+
+    public void requestNetwork(NetworkRequest networkRequest, LocalLog log) {
+        final int apnId = ApnContext.apnIdForNetworkRequest(networkRequest);
+        final ApnContext apnContext = mApnContextsById.get(apnId);
+        log.log("DcTracker.requestNetwork for " + networkRequest + " found " + apnContext);
+        if (apnContext != null) apnContext.requestNetwork(networkRequest, log);
+    }
+
+    public void releaseNetwork(NetworkRequest networkRequest, LocalLog log) {
+        final int apnId = ApnContext.apnIdForNetworkRequest(networkRequest);
+        final ApnContext apnContext = mApnContextsById.get(apnId);
+        log.log("DcTracker.releaseNetwork for " + networkRequest + " found " + apnContext);
+        if (apnContext != null) apnContext.releaseNetwork(networkRequest, log);
+    }
+
+    public boolean isApnSupported(String name) {
+        if (name == null) {
+            loge("isApnSupported: name=null");
+            return false;
+        }
+        ApnContext apnContext = mApnContexts.get(name);
+        if (apnContext == null) {
+            loge("Request for unsupported mobile name: " + name);
+            return false;
+        }
+        return true;
+    }
+
+    public int getApnPriority(String name) {
+        ApnContext apnContext = mApnContexts.get(name);
+        if (apnContext == null) {
+            loge("Request for unsupported mobile name: " + name);
+        }
+        return apnContext.priority;
+    }
+
+    // Turn telephony radio on or off.
+    private void setRadio(boolean on) {
+        final ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
+        try {
+            phone.setRadio(on);
+        } catch (Exception e) {
+            // Ignore.
+        }
+    }
+
+    // Class to handle Intent dispatched with user selects the "Sign-in to network"
+    // notification.
+    private class ProvisionNotificationBroadcastReceiver extends BroadcastReceiver {
+        private final String mNetworkOperator;
+        // Mobile provisioning URL.  Valid while provisioning notification is up.
+        // Set prior to notification being posted as URL contains ICCID which
+        // disappears when radio is off (which is the case when notification is up).
+        private final String mProvisionUrl;
+
+        public ProvisionNotificationBroadcastReceiver(String provisionUrl, String networkOperator) {
+            mNetworkOperator = networkOperator;
+            mProvisionUrl = provisionUrl;
+        }
+
+        private void setEnableFailFastMobileData(int enabled) {
+            sendMessage(obtainMessage(DctConstants.CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA, enabled, 0));
+        }
+
+        private void enableMobileProvisioning() {
+            final Message msg = obtainMessage(DctConstants.CMD_ENABLE_MOBILE_PROVISIONING);
+            msg.setData(Bundle.forPair(DctConstants.PROVISIONING_URL_KEY, mProvisionUrl));
+            sendMessage(msg);
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // Turning back on the radio can take time on the order of a minute, so show user a
+            // spinner so they know something is going on.
+            mProvisioningSpinner = new ProgressDialog(context);
+            mProvisioningSpinner.setTitle(mNetworkOperator);
+            mProvisioningSpinner.setMessage(
+                    // TODO: Don't borrow "Connecting..." i18n string; give Telephony a version.
+                    context.getText(com.android.internal.R.string.media_route_status_connecting));
+            mProvisioningSpinner.setIndeterminate(true);
+            mProvisioningSpinner.setCancelable(true);
+            // Allow non-Activity Service Context to create a View.
+            mProvisioningSpinner.getWindow().setType(
+                    WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
+            mProvisioningSpinner.show();
+            // After timeout, hide spinner so user can at least use their device.
+            // TODO: Indicate to user that it is taking an unusually long time to connect?
+            sendMessageDelayed(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER,
+                    mProvisioningSpinner), PROVISIONING_SPINNER_TIMEOUT_MILLIS);
+            // This code is almost identical to the old
+            // ConnectivityService.handleMobileProvisioningAction code.
+            setRadio(true);
+            setEnableFailFastMobileData(DctConstants.ENABLED);
+            enableMobileProvisioning();
+        }
+    }
+
+    public boolean isDataPossible(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext == null) {
+            return false;
+        }
+        boolean apnContextIsEnabled = apnContext.isEnabled();
+        DctConstants.State apnContextState = apnContext.getState();
+        boolean apnTypePossible = !(apnContextIsEnabled &&
+                (apnContextState == DctConstants.State.FAILED));
+        boolean isEmergencyApn = apnContext.getApnType().equals(PhoneConstants.APN_TYPE_EMERGENCY);
+        // Set the emergency APN availability status as TRUE irrespective of conditions checked in
+        // isDataAllowed() like IN_SERVICE, MOBILE DATA status etc.
+        boolean dataAllowed = isEmergencyApn || isDataAllowed(null);
+        boolean possible = dataAllowed && apnTypePossible;
+
+        if ((apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    || apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IA))
+                && (mPhone.getServiceState().getRilDataRadioTechnology()
+                == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+            log("Default data call activation not possible in iwlan.");
+            possible = false;
+        }
+
+        if (VDBG) {
+            log(String.format("isDataPossible(%s): possible=%b isDataAllowed=%b " +
+                            "apnTypePossible=%b apnContextisEnabled=%b apnContextState()=%s",
+                    apnType, possible, dataAllowed, apnTypePossible,
+                    apnContextIsEnabled, apnContextState));
+        }
+        return possible;
+    }
+
+    @Override
+    protected void finalize() {
+        if(DBG && mPhone != null) log("finalize");
+    }
+
+    private ApnContext addApnContext(String type, NetworkConfig networkConfig) {
+        ApnContext apnContext = new ApnContext(mPhone, type, LOG_TAG, networkConfig, this);
+        mApnContexts.put(type, apnContext);
+        mApnContextsById.put(ApnContext.apnIdForApnName(type), apnContext);
+        mPrioritySortedApnContexts.add(apnContext);
+        return apnContext;
+    }
+
+    private void initApnContexts() {
+        log("initApnContexts: E");
+        // Load device network attributes from resources
+        String[] networkConfigStrings = mPhone.getContext().getResources().getStringArray(
+                com.android.internal.R.array.networkAttributes);
+        for (String networkConfigString : networkConfigStrings) {
+            NetworkConfig networkConfig = new NetworkConfig(networkConfigString);
+            ApnContext apnContext = null;
+
+            switch (networkConfig.type) {
+            case ConnectivityManager.TYPE_MOBILE:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DEFAULT, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_MMS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_MMS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_SUPL:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_SUPL, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_DUN:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DUN, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_HIPRI:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_HIPRI, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_FOTA:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_FOTA, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_IMS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_IMS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_CBS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_CBS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_IA:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_IA, networkConfig);
+                break;
+            /** M: start */
+            case ConnectivityManager.TYPE_MOBILE_DM:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_DM, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_NET:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_NET, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_WAP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_WAP, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_CMMAIL:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_CMMAIL, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_RCSE:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_RCSE, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_XCAP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_XCAP, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_RCS:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_RCS, networkConfig);
+                break;
+            case ConnectivityManager.TYPE_MOBILE_BIP:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_BIP, networkConfig);
+                break;
+            /** M: end*/
+            case ConnectivityManager.TYPE_MOBILE_EMERGENCY:
+                apnContext = addApnContext(PhoneConstants.APN_TYPE_EMERGENCY, networkConfig);
+                break;
+            default:
+                log("initApnContexts: skipping unknown type=" + networkConfig.type);
+                continue;
+            }
+            log("initApnContexts: apnContext=" + apnContext);
+        }
+
+        //The implement of priorityQueue class is incorrect, we sort the list by ourself
+        Collections.sort(mPrioritySortedApnContexts, new Comparator<ApnContext>() {
+            public int compare(ApnContext c1, ApnContext c2) {
+                return c2.priority - c1.priority;
+            }
+        });
+        logd("initApnContexts: mPrioritySortedApnContexts=" + mPrioritySortedApnContexts);
+        if (VDBG) log("initApnContexts: X mApnContexts=" + mApnContexts);
+    }
+
+    public LinkProperties getLinkProperties(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            DcAsyncChannel dcac = apnContext.getDcAc();
+            if (dcac != null) {
+                if (DBG) log("return link properites for " + apnType);
+                return dcac.getLinkPropertiesSync();
+            }
+        }
+        if (DBG) log("return new LinkProperties");
+        return new LinkProperties();
+    }
+
+    public NetworkCapabilities getNetworkCapabilities(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext!=null) {
+            DcAsyncChannel dataConnectionAc = apnContext.getDcAc();
+            if (dataConnectionAc != null) {
+                if (DBG) {
+                    log("get active pdp is not null, return NetworkCapabilities for " + apnType);
+                }
+                return dataConnectionAc.getNetworkCapabilitiesSync();
+            }
+        }
+        if (DBG) log("return new NetworkCapabilities");
+        return new NetworkCapabilities();
+    }
+
+    // Return all active apn types
+    public String[] getActiveApnTypes() {
+        if (DBG) log("get all active apn types");
+        ArrayList<String> result = new ArrayList<String>();
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (mAttached.get() && apnContext.isReady()) {
+                result.add(apnContext.getApnType());
+            }
+        }
+
+        return result.toArray(new String[0]);
+    }
+
+    // Return active apn of specific apn type
+    public String getActiveApnString(String apnType) {
+        if (VDBG) logv("get active apn string for type:" + apnType);
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            ApnSetting apnSetting = apnContext.getApnSetting();
+            if (apnSetting != null) {
+                return apnSetting.apn;
+            }
+        }
+        return null;
+    }
+
+    // Return state of specific apn type
+    public DctConstants.State getState(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            return apnContext.getState();
+        }
+        return DctConstants.State.FAILED;
+    }
+
+    // Return if apn type is a provisioning apn.
+    private boolean isProvisioningApn(String apnType) {
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext != null) {
+            return apnContext.isProvisioningApn();
+        }
+        return false;
+    }
+
+    // Return state of overall
+    public DctConstants.State getOverallState() {
+        boolean isConnecting = false;
+        boolean isFailed = true; // All enabled Apns should be FAILED.
+        boolean isAnyEnabled = false;
+
+        //M: For debug, dump overall state.
+        StringBuilder builder = new StringBuilder();
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext != null) {
+                builder.append(apnContext.toString() + ", ");
+            }
+        }
+        logd("overall state is " + builder);
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.isEnabled()) {
+                isAnyEnabled = true;
+                switch (apnContext.getState()) {
+                case CONNECTED:
+                case DISCONNECTING:
+                    if (VDBG) log("overall state is CONNECTED");
+                    return DctConstants.State.CONNECTED;
+                case RETRYING:
+                case CONNECTING:
+                    isConnecting = true;
+                    isFailed = false;
+                    break;
+                case IDLE:
+                case SCANNING:
+                    isFailed = false;
+                    break;
+                default:
+                    isAnyEnabled = true;
+                    break;
+                }
+            }
+        }
+
+        if (!isAnyEnabled) { // Nothing enabled. return IDLE.
+            if (VDBG) log( "overall state is IDLE");
+            return DctConstants.State.IDLE;
+        }
+
+        if (isConnecting) {
+            if (VDBG) log( "overall state is CONNECTING");
+            return DctConstants.State.CONNECTING;
+        } else if (!isFailed) {
+            if (VDBG) log( "overall state is IDLE");
+            return DctConstants.State.IDLE;
+        } else {
+            if (VDBG) log( "overall state is FAILED");
+            return DctConstants.State.FAILED;
+        }
+    }
+
+    public boolean isApnTypeAvailable(String type) {
+        if ((type.equals(PhoneConstants.APN_TYPE_DUN) && fetchDunApn() != null) ||
+             type.equals(PhoneConstants.APN_TYPE_EMERGENCY)) {
+            logd("isApnTypeAvaiable, apn: " + type);
+            return true;
+        }
+
+        if (mAllApnSettings != null) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(type)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Report on whether data connectivity is enabled for any APN.
+     * @return {@code false} if data connectivity has been explicitly disabled,
+     * {@code true} otherwise.
+     */
+    public boolean getAnyDataEnabled() {
+        if (!mDataEnabledSettings.isDataEnabled(true)) return false;
+        DataAllowFailReason failureReason = new DataAllowFailReason();
+        if (!isDataAllowed(failureReason)) {
+            if (DBG) log(failureReason.getDataAllowFailReason());
+            return false;
+        }
+        for (ApnContext apnContext : mApnContexts.values()) {
+            // Make sure we don't have a context that is going down
+            // and is explicitly disabled.
+            if (isDataAllowedForApn(apnContext)) {
+                logd("getAnyDataEnabled1 return true, apn=" + apnContext.getApnType());
+                return true;
+            }
+        }
+        log("getAnyDataEnabled1 return false");
+        return false;
+    }
+
+    @VisibleForTesting
+    public boolean isDataEnabled(boolean checkUserDataEnabled) {
+        return mDataEnabledSettings.isDataEnabled(checkUserDataEnabled);
+    }
+
+    private boolean isDataAllowedForApn(ApnContext apnContext) {
+        //If RAT is iwlan then dont allow default/IA PDP at all.
+        //Rest of APN types can be evaluated for remaining conditions.
+        if ((apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    || apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IA))
+                && (mPhone.getServiceState().getRilDataRadioTechnology()
+                == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+            log("Default data call activation not allowed in iwlan.");
+            return false;
+        }
+
+        return apnContext.isReady();
+    }
+
+    //****** Called from ServiceStateTracker
+    /**
+     * Invoked when ServiceStateTracker observes a transition from GPRS
+     * attach to detach.
+     */
+    private void onDataConnectionDetached() {
+        /*
+         * We presently believe it is unnecessary to tear down the PDP context
+         * when GPRS detaches, but we should stop the network polling.
+         */
+        if (DBG) log ("onDataConnectionDetached: stop polling and notify detached");
+        stopNetStatPoll();
+        stopDataStallAlarm();
+        notifyDataConnection(Phone.REASON_DATA_DETACHED);
+        mAttached.set(false);
+
+        // M: To avoid trying setup data call before PS attach.
+        if (mAutoAttachOnCreationConfig) {
+            mAutoAttachOnCreation.set(false);
+        }
+    }
+
+    private void onDataConnectionAttached() {
+        if (DBG) log("onDataConnectionAttached");
+        mAttached.set(true);
+        if (getOverallState() == DctConstants.State.CONNECTED) {
+            if (DBG) log("onDataConnectionAttached: start polling notify attached");
+            startNetStatPoll();
+            startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+            notifyDataConnection(Phone.REASON_DATA_ATTACHED);
+        } else {
+            // update APN availability so that APN can be enabled.
+            notifyOffApnsOfAvailability(Phone.REASON_DATA_ATTACHED);
+        }
+        if (mAutoAttachOnCreationConfig) {
+            mAutoAttachOnCreation.set(true);
+        }
+        setupDataOnConnectableApns(Phone.REASON_DATA_ATTACHED);
+    }
+
+    private boolean isDataAllowed(DataAllowFailReason failureReason) {
+        final boolean internalDataEnabled;
+        internalDataEnabled = mDataEnabledSettings.isInternalDataEnabled();
+
+        boolean attachedState = mAttached.get();
+        boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
+        boolean radioStateFromCarrier = mPhone.getServiceStateTracker().getPowerStateFromCarrier();
+        int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+        if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+            desiredPowerState = true;
+            radioStateFromCarrier = true;
+        }
+
+        IccRecords r = mIccRecords.get();
+        boolean recordsLoaded = false;
+        if (r != null) {
+            recordsLoaded = r.getRecordsLoaded();
+            if (DBG && !recordsLoaded) log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
+        }
+
+        boolean bIsFdnEnabled = isFdnEnabled();
+
+        int dataSub = SubscriptionManager.getDefaultDataSubscriptionId();
+        boolean defaultDataSelected = SubscriptionManager.isValidSubscriptionId(dataSub);
+
+        PhoneConstants.State state = PhoneConstants.State.IDLE;
+        // Note this is explicitly not using mPhone.getState.  See b/19090488.
+        // mPhone.getState reports the merge of CS and PS (volte) voice call state
+        // but we only care about CS calls here for data/voice concurrency issues.
+        // Calling getCallTracker currently gives you just the CS side where the
+        // ImsCallTracker is held internally where applicable.
+        // This should be redesigned to ask explicitly what we want:
+        // voiceCallStateAllowDataCall, or dataCallAllowed or something similar.
+        if (mPhone.getCallTracker() != null) {
+            state = mPhone.getCallTracker().getState();
+        }
+
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (failureReason != null) failureReason.clearAllReasons();
+        if (!(attachedState || mAutoAttachOnCreation.get())) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.NOT_ATTACHED);
+        }
+        if (!recordsLoaded) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.RECORD_NOT_LOADED);
+        }
+        if (!dcHelper.isAllCallingStateIdle() &&
+                !dcHelper.isDataSupportConcurrent(mPhone.getPhoneId()) &&
+                !(dcHelper.isWifiCallingEnabled() && !mPhone.isInEmergencyCall())) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.INVALID_PHONE_STATE);
+            failureReason.addDataAllowFailReason(
+                    DataAllowFailReasonType.CONCURRENT_VOICE_DATA_NOT_ALLOWED);
+        }
+        if (!internalDataEnabled) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.INTERNAL_DATA_DISABLED);
+        }
+        if (!defaultDataSelected) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(
+                    DataAllowFailReasonType.DEFAULT_DATA_UNSELECTED);
+        }
+        if ((mPhone.getServiceState().getDataRoaming() ||
+                mPhone.getServiceStateTracker().isPsRegStateRoamByUnsol()) &&
+                !getDataOnRoamingEnabled()) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.ROAMING_DISABLED);
+        }
+        if (mIsPsRestricted) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.PS_RESTRICTED);
+        }
+        if (!desiredPowerState) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.UNDESIRED_POWER_STATE);
+        }
+        if (!radioStateFromCarrier) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.RADIO_DISABLED_BY_CARRIER);
+        }
+        if (bIsFdnEnabled) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.FDN_ENABLED);
+        }
+
+        if (!getAllowConfig()) {
+            if(failureReason == null) return false;
+            failureReason.addDataAllowFailReason(DataAllowFailReasonType.NOT_ALLOWED);
+        }
+
+        return failureReason == null || !failureReason.isFailed();
+    }
+
+    private boolean isDataAllowedExt(DataAllowFailReason failureReason, String apnType) {
+        int nFailReasonSize = failureReason.getSizeOfFailReason();
+        boolean allow = false;
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.DEFAULT_DATA_UNSELECTED)) {
+            if (ignoreDefaultDataUnselected(apnType)) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.ROAMING_DISABLED)) {
+            if (ignoreDataRoaming(apnType) || getDomesticRoamingEnabled()) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (failureReason.mDataAllowFailReasonSet.contains(
+                DataAllowFailReasonType.NOT_ALLOWED)) {
+            if (ignoreDataAllow(apnType)) {
+                nFailReasonSize--;
+            } else {
+                return false;
+            }
+        }
+
+        if (nFailReasonSize == 0) {
+            allow = true;
+        }
+
+        if (VDBG) log("isDataAllowedExt: " + allow);
+
+        return allow;
+    }
+
+    // arg for setupDataOnConnectableApns
+    private enum RetryFailures {
+        // retry failed networks always (the old default)
+        ALWAYS,
+        // retry only when a substantial change has occurred.  Either:
+        // 1) we were restricted by voice/data concurrency and aren't anymore
+        // 2) our apn list has change
+        ONLY_ON_CHANGE
+    };
+
+    private void setupDataOnConnectableApns(String reason) {
+        setupDataOnConnectableApns(reason, RetryFailures.ALWAYS);
+    }
+
+    private void setupDataOnConnectableApns(String reason, RetryFailures retryFailures) {
+        if (VDBG) log("setupDataOnConnectableApns: " + reason);
+
+        if (DBG && !VDBG) {
+            StringBuilder sb = new StringBuilder(120);
+            for (ApnContext apnContext : mPrioritySortedApnContexts) {
+                sb.append(apnContext.getApnType());
+                sb.append(":[state=");
+                sb.append(apnContext.getState());
+                sb.append(",enabled=");
+                sb.append(apnContext.isEnabled());
+                sb.append("] ");
+            }
+            log("setupDataOnConnectableApns: " + reason + " " + sb);
+        }
+
+        ArrayList<ApnContext> aryApnContext = new ArrayList<ApnContext>();
+        String strTempIA = SystemProperties.get("ril.radio.ia-apn");
+
+        for (ApnContext tmpApnContext : mPrioritySortedApnContexts) {
+            if ((TextUtils.equals(strTempIA, "VZWIMS")
+                    && TextUtils.equals(tmpApnContext.getApnType(), PhoneConstants.APN_TYPE_IMS))
+                    || (TextUtils.equals(strTempIA, "VZWINTERNET")
+                    && TextUtils.equals(tmpApnContext.getApnType(),
+                        PhoneConstants.APN_TYPE_DEFAULT))) {
+                aryApnContext.add(0, tmpApnContext);
+            } else {
+                aryApnContext.add(tmpApnContext);
+            }
+        }
+
+        for (ApnContext apnContext : aryApnContext) {
+            ArrayList<ApnSetting> waitingApns = null;
+
+            if (VDBG) logv("setupDataOnConnectableApns: apnContext " + apnContext);
+
+            if ((mTelDevController.getModem(0) != null &&
+                    mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false)
+                    //Don't retry IMS PDN for reason Phone.REASON_MD_DATA_RETRY_COUNT_RESET
+                    //as it's originally designed for default PDN.
+                    || TextUtils.equals(reason, Phone.REASON_MD_DATA_RETRY_COUNT_RESET)) {
+                    if (PhoneConstants.APN_TYPE_IMS.equals(apnContext.getApnType()) ||
+                            PhoneConstants.APN_TYPE_EMERGENCY.equals(apnContext.getApnType())) {
+                        logd("setupDataOnConnectableApns: ignore apnContext " + apnContext);
+                        continue;
+                    }
+            }
+
+            if (apnContext.getState() == DctConstants.State.SCANNING) {
+                // M: The SCANNING state of ApnContext is meant to be RETRYING state currently,
+                // TODO: Should pay attention to the meaning of SCANNING state.
+                if (mDcFcMgr != null && mDcFcMgr.canIgnoredReason(reason)) {
+                    continue;
+                }
+            }
+
+            if (apnContext.getState() == DctConstants.State.FAILED
+                    || apnContext.getState() == DctConstants.State.SCANNING) {
+                if (retryFailures == RetryFailures.ALWAYS) {
+                    apnContext.releaseDataConnection(reason);
+                } else if (apnContext.isConcurrentVoiceAndDataAllowed() == false &&
+                        mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
+                    // RetryFailures.ONLY_ON_CHANGE - check if voice concurrency has changed
+                    apnContext.releaseDataConnection(reason);
+                } else {
+                    // RetryFailures.ONLY_ON_CHANGE - check if the apns have changed
+                    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+                    ArrayList<ApnSetting> originalApns = apnContext.getWaitingApns();
+                    if (originalApns != null && originalApns.isEmpty() == false) {
+                        waitingApns = buildWaitingApns(apnContext.getApnType(), radioTech);
+                        if (originalApns.size() != waitingApns.size() ||
+                                originalApns.containsAll(waitingApns) == false) {
+                            apnContext.releaseDataConnection(reason);
+                        } else {
+                            continue;
+                        }
+                        continue;
+                    }
+                }
+            }
+            if (TextUtils.equals(apnContext.getApnType(), PhoneConstants.APN_TYPE_DEFAULT)
+                    && TextUtils.equals(strTempIA, "VZWIMS")) {
+                ApnContext apnContextIms = mApnContexts.get(PhoneConstants.APN_TYPE_IMS);
+                if (apnContextIms != null && !apnContextIms.isEnabled()
+                        && !TextUtils.equals(reason, Phone.REASON_DATA_ATTACHED)
+                            && !TextUtils.equals(reason, Phone.REASON_DATA_ENABLED)
+                        && !TextUtils.equals(reason, Phone.REASON_APN_CHANGED)
+                        && !TextUtils.equals(reason, Phone.REASON_VOICE_CALL_ENDED)
+                        && !TextUtils.equals(reason, Phone.REASON_SIM_LOADED)) {
+                    log("setupDataOnConnectableApns: ignore default pdn setup");
+                    continue;
+                }
+            }
+            if (apnContext.isConnectable()) {
+                log("setupDataOnConnectableApns: isConnectable() call trySetupData");
+                apnContext.setReason(reason);
+                trySetupData(apnContext, waitingApns);
+            }
+        }
+    }
+
+    boolean isEmergency() {
+        final boolean result = mPhone.isInEcm() || mPhone.isInEmergencyCall();
+        log("isEmergency: result=" + result);
+        return result;
+    }
+
+    private boolean trySetupData(ApnContext apnContext) {
+        return trySetupData(apnContext, null);
+    }
+
+    private boolean trySetupData(ApnContext apnContext, ArrayList<ApnSetting> waitingApns) {
+        // M: For debug
+        if (DBG) {
+            logi("trySetupData for type:" + apnContext.getApnType() +
+                    " due to " + apnContext.getReason() + ", mIsPsRestricted=" + mIsPsRestricted);
+        }
+        apnContext.requestLog("trySetupData due to " + apnContext.getReason());
+
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            apnContext.setState(DctConstants.State.CONNECTED);
+            mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+            log("trySetupData: X We're on the simulator; assuming connected retValue=true");
+            return true;
+        }
+
+        // Allow SETUP_DATA request for E-APN to be completed during emergency call
+        // and MOBILE DATA On/Off cases as well.
+        boolean isEmergencyApn = apnContext.getApnType().equals(PhoneConstants.APN_TYPE_EMERGENCY);
+        final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+
+        // set to false if apn type is non-metered or if we have a restricted (priveleged)
+        // request for the network.
+        // TODO - may want restricted requests to only apply to carrier-limited data access
+        //        rather than applying to user limited as well.
+        // Exclude DUN for the purposes of the override until we get finer grained
+        // intention in NetworkRequests
+        boolean checkUserDataEnabled =
+                ApnSetting.isMeteredApnType(apnContext.getApnType(), mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming()) &&
+                        /** M: enable MMS and SUPL even if data is disabled */
+                        !isDataAllowedAsOff(apnContext.getApnType()) &&
+                        apnContext.hasNoRestrictedRequests(true /*exclude DUN */);
+
+        DataAllowFailReason failureReason = new DataAllowFailReason();
+
+        // allow data if currently in roaming service, roaming setting disabled
+        // and requested apn type is non-metered for roaming.
+        boolean isDataAllowed = isDataAllowed(failureReason) ||
+                (failureReason.isFailForSingleReason(DataAllowFailReasonType.ROAMING_DISABLED) &&
+                !(ApnSetting.isMeteredApnType(apnContext.getApnType(), mPhone.getContext(),
+                mPhone.getSubId(), mPhone.getServiceState().getDataRoaming()))) ||
+                // M: extend the logics of isDataAllowed()
+                isDataAllowedExt(failureReason, apnContext.getApnType());
+
+        if (apnContext.isConnectable() && (isEmergencyApn ||
+                (isDataAllowed && isDataAllowedForApn(apnContext) &&
+                        mDataEnabledSettings.isDataEnabled(checkUserDataEnabled) && !isEmergency()))) {
+            if (apnContext.getState() == DctConstants.State.FAILED) {
+                String str = "trySetupData: make a FAILED ApnContext IDLE so its reusable";
+                if (DBG) log(str);
+                apnContext.requestLog(str);
+                apnContext.setState(DctConstants.State.IDLE);
+            }
+            int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+            apnContext.setConcurrentVoiceAndDataAllowed(sst.isConcurrentVoiceAndDataAllowed());
+            if (apnContext.getState() == DctConstants.State.IDLE) {
+
+                if (waitingApns == null) {
+                    if (mTelDevController.getModem(0) != null &&
+                            mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false) {
+                        // M: ECC w/o SIM {
+                        if (TextUtils.equals(apnContext.getApnType(),
+                            PhoneConstants.APN_TYPE_EMERGENCY)) {
+                            if (mAllApnSettings == null) {
+                                logi("mAllApnSettings is null, create first and add emergency one");
+                                createAllApnList();
+                            } else if (mAllApnSettings.isEmpty()) {
+                                logi("add mEmergencyApn: " + mEmergencyApn + " to mAllApnSettings");
+                                addEmergencyApnSetting();
+                            }
+                        }
+                        // M: ECC w/o SIM }
+                    }
+                    waitingApns = buildWaitingApns(apnContext.getApnType(), radioTech);
+                }
+                if (waitingApns.isEmpty()) {
+                    notifyNoData(DcFailCause.MISSING_UNKNOWN_APN, apnContext);
+                    notifyOffApnsOfAvailability(apnContext.getReason());
+                    String str = "trySetupData: X No APN found retValue=false";
+                    if (DBG) log(str);
+                    apnContext.requestLog(str);
+                    return false;
+                } else {
+                    apnContext.setWaitingApns(waitingApns);
+                    // M: VDF MMS over ePDG @{
+                    apnContext.setWifiApns(buildWifiApns(apnContext.getApnType()));
+                    /// @}
+                    if (DBG) {
+                        log ("trySetupData: Create from mAllApnSettings : "
+                                    + apnListToString(mAllApnSettings));
+                    }
+                }
+            }
+
+            logd("trySetupData: call setupData, waitingApns : "
+                    + apnListToString(apnContext.getWaitingApns())
+                    + ", wifiApns : " // VDF MMS over ePDG
+                    + apnListToString(apnContext.getWifiApns()));
+
+            boolean retValue = setupData(apnContext, radioTech);
+            notifyOffApnsOfAvailability(apnContext.getReason());
+
+            if (DBG) log("trySetupData: X retValue=" + retValue);
+            return retValue;
+        } else {
+            if (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT)
+                    && apnContext.isConnectable()) {
+                if (apnContext.getApnType().equals(PhoneConstants.APN_TYPE_MMS)
+                        && TelephonyManager.getDefault().isMultiSimEnabled() && !mAttached.get()) {
+                    log("Wait for attach");
+                    return true;
+                } else {
+                    mPhone.notifyDataConnectionFailed(apnContext.getReason(),
+                            apnContext.getApnType());
+                }
+            }
+            notifyOffApnsOfAvailability(apnContext.getReason());
+
+            StringBuilder str = new StringBuilder();
+
+            str.append("trySetupData failed. apnContext = [type=" + apnContext.getApnType() +
+                    ", mState=" + apnContext.getState() + ", mDataEnabled=" +
+                    apnContext.isEnabled() + ", mDependencyMet=" +
+                    apnContext.getDependencyMet() + "] ");
+
+            if (!apnContext.isConnectable()) {
+                str.append("isConnectable = false. ");
+            }
+            if (!isDataAllowed) {
+                str.append("data not allowed: " + failureReason.getDataAllowFailReason() + ". ");
+            }
+            if (!isDataAllowedForApn(apnContext)) {
+                str.append("isDataAllowedForApn = false. RAT = " +
+                        mPhone.getServiceState().getRilDataRadioTechnology());
+            }
+            if (!mDataEnabledSettings.isDataEnabled(checkUserDataEnabled)) {
+                str.append("isDataEnabled(" + checkUserDataEnabled + ") = false. " +
+                        "isInternalDataEnabled = " + mDataEnabledSettings.isInternalDataEnabled() +
+                        ", userDataEnabled = " + mDataEnabledSettings.isUserDataEnabled() +
+                        ", isPolicyDataEnabled = " + mDataEnabledSettings.isPolicyDataEnabled() +
+                        ", isCarrierDataEnabled = " +
+                        mDataEnabledSettings.isCarrierDataEnabled());
+            }
+            if (isEmergency()) {
+                str.append("emergency = true");
+            }
+
+            // M: For debug
+            if (DBG) logi(str.toString());
+            apnContext.requestLog(str.toString());
+
+            return false;
+        }
+    }
+
+    // Disabled apn's still need avail/unavail notifications - send them out
+    private void notifyOffApnsOfAvailability(String reason) {
+        if (DBG) {
+            DataAllowFailReason failureReason = new DataAllowFailReason();
+            if (!isDataAllowed(failureReason)) {
+                log(failureReason.getDataAllowFailReason());
+            }
+        }
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if ((!mAttached.get() || !apnContext.isReady()) && apnContext.isNeedNotify()) {
+                String apnType = apnContext.getApnType();
+                if (VDBG) {
+                    logv("notifyOffApnOfAvailability type:" + apnType + " reason: " + reason);
+                }
+                mPhone.notifyDataConnection(reason != null ? reason : apnContext.getReason(),
+                                            apnType, PhoneConstants.DataState.DISCONNECTED);
+            } else {
+                if (VDBG) {
+                    logv("notifyOffApnsOfAvailability skipped apn due to attached && isReady " +
+                            apnContext.toString());
+                }
+            }
+        }
+    }
+
+    /**
+     * If tearDown is true, this only tears down a CONNECTED session. Presently,
+     * there is no mechanism for abandoning an CONNECTING session,
+     * but would likely involve cancelling pending async requests or
+     * setting a flag or new state to ignore them when they came in
+     * @param tearDown true if the underlying DataConnection should be
+     * disconnected.
+     * @param reason reason for the clean up.
+     * @return boolean - true if we did cleanup any connections, false if they
+     *                   were already all disconnected.
+     */
+    private boolean cleanUpAllConnections(boolean tearDown, String reason) {
+        if (DBG) log("cleanUpAllConnections: tearDown=" + tearDown + " reason=" + reason);
+        boolean didDisconnect = false;
+        boolean disableMeteredOnly = false;
+
+        // reasons that only metered apn will be torn down
+        if (!TextUtils.isEmpty(reason)) {
+            disableMeteredOnly = reason.equals(Phone.REASON_DATA_SPECIFIC_DISABLED) ||
+                    reason.equals(Phone.REASON_ROAMING_ON) ||
+                    reason.equals(Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
+            // /Ignore IMS PDN deactivation when Radio turned off or PDP Recovery @{
+            disableMeteredOnly =
+                    disableMeteredOnly ||
+                    reason.equals(Phone.REASON_RADIO_TURNED_OFF) ||
+                    reason.equals(Phone.REASON_PDP_RESET);
+            // /@}
+        }
+
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.isDisconnected() == false) didDisconnect = true;
+            if (disableMeteredOnly) {
+                // Use ApnSetting to decide metered or non-metered.
+                // Tear down all metered data connections.
+                ApnSetting apnSetting = apnContext.getApnSetting();
+                if (apnSetting != null && apnSetting.isMetered(mPhone.getContext(),
+                        mPhone.getSubId(), mPhone.getServiceState().getDataRoaming())) {
+                    if (DBG) log("clean up metered ApnContext Type: " + apnContext.getApnType());
+                    apnContext.setReason(reason);
+                    cleanUpConnection(tearDown, apnContext);
+                }
+            } else {
+                if (reason != null && reason.equals(Phone.REASON_ROAMING_ON)
+                        && ignoreDataRoaming(apnContext.getApnType())) {
+                    log("cleanUpConnection: Ignore Data Roaming for apnType = "
+                            + apnContext.getApnType());
+                } else {
+                    // TODO - only do cleanup if not disconnected
+                    apnContext.setReason(reason);
+                    cleanUpConnection(tearDown, apnContext);
+                }
+            }
+        }
+
+        stopNetStatPoll();
+        stopDataStallAlarm();
+
+        // TODO: Do we need mRequestedApnType?
+        mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+        log("cleanUpConnection: mDisconnectPendingCount = " + mDisconnectPendingCount);
+        if (tearDown && mDisconnectPendingCount == 0) {
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+
+        return didDisconnect;
+    }
+
+    /**
+     * Cleanup all connections.
+     *
+     * TODO: Cleanup only a specified connection passed as a parameter.
+     *       Also, make sure when you clean up a conn, if it is last apply
+     *       logic as though it is cleanupAllConnections
+     *
+     * @param cause for the clean up.
+     */
+    private void onCleanUpAllConnections(String cause) {
+        cleanUpAllConnections(true, cause);
+    }
+
+    void sendCleanUpConnection(boolean tearDown, ApnContext apnContext) {
+        if (DBG) log("sendCleanUpConnection: tearDown=" + tearDown + " apnContext=" + apnContext);
+        Message msg = obtainMessage(DctConstants.EVENT_CLEAN_UP_CONNECTION);
+        msg.arg1 = tearDown ? 1 : 0;
+        msg.arg2 = 0;
+        msg.obj = apnContext;
+        sendMessage(msg);
+    }
+
+    private void cleanUpConnection(boolean tearDown, ApnContext apnContext) {
+        if (apnContext == null) {
+            if (DBG) log("cleanUpConnection: apn context is null");
+            return;
+        }
+
+        DcAsyncChannel dcac = apnContext.getDcAc();
+        String str = "cleanUpConnection: tearDown=" + tearDown + " reason=" +
+                apnContext.getReason();
+        if (VDBG) log(str + " apnContext=" + apnContext);
+        apnContext.requestLog(str);
+        if (tearDown) {
+            if (apnContext.isDisconnected()) {
+                // The request is tearDown and but ApnContext is not connected.
+                // If apnContext is not enabled anymore, break the linkage to the DCAC/DC.
+                apnContext.setState(DctConstants.State.IDLE);
+                if (!apnContext.isReady()) {
+                    if (dcac != null) {
+                        str = "cleanUpConnection: teardown, disconnected, !ready";
+                        // M: For debug
+                        if (DBG) logi(str + " apnContext=" + apnContext);
+                        apnContext.requestLog(str);
+                        dcac.tearDown(apnContext, "", null);
+                    }
+                    apnContext.setDataConnectionAc(null);
+                }
+            } else {
+                // Connection is still there. Try to clean up.
+                if (dcac != null) {
+                    if (apnContext.getState() != DctConstants.State.DISCONNECTING) {
+                        boolean disconnectAll = false;
+                        if (PhoneConstants.APN_TYPE_DUN.equals(apnContext.getApnType())) {
+                            // CAF_MSIM is this below condition required.
+                            // if (PhoneConstants.APN_TYPE_DUN.equals(PhoneConstants.APN_TYPE_DEFAULT)) {
+                            if (teardownForDun()) {
+                                if (DBG) {
+                                    log("cleanUpConnection: disconnectAll DUN connection");
+                                }
+                                // we need to tear it down - we brought it up just for dun and
+                                // other people are camped on it and now dun is done.  We need
+                                // to stop using it and let the normal apn list get used to find
+                                // connections for the remaining desired connections
+                                disconnectAll = true;
+                            }
+                        }
+                        final int generation = apnContext.getConnectionGeneration();
+                        str = "cleanUpConnection: tearing down" + (disconnectAll ? " all" : "") +
+                                " using gen#" + generation;
+                        // M: For debug
+                        if (DBG) logi(str + "apnContext=" + apnContext);
+                        apnContext.requestLog(str);
+                        Pair<ApnContext, Integer> pair =
+                                new Pair<ApnContext, Integer>(apnContext, generation);
+                        Message msg = obtainMessage(DctConstants.EVENT_DISCONNECT_DONE, pair);
+                        if (disconnectAll) {
+                            apnContext.getDcAc().tearDownAll(apnContext.getReason(), msg);
+                        } else {
+                            apnContext.getDcAc()
+                                .tearDown(apnContext, apnContext.getReason(), msg);
+                        }
+                        apnContext.setState(DctConstants.State.DISCONNECTING);
+                        mDisconnectPendingCount++;
+                    }
+                } else {
+                    // apn is connected but no reference to dcac.
+                    // Should not be happen, but reset the state in case.
+                    apnContext.setState(DctConstants.State.IDLE);
+                    apnContext.requestLog("cleanUpConnection: connected, bug no DCAC");
+                    if (apnContext.isNeedNotify()) {
+                        mPhone.notifyDataConnection(apnContext.getReason(),
+                                apnContext.getApnType());
+                    }
+                }
+            }
+        } else {
+            boolean needNotify = true;
+            //TODO: remove phone count.
+            int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+            if (apnContext.isDisconnected() && phoneCount > 2) {
+                needNotify = false;
+            }
+            // force clean up the data connection.
+            if (dcac != null) dcac.reqReset();
+            apnContext.setState(DctConstants.State.IDLE);
+            if (apnContext.isNeedNotify() && needNotify) {
+                mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+            }
+            apnContext.setDataConnectionAc(null);
+        }
+
+        // Make sure reconnection alarm is cleaned up if there is no ApnContext
+        // associated to the connection.
+        if (dcac != null) {
+            cancelReconnectAlarm(apnContext);
+        }
+        str = "cleanUpConnection: X tearDown=" + tearDown + " reason=" + apnContext.getReason();
+        if (DBG && apnContext.isNeedNotify()) {
+            log(str + " apnContext=" + apnContext + " dcac=" + apnContext.getDcAc());
+        }
+        apnContext.requestLog(str);
+    }
+
+    ApnSetting fetchDunApn() {
+        if (SystemProperties.getBoolean("net.tethering.noprovisioning", false)) {
+            log("fetchDunApn: net.tethering.noprovisioning=true ret: null");
+            return null;
+        }
+        int bearer = mPhone.getServiceState().getRilDataRadioTechnology();
+        ApnSetting retDunSetting = null;
+        String apnData = Settings.Global.getString(mResolver, Settings.Global.TETHER_DUN_APN);
+        List<ApnSetting> dunSettings = ApnSetting.arrayFromString(apnData);
+        IccRecords r = mIccRecords.get();
+        for (ApnSetting dunSetting : dunSettings) {
+            String operator = (r != null) ? r.getOperatorNumeric() : "";
+            if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer)) continue;
+            if (dunSetting.numeric.equals(operator)) {
+                if (dunSetting.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType,
+                            dunSetting.mvnoMatchData)) {
+                        if (VDBG) {
+                            log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
+                        }
+                        return dunSetting;
+                    }
+                } else if (mMvnoMatched == false) {
+                    if (VDBG) log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
+                    return dunSetting;
+                }
+            }
+        }
+
+        Context c = mPhone.getContext();
+        //String[] apnArrayData = c.getResources().getStringArray(R.array.config_tether_apndata);
+        String[] apnArrayData = getDunApnByMccMnc(c);
+        for (String apn : apnArrayData) {
+            ApnSetting dunSetting = ApnSetting.fromString(apn);
+            if (dunSetting != null) {
+                if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer)) continue;
+                if (dunSetting.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType,
+                            dunSetting.mvnoMatchData)) {
+                        if (VDBG) {
+                            log("fetchDunApn: config_tether_apndata mvno dunSetting=" + dunSetting);
+                        }
+                        return dunSetting;
+                    }
+                } else if (mMvnoMatched == false) {
+                    retDunSetting = dunSetting;
+                }
+            }
+        }
+
+        if (VDBG) log("fetchDunApn: config_tether_apndata dunSetting=" + retDunSetting);
+        return retDunSetting;
+    }
+
+    public boolean hasMatchedTetherApnSetting() {
+        ApnSetting matched = fetchDunApn();
+        log("hasMatchedTetherApnSetting: APN=" + matched);
+        return matched != null;
+    }
+
+    // M: Fixed google DUN only one resource problem
+    private String[] getDunApnByMccMnc(Context context){
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+        int mcc = 0;
+        int mnc = 0;
+        if (operator != null && operator.length() > 3) {
+            mcc = Integer.parseInt(operator.substring(0, 3));
+            mnc = Integer.parseInt(operator.substring(3, operator.length()));
+        }
+
+        Resources sysResource = context.getResources();
+        int sysMcc = sysResource.getConfiguration().mcc;
+        int sysMnc = sysResource.getConfiguration().mnc;
+        logd("fetchDunApn: Resource mccmnc=" + sysMcc + "," + sysMnc +
+                "; OperatorNumeric mccmnc=" + mcc + "," + mnc);
+        Resources resource = null;
+        try {
+            Configuration configuration = new Configuration();
+            configuration = context.getResources().getConfiguration();
+            configuration.mcc = mcc;
+            configuration.mnc = mnc;
+            Context resc = context.createConfigurationContext(configuration);
+            resource = resc.getResources();
+        } catch (Exception e) {
+            e.printStackTrace();
+            loge("getResourcesUsingMccMnc fail");
+        }
+
+        // If single sim, configuration numeric == sysNumeric or resourse
+        if ((TelephonyManager.getDefault().getSimCount() == 1) || resource == null) {
+            logd("fetchDunApn: get sysResource mcc=" + sysMcc + ", mnc=" + sysMnc );
+            return sysResource.getStringArray(R.array.config_tether_apndata);
+        } else {
+            logd("fetchDunApn: get resource from mcc=" + mcc + ", mnc=" + mnc);
+            return resource.getStringArray(R.array.config_tether_apndata);
+        }
+    }
+
+    /**
+     * Determine if DUN connection is special and we need to teardown on start/stop
+     */
+    private boolean teardownForDun() {
+        // CDMA always needs to do this the profile id is correct
+        final int rilRat = mPhone.getServiceState().getRilDataRadioTechnology();
+        if (ServiceState.isCdma(rilRat)) return true;
+
+        return (fetchDunApn() != null);
+    }
+
+    /**
+     * Cancels the alarm associated with apnContext.
+     *
+     * @param apnContext on which the alarm should be stopped.
+     */
+    private void cancelReconnectAlarm(ApnContext apnContext) {
+        if (apnContext == null) return;
+
+        PendingIntent intent = apnContext.getReconnectIntent();
+
+        if (intent != null) {
+                AlarmManager am =
+                    (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
+                am.cancel(intent);
+                apnContext.setReconnectIntent(null);
+        }
+    }
+
+    /**
+     * @param types comma delimited list of APN types
+     * @return array of APN types
+     */
+    private String[] parseTypes(String types) {
+        String[] result;
+        // If unset, set to DEFAULT.
+        if (types == null || types.equals("")) {
+            result = new String[1];
+            result[0] = PhoneConstants.APN_TYPE_ALL;
+        } else {
+            result = types.split(",");
+        }
+        return result;
+    }
+
+    boolean isPermanentFail(DcFailCause dcFailCause) {
+        // For OP129
+        if (129 == DataConnectionHelper.getInstance().getSbpIdFromNetworkOperator(
+                mPhone.getPhoneId())) {
+            return (dcFailCause.isPermanentFail()
+                    || dcFailCause == DcFailCause.TCM_ESM_TIMER_TIMEOUT)
+                    && (mAttached.get() == false || dcFailCause != DcFailCause.SIGNAL_LOST);
+        }
+        return (dcFailCause.isPermanentFail() &&
+                isPermanentFailByOp(dcFailCause) &&
+                (mAttached.get() == false || dcFailCause != DcFailCause.SIGNAL_LOST));
+    }
+
+    private ApnSetting makeApnSetting(Cursor cursor) {
+        // M: Inactive timer for Sprint
+        int inactiveTimer = 0;
+        try {
+            inactiveTimer = cursor.getInt(
+                    cursor.getColumnIndexOrThrow(Telephony.Carriers.INACTIVE_TIMER));
+        } catch (IllegalArgumentException e) {
+            log("makeApnSetting: parsing inactive timer failed. " + e);
+        }
+
+        String[] types = parseTypes(
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.TYPE)));
+        ApnSetting apn = new ApnSetting(
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.NUMERIC)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.NAME)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.APN)),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.PROXY))),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PORT)),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSC))),
+                NetworkUtils.trimV4AddrZeros(
+                        cursor.getString(
+                        cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSPROXY))),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MMSPORT)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.USER)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PASSWORD)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.AUTH_TYPE)),
+                types,
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.PROTOCOL)),
+                cursor.getString(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.ROAMING_PROTOCOL)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.CARRIER_ENABLED)) == 1,
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.BEARER)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.BEARER_BITMASK)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.PROFILE_ID)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.MODEM_COGNITIVE)) == 1,
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MAX_CONNS)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(
+                        Telephony.Carriers.WAIT_TIME)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MAX_CONNS_TIME)),
+                cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers.MTU)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MVNO_TYPE)),
+                cursor.getString(cursor.getColumnIndexOrThrow(Telephony.Carriers.MVNO_MATCH_DATA)),
+                inactiveTimer);
+        return apn;
+    }
+
+    private ArrayList<ApnSetting> createApnList(Cursor cursor) {
+        ArrayList<ApnSetting> mnoApns = new ArrayList<ApnSetting>();
+        ArrayList<ApnSetting> mvnoApns = new ArrayList<ApnSetting>();
+        IccRecords r = mIccRecords.get();
+
+        if (cursor.moveToFirst()) {
+            do {
+                ApnSetting apn = makeApnSetting(cursor);
+                if (apn == null) {
+                    continue;
+                }
+
+                if (apn.hasMvnoParams()) {
+                    if (r != null && ApnSetting.mvnoMatches(r, apn.mvnoType, apn.mvnoMatchData)) {
+                        mvnoApns.add(apn);
+                    }
+                } else {
+                    mnoApns.add(apn);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        ArrayList<ApnSetting> result;
+        if (mvnoApns.isEmpty()) {
+            result = mnoApns;
+            mMvnoMatched = false;
+        } else {
+            result = mvnoApns;
+            mMvnoMatched = true;
+        }
+        if (DBG) log("createApnList: X result=" + result);
+        return result;
+    }
+
+    private boolean dataConnectionNotInUse(DcAsyncChannel dcac) {
+        if (DBG) log("dataConnectionNotInUse: check if dcac is inuse dcac=" + dcac);
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.getDcAc() == dcac) {
+                if (DBG) log("dataConnectionNotInUse: in use by apnContext=" + apnContext);
+                return false;
+            }
+        }
+        /* To prevent that DataConnection is going to disconnect
+        /* and we still need its information, not to do teardown here
+        // TODO: Fix retry handling so free DataConnections have empty apnlists.
+        // Probably move retry handling into DataConnections and reduce complexity
+        // of DCT.
+        if (DBG) log("dataConnectionNotInUse: tearDownAll");
+        dcac.tearDownAll("No connection", null);
+        */
+        if (DBG) log("dataConnectionNotInUse: not in use return true");
+        return true;
+    }
+
+    private DcAsyncChannel findFreeDataConnection(String reqApnType, ApnSetting apnSetting) {
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            if (dcac.isInactiveSync() && dataConnectionNotInUse(dcac)) {
+                DcAsyncChannel dcacForTeardown = dcac;
+                if (isSupportThrottlingApn()) {
+                    for (String apn : HIGH_THROUGHPUT_APN) {
+                        if (apnSetting != null && apnSetting.canHandleType(apn)
+                                && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                                && !apnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS)
+                                && dcac != null) {
+                            int id = dcac.getDataConnectionIdSync();
+                            if (id < MIN_ID_HIGH_TROUGHPUT || id > MAX_ID_HIGH_TROUGHPUT) {
+                                dcac = null;
+                            }
+                        }
+                    }
+                    if(Arrays.asList(IMS_APN).indexOf(reqApnType) > -1){
+                        if (apnSetting != null && apnSetting.canHandleType(reqApnType)
+                                && dcac != null) {
+                            int id = dcac.getDataConnectionIdSync();
+                            logi("Data connection's interface is: " + id);
+                            if ((id) == MIN_ID_IMS_TROUGHPUT
+                                    && PhoneConstants.APN_TYPE_IMS.equals(reqApnType) ||
+                                    id == (MAX_ID_IMS_TROUGHPUT - 1)
+                                    && PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)) {
+                                logd("findFreeDataConnection: find connection to handle: "
+                                        + reqApnType);
+                            } else {
+                                dcac = null;
+                            }
+                        }
+                    }
+                    if (!PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                            && !PhoneConstants.APN_TYPE_IMS.equals(reqApnType)
+                            && dcac != null) {
+                        int id = dcac.getDataConnectionIdSync();
+                        if (id >= MIN_ID_IMS_TROUGHPUT && id <= MAX_ID_IMS_TROUGHPUT) {
+                            log("findFreeDataConnection: free dcac for non-IMS APN");
+                            dcac = null;
+                        }
+                    }
+                }
+
+                if (dcac != null) {
+                    log("findFreeDataConnection: found free DataConnection="
+                            + " dcac=" + dcac);
+                    return dcac;
+                }
+            }
+        }
+        log("findFreeDataConnection: NO free DataConnection");
+        return null;
+    }
+
+    private boolean setupData(ApnContext apnContext, int radioTech) {
+        if (DBG) log("setupData: apnContext=" + apnContext);
+        apnContext.requestLog("setupData");
+        ApnSetting apnSetting;
+        DcAsyncChannel dcac = null;
+
+        apnSetting = apnContext.getNextApnSetting();
+
+        if (apnSetting == null) {
+            log("setupData: return for no apn found!");
+            return false;
+        }
+
+        int profileId = apnSetting.profileId;
+        // M: VDF MMS over ePDG @{
+        //if (profileId == 0) {
+            profileId = getApnProfileID(apnContext.getApnType());
+        //}
+        /// @}
+        // On CDMA, if we're explicitly asking for DUN, we need have
+        // a dun-profiled connection so we can't share an existing one
+        // On GSM/LTE we can share existing apn connections provided they support
+        // this type.
+        if (apnContext.getApnType() != PhoneConstants.APN_TYPE_DUN ||
+                teardownForDun() == false) {
+            dcac = checkForCompatibleConnectedApnContext(apnContext);
+            if (dcac != null) {
+                // Get the dcacApnSetting for the connection we want to share.
+                ApnSetting dcacApnSetting = dcac.getApnSettingSync();
+                if (dcacApnSetting != null) {
+                    // Setting is good, so use it.
+                    apnSetting = dcacApnSetting;
+                }
+            }
+        }
+        if (dcac == null) {
+            if (isOnlySingleDcAllowed(radioTech)) {
+                if (isHigherPriorityApnContextActive(apnContext)) {
+                    if (DBG) {
+                        log("setupData: Higher priority ApnContext active.  Ignoring call");
+                    }
+                    return false;
+                }
+
+                // Only lower priority calls left.  Disconnect them all in this single PDP case
+                // so that we can bring up the requested higher priority call (once we receive
+                // response for deactivate request for the calls we are about to disconnect
+                if (cleanUpAllConnections(true, Phone.REASON_SINGLE_PDN_ARBITRATION)) {
+                    // If any call actually requested to be disconnected, means we can't
+                    // bring up this connection yet as we need to wait for those data calls
+                    // to be disconnected.
+                    if (DBG) log("setupData: Some calls are disconnecting first.  Wait and retry");
+                    return false;
+                }
+
+                // No other calls are active, so proceed
+                if (DBG) log("setupData: Single pdp. Continue setting up data call.");
+            }
+
+            /** M: throttling/high throughput APN start **/
+            if (!isSupportThrottlingApn() && !isOnlySingleDcAllowed(radioTech)) {
+                boolean isHighThroughputApn = false;
+                for (String apn : HIGH_THROUGHPUT_APN) {
+                    if (apnSetting.canHandleType(apn)) {
+                        isHighThroughputApn = true;
+                        break;
+                    }
+                }
+
+                if (!isHighThroughputApn) {
+                    boolean lastDcAlreadyInUse = false;
+                    for (DcAsyncChannel asyncChannel : mDataConnectionAcHashMap.values()) {
+                        if (asyncChannel.getDataConnectionIdSync() == getPdpConnectionPoolSize()) {
+                            if (asyncChannel.isInactiveSync() &&
+                                    dataConnectionNotInUse(asyncChannel)) {
+                                logd("setupData: find the last dc for non-high-throughput apn, " +
+                                        "execute tearDownAll to the dc");
+                                dcac = asyncChannel;
+                                asyncChannel.tearDownAll("No connection", null);
+                            } else {
+                                log("setupData: the last data connection is already in-use");
+                                lastDcAlreadyInUse = true;
+                            }
+                        }
+                    }
+                    if (dcac == null && !lastDcAlreadyInUse) {
+                        DataConnection conn = DataConnection.makeDataConnection(mPhone,
+                                getPdpConnectionPoolSize(), this, mDcTesterFailBringUpAll, mDcc);
+                        mDataConnections.put(getPdpConnectionPoolSize(), conn);
+                        dcac = new DcAsyncChannel(conn, LOG_TAG);
+                        int status = dcac.fullyConnectSync(mPhone.getContext(),
+                                this, conn.getHandler());
+                        if (status == AsyncChannel.STATUS_SUCCESSFUL) {
+                            logd("setupData: create the last data connection");
+                            mDataConnectionAcHashMap.put(dcac.getDataConnectionIdSync(), dcac);
+                        } else {
+                            loge("setupData: createDataConnection (last) could not connect to dcac="
+                                    + dcac + " status=" + status);
+                        }
+                    }
+                }
+            }
+            /** M: throttling/high throughput APN end start **/
+
+            if (dcac == null) {
+                log("setupData: No ready DataConnection found!");
+                // TODO: When allocating you are mapping type to id. If more than 1 free,
+                // then could findFreeDataConnection get the wrong one??
+                dcac = findFreeDataConnection(apnContext.getApnType(), apnSetting);
+
+            }
+
+            // M: Reuse DCAC if there is remain DCAC for the ApnContext.
+            if (dcac == null) {
+                if (apnContext.getApnType() == PhoneConstants.APN_TYPE_DEFAULT
+                        || apnContext.getApnType() == PhoneConstants.APN_TYPE_MMS) {
+                    DcAsyncChannel prevDcac = apnContext.getDcAc();
+                    // There is already an inactive dcac, try to reuse it.
+                    if (prevDcac != null && prevDcac.isInactiveSync()) {
+                        dcac = prevDcac;
+                        ApnSetting dcacApnSetting = dcac.getApnSettingSync();
+                        log("setupData: reuse previous DCAC: dcacApnSetting = "
+                                + dcacApnSetting);
+                        if (dcacApnSetting != null) {
+                            // Setting is good, so use it.
+                            apnSetting = dcacApnSetting;
+                        }
+                    }
+                }
+            }
+
+            if (dcac == null) {
+                dcac = createDataConnection(apnContext.getApnType(), apnSetting);
+            }
+
+            if (dcac == null) {
+                if (DBG) log("setupData: No free DataConnection and couldn't create one, WEIRD");
+                return false;
+            }
+        }
+        final int generation = apnContext.incAndGetConnectionGeneration();
+        if (DBG) {
+            log("setupData: dcac=" + dcac + " apnSetting=" + apnSetting + " gen#=" + generation);
+        }
+
+        apnContext.setDataConnectionAc(dcac);
+        apnContext.setApnSetting(apnSetting);
+        apnContext.setState(DctConstants.State.CONNECTING);
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+        Message msg = obtainMessage();
+        msg.what = DctConstants.EVENT_DATA_SETUP_COMPLETE;
+        msg.obj = new Pair<ApnContext, Integer>(apnContext, generation);
+        dcac.bringUp(apnContext, profileId, radioTech, msg, generation);
+
+        if (DBG) log("setupData: initing!");
+        return true;
+    }
+
+    // M: IA-change attach APN
+    private void onMdChangedAttachApn(AsyncResult ar) {
+        logv("onMdChangedAttachApn");
+        int[] ints = (int[]) ar.result;
+        int apnId = ints[0];
+
+        if (apnId != APN_CLASS_1 && apnId != APN_CLASS_3) {
+            logw("onMdChangedAttachApn: Not handle APN Class:" + apnId);
+            return;
+        }
+
+        // Save MD requested APN class in property, for cases that DCT object disposed.
+        int phoneId = mPhone.getPhoneId();
+        if (SubscriptionManager.isValidPhoneId(phoneId)) {
+            String iccId = SystemProperties.get(PROPERTY_ICCID[phoneId], "");
+            SystemProperties.set(PROP_APN_CLASS_ICCID + phoneId, iccId);
+            SystemProperties.set(PROP_APN_CLASS + phoneId, String.valueOf(apnId));
+            log("onMdChangedAttachApn, set " + iccId + ", " + apnId);
+        }
+
+        updateMdChangedAttachApn(apnId);
+
+        if (mMdChangedAttachApn != null) {
+            setInitialAttachApn();
+        } else {
+            // Before createAllApnList, the mMdChangedAttachApn will be null
+            // after updateMdChangedAttachApn(), it will be set in
+            // onRecordsLoaded->setInitialAttachApn()
+            logw("onMdChangedAttachApn: MdChangedAttachApn is null, not found APN");
+        }
+    }
+
+    // M: IA-change attach APN
+    private void updateMdChangedAttachApn(int apnId) {
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apnId == APN_CLASS_1 &&
+                        ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IMS)) {
+                    mMdChangedAttachApn = apn;
+                    log("updateMdChangedAttachApn: MdChangedAttachApn=" + apn);
+                    break;
+                } else if (apnId == APN_CLASS_3 &&
+                        ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_DEFAULT)) {
+                    mMdChangedAttachApn = apn;
+                    log("updateMdChangedAttachApn: MdChangedAttachApn=" + apn);
+                    break;
+                }
+            }
+        }
+    }
+
+    // M: IA-change attach APN
+    private boolean isMdChangedAttachApnEnabled() {
+        if (mMdChangedAttachApn != null && mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (TextUtils.equals(mMdChangedAttachApn.apn, apn.apn)) {
+                    log("isMdChangedAttachApnEnabled: " + apn);
+                    return apn.carrierEnabled;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void setInitialAttachApn() {
+        if (hasOperatorIaCapability() == false) {
+            // MD not support OP IA, so need to handle legacy platform logics.
+            log("setInitialApn: MD Not support OP IA, do setInitialAttachApnExt");
+            setInitialAttachApnExt();
+            return;
+        }
+
+        ApnSetting iaApnSetting = null;
+        ApnSetting defaultApnSetting = null;
+        ApnSetting firstApnSetting = null;
+
+        log("setInitialApn: E mPreferredApn=" + mPreferredApn);
+
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            firstApnSetting = mAllApnSettings.get(0);
+            log("setInitialApn: firstApnSetting=" + firstApnSetting);
+
+            // Search for Initial APN setting and the first apn that can handle default
+            for (ApnSetting apn : mAllApnSettings) {
+                // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) &&
+                        apn.carrierEnabled) {
+                    // The Initial Attach APN is highest priority so use it if there is one
+                    log("setInitialApn: iaApnSetting=" + apn);
+                    iaApnSetting = apn;
+                    break;
+                } else if ((defaultApnSetting == null)
+                        && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
+                    // Use the first default apn if no better choice
+                    log("setInitialApn: defaultApnSetting=" + apn);
+                    defaultApnSetting = apn;
+                }
+            }
+        }
+
+        // The priority of apn candidates from highest to lowest is:
+        //   1) APN_TYPE_IA (Initial Attach)
+        //   2) mPreferredApn, i.e. the current preferred apn
+        //   3) The first apn that than handle APN_TYPE_DEFAULT
+        //   4) The first APN we can find.
+
+        ApnSetting initialAttachApnSetting = null;
+        if (iaApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using iaApnSetting");
+            initialAttachApnSetting = iaApnSetting;
+        } else if (mPreferredApn != null) {
+            if (DBG) log("setInitialAttachApn: using mPreferredApn");
+            initialAttachApnSetting = mPreferredApn;
+        } else if (defaultApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using defaultApnSetting");
+            initialAttachApnSetting = defaultApnSetting;
+        } else if (firstApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using firstApnSetting");
+            initialAttachApnSetting = firstApnSetting;
+        }
+
+        if (initialAttachApnSetting == null) {
+            if (DBG) log("setInitialAttachApn: X There in no available apn");
+        } else {
+            if (DBG) log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
+
+            mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn,
+                    initialAttachApnSetting.protocol, initialAttachApnSetting.authType,
+                    initialAttachApnSetting.user, initialAttachApnSetting.password, null);
+        }
+    }
+
+    private void setInitialAttachApnExt() {
+        // M: JPN IA Start
+        boolean needsResumeModem = false;
+        String currentMcc;
+        // M: JPN IA End
+
+        boolean isIaApn = false;
+        ApnSetting previousAttachApn = mInitialAttachApnSetting;
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (operatorNumeric == null || operatorNumeric.length() == 0) {
+            log("setInitialApn: but no operator numeric");
+            return;
+        } else {
+            // M: JPN IA Start
+            synchronized (mNeedsResumeModemLock) {
+                if (mNeedsResumeModem) {
+                    mNeedsResumeModem = false;
+                    needsResumeModem = true;
+                }
+            }
+            currentMcc = operatorNumeric.substring(0, 3);
+            log("setInitialApn: currentMcc = " + currentMcc + ", needsResumeModem = "
+                    + needsResumeModem);
+            // M: JPN IA End
+        }
+
+        String[] dualApnPlmnList = null;
+        if (MTK_DUAL_APN_SUPPORT == true) {
+            dualApnPlmnList = mPhone.getContext().getResources()
+                        .getStringArray(com.mediatek.internal.R.array.dtag_dual_apn_plmn_list);
+        }
+
+        log("setInitialAttachApnExt: current attach Apn [" + mInitialAttachApnSetting + "]");
+
+        ApnSetting iaApnSetting = null;
+        ApnSetting defaultApnSetting = null;
+        ApnSetting firstApnSetting = null;
+        ApnSetting manualChangedAttachApn = null;
+
+        log("setInitialApn: E mPreferredApn=" + mPreferredApn);
+
+        // M: change attach APN for MD changed APN and handover to WIFI
+        if (mIsImsHandover || MTK_IMS_TESTMODE_SUPPORT) {
+            // In those case should change attach APN to  class3 APN (VZWINTERNET)
+            // The use of getClassTypeApn will return the ApnSetting of specify class APN.
+            // Need to make sure the class number is valid (e.g. class1~4) for OP12 APN.
+            manualChangedAttachApn = getClassTypeApn(APN_CLASS_3);
+
+            if (manualChangedAttachApn != null) {
+                log("setInitialAttachApn: manualChangedAttachApn = " + manualChangedAttachApn);
+            }
+        }
+
+        if (mMdChangedAttachApn == null) {
+            // Restore MD requested APN class from property, for cases that DCT object disposed.
+            // Don't restore if card changed.
+            int phoneId = mPhone.getPhoneId();
+            if (SubscriptionManager.isValidPhoneId(phoneId)) {
+                int apnClass = SystemProperties.getInt(PROP_APN_CLASS + phoneId, -1);
+                if (apnClass >= 0) {
+                    String iccId = SystemProperties.get(PROPERTY_ICCID[phoneId], "");
+                    String apnClassIccId = SystemProperties.get(PROP_APN_CLASS_ICCID + phoneId, "");
+                    log("setInitialAttachApn: " + iccId + " , " + apnClassIccId + ", " + apnClass);
+                    if (TextUtils.equals(iccId, apnClassIccId)) {
+                        updateMdChangedAttachApn(apnClass);
+                    } else {
+                        SystemProperties.set(PROP_APN_CLASS_ICCID + phoneId, "");
+                        SystemProperties.set(PROP_APN_CLASS + phoneId, "");
+                    }
+                }
+            }
+        }
+
+        // M: IA-change attach APN
+        // VZW required to detach when disabling VZWIMS. So when VZWIMS is MD changed APN
+        // but disabling VZWIMS, follow AOSP logic to change IA.
+        ApnSetting mdChangedAttachApn = mMdChangedAttachApn;
+        if (mMdChangedAttachApn != null && getClassType(mMdChangedAttachApn) == APN_CLASS_1
+                && !isMdChangedAttachApnEnabled()) {
+            mdChangedAttachApn = null;
+        }
+
+        if (mdChangedAttachApn == null && manualChangedAttachApn == null &&
+                mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            firstApnSetting = mAllApnSettings.get(0);
+            log("setInitialApn: firstApnSetting=" + firstApnSetting);
+
+            // Search for Initial APN setting and the first apn that can handle default
+            for (ApnSetting apn : mAllApnSettings) {
+                // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) &&
+                        apn.carrierEnabled && checkIfDomesticInitialAttachApn(currentMcc)) {
+                    // The Initial Attach APN is highest priority so use it if there is one
+                    log("setInitialApn: iaApnSetting=" + apn);
+                    iaApnSetting = apn;
+                    if (ArrayUtils.contains(PLMN_EMPTY_APN_PCSCF_SET, operatorNumeric)) {
+                        isIaApn = true;
+                    }
+                    break;
+                } else if ((defaultApnSetting == null)
+                        && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
+                    // Use the first default apn if no better choice
+                    log("setInitialApn: defaultApnSetting=" + apn);
+                    defaultApnSetting = apn;
+                }
+            }
+        }
+        // M: end of change attach APN
+
+        // The priority of apn candidates from highest to lowest is:
+        //   1) APN_TYPE_IA (Initial Attach)
+        //   2) mPreferredApn, i.e. the current preferred apn
+        //   3) The first apn that than handle APN_TYPE_DEFAULT
+        //   4) The first APN we can find.
+
+        mInitialAttachApnSetting = null;
+        // M: change attach APN for MD changed APN and handover to WIFI
+        if (manualChangedAttachApn != null) {
+            log("setInitialAttachApn: using manualChangedAttachApn");
+            mInitialAttachApnSetting = manualChangedAttachApn;
+        } else if (mdChangedAttachApn != null) {
+            log("setInitialAttachApn: using mMdChangedAttachApn");
+            mInitialAttachApnSetting = mdChangedAttachApn;
+        } else if (iaApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using iaApnSetting");
+            mInitialAttachApnSetting = iaApnSetting;
+        } else if (mPreferredApn != null) {
+            if (DBG) log("setInitialAttachApn: using mPreferredApn");
+            mInitialAttachApnSetting = mPreferredApn;
+        } else if (defaultApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using defaultApnSetting");
+            mInitialAttachApnSetting = defaultApnSetting;
+        } else if (firstApnSetting != null) {
+            if (DBG) log("setInitialAttachApn: using firstApnSetting");
+            mInitialAttachApnSetting = firstApnSetting;
+        }
+
+        if (mInitialAttachApnSetting == null) {
+            if (DBG) log("setInitialAttachApn: X There in no available apn, use empty");
+            IaExtendParam param = new IaExtendParam(operatorNumeric, dualApnPlmnList,
+                    RILConstants.SETUP_DATA_PROTOCOL_IPV4V6);
+            mPhone.mCi.setInitialAttachApn("", RILConstants.SETUP_DATA_PROTOCOL_IPV4V6,
+                    -1, "", "", (Object) param, null);
+        } else {
+            if (DBG) log("setInitialAttachApn: X selected Apn=" + mInitialAttachApnSetting);
+            String iaApn = mInitialAttachApnSetting.apn;
+            if (isIaApn) {
+                if (DBG) log("setInitialAttachApn: ESM flag false, change IA APN to empty");
+                iaApn = "";
+            }
+
+            Message msg = null;
+            // M: JPN IA Start
+            if (needsResumeModem) {
+                if (DBG) log("setInitialAttachApn: DCM IA support");
+                msg = obtainMessage(DctConstants.EVENT_SET_RESUME);
+            }
+            // M: JPN IA End
+            String iaApnProtocol = mInitialAttachApnSetting.protocol;
+            if (isOp18Sim()) {
+                if (mPhone.getServiceState().getDataRoaming()) {
+                    iaApnProtocol = mInitialAttachApnSetting.roamingProtocol;
+                }
+            }
+            IaExtendParam param = new IaExtendParam(operatorNumeric,
+                    mInitialAttachApnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS),
+                    dualApnPlmnList, mInitialAttachApnSetting.roamingProtocol);
+
+            mPhone.mCi.setInitialAttachApn(iaApn, iaApnProtocol,
+                    mInitialAttachApnSetting.authType, mInitialAttachApnSetting.user,
+                    mInitialAttachApnSetting.password, (Object) param, msg);
+        }
+        if (DBG) log("setInitialAttachApn: new attach Apn [" + mInitialAttachApnSetting + "]");
+    }
+
+    /**
+     * Handles changes to the APN database.
+     */
+    private void onApnChanged() {
+        if (mPhone instanceof GsmCdmaPhone) {
+            // The "current" may no longer be valid.  MMS depends on this to send properly. TBD
+            ((GsmCdmaPhone)mPhone).updateCurrentCarrierInProvider();
+        }
+
+        /** M: onApnChanged optimization
+         *  keep current settings before create new apn list
+         */
+        ArrayList<ApnSetting> prevAllApns = mAllApnSettings;
+        ApnSetting prevPreferredApn = mPreferredApn;
+        if (DBG) log("onApnChanged: createAllApnList and set initial attach APN");
+        createAllApnList();
+
+        ApnSetting previousAttachApn = mInitialAttachApnSetting;
+
+        // check if EM force update APN
+        if (SystemProperties.getInt(PROPERTY_FORCE_APN_CHANGE, 0) == 0) {
+            /// M: we will do nothing if the apn is not changed or only the APN name
+            /// is changed. Generally speaking, if PreferredApn and AttachApns are
+            /// both not changed, it will be considered that APN not changed. But if both
+            /// of them are not changed but any of them is null, then we double confirm it
+            /// by compare preAllApns and curAllApns.
+            /// VZW test case [SuppSig][02.17]: change APN name should trigger reattach
+            boolean ignoreName = !VZW_FEATURE;
+
+            final String prevPreferredApnString = (prevPreferredApn == null) ?
+                    "" : prevPreferredApn.toStringIgnoreName(ignoreName);
+            final String curPreferredApnString = (mPreferredApn == null) ?
+                    "" : mPreferredApn.toStringIgnoreName(ignoreName);
+            final String prevAttachApnSettingString = (previousAttachApn == null) ?
+                    "" : previousAttachApn.toStringIgnoreName(ignoreName);
+            final String curAttachApnSettingString = (mInitialAttachApnSetting == null) ?
+                    "" : mInitialAttachApnSetting.toStringIgnoreName(ignoreName);
+            if (TextUtils.equals(prevPreferredApnString, curPreferredApnString)
+                    && isApnSettingExist(previousAttachApn)) {
+                // If preferred APN or preferred initial APN is null, we need to check all APNs.
+                if ((prevPreferredApn == null || previousAttachApn == null) && !TextUtils.equals(
+                        ApnSetting.toStringIgnoreNameForList(prevAllApns, ignoreName),
+                        ApnSetting.toStringIgnoreNameForList(mAllApnSettings, ignoreName))) {
+                    log("onApnChanged: all APN setting changed.");
+                } else {
+                    if (MTK_IMS_SUPPORT) {
+                        if (isIMSApnSettingChanged(prevAllApns, mAllApnSettings)) {
+                            sendOnApnChangedDone(true);
+                            log("onApnChanged: IMS apn setting changed!!");
+                            return;
+                        }
+                    }
+                    log("onApnChanged: not changed");
+                    return;
+                }
+            }
+        }
+
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+        if (operator != null && operator.length() > 0) {
+            // M: update initial attach APN only in the case of valid numeric
+            setInitialAttachApn();
+        } else {
+            log("onApnChanged: but no operator numeric");
+        }
+
+        logd("onApnChanged: cleanUpAllConnections and setup connectable APN");
+        sendOnApnChangedDone(false);
+    }
+
+    private void sendOnApnChangedDone(boolean bImsApnChanged) {
+        Message msg = obtainMessage(DctConstants.EVENT_APN_CHANGED_DONE);
+        msg.arg1 = bImsApnChanged ? 1 : 0;
+        sendMessage(msg);
+    }
+
+    private void onApnChangedDone() {
+        //Fixed:[ALPS01670132] Data iocn cannot shows and data service cannot work
+        //after change default APN some times.
+        DctConstants.State overallState = getOverallState();
+        boolean isDisconnected = (overallState == DctConstants.State.IDLE ||
+                overallState == DctConstants.State.FAILED);
+
+        cleanUpConnectionsOnUpdatedApns(!isDisconnected);
+
+        logd("onApnChanged: phone.getsubId=" + mPhone.getSubId()
+                + "getDefaultDataSubscriptionId()" +
+                + SubscriptionManager.getDefaultDataSubscriptionId());
+        // FIXME: See bug 17426028 maybe no conditional is needed.
+        if (mPhone.getSubId() == SubscriptionManager.getDefaultDataSubscriptionId()) {
+            setupDataOnConnectableApns(Phone.REASON_APN_CHANGED);
+        }
+    }
+
+    /**
+     * @param cid Connection id provided from RIL.
+     * @return DataConnectionAc associated with specified cid.
+     */
+    private DcAsyncChannel findDataConnectionAcByCid(int cid) {
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+            if (dcac.getCidSync() == cid) {
+                return dcac;
+            }
+        }
+        return null;
+    }
+
+    // TODO: For multiple Active APNs not exactly sure how to do this.
+    private void gotoIdleAndNotifyDataConnection(String reason) {
+        if (DBG) log("gotoIdleAndNotifyDataConnection: reason=" + reason);
+        notifyDataConnection(reason);
+    }
+
+    /**
+     * "Active" here means ApnContext isEnabled() and not in FAILED state
+     * @param apnContext to compare with
+     * @return true if higher priority active apn found
+     */
+    private boolean isHigherPriorityApnContextActive(ApnContext apnContext) {
+        for (ApnContext otherContext : mPrioritySortedApnContexts) {
+            if (apnContext.getApnType().equalsIgnoreCase(otherContext.getApnType())) return false;
+            if (otherContext.isEnabled() && otherContext.getState() != DctConstants.State.FAILED) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Reports if we support multiple connections or not.
+     * This is a combination of factors, based on carrier and RAT.
+     * @param rilRadioTech the RIL Radio Tech currently in use
+     * @return true if only single DataConnection is allowed
+     */
+    private boolean isOnlySingleDcAllowed(int rilRadioTech) {
+        int[] singleDcRats = mPhone.getContext().getResources().getIntArray(
+                com.android.internal.R.array.config_onlySingleDcAllowed);
+        boolean onlySingleDcAllowed = false;
+
+        // MTK START [ALPS01540105]
+        if (!BSP_PACKAGE && mTelephonyExt != null) {
+            try {
+                onlySingleDcAllowed = mTelephonyExt.isOnlySingleDcAllowed(); // default is false
+                if (onlySingleDcAllowed == true) {
+                    log("isOnlySingleDcAllowed: " + onlySingleDcAllowed);
+                    return true;
+                }
+            } catch (Exception ex) {
+                loge("Fail to create or use plug-in");
+                ex.printStackTrace();
+            }
+        }
+        // MTK END [ALPS01540105]
+
+        if (Build.IS_DEBUGGABLE &&
+                SystemProperties.getBoolean("persist.telephony.test.singleDc", false)) {
+            onlySingleDcAllowed = true;
+        }
+        if (singleDcRats != null) {
+            for (int i=0; i < singleDcRats.length && onlySingleDcAllowed == false; i++) {
+                if (rilRadioTech == singleDcRats[i]) onlySingleDcAllowed = true;
+            }
+        }
+
+        if (DBG) log("isOnlySingleDcAllowed(" + rilRadioTech + "): " + onlySingleDcAllowed);
+        return onlySingleDcAllowed;
+    }
+
+    void sendRestartRadio() {
+        if (DBG)log("sendRestartRadio:");
+        Message msg = obtainMessage(DctConstants.EVENT_RESTART_RADIO);
+        sendMessage(msg);
+    }
+
+    private void restartRadio() {
+        if (DBG) log("restartRadio: ************TURN OFF RADIO**************");
+        cleanUpAllConnections(true, Phone.REASON_RADIO_TURNED_OFF);
+        mPhone.getServiceStateTracker().powerOffRadioSafely(this);
+        /* Note: no need to call setRadioPower(true).  Assuming the desired
+         * radio power state is still ON (as tracked by ServiceStateTracker),
+         * ServiceStateTracker will call setRadioPower when it receives the
+         * RADIO_STATE_CHANGED notification for the power off.  And if the
+         * desired power state has changed in the interim, we don't want to
+         * override it with an unconditional power on.
+         */
+
+        int reset = Integer.parseInt(SystemProperties.get("net.ppp.reset-by-timeout", "0"));
+        SystemProperties.set("net.ppp.reset-by-timeout", String.valueOf(reset + 1));
+    }
+
+    /**
+     * Return true if data connection need to be setup after disconnected due to
+     * reason.
+     *
+     * @param apnContext APN context
+     * @return true if try setup data connection is need for this reason
+     */
+    private boolean retryAfterDisconnected(ApnContext apnContext) {
+        boolean retry = true;
+        String reason = apnContext.getReason();
+
+        if ( Phone.REASON_RADIO_TURNED_OFF.equals(reason) ||
+                Phone.REASON_FDN_ENABLED.equals(reason) ||
+                (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())
+                 && isHigherPriorityApnContextActive(apnContext))) {
+            retry = false;
+        }
+        return retry;
+    }
+
+    private void startAlarmForReconnect(long delay, ApnContext apnContext) {
+        String apnType = apnContext.getApnType();
+
+        Intent intent = new Intent(INTENT_RECONNECT_ALARM + "." + apnType);
+        intent.putExtra(INTENT_RECONNECT_ALARM_EXTRA_REASON, apnContext.getReason());
+        intent.putExtra(INTENT_RECONNECT_ALARM_EXTRA_TYPE, apnType);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+
+        // Get current sub id.
+        //int subId = SubscriptionManager.getDefaultDataSubscriptionId();
+
+        /**
+         * Fix Google default issue.
+         * Enable retry mechanism if the current SIM is non default data SIM.
+         * Ex, SIM1 is default data SIM, use SIM2 to send MMS, if setup data
+         * fail, need enable retry mechanism to setup MMS connect.
+         */
+        int subId = mPhone.getSubId();
+        intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
+
+        if (DBG) {
+            log("startAlarmForReconnect: delay=" + delay + " action=" + intent.getAction()
+                    + " apn=" + apnContext + " subId = " + subId);
+        }
+
+        PendingIntent alarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0,
+                                        intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        apnContext.setReconnectIntent(alarmIntent);
+
+        // Use the exact timer instead of the inexact one to provide better user experience.
+        // In some extreme cases, we saw the retry was delayed for few minutes.
+        // Note that if the stated trigger time is in the past, the alarm will be triggered
+        // immediately.
+        mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + delay, alarmIntent);
+    }
+
+    private void notifyNoData(DcFailCause lastFailCauseCode,
+                              ApnContext apnContext) {
+        if (DBG) log( "notifyNoData: type=" + apnContext.getApnType());
+        if (isPermanentFail(lastFailCauseCode)
+            && (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_DEFAULT))) {
+            mPhone.notifyDataConnectionFailed(apnContext.getReason(), apnContext.getApnType());
+        }
+    }
+
+    public boolean getAutoAttachOnCreation() {
+        return mAutoAttachOnCreation.get();
+    }
+
+    private void onRecordsLoadedOrSubIdChanged() {
+        if (DBG) log("onRecordsLoadedOrSubIdChanged: createAllApnList");
+        mAutoAttachOnCreationConfig = mPhone.getContext().getResources()
+                .getBoolean(com.android.internal.R.bool.config_auto_attach_data_on_creation);
+
+        // M: cc33.
+        if (MTK_CC33_SUPPORT) {
+            mPhone.mCi.setRemoveRestrictEutranMode(true, null);
+        }
+        // M: Sync data setting to modem
+        syncDataSettingsToMd(new int[]{ getDataEnabled() ? 1 : 0,
+                                        getDataOnRoamingEnabled() ? 1 : 0,
+                                        SKIP_DATA_SETTINGS});
+
+        int defaultSubId = SubscriptionController.getInstance().getDefaultDataSubId();
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+        dcHelper.syncDefaultDataSubId(defaultSubId);
+
+        createAllApnList();
+        setInitialAttachApn();
+        if (mPhone.mCi.getRadioState().isOn()) {
+            if (DBG) log("onRecordsLoadedOrSubIdChanged: notifying data availability");
+            notifyOffApnsOfAvailability(Phone.REASON_SIM_LOADED);
+        }
+
+        setupDataOnConnectableApns(Phone.REASON_SIM_LOADED);
+    }
+
+    //MTK START: FDN Support
+    private boolean isFdnEnableSupport() {
+        boolean isFdnEnableSupport = false;
+        if (!BSP_PACKAGE && mGsmDctExt != null) {
+            isFdnEnableSupport = mGsmDctExt.isFdnEnableSupport();
+        }
+        return isFdnEnableSupport;
+    }
+
+    private boolean isFdnEnabled() {
+        boolean bIsFdnEnabled = false;
+        if (isFdnEnableSupport()) {
+            bIsFdnEnabled = getFdnStatus();
+        }
+        return bIsFdnEnabled;
+    }
+
+    private boolean getFdnStatus() {
+        boolean bIsFdnEnabled = false;
+        ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+
+        if (telephonyEx != null) {
+            try {
+                bIsFdnEnabled = telephonyEx.isFdnEnabled(mPhone.getSubId());
+            } catch (RemoteException ex) {
+                ex.printStackTrace();
+            }
+        } else {
+            loge("getFdnStatus get telephonyEx failed!!");
+        }
+
+        return bIsFdnEnabled;
+    }
+
+    private void onFdnChanged() {
+        if (isFdnEnableSupport()) {
+            logd("onFdnChanged");
+            if (getFdnStatus()) {
+                logd("fdn enabled, cleanUpAllConnections!");
+                cleanUpAllConnections(true, Phone.REASON_FDN_ENABLED);
+            } else {
+                logd("fdn disabled, setupDataOnConnectableApns!");
+                setupDataOnConnectableApns(Phone.REASON_FDN_DISABLED);
+            }
+        } else {
+            logd("not support fdn enabled, skip onFdnChanged");
+        }
+    }
+    //MTK END: Support FDN
+
+    public void setApnsEnabledByCarrier(boolean enabled) {
+        Message msg = obtainMessage(DctConstants.EVENT_SET_CARRIER_DATA_ENABLED);
+        msg.arg1 = (enabled ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    /**
+     * Action set from carrier signalling broadcast receivers to enable/disable metered apns.
+     */
+    private void onSetCarrierDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            if (enabled != mDataEnabledSettings.isCarrierDataEnabled()) {
+                if (DBG) {
+                    log("carrier Action: set metered apns enabled: " + enabled);
+                }
+
+                // Disable/enable all metered apns
+                mDataEnabledSettings.setCarrierDataEnabled(enabled);
+
+                if (!enabled) {
+                    // Send otasp_sim_unprovisioned so that SuW is able to proceed and notify users
+                    mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED);
+                    // Tear down all metered apns
+                    cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
+                } else {
+                    teardownRestrictedMeteredConnections();
+                    setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED);
+                }
+            }
+        }
+    }
+
+    /**
+     * Action set from carrier signalling broadcast receivers to enable/disable radio
+     */
+    public void carrierActionSetRadioEnabled(boolean enabled) {
+        if (DBG) {
+            log("carrier Action: set radio enabled: " + enabled);
+        }
+        final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+        sst.setRadioPowerFromCarrier(enabled);
+    }
+
+    private void onSimNotReady() {
+        if (DBG) log("onSimNotReady");
+
+        cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY);
+        if (mAllApnSettings != null) {
+            mAllApnSettings.clear();
+        }
+        mAutoAttachOnCreationConfig = false;
+    }
+
+    private void onSetDependencyMet(String apnType, boolean met) {
+        // don't allow users to tweak hipri to work around default dependency not met
+        if (PhoneConstants.APN_TYPE_HIPRI.equals(apnType)) return;
+
+        ApnContext apnContext = mApnContexts.get(apnType);
+        if (apnContext == null) {
+            loge("onSetDependencyMet: ApnContext not found in onSetDependencyMet(" +
+                    apnType + ", " + met + ")");
+            return;
+        }
+        applyNewState(apnContext, apnContext.isEnabled(), met);
+        if (PhoneConstants.APN_TYPE_DEFAULT.equals(apnType)) {
+            // tie actions on default to similar actions on HIPRI regarding dependencyMet
+            apnContext = mApnContexts.get(PhoneConstants.APN_TYPE_HIPRI);
+            if (apnContext != null) applyNewState(apnContext, apnContext.isEnabled(), met);
+        }
+    }
+
+    public void setPolicyDataEnabled(boolean enabled) {
+        if (DBG) log("setPolicyDataEnabled: " + enabled);
+        Message msg = obtainMessage(DctConstants.CMD_SET_POLICY_DATA_ENABLE);
+        msg.arg1 = (enabled ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    private void onSetPolicyDataEnabled(boolean enabled) {
+        synchronized (mDataEnabledSettings) {
+            final boolean prevEnabled = getAnyDataEnabled();
+            if (mDataEnabledSettings.isPolicyDataEnabled() != enabled) {
+                mDataEnabledSettings.setPolicyDataEnabled(enabled);
+                // TODO: We should register for DataEnabledSetting's data enabled/disabled event and
+                // handle the rest from there.
+                if (prevEnabled != getAnyDataEnabled()) {
+                    if (!prevEnabled) {
+                        teardownRestrictedMeteredConnections();
+                        onTrySetupData(Phone.REASON_DATA_ENABLED);
+                    } else {
+                        onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                    }
+                }
+            }
+        }
+    }
+
+    private void applyNewState(ApnContext apnContext, boolean enabled, boolean met) {
+        boolean cleanup = false;
+        boolean trySetup = false;
+        String str ="applyNewState(" + apnContext.getApnType() + ", " + enabled +
+                "(" + apnContext.isEnabled() + "), " + met + "(" +
+                apnContext.getDependencyMet() +"))";
+        if (DBG) log(str);
+        apnContext.requestLog(str);
+
+        if (apnContext.isReady()) {
+            cleanup = true;
+            if (enabled && met) {
+                DctConstants.State state = apnContext.getState();
+                switch(state) {
+                    case CONNECTING:
+                    case SCANNING:
+                    case CONNECTED:
+                    case DISCONNECTING:
+                        // We're "READY" and active so just return
+                        if (DBG) log("applyNewState: 'ready' so return");
+                        apnContext.requestLog("applyNewState state=" + state + ", so return");
+                        return;
+                    case IDLE:
+                        // fall through: this is unexpected but if it happens cleanup and try setup
+                    case FAILED:
+                    case RETRYING: {
+                        // We're "READY" but not active so disconnect (cleanup = true) and
+                        // connect (trySetup = true) to be sure we retry the connection.
+                        trySetup = true;
+                        apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                        break;
+                    }
+                }
+            //TODO: Need handle dependency met and data not enable case
+            } else if (!enabled) {
+                cleanup = true;
+                apnContext.setReason(Phone.REASON_DATA_DISABLED);
+/*
+            } else if (met) {
+                apnContext.setReason(Phone.REASON_DATA_DISABLED);
+                // If ConnectivityService has disabled this network, stop trying to bring
+                // it up, but do not tear it down - ConnectivityService will do that
+                // directly by talking with the DataConnection.
+                //
+                // This doesn't apply to DUN, however.  Those connections have special
+                // requirements from carriers and we need stop using them when the dun
+                // request goes away.  This applies to both CDMA and GSM because they both
+                // can declare the DUN APN sharable by default traffic, thus still satisfying
+                // those requests and not torn down organically.
+                if (apnContext.getApnType() == PhoneConstants.APN_TYPE_DUN && teardownForDun()) {
+                    cleanup = true;
+                } else {
+                    cleanup = false;
+                }
+*/
+            } else {
+                apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_UNMET);
+            }
+        } else {
+            if (enabled && met) {
+                if (apnContext.isEnabled()) {
+                    apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_MET);
+                } else {
+                    apnContext.setReason(Phone.REASON_DATA_ENABLED);
+                }
+                if (apnContext.getState() == DctConstants.State.FAILED) {
+                    apnContext.setState(DctConstants.State.IDLE);
+                }
+                trySetup = true;
+            }
+        }
+        apnContext.setEnabled(enabled);
+        apnContext.setDependencyMet(met);
+        if (cleanup) cleanUpConnection(true, apnContext);
+        if (trySetup) {
+            apnContext.resetErrorCodeRetries();
+            trySetupData(apnContext);
+        }
+    }
+
+    private DcAsyncChannel checkForCompatibleConnectedApnContext(ApnContext apnContext) {
+        String apnType = apnContext.getApnType();
+        ApnSetting dunSetting = null;
+
+        if (PhoneConstants.APN_TYPE_DUN.equals(apnType)) {
+            dunSetting = fetchDunApn();
+        }
+        if (DBG) {
+            log("checkForCompatibleConnectedApnContext: apnContext=" + apnContext );
+        }
+
+        DcAsyncChannel potentialDcac = null;
+        ApnContext potentialApnCtx = null;
+        for (ApnContext curApnCtx : mApnContexts.values()) {
+            DcAsyncChannel curDcac = curApnCtx.getDcAc();
+            if (curDcac != null) {
+                ApnSetting apnSetting = curApnCtx.getApnSetting();
+                log("apnSetting: " + apnSetting);
+                if (dunSetting != null) {
+                    if (dunSetting.equals(apnSetting)) {
+                        switch (curApnCtx.getState()) {
+                            case CONNECTED:
+                                if (DBG) {
+                                    log("checkForCompatibleConnectedApnContext:"
+                                            + " found dun conn=" + curDcac
+                                            + " curApnCtx=" + curApnCtx);
+                                }
+                                return curDcac;
+                            case RETRYING:
+                            case CONNECTING:
+                                potentialDcac = curDcac;
+                                potentialApnCtx = curApnCtx;
+                            default:
+                                // Not connected, potential unchanged
+                                break;
+                        }
+                    }
+                } else if (apnSetting != null && apnSetting.canHandleType(apnType)) {
+                    switch (curApnCtx.getState()) {
+                        case CONNECTED:
+                            if (DBG) {
+                                log("checkForCompatibleConnectedApnContext:"
+                                        + " found canHandle conn=" + curDcac
+                                        + " curApnCtx=" + curApnCtx);
+                            }
+                            return curDcac;
+                        case RETRYING:
+                        case CONNECTING:
+                        case SCANNING:
+                            potentialDcac = curDcac;
+                            potentialApnCtx = curApnCtx;
+                        default:
+                            // Not connected, potential unchanged
+                            break;
+                    }
+                }
+            } else {
+                if (VDBG) {
+                    log("checkForCompatibleConnectedApnContext: not conn curApnCtx=" + curApnCtx);
+                }
+            }
+        }
+        if (potentialDcac != null) {
+            if (DBG) {
+                log("checkForCompatibleConnectedApnContext: found potential conn=" + potentialDcac
+                        + " curApnCtx=" + potentialApnCtx);
+            }
+            return potentialDcac;
+        }
+
+        if (DBG) log("checkForCompatibleConnectedApnContext: NO conn apnContext=" + apnContext);
+        return null;
+    }
+
+    public void setEnabled(int id, boolean enable) {
+        Message msg = obtainMessage(DctConstants.EVENT_ENABLE_NEW_APN);
+        msg.arg1 = id;
+        msg.arg2 = (enable ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+    }
+
+    private void onEnableApn(int apnId, int enabled) {
+        ApnContext apnContext = mApnContextsById.get(apnId);
+        if (apnContext == null) {
+            loge("onEnableApn(" + apnId + ", " + enabled + "): NO ApnContext");
+            return;
+        }
+        // TODO change our retry manager to use the appropriate numbers for the new APN
+        if (DBG) log("onEnableApn: apnContext=" + apnContext + " call applyNewState");
+        applyNewState(apnContext, enabled == DctConstants.ENABLED, apnContext.getDependencyMet());
+    }
+
+    // TODO: We shouldnt need this.
+    private boolean onTrySetupData(String reason) {
+        if (DBG) log("onTrySetupData: reason=" + reason);
+        setupDataOnConnectableApns(reason);
+        return true;
+    }
+
+    private boolean onTrySetupData(ApnContext apnContext) {
+        if (DBG) log("onTrySetupData: apnContext=" + apnContext);
+        return trySetupData(apnContext);
+    }
+
+    /**
+     * Return current {@link android.provider.Settings.Global#MOBILE_DATA} value.
+     */
+    //TODO: Merge this into DataSettings. And probably should rename to getUserDataEnabled().
+    public boolean getDataEnabled() {
+        final int device_provisioned =
+                Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONED, 0);
+
+        boolean retVal = "true".equalsIgnoreCase(SystemProperties.get(
+                "ro.com.android.mobiledata", "true"));
+        if (TelephonyManager.getDefault().getSimCount() == 1) {
+            retVal = Settings.Global.getInt(mResolver, Settings.Global.MOBILE_DATA,
+                    retVal ? 1 : 0) != 0;
+        } else {
+            int phoneSubId = mPhone.getSubId();
+            try {
+                retVal = TelephonyManager.getIntWithSubId(mResolver,
+                        Settings.Global.MOBILE_DATA, phoneSubId) != 0;
+            } catch (SettingNotFoundException e) {
+                // use existing retVal
+            }
+        }
+        logd("getDataEnabled: retVal=" + retVal);
+        if (device_provisioned == 0) {
+            // device is still getting provisioned - use whatever setting they
+            // want during this process
+            //
+            // use the normal data_enabled setting (retVal, determined above)
+            // as the default if nothing else is set
+            final String prov_property = SystemProperties.get("ro.com.android.prov_mobiledata",
+                  retVal ? "true" : "false");
+            retVal = "true".equalsIgnoreCase(prov_property);
+
+            final int prov_mobile_data = Settings.Global.getInt(mResolver,
+                    Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED,
+                    retVal ? 1 : 0);
+            retVal = prov_mobile_data != 0;
+            log("getDataEnabled during provisioning retVal=" + retVal + " - (" + prov_property +
+                    ", " + prov_mobile_data + ")");
+        }
+
+        return retVal;
+    }
+
+    /**
+     * Modify {@link android.provider.Settings.Global#DATA_ROAMING} value.
+     */
+    public void setDataOnRoamingEnabled(boolean enabled) {
+        final int phoneSubId = mPhone.getSubId();
+        if (getDataOnRoamingEnabled() != enabled) {
+            int roaming = enabled ? 1 : 0;
+
+            // For single SIM phones, this is a per phone property.
+            if (TelephonyManager.getDefault().getSimCount() == 1) {
+                Settings.Global.putInt(mResolver, Settings.Global.DATA_ROAMING, roaming);
+            } else {
+                Settings.Global.putInt(mResolver, Settings.Global.DATA_ROAMING +
+                         phoneSubId, roaming);
+            }
+
+            // M: Sync data setting to modem
+            syncDataSettingsToMd(new int[] { getDataEnabled() ? 1 : 0,
+                                             enabled ? 1 : 0,
+                                             SKIP_DATA_SETTINGS});
+
+            mSubscriptionManager.setDataRoaming(roaming, phoneSubId);
+            // will trigger handleDataOnRoamingChange() through observer
+            if (DBG) {
+               log("setDataOnRoamingEnabled: set phoneSubId=" + phoneSubId
+                       + " isRoaming=" + enabled);
+            }
+        } else {
+            if (DBG) {
+                log("setDataOnRoamingEnabled: unchanged phoneSubId=" + phoneSubId
+                        + " isRoaming=" + enabled);
+             }
+        }
+    }
+
+    /**
+     * Return current {@link android.provider.Settings.Global#DATA_ROAMING} value.
+     */
+    public boolean getDataOnRoamingEnabled() {
+        boolean isDataRoamingEnabled = "true".equalsIgnoreCase(SystemProperties.get(
+                "ro.com.android.dataroaming", "false"));
+        final int phoneSubId = mPhone.getSubId();
+        String simOp = TelephonyManager.getDefault().getSimOperator(phoneSubId);
+        String srvOp = mPhone.getServiceState().getOperatorNumeric();
+
+        boolean nationRegion = (simOp != null && srvOp != null && simOp.length() >= 3
+                && srvOp.length() >= 3 && simOp.substring(0, 3).equals(srvOp.substring(0, 3)));
+
+        try {
+            final int roamingChoice = android.provider.Settings.Global.getInt(
+                    mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                    PREFERRED_ROAMING + phoneSubId, 0);
+            boolean nationReginOnly = (1 == roamingChoice);
+
+            if (DBG) {
+                android.util.Log.d(LOG_TAG, "simOp = " + simOp + ", srvOp = " + srvOp
+                        + ", nationRegion=" + nationRegion
+                        + ", roamingChoice=" + roamingChoice + ", nationReginOnly="
+                        + nationReginOnly);
+            }
+
+            if (nationReginOnly && !nationRegion) {
+                isDataRoamingEnabled = false;
+            } else {
+                // For single SIM phones, this is a per phone property.
+                if (TelephonyManager.getDefault().getSimCount() == 1) {
+                    isDataRoamingEnabled = Settings.Global.getInt(mResolver,
+                            Settings.Global.DATA_ROAMING, isDataRoamingEnabled ? 1 : 0) != 0;
+                } else {
+                    isDataRoamingEnabled = TelephonyManager.getIntWithSubId(mResolver,
+                            Settings.Global.DATA_ROAMING, phoneSubId) != 0;
+                }
+            }
+        } catch (SettingNotFoundException snfe) {
+            if (DBG) log("getDataOnRoamingEnabled: SettingNofFoundException snfe=" + snfe);
+        }
+        if (VDBG) {
+            logTel("getDataOnRoamingEnabled: phoneSubId=" + phoneSubId +
+                    " isDataRoamingEnabled=" + isDataRoamingEnabled);
+        }
+        return isDataRoamingEnabled;
+    }
+
+    private boolean ignoreDataRoaming(String apnType) {
+        logd("ignoreDataRoaming: apnType = " + apnType);
+        boolean ignoreDataRoaming = false;
+        try {
+            ignoreDataRoaming = mTelephonyExt.ignoreDataRoaming(apnType);
+        } catch (Exception e) {
+            loge("get ignoreDataRoaming fail!");
+            e.printStackTrace();
+        }
+        if (ignoreDataRoaming) {
+            logd("ignoreDataRoaming: " + ignoreDataRoaming + ", apnType = " + apnType);
+        }
+        return ignoreDataRoaming;
+    }
+
+    private boolean getDomesticRoamingEnabled() {
+        boolean isDomesticRoaming = isDomesticRoaming();
+        // No matter whether register on domestic roaming, check if is allowed by specific SIM.
+        boolean bDomesticRoamingEnabled = getDomesticRoamingEnabledBySim();
+
+        if (DBG) {
+            log("getDomesticRoamingEnabled: isDomesticRoaming=" + isDomesticRoaming
+                    + ", bDomesticRoamingEnabled=" + bDomesticRoamingEnabled);
+        }
+        return (isDomesticRoaming && bDomesticRoamingEnabled);
+    }
+
+    private boolean isDomesticRoaming() {
+        return mPhone.getServiceState().getDataRoamingType() ==
+                ServiceState.ROAMING_TYPE_DOMESTIC;
+    }
+
+    private boolean isInternationalRoaming() {
+        return mPhone.getServiceState().getDataRoamingType() ==
+                ServiceState.ROAMING_TYPE_INTERNATIONAL;
+    }
+
+    private boolean ignoreDataAllow(String apnType) {
+        boolean ignoreDataAllow = false;
+        if (PhoneConstants.APN_TYPE_IMS.equals(apnType)) {
+            ignoreDataAllow = true;
+        }
+
+        return ignoreDataAllow;
+    }
+
+    private boolean ignoreDefaultDataUnselected(String apnType) {
+        boolean ignoreDefaultDataUnselected = false;
+
+        try {
+            ignoreDefaultDataUnselected = mTelephonyExt.ignoreDefaultDataUnselected(apnType);
+        } catch (Exception e) {
+            loge("get ignoreDefaultDataUnselected fail!");
+            e.printStackTrace();
+        }
+
+        // M: Vsim
+        if (!ignoreDefaultDataUnselected
+                && TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)
+                && isVsimActive(mPhone.getPhoneId())) {
+            logd("Vsim is enabled, set ignoreDefaultDataUnselected as true");
+            ignoreDefaultDataUnselected = true;
+        }
+
+        if (ignoreDefaultDataUnselected) {
+            logd("ignoreDefaultDataUnselected: " + ignoreDefaultDataUnselected
+                    + ", apnType = " + apnType);
+        }
+        return ignoreDefaultDataUnselected;
+    }
+
+    private void onRoamingOff() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+
+        logd("onRoamingOff bDataOnRoamingEnabled=" + bDataOnRoamingEnabled);
+
+        if (!mDataEnabledSettings.isUserDataEnabled()) return;
+        if (false == hasOperatorIaCapability()) {
+            if (isOp18Sim()) {
+                setInitialAttachApn();
+            }
+        }
+        if (!bDataOnRoamingEnabled) {
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
+        } else {
+            notifyDataConnection(Phone.REASON_ROAMING_OFF);
+        }
+    }
+
+    private void onRoamingOn() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+        boolean bDomesticRoamingEnabled = getDomesticRoamingEnabled();
+
+        if (DBG) {
+            log("onRoamingOn bDataOnRoamingEnabled=" + bDataOnRoamingEnabled);
+        }
+
+        if (!mDataEnabledSettings.isUserDataEnabled()) {
+            if (getDomesticRoamingEnabledBySim()) {
+                if (isDomesticRoaming()) {
+                    if (DBG) log("data not enabled by specific SIM");
+                    return;
+                }
+            } else {
+                if (DBG) log("data not enabled by user");
+                return;
+            }
+        }
+        // Check if the device is actually data roaming
+        if (!mPhone.getServiceState().getDataRoaming()) {
+            if (DBG) log("device is not roaming. ignored the request.");
+            return;
+        }
+        if (false == hasOperatorIaCapability()) {
+            if (isOp18Sim()) {
+                setInitialAttachApn();
+            }
+        }
+        if (bDataOnRoamingEnabled || bDomesticRoamingEnabled) {
+            if (DBG) log("onRoamingOn: setup data on roaming");
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
+            notifyDataConnection(Phone.REASON_ROAMING_ON);
+        } else {
+            if (DBG) log("onRoamingOn: Tear down data connection on roaming.");
+            cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+        }
+    }
+
+    private void onRoamingTypeChanged() {
+        boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+        boolean bUserDataEnabled = mDataEnabledSettings.isUserDataEnabled();
+        int roamingType = mPhone.getServiceState().getDataRoamingType();
+
+        if (DBG) {
+            log("onRoamingTypeChanged: bDataOnRoamingEnabled=" + bDataOnRoamingEnabled
+                    + ", bUserDataEnabled=" + bUserDataEnabled
+                    + ", roamingType=" + roamingType);
+        }
+
+        if (!getDomesticRoamingEnabledBySim()) {
+            if (DBG) log("onRoamingTypeChanged: is not specific SIM. ignored the request.");
+            return;
+        }
+
+        // Check if the device is actually data roaming
+        if (!mPhone.getServiceState().getDataRoaming()) {
+            if (DBG) log("onRoamingTypeChanged: device is not roaming. ignored the request.");
+            return;
+        }
+
+        // Only the roaming types changed between DOMESTIC and INTERNATIONAL is expected here,
+        // if NOT, there might be something wrong with NW, suggest to discuss with them.
+        if ((roamingType == ServiceState.ROAMING_TYPE_DOMESTIC && bUserDataEnabled) ||
+                (roamingType == ServiceState.ROAMING_TYPE_INTERNATIONAL && bDataOnRoamingEnabled)) {
+            if (DBG) log("onRoamingTypeChanged: setup data on roaming");
+            setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
+            notifyDataConnection(Phone.REASON_ROAMING_ON);
+        } else {
+            if (DBG) log("onRoamingTypeChanged: Tear down data connection on roaming.");
+            cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
+            notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+        }
+    }
+
+    private void onRadioAvailable() {
+        if (DBG) log("onRadioAvailable");
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            // setState(DctConstants.State.CONNECTED);
+            notifyDataConnection(null);
+
+            log("onRadioAvailable: We're on the simulator; assuming data is connected");
+        }
+
+        IccRecords r = mIccRecords.get();
+        if (r != null && r.getRecordsLoaded()) {
+            notifyOffApnsOfAvailability(null);
+        }
+
+        if (getOverallState() != DctConstants.State.IDLE) {
+            cleanUpConnection(true, null);
+        }
+    }
+
+    private void onRadioOffOrNotAvailable() {
+        // Make sure our reconnect delay starts at the initial value
+        // next time the radio comes on
+
+        mReregisterOnReconnectFailure = false;
+
+        // M: To avoid trying setup data call before PS attach.
+        mAutoAttachOnCreation.set(false);
+        // Clear MD changed APN
+        mMdChangedAttachApn = null;
+        if (mPhone.getSimulatedRadioControl() != null) {
+            // Assume data is connected on the simulator
+            // FIXME  this can be improved
+            log("We're on the simulator; assuming radio off is meaningless");
+            notifyOffApnsOfAvailability(null);
+        } else {
+            logd("onRadioOffOrNotAvailable: is off and clean up all connections");
+            cleanUpAllConnections(false, Phone.REASON_RADIO_TURNED_OFF);
+        }
+        //ALPS01769896: We don't notify off twice.
+        //notifyOffApnsOfAvailability(null);
+    }
+
+    private void completeConnection(ApnContext apnContext) {
+
+        if (DBG) log("completeConnection: successful, notify the world apnContext=" + apnContext);
+
+        if (mIsProvisioning && !TextUtils.isEmpty(mProvisioningUrl)) {
+            if (DBG) {
+                log("completeConnection: MOBILE_PROVISIONING_ACTION url="
+                        + mProvisioningUrl);
+            }
+            Intent newIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,
+                    Intent.CATEGORY_APP_BROWSER);
+            newIntent.setData(Uri.parse(mProvisioningUrl));
+            newIntent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT |
+                    Intent.FLAG_ACTIVITY_NEW_TASK);
+            try {
+                mPhone.getContext().startActivity(newIntent);
+            } catch (ActivityNotFoundException e) {
+                loge("completeConnection: startActivityAsUser failed" + e);
+            }
+        }
+        mIsProvisioning = false;
+        mProvisioningUrl = null;
+        if (mProvisioningSpinner != null) {
+            sendMessage(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER,
+                    mProvisioningSpinner));
+        }
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+        startNetStatPoll();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+    }
+
+    /**
+     * A SETUP (aka bringUp) has completed, possibly with an error. If
+     * there is an error this method will call {@link #onDataSetupCompleteError}.
+     */
+    private void onDataSetupComplete(AsyncResult ar) {
+
+        DcFailCause cause = DcFailCause.UNKNOWN;
+        boolean handleError = false;
+        ApnContext apnContext = getValidApnContext(ar, "onDataSetupComplete");
+
+        if (apnContext == null) return;
+
+        if (ar.exception == null) {
+            DcAsyncChannel dcac = apnContext.getDcAc();
+
+            if (RADIO_TESTS) {
+                // Note: To change radio.test.onDSC.null.dcac from command line you need to
+                // adb root and adb remount and from the command line you can only change the
+                // value to 1 once. To change it a second time you can reboot or execute
+                // adb shell stop and then adb shell start. The command line to set the value is:
+                // adb shell sqlite3 /data/data/com.android.providers.settings/databases/settings.db "insert into system (name,value) values ('radio.test.onDSC.null.dcac', '1');"
+                ContentResolver cr = mPhone.getContext().getContentResolver();
+                String radioTestProperty = "radio.test.onDSC.null.dcac";
+                if (Settings.System.getInt(cr, radioTestProperty, 0) == 1) {
+                    log("onDataSetupComplete: " + radioTestProperty +
+                            " is true, set dcac to null and reset property to false");
+                    dcac = null;
+                    Settings.System.putInt(cr, radioTestProperty, 0);
+                    log("onDataSetupComplete: " + radioTestProperty + "=" +
+                            Settings.System.getInt(mPhone.getContext().getContentResolver(),
+                                    radioTestProperty, -1));
+                }
+            }
+            if (dcac == null) {
+                log("onDataSetupComplete: no connection to DC, handle as error");
+                cause = DcFailCause.CONNECTION_TO_DATACONNECTIONAC_BROKEN;
+                // M: Bug fixed.
+                apnContext.setState(DctConstants.State.FAILED);
+                handleError = true;
+            } else {
+                ApnSetting apn = apnContext.getApnSetting();
+                if (DBG) {
+                    log("onDataSetupComplete: success apn=" + (apn == null ? "unknown" : apn.apn));
+                }
+                if (apn != null && apn.proxy != null && apn.proxy.length() != 0) {
+                    try {
+                        String port = apn.port;
+                        if (TextUtils.isEmpty(port)) port = "8080";
+                        ProxyInfo proxy = new ProxyInfo(apn.proxy,
+                                Integer.parseInt(port), null);
+                        dcac.setLinkPropertiesHttpProxySync(proxy);
+                    } catch (NumberFormatException e) {
+                        loge("onDataSetupComplete: NumberFormatException making ProxyProperties (" +
+                                apn.port + "): " + e);
+                    }
+                }
+
+                // everything is setup
+                if(TextUtils.equals(apnContext.getApnType(),PhoneConstants.APN_TYPE_DEFAULT)) {
+                    try {
+                        SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "true");
+                    } catch (RuntimeException ex) {
+                        log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to true");
+                    }
+                    if (mCanSetPreferApn && mPreferredApn == null) {
+                        if (DBG) log("onDataSetupComplete: PREFERRED APN is null");
+                        mPreferredApn = apn;
+                        if (mPreferredApn != null) {
+                            setPreferredApn(mPreferredApn.id);
+                        }
+                    }
+                } else {
+                    try {
+                        SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
+                    } catch (RuntimeException ex) {
+                        loge("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
+                    }
+                }
+
+                // A connection is setup
+                apnContext.setState(DctConstants.State.CONNECTED);
+
+                boolean isProvApn = apnContext.isProvisioningApn();
+                final ConnectivityManager cm = ConnectivityManager.from(mPhone.getContext());
+                if (mProvisionBroadcastReceiver != null) {
+                    mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
+                    mProvisionBroadcastReceiver = null;
+                }
+                if ((!isProvApn) || mIsProvisioning) {
+                    // Hide any provisioning notification.
+                    cm.setProvisioningNotificationVisible(false, ConnectivityManager.TYPE_MOBILE,
+                            mProvisionActionName);
+                    // Complete the connection normally notifying the world we're connected.
+                    // We do this if this isn't a special provisioning apn or if we've been
+                    // told its time to provision.
+                    completeConnection(apnContext);
+                } else {
+                    // This is a provisioning APN that we're reporting as connected. Later
+                    // when the user desires to upgrade this to a "default" connection,
+                    // mIsProvisioning == true, we'll go through the code path above.
+                    // mIsProvisioning becomes true when CMD_ENABLE_MOBILE_PROVISIONING
+                    // is sent to the DCT.
+                    if (DBG) {
+                        log("onDataSetupComplete: successful, BUT send connected to prov apn as"
+                                + " mIsProvisioning:" + mIsProvisioning + " == false"
+                                + " && (isProvisioningApn:" + isProvApn + " == true");
+                    }
+
+                    // While radio is up, grab provisioning URL.  The URL contains ICCID which
+                    // disappears when radio is off.
+                    mProvisionBroadcastReceiver = new ProvisionNotificationBroadcastReceiver(
+                            cm.getMobileProvisioningUrl(),
+                            TelephonyManager.getDefault().getNetworkOperatorName());
+                    mPhone.getContext().registerReceiver(mProvisionBroadcastReceiver,
+                            new IntentFilter(mProvisionActionName));
+                    // Put up user notification that sign-in is required.
+                    cm.setProvisioningNotificationVisible(true, ConnectivityManager.TYPE_MOBILE,
+                            mProvisionActionName);
+                    // Turn off radio to save battery and avoid wasting carrier resources.
+                    // The network isn't usable and network validation will just fail anyhow.
+                    setRadio(false);
+                }
+                if (DBG) {
+                    log("onDataSetupComplete: SETUP complete type=" + apnContext.getApnType()
+                        + ", reason:" + apnContext.getReason());
+                }
+                if (Build.IS_DEBUGGABLE) {
+                    // adb shell setprop persist.radio.test.pco [pco_val]
+                    String radioTestProperty = "persist.radio.test.pco";
+                    int pcoVal = SystemProperties.getInt(radioTestProperty, -1);
+                    if (pcoVal != -1) {
+                        log("PCO testing: read pco value from persist.radio.test.pco " + pcoVal);
+                        final byte[] value = new byte[1];
+                        value[0] = (byte) pcoVal;
+                        final Intent intent =
+                                new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
+                        intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, "default");
+                        intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, "IPV4V6");
+                        intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, 0xFF00);
+                        intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, value);
+                        mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+                    }
+                }
+            }
+        } else {
+            cause = (DcFailCause) (ar.result);
+            if (DBG) {
+                ApnSetting apn = apnContext.getApnSetting();
+                log(String.format("onDataSetupComplete: error apn=%s cause=%s",
+                        (apn == null ? "unknown" : apn.apn), cause));
+            }
+            if (cause.isEventLoggable()) {
+                // Log this failure to the Event Logs.
+                int cid = getCellLocationId();
+                EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,
+                        cause.ordinal(), cid, TelephonyManager.getDefault().getNetworkType());
+            }
+            ApnSetting apn = apnContext.getApnSetting();
+            mPhone.notifyPreciseDataConnectionFailed(apnContext.getReason(),
+                    apnContext.getApnType(), apn != null ? apn.apn : "unknown", cause.toString());
+
+            // Compose broadcast intent send to the specific carrier signaling receivers
+            Intent intent = new Intent(TelephonyIntents
+                    .ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED);
+            intent.putExtra(TelephonyIntents.EXTRA_ERROR_CODE_KEY, cause.getErrorCode());
+            intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnContext.getApnType());
+            mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+
+            if (cause.isRestartRadioFail() || apnContext.restartOnError(cause.getErrorCode())) {
+                if (DBG) log("Modem restarted.");
+                sendRestartRadio();
+            }
+
+            // If the data call failure cause is a permanent failure, we mark the APN as permanent
+            // failed.
+            if (isPermanentFail(cause) ||
+                    (mGsmDctExt != null && mGsmDctExt.isIgnoredCause(cause))) {
+                log("cause = " + cause + ", mark apn as permanent failed. apn = " + apn);
+                apnContext.markApnPermanentFailed(apn);
+            }
+
+            handleError = true;
+        }
+
+        if (handleError) {
+            onDataSetupCompleteError(ar);
+        }
+
+        /* If flag is set to false after SETUP_DATA_CALL is invoked, we need
+         * to clean data connections.
+         */
+        if (!mDataEnabledSettings.isInternalDataEnabled()) {
+            cleanUpAllConnections(Phone.REASON_DATA_DISABLED);
+        }
+
+    }
+
+    /**
+     * check for obsolete messages.  Return ApnContext if valid, null if not
+     */
+    private ApnContext getValidApnContext(AsyncResult ar, String logString) {
+        if (ar != null && ar.userObj instanceof Pair) {
+            Pair<ApnContext, Integer>pair = (Pair<ApnContext, Integer>)ar.userObj;
+            ApnContext apnContext = pair.first;
+            if (apnContext != null) {
+                final int generation = apnContext.getConnectionGeneration();
+                if (DBG) {
+                    log("getValidApnContext (" + logString + ") on " + apnContext + " got " +
+                            generation + " vs " + pair.second);
+                }
+                if (generation == pair.second) {
+                    return apnContext;
+                } else {
+                    log("ignoring obsolete " + logString);
+                    return null;
+                }
+            }
+        }
+        throw new RuntimeException(logString + ": No apnContext");
+    }
+
+    /**
+     * Error has occurred during the SETUP {aka bringUP} request and the DCT
+     * should either try the next waiting APN or start over from the
+     * beginning if the list is empty. Between each SETUP request there will
+     * be a delay defined by {@link #getApnDelay()}.
+     */
+    private void onDataSetupCompleteError(AsyncResult ar) {
+
+        ApnContext apnContext = getValidApnContext(ar, "onDataSetupCompleteError");
+
+        if (apnContext == null) return;
+
+        long delay = apnContext.getDelayForNextApn(mFailFast);
+
+        // Check if we need to retry or not.
+        if (delay >= 0) {
+            if (DBG) log("onDataSetupCompleteError: Try next APN. delay = " + delay);
+            apnContext.setState(DctConstants.State.SCANNING);
+            // Wait a bit before trying the next APN, so that
+            // we're not tying up the RIL command channel
+            startAlarmForReconnect(delay, apnContext);
+        } else {
+            // If we are not going to retry any APN, set this APN context to failed state.
+            // This would be the final state of a data connection.
+            apnContext.setState(DctConstants.State.FAILED);
+            mPhone.notifyDataConnection(Phone.REASON_APN_FAILED, apnContext.getApnType());
+            apnContext.setDataConnectionAc(null);
+            log("onDataSetupCompleteError: Stop retrying APNs.");
+        }
+    }
+
+    /**
+     * Called when EVENT_REDIRECTION_DETECTED is received.
+     */
+    private void onDataConnectionRedirected(String redirectUrl) {
+        if (!TextUtils.isEmpty(redirectUrl)) {
+            Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_REDIRECTED);
+            intent.putExtra(TelephonyIntents.EXTRA_REDIRECTION_URL_KEY, redirectUrl);
+            if(mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent)) {
+                log("Notify carrier signal receivers with redirectUrl: " + redirectUrl);
+            }
+        }
+    }
+
+    /**
+     * Called when EVENT_DISCONNECT_DONE is received.
+     */
+    private void onDisconnectDone(AsyncResult ar) {
+        ApnContext apnContext = getValidApnContext(ar, "onDisconnectDone");
+        if (apnContext == null) return;
+
+        if(DBG) log("onDisconnectDone: EVENT_DISCONNECT_DONE apnContext=" + apnContext);
+        apnContext.setState(DctConstants.State.IDLE);
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+
+        // if all data connection are gone, check whether Airplane mode request was
+        // pending. (ignore only IMS or EIMS is connected)
+        if (isDisconnected() || isOnlyIMSorEIMSPdnConnected()) {
+            if (mPhone.getServiceStateTracker().processPendingRadioPowerOffAfterDataOff()) {
+                if (DBG) log("onDisconnectDone: radio will be turned off, no retries");
+                // Radio will be turned off. No need to retry data setup
+                apnContext.setApnSetting(null);
+                apnContext.setDataConnectionAc(null);
+
+                // Need to notify disconnect as well, in the case of switching Airplane mode.
+                // Otherwise, it would cause 30s delayed to turn on Airplane mode.
+                if (mDisconnectPendingCount > 0) {
+                    mDisconnectPendingCount--;
+                }
+
+                if (mDisconnectPendingCount == 0) {
+                    notifyDataDisconnectComplete();
+                    notifyAllDataDisconnected();
+                }
+                return;
+            }
+        }
+        // If APN is still enabled, try to bring it back up automatically
+        if (mAttached.get() && apnContext.isReady() && retryAfterDisconnected(apnContext)) {
+            try {
+                SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
+            } catch (RuntimeException ex) {
+                log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
+            }
+
+            if (mTelDevController.getModem(0) != null &&
+                    mTelDevController.getModem(0).hasMdAutoSetupImsCapability() == false) {
+                if (PhoneConstants.APN_TYPE_IMS.equals(apnContext.getApnType()) ||
+                        PhoneConstants.APN_TYPE_EMERGENCY.equals(apnContext.getApnType())) {
+                    logd("onDisconnectDone: not to retry for " + apnContext.getApnType() + " PDN");
+                    return;
+                }
+            }
+
+            // Wait a bit before trying the next APN, so that
+            // we're not tying up the RIL command channel.
+            // This also helps in any external dependency to turn off the context.
+            if (DBG) log("onDisconnectDone: attached, ready and retry after disconnect");
+            long delay = apnContext.getInterApnDelay(mFailFast);
+            delay = getDisconnectDoneRetryTimer(apnContext.getReason(), delay);
+            if (delay > 0) {
+                // Data connection is in IDLE state, so when we reconnect later, we'll rebuild
+                // the waiting APN list, which will also reset/reconfigure the retry manager.
+                startAlarmForReconnect(delay, apnContext);
+            }
+        } else {
+            boolean restartRadioAfterProvisioning = mPhone.getContext().getResources().getBoolean(
+                    com.android.internal.R.bool.config_restartRadioAfterProvisioning);
+
+            if (apnContext.isProvisioningApn() && restartRadioAfterProvisioning) {
+                log("onDisconnectDone: restartRadio after provisioning");
+                restartRadio();
+            }
+            apnContext.setApnSetting(null);
+            apnContext.setDataConnectionAc(null);
+            if (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())) {
+                if(DBG) log("onDisconnectDone: isOnlySigneDcAllowed true so setup single apn");
+                setupDataOnConnectableApns(Phone.REASON_SINGLE_PDN_ARBITRATION);
+            } else {
+                if(DBG) log("onDisconnectDone: not retrying");
+            }
+        }
+
+        if (mDisconnectPendingCount > 0)
+            mDisconnectPendingCount--;
+
+        if (mDisconnectPendingCount == 0) {
+            apnContext.setConcurrentVoiceAndDataAllowed(
+                    mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed());
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+    }
+
+    /**
+     * M: Called when EVENT_DISCONNECT_DONE is received.
+     * Get retry timer for onDisconnectDone.
+     */
+    private long getDisconnectDoneRetryTimer(String reason, long delay) {
+        long timer = delay;
+        if (Phone.REASON_APN_CHANGED.equals(reason)) {
+            // M: onApnChanged need retry quickly
+            timer = 3000;
+        } else if (!BSP_PACKAGE && mGsmDctExt != null) {
+            // M: for other specific reason
+            try {
+                timer = mGsmDctExt.getDisconnectDoneRetryTimer(reason, timer);
+            } catch (Exception e) {
+                loge("GsmDCTExt.getDisconnectDoneRetryTimer fail!");
+                e.printStackTrace();
+            }
+        }
+
+        return timer;
+    }
+
+    /**
+     * Called when EVENT_DISCONNECT_DC_RETRYING is received.
+     */
+    private void onDisconnectDcRetrying(AsyncResult ar) {
+        // We could just do this in DC!!!
+        ApnContext apnContext = getValidApnContext(ar, "onDisconnectDcRetrying");
+        if (apnContext == null) return;
+
+        apnContext.setState(DctConstants.State.RETRYING);
+        if(DBG) log("onDisconnectDcRetrying: apnContext=" + apnContext);
+
+        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
+    }
+
+    public void onVoiceCallStarted() {
+        mInVoiceCall = true;
+
+        boolean isSupportConcurrent =
+                DataConnectionHelper.getInstance().isDataSupportConcurrent(mPhone.getPhoneId());
+        logd("onVoiceCallStarted:isDataSupportConcurrent = " + isSupportConcurrent);
+
+        if (isConnected() && !isSupportConcurrent) {
+            logd("onVoiceCallStarted stop polling");
+            stopNetStatPoll();
+            stopDataStallAlarm();
+            notifyDataConnection(Phone.REASON_VOICE_CALL_STARTED);
+        }
+        notifyVoiceCallEventToDataConnection(mInVoiceCall, isSupportConcurrent);
+    }
+
+    public void onVoiceCallEnded() {
+        mInVoiceCall = false;
+
+        boolean isSupportConcurrent =
+                DataConnectionHelper.getInstance().isDataSupportConcurrent(mPhone.getPhoneId());
+        logd("onVoiceCallEnded:isDataSupportConcurrent = " + isSupportConcurrent);
+
+        if (!getDataEnabled()) {
+            logd("onVoiceCallEnded: default data disable, cleanup default apn.");
+            onCleanUpConnection(true, DctConstants.APN_DEFAULT_ID, Phone.REASON_DATA_DISABLED);
+        }
+
+        if (isConnected()) {
+            if (!isSupportConcurrent) {
+                startNetStatPoll();
+                startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
+            } else {
+                // clean slate after call end.
+                resetPollStats();
+            }
+        }
+        // reset reconnect timer
+        setupDataOnConnectableApns(Phone.REASON_VOICE_CALL_ENDED);
+
+        notifyVoiceCallEventToDataConnection(mInVoiceCall, isSupportConcurrent);
+    }
+
+    private void onCleanUpConnection(boolean tearDown, int apnId, String reason) {
+        if (DBG) log("onCleanUpConnection");
+        ApnContext apnContext = mApnContextsById.get(apnId);
+        if (apnContext != null) {
+            apnContext.setReason(reason);
+            cleanUpConnection(tearDown, apnContext);
+        }
+    }
+
+    private boolean isConnected() {
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (apnContext.getState() == DctConstants.State.CONNECTED) {
+                // At least one context is connected, return true
+                return true;
+            }
+        }
+        // There are not any contexts connected, return false
+        return false;
+    }
+
+    public boolean isDisconnected() {
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (!apnContext.isDisconnected()) {
+                // At least one context was not disconnected return false
+                return false;
+            }
+        }
+        // All contexts were disconnected so return true
+        return true;
+    }
+
+    private void notifyDataConnection(String reason) {
+        if (DBG) log("notifyDataConnection: reason=" + reason);
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (mAttached.get() && apnContext.isReady() && apnContext.isNeedNotify()) {
+                // M: Check need notify or not in order to avoid ANR issue
+                if (DBG) log("notifyDataConnection: type:" + apnContext.getApnType());
+                mPhone.notifyDataConnection(reason != null ? reason : apnContext.getReason(),
+                        apnContext.getApnType());
+            }
+        }
+        notifyOffApnsOfAvailability(reason);
+    }
+
+    private void setDataProfilesAsNeeded() {
+        if (DBG) log("setDataProfilesAsNeeded");
+        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.modemCognitive) {
+                    DataProfile dp = new DataProfile(apn,
+                            mPhone.getServiceState().getDataRoaming());
+                    boolean isDup = false;
+                    for(DataProfile dpIn : dps) {
+                        if (dp.equals(dpIn)) {
+                            isDup = true;
+                            break;
+                        }
+                    }
+                    if (!isDup) {
+                        dps.add(dp);
+                    }
+                }
+            }
+            if(dps.size() > 0) {
+                mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), null);
+            }
+        }
+    }
+
+    /**
+     * Based on the sim operator numeric, create a list for all possible
+     * Data Connections and setup the preferredApn.
+     */
+    private void createAllApnList() {
+        mMvnoMatched = false;
+        mAllApnSettings = new ArrayList<ApnSetting>();
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        /// M: for plug-in @{
+        // use mcc&mnc in IMPI to query apn.
+        if (DBG) log("createAllApnList: operator = " + operator);
+        if (mTelephonyExt != null) {
+            operator = mTelephonyExt.getOperatorNumericFromImpi(operator, mPhone.getPhoneId());
+        }
+        /// @}
+
+        if (operator != null) {
+            String selection = "numeric = '" + operator + "'";
+            String orderBy = "_id";
+            // query only enabled apn.
+            // carrier_enabled : 1 means enabled apn, 0 disabled apn.
+            // selection += " and carrier_enabled = 1";
+            if (DBG) log("createAllApnList: selection=" + selection);
+
+            Cursor cursor = mPhone.getContext().getContentResolver().query(
+                    Telephony.Carriers.CONTENT_URI, null, selection, null, orderBy);
+
+            if (cursor != null) {
+                if (cursor.getCount() > 0) {
+                    mAllApnSettings = createApnList(cursor);
+                }
+                cursor.close();
+            }
+        }
+
+        // Try to load default emergency again
+        initEmergencyApnSetting();
+        addEmergencyApnSetting();
+
+        dedupeApnSettings();
+
+        if (mAllApnSettings.isEmpty()) {
+            if (DBG) log("createAllApnList: No APN found for carrier: " + operator);
+            mPreferredApn = null;
+            // TODO: What is the right behavior?
+            //notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
+        } else {
+            mPreferredApn = getPreferredApn();
+            if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
+                mPreferredApn = null;
+                setPreferredApn(-1);
+            }
+            if (DBG) log("createAllApnList: mPreferredApn=" + mPreferredApn);
+        }
+        // M: For debug
+        if (DBG) logi("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
+
+        setDataProfilesAsNeeded();
+
+        // M: sync apn table to md
+        if (operator != null) {
+            syncApnToMd();
+        }
+
+        // M: VDF MMS over ePDG @{
+        syncApnTableToRds(mAllApnSettings);
+        /// @}
+    }
+
+    private void dedupeApnSettings() {
+        ArrayList<ApnSetting> resultApns = new ArrayList<ApnSetting>();
+
+        // coalesce APNs if they are similar enough to prevent
+        // us from bringing up two data calls with the same interface
+        int i = 0;
+        while (i < mAllApnSettings.size() - 1) {
+            ApnSetting first = mAllApnSettings.get(i);
+            ApnSetting second = null;
+            int j = i + 1;
+            while (j < mAllApnSettings.size()) {
+                second = mAllApnSettings.get(j);
+                if (apnsSimilar(first, second)) {
+                    ApnSetting newApn = mergeApns(first, second);
+                    mAllApnSettings.set(i, newApn);
+                    first = newApn;
+                    mAllApnSettings.remove(j);
+                } else {
+                    j++;
+                }
+            }
+            i++;
+        }
+    }
+
+    //check whether the types of two APN same (even only one type of each APN is same)
+    private boolean apnTypeSameAny(ApnSetting first, ApnSetting second) {
+        if(VDBG) {
+            StringBuilder apnType1 = new StringBuilder(first.apn + ": ");
+            for(int index1 = 0; index1 < first.types.length; index1++) {
+                apnType1.append(first.types[index1]);
+                apnType1.append(",");
+            }
+
+            StringBuilder apnType2 = new StringBuilder(second.apn + ": ");
+            for(int index1 = 0; index1 < second.types.length; index1++) {
+                apnType2.append(second.types[index1]);
+                apnType2.append(",");
+            }
+            log("APN1: is " + apnType1);
+            log("APN2: is " + apnType2);
+        }
+
+        for(int index1 = 0; index1 < first.types.length; index1++) {
+            for(int index2 = 0; index2 < second.types.length; index2++) {
+                if(first.types[index1].equals(PhoneConstants.APN_TYPE_ALL) ||
+                        second.types[index2].equals(PhoneConstants.APN_TYPE_ALL) ||
+                        first.types[index1].equals(second.types[index2])) {
+                    if(VDBG)log("apnTypeSameAny: return true");
+                    return true;
+                }
+            }
+        }
+
+        if(VDBG)log("apnTypeSameAny: return false");
+        return false;
+    }
+
+    // Check if neither mention DUN and are substantially similar
+    private boolean apnsSimilar(ApnSetting first, ApnSetting second) {
+        return (first.canHandleType(PhoneConstants.APN_TYPE_DUN) == false &&
+                second.canHandleType(PhoneConstants.APN_TYPE_DUN) == false &&
+                Objects.equals(first.apn, second.apn) &&
+                !apnTypeSameAny(first, second) &&
+                xorEquals(first.proxy, second.proxy) &&
+                xorEquals(first.port, second.port) &&
+                first.carrierEnabled == second.carrierEnabled &&
+                first.bearerBitmask == second.bearerBitmask &&
+                first.profileId == second.profileId &&
+                Objects.equals(first.mvnoType, second.mvnoType) &&
+                Objects.equals(first.mvnoMatchData, second.mvnoMatchData) &&
+                xorEquals(first.mmsc, second.mmsc) &&
+                xorEquals(first.mmsProxy, second.mmsProxy) &&
+                xorEquals(first.mmsPort, second.mmsPort));
+    }
+
+    // equal or one is not specified
+    private boolean xorEquals(String first, String second) {
+        return (Objects.equals(first, second) ||
+                TextUtils.isEmpty(first) ||
+                TextUtils.isEmpty(second));
+    }
+
+    private ApnSetting mergeApns(ApnSetting dest, ApnSetting src) {
+        int id = dest.id;
+        ArrayList<String> resultTypes = new ArrayList<String>();
+        resultTypes.addAll(Arrays.asList(dest.types));
+        for (String srcType : src.types) {
+            if (resultTypes.contains(srcType) == false) resultTypes.add(srcType);
+            if (srcType.equals(PhoneConstants.APN_TYPE_DEFAULT)) id = src.id;
+        }
+        String mmsc = (TextUtils.isEmpty(dest.mmsc) ? src.mmsc : dest.mmsc);
+        String mmsProxy = (TextUtils.isEmpty(dest.mmsProxy) ? src.mmsProxy : dest.mmsProxy);
+        String mmsPort = (TextUtils.isEmpty(dest.mmsPort) ? src.mmsPort : dest.mmsPort);
+        String proxy = (TextUtils.isEmpty(dest.proxy) ? src.proxy : dest.proxy);
+        String port = (TextUtils.isEmpty(dest.port) ? src.port : dest.port);
+        String protocol = src.protocol.equals("IPV4V6") ? src.protocol : dest.protocol;
+        String roamingProtocol = src.roamingProtocol.equals("IPV4V6") ? src.roamingProtocol :
+                dest.roamingProtocol;
+        int bearerBitmask = (dest.bearerBitmask == 0 || src.bearerBitmask == 0) ?
+                0 : (dest.bearerBitmask | src.bearerBitmask);
+
+        return new ApnSetting(id, dest.numeric, dest.carrier, dest.apn,
+                proxy, port, mmsc, mmsProxy, mmsPort, dest.user, dest.password,
+                dest.authType, resultTypes.toArray(new String[0]), protocol,
+                roamingProtocol, dest.carrierEnabled, 0, bearerBitmask, dest.profileId,
+                (dest.modemCognitive || src.modemCognitive), dest.maxConns, dest.waitTime,
+                dest.maxConnsTime, dest.mtu, dest.mvnoType, dest.mvnoMatchData, dest.inactiveTimer);
+    }
+
+    /** Return the DC AsyncChannel for the new data connection */
+    private DcAsyncChannel createDataConnection(String reqApnType, ApnSetting apnSetting) {
+        if (DBG) log("createDataConnection E");
+
+        int id = 0;
+        if (isSupportThrottlingApn()) {
+            id = generateDataConnectionId(reqApnType, apnSetting);
+            if (id < 0) {
+                return null;
+            }
+        } else {
+            id = mUniqueIdGenerator.getAndIncrement();
+            if (id >= getPdpConnectionPoolSize()) {
+                loge("Max PDP count is " + getPdpConnectionPoolSize() + ",but request " + (id + 1));
+                mUniqueIdGenerator.getAndDecrement();
+                return null;
+            }
+        }
+
+        DataConnection conn = DataConnection.makeDataConnection(mPhone, id,
+                                                this, mDcTesterFailBringUpAll, mDcc);
+        mDataConnections.put(id, conn);
+        DcAsyncChannel dcac = new DcAsyncChannel(conn, LOG_TAG);
+        int status = dcac.fullyConnectSync(mPhone.getContext(), this, conn.getHandler());
+        if (status == AsyncChannel.STATUS_SUCCESSFUL) {
+            mDataConnectionAcHashMap.put(dcac.getDataConnectionIdSync(), dcac);
+        } else {
+            loge("createDataConnection: Could not connect to dcac=" + dcac + " status=" + status);
+        }
+
+        if (DBG) log("createDataConnection() X id=" + id + " dc=" + conn);
+        return dcac;
+    }
+
+    private void destroyDataConnections() {
+        if(mDataConnections != null) {
+            if (DBG) log("destroyDataConnections: clear mDataConnectionList");
+            mDataConnections.clear();
+        } else {
+            if (DBG) log("destroyDataConnections: mDataConnecitonList is empty, ignore");
+        }
+    }
+
+    /**
+     * Build a list of APNs to be used to create PDP's.
+     *
+     * @param requestedApnType
+     * @return waitingApns list to be used to create PDP
+     *          error when waitingApns.isEmpty()
+     */
+    private ArrayList<ApnSetting> buildWaitingApns(String requestedApnType, int radioTech) {
+        if (DBG) log("buildWaitingApns: E requestedApnType=" + requestedApnType);
+        ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
+
+        if (requestedApnType.equals(PhoneConstants.APN_TYPE_DUN)) {
+            ApnSetting dun = fetchDunApn();
+            if (dun != null) {
+                apnList.add(dun);
+                if (DBG) log("buildWaitingApns: X added APN_TYPE_DUN apnList=" + apnList);
+                return apnList;
+            }
+        }
+
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        // This is a workaround for a bug (7305641) where we don't failover to other
+        // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
+        // failover to a provisioning APN, but once we've used their default data
+        // connection we are locked to it for life.  This change allows ATT devices
+        // to say they don't want to use preferred at all.
+        boolean usePreferred = true;
+        try {
+            usePreferred = ! mPhone.getContext().getResources().getBoolean(com.android.
+                    internal.R.bool.config_dontPreferApn);
+        } catch (Resources.NotFoundException e) {
+            if (DBG) log("buildWaitingApns: usePreferred NotFoundException set to true");
+            usePreferred = true;
+        }
+        if (usePreferred) {
+            mPreferredApn = getPreferredApn();
+        }
+        if (DBG) {
+            log("buildWaitingApns: usePreferred=" + usePreferred
+                    + " canSetPreferApn=" + mCanSetPreferApn
+                    + " mPreferredApn=" + mPreferredApn
+                    + " operator=" + operator + " radioTech=" + radioTech
+                    + " IccRecords r=" + r);
+        }
+
+        if (usePreferred && mCanSetPreferApn && mPreferredApn != null &&
+                mPreferredApn.canHandleType(requestedApnType)) {
+            if (DBG) {
+                log("buildWaitingApns: Preferred APN:" + operator + ":"
+                        + mPreferredApn.numeric + ":" + mPreferredApn);
+            }
+            if (mPreferredApn.numeric.equals(operator)) {
+                if (ServiceState.bitmaskHasTech(mPreferredApn.bearerBitmask, radioTech)) {
+                    apnList.add(mPreferredApn);
+                    if (DBG) log("buildWaitingApns: X added preferred apnList=" + apnList);
+                    return apnList;
+                } else {
+                    if (DBG) log("buildWaitingApns: no preferred APN");
+                    setPreferredApn(-1);
+                    mPreferredApn = null;
+                }
+            } else {
+                if (DBG) log("buildWaitingApns: no preferred APN");
+                setPreferredApn(-1);
+                mPreferredApn = null;
+            }
+        }
+        if (mAllApnSettings != null) {
+            if (DBG) log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(requestedApnType)) {
+                    if (ServiceState.bitmaskHasTech(apn.bearerBitmask, radioTech)) {
+                        if (DBG) log("buildWaitingApns: adding apn=" + apn);
+                        apnList.add(apn);
+                    } else {
+                        if (DBG) {
+                            log("buildWaitingApns: bearerBitmask:" + apn.bearerBitmask + " does " +
+                                    "not include radioTech:" + radioTech);
+                        }
+                    }
+                } else if (DBG) {
+                    log("buildWaitingApns: couldn't handle requested ApnType="
+                            + requestedApnType);
+                }
+            }
+        } else {
+            loge("mAllApnSettings is null!");
+        }
+        if (DBG) log("buildWaitingApns: " + apnList.size() + " APNs in the list: " + apnList);
+        return apnList;
+    }
+
+    // M: VDF MMS over ePDG @{
+    private ArrayList<ApnSetting> buildWifiApns(String requestedApnType) {
+        if (DBG) log("buildWifiApns: E requestedApnType=" + requestedApnType);
+        ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
+
+        if (mAllApnSettings != null) {
+            if (DBG) log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apn.canHandleType(requestedApnType)) {
+                    if (isWifiOnlyApn(apn.bearerBitmask)) {
+                        apnList.add(apn);
+                    }
+                }
+            }
+        }
+        if (DBG) log("buildWifiApns: X apnList=" + apnList);
+        return apnList;
+    }
+    /// @}
+    private String apnListToString (ArrayList<ApnSetting> apns) {
+        StringBuilder result = new StringBuilder();
+        try {
+            for (int i = 0, size = apns.size(); i < size; i++) {
+                result.append('[')
+                  .append(apns.get(i).toString())
+                  .append(']');
+            }
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+        return result.toString();
+    }
+
+    private void setPreferredApn(int pos) {
+        if (!mCanSetPreferApn) {
+            log("setPreferredApn: X !canSEtPreferApn");
+            return;
+        }
+
+        String subId = Long.toString(mPhone.getSubId());
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        log("setPreferredApn: delete subId=" + subId);
+        ContentResolver resolver = mPhone.getContext().getContentResolver();
+        resolver.delete(uri, null, null);
+
+        if (pos >= 0) {
+            log("setPreferredApn: insert pos=" + pos + ", subId=" + subId);
+            ContentValues values = new ContentValues();
+            values.put(APN_ID, pos);
+            resolver.insert(uri, values);
+        }
+    }
+
+    private ApnSetting getPreferredApn() {
+        if (mAllApnSettings == null || mAllApnSettings.isEmpty()) {
+            log("getPreferredApn: mAllApnSettings is " + ((mAllApnSettings == null)?"null":"empty"));
+            return null;
+        }
+
+        String subId = Long.toString(mPhone.getSubId());
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        Cursor cursor = mPhone.getContext().getContentResolver().query(
+                uri, new String[] { "_id", "name", "apn" },
+                null, null, Telephony.Carriers.DEFAULT_SORT_ORDER);
+
+        if (cursor != null) {
+            mCanSetPreferApn = true;
+        } else {
+            mCanSetPreferApn = false;
+        }
+        log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor=" + cursor
+                + " cursor.count=" + ((cursor != null) ? cursor.getCount() : 0)
+                + " subId=" + subId);
+
+        if (mCanSetPreferApn && cursor.getCount() > 0) {
+            int pos;
+            cursor.moveToFirst();
+            pos = cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID));
+            for(ApnSetting p : mAllApnSettings) {
+                log("getPreferredApn: apnSetting=" + p + ", pos=" + pos + ", subId=" + subId);
+                if (p.id == pos && p.canHandleType(mRequestedApnType)) {
+                    log("getPreferredApn: X found apnSetting" + p);
+                    cursor.close();
+                    return p;
+                }
+            }
+        }
+
+        if (cursor != null) {
+            cursor.close();
+        }
+
+        log("getPreferredApn: X not found");
+        return null;
+    }
+
+    @Override
+    public void handleMessage (Message msg) {
+        if (VDBG) log("handleMessage msg=" + msg);
+        AsyncResult ar;
+
+        switch (msg.what) {
+            case DctConstants.EVENT_RECORDS_LOADED:
+                // If onRecordsLoadedOrSubIdChanged() is not called here, it should be called on
+                // onSubscriptionsChanged() when a valid subId is available.
+                int subId = mPhone.getSubId();
+                if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                    onRecordsLoadedOrSubIdChanged();
+                } else {
+                    log("Ignoring EVENT_RECORDS_LOADED as subId is not valid: " + subId);
+                }
+                break;
+
+            case DctConstants.EVENT_DATA_CONNECTION_DETACHED:
+                onDataConnectionDetached();
+                break;
+
+            case DctConstants.EVENT_DATA_CONNECTION_ATTACHED:
+                onDataConnectionAttached();
+                break;
+
+            case DctConstants.EVENT_DO_RECOVERY:
+                doRecovery();
+                break;
+
+            case DctConstants.EVENT_APN_CHANGED:
+                onApnChanged();
+                break;
+
+            case DctConstants.EVENT_APN_CHANGED_DONE:
+                boolean bImsApnChanged = (msg.arg1 == 0) ? false : true;
+                logd("EVENT_APN_CHANGED_DONE");
+                if (bImsApnChanged) {
+                    log("ims apn changed");
+                    ApnContext apnContext = mApnContexts.get(PhoneConstants.APN_TYPE_IMS);
+                    cleanUpConnection(true, apnContext);
+                } else {
+                    // default changed
+                    onApnChangedDone();
+                }
+                break;
+
+            case DctConstants.EVENT_PS_RESTRICT_ENABLED:
+                /**
+                 * We don't need to explicitly to tear down the PDP context
+                 * when PS restricted is enabled. The base band will deactive
+                 * PDP context and notify us with PDP_CONTEXT_CHANGED.
+                 * But we should stop the network polling and prevent reset PDP.
+                 */
+                if (DBG) log("EVENT_PS_RESTRICT_ENABLED " + mIsPsRestricted);
+                stopNetStatPoll();
+                stopDataStallAlarm();
+                mIsPsRestricted = true;
+                break;
+
+            case DctConstants.EVENT_PS_RESTRICT_DISABLED:
+                /**
+                 * When PS restrict is removed, we need setup PDP connection if
+                 * PDP connection is down.
+                 */
+                // M: Wifi only
+                ConnectivityManager cnnm = (ConnectivityManager) mPhone.getContext()
+                        .getSystemService(Context.CONNECTIVITY_SERVICE);
+
+                if (DBG) log("EVENT_PS_RESTRICT_DISABLED " + mIsPsRestricted);
+                mIsPsRestricted  = false;
+                if (isConnected()) {
+                    startNetStatPoll();
+                    startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                } else {
+                    // TODO: Should all PDN states be checked to fail?
+                    if (mState == DctConstants.State.FAILED) {
+                        cleanUpAllConnections(false, Phone.REASON_PS_RESTRICT_ENABLED);
+                        mReregisterOnReconnectFailure = false;
+                    }
+                    ApnContext apnContext = mApnContextsById.get(DctConstants.APN_DEFAULT_ID);
+                    if (apnContext != null) {
+                        // M: Fix dual DataConnection issue. For the case that PS is detached but
+                        //    the EVENT_DATA_CONNECTION_DETACHED haven't received yet. In this case,
+                        //    isDataAllow returns true and will try to setup data. Then, the detach
+                        //    message received and set mAttached as false. After this,
+                        //    onDisconnectDone() called and will set ApnContext idle and DCAC null.
+                        //    It will make DCAC can not re-use when setup data at the second time.
+                        if (mPhone.getServiceStateTracker().getCurrentDataConnectionState()
+                                == ServiceState.STATE_IN_SERVICE) {
+                            apnContext.setReason(Phone.REASON_PS_RESTRICT_ENABLED);
+                            trySetupData(apnContext);
+                        } else {
+                            log("EVENT_PS_RESTRICT_DISABLED, data not attached, skip.");
+                        }
+                    } else {
+                        loge("**** Default ApnContext not found ****");
+                        // M: Wifi only
+                        if (Build.IS_DEBUGGABLE && cnnm.isNetworkSupported(
+                                ConnectivityManager.TYPE_MOBILE)) {
+                            throw new RuntimeException("Default ApnContext not found");
+                        }
+                    }
+                }
+                break;
+
+            case DctConstants.EVENT_TRY_SETUP_DATA:
+                if (msg.obj instanceof ApnContext) {
+                    onTrySetupData((ApnContext)msg.obj);
+                } else if (msg.obj instanceof String) {
+                    onTrySetupData((String)msg.obj);
+                } else {
+                    loge("EVENT_TRY_SETUP request w/o apnContext or String");
+                }
+                break;
+
+            case DctConstants.EVENT_CLEAN_UP_CONNECTION:
+                boolean tearDown = (msg.arg1 == 0) ? false : true;
+                if (DBG) log("EVENT_CLEAN_UP_CONNECTION tearDown=" + tearDown);
+                if (msg.obj instanceof ApnContext) {
+                    cleanUpConnection(tearDown, (ApnContext)msg.obj);
+                } else {
+                    onCleanUpConnection(tearDown, msg.arg2, (String) msg.obj);
+                }
+                break;
+            case DctConstants.EVENT_SET_INTERNAL_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                onSetInternalDataEnabled(enabled, (Message) msg.obj);
+                break;
+            }
+            case DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS:
+                if ((msg.obj != null) && (msg.obj instanceof String == false)) {
+                    msg.obj = null;
+                }
+                onCleanUpAllConnections((String) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DATA_RAT_CHANGED:
+                //May new Network allow setupData, so try it here
+                setupDataOnConnectableApns(Phone.REASON_NW_TYPE_CHANGED,
+                        RetryFailures.ONLY_ON_CHANGE);
+                break;
+
+            case DctConstants.CMD_CLEAR_PROVISIONING_SPINNER:
+                // Check message sender intended to clear the current spinner.
+                if (mProvisioningSpinner == msg.obj) {
+                    mProvisioningSpinner.dismiss();
+                    mProvisioningSpinner = null;
+                }
+                break;
+
+            // M: IA-change attach APN
+            case DctConstants.EVENT_ATTACH_APN_CHANGED:
+                onMdChangedAttachApn((AsyncResult) msg.obj);
+                break;
+
+            //M: FDN Support
+            case DctConstants.EVENT_FDN_CHANGED:
+                onFdnChanged();
+                break;
+
+            case DctConstants.EVENT_RESET_PDP_DONE:
+                logd("EVENT_RESET_PDP_DONE cid=" + msg.arg1);
+                break;
+
+            case DctConstants.EVENT_REMOVE_RESTRICT_EUTRAN:
+                if (MTK_CC33_SUPPORT) {
+                    logd("EVENT_REMOVE_RESTRICT_EUTRAN");
+                    mReregisterOnReconnectFailure = false;
+                    setupDataOnConnectableApns(Phone.REASON_PS_RESTRICT_DISABLED);
+                }
+                break;
+
+            case DctConstants.EVENT_MD_DATA_RETRY_COUNT_RESET:
+                logd("EVENT_MD_DATA_RETRY_COUNT_RESET");
+                setupDataOnConnectableApns(Phone.REASON_MD_DATA_RETRY_COUNT_RESET);
+                break;
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            // TODO: Should this move to NW frameworks to handle?
+            case DctConstants.EVENT_LTE_ACCESS_STRATUM_STATE:
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception == null) {
+                    int[] ints = (int[]) ar.result;
+                    int lteAccessStratumDataState = ints.length > 0 ? ints[0]
+                            : DctConstants.INVALID;
+                    int networkType = ints.length > 1 ? ints[1] : DctConstants.INVALID;
+                    if (lteAccessStratumDataState != LTE_AS_CONNECTED) { // LTE AS Disconnected
+                        notifyPsNetworkTypeChanged(networkType);
+                    } else { // LTE AS Connected
+                        mPhone.notifyPsNetworkTypeChanged(TelephonyManager.NETWORK_TYPE_LTE);
+                    }
+                    logd("EVENT_LTE_ACCESS_STRATUM_STATE lteAccessStratumDataState = "
+                            + lteAccessStratumDataState + ", networkType = " + networkType);
+                    notifyLteAccessStratumChanged(lteAccessStratumDataState);
+                } else {
+                    loge("LteAccessStratumState exception: " + ar.exception);
+                }
+                break;
+
+            case DctConstants.EVENT_DEFAULT_APN_REFERENCE_COUNT_CHANGED: {
+                int newDefaultRefCount = msg.arg1;
+                onSharedDefaultApnState(newDefaultRefCount);
+                break;
+            }
+            // M: [LTE][Low Power][UL traffic shaping] End
+
+            // M: JPN IA Start
+            case DctConstants.EVENT_REG_PLMN_CHANGED:
+                log("handleMessage : <EVENT_REG_PLMN_CHANGED>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    handlePlmnChange((AsyncResult) msg.obj);
+                }
+                break;
+            case DctConstants.EVENT_REG_SUSPENDED:
+                log("handleMessage : <EVENT_REG_SUSPENDED>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    if (isNeedToResumeMd()) {
+                        handleRegistrationSuspend((AsyncResult) msg.obj);
+                    }
+                }
+                break;
+            case DctConstants.EVENT_SET_RESUME:
+                log("handleMessage : <EVENT_SET_RESUME>");
+                if (isOp129IaSupport() || isOp17IaSupport()) {
+                    handleSetResume();
+                }
+                break;
+            // M: JPN IA End
+
+            case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                log("DISCONNECTED_CONNECTED: msg=" + msg);
+                DcAsyncChannel dcac = (DcAsyncChannel) msg.obj;
+                mDataConnectionAcHashMap.remove(dcac.getDataConnectionIdSync());
+                dcac.disconnected();
+                break;
+            }
+            case DctConstants.EVENT_ENABLE_NEW_APN:
+                onEnableApn(msg.arg1, msg.arg2);
+                break;
+
+            case DctConstants.EVENT_DATA_STALL_ALARM:
+                onDataStallAlarm(msg.arg1);
+                break;
+
+            case DctConstants.EVENT_ROAMING_OFF:
+                onRoamingOff();
+                break;
+
+            case DctConstants.EVENT_ROAMING_ON:
+                onRoamingOn();
+                break;
+
+            case DctConstants.EVENT_ROAMING_TYPE_CHANGED:
+                onRoamingTypeChanged();
+                break;
+
+            case DctConstants.EVENT_DEVICE_PROVISIONED_CHANGE:
+                onDeviceProvisionedChange();
+                break;
+
+            case DctConstants.EVENT_REDIRECTION_DETECTED:
+                String url = (String) msg.obj;
+                log("dataConnectionTracker.handleMessage: EVENT_REDIRECTION_DETECTED=" + url);
+                onDataConnectionRedirected(url);
+
+            case DctConstants.EVENT_RADIO_AVAILABLE:
+                onRadioAvailable();
+                break;
+
+            case DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                onRadioOffOrNotAvailable();
+                break;
+
+            case DctConstants.EVENT_DATA_SETUP_COMPLETE:
+                onDataSetupComplete((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DATA_SETUP_COMPLETE_ERROR:
+                onDataSetupCompleteError((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DISCONNECT_DONE:
+                log("DataConnectionTracker.handleMessage: EVENT_DISCONNECT_DONE msg=" + msg);
+                onDisconnectDone((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_DISCONNECT_DC_RETRYING:
+                log("DataConnectionTracker.handleMessage: EVENT_DISCONNECT_DC_RETRYING msg=" + msg);
+                onDisconnectDcRetrying((AsyncResult) msg.obj);
+                break;
+
+            case DctConstants.EVENT_VOICE_CALL_STARTED:
+                onVoiceCallStarted();
+                break;
+
+            case DctConstants.EVENT_VOICE_CALL_ENDED:
+                onVoiceCallEnded();
+                break;
+
+            case DctConstants.EVENT_RESET_DONE: {
+                if (DBG) log("EVENT_RESET_DONE");
+                onResetDone((AsyncResult) msg.obj);
+                break;
+            }
+            case DctConstants.CMD_SET_USER_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                if (DBG) log("CMD_SET_USER_DATA_ENABLE enabled=" + enabled);
+                onSetUserDataEnabled(enabled);
+                break;
+            }
+            // TODO - remove
+            case DctConstants.CMD_SET_DEPENDENCY_MET: {
+                boolean met = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                if (DBG) log("CMD_SET_DEPENDENCY_MET met=" + met);
+                Bundle bundle = msg.getData();
+                if (bundle != null) {
+                    String apnType = (String)bundle.get(DctConstants.APN_TYPE_KEY);
+                    if (apnType != null) {
+                        onSetDependencyMet(apnType, met);
+                    }
+                }
+                break;
+            }
+            case DctConstants.CMD_SET_POLICY_DATA_ENABLE: {
+                final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
+                onSetPolicyDataEnabled(enabled);
+                break;
+            }
+            case DctConstants.CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: {
+                sEnableFailFastRefCounter += (msg.arg1 == DctConstants.ENABLED) ? 1 : -1;
+                if (DBG) {
+                    log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: "
+                            + " sEnableFailFastRefCounter=" + sEnableFailFastRefCounter);
+                }
+                if (sEnableFailFastRefCounter < 0) {
+                    final String s = "CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: "
+                            + "sEnableFailFastRefCounter:" + sEnableFailFastRefCounter + " < 0";
+                    loge(s);
+                    sEnableFailFastRefCounter = 0;
+                }
+                final boolean enabled = sEnableFailFastRefCounter > 0;
+                if (DBG) {
+                    log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: enabled=" + enabled
+                            + " sEnableFailFastRefCounter=" + sEnableFailFastRefCounter);
+                }
+                if (mFailFast != enabled) {
+                    mFailFast = enabled;
+
+                    mDataStallDetectionEnabled = !enabled;
+                    if (mDataStallDetectionEnabled
+                            && (getOverallState() == DctConstants.State.CONNECTED)
+                            && (!mInVoiceCall ||
+                                    mPhone.getServiceStateTracker()
+                                        .isConcurrentVoiceAndDataAllowed())) {
+                        if (DBG) log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: start data stall");
+                        stopDataStallAlarm();
+                        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+                    } else {
+                        if (DBG) log("CMD_SET_ENABLE_FAIL_FAST_MOBILE_DATA: stop data stall");
+                        stopDataStallAlarm();
+                    }
+                }
+
+                break;
+            }
+            case DctConstants.CMD_ENABLE_MOBILE_PROVISIONING: {
+                Bundle bundle = msg.getData();
+                if (bundle != null) {
+                    try {
+                        mProvisioningUrl = (String)bundle.get(DctConstants.PROVISIONING_URL_KEY);
+                    } catch(ClassCastException e) {
+                        loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioning url not a string" + e);
+                        mProvisioningUrl = null;
+                    }
+                }
+                if (TextUtils.isEmpty(mProvisioningUrl)) {
+                    loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioning url is empty, ignoring");
+                    mIsProvisioning = false;
+                    mProvisioningUrl = null;
+                } else {
+                    loge("CMD_ENABLE_MOBILE_PROVISIONING: provisioningUrl=" + mProvisioningUrl);
+                    mIsProvisioning = true;
+                    startProvisioningApnAlarm();
+                }
+                break;
+            }
+            case DctConstants.EVENT_PROVISIONING_APN_ALARM: {
+                if (DBG) log("EVENT_PROVISIONING_APN_ALARM");
+                ApnContext apnCtx = mApnContextsById.get(DctConstants.APN_DEFAULT_ID);
+                if (apnCtx.isProvisioningApn() && apnCtx.isConnectedOrConnecting()) {
+                    if (mProvisioningApnAlarmTag == msg.arg1) {
+                        if (DBG) log("EVENT_PROVISIONING_APN_ALARM: Disconnecting");
+                        mIsProvisioning = false;
+                        mProvisioningUrl = null;
+                        stopProvisioningApnAlarm();
+                        sendCleanUpConnection(true, apnCtx);
+                    } else {
+                        if (DBG) {
+                            log("EVENT_PROVISIONING_APN_ALARM: ignore stale tag,"
+                                    + " mProvisioningApnAlarmTag:" + mProvisioningApnAlarmTag
+                                    + " != arg1:" + msg.arg1);
+                        }
+                    }
+                } else {
+                    if (DBG) log("EVENT_PROVISIONING_APN_ALARM: Not connected ignore");
+                }
+                break;
+            }
+            case DctConstants.CMD_IS_PROVISIONING_APN: {
+                if (DBG) log("CMD_IS_PROVISIONING_APN");
+                boolean isProvApn;
+                try {
+                    String apnType = null;
+                    Bundle bundle = msg.getData();
+                    if (bundle != null) {
+                        apnType = (String)bundle.get(DctConstants.APN_TYPE_KEY);
+                    }
+                    if (TextUtils.isEmpty(apnType)) {
+                        loge("CMD_IS_PROVISIONING_APN: apnType is empty");
+                        isProvApn = false;
+                    } else {
+                        isProvApn = isProvisioningApn(apnType);
+                    }
+                } catch (ClassCastException e) {
+                    loge("CMD_IS_PROVISIONING_APN: NO provisioning url ignoring");
+                    isProvApn = false;
+                }
+                if (DBG) log("CMD_IS_PROVISIONING_APN: ret=" + isProvApn);
+                mReplyAc.replyToMessage(msg, DctConstants.CMD_IS_PROVISIONING_APN,
+                        isProvApn ? DctConstants.ENABLED : DctConstants.DISABLED);
+                break;
+            }
+            case DctConstants.EVENT_ICC_CHANGED: {
+                onUpdateIcc();
+                break;
+            }
+            case DctConstants.EVENT_RESTART_RADIO: {
+                restartRadio();
+                break;
+            }
+            case DctConstants.CMD_NET_STAT_POLL: {
+                if (msg.arg1 == DctConstants.ENABLED) {
+                    handleStartNetStatPoll((DctConstants.Activity)msg.obj);
+                } else if (msg.arg1 == DctConstants.DISABLED) {
+                    handleStopNetStatPoll((DctConstants.Activity)msg.obj);
+                }
+                break;
+            }
+            case DctConstants.EVENT_DATA_STATE_CHANGED: {
+                // no longer do anything, but still registered - clean up log
+                // TODO - why are we still registering?
+                break;
+            }
+            case DctConstants.EVENT_PCO_DATA_RECEIVED: {
+                handlePcoData((AsyncResult)msg.obj);
+                break;
+            }
+            case DctConstants.EVENT_SET_CARRIER_DATA_ENABLED:
+                onSetCarrierDataEnabled(msg.arg1 == DctConstants.ENABLED);
+                break;
+
+            // M: Multi-PS Attach Start
+            case DctConstants.EVENT_DATA_ALLOWED:
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.result != null) {
+                    int[] ints = (int[]) ar.result;
+                    boolean allowed = ints[0] == 1 ? true : false;
+                    onAllowChanged(allowed);
+                } else {
+                    loge("Parameter error: ret should not be NULL");
+                }
+                break;
+            // M: Multi-PS Attach End
+
+            //Reset Attach Apn
+            case DctConstants.EVENT_RESET_ATTACH_APN: {
+                if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+                    setInitialAttachApn();
+                } else {
+                    if (DBG) {
+                        log("EVENT_RESET_ATTACH_APN: Ignore due to null APN list");
+                    }
+                }
+                break;
+            }
+            case DctConstants.EVENT_PCO_STATUS:
+                onPcoStatus((AsyncResult) msg.obj);
+                break;
+            // M: Handle the event EVENT_DATA_ENABLED_SETTINGS
+            case DctConstants.EVENT_DATA_ENABLED_SETTINGS:
+                ar = (AsyncResult) msg.obj;
+                if (ar.result instanceof Pair) {
+                    Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
+                    onDataEnabledSettings(p.first, p.second);
+                }
+                break;
+            default:
+                Rlog.e("DcTracker", "Unhandled event=" + msg);
+                break;
+
+        }
+    }
+
+    private int getApnProfileID(String apnType) {
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
+            return RILConstants.DATA_PROFILE_IMS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_FOTA)) {
+            return RILConstants.DATA_PROFILE_FOTA;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CBS)) {
+            return RILConstants.DATA_PROFILE_CBS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IA)) {
+            return RILConstants.DATA_PROFILE_DEFAULT; // DEFAULT for now
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
+            return RILConstants.DATA_PROFILE_TETHERED;
+        // M: VDF MMS over ePDG @{
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) {
+            return RILConstants.DATA_PROFILE_MMS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_SUPL)) {
+            return RILConstants.DATA_PROFILE_SUPL;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_HIPRI)) {
+            return RILConstants.DATA_PROFILE_HIPRI;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DM)) {
+            return RILConstants.DATA_PROFILE_DM;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_WAP)) {
+            return RILConstants.DATA_PROFILE_WAP;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_NET)) {
+            return RILConstants.DATA_PROFILE_NET;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CMMAIL)) {
+            return RILConstants.DATA_PROFILE_CMMAIL;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_RCSE)) {
+            return RILConstants.DATA_PROFILE_RCSE;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_EMERGENCY)) {
+            return RILConstants.DATA_PROFILE_EMERGENCY;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_XCAP)) {
+            return RILConstants.DATA_PROFILE_XCAP;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_RCS)) {
+            return RILConstants.DATA_PROFILE_RCS;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)) {
+            return RILConstants.DATA_PROFILE_DEFAULT;
+        } else {
+        /// @}
+            return RILConstants.DATA_PROFILE_INVALID;
+        }
+    }
+
+    private int getCellLocationId() {
+        int cid = -1;
+        CellLocation loc = mPhone.getCellLocation();
+
+        if (loc != null) {
+            if (loc instanceof GsmCellLocation) {
+                cid = ((GsmCellLocation)loc).getCid();
+            } else if (loc instanceof CdmaCellLocation) {
+                cid = ((CdmaCellLocation)loc).getBaseStationId();
+            }
+        }
+        return cid;
+    }
+
+    private IccRecords getUiccRecords(int appFamily) {
+        return mUiccController.getIccRecords(mPhone.getPhoneId(), appFamily);
+    }
+
+
+    private void onUpdateIcc() {
+        if (mUiccController == null ) {
+            return;
+        }
+
+        IccRecords newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
+
+        // M: Fix AOSP always get 3GPP when Phone is CDMA.
+        if (newIccRecords == null && mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+            // M:  CDMALTEPhone gets 3GPP above, pure CDMA card gets 3GPP2 here.
+            newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP2);
+        }
+
+        IccRecords r = mIccRecords.get();
+
+        // As UiccController always notify 2 SIMs, If only have 1 SIM, no need print this log
+        if (newIccRecords != null || r != null) {
+            logd("onUpdateIcc: newIccRecords=" + newIccRecords + ", r=" + r);
+        }
+
+        if (r != newIccRecords) {
+            if (r != null) {
+                log("Removing stale icc objects.");
+                r.unregisterForRecordsLoaded(this);
+                mIccRecords.set(null);
+            }
+            if (newIccRecords != null) {
+                if (SubscriptionManager.isValidSubscriptionId(mPhone.getSubId())) {
+                    log("New records found.");
+                    mIccRecords.set(newIccRecords);
+                    newIccRecords.registerForRecordsLoaded(
+                            this, DctConstants.EVENT_RECORDS_LOADED, null);
+                    // reset carrier actions on sim loaded
+                    final ServiceStateTracker sst = mPhone.getServiceStateTracker();
+                    sst.setRadioPowerFromCarrier(true);
+                    mDataEnabledSettings.setCarrierDataEnabled(true);
+                    mPhone.getCarrierSignalAgent().reset();
+                }
+            } else {
+                onSimNotReady();
+            }
+        }
+
+        if (mAllApnSettings != null && r == null && newIccRecords == null) {
+            // M: clear mAllApnSettings in main thread to avoid concurrent access exception.
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    if (VDBG) {
+                        logTel("onUpdateIcc: clear mAllApnSettings, " +
+                                (mAllApnSettings != null));
+                    }
+                    if (mAllApnSettings != null) {
+                        mAllApnSettings.clear();
+                    }
+                }
+            });
+        }
+
+        //MTK START: FDN Support
+        UiccCardApplication app = mUiccCardApplication.get();
+        UiccCardApplication newUiccCardApp = mUiccController.getUiccCardApplication(
+                mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA ?
+                UiccController.APP_FAM_3GPP2 : UiccController.APP_FAM_3GPP);
+
+        if (app != newUiccCardApp) {
+            if (app != null) {
+                log("Removing stale UiccCardApplication objects.");
+                app.unregisterForFdnChanged(this);
+                mUiccCardApplication.set(null);
+            }
+
+            if (newUiccCardApp != null) {
+                log("New UiccCardApplication found");
+                newUiccCardApp.registerForFdnChanged(this, DctConstants.EVENT_FDN_CHANGED, null);
+                mUiccCardApplication.set(newUiccCardApp);
+            }
+        }
+        //MTK END: FDN Support
+    }
+
+    public void update() {
+        log("update sub = " + mPhone.getSubId());
+        onUpdateIcc();
+        synchronized (mDataEnabledSettings) {
+            mDataEnabledSettings.setUserDataEnabled(getDataEnabled());
+        }
+        mAutoAttachOnCreation.set(false);
+
+        ((GsmCdmaPhone)mPhone).updateCurrentCarrierInProvider();
+    }
+
+    public void cleanUpAllConnections(String cause) {
+        cleanUpAllConnections(cause, null);
+    }
+
+    public void updateRecords() {
+        onUpdateIcc();
+    }
+
+    public void cleanUpAllConnections(String cause, Message disconnectAllCompleteMsg) {
+        log("cleanUpAllConnections");
+        if (disconnectAllCompleteMsg != null) {
+            mDisconnectAllCompleteMsgList.add(disconnectAllCompleteMsg);
+        }
+
+        Message msg = obtainMessage(DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS);
+        msg.obj = cause;
+        sendMessage(msg);
+    }
+
+    private void notifyDataDisconnectComplete() {
+        log("notifyDataDisconnectComplete");
+        for (Message m: mDisconnectAllCompleteMsgList) {
+            m.sendToTarget();
+        }
+        mDisconnectAllCompleteMsgList.clear();
+    }
+
+
+    private void notifyAllDataDisconnected() {
+        sEnableFailFastRefCounter = 0;
+        mFailFast = false;
+        mAllDataDisconnectedRegistrants.notifyRegistrants();
+    }
+
+    public void registerForAllDataDisconnected(Handler h, int what, Object obj) {
+        mAllDataDisconnectedRegistrants.addUnique(h, what, obj);
+
+        if (isDisconnected()) {
+            log("notify All Data Disconnected");
+            notifyAllDataDisconnected();
+        }
+    }
+
+    public void unregisterForAllDataDisconnected(Handler h) {
+        mAllDataDisconnectedRegistrants.remove(h);
+    }
+
+    public void registerForDataEnabledChanged(Handler h, int what, Object obj) {
+        mDataEnabledSettings.registerForDataEnabledChanged(h, what, obj);
+    }
+
+    public void unregisterForDataEnabledChanged(Handler h) {
+        mDataEnabledSettings.unregisterForDataEnabledChanged(h);
+    }
+
+    private void onSetInternalDataEnabled(boolean enabled, Message onCompleteMsg) {
+        synchronized (mDataEnabledSettings) {
+            if (DBG) log("onSetInternalDataEnabled: enabled=" + enabled);
+            boolean sendOnComplete = true;
+
+            mDataEnabledSettings.setInternalDataEnabled(enabled);
+            if (enabled) {
+                log("onSetInternalDataEnabled: changed to enabled, try to setup data call");
+                onTrySetupData(Phone.REASON_DATA_ENABLED);
+            } else {
+                sendOnComplete = false;
+                log("onSetInternalDataEnabled: changed to disabled, cleanUpAllConnections");
+                cleanUpAllConnections(Phone.REASON_DATA_DISABLED, onCompleteMsg);
+            }
+
+            if (sendOnComplete) {
+                if (onCompleteMsg != null) {
+                    onCompleteMsg.sendToTarget();
+                }
+            }
+        }
+    }
+
+    public boolean setInternalDataEnabled(boolean enable) {
+        return setInternalDataEnabled(enable, null);
+    }
+
+    public boolean setInternalDataEnabled(boolean enable, Message onCompleteMsg) {
+        if (DBG) log("setInternalDataEnabled(" + enable + ")");
+
+        Message msg = obtainMessage(DctConstants.EVENT_SET_INTERNAL_DATA_ENABLE, onCompleteMsg);
+        msg.arg1 = (enable ? DctConstants.ENABLED : DctConstants.DISABLED);
+        sendMessage(msg);
+        return true;
+    }
+
+    private void log(String s) {
+        // AOSP by default using Rlog.d()
+        logd(s);
+    }
+
+    private void loge(String s) {
+        Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logw(String s) {
+        Rlog.w(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logi(String s) {
+        // default user/userdebug debug level set as INFO
+        Rlog.i(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logd(String s) {
+        // default eng debug level set as DEBUG
+        Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logv(String s) {
+        Rlog.v(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
+    }
+
+    private void logTel(String s) {
+        if (TEL_DBG > 0) {
+            logd(s);
+        } else {
+            logv(s);
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("DcTracker:");
+        pw.println(" RADIO_TESTS=" + RADIO_TESTS);
+        pw.println(" isInternalDataEnabled=" + mDataEnabledSettings.isInternalDataEnabled());
+        pw.println(" isUserDataEnabled=" + mDataEnabledSettings.isUserDataEnabled());
+        pw.println(" isPolicyDataEnabled=" + mDataEnabledSettings.isPolicyDataEnabled());
+        pw.flush();
+        pw.println(" mRequestedApnType=" + mRequestedApnType);
+        pw.println(" mPhone=" + mPhone.getPhoneName());
+        pw.println(" mActivity=" + mActivity);
+        pw.println(" mState=" + mState);
+        pw.println(" mTxPkts=" + mTxPkts);
+        pw.println(" mRxPkts=" + mRxPkts);
+        pw.println(" mNetStatPollPeriod=" + mNetStatPollPeriod);
+        pw.println(" mNetStatPollEnabled=" + mNetStatPollEnabled);
+        pw.println(" mDataStallTxRxSum=" + mDataStallTxRxSum);
+        pw.println(" mDataStallAlarmTag=" + mDataStallAlarmTag);
+        pw.println(" mDataStallDetectionEnabled=" + mDataStallDetectionEnabled);
+        pw.println(" mSentSinceLastRecv=" + mSentSinceLastRecv);
+        pw.println(" mNoRecvPollCount=" + mNoRecvPollCount);
+        pw.println(" mResolver=" + mResolver);
+        pw.println(" mIsWifiConnected=" + mIsWifiConnected);
+        pw.println(" mReconnectIntent=" + mReconnectIntent);
+        pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation.get());
+        pw.println(" mIsScreenOn=" + mIsScreenOn);
+        pw.println(" mUniqueIdGenerator=" + mUniqueIdGenerator);
+        pw.flush();
+        pw.println(" ***************************************");
+        DcController dcc = mDcc;
+        if (dcc != null) {
+            dcc.dump(fd, pw, args);
+        } else {
+            pw.println(" mDcc=null");
+        }
+        pw.println(" ***************************************");
+        HashMap<Integer, DataConnection> dcs = mDataConnections;
+        if (dcs != null) {
+            Set<Entry<Integer, DataConnection> > mDcSet = mDataConnections.entrySet();
+            pw.println(" mDataConnections: count=" + mDcSet.size());
+            for (Entry<Integer, DataConnection> entry : mDcSet) {
+                pw.printf(" *** mDataConnection[%d] \n", entry.getKey());
+                entry.getValue().dump(fd, pw, args);
+            }
+        } else {
+            pw.println("mDataConnections=null");
+        }
+        pw.println(" ***************************************");
+        pw.flush();
+        HashMap<String, Integer> apnToDcId = mApnToDataConnectionId;
+        if (apnToDcId != null) {
+            Set<Entry<String, Integer>> apnToDcIdSet = apnToDcId.entrySet();
+            pw.println(" mApnToDataConnectonId size=" + apnToDcIdSet.size());
+            for (Entry<String, Integer> entry : apnToDcIdSet) {
+                pw.printf(" mApnToDataConnectonId[%s]=%d\n", entry.getKey(), entry.getValue());
+            }
+        } else {
+            pw.println("mApnToDataConnectionId=null");
+        }
+        pw.println(" ***************************************");
+        pw.flush();
+        ConcurrentHashMap<String, ApnContext> apnCtxs = mApnContexts;
+        if (apnCtxs != null) {
+            Set<Entry<String, ApnContext>> apnCtxsSet = apnCtxs.entrySet();
+            pw.println(" mApnContexts size=" + apnCtxsSet.size());
+            for (Entry<String, ApnContext> entry : apnCtxsSet) {
+                entry.getValue().dump(fd, pw, args);
+            }
+            pw.println(" ***************************************");
+        } else {
+            pw.println(" mApnContexts=null");
+        }
+        pw.flush();
+        ArrayList<ApnSetting> apnSettings = mAllApnSettings;
+        if (apnSettings != null) {
+            pw.println(" mAllApnSettings size=" + apnSettings.size());
+            for (int i=0; i < apnSettings.size(); i++) {
+                pw.printf(" mAllApnSettings[%d]: %s\n", i, apnSettings.get(i));
+            }
+            pw.flush();
+        } else {
+            pw.println(" mAllApnSettings=null");
+        }
+        pw.println(" mPreferredApn=" + mPreferredApn);
+        pw.println(" mIsPsRestricted=" + mIsPsRestricted);
+        pw.println(" mIsDisposed=" + mIsDisposed);
+        pw.println(" mIntentReceiver=" + mIntentReceiver);
+        pw.println(" mReregisterOnReconnectFailure=" + mReregisterOnReconnectFailure);
+        pw.println(" canSetPreferApn=" + mCanSetPreferApn);
+        pw.println(" mApnObserver=" + mApnObserver);
+        pw.println(" getOverallState=" + getOverallState());
+        pw.println(" mDataConnectionAsyncChannels=%s\n" + mDataConnectionAcHashMap);
+        pw.println(" mAttached=" + mAttached.get());
+        pw.flush();
+    }
+
+    public String[] getPcscfAddress(String apnType) {
+        log("getPcscfAddress()");
+        ApnContext apnContext = null;
+
+        if(apnType == null){
+            log("apnType is null, return null");
+            return null;
+        }
+
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_EMERGENCY)) {
+            apnContext = mApnContextsById.get(DctConstants.APN_EMERGENCY_ID);
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
+            apnContext = mApnContextsById.get(DctConstants.APN_IMS_ID);
+        } else {
+            log("apnType is invalid, return null");
+            return null;
+        }
+
+        if (apnContext == null) {
+            log("apnContext is null, return null");
+            return null;
+        }
+
+        DcAsyncChannel dcac = apnContext.getDcAc();
+        String[] result = null;
+
+        if (dcac != null) {
+            result = dcac.getPcscfAddr();
+
+            for (int i = 0; i < result.length; i++) {
+                log("Pcscf[" + i + "]: " + result[i]);
+            }
+            return result;
+        }
+        return null;
+    }
+
+    /**
+     * Read APN configuration from Telephony.db for Emergency APN
+     * All opertors recognize the connection request for EPDN based on APN type
+     * PLMN name,APN name are not mandatory parameters
+     */
+    private void initEmergencyApnSetting() {
+        if (mEmergencyApn == null) {
+            // Operator Numeric is not available when sim records are not loaded.
+            // Query Telephony.db with APN type as EPDN request does not
+            // require APN name, plmn and all operators support same APN config.
+            // DB will contain only one entry for Emergency APN
+            /// M: We cannot get common emergency apn at first place in cursor, add empty numeric
+            //     as selection, can get only one emergency
+            String selection = "type=\"emergency\" and numeric=''";
+            Cursor cursor = mPhone.getContext().getContentResolver().query(
+                    Telephony.Carriers.CONTENT_URI, null, selection, null, null);
+            if (cursor != null) {
+                if (cursor.getCount() > 0) {
+                    if (cursor.moveToFirst()) {
+                        mEmergencyApn = makeApnSetting(cursor);
+                        log("Loaded default emergency APN: " + mEmergencyApn);
+                    }
+                } else {
+                    log("No record for emergency APN");
+                }
+                cursor.close();
+            } else {
+                log("No emergency APN found in DB");
+            }
+        } else {
+            log("mEmergencyApn already loaded: " + mEmergencyApn);
+        }
+    }
+
+    /**
+     * Add the Emergency APN settings to APN settings list
+     */
+    private void addEmergencyApnSetting() {
+        if(mEmergencyApn != null) {
+            if(mAllApnSettings == null) {
+                mAllApnSettings = new ArrayList<ApnSetting>();
+            } else {
+                boolean hasEmergencyApn = false;
+                for (ApnSetting apn : mAllApnSettings) {
+                    if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)) {
+                        hasEmergencyApn = true;
+                        break;
+                    }
+                }
+
+                if(hasEmergencyApn == false) {
+                    mAllApnSettings.add(mEmergencyApn);
+                } else {
+                    log("addEmergencyApnSetting - E-APN setting is already present");
+                }
+            }
+        }
+    }
+
+    private void cleanUpConnectionsOnUpdatedApns(boolean tearDown) {
+        if (DBG) log("cleanUpConnectionsOnUpdatedApns: tearDown=" + tearDown);
+        if (mAllApnSettings.isEmpty()) {
+            cleanUpAllConnections(tearDown, Phone.REASON_APN_CHANGED);
+        } else {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                if (VDBG) log("cleanUpConnectionsOnUpdatedApns for "+ apnContext);
+
+                boolean cleanUpApn = true;
+                ArrayList<ApnSetting> currentWaitingApns = apnContext.getWaitingApns();
+
+                if ((currentWaitingApns != null) && (!apnContext.isDisconnected())) {
+                    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+                    ArrayList<ApnSetting> waitingApns = buildWaitingApns(
+                            apnContext.getApnType(), radioTech);
+                    if (VDBG) log("new waitingApns:" + waitingApns);
+                    if (waitingApns.size() == currentWaitingApns.size()) {
+                        cleanUpApn = false;
+                        for (int i = 0; i < waitingApns.size(); i++) {
+                            final String currentWaitingApn =
+                                    currentWaitingApns.get(i).toStringIgnoreName(!VZW_FEATURE);
+                            final String waitingApn = waitingApns.get(i).toStringIgnoreName(
+                                    !VZW_FEATURE);
+                            if (!TextUtils.equals(currentWaitingApn, waitingApn)) {
+                                if (VDBG) log("new waiting apn is different at " + i);
+                                cleanUpApn = true;
+                                apnContext.setWaitingApns(waitingApns);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                if (cleanUpApn) {
+                    apnContext.setReason(Phone.REASON_APN_CHANGED);
+                    cleanUpConnection(true, apnContext);
+                }
+            }
+        }
+
+        if (!isConnected()) {
+            stopNetStatPoll();
+            stopDataStallAlarm();
+        }
+
+        mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
+
+        if (DBG) log("mDisconnectPendingCount = " + mDisconnectPendingCount);
+        if (tearDown && mDisconnectPendingCount == 0) {
+            notifyDataDisconnectComplete();
+            notifyAllDataDisconnected();
+        }
+    }
+
+    /** M: throttling/high throughput
+     *  Used to specified the maximum concurrent data connections
+     */
+    protected int getPdpConnectionPoolSize() {
+        //here we keep the last DataConnection for low throughput APN
+        //so the pool size is the maximum value - 1
+        if (isSupportThrottlingApn()) {
+            return THROTTLING_MAX_PDP_SIZE;
+        } else {
+            //here we keep the last DataConnection for low throughput APN
+            //so the pool size is the maximum value - 1
+            return PDP_CONNECTION_POOL_SIZE - 1 > 0 ? PDP_CONNECTION_POOL_SIZE - 1 : 1;
+        }
+    }
+
+    private boolean isSupportThrottlingApn() {
+        return (THROTTLING_APN_ENABLED || (SystemProperties.getInt(
+                PROPERTY_THROTTLING_APN_ENABLED, 0) == 1));
+    }
+
+    private int generateDataConnectionId(String reqApnType, ApnSetting apnSetting) {
+        int id = -1;
+        // 0: internet, 1: tethering, 2~3: others, 4~6: IMS (non-throttling), 7: eMBMS
+        AtomicInteger idGenerator = mOthersUniqueIdGenerator;
+        for (String apn : HIGH_THROUGHPUT_APN) {
+            if (apnSetting != null && apnSetting.canHandleType(apn)
+                    && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)
+                    && !apnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS)) {
+                idGenerator = mHighThroughputIdGenerator;
+                logd("generateDataConnectionId use high throughput DataConnection id generator");
+                break;
+            }
+        }
+        if (idGenerator != mHighThroughputIdGenerator) {
+            for (String apn : IMS_APN) {
+                if (PhoneConstants.APN_TYPE_EMERGENCY.equals(apn)
+                        && !PhoneConstants.APN_TYPE_EMERGENCY.equals(reqApnType)) {
+                    //skip since not request emergency apn
+                } else {
+                    if (apnSetting != null && apnSetting.canHandleType(apn)) {
+                        int idStart = MIN_ID_IMS_TROUGHPUT;
+                        if (PhoneConstants.APN_TYPE_EMERGENCY.equals(apn)) {
+                            idStart += 1;
+                        }
+                        // Set IMS: 4, EIMS: 5 for interface (fixed the interface)
+                        mImsUniqueIdGenerator.set(idStart);
+                        idGenerator = mImsUniqueIdGenerator;
+                        logd("generateDataConnectionId use ims DataConnection id generator");
+                        break;
+                    }
+                }
+            }
+        }
+
+        id = idGenerator.getAndIncrement();
+        if (idGenerator == mHighThroughputIdGenerator && id > MAX_ID_HIGH_TROUGHPUT) {
+            loge("Max id of highthrouthput is " + MAX_ID_HIGH_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        } else if (idGenerator == mOthersUniqueIdGenerator && id > MAX_ID_OTHERS_TROUGHPUT) {
+            loge("Max id of others is " + MAX_ID_OTHERS_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        } else if (idGenerator == mImsUniqueIdGenerator && id > MAX_ID_IMS_TROUGHPUT) {
+            loge("Max id of others is " + MAX_ID_IMS_TROUGHPUT
+                    + ", but generated id is " + id);
+            idGenerator.getAndDecrement();
+            id = -1;
+        }
+        log("generateDataConnectionId id = " + id);
+        return id;
+    }
+
+    // MTK
+    public void deactivatePdpByCid(int cid) {
+        mPhone.mCi.deactivateDataCall(cid, RILConstants.DEACTIVATE_REASON_PDP_RESET,
+                                      obtainMessage(DctConstants.EVENT_RESET_PDP_DONE, cid, 0));
+    }
+
+    // M: isVsimActive.
+    public boolean isVsimActive(int phoneId) {
+        int phoneNum = TelephonyManager.getDefault().getPhoneCount();
+        String vsimEnabled = null;
+        int act = 0 ;
+
+        for (int id = 0 ; id < phoneNum ; id++) {
+            if (id != phoneId) {
+                vsimEnabled = TelephonyManager.getDefault().getTelephonyProperty(
+                        id, PROPERTY_VSIM_ENABLE, "0");
+                act = ((vsimEnabled.isEmpty()) ? 0 : Integer.parseInt(vsimEnabled));
+                if (act == 2) {
+                    logd("Remote Vsim enabled on phone " + id +
+                            " and downloaded by phone" + phoneId);
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * M: syncApnToMd. Request for sync APN table to MD.
+     * apn;user;password;type(default,mms,...);protocol;roaming_protocol;
+     * authtype;carrier_enabled;max_conns;max_conns_time;wait_time;bearer_bitmask;inactive_timer
+     */
+    private void syncApnToMd() {
+        ArrayList<String> aryApn = null;
+        StringBuilder sb = null;
+        ArrayList<ApnSetting> tmpAllApnSettings = new ArrayList<ApnSetting>();
+        ApnSetting dunApnSetting = fetchDunApn();
+        boolean bAddDunApnSettingToList = true;
+
+        // create a temp 'tmpAllApnSettings' to copy from 'mAllApnSettings'
+        if (mAllApnSettings != null) {
+            tmpAllApnSettings.addAll(mAllApnSettings);
+        }
+
+        // check fetchDunApn() if return null, if not,
+        // then check the apn name if exist, if not, add it to 'tmpAllApnSettings'
+        if (dunApnSetting != null) {
+            tmpAllApnSettings.add(dunApnSetting);
+        }
+
+        if (!tmpAllApnSettings.isEmpty()) {
+            aryApn = new ArrayList<String>();
+            for (ApnSetting apn : tmpAllApnSettings) {
+                sb = new StringBuilder();
+                // Replace ";" with "/3B" to prevent the misjudgement of delimiter
+                String tmp = null;
+                if (apn.apn != null) {
+                    tmp = apn.apn.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (apn.user != null) {
+                    tmp = apn.user.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (apn.password != null) {
+                    tmp = apn.password.replace(";", "/3B");
+                    sb.append(tmp);
+                }
+                sb.append(";");
+                if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_ALL)) {
+                    for (int j = 0; j < PhoneConstants.APN_TYPES.length; j++) {
+                        sb.append(PhoneConstants.APN_TYPES[j]);
+                        if (j < (PhoneConstants.APN_TYPES.length - 1)) {
+                            sb.append(",");
+                        }
+                    }
+                } else {
+                    for (int j = 0; j < apn.types.length; j++) {
+                        sb.append(apn.types[j]);
+                        if (j < (apn.types.length - 1)) {
+                            sb.append(",");
+                        }
+                    }
+                }
+                sb.append(";");
+                sb.append(apn.protocol);
+                sb.append(";");
+                sb.append(apn.roamingProtocol);
+                sb.append(";");
+                int authType = apn.authType;
+                if (authType == -1) {
+                    authType = TextUtils.isEmpty(apn.user) ? RILConstants.SETUP_DATA_AUTH_NONE
+                            : RILConstants.SETUP_DATA_AUTH_PAP_CHAP;
+                }
+                sb.append(authType);
+                sb.append(";");
+                sb.append(apn.carrierEnabled ? 1 : 0);
+                sb.append(";");
+                sb.append(apn.maxConns);
+                sb.append(";");
+                sb.append(apn.maxConnsTime);
+                sb.append(";");
+                sb.append(apn.waitTime);
+                sb.append(";");
+                sb.append(apn.bearerBitmask);
+                sb.append(";");
+                sb.append(apn.inactiveTimer);
+                log("syncApnToMd: apn: " + sb.toString());
+                aryApn.add(sb.toString());
+            }
+            if (aryApn.size() > 0) {
+                mPhone.mCi.syncApnTable(aryApn.toArray(new String[aryApn.size()]), null);
+            }
+        } else {
+            log("syncApnToMd: tmpAllApnSettings is empty!");
+        }
+    }
+
+    /**
+     * M: getClassType.
+     *
+     * @param apn ApnSetting
+     * @return int for class type
+     */
+    public int getClassType(ApnSetting apn) {
+        int classType = APN_CLASS_3;
+
+        if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)
+            || VZW_EMERGENCY_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_0;
+        } else if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IMS)
+            || VZW_IMS_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_1;
+        } else if (VZW_ADMIN_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_2;
+        } else if (VZW_APP_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_4;
+        } else if (VZW_800_NI.compareToIgnoreCase(apn.apn) == 0) {
+            classType = APN_CLASS_5;
+        } else if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_DEFAULT)) {
+            classType = APN_CLASS_3;
+        } else {
+            log("getClassType: set to default class 3");
+        }
+
+        logd("getClassType:" + classType);
+        return classType;
+    }
+
+    /**
+     * M: getClassTypeApn.
+     *
+     * @param classType APN class type
+     * @return ApnSetting for class type apn
+     */
+    public ApnSetting getClassTypeApn(int classType) {
+        ApnSetting classTypeApn = null;
+        String apnName = "";
+
+        if (APN_CLASS_0 == classType) {
+            apnName = VZW_EMERGENCY_NI;
+        } else if (APN_CLASS_1 == classType) {
+            apnName = VZW_IMS_NI;
+        } else if (APN_CLASS_2 == classType) {
+            apnName = VZW_ADMIN_NI;
+        } else if (APN_CLASS_3 == classType) {
+            apnName = VZW_INTERNET_NI;
+        } else if (APN_CLASS_4 == classType) {
+            apnName = VZW_APP_NI;
+        } else if (APN_CLASS_5 == classType) {
+            apnName = VZW_800_NI;
+        } else {
+            log("getClassTypeApn: can't handle class:" + classType);
+            return null;
+        }
+
+        if (mAllApnSettings != null) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (apnName.compareToIgnoreCase(apn.apn) == 0) {
+                    classTypeApn = apn;
+                }
+            }
+        }
+
+        logd("getClassTypeApn:" + classTypeApn + ", class:" + classType);
+        return classTypeApn;
+    }
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    private void onSharedDefaultApnState(int newDefaultRefCount) {
+        logd("onSharedDefaultApnState: newDefaultRefCount = " + newDefaultRefCount
+                + ", curDefaultRefCount = " + mDefaultRefCount);
+
+        if(newDefaultRefCount != mDefaultRefCount) {
+            if (newDefaultRefCount > 1) {
+                mIsSharedDefaultApn = true;
+            } else {
+                mIsSharedDefaultApn = false;
+            }
+            mDefaultRefCount = newDefaultRefCount;
+            logd("onSharedDefaultApnState: mIsSharedDefaultApn = " + mIsSharedDefaultApn);
+            notifySharedDefaultApn(mIsSharedDefaultApn);
+        }
+    }
+
+    public void onSetLteAccessStratumReport(boolean enabled, Message response) {
+        mPhone.mCi.setLteAccessStratumReport(enabled, response);
+    }
+
+    public void onSetLteUplinkDataTransfer(int timeMillis, Message response) {
+        for(ApnContext apnContext : mApnContexts.values()) {
+            if(PhoneConstants.APN_TYPE_DEFAULT.equals(apnContext.getApnType())) {
+                try {
+                    int interfaceId = apnContext.getDcAc().getCidSync();
+                    mPhone.mCi.setLteUplinkDataTransfer(timeMillis, interfaceId, response);
+                } catch (Exception e) {
+                    loge("getDcAc fail!");
+                    e.printStackTrace();
+                    if (response != null) {
+                        AsyncResult.forMessage(response, null,
+                                new CommandException(CommandException.Error.GENERIC_FAILURE));
+                        response.sendToTarget();
+                    }
+                }
+            }
+        }
+    }
+
+    private void notifySharedDefaultApn(boolean isSharedDefaultApn) {
+        mPhone.notifySharedDefaultApnStateChanged(isSharedDefaultApn);
+    }
+
+    // TODO: Should this move to NW frameworks to handle?
+    private void notifyLteAccessStratumChanged(int lteAccessStratumDataState) {
+        mLteAccessStratumDataState = (lteAccessStratumDataState == LTE_AS_CONNECTED) ?
+                PhoneConstants.LTE_ACCESS_STRATUM_STATE_CONNECTED :
+                PhoneConstants.LTE_ACCESS_STRATUM_STATE_IDLE;
+        logd("notifyLteAccessStratumChanged mLteAccessStratumDataState = "
+                + mLteAccessStratumDataState);
+        mPhone.notifyLteAccessStratumChanged(mLteAccessStratumDataState);
+    }
+
+    // TODO: Should this move to NW frameworks to handle?
+    private void notifyPsNetworkTypeChanged(int newRilNwType) {
+        int newNwType = mPhone.getServiceState().rilRadioTechnologyToNetworkTypeEx(newRilNwType);
+        logd("notifyPsNetworkTypeChanged mNetworkType = " + mNetworkType
+                + ", newNwType = " + newNwType
+                + ", newRilNwType = " + newRilNwType);
+        if (newNwType != mNetworkType) {
+            mNetworkType = newNwType;
+            mPhone.notifyPsNetworkTypeChanged(mNetworkType);
+        }
+    }
+
+    public String getLteAccessStratumState() {
+        return mLteAccessStratumDataState;
+    }
+
+    public boolean isSharedDefaultApn() {
+        return mIsSharedDefaultApn;
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Polling stuff
+     */
+    private void resetPollStats() {
+        mTxPkts = -1;
+        mRxPkts = -1;
+        mNetStatPollPeriod = POLL_NETSTAT_MILLIS;
+    }
+
+    private void startNetStatPoll() {
+        if (getOverallState() == DctConstants.State.CONNECTED
+                && mNetStatPollEnabled == false) {
+            if (DBG) {
+                log("startNetStatPoll");
+            }
+            resetPollStats();
+            mNetStatPollEnabled = true;
+            mPollNetStat.run();
+        }
+        if (mPhone != null) {
+            mPhone.notifyDataActivity();
+        }
+    }
+
+    private void stopNetStatPoll() {
+        mNetStatPollEnabled = false;
+        removeCallbacks(mPollNetStat);
+        if (DBG) {
+            log("stopNetStatPoll");
+        }
+
+        // To sync data activity icon in the case of switching data connection to send MMS.
+        if (mPhone != null) {
+            mPhone.notifyDataActivity();
+        }
+    }
+
+    public void sendStartNetStatPoll(DctConstants.Activity activity) {
+        Message msg = obtainMessage(DctConstants.CMD_NET_STAT_POLL);
+        msg.arg1 = DctConstants.ENABLED;
+        msg.obj = activity;
+        sendMessage(msg);
+    }
+
+    private void handleStartNetStatPoll(DctConstants.Activity activity) {
+        startNetStatPoll();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+        setActivity(activity);
+    }
+
+    public void sendStopNetStatPoll(DctConstants.Activity activity) {
+        Message msg = obtainMessage(DctConstants.CMD_NET_STAT_POLL);
+        msg.arg1 = DctConstants.DISABLED;
+        msg.obj = activity;
+        sendMessage(msg);
+    }
+
+    private void handleStopNetStatPoll(DctConstants.Activity activity) {
+        stopNetStatPoll();
+        stopDataStallAlarm();
+        setActivity(activity);
+    }
+
+    private void updateDataActivity() {
+        long sent, received;
+
+        DctConstants.Activity newActivity;
+
+        TxRxSum preTxRxSum = new TxRxSum(mTxPkts, mRxPkts);
+        TxRxSum curTxRxSum = new TxRxSum();
+        curTxRxSum.updateTxRxSum();
+        mTxPkts = curTxRxSum.txPkts;
+        mRxPkts = curTxRxSum.rxPkts;
+
+        if (VDBG) {
+            log("updateDataActivity: curTxRxSum=" + curTxRxSum + " preTxRxSum=" + preTxRxSum);
+        }
+
+        if (mNetStatPollEnabled && (preTxRxSum.txPkts > 0 || preTxRxSum.rxPkts > 0)) {
+            sent = mTxPkts - preTxRxSum.txPkts;
+            received = mRxPkts - preTxRxSum.rxPkts;
+
+            if (VDBG)
+                log("updateDataActivity: sent=" + sent + " received=" + received);
+            if (sent > 0 && received > 0) {
+                newActivity = DctConstants.Activity.DATAINANDOUT;
+            } else if (sent > 0 && received == 0) {
+                newActivity = DctConstants.Activity.DATAOUT;
+            } else if (sent == 0 && received > 0) {
+                newActivity = DctConstants.Activity.DATAIN;
+            } else {
+                newActivity = (mActivity == DctConstants.Activity.DORMANT) ?
+                        mActivity : DctConstants.Activity.NONE;
+            }
+
+            if (mActivity != newActivity && mIsScreenOn) {
+                if (VDBG)
+                    log("updateDataActivity: newActivity=" + newActivity);
+                mActivity = newActivity;
+                mPhone.notifyDataActivity();
+            }
+        }
+    }
+
+    private void handlePcoData(AsyncResult ar) {
+        if (ar.exception != null) {
+            Rlog.e(LOG_TAG, "PCO_DATA exception: " + ar.exception);
+            return;
+        }
+        PcoData pcoData = (PcoData)(ar.result);
+        ArrayList<DataConnection> dcList = new ArrayList<>();
+        DataConnection temp = mDcc.getActiveDcByCid(pcoData.cid);
+        if (temp != null) {
+            dcList.add(temp);
+        }
+        if (dcList.size() == 0) {
+            Rlog.e(LOG_TAG, "PCO_DATA for unknown cid: " + pcoData.cid + ", inferring");
+            for (DataConnection dc : mDataConnections.values()) {
+                final int cid = dc.getCid();
+                if (cid == pcoData.cid) {
+                    if (VDBG) Rlog.d(LOG_TAG, "  found " + dc);
+                    dcList.clear();
+                    dcList.add(dc);
+                    break;
+                }
+                // check if this dc is still connecting
+                if (cid == -1) {
+                    for (ApnContext apnContext : dc.mApnContexts.keySet()) {
+                        if (apnContext.getState() == DctConstants.State.CONNECTING) {
+                            if (VDBG) Rlog.d(LOG_TAG, "  found potential " + dc);
+                            dcList.add(dc);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (dcList.size() == 0) {
+            Rlog.e(LOG_TAG, "PCO_DATA - couldn't infer cid");
+            return;
+        }
+        for (DataConnection dc : dcList) {
+            if (dc.mApnContexts.size() == 0) {
+                break;
+            }
+            // send one out for each apn type in play
+            for (ApnContext apnContext : dc.mApnContexts.keySet()) {
+                String apnType = apnContext.getApnType();
+
+                final Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
+                intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnType);
+                intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, pcoData.bearerProto);
+                intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, pcoData.pcoId);
+                intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, pcoData.contents);
+                mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
+            }
+        }
+    }
+
+    /**
+     * Data-Stall
+     */
+    // Recovery action taken in case of data stall
+    private static class RecoveryAction {
+        public static final int GET_DATA_CALL_LIST      = 0;
+        public static final int CLEANUP                 = 1;
+        public static final int REREGISTER              = 2;
+        public static final int RADIO_RESTART           = 3;
+        public static final int RADIO_RESTART_WITH_PROP = 4;
+
+        private static boolean isAggressiveRecovery(int value) {
+            return ((value == RecoveryAction.CLEANUP) ||
+                    (value == RecoveryAction.REREGISTER) ||
+                    (value == RecoveryAction.RADIO_RESTART) ||
+                    (value == RecoveryAction.RADIO_RESTART_WITH_PROP));
+        }
+    }
+
+    private int getRecoveryAction() {
+        ///M: Make data stall mechanism support multiple phone @{
+        //int action = Settings.System.getInt(mResolver,
+        //        "radio.data.stall.recovery.action", RecoveryAction.GET_DATA_CALL_LIST);
+        String actionName = "radio.data.stall.recovery.action" + String.valueOf(mPhone.getPhoneId());
+        int action = Settings.System.getInt(mResolver,
+                actionName, RecoveryAction.GET_DATA_CALL_LIST);
+        /// @}
+        if (VDBG_STALL) log("getRecoveryAction: " + action);
+        return action;
+    }
+
+    private void putRecoveryAction(int action) {
+        ///M: Make data stall mechanism support multiple phone @{
+        //Settings.System.putInt(mResolver, "radio.data.stall.recovery.action", action);
+        String actionName = "radio.data.stall.recovery.action" + String.valueOf(mPhone.getPhoneId());
+        Settings.System.putInt(mResolver, actionName, action);
+        /// @}
+        if (VDBG_STALL) log("putRecoveryAction: " + action);
+    }
+
+    private void doRecovery() {
+        if (getOverallState() == DctConstants.State.CONNECTED) {
+            // Go through a series of recovery steps, each action transitions to the next action
+            final int recoveryAction = getRecoveryAction();
+            TelephonyMetrics.getInstance().writeDataStallEvent(mPhone.getPhoneId(), recoveryAction);
+            switch (recoveryAction) {
+            case RecoveryAction.GET_DATA_CALL_LIST:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_GET_DATA_CALL_LIST,
+                        mSentSinceLastRecv);
+                if (DBG) log("doRecovery() get data call list");
+                mPhone.mCi.getDataCallList(obtainMessage(DctConstants.EVENT_DATA_STATE_CHANGED));
+                putRecoveryAction(RecoveryAction.CLEANUP);
+                break;
+            case RecoveryAction.CLEANUP:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_CLEANUP, mSentSinceLastRecv);
+                /* M: Start - abnormal event logging for logger */
+                Intent intent = new Intent(TelephonyIntents.ACTION_EXCEPTION_HAPPENED);
+                intent.putExtra("Reason", "SmartLogging");
+                intent.putExtra("from_where", "DCT");
+                mPhone.getContext().sendBroadcast(intent);
+                log("Broadcast for SmartLogging - NO DATA");
+                /* M: End - abnormal event logging for logger */
+                if (DBG) log("doRecovery() cleanup all connections");
+                cleanUpAllConnections(Phone.REASON_PDP_RESET);
+                putRecoveryAction(RecoveryAction.REREGISTER);
+                break;
+            case RecoveryAction.REREGISTER:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_REREGISTER,
+                        mSentSinceLastRecv);
+                if (DBG) log("doRecovery() re-register");
+                mPhone.getServiceStateTracker().reRegisterNetwork(null); // AOSP
+                // M: re-register PS domain only
+                //   Not to use mPhone.getServiceStateTracker().reRegisterNetwork
+                //   Re-register may not be triggered by it and both CS and PS could be impacted
+                //   FIXME: To choose AOSP or use MTK soltuion.
+                /// DataConnectionHelper.getInstance().reRegisterPsNetwork();
+                putRecoveryAction(RecoveryAction.RADIO_RESTART);
+                break;
+            case RecoveryAction.RADIO_RESTART:
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART,
+                        mSentSinceLastRecv);
+                if (DBG) log("restarting radio");
+                putRecoveryAction(RecoveryAction.RADIO_RESTART_WITH_PROP);
+                restartRadio();
+                break;
+            case RecoveryAction.RADIO_RESTART_WITH_PROP:
+                // This is in case radio restart has not recovered the data.
+                // It will set an additional "gsm.radioreset" property to tell
+                // RIL or system to take further action.
+                // The implementation of hard reset recovery action is up to OEM product.
+                // Once RADIO_RESET property is consumed, it is expected to set back
+                // to false by RIL.
+                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART_WITH_PROP, -1);
+                if (DBG) log("restarting radio with gsm.radioreset to true");
+                SystemProperties.set(RADIO_RESET_PROPERTY, "true");
+                // give 1 sec so property change can be notified.
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {}
+                restartRadio();
+                putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+                break;
+            default:
+                throw new RuntimeException("doRecovery: Invalid recoveryAction=" +
+                    recoveryAction);
+            }
+            mSentSinceLastRecv = 0;
+        }
+    }
+
+    private void updateDataStallInfo() {
+        long sent, received;
+
+        TxRxSum preTxRxSum = new TxRxSum(mDataStallTxRxSum);
+        mDataStallTxRxSum.updateTxRxSum();
+
+        if (VDBG_STALL) {
+            log("updateDataStallInfo: mDataStallTxRxSum=" + mDataStallTxRxSum +
+                    " preTxRxSum=" + preTxRxSum);
+        }
+
+        sent = mDataStallTxRxSum.txPkts - preTxRxSum.txPkts;
+        received = mDataStallTxRxSum.rxPkts - preTxRxSum.rxPkts;
+
+        if (RADIO_TESTS) {
+            if (SystemProperties.getBoolean("radio.test.data.stall", false)) {
+                log("updateDataStallInfo: radio.test.data.stall true received = 0;");
+                received = 0;
+            }
+        }
+        if ( sent > 0 && received > 0 ) {
+            if (VDBG_STALL) log("updateDataStallInfo: IN/OUT");
+            mSentSinceLastRecv = 0;
+            putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+        } else if (sent > 0 && received == 0) {
+            if (mPhone.getState() == PhoneConstants.State.IDLE) {
+                mSentSinceLastRecv += sent;
+            } else {
+                mSentSinceLastRecv = 0;
+            }
+            if (DBG) {
+                log("updateDataStallInfo: OUT sent=" + sent +
+                        " mSentSinceLastRecv=" + mSentSinceLastRecv);
+            }
+        } else if (sent == 0 && received > 0) {
+            if (VDBG_STALL) log("updateDataStallInfo: IN");
+            mSentSinceLastRecv = 0;
+            putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
+        } else {
+            if (VDBG_STALL) log("updateDataStallInfo: NONE");
+        }
+    }
+
+    private void onDataStallAlarm(int tag) {
+        if (mDataStallAlarmTag != tag) {
+            if (DBG) {
+                log("onDataStallAlarm: ignore, tag=" + tag + " expecting " + mDataStallAlarmTag);
+            }
+            return;
+        }
+        updateDataStallInfo();
+
+        int hangWatchdogTrigger = Settings.Global.getInt(mResolver,
+                Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT,
+                NUMBER_SENT_PACKETS_OF_HANG);
+
+        boolean suspectedStall = DATA_STALL_NOT_SUSPECTED;
+        if (mSentSinceLastRecv >= hangWatchdogTrigger) {
+            if (DBG) {
+                log("onDataStallAlarm: tag=" + tag + " do recovery action=" + getRecoveryAction());
+            }
+            if (isOnlyIMSorEIMSPdnConnected() || skipDataStallAlarm()) {
+                log("onDataStallAlarm: only IMS or EIMS Connected, or switch data-stall off, "
+                        + "skip it!");
+            } else {
+                suspectedStall = DATA_STALL_SUSPECTED;
+                sendMessage(obtainMessage(DctConstants.EVENT_DO_RECOVERY));
+            }
+        } else {
+            if (VDBG_STALL) {
+                log("onDataStallAlarm: tag=" + tag + " Sent " + String.valueOf(mSentSinceLastRecv) +
+                    " pkts since last received, < watchdogTrigger=" + hangWatchdogTrigger);
+            }
+        }
+        startDataStallAlarm(suspectedStall);
+    }
+
+    private void startDataStallAlarm(boolean suspectedStall) {
+        int nextAction = getRecoveryAction();
+        int delayInMs;
+
+        if (mDataStallDetectionEnabled && getOverallState() == DctConstants.State.CONNECTED) {
+            // If screen is on or data stall is currently suspected, set the alarm
+            // with an aggressive timeout.
+            if (mIsScreenOn || suspectedStall || RecoveryAction.isAggressiveRecovery(nextAction)) {
+                delayInMs = Settings.Global.getInt(mResolver,
+                        Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
+                        DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
+            } else {
+                delayInMs = Settings.Global.getInt(mResolver,
+                        Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
+                        DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
+            }
+
+            mDataStallAlarmTag += 1;
+            if (VDBG_STALL) {
+                log("startDataStallAlarm: tag=" + mDataStallAlarmTag +
+                        " delay=" + (delayInMs / 1000) + "s");
+            }
+            Intent intent = new Intent(INTENT_DATA_STALL_ALARM);
+            intent.putExtra(DATA_STALL_ALARM_TAG_EXTRA, mDataStallAlarmTag);
+            ///M: Make data stall mechanism support multiple phone @{
+            //mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent,
+            //          PendingIntent.FLAG_UPDATE_CURRENT);
+            mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(),
+                    mPhone.getPhoneId(), intent, PendingIntent.FLAG_UPDATE_CURRENT);
+            /// @}
+            mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    SystemClock.elapsedRealtime() + delayInMs, mDataStallAlarmIntent);
+        } else {
+            if (VDBG_STALL) {
+                log("startDataStallAlarm: NOT started, no connection tag=" + mDataStallAlarmTag);
+            }
+        }
+    }
+
+    private void stopDataStallAlarm() {
+        if (VDBG_STALL) {
+            log("stopDataStallAlarm: current tag=" + mDataStallAlarmTag +
+                    " mDataStallAlarmIntent=" + mDataStallAlarmIntent);
+        }
+        mDataStallAlarmTag += 1;
+        if (mDataStallAlarmIntent != null) {
+            mAlarmManager.cancel(mDataStallAlarmIntent);
+            mDataStallAlarmIntent = null;
+        }
+    }
+
+    private void restartDataStallAlarm() {
+        if (isConnected() == false) return;
+        // To be called on screen status change.
+        // Do not cancel the alarm if it is set with aggressive timeout.
+        int nextAction = getRecoveryAction();
+
+        if (RecoveryAction.isAggressiveRecovery(nextAction)) {
+            if (DBG) log("restartDataStallAlarm: action is pending. not resetting the alarm.");
+            return;
+        }
+        if (VDBG_STALL) log("restartDataStallAlarm: stop then start.");
+        stopDataStallAlarm();
+        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+    }
+
+    /**
+     * Provisioning APN
+     */
+    private void onActionIntentProvisioningApnAlarm(Intent intent) {
+        if (DBG) log("onActionIntentProvisioningApnAlarm: action=" + intent.getAction());
+        Message msg = obtainMessage(DctConstants.EVENT_PROVISIONING_APN_ALARM,
+                intent.getAction());
+        msg.arg1 = intent.getIntExtra(PROVISIONING_APN_ALARM_TAG_EXTRA, 0);
+        sendMessage(msg);
+    }
+
+    private void startProvisioningApnAlarm() {
+        int delayInMs = Settings.Global.getInt(mResolver,
+                                Settings.Global.PROVISIONING_APN_ALARM_DELAY_IN_MS,
+                                PROVISIONING_APN_ALARM_DELAY_IN_MS_DEFAULT);
+        if (Build.IS_DEBUGGABLE) {
+            // Allow debug code to use a system property to provide another value
+            String delayInMsStrg = Integer.toString(delayInMs);
+            delayInMsStrg = System.getProperty(DEBUG_PROV_APN_ALARM, delayInMsStrg);
+            try {
+                delayInMs = Integer.parseInt(delayInMsStrg);
+            } catch (NumberFormatException e) {
+                loge("startProvisioningApnAlarm: e=" + e);
+            }
+        }
+        mProvisioningApnAlarmTag += 1;
+        if (DBG) {
+            log("startProvisioningApnAlarm: tag=" + mProvisioningApnAlarmTag +
+                    " delay=" + (delayInMs / 1000) + "s");
+        }
+        Intent intent = new Intent(INTENT_PROVISIONING_APN_ALARM);
+        intent.putExtra(PROVISIONING_APN_ALARM_TAG_EXTRA, mProvisioningApnAlarmTag);
+        mProvisioningApnAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent,
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + delayInMs, mProvisioningApnAlarmIntent);
+    }
+
+    private void stopProvisioningApnAlarm() {
+        if (DBG) {
+            log("stopProvisioningApnAlarm: current tag=" + mProvisioningApnAlarmTag +
+                    " mProvsioningApnAlarmIntent=" + mProvisioningApnAlarmIntent);
+        }
+        mProvisioningApnAlarmTag += 1;
+        if (mProvisioningApnAlarmIntent != null) {
+            mAlarmManager.cancel(mProvisioningApnAlarmIntent);
+            mProvisioningApnAlarmIntent = null;
+        }
+    }
+
+    public boolean isOnlyIMSorEIMSPdnConnected() {
+
+        boolean bIsOnlyIMSorEIMSConnected = false;
+        if (MTK_IMS_SUPPORT) {
+            for (ApnContext apnContext : mApnContexts.values()) {
+                String apnType = apnContext.getApnType();
+                if (!apnContext.isDisconnected()) {
+                    if (apnType.equals(PhoneConstants.APN_TYPE_IMS) == false &&
+                        apnType.equals(PhoneConstants.APN_TYPE_EMERGENCY) == false) {
+                        logd("apnType: " + apnType + " is still conntected!!");
+                    // At least one context (not ims or Emergency) was not disconnected return false
+                        bIsOnlyIMSorEIMSConnected = false;
+                        break;
+                    } else { //IMS or/and Emergency is/are still connected
+                        bIsOnlyIMSorEIMSConnected = true;
+                    }
+                }
+            }
+        }
+        return bIsOnlyIMSorEIMSConnected;
+    }
+
+    /**
+    * M: get the string of ims ApnSetting in the list.
+    *
+    * @param apnSettings
+    * @return
+    */
+    private String getIMSApnSetting(ArrayList<ApnSetting> apnSettings) {
+        if (apnSettings == null || apnSettings.size() == 0) {
+            return "";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        for (ApnSetting t : apnSettings) {
+            if (t.canHandleType("ims")) {
+                sb.append(apnToStringIgnoreName(t));
+            }
+        }
+        logd("getIMSApnSetting, apnsToStringIgnoreName: sb = " + sb.toString());
+        return sb.toString();
+    }
+
+    private boolean isIMSApnSettingChanged(ArrayList<ApnSetting> prevApnList,
+                                        ArrayList<ApnSetting> currApnList) {
+        boolean bImsApnChanged = false;
+        String prevIMSApn = getIMSApnSetting(prevApnList);
+        String currIMSApn = getIMSApnSetting(currApnList);
+
+        if (!prevIMSApn.isEmpty()) {
+            if (!TextUtils.equals(prevIMSApn, currIMSApn)) {
+                bImsApnChanged = true;
+            }
+        }
+
+        return bImsApnChanged;
+    }
+
+    /**
+     * M: Similar as ApnSetting.toString except the carrier is not considerred
+     * because some operator need to change the APN name when locale changed.
+     *
+     * @param apnSetting
+     * @return
+     */
+    private String apnToStringIgnoreName(ApnSetting apnSetting) {
+        if (apnSetting == null) {
+            return null;
+        }
+
+        StringBuilder sb = new StringBuilder();
+        sb.append(apnSetting.id)
+        .append(", ").append(apnSetting.numeric)
+        .append(", ").append(apnSetting.apn)
+        .append(", ").append(apnSetting.proxy)
+        .append(", ").append(apnSetting.mmsc)
+        .append(", ").append(apnSetting.mmsProxy)
+        .append(", ").append(apnSetting.mmsPort)
+        .append(", ").append(apnSetting.port)
+        .append(", ").append(apnSetting.authType).append(", ");
+        for (int i = 0; i < apnSetting.types.length; i++) {
+            sb.append(apnSetting.types[i]);
+            if (i < apnSetting.types.length - 1) {
+                sb.append(" | ");
+            }
+        }
+        sb.append(", ").append(apnSetting.protocol);
+        sb.append(", ").append(apnSetting.roamingProtocol);
+        sb.append(", ").append(apnSetting.carrierEnabled);
+        sb.append(", ").append(apnSetting.bearerBitmask);
+        logd("apnToStringIgnoreName: sb = " + sb.toString());
+        return sb.toString();
+    }
+
+    // M: Is data allowed even if mobile data off
+    private boolean isDataAllowedAsOff(String apnType) {
+        boolean isDataAllowedAsOff = false;
+        if (!BSP_PACKAGE && mGsmDctExt != null) {
+            isDataAllowedAsOff = mGsmDctExt.isDataAllowedAsOff(apnType);
+        }
+
+        // M: Vsim
+        if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT)
+                && isVsimActive(mPhone.getPhoneId())) {
+            logd("Vsim is enabled, set isDataAllowedAsOff true");
+            isDataAllowedAsOff = true;
+        }
+
+        if (getDomesticRoamingEnabledBySim()) {
+            boolean bDataOnRoamingEnabled = getDataOnRoamingEnabled();
+            boolean bIsInternationalRoaming = isInternationalRoaming();
+            if (DBG) {
+                log("isDataAllowedAsOff: bDataOnRoamingEnabled=" + bDataOnRoamingEnabled
+                        + ", bIsInternationalRoaming=" + bIsInternationalRoaming);
+            }
+
+            if (bIsInternationalRoaming && bDataOnRoamingEnabled) {
+                // M: International data roaming is allowed even if mobile data off.
+                isDataAllowedAsOff = true;
+            }
+        }
+
+        return isDataAllowedAsOff;
+    }
+
+    // M: Notify mobile data change
+    protected void notifyMobileDataChange(int enabled) {
+        logd("notifyMobileDataChange, enable = " + enabled);
+        Intent intent = new Intent(DataSubSelector.ACTION_MOBILE_DATA_ENABLE);
+        intent.putExtra(DataSubSelector.EXTRA_MOBILE_DATA_ENABLE_REASON, enabled);
+        mPhone.getContext().sendBroadcast(intent);
+    }
+
+    // M: Set mobile data property
+    private void setUserDataProperty(boolean enabled) {
+        int phoneId = mPhone.getPhoneId();
+        String dataOnIccid = "0";
+
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            log("invalid phone id, don't update");
+            return;
+        }
+
+        if (enabled) {
+            dataOnIccid = SystemProperties.get(PROPERTY_ICCID[phoneId], "0");
+        }
+
+        logd("setUserDataProperty:" + dataOnIccid);
+        TelephonyManager.getDefault().setTelephonyProperty(phoneId, PROPERTY_MOBILE_DATA_ENABLE,
+                dataOnIccid);
+    }
+
+    // M: JPN IA Start
+    private void handleSetResume() {
+        if (!SubscriptionManager.isValidPhoneId(mPhone.getPhoneId())) return;
+        mPhone.mCi.setResumeRegistration(mSuspendId, null);
+    }
+
+    private void handleRegistrationSuspend(AsyncResult ar) {
+        if (ar.exception == null && ar.result != null) {
+            if (DBG) log("handleRegistrationSuspend: createAllApnList and set initial attach APN");
+            mSuspendId = ((int[]) ar.result)[0];
+            log("handleRegistrationSuspend: suspending with Id=" + mSuspendId);
+            synchronized (mNeedsResumeModemLock) {
+                mNeedsResumeModem = true;
+            }
+            createAllApnList();
+            setInitialAttachApn();
+        } else {
+            log("handleRegistrationSuspend: AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+
+    private void handlePlmnChange(AsyncResult ar) {
+        if (ar.exception == null && ar.result != null) {
+            String[] plmnString = (String[]) ar.result;
+
+            for (int i = 0; i < plmnString.length; i++) {
+                logd("plmnString[" + i + "]=" + plmnString[i]);
+            }
+            mRegion = getRegion(plmnString[0]);
+
+            IccRecords r = mIccRecords.get();
+            String operator = (r != null) ? r.getOperatorNumeric() : "";
+            if (!TextUtils.isEmpty(operator) &&
+                    isNeedToResumeMd() == false &&
+                    mPhone.getPhoneId() ==
+                            SubscriptionManager.getPhoneId(
+                            SubscriptionController.getInstance().getDefaultDataSubId())){
+                logd("handlePlmnChange: createAllApnList and set initial attach APN");
+                createAllApnList();
+                setInitialAttachApn();
+            } else {
+                logd("No need to update APN for Operator");
+            }
+        } else {
+            log("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private int getRegion(String plmn) {
+        String currentMcc;
+        if (plmn == null || plmn.equals("") || plmn.length() < 5) {
+            logd("[getRegion] Invalid PLMN");
+            return REGION_UNKNOWN;
+        }
+
+        currentMcc = plmn.substring(0, 3);
+        for (String mcc : MCC_TABLE_TEST) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] Test PLMN");
+                return REGION_UNKNOWN;
+            }
+        }
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] REGION_DOMESTIC");
+                return REGION_DOMESTIC;
+            } else {
+                logd("[getRegion] REGION_FOREIGN");
+                return REGION_FOREIGN;
+            }
+        }
+        logd("[getRegion] REGION_UNKNOWN");
+        return REGION_UNKNOWN;
+    }
+
+    public boolean getImsEnabled() {
+        boolean isImsEnabled = (ImsManager.isVolteEnabledByPlatform(mPhone.getContext()) &&
+                ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext()));
+        logd("getImsEnabled: getInt isImsEnabled=" + isImsEnabled);
+        return isImsEnabled;
+    }
+
+    /* M: VDF syncApnTableToRds. Request for two cmds as follow:
+     * (apn;apn_type(profile_id|profile_id);rat;protocol)
+     * @param ArrayList<ApnSetting> apnlist
+     * @return void
+     */
+    private void syncApnTableToRds(ArrayList<ApnSetting> apnlist) {
+        log("syncApnTableToRds: E");
+        ApnSetting apn;
+        ArrayList<String> aryApn = null;
+        StringBuilder sb = null;
+        int numOfProfileId = 0;
+        int rat = 1;
+
+        if (apnlist != null && apnlist.size() > 0) {
+            aryApn = new ArrayList<String>();
+            for (int i = 0; i < apnlist.size(); i++) {
+                apn = apnlist.get(i);
+                if (TextUtils.isEmpty(apn.apn)) {
+                    log("syncApnTableToRds: apn name is empty");
+                    continue;
+                }
+                sb = new StringBuilder();
+                sb.append(apn.apn);
+                sb.append(";");
+                numOfProfileId = 0;
+                for (int j = 0; j < apn.types.length; j++) {
+                    int profileId = getApnProfileID(apn.types[j]);
+                    if (profileId != RILConstants.DATA_PROFILE_INVALID) {
+                        if (numOfProfileId > 0) {
+                            sb.append("|");
+                        }
+                        sb.append(profileId);
+                        numOfProfileId++;
+                    }
+                }
+                sb.append(";");
+                rat = getApnRatByBearer(apn.bearerBitmask);
+                log("apn.rat: " + rat);
+                sb.append(rat);
+                sb.append(";");
+                sb.append(apn.protocol);
+                log("syncApnTableToRds: apn: " + sb.toString());
+                aryApn.add(sb.toString());
+            }
+            if (aryApn.size() > 0) {
+                mPhone.mCi.syncApnTableToRds(aryApn.toArray(new String[aryApn.size()]), null);
+            }
+        }
+        log("syncApnTableToRds: X");
+    }
+    // M: VDF MMS over ePDG @{
+    private int getApnRatByBearer(int bearerBitMask) {
+        int invertIWLANBitMask = 0;
+        log("getApnRatByBearer: " + bearerBitMask);
+
+        if (bearerBitMask == 0) {
+            return PhoneConstants.APN_RAT_CELLULAR_ONLY;
+        } else {
+            if (ServiceState.bitmaskHasTech(bearerBitMask,
+                    ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN)) {
+                invertIWLANBitMask = ~(1 << (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN - 1))
+                        & 0xffffff;
+                if (isWifiOnlyApn(bearerBitMask)) {
+                    return PhoneConstants.APN_RAT_WIFI_ONLY;
+                } else {
+                    return PhoneConstants.APN_RAT_CELLULAR_WIFI;
+                }
+            } else {
+                return PhoneConstants.APN_RAT_CELLULAR_ONLY;
+            }
+        }
+    }
+
+    private boolean isWifiOnlyApn(int bearerBitMask) {
+        int invertIWLANBitMask = ~(1 << (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN - 1)) & 0xffffff;
+
+        if (bearerBitMask == 0) {
+            return false;
+        }
+        return ((bearerBitMask & invertIWLANBitMask) == 0);
+    }
+    /// @}
+
+    public boolean checkIfDomesticInitialAttachApn(String currentMcc) {
+        boolean isMccDomestic = false;
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (currentMcc.equals(mcc)) {
+                isMccDomestic = true;
+                break;
+            }
+        }
+        if (isOp17IaSupport()&& isMccDomestic) {
+            if (getImsEnabled()) {
+                return mRegion == REGION_DOMESTIC;
+            } else {
+                return false;
+            }
+        }
+        if (enableOpIA()) {
+            return mRegion == REGION_DOMESTIC;
+        }
+
+        if (DBG) {
+            log("checkIfDomesticInitialAttachApn: Not OP129 or MCC is not in domestic for OP129");
+        }
+
+        return true;
+    }
+
+    public boolean enableOpIA() {
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (TextUtils.isEmpty(operatorNumeric)) {
+            return false;
+        }
+        String simOperator = operatorNumeric.substring(0, 3);
+        log("enableOpIA: currentMcc = " + simOperator);
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (simOperator.equals(mcc)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void onPcoStatus(AsyncResult ar) {
+        if (ar.exception == null) {
+            int[] aryPcoStatus = (int[]) ar.result;
+            if (aryPcoStatus != null && aryPcoStatus.length == 6) {
+                log("onPcoStatus: PCO_MCC = " + aryPcoStatus[0]
+                        + ", PCO_MNC = " + aryPcoStatus[1]
+                        + ", PCO_VAL = " + aryPcoStatus[2]
+                        + ", PCO_TECH = " + aryPcoStatus[3]
+                        + ", PCO_PDN_ID = " + aryPcoStatus[5]);
+
+                DcAsyncChannel dcac = mDataConnectionAcHashMap.get(aryPcoStatus[5]);
+                if (dcac != null) {
+                    String[] aryApnType = dcac.getApnTypeSync();
+                    if (aryApnType != null) {
+                        for (String apnType: aryApnType) {
+                            Intent intent = new Intent(TelephonyIntents.ACTION_PCO_STATUS);
+                            intent.putExtra(PhoneConstants.DATA_APN_TYPE_KEY, apnType);
+                            intent.putExtra(TelephonyIntents.EXTRA_PCO_TYPE, aryPcoStatus[2]);
+                            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+                        }
+                    } else {
+                        logw("onPcoStatus: dcac.getApnTypeSync() return null");
+                    }
+                }
+            } else {
+                logw("onPcoStatus: pco status is null");
+            }
+        } else {
+            loge("onPcoStatus exception: " + ar.exception);
+        }
+    }
+
+    // M: Multi-PS Attach Start
+    private void onAllowChanged(boolean allow) {
+        if (DBG) {
+            log("onAllowChanged: Allow = " + allow);
+        }
+
+        mAllowConfig = allow;
+        if (allow) {
+            setupDataOnConnectableApns(Phone.REASON_DATA_ALLOWED);
+        }
+    }
+
+    private boolean getAllowConfig() {
+        if(!DataConnectionHelper.getInstance().isMultiPsAttachSupport()) {
+            return true;
+        } else {
+            return hasModemDeactPdnCapabilityForMultiPS() ? true : mAllowConfig;
+        }
+    }
+    // M: Multi-PS Attach End
+
+    // M: Customize fallback retry
+    private boolean isPermanentFailByOp(DcFailCause dcFailCause) {
+        boolean isPermanent = true;
+        if (mDcFcMgr == null) {
+            loge("mDcFcMgr should not be null, something wrong");
+        } else {
+            isPermanent = mDcFcMgr.isPermanentFailByOp(dcFailCause);
+        }
+        return isPermanent;
+    }
+
+    // M: Set Default data SIM to RILD {
+    public void syncDefaultDataSlotId(int slotId) {
+        log("syncDefaultDataSlotId slot: " + slotId);
+
+        syncDataSettingsToMd(new int[] { SKIP_DATA_SETTINGS, SKIP_DATA_SETTINGS, slotId});
+    }
+    // }
+
+    /**
+     * M: Sync data setting to modem.
+     */
+    private void syncDataSettingsToMd(int[] dataSettings) {
+        logd("syncDataSettingsToMd(), "
+            + dataSettings[MOBILE_DATA_IDX]
+            + ", " + dataSettings[ROAMING_DATA_IDX]
+            + ", " + dataSettings[DEFAULT_DATA_SIM_IDX]);
+        mPhone.mCi.syncDataSettingsToMd(dataSettings, null);
+    }
+
+    private boolean skipDataStallAlarm() {
+        boolean skipStall = true;
+        boolean isTestSim = false;
+        int phoneId = mPhone.getPhoneId();
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (SubscriptionManager.isValidPhoneId(phoneId) &&
+                dcHelper != null && dcHelper.isTestIccCard(phoneId)) {
+            isTestSim = true;
+        }
+
+        if (isTestSim) {
+            if (SystemProperties.get(SKIP_DATA_STALL_ALARM).equals("0")) {
+                skipStall = false;
+            } else {
+                // majority behavior
+                skipStall = true;
+            }
+        } else {
+            if (SystemProperties.get(SKIP_DATA_STALL_ALARM).equals("1")) {
+                skipStall = true;
+            } else {
+                // majority behavior
+                skipStall = false;
+            }
+        }
+
+        return skipStall;
+    }
+
+    private void notifyVoiceCallEventToDataConnection(boolean bInVoiceCall,
+            boolean bSupportConcurrent) {
+        logd("notifyVoiceCallEventToDataConnection: bInVoiceCall = " + bInVoiceCall
+                + ", bSupportConcurrent = " + bSupportConcurrent);
+        for (DcAsyncChannel dcac : mDataConnectionAcHashMap.values()) {
+                dcac.notifyVoiceCallEvent(bInVoiceCall, bSupportConcurrent);
+        }
+    }
+
+    private boolean isApnSettingExist(ApnSetting apnSetting) {
+        if (apnSetting != null && mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+            for (ApnSetting apn : mAllApnSettings) {
+                if (TextUtils.equals(apnSetting.toStringIgnoreName(false),
+                        apn.toStringIgnoreName(false))) {
+                    log("isApnSettingExist: " + apn);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * M: VzW feature, change IA in EPDG handover case.
+     */
+    private void onAttachApnChangedByHandover(boolean isImsHandover) {
+        mIsImsHandover = isImsHandover;
+        log("onAttachApnChangedByHandover: mIsImsHandover = " + mIsImsHandover);
+        /* Set ril.imshandover which will be used in RILD to decide APN control mode
+           1: handover start
+           2: handover end
+        */
+        SystemProperties.set(PROP_IMS_HANDOVER, mIsImsHandover ? "1" : "2");
+        setInitialAttachApn();
+    }
+
+    private boolean isOp17IaSupport() {
+        String value = TelephonyManager.getTelephonyProperty(
+                mPhone.getPhoneId(), "gsm.ril.sim.op17", "0");
+        return value.equals("1") ? true : false;
+    }
+
+    private boolean isOp129IaSupport() {
+        return SystemProperties.get("gsm.ril.sim.op129").equals("1") ? true : false;
+    }
+
+    private boolean isNeedToResumeMd() {
+        return SystemProperties.get("gsm.ril.data.op.suspendmd").equals("1") ? true : false;
+    }
+
+    private boolean isOp18Sim() {
+        IccRecords r = mIccRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+
+        if (operator != null) {
+            for (int i = 0; i < MCCMNC_OP18.length; i++) {
+                if (operator.startsWith(MCCMNC_OP18[i])) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean getDomesticRoamingEnabledBySim() {
+        DataConnectionHelper dcHelper = DataConnectionHelper.getInstance();
+
+        if (dcHelper == null) {
+            loge("getDomesticRoamingEnabledBySim: dcHelper is null");
+            return false;
+        }
+
+        boolean bDomesticRoamingEnabled =
+                dcHelper.getDomesticRoamingEnabledBySim(mPhone.getPhoneId());
+
+        if (DBG) {
+            log("getDomesticRoamingEnabledBySim: bDomesticRoamingEnabled="
+                    + bDomesticRoamingEnabled);
+        }
+
+        return bDomesticRoamingEnabled;
+    }
+
+    private boolean hasOperatorIaCapability() {
+        if (mTelDevController != null &&
+                mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasOperatorIaCapability() == true) {
+            log("hasOpIaCapability: true");
+            return true;
+        }
+        return false;
+    }
+
+    private boolean hasModemDeactPdnCapabilityForMultiPS() {
+        if (mTelDevController != null &&
+                mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasModemDeactPdnCapabilityForMultiPS() == true) {
+            log("hasModemDeactPdnCapabilityForMultiPS: true");
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * M: Handler of data enabled changed event
+     * @param enabled True if data is enabled, otherwise disabled.
+     * @param reason Reason for data enabled/disabled (see {@code REASON_*} in
+     *      {@link DataEnabledSettings}.
+     */
+    private void onDataEnabledSettings(boolean enabled, int reason) {
+        log("onDataEnabledSettings: enabled=" + enabled + ", reason=" + reason);
+
+        if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
+            if (getDataOnRoamingEnabled() == false &&
+                    mPhone.getServiceState().getDataRoaming() == true) {
+                if (enabled) {
+                    notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
+                } else {
+                    notifyOffApnsOfAvailability(Phone.REASON_DATA_DISABLED);
+                }
+            }
+
+            // M: Sync data setting to modem
+            syncDataSettingsToMd(new int[]{ enabled ? 1 : 0,
+                                            getDataOnRoamingEnabled() ? 1 : 0,
+                                            SKIP_DATA_SETTINGS});
+
+            if (enabled) {
+                teardownRestrictedMeteredConnections();
+                onTrySetupData(Phone.REASON_DATA_ENABLED);
+            } else {
+                if (BSP_PACKAGE) {
+                    onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                } else {
+                     for (ApnContext apnContext : mApnContexts.values()) {
+                        if (!isDataAllowedAsOff(apnContext.getApnType())) {
+                            apnContext.setReason(Phone.REASON_DATA_SPECIFIC_DISABLED);
+                            onCleanUpConnection(true
+                                    , apnContext.apnIdForApnName(apnContext.getApnType())
+                                    , Phone.REASON_DATA_SPECIFIC_DISABLED);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/ServiceStateTracker.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/ServiceStateTracker.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/ServiceStateTracker.java	(revision 8052)
@@ -0,0 +1,8879 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.app.AlarmManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.os.AsyncResult;
+import android.os.BaseBundle;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PersistableBundle;
+import android.os.PowerManager;
+import android.os.Registrant;
+import android.os.RegistrantList;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.preference.PreferenceManager;
+import android.provider.Settings;
+import android.telephony.CarrierConfigManager;
+import android.telephony.CellIdentityGsm;
+import android.telephony.CellIdentityLte;
+import android.telephony.CellIdentityWcdma;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoCdma;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellInfoLte;
+import android.telephony.CellInfoWcdma;
+import android.telephony.CellLocation;
+import android.telephony.CellSignalStrengthLte;
+import android.telephony.RadioAccessFamily;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.text.TextUtils;
+import android.util.EventLog;
+import android.util.LocalLog;
+import android.util.Pair;
+import android.util.TimeUtils;
+import android.view.Display;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.TimeZone;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
+import com.android.internal.telephony.cdma.EriInfo;
+import com.android.internal.telephony.dataconnection.DcTracker;
+import com.android.internal.telephony.metrics.TelephonyMetrics;
+import com.android.internal.telephony.imsphone.ImsPhone;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
+import com.android.internal.telephony.uicc.IccConstants;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccRefreshResponse;
+import com.android.internal.telephony.uicc.IccUtils;
+import com.android.internal.telephony.uicc.RuimRecords;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.util.IndentingPrintWriter;
+import com.android.internal.telephony.uicc.SpnOverride;
+import com.android.internal.telephony.IccCardConstants;
+
+import com.android.ims.ImsException;
+import com.android.ims.ImsManager;
+
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.telephony.IServiceStateExt;
+import com.mediatek.internal.telephony.cdma.pluscode.IPlusCodeUtils;
+import com.mediatek.internal.telephony.cdma.pluscode.PlusCodeProcessor;
+import com.mediatek.internal.telephony.RadioManager;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+
+import android.net.ConnectivityManager;
+import android.provider.Settings.SettingNotFoundException;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.view.WindowManager;
+import android.app.ActivityManager;
+import android.telephony.SubscriptionInfo;
+
+import com.mediatek.internal.telephony.RadioManager;
+/**
+ * {@hide}
+ */
+public class ServiceStateTracker extends Handler {
+    private static final String LOG_TAG = "SST";
+    //private static final boolean DBG = true;
+    private static final boolean VDBG = false;  // STOPSHIP if true
+
+    private static final String PROP_FORCE_ROAMING = "telephony.test.forceRoaming";
+
+    private CommandsInterface mCi;
+    private UiccController mUiccController = null;
+    private UiccCardApplication mUiccApplcation = null;
+    private IccRecords mIccRecords = null;
+
+    private boolean mVoiceCapable;
+    //[ALPS01803573] - for 4gds/3gds tablet project
+    protected boolean mSmsCapable;
+
+    public ServiceState mSS;
+    private ServiceState mNewSS;
+
+    private static final long LAST_CELL_INFO_LIST_MAX_AGE_MS = 2000;
+    private long mLastCellInfoListTime;
+    private List<CellInfo> mLastCellInfoList = null;
+
+    // M: Report CellInfo by rate was done by polling cell info from framework by rate
+    protected int mCellInfoRate = Integer.MAX_VALUE;
+
+    private SignalStrength mSignalStrength;
+
+    // TODO - this should not be public, right now used externally GsmConnetion.
+    public RestrictedState mRestrictedState;
+
+    /* The otaspMode passed to PhoneStateListener#onOtaspChanged */
+    static public final int OTASP_UNINITIALIZED = 0;
+    static public final int OTASP_UNKNOWN = 1;
+    static public final int OTASP_NEEDED = 2;
+    static public final int OTASP_NOT_NEEDED = 3;
+    /**
+     * OtaUtil has conflict enum 4: OtaUtils.OTASP_FAILURE_SPC_RETRIES
+     */
+    static public final int OTASP_SIM_UNPROVISIONED = 5;
+
+    /**
+     * A unique identifier to track requests associated with a poll
+     * and ignore stale responses.  The value is a count-down of
+     * expected responses in this pollingContext.
+     */
+    private int[] mPollingContext;
+    private boolean mDesiredPowerState;
+
+    /**
+     * By default, strength polling is enabled.  However, if we're
+     * getting unsolicited signal strength updates from the radio, set
+     * value to true and don't bother polling any more.
+     */
+    private boolean mDontPollSignalStrength = false;
+
+    private RegistrantList mVoiceRoamingOnRegistrants = new RegistrantList();
+    private RegistrantList mVoiceRoamingOffRegistrants = new RegistrantList();
+    private RegistrantList mDataRoamingOnRegistrants = new RegistrantList();
+    private RegistrantList mDataRoamingOffRegistrants = new RegistrantList();
+    private RegistrantList mDataRoamingTypeChangedRegistrants = new RegistrantList();
+    protected RegistrantList mAttachedRegistrants = new RegistrantList();
+    protected RegistrantList mDetachedRegistrants = new RegistrantList();
+    private RegistrantList mDataRegStateOrRatChangedRegistrants = new RegistrantList();
+    private RegistrantList mNetworkAttachedRegistrants = new RegistrantList();
+    private RegistrantList mPsRestrictEnabledRegistrants = new RegistrantList();
+    private RegistrantList mPsRestrictDisabledRegistrants = new RegistrantList();
+
+    protected RegistrantList mSignalStrengthChangedRegistrants = new RegistrantList();
+
+    /* Radio power off pending flag and tag counter */
+    private boolean mPendingRadioPowerOffAfterDataOff = false;
+    private int mPendingRadioPowerOffAfterDataOffTag = 0;
+
+    /* PS restrict disabled notify pending flag */
+    protected boolean mPendingPsRestrictDisabledNotify = false;
+
+    /* Always broadcast service state to trigger possible roaming state change */
+    protected boolean mEriTriggeredPollState = false;
+
+
+    //MTK-START Replace 20 with 10
+    /** Signal strength poll rate. */
+    private static final int POLL_PERIOD_MILLIS = 10 * 1000;
+    //MTK-END Replace 20 with 10
+
+    /** Waiting period before recheck gprs and voice registration. */
+    public static final int DEFAULT_GPRS_CHECK_PERIOD_MILLIS = 60 * 1000;
+
+    /** GSM events */
+    protected static final int EVENT_RADIO_STATE_CHANGED               = 1;
+    protected static final int EVENT_NETWORK_STATE_CHANGED             = 2;
+    protected static final int EVENT_GET_SIGNAL_STRENGTH               = 3;
+    protected static final int EVENT_POLL_STATE_REGISTRATION           = 4;
+    protected static final int EVENT_POLL_STATE_GPRS                   = 5;
+    protected static final int EVENT_POLL_STATE_OPERATOR               = 6;
+    protected static final int EVENT_POLL_SIGNAL_STRENGTH              = 10;
+    protected static final int EVENT_NITZ_TIME                         = 11;
+    protected static final int EVENT_SIGNAL_STRENGTH_UPDATE            = 12;
+    protected static final int EVENT_RADIO_AVAILABLE                   = 13;
+    protected static final int EVENT_POLL_STATE_NETWORK_SELECTION_MODE = 14;
+    protected static final int EVENT_GET_LOC_DONE                      = 15;
+    protected static final int EVENT_SIM_RECORDS_LOADED                = 16;
+    protected static final int EVENT_SIM_READY                         = 17;
+    protected static final int EVENT_LOCATION_UPDATES_ENABLED          = 18;
+    protected static final int EVENT_GET_PREFERRED_NETWORK_TYPE        = 19;
+    protected static final int EVENT_SET_PREFERRED_NETWORK_TYPE        = 20;
+    protected static final int EVENT_RESET_PREFERRED_NETWORK_TYPE      = 21;
+    protected static final int EVENT_CHECK_REPORT_GPRS                 = 22;
+    protected static final int EVENT_RESTRICTED_STATE_CHANGED          = 23;
+
+    /* M: MTK added events begin*/
+    protected static final int EVENT_DATA_CONNECTION_DETACHED = 100;
+    protected static final int EVENT_INVALID_SIM_INFO = 101; //ALPS00248788
+    protected static final int EVENT_PS_NETWORK_STATE_CHANGED = 102;
+    protected static final int EVENT_IMEI_LOCK = 103; /* ALPS00296298 */
+    protected static final int EVENT_DISABLE_EMMRRS_STATUS = 104;
+    protected static final int EVENT_ENABLE_EMMRRS_STATUS = 105;
+    protected static final int EVENT_ICC_REFRESH = 106;
+    protected static final int EVENT_FEMTO_CELL_INFO = 107;
+    protected static final int EVENT_GET_CELL_INFO_LIST_BY_RATE = 108;
+    protected static final int EVENT_SET_IMS_ENABLED_DONE = 109;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE = 110;
+    protected static final int EVENT_IMS_DISABLED_URC = 111;
+    protected static final int EVENT_IMS_REGISTRATION_INFO = 112;
+    protected static final int EVENT_PS_NETWORK_TYPE_CHANGED = 113;
+    protected static final int EVENT_MODULATION_INFO = 117;
+    protected static final int EVENT_NETWORK_EVENT = 118;
+    protected static final int EVENT_CS_NETWORK_STATE_CHANGED = 119;
+    protected static final int EVENT_SIM_OPL_LOADED = 120;
+    /* MTK added events end*/
+
+    ///M: for changed the mtklogger
+    protected static final int EVENT_ETS_DEV_CHANGED_LOGGER = 205;
+    /// @}
+
+    /** CDMA events */
+    protected static final int EVENT_RUIM_READY                        = 26;
+    protected static final int EVENT_RUIM_RECORDS_LOADED               = 27;
+    protected static final int EVENT_POLL_STATE_CDMA_SUBSCRIPTION      = 34;
+    protected static final int EVENT_NV_READY                          = 35;
+    protected static final int EVENT_ERI_FILE_LOADED                   = 36;
+    protected static final int EVENT_OTA_PROVISION_STATUS_CHANGE       = 37;
+    protected static final int EVENT_SET_RADIO_POWER_OFF               = 38;
+    protected static final int EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED  = 39;
+    protected static final int EVENT_CDMA_PRL_VERSION_CHANGED          = 40;
+
+    protected static final int EVENT_RADIO_ON                          = 41;
+    public    static final int EVENT_ICC_CHANGED                       = 42;
+    protected static final int EVENT_GET_CELL_INFO_LIST                = 43;
+    protected static final int EVENT_UNSOL_CELL_INFO_LIST              = 44;
+    protected static final int EVENT_CHANGE_IMS_STATE                  = 45;
+    protected static final int EVENT_IMS_STATE_CHANGED                 = 46;
+    protected static final int EVENT_IMS_STATE_DONE                    = 47;
+    protected static final int EVENT_IMS_CAPABILITY_CHANGED            = 48;
+    protected static final int EVENT_ALL_DATA_DISCONNECTED             = 49;
+    protected static final int EVENT_PHONE_TYPE_SWITCHED               = 50;
+    protected static final int EVENT_GET_AVAILABLE_NETWORK_DONE       = 51;
+
+    protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
+    protected static final String PROPERTY_AUTO_RAT_SWITCH = "persist.radio.autoratswitch";
+
+    private static final boolean mEngLoad = SystemProperties.get("ro.build.type").equals("eng")?
+            true : false;
+    private static int mLogLv = SystemProperties.getInt("persist.log.tag.tel_dbg", 0);
+    private static boolean DBG = (mEngLoad ||(mLogLv>0));
+
+    /**
+     * List of ISO codes for countries that can have an offset of
+     * GMT+0 when not in daylight savings time.  This ignores some
+     * small places such as the Canary Islands (Spain) and
+     * Danmarkshavn (Denmark).  The list must be sorted by code.
+    */
+    protected static final String[] GMT_COUNTRY_CODES = {
+        "bf", // Burkina Faso
+        "ci", // Cote d'Ivoire
+        "eh", // Western Sahara
+        "fo", // Faroe Islands, Denmark
+        "gb", // United Kingdom of Great Britain and Northern Ireland
+        "gh", // Ghana
+        "gm", // Gambia
+        "gn", // Guinea
+        "gw", // Guinea Bissau
+        "ie", // Ireland
+        "lr", // Liberia
+        "is", // Iceland
+        "ma", // Morocco
+        "ml", // Mali
+        "mr", // Mauritania
+        "pt", // Portugal
+        "sl", // Sierra Leone
+        "sn", // Senegal
+        "st", // Sao Tome and Principe
+        "tg", // Togo
+    };
+
+    private class CellInfoResult {
+        List<CellInfo> list;
+        Object lockObj = new Object();
+    }
+
+    /** Reason for registration denial. */
+    protected static final String REGISTRATION_DENIED_GEN  = "General";
+    protected static final String REGISTRATION_DENIED_AUTH = "Authentication Failure";
+
+    private boolean mImsRegistrationOnOff = false;
+    private boolean mAlarmSwitch = false;
+    /** Radio is disabled by carrier. Radio power will not be override if this field is set */
+    private boolean mRadioDisabledByCarrier = false;
+    private PendingIntent mRadioOffIntent = null;
+    private static final String ACTION_RADIO_OFF = "android.intent.action.ACTION_RADIO_OFF";
+    private boolean mPowerOffDelayNeed = true;
+    private boolean mDeviceShuttingDown = false;
+    /** Keep track of SPN display rules, so we only broadcast intent if something changes. */
+    private boolean mSpnUpdatePending = false;
+    private String mCurSpn = null;
+    private String mCurDataSpn = null;
+    private String mCurPlmn = null;
+    private boolean mCurShowPlmn = false;
+    private boolean mCurShowSpn = false;
+    private int mSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+
+    private boolean mImsRegistered = false;
+
+    private SubscriptionManager mSubscriptionManager;
+    private SubscriptionController mSubscriptionController;
+    private final SstSubscriptionsChangedListener mOnSubscriptionsChangedListener =
+        new SstSubscriptionsChangedListener();
+
+
+    private final RatRatcheter mRatRatcheter;
+
+    private final LocalLog mRoamingLog = new LocalLog(10);
+    private final LocalLog mAttachLog = new LocalLog(10);
+    private final LocalLog mPhoneTypeLog = new LocalLog(10);
+    private final LocalLog mRatLog = new LocalLog(20);
+
+    private class SstSubscriptionsChangedListener extends OnSubscriptionsChangedListener {
+        public final AtomicInteger mPreviousSubId =
+                new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+        /**
+         * Callback invoked when there is any change to any SubscriptionInfo. Typically
+         * this method would invoke {@link SubscriptionManager#getActiveSubscriptionInfoList}
+         */
+        @Override
+        public void onSubscriptionsChanged() {
+            // Set the network type, in case the radio does not restore it.
+            int subId = mPhone.getSubId();
+            if (DBG) log("SubscriptionListener.onSubscriptionInfoChanged start " + subId);
+            if (mPreviousSubId.getAndSet(subId) != subId) {
+                if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                    Context context = mPhone.getContext();
+
+                    mPhone.notifyPhoneStateChanged();
+                    mPhone.notifyCallForwardingIndicator();
+
+                    boolean restoreSelection = !context.getResources().getBoolean(
+                            com.android.internal.R.bool.skip_restoring_network_selection);
+                    mPhone.sendSubscriptionSettings(restoreSelection);
+
+                    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE,
+                            ServiceState.rilRadioTechnologyToString(
+                                    mSS.getRilDataRadioTechnology()));
+
+                    if (mSpnUpdatePending) {
+                        mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), mCurShowPlmn,
+                                mCurPlmn, mCurShowSpn, mCurSpn);
+                        mSpnUpdatePending = false;
+                        /// M: send SPN_STRINGS_UPDATED_ACTION again when subId become valid. @{
+                        if (!mPhone.isPhoneTypeGsm()) {
+                            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
+                            // For multiple SIM support, share the same intent, do not replace the other one
+                            if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+                            }
+                            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, mCurShowSpn);
+                            intent.putExtra(TelephonyIntents.EXTRA_SPN, mCurSpn);
+                            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, mCurShowPlmn);
+                            intent.putExtra(TelephonyIntents.EXTRA_PLMN, mCurPlmn);
+                            intent.putExtra(TelephonyIntents.EXTRA_HNB_NAME, (String)null);
+                            intent.putExtra(TelephonyIntents.EXTRA_CSG_ID, (String)null);
+                            intent.putExtra(TelephonyIntents.EXTRA_DOMAIN, 0);
+                            // isFemtocell (LTE/C2K)
+                            intent.putExtra(TelephonyIntents.EXTRA_FEMTO, mIsFemtocell);
+                            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+                            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+                            log("[CDMA]onSubscriptionInfoChanged: send SPN_STRINGS_UPDATED_ACTION broadcast again, "
+                                    + " showPlmn="
+                                    + mCurShowPlmn
+                                    + ", plmn="
+                                    + mCurPlmn
+                                    + ", showSpn="
+                                    + mCurShowSpn
+                                    + ", spn=" + mCurSpn);
+                        }
+                        /// @}
+                    }
+
+                    // Remove old network selection sharedPreferences since SP key names are now
+                    // changed to include subId. This will be done only once when upgrading from an
+                    // older build that did not include subId in the names.
+                    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(
+                            context);
+                    String oldNetworkSelection = sp.getString(
+                            Phone.NETWORK_SELECTION_KEY, "");
+                    String oldNetworkSelectionName = sp.getString(
+                            Phone.NETWORK_SELECTION_NAME_KEY, "");
+                    String oldNetworkSelectionShort = sp.getString(
+                            Phone.NETWORK_SELECTION_SHORT_KEY, "");
+                    // M ADD: MTK solution, always auto mode after sim is insert if skip is true
+                    // clear the user's setting to avoid the notification
+                    boolean skipRestoringSelection = mPhone.getContext().getResources().getBoolean(
+                            com.android.internal.R.bool.skip_restoring_network_selection);
+                    if (skipRestoringSelection) {
+                        sp.edit().
+                            remove(Phone.NETWORK_SELECTION_KEY + subId).
+                            remove(Phone.NETWORK_SELECTION_NAME_KEY + subId).
+                            remove(Phone.NETWORK_SELECTION_SHORT_KEY + subId).commit();
+                    } else if (!TextUtils.isEmpty(oldNetworkSelection) ||
+                            !TextUtils.isEmpty(oldNetworkSelectionName) ||
+                            !TextUtils.isEmpty(oldNetworkSelectionShort)) {
+                        SharedPreferences.Editor editor = sp.edit();
+                        editor.putString(Phone.NETWORK_SELECTION_KEY + subId,
+                                oldNetworkSelection);
+                        editor.putString(Phone.NETWORK_SELECTION_NAME_KEY + subId,
+                                oldNetworkSelectionName);
+                        editor.putString(Phone.NETWORK_SELECTION_SHORT_KEY + subId,
+                                oldNetworkSelectionShort);
+                        editor.remove(Phone.NETWORK_SELECTION_KEY);
+                        editor.remove(Phone.NETWORK_SELECTION_NAME_KEY);
+                        editor.remove(Phone.NETWORK_SELECTION_SHORT_KEY);
+                        editor.commit();
+                    }
+
+                    // Once sub id becomes valid, we need to update the service provider name
+                    // displayed on the UI again. The old SPN update intents sent to
+                    // MobileSignalController earlier were actually ignored due to invalid sub id.
+                    updateSpnDisplay();
+                }
+                // update voicemail count and notify message waiting changed
+                mPhone.updateVoiceMail();
+            }
+            // Common
+            if (mSubscriptionController.isReady()) {
+                int phoneId = mPhone.getPhoneId();
+                log("phoneId= " + phoneId + " ,mSpnUpdatePending= " + mSpnUpdatePending);
+                if (mSpnUpdatePending) {
+                    mSubscriptionController.setPlmnSpn(phoneId, mCurShowPlmn,
+                        mCurPlmn, mCurShowSpn, mCurSpn);
+                    mSpnUpdatePending = false;
+                }
+            }
+        }
+    };
+
+    //Common
+    private GsmCdmaPhone mPhone;
+    public CellLocation mCellLoc;
+    private CellLocation mNewCellLoc;
+    public static final int MS_PER_HOUR = 60 * 60 * 1000;
+    /* Time stamp after 19 January 2038 is not supported under 32 bit */
+    private static final int MAX_NITZ_YEAR = 2037;
+    /**
+     * Sometimes we get the NITZ time before we know what country we
+     * are in. Keep the time zone information from the NITZ string so
+     * we can fix the time zone once know the country.
+     */
+    private boolean mNeedFixZoneAfterNitz = false;
+    private int mZoneOffset;
+    private boolean mZoneDst;
+    private long mZoneTime;
+    private boolean mGotCountryCode = false;
+    private String mSavedTimeZone;
+    private long mSavedTime;
+    private long mSavedAtTime;
+    /** Wake lock used while setting time of day. */
+    private PowerManager.WakeLock mWakeLock;
+    public static final String WAKELOCK_TAG = "ServiceStateTracker";
+    private ContentResolver mCr;
+    private ContentObserver mAutoTimeObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            Rlog.i(LOG_TAG, "Auto time state changed");
+            revertToNitzTime();
+        }
+    };
+
+    private ContentObserver mAutoTimeZoneObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            Rlog.i(LOG_TAG, "Auto time zone state changed");
+            revertToNitzTimeZone();
+        }
+    };
+
+    //GSM
+    private int mPreferredNetworkType;
+    private int mMaxDataCalls = 1;
+    private int mNewMaxDataCalls = 1;
+    private int mReasonDataDenied = -1;
+    private int mNewReasonDataDenied = -1;
+    /**
+     * GSM roaming status solely based on TS 27.007 7.2 CREG. Only used by
+     * handlePollStateResult to store CREG roaming result.
+     */
+    private boolean mGsmRoaming = false;
+    /**
+     * Data roaming status solely based on TS 27.007 10.1.19 CGREG. Only used by
+     * handlePollStateResult to store CGREG roaming result.
+     */
+    private boolean mDataRoaming = false;
+    /**
+     * Mark when service state is in emergency call only mode
+     */
+    private boolean mEmergencyOnly = false;
+    /** Boolean is true is setTimeFromNITZString was called */
+    private boolean mNitzUpdatedTime = false;
+
+    //[ALPS01825832]
+    private static boolean[] sReceiveNitz
+            = new boolean[TelephonyManager.getDefault().getPhoneCount()];
+
+    /** Started the recheck process after finding gprs should registered but not. */
+    private boolean mStartedGprsRegCheck;
+    /** Already sent the event-log for no gprs register. */
+    private boolean mReportedGprsNoReg;
+    /**
+     * The Notification object given to the NotificationManager.
+     */
+    private Notification.Builder mNotificationBuilder;
+    private Notification mNotification;
+    /** Notification type. */
+    public static final int PS_ENABLED = 1001;            // Access Control blocks data service
+    public static final int PS_DISABLED = 1002;           // Access Control enables data service
+    public static final int CS_ENABLED = 1003;            // Access Control blocks all voice/sms service
+    public static final int CS_DISABLED = 1004;           // Access Control enables all voice/sms service
+    public static final int CS_NORMAL_ENABLED = 1005;     // Access Control blocks normal voice/sms service
+    public static final int CS_EMERGENCY_ENABLED = 1006;  // Access Control blocks emergency call service
+    /** Notification id. */
+    public static final int PS_NOTIFICATION = 888;  // Id to update and cancel PS restricted
+    public static final int CS_NOTIFICATION = 999;  // Id to update and cancel CS restricted
+
+    /** mtk01616_120613 Notification id. */
+    static final int REJECT_NOTIFICATION = 890;
+
+    /** [ALPS01558804] Add notification id for using some spcial icc card*/
+    static final int SPECIAL_CARD_TYPE_NOTIFICATION = 8903;
+
+    private int gprsState = ServiceState.STATE_OUT_OF_SERVICE;
+    private int newGPRSState = ServiceState.STATE_OUT_OF_SERVICE;
+
+    private String mHhbName = null;
+    private String mCsgId = null;
+    private int mFemtocellDomain = 0;
+    private int mIsFemtocell = 0;
+
+    /* ALPS00236452: manufacturer maintained table for specific operator with multiple PLMN id */
+    // ALFMS00040828 - add "46008"
+    public static final String[][] customEhplmn = {{"46000", "46002", "46004", "46007", "46008"},
+                                       {"45400", "45402", "45418"},
+                                       {"46001", "46009"},
+                                       {"45403", "45404"},
+                                       {"45412", "45413"},
+                                       {"45416", "45419"},
+                                       {"45501", "45504"},
+                                       {"45503", "45505"},
+                                       {"45002", "45008"},
+                                       {"52501", "52502"},
+                                       {"43602", "43612"},
+                                       {"52010", "52099"},
+                                       //ALPS02663460[
+                                       {"52005", "52018"},
+                                       //ALPS02663460]
+                                       {"24001", "24005"},
+                                       {"26207", "26208", "26203", "26277"},
+                                       {"23430", "23431", "23432", "23433", "23434"},
+                                       {"72402", "72403", "72404"},
+                                       {"72406", "72410", "72411", "72423"},
+                                       {"72432", "72433", "72434"},
+                                       {"31026", "31031", "310160", "310200", "310210", "310220",
+                                        "310230", "310240", "310250", "310260", "310270", "310280",
+                                        "311290", "310300", "310310", "310320", "311330", "310660",
+                                        "310800"},
+                                       {"310150", "310170", "310380", "310410"},
+                                       {"31033", "310330"},
+                                       //ALPS02446235[
+                                       {"21401", "21402", "21403", "21404", "21405", "21406",
+                                        "21407", "21408", "21409", "21410", "21411", "21412",
+                                        "21413", "21414", "21415", "21416", "21417", "21418",
+                                        "21419", "21420", "21421"},
+                                       //ALPS02446235]
+                                       /** ALPS02501839 treat 20815 as 20801's EPLMN @{ */
+                                       {"20815", "20801"}
+                                       /** @} */
+                                       };
+
+    /** M:[ALPS02503235] add operator considered roaming configures @{ */
+    public static final String[][] customOperatorConsiderRoamingMcc = {
+        {"404"/*SIM MCC*/, "404", "405"},
+        {"405", "404", "405"}
+    };
+    /** @} */
+
+    public boolean dontUpdateNetworkStateFlag = false;
+    public boolean hasPendingPollState = false;
+
+    //MTK-START [mtk03851][111124]MTK added
+    protected static final int EVENT_SET_AUTO_SELECT_NETWORK_DONE = 50;
+    /** Indicate the first radio state changed **/
+    private boolean mFirstRadioChange = true;
+    private int explict_update_spn = 0;
+
+    private String mLastRegisteredPLMN = null;
+    private String mLastPSRegisteredPLMN = null;
+    private boolean mEverIVSR = false;  /* ALPS00324111: at least one chance to do IVSR  */
+
+    //MTK-ADD: for for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS only
+    //SIM card or CS domain network registeration temporary failure
+    private boolean isCsInvalidCard = false;
+
+    private IServiceStateExt mServiceStateExt;
+
+    private String mLocatedPlmn = null;
+    private int mPsRegState = ServiceState.STATE_OUT_OF_SERVICE;
+    private int mPsRegStateRaw = ServiceState.RIL_REG_STATE_NOT_REG;
+
+    /** [ALPS01558804] Add notification id for using some spcial icc card*/
+    private String mSimType = "";
+    //MTK-START : [ALPS01262709] update TimeZone by MCC/MNC
+    /* manufacturer maintained table for specific timezone
+         with multiple timezone of country in time_zones_by_country.xml */
+    private String[][] mTimeZoneIdOfCapitalCity = {{"au", "Australia/Sydney"},
+                                                   {"br", "America/Sao_Paulo"},
+                                                   {"ca", "America/Toronto"},
+                                                   {"cl", "America/Santiago"},
+                                                   {"es", "Europe/Madrid"},
+                                                   {"fm", "Pacific/Ponape"},
+                                                   {"gl", "America/Godthab"},
+                                                   {"id", "Asia/Jakarta"},
+                                                   {"kz", "Asia/Almaty"},
+                                                   {"mn", "Asia/Ulaanbaatar"},
+                                                   {"mx", "America/Mexico_City"},
+                                                   {"pf", "Pacific/Tahiti"},
+                                                   {"pt", "Europe/Lisbon"},
+                                                   {"ru", "Europe/Moscow"},
+                                                   {"us", "America/New_York"},
+                                                   {"ec", "America/Guayaquil"}
+                                                  };
+    //MTK-END [ALPS01262709]
+    /* manufacturer maintained table for the case that
+       MccTable.defaultTimeZoneForMcc() returns unexpected timezone */
+    private String[][] mTimeZoneIdByMcc = {{"460", "Asia/Shanghai"},
+                                           {"404", "Asia/Calcutta"},
+                                           {"454", "Asia/Hong_Kong"}
+                                          };
+
+    private boolean mIsImeiLock = false;
+
+    //[ALPS01132085] for NetworkType display abnormal
+    //[ALPS01497861] when ipo reboot this value must be ture
+    //private boolean mIsScreenOn = true;  //[ALPS01810775,ALPS01868743]removed
+    private boolean mIsForceSendScreenOnForUpdateNwInfo = false;
+
+    private static Timer mCellInfoTimer = null;
+
+    protected boolean bHasDetachedDuringPolling = false;
+    ///M: Fix the operator info not update issue.
+    private  boolean mNeedNotify = false;
+
+    // keep the rat info of the voice URC
+    private boolean voiceUrcWith4G = false;
+
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (!mPhone.isPhoneTypeGsm()) {
+                /// M: [CDMA] status bar does not update after change language. @{
+                if (intent.getAction().equals(Intent.ACTION_LOCALE_CHANGED)) {
+                    refreshSpnDisplay();
+                    return;
+                } else if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                    int phoneId = intent.getIntExtra(PhoneConstants.PHONE_KEY,
+                            SubscriptionManager.INVALID_PHONE_INDEX);
+                    String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                    log("[CDMA]phoneId:" + phoneId + ", mPhoneId:" + mPhone.getPhoneId()
+                            + ", simStatus:" + (simStatus == null ? "null" : simStatus));
+                    if (phoneId == mPhone.getPhoneId()) {
+                        if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)) {
+                            mMdn = null;
+                        }
+                    }
+
+                    if ((simStatus != null)
+                            && simStatus.equals(IccCardConstants.INTENT_VALUE_ICC_IMSI)) {
+                        setDeviceRatMode(mPhone.getPhoneId());
+                    }
+                    return;
+                }
+                /// @}
+
+                loge("Ignoring intent " + intent + " received on CDMA phone");
+                return;
+            }
+
+            if (intent.getAction().equals(ACTION_SHOW_ROAMING_REMINDER)) {
+                int showRoamingReminderChoice = android.provider.Settings.Global.getInt(
+                    mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                    PREFERRED_SHOW_ROAMING_REMINDER + mPhone.getSubId(), 0);
+                int roamingChoice = android.provider.Settings.Global.getInt(
+                    mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                    PREFERRED_ROAMING + mPhone.getSubId(), 0);
+
+                logd("ACTION_SHOW_ROAMING_REMINDER, mNewSS.getRoaming()="
+                        + mNewSS.getRoaming() + ", reminderChoice=" + showRoamingReminderChoice
+                        + ", roamingChoice=" + roamingChoice);
+
+                if (mNewSS.getRoaming() && 0 == showRoamingReminderChoice && roamingChoice != 0) {
+                    showDataRoamingConfirmDialog();
+                }
+                return;
+            }
+
+            if (intent.getAction().equals(Intent.ACTION_LOCALE_CHANGED)) {
+                // update emergency string whenever locale changed
+                ///M: Support language update for spn display. @{
+                // updateSpnDisplay();
+                refreshSpnDisplay();
+                /// @}
+            } else if (intent.getAction().equals(ACTION_RADIO_OFF)) {
+                mAlarmSwitch = false;
+                DcTracker dcTracker = mPhone.mDcTracker;
+                powerOffRadioSafely(dcTracker);
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                //[ALPS02042805] pollState after RILJ noitfy URC when screen on
+                //pollState();
+                explict_update_spn = 1;
+                if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    try {
+                        if (mServiceStateExt.needEMMRRS()) {
+                            if (isCurrentPhoneDataConnectionOn()) {
+                                getEINFO(EVENT_ENABLE_EMMRRS_STATUS);
+                            }
+                        }
+                    } catch (RuntimeException e) {
+                        e.printStackTrace();
+                    }
+                }
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    try {
+                        if (mServiceStateExt.needEMMRRS()) {
+                            if (isCurrentPhoneDataConnectionOn()) {
+                                getEINFO(EVENT_DISABLE_EMMRRS_STATUS);
+                            }
+                        }
+                    } catch (RuntimeException e) {
+                        e.printStackTrace();
+                    }
+                }
+            } else if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                String simState = IccCardConstants.INTENT_VALUE_ICC_UNKNOWN;
+
+                int slotId = intent.getIntExtra(PhoneConstants.PHONE_KEY, -1);
+                if (slotId == mPhone.getPhoneId()) {
+                    simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                    log("SIM state change, slotId: " + slotId + " simState[" + simState + "]");
+                }
+
+                //[ALPS01558804] MTK-START: send notification for using some spcial icc card
+                if ((simState.equals(IccCardConstants.INTENT_VALUE_ICC_READY))
+                        && (mSimType.equals(""))) {
+                    mSimType = PhoneFactory.getPhone(mPhone.getPhoneId())
+                        .getIccCard().getIccCardType();
+
+                    log("SimType= " + mSimType);
+
+                    if ((mSimType != null) && (!mSimType.equals(""))) {
+                        if (mSimType.equals("SIM") || mSimType.equals("USIM")) {
+                            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                                try {
+                                    if (mServiceStateExt.needIccCardTypeNotification(mSimType)) {
+                                        //[ALPS01600557] - start : need to check 3G Capability SIM
+                                        if (TelephonyManager.getDefault().getPhoneCount() > 1) {
+                                            int raf = mPhone.getRadioAccessFamily();
+                                            log("check RAF=" + raf);
+                                            if ((raf&RadioAccessFamily.RAF_LTE)
+                                                    == RadioAccessFamily.RAF_LTE) {
+                                                setSpecialCardTypeNotification(mSimType, 0, 0);
+                                            }
+                                        } else {
+                                            setSpecialCardTypeNotification(mSimType, 0, 0);
+                                        }
+                                    }
+                                } catch (RuntimeException e) {
+                                    e.printStackTrace();
+                                }
+                            }
+                        }
+                    }
+                }
+
+                /* [ALPS01602110] START */
+                if ((intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE) != null)
+                        && (intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE)).equals(
+                              IccCardConstants.INTENT_VALUE_ICC_IMSI)) {
+                    setDeviceRatMode(mPhone.getPhoneId());
+                }
+                /* [ALPS01602110] END */
+
+                if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT) ||
+                        simState.equals(IccCardConstants.INTENT_VALUE_ICC_NOT_READY)) {
+                    mSimType = "";
+                    int raf = mPhone.getRadioAccessFamily();
+                    if ((raf&RadioAccessFamily.RAF_LTE) == RadioAccessFamily.RAF_LTE) {
+                        NotificationManager notificationManager = (NotificationManager)
+                            context.getSystemService(Context.NOTIFICATION_SERVICE);
+                        notificationManager.cancel(SPECIAL_CARD_TYPE_NOTIFICATION);
+                    }
+                    //[ALPS01825832] reset flag
+                    setReceivedNitz(mPhone.getPhoneId(), false);
+                    //[ALPS01839778] reset flag for user change SIM card
+                    mLastRegisteredPLMN = null;
+                    mLastPSRegisteredPLMN = null;
+
+                    //[ALPS01509553]-start:reset flag when sim plug-out
+                    if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT)) {
+                        dontUpdateNetworkStateFlag = false;
+                    }
+                    //[ALPS01509553]-end
+                }
+                //[ALPS01558804] MTK-END: send notification for using some special icc card
+            } else if (intent.getAction().equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED)) {
+                if (intent.getIntExtra(SubscriptionManager.INTENT_KEY_DETECT_STATUS,
+                        SubscriptionManager.EXTRA_VALUE_NOCHANGE)
+                        != SubscriptionManager.EXTRA_VALUE_NOCHANGE) {
+                    updateSpnDisplayGsm(true);
+                }
+            }
+        }
+    };
+
+    //MTK-START [ALPS00368272]
+    private ContentObserver mDataConnectionSettingObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            log("Data Connection Setting changed");
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    if (mServiceStateExt.needEMMRRS()) {
+                        if (isCurrentPhoneDataConnectionOn()) {
+                            getEINFO(EVENT_ENABLE_EMMRRS_STATUS);
+                        } else {
+                            getEINFO(EVENT_DISABLE_EMMRRS_STATUS);
+                        }
+                    }
+                } catch (RuntimeException e) {
+                        e.printStackTrace();
+                }
+            }
+        }
+    };
+    //MTK-END [ALPS00368272]
+
+    //[ALPS01577029]-START:To support auto switch rat mode to 2G only for 3M TDD csfb project when
+    //we are not in china
+    private ContentObserver mMsicFeatureConfigObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            Rlog.i("GsmServiceStateTracker", "Msic Feature Config has changed");
+            pollState();
+        }
+    };
+    //[ALPS01577029]-END
+
+
+    //CDMA
+    // Min values used to by getOtasp()
+    public static final String UNACTIVATED_MIN2_VALUE = "000000";
+    public static final String UNACTIVATED_MIN_VALUE = "1111110111";
+    // Current Otasp value
+    private int mCurrentOtaspMode = OTASP_UNINITIALIZED;
+    /** if time between NITZ updates is less than mNitzUpdateSpacing the update may be ignored. */
+    public static final int NITZ_UPDATE_SPACING_DEFAULT = 1000 * 60 * 10;
+    private int mNitzUpdateSpacing = SystemProperties.getInt("ro.nitz_update_spacing",
+            NITZ_UPDATE_SPACING_DEFAULT);
+    /** If mNitzUpdateSpacing hasn't been exceeded but update is > mNitzUpdate do the update */
+    public static final int NITZ_UPDATE_DIFF_DEFAULT = 2000;
+    private int mNitzUpdateDiff = SystemProperties.getInt("ro.nitz_update_diff",
+            NITZ_UPDATE_DIFF_DEFAULT);
+    private int mRoamingIndicator;
+    private boolean mIsInPrl;
+    private int mDefaultRoamingIndicator;
+    /**
+     * Initially assume no data connection.
+     */
+    private int mRegistrationState = -1;
+    private RegistrantList mCdmaForSubscriptionInfoReadyRegistrants = new RegistrantList();
+    private String mMdn;
+    private int mHomeSystemId[] = null;
+    private int mHomeNetworkId[] = null;
+    private String mMin;
+    private String mPrlVersion;
+    private boolean mIsMinInfoReady = false;
+    private boolean mIsEriTextLoaded = false;
+    private boolean mIsSubscriptionFromRuim = false;
+    private CdmaSubscriptionSourceManager mCdmaSSM;
+    public static final String INVALID_MCC = "000";
+    public static final String DEFAULT_MNC = "00";
+    private HbpcdUtils mHbpcdUtils = null;
+    /* Used only for debugging purposes. */
+    private String mRegistrationDeniedReason;
+    private String mCurrentCarrier = null;
+
+    /// M: [CDMA] @{
+    // Mark when service state is in emergency call only mode.
+    private boolean mNetworkExsit = true;
+    // Add for cdma plus code feature.
+    private IPlusCodeUtils mPlusCodeUtils = PlusCodeProcessor.getPlusCodeUtils();
+    /// @}
+    private static final String ACTION_SHOW_ROAMING_REMINDER = "android.intent.action.SHOW_ROAMING_REMINDER";
+
+    public ServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) {
+        mPhone = phone;
+        mCi = ci;
+
+        mRatRatcheter = new RatRatcheter(mPhone);
+        mVoiceCapable = mPhone.getContext().getResources().getBoolean(
+                com.android.internal.R.bool.config_voice_capable);
+        // Common
+        //[ALPS01803573] - for 4gds/3gds tablet project
+        mSmsCapable = mPhone.getContext().getResources().getBoolean(
+            com.android.internal.R.bool.config_sms_capable);
+        mUiccController = UiccController.getInstance();
+
+        mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null);
+        mCi.setOnSignalStrengthUpdate(this, EVENT_SIGNAL_STRENGTH_UPDATE, null);
+        mCi.registerForCellInfoList(this, EVENT_UNSOL_CELL_INFO_LIST, null);
+        mCi.registerForGetAvailableNetworksDone(this, EVENT_GET_AVAILABLE_NETWORK_DONE, null);
+        /// M: Register for ps state change @{
+        mCi.registerForPsNetworkStateChanged(this, EVENT_PS_NETWORK_STATE_CHANGED, null);
+        /// @}
+
+        mSubscriptionController = SubscriptionController.getInstance();
+        mSubscriptionManager = SubscriptionManager.from(phone.getContext());
+        mSubscriptionManager
+                .addOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+
+        mCi.registerForImsNetworkStateChanged(this, EVENT_IMS_STATE_CHANGED, null);
+
+        PowerManager powerManager =
+                (PowerManager)phone.getContext().getSystemService(Context.POWER_SERVICE);
+        mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKELOCK_TAG);
+
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            try {
+                mServiceStateExt = MPlugin.createInstance(
+                        IServiceStateExt.class.getName(), phone.getContext());
+            } catch (RuntimeException e) {
+                e.printStackTrace();
+            }
+        }
+
+        mCi.registerForRadioStateChanged(this, EVENT_RADIO_STATE_CHANGED, null);
+        mCi.registerForVoiceNetworkStateChanged(this, EVENT_NETWORK_STATE_CHANGED, null);
+        mCi.setOnNITZTime(this, EVENT_NITZ_TIME, null);
+
+        mCr = phone.getContext().getContentResolver();
+        // system setting property AIRPLANE_MODE_ON is set in Settings.
+        int airplaneMode = Settings.Global.getInt(mCr, Settings.Global.AIRPLANE_MODE_ON, 0);
+        int enableCellularOnBoot = Settings.Global.getInt(mCr,
+                Settings.Global.ENABLE_CELLULAR_ON_BOOT, 1);
+        mDesiredPowerState = (enableCellularOnBoot > 0) && ! (airplaneMode > 0);
+
+        mCr.registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.AUTO_TIME), true,
+                mAutoTimeObserver);
+        mCr.registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.AUTO_TIME_ZONE), true,
+                mAutoTimeZoneObserver);
+        mCr.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),
+                true, mAirplaneModeObserver);
+        setSignalStrengthDefaultValues();
+
+        // Monitor locale change
+        Context context = mPhone.getContext();
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_LOCALE_CHANGED);
+        context.registerReceiver(mIntentReceiver, filter);
+        filter = new IntentFilter();
+        filter.addAction(ACTION_RADIO_OFF);
+        filter.addAction(ACTION_SHOW_ROAMING_REMINDER);
+
+        // M : MTK added
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        filter.addAction(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
+        // M: MTK added end
+        context.registerReceiver(mIntentReceiver, filter);
+
+        mPhone.notifyOtaspChanged(OTASP_UNINITIALIZED);
+
+        updatePhoneType();
+    }
+
+    @VisibleForTesting
+    public void updatePhoneType() {
+        mSS = new ServiceState();
+        mNewSS = new ServiceState();
+        mLastCellInfoListTime = 0;
+        mLastCellInfoList = null;
+        mSignalStrength = new SignalStrength();
+        mRestrictedState = new RestrictedState();
+        mStartedGprsRegCheck = false;
+        mReportedGprsNoReg = false;
+        mMdn = null;
+        mMin = null;
+        mPrlVersion = null;
+        mIsMinInfoReady = false;
+        mNitzUpdatedTime = false;
+
+        //cancel any pending pollstate request on voice tech switching
+        cancelPollState();
+
+        if (mPhone.isPhoneTypeGsm()) {
+            //clear CDMA registrations first
+            if (mCdmaSSM != null) {
+                mCdmaSSM.dispose(this);
+            }
+
+            mCi.unregisterForCdmaPrlChanged(this);
+            mPhone.unregisterForEriFileLoaded(this);
+            mCi.unregisterForCdmaOtaProvision(this);
+            mPhone.unregisterForSimRecordsLoaded(this);
+
+            mCellLoc = new GsmCellLocation();
+            mNewCellLoc = new GsmCellLocation();
+            mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
+            mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
+
+
+            // M: MTK added
+            mCi.setInvalidSimInfo(this, EVENT_INVALID_SIM_INFO, null); //ALPS00248788
+            mCi.registerForModulation(this, EVENT_MODULATION_INFO, null);
+            mCi.registerForCsNetworkStateChanged(this, EVENT_CS_NETWORK_STATE_CHANGED, null);
+
+            try {
+               if (mServiceStateExt.isImeiLocked())
+                   mCi.registerForIMEILock(this, EVENT_IMEI_LOCK, null);
+            } catch (RuntimeException e) {
+               /* BSP must exception here but Turnkey should not exception here */
+               loge("No isImeiLocked");
+            }
+
+
+            mCi.registerForIccRefresh(this, EVENT_ICC_REFRESH, null);
+
+
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")) {
+                mCi.registerForFemtoCellInfo(this, EVENT_FEMTO_CELL_INFO, null);
+            }
+
+            mCi.registerForNetworkEvent(this, EVENT_NETWORK_EVENT, null);
+            //M: MTK added end
+
+            //[ALPS01577029]-START:
+            //To support auto switch rat mode to 2G only for 3M TDD csfb project
+            //when we are not in china
+            mCr.registerContentObserver(
+                    Settings.Global.getUriFor(Settings.Global.TELEPHONY_MISC_FEATURE_CONFIG), true,
+                    mMsicFeatureConfigObserver);
+            //[ALPS01577029]-END
+
+            //MTK-START [ALPS00368272]
+            mCr.registerContentObserver(
+                    Settings.System.getUriFor(Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION),
+                    true,
+                    mDataConnectionSettingObserver);
+            mCr.registerContentObserver(
+                    Settings.System.getUriFor(Settings.Global.MOBILE_DATA), true,
+                    mDataConnectionSettingObserver);
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    if (mServiceStateExt.needEMMRRS()) {
+                        if (isCurrentPhoneDataConnectionOn()) {
+                            getEINFO(EVENT_ENABLE_EMMRRS_STATUS);
+                        } else {
+                            getEINFO(EVENT_DISABLE_EMMRRS_STATUS);
+                        }
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+            //MTK-END [ALPS00368272]
+
+            //[ALPS01825832] reset flag
+            for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
+                setReceivedNitz(i, false);
+            }
+        } else {
+            //clear GSM regsitrations first
+            mCi.unregisterForAvailable(this);
+            mCi.unSetOnRestrictedStateChanged(this);
+            //M:
+            // Reset Restricted State
+            mPsRestrictDisabledRegistrants.notifyRegistrants();
+
+            /// M: [CDMA] Clear CDMA registrants for phone type switch with CdmaLte and Cdma @{
+            mCi.unregisterForCdmaPrlChanged(this);
+            mPhone.unregisterForEriFileLoaded(this);
+            mCi.unregisterForCdmaOtaProvision(this);
+            mPhone.unregisterForSimRecordsLoaded(this);
+            /// @}
+
+
+            mCi.unSetInvalidSimInfo(this);
+            mCi.unregisterForModulation(this);
+            mCi.unregisterForCsNetworkStateChanged(this);
+
+            try {
+                if (mServiceStateExt.isImeiLocked())
+                    mCi.unregisterForIMEILock(this);
+            } catch (RuntimeException e) {
+                /* BSP must exception here but Turnkey should not exception here */
+                loge("No isImeiLocked");
+            }
+
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")) {
+                mCi.unregisterForFemtoCellInfo(this);
+            }
+
+            mCi.unregisterForIccRefresh(this);
+
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")) {
+                mCi.unregisterForFemtoCellInfo(this);
+            }
+
+            if (SystemProperties.get("persist.mtk_ims_support").equals("1")) {
+                mCi.unregisterForImsDisable(this);
+                mCi.unregisterForImsRegistrationInfo(this);
+            }
+
+            mCi.unregisterForNetworkEvent(this);
+            mCr.unregisterContentObserver(mMsicFeatureConfigObserver);   //[ALPS01577029]
+            mCr.unregisterContentObserver(mDataConnectionSettingObserver);
+            //M;
+
+            if (mPhone.isPhoneTypeCdmaLte()) {
+                mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
+            }
+            mCellLoc = new CdmaCellLocation();
+            mNewCellLoc = new CdmaCellLocation();
+            mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this,
+                    EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
+            mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() ==
+                    CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
+
+            mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
+            mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
+            mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
+
+            mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
+            // update OTASP state in case previously set by another service
+            updateOtaspState();
+        }
+
+        // This should be done after the technology specific initializations above since it relies
+        // on fields like mIsSubscriptionFromRuim (which is updated above)
+        onUpdateIccAvailability();
+
+        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE,
+                ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
+        // Query signal strength from the modem after service tracker is created (i.e. boot up,
+        // switching between GSM and CDMA phone), because the unsolicited signal strength
+        // information might come late or even never come. This will get the accurate signal
+        // strength information displayed on the UI.
+        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
+        sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
+
+        logPhoneTypeChange();
+
+        // Tell everybody that we've thrown away state and are starting over with
+        // empty, detached ServiceStates.
+        mVoiceRoamingOffRegistrants.notifyRegistrants();
+        mDataRoamingOffRegistrants.notifyRegistrants();
+        mDetachedRegistrants.notifyRegistrants();
+        notifyDataRegStateRilRadioTechnologyChanged();
+    }
+
+    @VisibleForTesting
+    public void requestShutdown() {
+        if (mDeviceShuttingDown == true) return;
+        mDeviceShuttingDown = true;
+        mDesiredPowerState = false;
+        // setPowerStateToDesired();
+
+        // We need to shut down modem in our solution
+        int phoneId = getPhone().getPhoneId();
+        RadioManager.getInstance().setModemPower(false, (1 << phoneId));
+    }
+
+    public void dispose() {
+        mCi.unSetOnSignalStrengthUpdate(this);
+        mUiccController.unregisterForIccChanged(this);
+        mCi.unregisterForCellInfoList(this);
+        mSubscriptionManager
+            .removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+        mCi.unregisterForImsNetworkStateChanged(this);
+        mCi.unregisterForGetAvailableNetworksDone(this);
+        mCi.unregisterForPsNetworkStateChanged(this);
+        //M:
+        if (mPhone.isPhoneTypeGsm()) {
+            //clear GSM regsitrations
+            mCi.unregisterForAvailable(this);
+            mCi.unSetOnRestrictedStateChanged(this);
+
+
+            mCi.unSetInvalidSimInfo(this);
+            mCi.unregisterForModulation(this);
+            mCi.unregisterForCsNetworkStateChanged(this);
+
+            try {
+                if (mServiceStateExt.isImeiLocked())
+                    mCi.unregisterForIMEILock(this);
+            } catch (RuntimeException e) {
+                /* BSP must exception here but Turnkey should not exception here */
+                loge("No isImeiLocked");
+            }
+
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")) {
+                mCi.unregisterForFemtoCellInfo(this);
+            }
+
+            mCi.unregisterForIccRefresh(this);
+
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")) {
+                mCi.unregisterForFemtoCellInfo(this);
+            }
+
+            mCi.unregisterForNetworkEvent(this);
+            mCr.unregisterContentObserver(mMsicFeatureConfigObserver);   //[ALPS01577029]
+            mCr.unregisterContentObserver(mDataConnectionSettingObserver);
+        }
+        //M;
+
+        /// M: [CDMA] Add for unregister the broadcast receiver. @{
+        if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+            mPhone.getContext().unregisterReceiver(mIntentReceiver);
+        }
+        /// @}
+    }
+
+    public boolean getDesiredPowerState() {
+        return mDesiredPowerState;
+    }
+    public boolean getPowerStateFromCarrier() { return !mRadioDisabledByCarrier; }
+
+    protected SignalStrength mLastSignalStrength = null;
+    protected boolean notifySignalStrength() {
+        boolean notified = false;
+        if (!mSignalStrength.equals(mLastSignalStrength)) {
+            try {
+                if (DBG) {
+                    log("notifySignalStrength: mSignalStrength.getLevel=" +
+                            mSignalStrength.getLevel());
+                }
+                mPhone.notifySignalStrength();
+                // MTK add Common START
+                mLastSignalStrength = new SignalStrength(mSignalStrength);
+                // END
+                notified = true;
+            } catch (NullPointerException ex) {
+                loge("updateSignalStrength() Phone already destroyed: " + ex
+                        + "SignalStrength not notified");
+            }
+        }
+        return notified;
+    }
+
+    /**
+     * Notify all mDataConnectionRatChangeRegistrants using an
+     * AsyncResult in msg.obj where AsyncResult#result contains the
+     * new RAT as an Integer Object.
+     */
+    protected void notifyDataRegStateRilRadioTechnologyChanged() {
+        int rat = mSS.getRilDataRadioTechnology();
+        int drs = mSS.getDataRegState();
+        if (DBG) log("notifyDataRegStateRilRadioTechnologyChanged: drs=" + drs + " rat=" + rat);
+
+        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE,
+                ServiceState.rilRadioTechnologyToString(rat));
+        mDataRegStateOrRatChangedRegistrants.notifyResult(new Pair<Integer, Integer>(drs, rat));
+    }
+
+    /**
+     * Some operators have been known to report registration failure
+     * data only devices, to fix that use DataRegState.
+     */
+    protected void useDataRegStateForDataOnlyDevices() {
+        //[ALPS01803573] - for 4gds/3gds tablet project
+        //if (mVoiceCapable == false) {
+        if (mSmsCapable == false) {
+            if (DBG) {
+                log("useDataRegStateForDataOnlyDevice: VoiceRegState=" + mNewSS.getVoiceRegState()
+                    + " DataRegState=" + mNewSS.getDataRegState());
+            }
+            // TODO: Consider not lying and instead have callers know the difference.
+            mNewSS.setVoiceRegState(mNewSS.getDataRegState());
+
+            // Common
+            /* Integrate ALPS00286197 with MR2 data only device state update */
+            mNewSS.setRegState(ServiceState.REGISTRATION_STATE_HOME_NETWORK);
+        }
+    }
+
+    protected void updatePhoneObject() {
+        if (mPhone.getContext().getResources().
+                getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
+            // If the phone is not registered on a network, no need to update.
+            boolean isRegistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE ||
+                    mSS.getVoiceRegState() == ServiceState.STATE_EMERGENCY_ONLY;
+            if (!isRegistered) {
+                log("updatePhoneObject: Ignore update");
+                return;
+            }
+            mPhone.updatePhoneObject(mSS.getRilVoiceRadioTechnology());
+        }
+    }
+
+    /**
+     * Registration point for combined roaming on of mobile voice
+     * combined roaming is true when roaming is true and ONS differs SPN
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForVoiceRoamingOn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVoiceRoamingOnRegistrants.add(r);
+
+        if (mSS.getVoiceRoaming()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForVoiceRoamingOn(Handler h) {
+        mVoiceRoamingOnRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for roaming off of mobile voice
+     * combined roaming is true when roaming is true and ONS differs SPN
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForVoiceRoamingOff(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVoiceRoamingOffRegistrants.add(r);
+
+        if (!mSS.getVoiceRoaming()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForVoiceRoamingOff(Handler h) {
+        mVoiceRoamingOffRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for combined roaming on of mobile data
+     * combined roaming is true when roaming is true and ONS differs SPN
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataRoamingOn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataRoamingOnRegistrants.add(r);
+
+        if (mSS.getDataRoaming()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForDataRoamingOn(Handler h) {
+        mDataRoamingOnRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for roaming off of mobile data
+     * combined roaming is true when roaming is true and ONS differs SPN
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataRoamingOff(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataRoamingOffRegistrants.add(r);
+
+        if (!mSS.getDataRoaming()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForDataRoamingOff(Handler h) {
+        mDataRoamingOffRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for roaming type changed of mobile data
+     * notify when data roaming is true and roaming type differs the previous
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataRoamingTypeChange(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataRoamingTypeChangedRegistrants.add(r);
+    }
+
+    public void unregisterForDataRoamingTypeChange(Handler h) {
+        mDataRoamingTypeChangedRegistrants.remove(h);
+    }
+
+    /**
+     * Re-register network by toggling preferred network type.
+     * This is a work-around to deregister and register network since there is
+     * no ril api to set COPS=2 (deregister) only.
+     *
+     * @param onComplete is dispatched when this is complete.  it will be
+     * an AsyncResult, and onComplete.obj.exception will be non-null
+     * on failure.
+     */
+    public void reRegisterNetwork(Message onComplete) {
+        mCi.getPreferredNetworkType(
+                obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE, onComplete));
+    }
+
+    public void
+    setRadioPower(boolean power) {
+        mDesiredPowerState = power;
+
+        setPowerStateToDesired();
+    }
+
+    /**
+     * Radio power set from carrier action. if set to false means carrier desire to turn radio off
+     * and radio wont be re-enabled unless carrier explicitly turn it back on.
+     * @param enable indicate if radio power is enabled or disabled from carrier action.
+     */
+    public void setRadioPowerFromCarrier(boolean enable) {
+        mRadioDisabledByCarrier = !enable;
+        /// M:replace aosp logic by mtk logic.
+        /// Using RadioManager to controller the radio logic on the whole.
+        //setPowerStateToDesired();
+        RadioManager.getInstance().setRadioPower(
+                mDesiredPowerState, mPhone.getPhoneId());
+    }
+
+    /**
+     * These two flags manage the behavior of the cell lock -- the
+     * lock should be held if either flag is true.  The intention is
+     * to allow temporary acquisition of the lock to get a single
+     * update.  Such a lock grab and release can thus be made to not
+     * interfere with more permanent lock holds -- in other words, the
+     * lock will only be released if both flags are false, and so
+     * releases by temporary users will only affect the lock state if
+     * there is no continuous user.
+     */
+    private boolean mWantContinuousLocationUpdates;
+    private boolean mWantSingleLocationUpdate;
+
+    public void enableSingleLocationUpdate() {
+        if (mWantSingleLocationUpdate || mWantContinuousLocationUpdates) return;
+        mWantSingleLocationUpdate = true;
+        mCi.setLocationUpdates(true, obtainMessage(EVENT_LOCATION_UPDATES_ENABLED));
+    }
+
+    public void enableLocationUpdates() {
+        if (mWantSingleLocationUpdate || mWantContinuousLocationUpdates) return;
+        mWantContinuousLocationUpdates = true;
+        mCi.setLocationUpdates(true, obtainMessage(EVENT_LOCATION_UPDATES_ENABLED));
+    }
+
+    protected void disableSingleLocationUpdate() {
+        mWantSingleLocationUpdate = false;
+        if (!mWantSingleLocationUpdate && !mWantContinuousLocationUpdates) {
+            mCi.setLocationUpdates(false, null);
+        }
+    }
+
+    public void disableLocationUpdates() {
+        mWantContinuousLocationUpdates = false;
+        if (!mWantSingleLocationUpdate && !mWantContinuousLocationUpdates) {
+            mCi.setLocationUpdates(false, null);
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        int[] ints;
+        Message message;
+        switch (msg.what) {
+            case EVENT_SET_RADIO_POWER_OFF:
+                synchronized(this) {
+                    if (mPendingRadioPowerOffAfterDataOff &&
+                            (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
+                        if (DBG) log("EVENT_SET_RADIO_OFF, turn radio off now.");
+                        hangupAndPowerOff();
+                        mPendingRadioPowerOffAfterDataOffTag += 1;
+                        mPendingRadioPowerOffAfterDataOff = false;
+                    } else {
+                        log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 +
+                                "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
+                    }
+                }
+                break;
+
+            case EVENT_ICC_CHANGED:
+                onUpdateIccAvailability();
+                break;
+
+            /* MR2 newly added event handling START */
+            case EVENT_GET_CELL_INFO_LIST_BY_RATE:
+            case EVENT_GET_CELL_INFO_LIST: {
+                ar = (AsyncResult) msg.obj;
+                CellInfoResult result = (CellInfoResult) ar.userObj;
+                synchronized(result.lockObj) {
+                    if (ar.exception != null) {
+                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
+                        result.list = null;
+                    } else {
+                        result.list = (List<CellInfo>) ar.result;
+
+                        if (DBG) {
+                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size()
+                                    /*+ " list=" + result.list*/);
+                        }
+                    }
+                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
+                    mLastCellInfoList = result.list;
+                    // MTK add Common START
+                    if (msg.what == EVENT_GET_CELL_INFO_LIST_BY_RATE) {
+                        log("EVENT_GET_CELL_INFO_LIST_BY_RATE notify result");
+                        mPhone.notifyCellInfo(result.list);
+                    }
+                    // END
+                    result.lockObj.notify();
+                }
+                break;
+            }
+
+            case EVENT_GET_AVAILABLE_NETWORK_DONE:
+                log("EVENT_GET_AVAILABLE_NETWORK_DONE, radio is: " + mCi.getRadioState()
+                    + ", voiceReg = " + mSS.getVoiceRegState()
+                    + ", dataReg = " + mSS.getDataRegState());
+                if (mCi.getRadioState().isOn()
+                    && (mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE
+                     || mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE)) {
+                    log("EVENT_GET_AVAILABLE_NETWORK_DONE, need query again.");
+                    pollState(true);
+                }
+                break;
+
+            case EVENT_UNSOL_CELL_INFO_LIST: {
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
+                } else {
+                    List<CellInfo> list = (List<CellInfo>) ar.result;
+                    if (VDBG) {
+                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
+                    }
+                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
+                    mLastCellInfoList = list;
+                    mPhone.notifyCellInfo(list);
+                }
+                break;
+            }
+
+            case  EVENT_IMS_STATE_CHANGED: // received unsol
+                mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
+                break;
+
+            case EVENT_IMS_STATE_DONE:
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception == null) {
+                    int[] responseArray = (int[])ar.result;
+                    mImsRegistered = (responseArray[0] == 1) ? true : false;
+                }
+                break;
+
+            //GSM
+            case EVENT_RADIO_AVAILABLE:
+                //check if we boot up under airplane mode
+                if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    log("not BSP package, notify!");
+                    RadioManager.getInstance().notifyRadioAvailable(mPhone.getPhoneId());
+                }
+                //this is unnecessary
+                //setPowerStateToDesired();
+                break;
+
+            case EVENT_SIM_READY:
+                // Reset the mPreviousSubId so we treat a SIM power bounce
+                // as a first boot.  See b/19194287
+                mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
+                if (mPhone.isPhoneTypeGsm()) {
+                    boolean skipRestoringSelection = mPhone.getContext().getResources().getBoolean(
+                            com.android.internal.R.bool.skip_restoring_network_selection);
+                    if (DBG) log("skipRestoringSelection=" + skipRestoringSelection);
+                    if (!skipRestoringSelection) {
+                        // restore the previous network selection.
+                        mPhone.restoreSavedNetworkSelection(null);
+                    }
+                }
+                pollState();
+                // Signal strength polling stops when radio is off
+                queueNextSignalStrengthPoll();
+                break;
+
+            case EVENT_RADIO_STATE_CHANGED:
+            case EVENT_PHONE_TYPE_SWITCHED:
+                if(!mPhone.isPhoneTypeGsm() &&
+                        mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
+                    handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
+
+                    // Signal strength polling stops when radio is off.
+                    queueNextSignalStrengthPoll();
+                } else if (mPhone.isPhoneTypeGsm() &&
+                        mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON &&
+                        msg.what == EVENT_RADIO_STATE_CHANGED) {
+                    // Cover constructor signal strength polling stopped due to radio off.
+                    queueNextSignalStrengthPoll();
+                }
+                if (RadioManager.isMSimModeSupport()) {
+                    logd("handle [msg.what]=" + msg.what
+                            + ",MTK propiertary Power on flow, setRadioPower:  mDesiredPowerState="
+                            + mDesiredPowerState + "  phoneId=" + mPhone.getPhoneId());
+                    RadioManager.getInstance().setRadioPower(
+                            mDesiredPowerState, mPhone.getPhoneId());
+                }
+                else {
+                    // This will do nothing in the 'radio not available' case
+                    // setPowerStateToDesired();
+                    log("handle [msg.what]=" + msg.what + ",BSP package but use MTK Power on flow");
+                    RadioManager.getInstance().setRadioPower(
+                            mDesiredPowerState, mPhone.getPhoneId());
+                }
+                // These events are modem triggered, so pollState() needs to be forced
+                modemTriggeredPollState();
+                break;
+
+            case EVENT_NETWORK_STATE_CHANGED:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onNetworkStateChangeResult(ar);
+                }
+
+                modemTriggeredPollState();
+                break;
+
+            case EVENT_PS_NETWORK_STATE_CHANGED:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onPsNetworkStateChangeResult(ar);
+                }
+                modemTriggeredPollState();
+                break;
+
+            case EVENT_CS_NETWORK_STATE_CHANGED:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onNetworkStateChangeResult(ar);
+                }
+
+                break;
+
+            case EVENT_GET_SIGNAL_STRENGTH:
+                // This callback is called when signal strength is polled
+                // all by itself
+
+                if (!(mCi.getRadioState().isOn())) {
+                    // Polling will continue when radio turns back on
+                    return;
+                }
+                ar = (AsyncResult) msg.obj;
+                onSignalStrengthResult(ar);
+                queueNextSignalStrengthPoll();
+
+                break;
+
+            case EVENT_GET_LOC_DONE:
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                    String states[] = (String[])ar.result;
+                    if (mPhone.isPhoneTypeGsm()) {
+                        int lac = -1;
+                        int cid = -1;
+                        if (states.length >= 3) {
+                            try {
+                                if (states[1] != null && states[1].length() > 0) {
+                                    lac = Integer.parseInt(states[1], 16);
+                                }
+                                if (states[2] != null && states[2].length() > 0) {
+                                    cid = Integer.parseInt(states[2], 16);
+                                }
+                            } catch (NumberFormatException ex) {
+                                Rlog.w(LOG_TAG, "error parsing location: " + ex);
+                            }
+                        }
+                        ((GsmCellLocation)mCellLoc).setLacAndCid(lac, cid);
+                    } else {
+                        int baseStationId = -1;
+                        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
+                        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
+                        int systemId = -1;
+                        int networkId = -1;
+
+                        if (states.length > 9) {
+                            try {
+                                if (states[4] != null) {
+                                    baseStationId = Integer.parseInt(states[4]);
+                                }
+                                if (states[5] != null) {
+                                    baseStationLatitude = Integer.parseInt(states[5]);
+                                }
+                                if (states[6] != null) {
+                                    baseStationLongitude = Integer.parseInt(states[6]);
+                                }
+                                // Some carriers only return lat-lngs of 0,0
+                                if (baseStationLatitude == 0 && baseStationLongitude == 0) {
+                                    baseStationLatitude  = CdmaCellLocation.INVALID_LAT_LONG;
+                                    baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
+                                }
+                                if (states[8] != null) {
+                                    systemId = Integer.parseInt(states[8]);
+                                }
+                                if (states[9] != null) {
+                                    networkId = Integer.parseInt(states[9]);
+                                }
+                            } catch (NumberFormatException ex) {
+                                loge("error parsing cell location data: " + ex);
+                            }
+                        }
+
+                        ((CdmaCellLocation)mCellLoc).setCellLocationData(baseStationId,
+                                baseStationLatitude, baseStationLongitude, systemId, networkId);
+                    }
+                    mPhone.notifyLocationChanged();
+                }
+
+                // Release any temporary cell lock, which could have been
+                // acquired to allow a single-shot location update.
+                disableSingleLocationUpdate();
+                break;
+
+            case EVENT_POLL_STATE_REGISTRATION:
+            case EVENT_POLL_STATE_GPRS:
+            case EVENT_POLL_STATE_OPERATOR:
+                ar = (AsyncResult) msg.obj;
+                handlePollStateResult(msg.what, ar);
+                break;
+
+            case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
+                if (DBG) log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
+                ar = (AsyncResult) msg.obj;
+                if (mPhone.isPhoneTypeGsm()) {
+                    handlePollStateResult(msg.what, ar);
+                } else {
+                    if (ar.exception == null && ar.result != null) {
+                        ints = (int[])ar.result;
+                        if (ints[0] == 1) {  // Manual selection.
+                            mPhone.setNetworkSelectionModeAutomatic(null);
+                        }
+                    } else {
+                        log("Unable to getNetworkSelectionMode");
+                    }
+                }
+                break;
+
+            case EVENT_POLL_SIGNAL_STRENGTH:
+                // Just poll signal strength...not part of pollState()
+                if (mPhone.isPhoneTypeGsm()) {
+                    log("handle EVENT_POLL_SIGNAL_STRENGTH GSM " + mDontPollSignalStrength);
+                    if (mDontPollSignalStrength) {
+                        // The radio is telling us about signal strength changes
+                        // we don't have to ask it
+                        return;
+                    }
+                }
+                mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
+                break;
+
+            case EVENT_NITZ_TIME:
+                ar = (AsyncResult) msg.obj;
+
+                String nitzString = (String)((Object[])ar.result)[0];
+                long nitzReceiveTime = ((Long)((Object[])ar.result)[1]).longValue();
+
+                setTimeFromNITZString(nitzString, nitzReceiveTime);
+                break;
+
+            case EVENT_SIGNAL_STRENGTH_UPDATE:
+                // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
+
+                ar = (AsyncResult) msg.obj;
+
+                // The radio is telling us about signal strength changes
+                // we don't have to ask it
+                mDontPollSignalStrength = true;
+                if (mPhone.isPhoneTypeGsm()) {
+                    if ((ar.exception == null) && (ar.result != null)) {
+                        mSignalStrengthChangedRegistrants.notifyResult(
+                        new SignalStrength((SignalStrength) ar.result));
+                    }
+                }
+
+                onSignalStrengthResult(ar);
+                break;
+
+            case EVENT_SIM_RECORDS_LOADED:
+                log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
+                updatePhoneObject();
+                updateOtaspState();
+                if (mPhone.isPhoneTypeGsm()) {
+                    /* updateSpnDisplay() will be executed in refreshSpnDisplay() */
+                    ////updateSpnDisplay();
+                    // pollState() result may be faster than load EF complete, so
+                    // update ss.alphaLongShortName
+                    refreshSpnDisplay();
+
+                    /// M: Notify service state changed if need notify. @{
+                    if (mNeedNotify) {
+                        mPhone.notifyServiceStateChanged(mSS);
+                        mNeedNotify = false;
+                    }
+                    /// @}
+                }
+                break;
+            // GSM only event.
+            case EVENT_SIM_OPL_LOADED:
+                ar = (AsyncResult)msg.obj;
+                if ((ar != null) && (ar.result != null)) {
+                    Integer id = (Integer)ar.result;
+                    log("EVENT_SIM_OPL_LOADED: id=" + id);
+                    if (id.intValue() == IccRecords.EVENT_OPL) {
+                        if (mPhone.isPhoneTypeGsm()) {
+                            refreshSpnDisplay();
+                            if (mNeedNotify) {
+                                mPhone.notifyServiceStateChanged(mSS);
+                                mNeedNotify = false;
+                            }
+                        } else {
+                            loge("EVENT_SIM_OPL_LOADED should not be here");
+                        }
+                    }
+                }
+                break;
+            case EVENT_LOCATION_UPDATES_ENABLED:
+                log("handle EVENT_LOCATION_UPDATES_ENABLED");
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                    mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
+                }
+                break;
+
+            case EVENT_SET_PREFERRED_NETWORK_TYPE:
+                log("handle EVENT_SET_PREFERRED_NETWORK_TYPE");
+
+                ar = (AsyncResult) msg.obj;
+                // Don't care the result, only use for dereg network (COPS=2)
+                message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
+                mCi.setPreferredNetworkType(mPreferredNetworkType, message);
+                break;
+
+            case EVENT_RESET_PREFERRED_NETWORK_TYPE:
+                log("handle EVENT_RESET_PREFERRED_NETWORK_TYPE");
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.userObj != null) {
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                            = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_PREFERRED_NETWORK_TYPE:
+                log("handle EVENT_GET_PREFERRED_NETWORK_TYPE");
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                    mPreferredNetworkType = ((int[])ar.result)[0];
+                } else {
+                    mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
+                }
+
+                message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
+                int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
+
+                mCi.setPreferredNetworkType(toggledNetworkType, message);
+                break;
+
+            case EVENT_CHECK_REPORT_GPRS:
+                log("handle EVENT_CHECK_REPORT_GPRS");
+
+                if (mPhone.isPhoneTypeGsm() && mSS != null &&
+                        !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
+
+                    // Can't register data service while voice service is ok
+                    // i.e. CREG is ok while CGREG is not
+                    // possible a network or baseband side error
+                    GsmCellLocation loc = ((GsmCellLocation)mPhone.getCellLocation());
+                    EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL,
+                            mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
+                    mReportedGprsNoReg = true;
+                }
+                mStartedGprsRegCheck = false;
+                break;
+
+            case EVENT_RESTRICTED_STATE_CHANGED:
+                if (mPhone.isPhoneTypeGsm()) {
+                    // This is a notification from
+                    // CommandsInterface.setOnRestrictedStateChanged
+
+                    if (DBG) log("EVENT_RESTRICTED_STATE_CHANGED");
+
+                    ar = (AsyncResult) msg.obj;
+
+                    onRestrictedStateChanged(ar);
+                }
+                break;
+
+            case EVENT_ALL_DATA_DISCONNECTED:
+                int dds = SubscriptionManager.getDefaultDataSubscriptionId();
+                ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
+                synchronized(this) {
+                    if (mPendingRadioPowerOffAfterDataOff) {
+                        if (DBG) log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
+                        hangupAndPowerOff();
+                        mPendingRadioPowerOffAfterDataOff = false;
+                    } else {
+                        log("EVENT_ALL_DATA_DISCONNECTED is stale");
+                    }
+                }
+                break;
+
+            case EVENT_CHANGE_IMS_STATE:
+                if (DBG) log("EVENT_CHANGE_IMS_STATE:");
+
+                setPowerStateToDesired();
+                break;
+            case EVENT_INVALID_SIM_INFO: //ALPS00248788
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onInvalidSimInfoReceived(ar);
+                }
+                break;
+            case EVENT_MODULATION_INFO:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onModulationInfoReceived(ar);
+                }
+                break;
+            case EVENT_IMEI_LOCK: //ALPS00296298
+                if (mPhone.isPhoneTypeGsm()) {
+                    log("handle EVENT_IMEI_LOCK GSM");
+                    mIsImeiLock = true;
+                }
+                break;
+            case EVENT_ICC_REFRESH:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception == null) {
+                        IccRefreshResponse res = ((IccRefreshResponse) ar.result);
+                        if (res == null) {
+                            log("IccRefreshResponse is null");
+                            break;
+                        }
+                        switch (res.refreshResult) {
+                            case IccRefreshResponse.REFRESH_INIT_FULL_FILE_UPDATED:
+                            case 6: // NAA session Reset only applicable for a 3G platform
+                                /* ALPS00949490 */
+                                mLastRegisteredPLMN = null;
+                                mLastPSRegisteredPLMN = null;
+                                log("Reset mLastRegisteredPLMN/mLastPSRegisteredPLMN"
+                                        + "for ICC refresh");
+                                break;
+
+                            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
+                            case IccRefreshResponse.REFRESH_INIT_FILE_UPDATED:
+                                if (res.efId == IccConstants.EF_IMSI) {
+                                    mLastRegisteredPLMN = null;
+                                    mLastPSRegisteredPLMN = null;
+                                    log("Reset flag of IVSR for IMSI update");
+                                    break;
+                                }
+                                break;
+                            default:
+                                log("GSST EVENT_ICC_REFRESH IccRefreshResponse =" + res);
+                            break;
+                        }
+                    }
+                }
+                break;
+            case EVENT_ENABLE_EMMRRS_STATUS:
+                if (mPhone.isPhoneTypeGsm()) {
+                    log("handle EVENT_ENABLE_EMMRRS_STATUS GSM");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception == null) {
+                        String data[] = (String []) ar.result;
+                        log("EVENT_ENABLE_EMMRRS_STATUS, data[0] is : " + data[0]);
+                        log("EVENT_ENABLE_EMMRRS_STATUS, einfo value is : " + data[0].substring(8));
+                        int oldValue = Integer.valueOf(data[0].substring(8));
+                        int value = oldValue | 0x80;
+                        log("EVENT_ENABLE_EMMRRS_STATUS, einfo value change is : " + value);
+                        if (oldValue != value) {
+                            setEINFO(value, null);
+                        }
+                    }
+                }
+                break;
+            case EVENT_DISABLE_EMMRRS_STATUS:
+                if (mPhone.isPhoneTypeGsm()) {
+                    log("handle EVENT_DISABLE_EMMRRS_STATUS GSM");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception == null) {
+                        String data[] = (String []) ar.result;
+                        log("EVENT_DISABLE_EMMRRS_STATUS, data[0] is : " + data[0]);
+                        log("EVENT_DISABLE_EMMRRS_STATUS, einfo value is : "
+                                + data[0].substring(8));
+
+                        try {
+                            int oldValue = Integer.valueOf(data[0].substring(8));
+                            int value = oldValue & 0xff7f;
+                            log("EVENT_DISABLE_EMMRRS_STATUS, einfo value change is : " + value);
+                            if (oldValue != value) {
+                                setEINFO(value, null);
+                            }
+                        } catch (NumberFormatException ex) {
+                            loge("Unexpected einfo value : " + ex);
+                        }
+                    }
+                }
+                break;
+            case EVENT_FEMTO_CELL_INFO:
+                ar = (AsyncResult) msg.obj;
+                onFemtoCellInfoResult(ar);
+                break;
+
+            case EVENT_IMS_CAPABILITY_CHANGED:
+                if (DBG) log("EVENT_IMS_CAPABILITY_CHANGED");
+                updateSpnDisplay();
+                break;
+            case EVENT_NETWORK_EVENT:
+                if (mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+                    onNetworkEventReceived(ar);
+                }
+                break;
+
+
+            //CDMA
+            case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
+                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
+                break;
+
+            case EVENT_RUIM_READY:
+                /// M: [CDMA] @{
+                if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+                    mIsSubscriptionFromRuim = true;
+                }
+                /// @}
+
+                if (mPhone.isPhoneTypeCdmaLte()) {
+                    // Subscription will be read from SIM I/O
+                    if (DBG) log("Receive EVENT_RUIM_READY");
+                    pollState();
+                } else {
+                    if (DBG) log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
+                    getSubscriptionInfoAndStartPollingThreads();
+                }
+
+                // Only support automatic selection mode in CDMA.
+                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
+
+                break;
+
+            case EVENT_NV_READY:
+                updatePhoneObject();
+
+                // Only support automatic selection mode in CDMA.
+                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
+
+                // For Non-RUIM phones, the subscription information is stored in
+                // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
+                // subscription info.
+                getSubscriptionInfoAndStartPollingThreads();
+                break;
+
+            case EVENT_POLL_STATE_CDMA_SUBSCRIPTION: // Handle RIL_CDMA_SUBSCRIPTION
+                if (!mPhone.isPhoneTypeGsm()) {
+                    ar = (AsyncResult) msg.obj;
+
+                    if (ar.exception == null) {
+                        String cdmaSubscription[] = (String[]) ar.result;
+                        if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
+                            mMdn = cdmaSubscription[0];
+                            parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
+
+                            mMin = cdmaSubscription[3];
+                            mPrlVersion = cdmaSubscription[4];
+                            if (DBG) log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
+
+                            mIsMinInfoReady = true;
+
+                            updateOtaspState();
+                            // Notify apps subscription info is ready
+                            notifyCdmaSubscriptionInfoReady();
+
+                            if (!mIsSubscriptionFromRuim && mIccRecords != null) {
+                                if (DBG) {
+                                    log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
+                                }
+                                mIccRecords.setImsi(getImsi());
+                            } else {
+                                if (DBG) {
+                                    log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " +
+                                            "type device - not setting Imsi in mIccRecords");
+                                }
+                            }
+                        } else {
+                            if (DBG) {
+                                log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " +
+                                        "params num=" + cdmaSubscription.length);
+                            }
+                        }
+                    }
+                }
+                break;
+
+            case EVENT_RUIM_RECORDS_LOADED:
+                if (!mPhone.isPhoneTypeGsm()) {
+                    log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
+                    updatePhoneObject();
+                    if (mPhone.isPhoneTypeCdma()) {
+                        updateSpnDisplay();
+                    } else {
+                        RuimRecords ruim = (RuimRecords) mIccRecords;
+                        if (ruim != null) {
+                            if (ruim.isProvisioned()) {
+                                mMdn = ruim.getMdn();
+                                mMin = ruim.getMin();
+                                parseSidNid(ruim.getSid(), ruim.getNid());
+                                mPrlVersion = ruim.getPrlVersion();
+                                mIsMinInfoReady = true;
+                            }
+                            updateOtaspState();
+
+                            /// M: [CDMALTE] Happen in CDMA dual mode card, if change
+                            /// from gsm to cdma, we should update spn gain. @{
+                            updateSpnDisplay();
+                            /// @}
+
+                            // Notify apps subscription info is ready
+                            notifyCdmaSubscriptionInfoReady();
+                        }
+                        // SID/NID/PRL is loaded. Poll service state
+                        // again to update to the roaming state with
+                        // the latest variables.
+                        pollState();
+                    }
+                }
+                break;
+
+            case EVENT_ERI_FILE_LOADED:
+                // Repoll the state once the ERI file has been loaded.
+                if (DBG) log("ERI file has been loaded, repolling.");
+                // MTK
+                mEriTriggeredPollState = true;
+                pollState();
+                break;
+
+            case EVENT_OTA_PROVISION_STATUS_CHANGE:
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    ints = (int[]) ar.result;
+                    int otaStatus = ints[0];
+                    if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED
+                            || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
+                        if (DBG) log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
+                        mCi.getCDMASubscription( obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
+                    }
+                }
+                break;
+
+            case EVENT_CDMA_PRL_VERSION_CHANGED:
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    ints = (int[]) ar.result;
+                    mPrlVersion = Integer.toString(ints[0]);
+                }
+                break;
+
+            default:
+                log("Unhandled message with number: " + msg.what);
+                break;
+        }
+    }
+
+    protected int calculateDeviceRatMode(int phoneId) {
+        int networkType = -1;
+        int restrictedNwMode = -1 ;
+        if (mPhone.isPhoneTypeGsm()) {
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    if (mServiceStateExt.isSupportRatBalancing()) {
+                        logd("networkType is controlled by RAT Blancing,"
+                            + " no need to set network type");
+                        return -1;
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+               try {
+                   restrictedNwMode = mServiceStateExt.needAutoSwitchRatMode(phoneId, mLocatedPlmn);
+               } catch (RuntimeException e) {
+                   e.printStackTrace();
+               }
+            }
+            networkType = getPreferredNetworkModeSettings(phoneId);
+            if (restrictedNwMode >= Phone.NT_MODE_WCDMA_PREF) {
+               if (restrictedNwMode != networkType) {
+                   logd("Revise networkType to " + restrictedNwMode);
+                   networkType = restrictedNwMode;
+               }
+            }
+
+        } else {
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    networkType = mServiceStateExt.getNetworkTypeForMota(phoneId);
+                    log("[CDMA], networkType for mota is: " + networkType);
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+            if (networkType == -1) {
+                networkType = getPreferredNetworkModeSettings(phoneId);
+            }
+
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+               try {
+                   restrictedNwMode = mServiceStateExt.needAutoSwitchRatMode(phoneId, mLocatedPlmn);
+               } catch (RuntimeException e) {
+                   e.printStackTrace();
+               }
+            }
+
+            if (restrictedNwMode >= Phone.NT_MODE_WCDMA_PREF) {
+               if (restrictedNwMode != networkType) {
+                   logd("Revise networkType to " + restrictedNwMode);
+                   networkType = restrictedNwMode;
+               }
+            }
+        }
+        logd("calculateDeviceRatMode=" + networkType + ", restrictedNwMode=" + restrictedNwMode);
+        return networkType;
+    }
+
+    protected void setDeviceRatMode(int phoneId) {
+        int networkType = -1;
+        networkType = calculateDeviceRatMode(phoneId);
+        if (networkType >= Phone.NT_MODE_WCDMA_PREF) {
+            mPhone.setPreferredNetworkType(networkType, null);
+        }
+
+    }
+
+    public boolean isPsRegStateRoamByUnsol() {
+        return regCodeIsRoaming(mPsRegStateRaw) && !isSameNamedOperators(mSS);
+    }
+
+
+    protected boolean isSidsAllZeros() {
+        if (mHomeSystemId != null) {
+            for (int i=0; i < mHomeSystemId.length; i++) {
+                if (mHomeSystemId[i] != 0) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Check whether a specified system ID that matches one of the home system IDs.
+     */
+    private boolean isHomeSid(int sid) {
+        if (mHomeSystemId != null) {
+            for (int i=0; i < mHomeSystemId.length; i++) {
+                if (sid == mHomeSystemId[i]) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public String getMdnNumber() {
+        return mMdn;
+    }
+
+    public String getCdmaMin() {
+        return mMin;
+    }
+
+    /** Returns null if NV is not yet ready */
+    public String getPrlVersion() {
+        return mPrlVersion;
+    }
+
+    /**
+     * Returns IMSI as MCC + MNC + MIN
+     */
+    public String getImsi() {
+        // TODO: When RUIM is enabled, IMSI will come from RUIM not build-time props.
+        String operatorNumeric = ((TelephonyManager) mPhone.getContext().
+                getSystemService(Context.TELEPHONY_SERVICE)).
+                getSimOperatorNumericForPhone(mPhone.getPhoneId());
+
+        if (!TextUtils.isEmpty(operatorNumeric) && getCdmaMin() != null) {
+            return (operatorNumeric + getCdmaMin());
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Check if subscription data has been assigned to mMin
+     *
+     * return true if MIN info is ready; false otherwise.
+     */
+    public boolean isMinInfoReady() {
+        return mIsMinInfoReady;
+    }
+
+    /**
+     * Returns OTASP_UNKNOWN, OTASP_UNINITIALIZED, OTASP_NEEDED or OTASP_NOT_NEEDED
+     */
+    public int getOtasp() {
+        int provisioningState;
+        // if sim is not loaded, return otasp uninitialized
+        if(!mPhone.getIccRecordsLoaded()) {
+            if(DBG) log("getOtasp: otasp uninitialized due to sim not loaded");
+            return OTASP_UNINITIALIZED;
+        }
+        // if voice tech is Gsm, return otasp not needed
+        if(mPhone.isPhoneTypeGsm()) {
+            if(DBG) log("getOtasp: otasp not needed for GSM");
+            return OTASP_NOT_NEEDED;
+        }
+        // for ruim, min is null means require otasp.
+        if (mIsSubscriptionFromRuim && mMin == null) {
+            return OTASP_NEEDED;
+        }
+        if (mMin == null || (mMin.length() < 6)) {
+            if (DBG) log("getOtasp: bad mMin='" + mMin + "'");
+            provisioningState = OTASP_UNKNOWN;
+        } else {
+            if ((mMin.equals(UNACTIVATED_MIN_VALUE)
+                    || mMin.substring(0,6).equals(UNACTIVATED_MIN2_VALUE))
+                    || SystemProperties.getBoolean("test_cdma_setup", false)) {
+                provisioningState = OTASP_NEEDED;
+            } else {
+                provisioningState = OTASP_NOT_NEEDED;
+            }
+        }
+        if (DBG) log("getOtasp: state=" + provisioningState);
+        return provisioningState;
+    }
+
+    protected void parseSidNid (String sidStr, String nidStr) {
+        if (sidStr != null) {
+            String[] sid = sidStr.split(",");
+            mHomeSystemId = new int[sid.length];
+            for (int i = 0; i < sid.length; i++) {
+                try {
+                    mHomeSystemId[i] = Integer.parseInt(sid[i]);
+                } catch (NumberFormatException ex) {
+                    loge("error parsing system id: " + ex);
+                }
+            }
+        }
+        if (DBG) log("CDMA_SUBSCRIPTION: SID=" + sidStr);
+
+        if (nidStr != null) {
+            String[] nid = nidStr.split(",");
+            mHomeNetworkId = new int[nid.length];
+            for (int i = 0; i < nid.length; i++) {
+                try {
+                    mHomeNetworkId[i] = Integer.parseInt(nid[i]);
+                } catch (NumberFormatException ex) {
+                    loge("CDMA_SUBSCRIPTION: error parsing network id: " + ex);
+                }
+            }
+        }
+        if (DBG) log("CDMA_SUBSCRIPTION: NID=" + nidStr);
+    }
+
+    protected void updateOtaspState() {
+        int otaspMode = getOtasp();
+        int oldOtaspMode = mCurrentOtaspMode;
+        mCurrentOtaspMode = otaspMode;
+
+        if (oldOtaspMode != mCurrentOtaspMode) {
+            if (DBG) {
+                log("updateOtaspState: call notifyOtaspChanged old otaspMode=" +
+                        oldOtaspMode + " new otaspMode=" + mCurrentOtaspMode);
+            }
+            mPhone.notifyOtaspChanged(mCurrentOtaspMode);
+        }
+    }
+
+    protected Phone getPhone() {
+        return mPhone;
+    }
+
+    //MTK-ADD Start : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS
+    //only SIM card or CS domain network registeration temporary failure
+    /* update  mNewCellLoc when CS is not registered but PS is registered */
+    int psLac = -1;
+    int psCid = -1;
+    //MTK-ADD END: for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS only
+    //SIM card or CS domain network registeration temporary failure
+
+
+    protected void handlePollStateResult(int what, AsyncResult ar) {
+        psLac = -1;
+        psCid = -1;
+
+        // Ignore stale requests from last poll
+        if (ar.userObj != mPollingContext) {
+            if (what == EVENT_POLL_STATE_REGISTRATION) {
+                logd("EVENT_POLL_STATE_REGISTRATION, return due to(ar.userObj != mPollingContext)");
+            } else if (what == EVENT_POLL_STATE_GPRS) {
+                logd("EVENT_POLL_STATE_GPRS, return due to(ar.userObj != mPollingContext)");
+            } else if (what == EVENT_POLL_STATE_OPERATOR) {
+                logd("EVENT_POLL_STATE_OPERATOR, return due to(ar.userObj != mPollingContext)");
+            }
+            return;
+        }
+
+        if (ar.exception != null) {
+            CommandException.Error err=null;
+
+            if (ar.exception instanceof CommandException) {
+                err = ((CommandException)(ar.exception)).getCommandError();
+            }
+
+            if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
+                // Radio has crashed or turned off
+                cancelPollState();
+                loge("handlePollStateResult cancelPollState due to RADIO_NOT_AVAILABLE");
+                // Invoke pollState again to trigger pollStateDone() if needed
+                if (hasPendingPollState) {
+                    hasPendingPollState = false;
+                    pollState();
+                    if (DBG) {
+                        loge("handlePollStateResult trigger pending pollState()");
+                    }
+                } else if (mCi.getRadioState() != CommandsInterface.RadioState.RADIO_ON) {
+                    // Clear status and invoke pollStateDone to notify other module
+                    mNewSS.setStateOff();
+                    mNewCellLoc.setStateInvalid();
+                    setSignalStrengthDefaultValues();
+                    mGotCountryCode = false;
+                    mNitzUpdatedTime = false;
+                    setNullState();
+                    mPsRegStateRaw = ServiceState.RIL_REG_STATE_NOT_REG;
+                    pollStateDone();
+                    loge("handlePollStateResult pollStateDone to notify RADIO_NOT_AVAILABLE");
+                }
+                return;
+            }
+
+            if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
+                loge("RIL implementation has returned an error where it must succeed" +
+                        ar.exception);
+            }
+        } else try {
+            handlePollStateResultMessage(what, ar);
+        } catch (RuntimeException ex) {
+            loge("Exception while polling service state. Probably malformed RIL response." + ex);
+        }
+
+        mPollingContext[0]--;
+
+        if (mPollingContext[0] == 0) {
+            // For the newer MD, we need clear the operator when we're not in service
+            if (mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE &&
+                    mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
+                mNewSS.setOperatorName(null, null, null);
+            }
+
+            if (mPhone.isPhoneTypeGsm()) {
+
+                /**
+                 * Notify pending PS restricted status here
+                 */
+                if (mPendingPsRestrictDisabledNotify) {
+                    mPsRestrictDisabledRegistrants.notifyRegistrants();
+                    setNotification(PS_DISABLED);
+                    mPendingPsRestrictDisabledNotify = false;
+                }
+
+                /**
+                 * [ALPS00006527]
+                 * Only when CS in service, treat PS as in service
+                 */
+                if ((mNewSS.getState() != ServiceState.STATE_IN_SERVICE) &&
+                    (mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+                        //when CS not registered, we update cellLoc by +CGREG
+                        log("update cellLoc by +CGREG");
+                        ((GsmCellLocation)mNewCellLoc).setLacAndCid(psLac, psCid);
+                }
+                updateRoamingState();
+
+                /**
+                 * Control mEmergencyOnly to determine ECC only string.
+                 */
+                if (voiceUrcWith4G == true) {
+                    mEmergencyOnly = false;
+                    // If voice's urc is 4G, show ECC only when IMS's ECC is supported and OOS
+                    ImsPhone imsPhone = (ImsPhone) mPhone.getImsPhone();
+                    if (mPhone.isImsUseEnabled() && (imsPhone != null)) {
+                        if (imsPhone.getServiceState() != null) {
+                            boolean isImsEccOnly = imsPhone.isSupportLteEcc();
+                            if (isImsEccOnly &&
+                                    (mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE) &&
+                                    (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE)) {
+                                log("set mEmergencyOnly = true for Ims ECC");
+                                mEmergencyOnly = true;
+                            }
+                        }
+                    }
+                } else {
+                    // for CS not registered , PS regsitered (ex: LTE PS only mode or
+                    // 2/3G PS only SIM card or CS domain network registeration temporary failure
+                    if ((mEmergencyOnly == true) && // CS is out of service and supports ECC
+                            (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+                        mEmergencyOnly = false;
+                    }
+                }
+                mNewSS.setEmergencyOnly(mEmergencyOnly);
+            } else {
+                boolean namMatch = false;
+                if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
+                    namMatch = true;
+                }
+
+                // Setting SS Roaming (general)
+                if (mIsSubscriptionFromRuim) {
+                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
+                }
+                // For CDMA, voice and data should have the same roaming status
+                final boolean isVoiceInService =
+                        (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
+                final int dataRegType = mNewSS.getRilDataRadioTechnology();
+                if (isVoiceInService && ServiceState.isCdma(dataRegType)) {
+                    mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
+                }
+
+                /// M: [CDMA] Add for show EccButton when sim out of service. @{
+                mEmergencyOnly = false;
+                if (mCi.getRadioState().isOn()) {
+                    if ((mNewSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE)
+                            && (mNewSS.getDataRegState() == ServiceState.STATE_OUT_OF_SERVICE)
+                            && mNetworkExsit) {
+                        mEmergencyOnly = true;
+                    }
+                    mEmergencyOnly = mergeEmergencyOnlyCdmaIms(mEmergencyOnly);
+                }
+                if (DBG) {
+                    log("[CDMA]handlePollStateResult: set mEmergencyOnly=" + mEmergencyOnly
+                            + ", mNetworkExsit=" + mNetworkExsit);
+                }
+                mNewSS.setEmergencyOnly(mEmergencyOnly);
+                /// @}
+
+                // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
+                mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
+                mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
+                boolean isPrlLoaded = true;
+                if (TextUtils.isEmpty(mPrlVersion)) {
+                    isPrlLoaded = false;
+                }
+                if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology()
+                        == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
+                    log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
+                    mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
+                } else if (!isSidsAllZeros()) {
+                    if (!namMatch && !mIsInPrl) {
+                        // Use default
+                        mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
+                    } else if (namMatch && !mIsInPrl) {
+                        // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
+                        if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
+                            log("Turn off roaming indicator as voice is LTE");
+                            mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
+                        } else {
+                            mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
+                        }
+                    } else if (!namMatch && mIsInPrl) {
+                        // Use the one from PRL/ERI
+                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
+                    } else {
+                        // It means namMatch && mIsInPrl
+                        if ((mRoamingIndicator <= 2)) {
+                            mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
+                        } else {
+                            // Use the one from PRL/ERI
+                            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
+                        }
+                    }
+                }
+
+                int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
+                mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator,
+                        mDefaultRoamingIndicator));
+                mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator,
+                        mDefaultRoamingIndicator));
+
+                // NOTE: Some operator may require overriding mCdmaRoaming
+                // (set by the modem), depending on the mRoamingIndicator.
+
+                if (DBG) {
+                    log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator()
+                            + ". voiceRoaming = " + mNewSS.getVoiceRoaming()
+                            + ". dataRoaming = " + mNewSS.getDataRoaming()
+                            + ", isPrlLoaded = " + isPrlLoaded
+                            + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl
+                            + ", mRoamingIndicator = " + mRoamingIndicator
+                            + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
+                }
+            }
+            pollStateDone();
+        }
+
+    }
+
+    /**
+     * Set roaming state when cdmaRoaming is true and ons is different from spn
+     * @param cdmaRoaming TS 27.007 7.2 CREG registered roaming
+     * @param s ServiceState hold current ons
+     * @return true for roaming state set
+     */
+    private boolean isRoamingBetweenOperators(boolean cdmaRoaming, ServiceState s) {
+        return cdmaRoaming && !isSameOperatorNameFromSimAndSS(s);
+    }
+
+    void handlePollStateResultMessage(int what, AsyncResult ar) {
+        int ints[];
+        String states[];
+        switch (what) {
+            case EVENT_POLL_STATE_REGISTRATION: {
+                if (mPhone.isPhoneTypeGsm()) {
+                    states = (String[]) ar.result;
+                    int lac = -1;
+                    int cid = -1;
+                    int type = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
+                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
+                    int reasonRegStateDenied = -1;
+                    int psc = -1;
+                    int rejCause = -1;
+                    if (states.length > 0) {
+                        try {
+                            regState = Integer.parseInt(states[0]);
+                            if (states.length >= 3) {
+                                if (states[1] != null && states[1].length() > 0) {
+                                    //[ALPS00907900]-START
+                                    int tempLac = Integer.parseInt(states[1], 16);
+                                    if (tempLac < 0) {
+                                        log("set Lac to previous value");
+                                        tempLac = ((GsmCellLocation)mCellLoc).getLac();
+                                    }
+                                    lac = tempLac;
+                                    //[ALPS00907900]-END
+
+                                }
+                                if (states[2] != null && states[2].length() > 0) {
+                                    //[ALPS00907900]-START
+                                    int tempCid = Integer.parseInt(states[2], 16);
+                                    if (tempCid < 0) {
+                                        log("set Cid to previous value");
+                                        tempCid = ((GsmCellLocation)mCellLoc).getCid();
+                                    }
+                                    cid = tempCid;
+                                    //[ALPS00907900]-END
+                                }
+
+                                // states[3] (if present) is the current radio technology
+                                if (states.length >= 4 &&
+                                        states[3] != null &&
+                                        states[3].length() > 0) {
+                                    //[ALPS01810775,ALPS01868743] -Start: update network type at
+                                     //screen off
+                                    // ALPS03091813 for ECREG optimization support
+                                    int mNwType = Integer.parseInt(states[3]);
+                                    if (mNwType == -1) {
+                                        // for ECREG not support case, act is -1 with short CREG
+                                        // the network type is unknown(0)
+                                        updateNetworkInfo(regState, 0);
+                                    } else {
+                                        // for ECREG support, act should not be -1 and it is valid
+                                        mNewSS.setRilVoiceRadioTechnology(mNwType);
+                                    }
+                                     //[ALPS01810775,ALPS01868743] -End
+                                }
+
+                                if (states.length >= 14 &&
+                                        states[13] != null && states[13].length() > 0) {
+                                    rejCause = Integer.parseInt(states[13]);
+                                    mNewSS.setVoiceRejectCause(rejCause);
+                                    logd("set voice reject cause to " + rejCause);
+                                }
+                            }
+                            if (states.length > 14) {
+                                if (states[14] != null && states[14].length() > 0) {
+                                    psc = Integer.parseInt(states[14], 16);
+                                }
+                            }
+
+                            log("EVENT_POLL_STATE_REGISTRATION mSS getRilVoiceRadioTechnology:"
+                                    + mSS.getRilVoiceRadioTechnology() +
+                                    ", regState:" + regState +
+                                    ", NewSS RilVoiceRadioTechnology:"
+                                    + mNewSS.getRilVoiceRadioTechnology() +
+                                    ", lac:" + lac +
+                                    ", cid:" + cid);
+                        } catch (NumberFormatException ex) {
+                            loge("error parsing RegistrationState: " + ex);
+                        }
+                    }
+
+                    mGsmRoaming = regCodeIsRoaming(regState);
+                    mNewSS.setVoiceRegState(regCodeToServiceState(regState));
+
+                    /// M: [GSM] @{
+                    if (mGsmRoaming) {
+                        mNewSS.setRilVoiceRegState(ServiceState.RIL_REG_STATE_ROAMING);
+                    } else {
+                        mNewSS.setRilVoiceRegState(regState);
+                    }
+                    /// @}
+
+                    boolean isVoiceCapable = mPhone.getContext().getResources()
+                            .getBoolean(com.android.internal.R.bool.config_voice_capable);
+                    if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED
+                            || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED
+                            || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED
+                            || regState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)
+                            && isVoiceCapable) {
+                        mEmergencyOnly = true;
+                    } else {
+                        mEmergencyOnly = false;
+                    }
+
+                    log("[states.length] = " + states.length + ", regState = " + regState
+                            + ", isVoiceCapable = " + isVoiceCapable + ", mEmergencyOnly = "
+                            + mEmergencyOnly);
+
+                    // LAC and CID are -1 if not avail. LAC and CID will be updated in
+
+                    // onNetworkStateChangeResult() when in OUT_SERVICE
+                    if (states.length > 3) {
+                        /* ALPS00291583: ignore unknown lac or cid value */
+                        if (lac == 0xfffe || cid == 0x0fffffff) {
+                            log("unknown lac:" + lac + " or cid:" + cid);
+                        } else {
+                            /* AT+CREG? result won't include <lac> and <cid> when  in OUT_SERVICE */
+                            if (regCodeToServiceState(regState)
+                                    != ServiceState.STATE_OUT_OF_SERVICE) {
+                                ((GsmCellLocation)mNewCellLoc).setLacAndCid(lac, cid);
+                            }
+                        }
+                    }
+                    ((GsmCellLocation)mNewCellLoc).setPsc(psc);
+                    // Check whether EONS name changed
+                    hasEonsChanged();
+                } else {
+                    states = (String[])ar.result;
+
+                    int registrationState = 4;     //[0] registrationState
+                    int radioTechnology = -1;      //[3] radioTechnology
+                    int baseStationId = -1;        //[4] baseStationId
+                    //[5] baseStationLatitude
+                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
+                    //[6] baseStationLongitude
+                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
+                    int cssIndicator = 0;          //[7] init with 0, because it is treated as a boolean
+                    int systemId = 0;              //[8] systemId
+                    int networkId = 0;             //[9] networkId
+                    int roamingIndicator = -1;     //[10] Roaming indicator
+                    int systemIsInPrl = 0;         //[11] Indicates if current system is in PRL
+                    int defaultRoamingIndicator = 0;  //[12] Is default roaming indicator from PRL
+                    int reasonForDenial = 0;       //[13] Denial reason if registrationState = 3
+
+                    if (states.length >= 14) {
+                        try {
+                            if (states[0] != null) {
+                                registrationState = Integer.parseInt(states[0]);
+                            }
+                            if (states[3] != null) {
+                                radioTechnology = Integer.parseInt(states[3]);
+                                // ALPS03091813 forGSM ECREG optimization not support
+                                // -1 means short format
+                                if (radioTechnology == -1) {
+                                    radioTechnology = 0;
+                                }
+                            }
+                            if (states[4] != null) {
+                                baseStationId = Integer.parseInt(states[4]);
+                            }
+                            if (states[5] != null) {
+                                baseStationLatitude = Integer.parseInt(states[5]);
+                            }
+                            if (states[6] != null) {
+                                baseStationLongitude = Integer.parseInt(states[6]);
+                            }
+                            // Some carriers only return lat-lngs of 0,0
+                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
+                                baseStationLatitude  = CdmaCellLocation.INVALID_LAT_LONG;
+                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
+                            }
+                            if (states[7] != null) {
+                                cssIndicator = Integer.parseInt(states[7]);
+                            }
+                            if (states[8] != null) {
+                                systemId = Integer.parseInt(states[8]);
+                            }
+                            if (states[9] != null) {
+                                networkId = Integer.parseInt(states[9]);
+                            }
+                            if (states[10] != null) {
+                                roamingIndicator = Integer.parseInt(states[10]);
+                            }
+                            if (states[11] != null) {
+                                systemIsInPrl = Integer.parseInt(states[11]);
+                            }
+                            if (states[12] != null) {
+                                defaultRoamingIndicator = Integer.parseInt(states[12]);
+                            }
+                            if (states[13] != null) {
+                                reasonForDenial = Integer.parseInt(states[13]);
+                            }
+
+                            /// M: [CDMA] @{
+                            if (states.length > 15 && states[15] != null) {
+                                mNetworkExsit = (1 == Integer.parseInt(states[15])) ? true : false;
+                            }
+                            /// @}
+                        } catch (NumberFormatException ex) {
+                            loge("EVENT_POLL_STATE_REGISTRATION_CDMA: error parsing: " + ex);
+                        }
+                    } else {
+                        throw new RuntimeException("Warning! Wrong number of parameters returned from "
+                                + "RIL_REQUEST_REGISTRATION_STATE: expected 14 or more "
+                                + "strings and got " + states.length + " strings");
+                    }
+
+                    mRegistrationState = registrationState;
+                    // When registration state is roaming and TSB58
+                    // roaming indicator is not in the carrier-specified
+                    // list of ERIs for home system, mCdmaRoaming is true.
+                    boolean cdmaRoaming =
+                            regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
+                    mNewSS.setVoiceRoaming(cdmaRoaming);
+
+                    /// M: [CDMA] @{
+                    if (cdmaRoaming) {
+                        mNewSS.setRilVoiceRegState(ServiceState.RIL_REG_STATE_ROAMING);
+                    } else {
+                        mNewSS.setRilVoiceRegState(registrationState);
+                    }
+                    /// @}
+
+                    mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
+
+                    mNewSS.setRilVoiceRadioTechnology(radioTechnology);
+
+                    mNewSS.setCssIndicator(cssIndicator);
+                    mNewSS.setSystemAndNetworkId(systemId, networkId);
+                    mRoamingIndicator = roamingIndicator;
+                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
+                    mDefaultRoamingIndicator = defaultRoamingIndicator;
+
+
+                    // Values are -1 if not available.
+                    ((CdmaCellLocation)mNewCellLoc).setCellLocationData(baseStationId,
+                            baseStationLatitude, baseStationLongitude, systemId, networkId);
+
+                    if (reasonForDenial == 0) {
+                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
+                    } else if (reasonForDenial == 1) {
+                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
+                    } else {
+                        mRegistrationDeniedReason = "";
+                    }
+
+                    if (mRegistrationState == 3) {
+                        if (DBG) log("Registration denied, " + mRegistrationDeniedReason);
+                    }
+                }
+                break;
+            }
+
+            case EVENT_POLL_STATE_GPRS: {
+                if (mPhone.isPhoneTypeGsm()) {
+                    states = (String[]) ar.result;
+
+                    int type = 0;
+                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
+                    mNewReasonDataDenied = -1;
+                    mNewMaxDataCalls = 1;
+                    if (states.length > 0) {
+                        try {
+                            regState = Integer.parseInt(states[0]);
+
+                            //MTK-ADD Start : for CS not registered , PS regsitered (ex: LTE PS only
+                            //mode or 2/3G PS only SIM card or CS domain network registeration
+                            //temporary failure
+                            if (states.length >= 3) {
+                                if (states[1] != null && states[1].length() > 0) {
+                                    int tempLac = Integer.parseInt(states[1], 16);
+                                    if (tempLac < 0) {
+                                        logd("set Lac to previous value");
+                                        tempLac = ((GsmCellLocation)mCellLoc).getLac();
+                                    }
+                                    psLac = tempLac;
+                                }
+                                if (states[2] != null && states[2].length() > 0) {
+                                    int tempCid = Integer.parseInt(states[2], 16);
+                                    if (tempCid < 0) {
+                                        logd("set Cid to previous value");
+                                        tempCid =((GsmCellLocation)mCellLoc).getCid();
+                                    }
+                                    psCid = tempCid;
+                                }
+                            }
+                            //MTK-ADD END : for CS not registered , PS regsitered (ex: LTE PS only
+                            //mode or 2/3G PS only SIM card or CS domain network registeration
+                            //temporary failure
+
+                            // states[3] (if present) is the current radio technology
+                            if (states.length >= 4 && states[3] != null) {
+                                type = Integer.parseInt(states[3]);
+                            }
+                            if ((states.length >= 5) && (states[4] != null) &&
+                                    (regState == ServiceState.RIL_REG_STATE_DENIED)) {
+                                mNewReasonDataDenied = Integer.parseInt(states[4]);
+                                mNewSS.setDataRejectCause(mNewReasonDataDenied);
+                                log("set data reject cause to " + mNewReasonDataDenied);
+                            }
+                            if (states.length >= 6 && states[5] != null) {
+                                mNewMaxDataCalls = Integer.parseInt(states[5]);
+                            }
+                        } catch (NumberFormatException ex) {
+                            loge("error parsing GprsRegistrationState: " + ex);
+                        }
+                    }
+                    int dataRegState = regCodeToServiceState(regState);
+                    mNewSS.setRilDataRegState(regState);
+                    mNewSS.setDataRegState(dataRegState);
+                    mDataRoaming = regCodeIsRoaming(regState);
+                    mNewSS.setRilDataRadioTechnology(type);
+
+                    //carrier aggregation
+                    mNewSS.setProprietaryDataRadioTechnology(type);
+                    //mNewSS.setRilDataRadioTechnology(type);
+
+                    if (DBG) {
+                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState
+                                + " regState=" + regState
+                                + " dataRadioTechnology=" + type);
+                    }
+                } else if (mPhone.isPhoneTypeCdma()) {
+                    states = (String[])ar.result;
+                    if (DBG) {
+                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" +
+                                states.length + " states=" + states);
+                    }
+
+                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
+                    int dataRadioTechnology = 0;
+
+                    if (states.length > 0) {
+                        try {
+                            regState = Integer.parseInt(states[0]);
+
+                            // states[3] (if present) is the current radio technology
+                            if (states.length >= 4 && states[3] != null) {
+                                dataRadioTechnology = Integer.parseInt(states[3]);
+                            }
+                        } catch (NumberFormatException ex) {
+                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: "
+                                    + ex);
+                        }
+                    }
+
+                    int dataRegState = regCodeToServiceState(regState);
+                    mNewSS.setDataRegState(dataRegState);
+                    /// M: [CDMA] @{
+                    mNewSS.setRilDataRegState(regState);
+                    /// @}
+                    mNewSS.setRilDataRadioTechnology(dataRadioTechnology);
+                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
+                    if (DBG) {
+                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState
+                                + " regState=" + regState
+                                + " dataRadioTechnology=" + dataRadioTechnology);
+                    }
+                } else {
+                    states = (String[])ar.result;
+                    if (DBG) {
+                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" +
+                                states.length + " states=" + states);
+                    }
+
+                    int newDataRAT = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
+                    int regState = -1;
+                    if (states.length > 0) {
+                        try {
+                            regState = Integer.parseInt(states[0]);
+
+                            // states[3] (if present) is the current radio technology
+                            if (states.length >= 4 && states[3] != null) {
+                                newDataRAT = Integer.parseInt(states[3]);
+                            }
+                        } catch (NumberFormatException ex) {
+                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: "
+                                    + ex);
+                        }
+                    }
+
+                    // If the unsolicited signal strength comes just before data RAT family changes
+                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
+                    // display the wrong information until the next unsolicited signal strength
+                    // information coming from the modem, which might take a long time to come or
+                    // even not come at all.  In order to provide the best user experience, we
+                    // query the latest signal information so it will show up on the UI on time.
+                    int oldDataRAT = mSS.getRilDataRadioTechnology();
+                    if ((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN &&
+                            newDataRAT != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) ||
+                            (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRAT)) ||
+                            (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRAT))) {
+                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
+                    }
+
+                    mNewSS.setRilDataRadioTechnology(newDataRAT);
+                    int dataRegState = regCodeToServiceState(regState);
+                    mNewSS.setDataRegState(dataRegState);
+                    /// M: [CDMALTE] @{
+                    mNewSS.setRilDataRegState(regState);
+                    // Carrier aggregation
+                    mNewSS.setProprietaryDataRadioTechnology(newDataRAT);
+                    /// @}
+                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
+                    /// M: [CDMALTE] @{
+                    boolean isDateRoaming = regCodeIsRoaming(regState);
+                    mNewSS.setDataRoaming(isDateRoaming);
+                    if (isDateRoaming) {
+                        mNewSS.setRilDataRegState(ServiceState.RIL_REG_STATE_ROAMING);
+                    }
+                    /// @}
+                    if (DBG) {
+                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState
+                                + " regState=" + regState
+                                + " dataRadioTechnology=" + newDataRAT);
+                    }
+                }
+                break;
+            }
+
+            case EVENT_POLL_STATE_OPERATOR: {
+                if (mPhone.isPhoneTypeGsm()) {
+                    String opNames[] = (String[]) ar.result;
+
+                    if (opNames != null && opNames.length >= 3) {
+                        // FIXME: Giving brandOverride higher precedence, is this desired?
+                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ?
+                                mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
+                        if (brandOverride != null) {
+                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
+                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
+                        } else {
+
+                            String strOperatorLong = null;
+                            String strOperatorShort = null;
+                            SpnOverride spnOverride = SpnOverride.getInstance();
+
+                            strOperatorLong = mCi.lookupOperatorNameFromNetwork(
+                                    SubscriptionManager.getSubIdUsingPhoneId(mPhone.getPhoneId()),
+                                    opNames[2], true);
+                            if (strOperatorLong != null) {
+                                log("EVENT_POLL_STATE_OPERATOR: OperatorLong use lookFromNetwork");
+                            } else {
+                                strOperatorLong = spnOverride.lookupOperatorName(
+                                        SubscriptionManager.getSubIdUsingPhoneId(
+                                                mPhone.getPhoneId()), opNames[2], true,
+                                                mPhone.getContext());
+                                if (strOperatorLong != null) {
+                                    logd("EVENT_POLL_STATE_OPERATOR: "
+                                        + "OperatorLong use lookupOperatorName");
+                                    strOperatorLong = mServiceStateExt.updateOpAlphaLongForHK(
+                                        strOperatorLong, opNames[2], mPhone.getPhoneId());
+                                } else {
+                                    log("EVENT_POLL_STATE_OPERATOR: "
+                                        + "OperatorLong use value from ril");
+                                    strOperatorLong = opNames[0];
+                                }
+                            }
+                            strOperatorShort = mCi.lookupOperatorNameFromNetwork(
+                                    SubscriptionManager.getSubIdUsingPhoneId(mPhone.getPhoneId()),
+                                            opNames[2], false);
+                            if (strOperatorShort != null) {
+                                log("EVENT_POLL_STATE_OPERATOR: OperatorShort use "
+                                    + "lookupOperatorNameFromNetwork");
+                            } else {
+                                strOperatorShort = spnOverride.lookupOperatorName(
+                                        SubscriptionManager.getSubIdUsingPhoneId(
+                                                mPhone.getPhoneId()),
+                                                opNames[2],
+                                                false, mPhone.getContext());
+                                if (strOperatorShort != null) {
+                                    logd("EVENT_POLL_STATE_OPERATOR: OperatorShort "
+                                            + "use lookupOperatorName");
+                                } else {
+                                    log("EVENT_POLL_STATE_OPERATOR: OperatorShort "
+                                            + "use value from ril");
+                                    strOperatorShort = opNames[1];
+                                }
+                            }
+                            log("EVENT_POLL_STATE_OPERATOR: " + strOperatorLong
+                                    + ", " + strOperatorShort);
+                            mNewSS.setOperatorName (strOperatorLong, strOperatorShort, opNames[2]);
+                        }
+                        updateLocatedPlmn(opNames[2]);
+                    } else if (opNames != null && opNames.length == 1) {
+                        log("opNames:" + opNames[0] + " len=" + opNames[0].length());
+                        mNewSS.setOperatorName(null, null, null);
+                        // to keep the original AOSP behavior, set null when not registered
+
+                        /* Do NOT update invalid PLMN value "000000" */
+                        if (opNames[0].length() >= 5 && !(opNames[0].equals("000000"))) {
+                            updateLocatedPlmn(opNames[0]);
+                        } else {
+                            updateLocatedPlmn(null);
+                        }
+                    }
+                } else {
+                    String opNames[] = (String[])ar.result;
+
+                    if (opNames != null && opNames.length >= 3) {
+                        // TODO: Do we care about overriding in this case.
+                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
+                        if ((opNames[2] == null) || (opNames[2].length() < 5)
+                                || ("00000".equals(opNames[2]))
+                                || ("N/AN/A".equals(opNames[2]))) {
+                            opNames[2] = SystemProperties.get(
+                                    GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "");
+                            if (DBG) {
+                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " +
+                                        " is bad. Using SystemProperties '" +
+                                        GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC +
+                                        "'= " + opNames[2]);
+                            }
+                        }
+
+                        /// M: [CDMA] Add for cdma plus code feature. @{
+                        String numeric = opNames[2];
+                        boolean plusCode = false;
+                        if (numeric.startsWith("2134") && numeric.length() == 7) {
+                            String tempStr = mPlusCodeUtils.checkMccBySidLtmOff(numeric);
+                            if (!tempStr.equals("0")) {
+                                opNames[2] = tempStr + numeric.substring(4);
+                                numeric = tempStr;
+                                log("EVENT_POLL_STATE_OPERATOR_CDMA: checkMccBySidLtmOff: numeric ="
+                                        + numeric + ", plmn =" + opNames[2]);
+                            }
+                            plusCode = true;
+                        }
+                        /// @}
+
+                        if (!mIsSubscriptionFromRuim) {
+                            // NV device (as opposed to CSIM)
+                            /// M: [CDMA] Add for cdma plus code feature. @{
+                            if (plusCode) {
+                                opNames[1] = SpnOverride.getInstance().lookupOperatorName(
+                                        mPhone.getSubId(), opNames[2], false, mPhone.getContext());
+                            }
+                            mNewSS.setOperatorName(null, opNames[1], opNames[2]);
+                            /// @}
+                        } else {
+                            String brandOverride = mUiccController.getUiccCard(
+                                    getPhoneId()) != null ?
+                                    mUiccController.getUiccCard(
+                                            getPhoneId()).getOperatorBrandOverride() : null;
+                            if (brandOverride != null) {
+                                /// M: [CDMA] Add log. @{
+                                log("EVENT_POLL_STATE_OPERATOR_CDMA: use brand=" + brandOverride);
+                                /// @}
+                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
+                            } else {
+                                /// M: [CDMA] Add for Operator Name display. @{
+                                // mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                                String strOperatorLong = null;
+                                String strOperatorShort = null;
+                                SpnOverride spnOverride = SpnOverride.getInstance();
+                                strOperatorLong = mCi.lookupOperatorNameFromNetwork(
+                                        SubscriptionManager.getSubIdUsingPhoneId(
+                                                mPhone.getPhoneId()), opNames[2], true);
+                                if (strOperatorLong != null) {
+                                    log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorLong "
+                                            + "use lookupOperatorNameFromNetwork");
+                                } else {
+                                    strOperatorLong = spnOverride.lookupOperatorName(
+                                            SubscriptionManager.getSubIdUsingPhoneId(
+                                                    mPhone.getPhoneId()), opNames[2], true,
+                                            mPhone.getContext());
+                                    if (strOperatorLong != null) {
+                                        log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorLong "
+                                                + "use lookupOperatorName");
+                                    } else {
+                                        log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorLong "
+                                                + "use value from ril");
+                                        strOperatorLong = opNames[0];
+                                    }
+                                }
+                                strOperatorShort = mCi.lookupOperatorNameFromNetwork(
+                                        SubscriptionManager.getSubIdUsingPhoneId(
+                                                mPhone.getPhoneId()), opNames[2], false);
+                                if (strOperatorShort != null) {
+                                    log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorShort use "
+                                            + "lookupOperatorNameFromNetwork");
+                                } else {
+                                    strOperatorShort = spnOverride.lookupOperatorName(
+                                            SubscriptionManager.getSubIdUsingPhoneId(
+                                                    mPhone.getPhoneId()),
+                                            opNames[2], false, mPhone.getContext());
+                                    if (strOperatorShort != null) {
+                                        log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorShort "
+                                                + "use lookupOperatorName");
+                                    } else {
+                                        log("EVENT_POLL_STATE_OPERATOR_CDMA: OperatorShort "
+                                                + "use value from ril");
+                                        strOperatorShort = opNames[1];
+                                    }
+                                }
+                                log("EVENT_POLL_STATE_OPERATOR_CDMA: "
+                                        + strOperatorLong + ", " + strOperatorShort);
+                                mNewSS.setOperatorName(strOperatorLong, strOperatorShort,
+                                        opNames[2]);
+                                /// @}
+                            }
+                        }
+                        // updateLocatedPlmn
+                        if (opNames[2].length() >= 5 && !(opNames[2].equals("000000"))) {
+                            updateLocatedPlmn(opNames[2]);
+                        } else {
+                            updateLocatedPlmn(null);
+                        }
+                    } else {
+                        if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
+                    }
+                }
+                break;
+            }
+
+            case EVENT_POLL_STATE_NETWORK_SELECTION_MODE: {
+                ints = (int[])ar.result;
+                mNewSS.setIsManualSelection(ints[0] == 1);
+                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
+                        /*
+                         * modem is currently in manual selection but manual
+                         * selection is not allowed in the current mode so
+                         * switch to automatic registration
+                         */
+                    mPhone.setNetworkSelectionModeAutomatic (null);
+                    log(" Forcing Automatic Network Selection, " +
+                            "manual selection is not allowed");
+                }
+                break;
+            }
+
+            default:
+                loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
+        }
+    }
+
+    /**
+     * Determine whether a roaming indicator is in the carrier-specified list of ERIs for
+     * home system
+     *
+     * @param roamInd roaming indicator in String
+     * @return true if the roamInd is in the carrier-specified list of ERIs for home network
+     */
+    private boolean isRoamIndForHomeSystem(String roamInd) {
+        // retrieve the carrier-specified list of ERIs for home system
+        String[] homeRoamIndicators = mPhone.getContext().getResources()
+                .getStringArray(com.android.internal.R.array.config_cdma_home_system);
+
+        if (homeRoamIndicators != null) {
+            // searches through the comma-separated list for a match,
+            // return true if one is found.
+            for (String homeRoamInd : homeRoamIndicators) {
+                if (homeRoamInd.equals(roamInd)) {
+                    return true;
+                }
+            }
+            // no matches found against the list!
+            return false;
+        }
+
+        // no system property found for the roaming indicators for home system
+        return false;
+    }
+
+    /**
+     * Query the carrier configuration to determine if there any network overrides
+     * for roaming or not roaming for the current service state.
+     */
+    protected void updateRoamingState() {
+        if (mPhone.isPhoneTypeGsm()) {
+            /**
+             * Since the roaming state of gsm service (from +CREG) and
+             * data service (from +CGREG) could be different, the new SS
+             * is set to roaming when either is true.
+             *
+             * There are exceptions for the above rule.
+             * The new SS is not set as roaming while gsm service reports
+             * roaming but indeed it is same operator.
+             * And the operator is considered non roaming.
+             *
+             * The test for the operators is to handle special roaming
+             * agreements and MVNO's.
+             */
+            boolean roaming = (mGsmRoaming || mDataRoaming);
+            log("set roaming=" + roaming + ",mGsmRoaming= " + mGsmRoaming
+                            + ",mDataRoaming= " + mDataRoaming);
+
+            //add for special SIM
+            boolean isRoamingForSpecialSim = false;
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                String simType = PhoneFactory.getPhone(mPhone.getPhoneId())
+                        .getIccCard().getIccCardType();
+                try {
+                    if ((mNewSS.getOperatorNumeric() != null)
+                            && (getSIMOperatorNumeric() != null)
+                            && ((simType != null) && (!simType.equals("")) && simType
+                                    .equals("CSIM"))
+                            && mServiceStateExt.isRoamingForSpecialSIM(
+                                    mNewSS.getOperatorNumeric(), getSIMOperatorNumeric())) {
+                        isRoamingForSpecialSim = true;
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if (!isRoamingForSpecialSim) {
+                //ALPS02446235[
+                /* AOSP
+                if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) &&
+                    (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
+                */
+                // [ALPS02948695] consider both cs & ps
+                if (roaming && isSameNamedOperators(mNewSS)
+                        && !isOperatorConsideredRoamingMtk(mNewSS)) {
+                // ALPS02446235]
+                    if (VDBG)
+                        log("set raoming fasle due to special roaming agreements and MVNO's.");
+                    roaming = false;
+                }
+
+                if (mPhone.isMccMncMarkedAsNonRoaming(mNewSS.getOperatorNumeric())) {
+                    roaming = false;
+                } else if (mPhone.isMccMncMarkedAsRoaming(mNewSS.getOperatorNumeric())) {
+                    roaming = true;
+                }
+            }
+
+            // Save the roaming state before carrier config possibly overrides it.
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mNewSS.getRilDataRadioTechnology()) {
+                mNewSS.setDataRoamingFromRegistration(mDataRoaming);
+            } else {
+                mNewSS.setDataRoamingFromRegistration(roaming);
+            }
+
+            CarrierConfigManager configLoader = (CarrierConfigManager)
+                    mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+            if (configLoader != null) {
+                try {
+                    PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
+
+                    if (alwaysOnHomeNetwork(b)) {
+                        log("updateRoamingState: carrier config override always on home network");
+                        roaming = false;
+                    } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
+                        log("updateRoamingState: carrier config override set non roaming:"
+                                + mNewSS.getOperatorNumeric());
+                        roaming = false;
+                    } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
+                        log("updateRoamingState: carrier config override set roaming:"
+                                + mNewSS.getOperatorNumeric());
+                        roaming = true;
+                    }
+                } catch (Exception e) {
+                    loge("updateRoamingState: unable to access carrier config service");
+                }
+            } else {
+                log("updateRoamingState: no carrier config service available");
+            }
+
+            mNewSS.setVoiceRoaming(roaming);
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mNewSS.getRilDataRadioTechnology()) {
+                mNewSS.setDataRoaming(mDataRoaming);
+            } else {
+                mNewSS.setDataRoaming(roaming);
+            }
+        } else {
+            // Save the roaming state before carrier config possibly overrides it.
+            mNewSS.setDataRoamingFromRegistration(mNewSS.getDataRoaming());
+
+            CarrierConfigManager configLoader = (CarrierConfigManager)
+                    mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            if (configLoader != null) {
+                try {
+                    PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
+                    String systemId = Integer.toString(mNewSS.getSystemId());
+
+                    if (alwaysOnHomeNetwork(b)) {
+                        log("updateRoamingState: carrier config override always on home network");
+                        setRoamingOff();
+                    } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())
+                            || isNonRoamingInCdmaNetwork(b, systemId)) {
+                        log("updateRoamingState: carrier config override set non-roaming:"
+                                + mNewSS.getOperatorNumeric() + ", " + systemId);
+                        setRoamingOff();
+                    } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())
+                            || isRoamingInCdmaNetwork(b, systemId)) {
+                        log("updateRoamingState: carrier config override set roaming:"
+                                + mNewSS.getOperatorNumeric() + ", " + systemId);
+                        setRoamingOn();
+                    }
+                } catch (Exception e) {
+                    loge("updateRoamingState: unable to access carrier config service");
+                }
+            } else {
+                log("updateRoamingState: no carrier config service available");
+            }
+
+            if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
+                mNewSS.setVoiceRoaming(true);
+                mNewSS.setDataRoaming(true);
+            }
+        }
+    }
+
+    private void setRoamingOn() {
+        mNewSS.setVoiceRoaming(true);
+        mNewSS.setDataRoaming(true);
+        mNewSS.setCdmaEriIconIndex(EriInfo.ROAMING_INDICATOR_ON);
+        mNewSS.setCdmaEriIconMode(EriInfo.ROAMING_ICON_MODE_NORMAL);
+    }
+
+    private void setRoamingOff() {
+        mNewSS.setVoiceRoaming(false);
+        mNewSS.setDataRoaming(false);
+        mNewSS.setCdmaEriIconIndex(EriInfo.ROAMING_INDICATOR_OFF);
+    }
+
+    public void refreshSpnDisplay() {
+        String numeric = mSS.getOperatorNumeric();
+        String newAlphaLong = null;
+        String newAlphaShort = null;
+
+        if ((numeric != null) && (!(numeric.equals("")))) {
+            newAlphaLong = SpnOverride.getInstance().lookupOperatorName(
+                   SubscriptionManager.getSubIdUsingPhoneId(mPhone.getPhoneId()), numeric,
+                   true, mPhone.getContext());
+            newAlphaShort = SpnOverride.getInstance().lookupOperatorName(
+                   SubscriptionManager.getSubIdUsingPhoneId(mPhone.getPhoneId()), numeric,
+                   false, mPhone.getContext());
+            //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+            //mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA,
+            //      newAlphaLong);
+            //updateOperatorAlpha(newAlphaLong);    //remark for [ALPS01965792]
+            //[ALPS01804936]-end
+
+            if (mPhone.isPhoneTypeGsm()) {
+                if (newAlphaLong != null) {
+                    newAlphaLong = mServiceStateExt.updateOpAlphaLongForHK(newAlphaLong,
+                            numeric, mPhone.getPhoneId());
+                }
+            }
+
+            if (!TextUtils.equals(newAlphaLong, mSS.getOperatorAlphaLong())) {
+                mNeedNotify = true;
+            }
+
+            log("refreshSpnDisplay set alpha to " + newAlphaLong + ","
+                    + newAlphaShort + "," + numeric + ", mNeedNotify=" + mNeedNotify);
+            mSS.setOperatorName(newAlphaLong, newAlphaShort, numeric);
+        }
+        updateSpnDisplay();
+    }
+
+    // TODO FIX: should not be Android O
+    // this declaration is due to updateSpnDisplayGsm/Cdma
+    // refer: commit fce584177afabb301d8ecbeea55f432adcee5e0b
+    private String wfcVoiceSpnFormat = null;
+    private String wfcDataSpnFormat = null;
+
+    protected void updateSpnDisplay() {
+        updateOperatorNameFromEri();
+
+        wfcVoiceSpnFormat = null;
+        wfcDataSpnFormat = null;
+        if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
+            // In Wi-Fi Calling mode show SPN+WiFi
+
+            String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(
+                    com.android.internal.R.array.wfcSpnFormats);
+            int voiceIdx = 0;
+            int dataIdx = 0;
+            CarrierConfigManager configLoader = (CarrierConfigManager)
+                    mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            if (configLoader != null) {
+                try {
+                    PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
+                    if (b != null) {
+                        voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
+                        dataIdx = b.getInt(
+                                CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
+                    }
+                } catch (Exception e) {
+                    loge("updateSpnDisplay: carrier config error: " + e);
+                }
+            }
+
+            wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
+            wfcDataSpnFormat = wfcSpnFormats[dataIdx];
+        }
+
+        if (mPhone.isPhoneTypeGsm()) {
+            updateSpnDisplayGsm(false);
+        } else {
+            updateSpnDisplayCdma(false);
+        }
+    }
+
+    protected void updateSpnDisplayGsm(boolean forceUpdate) {
+        SIMRecords simRecords = null;
+        IccRecords r = mPhone.mIccRecords.get();
+        if (r != null) {
+            simRecords = (SIMRecords) r;
+        }
+
+        int rule = (simRecords != null) ? simRecords.getDisplayRule(
+                mSS.getOperatorNumeric()) : SIMRecords.SPN_RULE_SHOW_PLMN;
+        String strNumPlmn = mSS.getOperatorNumeric();
+        String spn = (simRecords != null) ? simRecords.getServiceProviderName() : "";
+        String sEons = null;
+        boolean showPlmn = false;
+        String plmn = null;
+        String realPlmn = null;
+        String mSimOperatorNumeric = (simRecords != null) ? simRecords.getOperatorNumeric() : "";
+		
+        try {
+			if(!("29505".equals(strNumPlmn) || "23212".equals(strNumPlmn))){
+            sEons = (simRecords != null) ? simRecords.getEonsIfExist(mSS.getOperatorNumeric(),
+                    ((GsmCellLocation)mCellLoc).getLac(), true) : null;
+			}
+        } catch (RuntimeException ex) {
+            loge("Exception while getEonsIfExist. " + ex);
+        }
+
+        if (sEons != null) {
+            plmn = sEons;
+        }
+        else if (strNumPlmn != null && strNumPlmn.equals(mSimOperatorNumeric)) {
+            log("Home PLMN, get CPHS ons");
+            plmn = (simRecords != null) ? simRecords.getSIMCPHSOns() : "";
+            if (strNumPlmn.equals("00101") && plmn != null) {
+                if (plmn.contains("Operateur Name StrinRROR") || plmn.contains("Operateur Name StrinF FF")) {
+                	plmn = "Operateur Name String";
+                }
+            }
+        }
+
+        if (TextUtils.isEmpty(plmn)) {
+            log("No matched EONS and No CPHS ONS");
+            plmn = mSS.getOperatorAlphaLong();
+            // M:[ALPS02414050] OperatorAlphaLong maybe ""
+            if (TextUtils.isEmpty(plmn) || plmn.equals(mSS.getOperatorNumeric())) {
+                plmn = mSS.getOperatorAlphaShort();
+            }
+        }
+
+        /*[ALPS00460547] - star */
+        //keep operator name for update PROPERTY_OPERATOR_ALPHA
+        realPlmn = plmn;
+        /*[ALPS00460547] - end */
+
+        // Do not display SPN before get normal service
+        //M: for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS only SIM card
+        //or CS domain network registeration temporary failure
+        //if (mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE) {
+        if ((mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE) &&
+                (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE)) {
+            showPlmn = true;
+            plmn = Resources.getSystem().
+                    getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
+
+        }
+        log("updateSpnDisplay mVoiceCapable=" + mVoiceCapable + " mEmergencyOnly=" + mEmergencyOnly
+            + " mCi.getRadioState().isOn()=" + mCi.getRadioState().isOn() + " getVoiceRegState()="
+            + mSS.getVoiceRegState() + " getDataRegState()" + mSS.getDataRegState());
+
+        // ALPS00283717 For emergency calls only, pass the EmergencyCallsOnly string via EXTRA_PLMN
+        //MTK-ADD START : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS
+        //only SIM card or CS domain network registeration temporary failure
+        if (mVoiceCapable && mEmergencyOnly && mCi.getRadioState().isOn()
+                && (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE)) {
+            logd("updateSpnDisplay show mEmergencyOnly");
+            showPlmn = true;
+
+            plmn = Resources.getSystem().getText(
+                    com.android.internal.R.string.emergency_calls_only).toString();
+
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    //CDR-NWS-2409
+                    if(mServiceStateExt.needBlankDisplay(mSS.getVoiceRejectCause()) == true){
+                        log("Do NOT show emergency call only display");
+                        plmn = "";
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        /**
+         * mImeiAbnormal=0, Valid IMEI
+         * mImeiAbnormal=1, IMEI is null or not valid format
+         * mImeiAbnormal=2, Phone1/Phone2 have same IMEI
+         */
+        int imeiAbnormal = mPhone.isDeviceIdAbnormal();
+        if (imeiAbnormal == 1) {
+            //[ALPS00872883] don't update plmn string when radio is not available
+            if (mCi.getRadioState() != CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+                plmn = Resources.getSystem().getText(com.mediatek.R.string.invalid_imei).toString();
+            }
+        } else if (imeiAbnormal == 2) {
+            plmn = Resources.getSystem().getText(com.mediatek.R.string.same_imei).toString();
+        } else if (imeiAbnormal == 0) {
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    plmn = mServiceStateExt.onUpdateSpnDisplay(plmn, mSS,
+                               mPhone.getPhoneId());
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            // If CS not registered , PS registered , add "Data
+            // connection only" postfix in PLMN name
+            if ((mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE) &&
+                    (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+                //[ALPS01650043]-Start: don't update PLMN name
+                // when it is null for backward compatible
+                if (plmn != null) {
+                    if (getImsServiceState() != ServiceState.STATE_IN_SERVICE) {
+                        plmn = plmn + "(" + Resources.getSystem()
+                                .getText(com.mediatek.R.string.data_conn_only)
+                                .toString() + ")";
+                    }
+                } else {
+                    log("PLMN name is null when CS not registered and PS registered");
+                }
+            }
+        }
+        /* ALPS00296298 */
+        if (mIsImeiLock) {
+            plmn = Resources.getSystem().getText(com.mediatek.R.string.invalid_card).toString();
+        }
+
+        //MTK-ADD Start : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS
+        //only SIM card or CS domain network registeration temporary failure
+        //if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+        if ((mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) ||
+            (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+            showPlmn = !TextUtils.isEmpty(plmn) &&
+                    ((rule & SIMRecords.SPN_RULE_SHOW_PLMN)
+                            == SIMRecords.SPN_RULE_SHOW_PLMN);
+        /* } else {
+                  // Power off state, such as airplane mode, show plmn as "No service"
+                  showPlmn = true;
+                  plmn = Resources.getSystem().
+                  getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
+                  if (DBG) log("updateSpnDisplay: radio is off w/ showPlmn="
+                         + showPlmn + " plmn=" + plmn);
+              }              */
+        }
+
+             /*
+              // The value of spn/showSpn are same in different scenarios.
+              // EXTRA_SHOW_SPN = depending on IccRecords rul
+              // EXTRA_SPN = spn
+              String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+             */
+
+        // The value of spn/showSpn are same in different scenarios.
+        //    EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
+        //    EXTRA_SPN = spn
+        //    EXTRA_DATA_SPN = dataSpn
+        String dataSpn = spn;
+        boolean showSpn = !TextUtils.isEmpty(spn)
+                && ((rule & SIMRecords.SPN_RULE_SHOW_SPN)
+                        == SIMRecords.SPN_RULE_SHOW_SPN);
+
+            if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) &&
+                    !TextUtils.isEmpty(wfcDataSpnFormat)) {
+            // In Wi-Fi Calling mode show SPN+WiFi
+
+            String originalSpn = spn.trim();
+            spn = String.format(wfcVoiceSpnFormat, originalSpn);
+            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
+            showSpn = true;
+            showPlmn = false;
+        /// M: ALPS02293142, don't show spn when no service/emergency only
+        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF
+                || (showPlmn && TextUtils.equals(spn, plmn))
+                || ((mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE) &&
+                        (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE))) {
+            // airplane mode or spn equals plmn, do not show spn
+            spn = null;
+            showSpn = false;
+        }
+
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            try {
+                if (mServiceStateExt.needSpnRuleShowPlmnOnly() && !TextUtils.isEmpty(plmn)) {
+                    log("origin showSpn:" + showSpn + " showPlmn:" + showPlmn + " rule:" + rule);
+                    showSpn = false;
+                    showPlmn = true;
+                    rule = SIMRecords.SPN_RULE_SHOW_PLMN;
+                }
+            } catch (RuntimeException e) {
+                e.printStackTrace();
+            }
+        }
+        ///M : WFC @{
+        try {
+            plmn = mServiceStateExt.onUpdateSpnDisplayForIms(
+                                   plmn, mSS, ((GsmCellLocation)mCellLoc).getLac(),
+                                   mPhone.getPhoneId(),simRecords);
+        } catch (RuntimeException e) {
+            e.printStackTrace();
+        }
+        /// @}
+
+        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
+        if (subIds != null && subIds.length > 0) {
+            subId = subIds[0];
+        }
+
+        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
+        if (mSubId != subId ||
+                showPlmn != mCurShowPlmn
+                || showSpn != mCurShowSpn
+                || !TextUtils.equals(spn, mCurSpn)
+                || !TextUtils.equals(dataSpn, mCurDataSpn)
+                || !TextUtils.equals(plmn, mCurPlmn)
+                || forceUpdate) {
+            // M: [ALPS521030] for [CT case][TC-IRLAB-02009]
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    if (!mServiceStateExt.allowSpnDisplayed()) {
+                        log("For CT test case don't show SPN.");
+                        if (rule == (SIMRecords.SPN_RULE_SHOW_PLMN
+                                | SIMRecords.SPN_RULE_SHOW_SPN)) {
+                            showSpn = false;
+                            spn = null;
+                        }
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+            if (DBG) {
+                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule +
+                        " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " +
+                        "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
+            }
+
+            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
+
+            // For multiple SIM support, share the same intent, do not replace the other one
+            if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            }
+
+            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
+            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
+            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
+            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
+            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
+
+            //M: Femtocell (CSG) info
+            intent.putExtra(TelephonyIntents.EXTRA_HNB_NAME, mHhbName);
+            intent.putExtra(TelephonyIntents.EXTRA_CSG_ID, mCsgId);
+            intent.putExtra(TelephonyIntents.EXTRA_DOMAIN, mFemtocellDomain);
+            // isFemtocell (LTE/C2K)
+            intent.putExtra(TelephonyIntents.EXTRA_FEMTO, mIsFemtocell);
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+
+            int phoneId = mPhone.getPhoneId();
+
+            // Append Femtocell (CSG) Info
+            if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1")){
+                if((mHhbName == null) && (mCsgId != null)){
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        try {
+                            if (mServiceStateExt.needToShowCsgId() == true) {
+                                plmn += " - ";
+                                plmn += mCsgId;
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    } else {
+                        plmn += " - ";
+                        plmn += mCsgId;
+                    }
+                } else if(mHhbName != null){
+                    plmn += " - ";
+                    plmn += mHhbName;
+                }
+            }
+
+            boolean setResult = mSubscriptionController.setPlmnSpn(phoneId,
+                    showPlmn, plmn, showSpn, spn);
+            if (!setResult) {
+                mSpnUpdatePending = true;
+            }
+            log("showSpn:" + showSpn + " spn:" + spn + " showPlmn:" + showPlmn +
+                    " plmn:" + plmn + " rule:" + rule +
+                    " setResult:" + setResult + " phoneId:" + phoneId);
+        }
+
+        //[ALPS01554309]-start
+        // update new operator info. when operator numeric has change.
+        /* ALPS00357573 for consistent operator name display */
+        String operatorLong = mSS.getOperatorAlphaLong();
+        if ((showSpn == true) && (showPlmn == false) && (spn != null)) {
+            /* When only <spn> is shown , we update with <spn> */
+            //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+            //mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA, spn);
+            if (operatorLong == null || !operatorLong.equals(spn)) {
+                mSS.setOperatorAlphaLong(spn); // add for [ALPS01965792]
+                //[ALPS01804936]-end
+                mNeedNotify = true;
+            }
+            log("updateAllOpertorInfo with spn:" + spn + ", mNeedNotify=" + mNeedNotify);
+            updateOperatorAlpha(spn);
+        } else {
+            //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+            //mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA, realPlmn);
+            if (operatorLong == null || !operatorLong.equals(realPlmn)) {
+                mSS.setOperatorAlphaLong(realPlmn); // add for [ALPS01965792]
+                // [ALPS01804936]-end
+                mNeedNotify = true;
+            }
+            log("updateAllOpertorInfo with realPlmn:" + realPlmn + ", mNeedNotify=" + mNeedNotify);
+            updateOperatorAlpha(realPlmn);
+        }
+        //[ALPS01554309]-end
+
+        mSubId = subId;
+        mCurShowSpn = showSpn;
+        mCurShowPlmn = showPlmn;
+        mCurSpn = spn;
+        mCurDataSpn = dataSpn;
+        mCurPlmn = plmn;
+    }
+
+    /// M: [CDMA] Add for CDMA update SpnDisplay. @{
+    private void updateSpnDisplayCdma(boolean forceUpdate) {
+        // mOperatorAlphaLong contains the ERI text
+        String plmn = mSS.getOperatorAlphaLong();
+        boolean showPlmn = false;
+
+        showPlmn = plmn != null;
+
+        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
+        if (subIds != null && subIds.length > 0) {
+            subId = subIds[0];
+        }
+
+        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
+            // In Wi-Fi Calling mode show SPN+WiFi
+
+            String originalPlmn = plmn.trim();
+            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
+        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
+            // todo: temporary hack; should have a better fix. This is to avoid using operator
+            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
+            // wifi calling is actually enabled
+            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " +
+                    "state is off");
+            plmn = null;
+        }
+
+        /// M: [CDMA] Add for the spn display feature. @{
+        if (plmn == null || plmn.equals("")) {
+            plmn = mSS.getOperatorAlphaLong();
+            if (plmn == null || plmn.equals(mSS.getOperatorNumeric())) {
+                plmn = mSS.getOperatorAlphaShort();
+            }
+        }
+
+        if (plmn != null) {
+            showPlmn = true;
+            if (plmn.equals("")) {
+                plmn = null;
+            }
+        }
+
+        log("[CDMA]updateSpnDisplay: getOperatorAlphaLong=" + mSS.getOperatorAlphaLong()
+                + ", getOperatorAlphaShort=" + mSS.getOperatorAlphaShort()
+                + ", plmn=" + plmn + ", forceUpdate=" + forceUpdate);
+
+        if (mEmergencyOnly && mCi.getRadioState().isOn()) {
+            // C2k modify for emergency only.
+            log("[CDMA]updateSpnDisplay: phone show emergency call only, mEmergencyOnly = true");
+            showPlmn = true;
+            plmn = Resources.getSystem().
+                    getText(com.android.internal.R.string.emergency_calls_only).toString();
+        } else if ((mSS.getState() != ServiceState.STATE_IN_SERVICE) &&
+                (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE)) {
+            // Do not display SPN before get normal service
+            log("[CDMA]updateSpnDisplay: Do not display SPN before get normal service");
+            showPlmn = true;
+            plmn = Resources.getSystem().getText(
+                    com.android.internal.R.string.lockscreen_carrier_default).toString();
+        }
+
+        int rule = 0;
+        String spn = "";
+        boolean showSpn = false;
+        // From RuimRecord get show display rule and spn
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            try {
+                if (mServiceStateExt.allowSpnDisplayed()) {
+                    IccRecords r = mPhone.mIccRecords.get();
+                    rule = (r != null) ? r.getDisplayRule(mSS
+                            .getOperatorNumeric()) : IccRecords.SPN_RULE_SHOW_PLMN;
+                    spn = (r != null) ? r.getServiceProviderName() : "";
+
+                    showSpn = !TextUtils.isEmpty(spn)
+                            && ((rule & RuimRecords.SPN_RULE_SHOW_SPN)
+                                == RuimRecords.SPN_RULE_SHOW_SPN)
+                            && !(mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF)
+                            && !mSS.getRoaming();
+
+                    log("[CDMA]updateSpnDisplay: rule=" + rule + ", spn=" + spn
+                            + ", showSpn=" + showSpn);
+                }
+            } catch (RuntimeException e) {
+                e.printStackTrace();
+            }
+        }
+        /// @}
+
+        /// M: [CDMA] @{
+        if (mSubId != subId
+                || showPlmn != mCurShowPlmn
+                || showSpn != mCurShowSpn
+                || !TextUtils.equals(spn, mCurSpn)
+                || !TextUtils.equals(plmn, mCurPlmn)
+                || forceUpdate) {
+            /// @}
+            // Allow A blank plmn, "" to set showPlmn to true. Previously, we
+            // would set showPlmn to true only if plmn was not empty, i.e. was not
+            // null and not blank. But this would cause us to incorrectly display
+            // "No Service". Now showPlmn is set to true for any non null string.
+
+            /// M: [CDMA] Modify for the spn display feature. @{
+            showPlmn = plmn != null;
+
+            // Airplane mode, out_of_service, roaming state or spn is null, do not show spn
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                try {
+                    if (mServiceStateExt.allowSpnDisplayed()) {
+                        if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF
+                                || mSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE
+                                || mSS.getRoaming()
+                                || (spn == null || spn.equals(""))) {
+                            showSpn = false;
+                            showPlmn = true;
+                        } else {
+                            showSpn = true;
+                            showPlmn = false;
+                        }
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if (DBG) {
+                log(String.format("[CDMA]updateSpnDisplay: changed sending intent" +
+                        " subId='%d' showPlmn='%b' plmn='%s' showSpn='%b' spn='%s'",
+                        subId, showPlmn, plmn, showSpn, spn));
+            }
+            /// @}
+
+            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
+            // For multiple SIM support, share the same intent, do not replace the other one
+            if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            }
+            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
+            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
+            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
+            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
+
+            //M: Femtocell (CSG) info
+            intent.putExtra(TelephonyIntents.EXTRA_HNB_NAME, (String)null);
+            intent.putExtra(TelephonyIntents.EXTRA_CSG_ID, (String)null);
+            intent.putExtra(TelephonyIntents.EXTRA_DOMAIN, 0);
+            // isFemtocell (LTE/C2K)
+            intent.putExtra(TelephonyIntents.EXTRA_FEMTO, mIsFemtocell);
+
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+
+            /// M: [CDMA] @{
+            boolean setResult = mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(),
+                    showPlmn, plmn, showSpn, spn);
+            if (!setResult) {
+                mSpnUpdatePending = true;
+            }
+            log("[CDMA]updateSpnDisplay: subId=" + subId +
+                    ", showPlmn=" + showPlmn +
+                    ", plmn=" + plmn +
+                    ", showSpn=" + showSpn +
+                    ", spn=" + spn +
+                    ", setResult=" + setResult +
+                    ", mSpnUpdatePending=" + mSpnUpdatePending);
+            /// @}
+        }
+
+        mSubId = subId;
+        mCurShowSpn = showSpn;
+        mCurShowPlmn = showPlmn;
+        mCurSpn = spn;
+        mCurPlmn = plmn;
+    }
+    /// @}
+
+    protected void setPowerStateToDesired() {
+        if (DBG) {
+            log("mDeviceShuttingDown=" + mDeviceShuttingDown +
+                    ", mDesiredPowerState=" + mDesiredPowerState +
+                    ", getRadioState=" + mCi.getRadioState() +
+                    ", mPowerOffDelayNeed=" + mPowerOffDelayNeed +
+                    ", mAlarmSwitch=" + mAlarmSwitch +
+                    ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier);
+        }
+
+        if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
+            if(DBG) log("mAlarmSwitch == true");
+            Context context = mPhone.getContext();
+            AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+            am.cancel(mRadioOffIntent);
+            mAlarmSwitch = false;
+        }
+
+        // If we want it on and it's off, turn it on
+        if (mDesiredPowerState && !mRadioDisabledByCarrier
+                && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
+            // [GSM] Send preferred network type before turn on radio power to avoid using wrong rat
+            if (mPhone.isPhoneTypeGsm()) setDeviceRatMode(mPhone.getPhoneId());
+            // MTK-START some actions must be took before EFUN
+            RadioManager.getInstance().sendRequestBeforeSetRadioPower(true, mPhone.getPhoneId());
+            /// MTK-END
+            mCi.setRadioPower(true, null);
+        } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
+            // If it's on and available and we want it off gracefully
+            if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
+                if (mImsRegistrationOnOff && !mAlarmSwitch) {
+                    if(DBG) log("mImsRegistrationOnOff == true");
+                    Context context = mPhone.getContext();
+                    AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+
+                    Intent intent = new Intent(ACTION_RADIO_OFF);
+                    mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
+
+                    mAlarmSwitch = true;
+                    if (DBG) log("Alarm setting");
+                    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                            SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
+                } else {
+                    DcTracker dcTracker = mPhone.mDcTracker;
+                    powerOffRadioSafely(dcTracker);
+                }
+            } else {
+                DcTracker dcTracker = mPhone.mDcTracker;
+                powerOffRadioSafely(dcTracker);
+            }
+        } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
+            mCi.requestShutdown(null);
+        }
+    }
+
+    protected void onUpdateIccAvailability() {
+        if (mUiccController == null ) {
+            return;
+        }
+
+        UiccCardApplication newUiccApplication = getUiccCardApplication();
+
+        /// M: [CDMA] Add for show EccButton when PIN and PUK status. @{
+        if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+            if (newUiccApplication != null) {
+                AppState appState = newUiccApplication.getState();
+                if ((appState == AppState.APPSTATE_PIN || appState == AppState.APPSTATE_PUK)
+                        && mNetworkExsit) {
+                    mEmergencyOnly = true;
+                } else {
+                    mEmergencyOnly = false;
+                }
+                mEmergencyOnly = mergeEmergencyOnlyCdmaIms(mEmergencyOnly);
+
+                log("[CDMA]onUpdateIccAvailability, appstate=" + appState
+                        + ", mNetworkExsit=" + mNetworkExsit
+                        + ", mEmergencyOnly=" + mEmergencyOnly);
+            }
+        }
+        /// @}
+
+        if (mUiccApplcation != newUiccApplication) {
+            if (mUiccApplcation != null) {
+                log("Removing stale icc objects.");
+                mUiccApplcation.unregisterForReady(this);
+                if (mIccRecords != null) {
+                    mIccRecords.unregisterForRecordsLoaded(this);
+                    if (mPhone.isPhoneTypeGsm()) {
+                        mIccRecords.unregisterForRecordsEvents(this);
+                    }
+                }
+                mIccRecords = null;
+                mUiccApplcation = null;
+            }
+            if (newUiccApplication != null) {
+                log("New card found");
+                mUiccApplcation = newUiccApplication;
+                mIccRecords = mUiccApplcation.getIccRecords();
+                if (mPhone.isPhoneTypeGsm()) {
+                    mUiccApplcation.registerForReady(this, EVENT_SIM_READY, null);
+                    if (mIccRecords != null) {
+                        mIccRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
+                        mIccRecords.registerForRecordsEvents(this, EVENT_SIM_OPL_LOADED, null);
+                    }
+                } else if (mIsSubscriptionFromRuim) {
+                    mUiccApplcation.registerForReady(this, EVENT_RUIM_READY, null);
+                    if (mIccRecords != null) {
+                        mIccRecords.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
+                    }
+                }
+            }
+        }
+    }
+
+    protected void logd(String s) {
+        if (mEngLoad ||(mLogLv>0)) {
+            if (mPhone.isPhoneTypeGsm()) {
+                Rlog.d(LOG_TAG, "[GsmSST" + mPhone.getPhoneId() + "] " + s);
+            } else if (mPhone.isPhoneTypeCdma()) {
+                Rlog.d(LOG_TAG, "[CdmaSST" + mPhone.getPhoneId() + "] " + s);
+            } else {
+                Rlog.d(LOG_TAG, "[CdmaLteSST" + mPhone.getPhoneId() + "] " + s);
+            }
+        }
+    }
+
+    private void logRoamingChange() {
+        mRoamingLog.log(mSS.toString());
+    }
+
+    private void logAttachChange() {
+        mAttachLog.log(mSS.toString());
+    }
+
+    private void logPhoneTypeChange() {
+        mPhoneTypeLog.log(Integer.toString(mPhone.getPhoneType()));
+    }
+
+    private void logRatChange() {
+        mRatLog.log(mSS.toString());
+    }
+
+    protected void log(String s) {
+        if (mPhone.isPhoneTypeGsm()) {
+            Rlog.d(LOG_TAG, "[GsmSST" + mPhone.getPhoneId() + "] " + s);
+        } else if (mPhone.isPhoneTypeCdma()) {
+            Rlog.d(LOG_TAG, "[CdmaSST" + mPhone.getPhoneId() + "] " + s);
+        } else {
+            Rlog.d(LOG_TAG, "[CdmaLteSST" + mPhone.getPhoneId() + "] " + s);
+        }
+    }
+
+    protected void loge(String s) {
+        if (mPhone.isPhoneTypeGsm()) {
+            Rlog.e(LOG_TAG, "[GsmSST" + mPhone.getPhoneId() + "] " + s);
+        } else if (mPhone.isPhoneTypeCdma()) {
+            Rlog.e(LOG_TAG, "[CdmaSST" + mPhone.getPhoneId() + "] " + s);
+        } else {
+            Rlog.e(LOG_TAG, "[CdmaLteSST" + mPhone.getPhoneId() + "] " + s);
+        }
+    }
+
+    /**
+     * @return The current GPRS state. IN_SERVICE is the same as "attached"
+     * and OUT_OF_SERVICE is the same as detached.
+     */
+    public int getCurrentDataConnectionState() {
+        return mSS.getDataRegState();
+    }
+
+    /**
+     * @return true if phone is camping on a technology (eg UMTS)
+     * that could support voice and data simultaneously.
+     */
+    public boolean isConcurrentVoiceAndDataAllowed() {
+        if (mPhone.isPhoneTypeGsm()) {
+            //return (mSS.getRilVoiceRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
+
+            //[ALPS01520958]-START:Detail HSPA PS bearer information for HSPA DC icon display
+            boolean isAllowed = false;
+            if (mSS.isVoiceRadioTechnologyHigher(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS) ||
+                mSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UMTS) {
+                isAllowed = true;
+            } else {
+                /// M: For CT VoLTE concurrent voice and data allow. @{
+                if (isConcurrentVoiceAndDataAllowedForVolte()) {
+                    isAllowed = true;
+                }
+                /// @}
+            }
+            //[ALPS01520958]-END
+
+            if (DBG) {
+                log("isConcurrentVoiceAndDataAllowed(): " + isAllowed);
+            }
+            return isAllowed;
+        } else if (mPhone.isPhoneTypeCdma()) {
+            // Note: it needs to be confirmed which CDMA network types
+            // can support voice and data calls concurrently.
+            // For the time-being, the return value will be false.
+            return false;
+        } else {
+            // Using the Conncurrent Service Supported flag for CdmaLte devices.
+            /// M: For svlte concurrent voice and data allow. @{
+            // here just a indicator of concurrent capability, but may be could not concurrent right
+            // now, so ignore voice register state.
+            if (SystemProperties.getInt("ro.boot.opt_c2k_lte_mode", 0) == 1
+                    && mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
+                return true;
+            }
+            /// @}
+
+            /// M: For VoLTE concurrent voice and data allow. @{
+            if (isConcurrentVoiceAndDataAllowedForVolte()) {
+                return true;
+            }
+            /// @}
+            return mSS.getCssIndicator() == 1;
+        }
+    }
+
+    public void setImsRegistrationState(boolean registered) {
+        log("ImsRegistrationState - registered : " + registered);
+
+        if (mImsRegistrationOnOff && !registered) {
+            if (mAlarmSwitch) {
+                mImsRegistrationOnOff = registered;
+
+                Context context = mPhone.getContext();
+                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+                am.cancel(mRadioOffIntent);
+                mAlarmSwitch = false;
+
+                sendMessage(obtainMessage(EVENT_CHANGE_IMS_STATE));
+                return;
+            }
+        }
+        mImsRegistrationOnOff = registered;
+    }
+
+    public void onImsCapabilityChanged() {
+        sendMessage(obtainMessage(EVENT_IMS_CAPABILITY_CHANGED));
+    }
+
+    public boolean isRadioOn() {
+        return mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON;
+    }
+
+    private void onNetworkStateChangeResult(AsyncResult ar) {
+        String info[];
+        int state = -1;
+        int lac = -1;
+        int cid = -1;
+        int Act = -1;
+        int cause = -1;
+
+        /* Note: There might not be full +CREG URC info when screen off
+                   Full URC format: +CREG:  <stat>, <lac>, <cid>, <Act>,<cause> */
+        if (ar.exception != null || ar.result == null) {
+           loge("onNetworkStateChangeResult exception");
+        } else {
+            info = (String[]) ar.result;
+
+            if (info.length > 0) {
+
+                state = Integer.parseInt(info[0]);
+
+                if (info[1] != null && info[1].length() > 0) {
+                   lac = Integer.parseInt(info[1], 16);
+                }
+
+                if (info[2] != null && info[2].length() > 0) {
+                   //TODO: fix JE (java.lang.NumberFormatException: Invalid int: "ffffffff")
+                   if (info[2].equals("FFFFFFFF") || info[2].equals("ffffffff")) {
+                       log("Invalid cid:" + info[2]);
+                       info[2] = "0000ffff";
+                   }
+                   cid = Integer.parseInt(info[2], 16);
+                }
+
+                if (info[3] != null && info[3].length() > 0) {
+                   Act = Integer.parseInt(info[3]);
+                }
+
+                if (info[4] != null && info[4].length() > 0) {
+                   cause = Integer.parseInt(info[4]);
+                }
+
+                log("onNetworkStateChangeResult state:" + state + " lac:" + lac + " cid:" + cid
+                        + " Act:" + Act + " cause:" + cause);
+
+                // determine whether this URC comes with 4G
+                if (Act == 14) voiceUrcWith4G = true;
+                else voiceUrcWith4G = false;
+
+                //ALPS00267573 CDR-ONS-245
+                if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    // Modem-based network loss optimization is only supported by newer version
+                    // modem, so we use this feature option to distinguish new/old modem.
+                    // AP-based solution here will thus be only applied to old version modem.
+                    if (SystemProperties.get("ro.mtk_md_world_mode_support").equals("0")) {
+                        try {
+                            if (mServiceStateExt.needIgnoredState(
+                                    mSS.getVoiceRegState(), state, cause) == true) {
+                                //MTK-ADD START : for CS not registered , PS regsitered (ex: LTE PS
+                                //only mode or 2/3G PS only SIM card or CS domain network
+                                //registeration temporary failure
+                                /* in case of CS not registered but PS regsitered, it will fasle
+                                   alarm "CS invalid".*/
+                                log("onNetworkStateChangeResult isCsInvalidCard:" +
+                                        isCsInvalidCard);
+                                if (!isCsInvalidCard) {
+                                    if (dontUpdateNetworkStateFlag == false) {
+                                        broadcastHideNetworkState("start",
+                                                ServiceState.STATE_OUT_OF_SERVICE);
+                                    }
+                                    dontUpdateNetworkStateFlag = true;
+                                } //end of if (!isCsInvalidCard)
+                                return;
+                            } else {
+                                if (dontUpdateNetworkStateFlag == true) {
+                                    broadcastHideNetworkState("stop",
+                                            ServiceState.STATE_OUT_OF_SERVICE);
+                                }
+                                dontUpdateNetworkStateFlag = false;
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                }
+                /* AT+CREG? result won't include <lac>,<cid> when phone is NOT registered.
+                   So we wpdate mNewCellLoc via +CREG URC when phone is not registered to network,
+                   so that CellLoc can be updated when pollStateDone  */
+                if ((lac != -1) && (cid != -1) && (regCodeToServiceState(state)
+                        == ServiceState.STATE_OUT_OF_SERVICE)) {
+                    // ignore unknown lac or cid value
+                    if (lac == 0xfffe || cid == 0x0fffffff) {
+                        logd("unknown lac:" + lac + " or cid:" + cid);
+                    } else {
+                        logd("mNewCellLoc Updated, lac:" + lac + " and cid:" + cid);
+                        ((GsmCellLocation)mNewCellLoc).setLacAndCid(lac, cid);
+                    }
+                }
+
+                if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    try {
+                    // ALPS00283696 CDR-NWS-241
+                        if (mServiceStateExt.needRejectCauseNotification(cause) == true) {
+                            setRejectCauseNotification(cause);
+                        }
+                    } catch (RuntimeException e) {
+                        e.printStackTrace();
+                    }
+                }
+
+            } else {
+                logd("onNetworkStateChangeResult length zero");
+            }
+        }
+
+        return;
+    }
+
+    public void setEverIVSR(boolean value)
+    {
+        log("setEverIVSR:" + value);
+        mEverIVSR = value;
+
+        /* ALPS00376525 notify IVSR start event */
+        if (value == true) {
+            Intent intent = new Intent(TelephonyIntents.ACTION_IVSR_NOTIFY);
+            intent.putExtra(TelephonyIntents.INTENT_KEY_IVSR_ACTION, "start");
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+
+            if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            }
+
+            log("broadcast ACTION_IVSR_NOTIFY intent");
+
+            mPhone.getContext().sendBroadcastAsUser(intent, UserHandle.ALL);
+        }
+    }
+
+    /**
+     * Return the current located PLMN string (ex: "46000") or null (ex: flight mode or no signal
+     * area)
+     */
+    public String getLocatedPlmn() {
+        return mLocatedPlmn;
+    }
+
+    private void updateLocatedPlmn(String plmn) {
+        logd("updateLocatedPlmn(),previous plmn= " + mLocatedPlmn + " ,update to: " + plmn);
+
+        if (((mLocatedPlmn == null) && (plmn != null)) ||
+            ((mLocatedPlmn != null) && (plmn == null)) ||
+            ((mLocatedPlmn != null) && (plmn != null) && !(mLocatedPlmn.equals(plmn)))) {
+            Intent intent = new Intent(TelephonyIntents.ACTION_LOCATED_PLMN_CHANGED);
+            if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            }
+            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
+
+            if (plmn != null) {
+                int mcc;
+                try {
+                    mcc = Integer.parseInt(plmn.substring(0, 3));
+                    intent.putExtra(TelephonyIntents.EXTRA_ISO, MccTable.countryCodeForMcc(mcc));
+                } catch (NumberFormatException ex) {
+                    loge("updateLocatedPlmn: countryCodeForMcc error" + ex);
+                    intent.putExtra(TelephonyIntents.EXTRA_ISO, "");
+                } catch (StringIndexOutOfBoundsException ex) {
+                    loge("updateLocatedPlmn: countryCodeForMcc error" + ex);
+                    intent.putExtra(TelephonyIntents.EXTRA_ISO, "");
+                }
+                if (SystemProperties.get(PROPERTY_AUTO_RAT_SWITCH).equals("0")) {
+                    loge("updateLocatedPlmn: framework auto RAT switch disabled");
+                } else {
+                    mLocatedPlmn = plmn;  //[ALPS02198932]
+                    setDeviceRatMode(mPhone.getPhoneId());
+                }
+            } else {
+                intent.putExtra(TelephonyIntents.EXTRA_ISO, "");
+            }
+
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        }
+
+        mLocatedPlmn = plmn;
+    }
+
+    private void onFemtoCellInfoResult(AsyncResult ar) {
+        String info[];
+        int isCsgCell = 0;
+
+        if (ar.exception != null || ar.result == null) {
+           loge("onFemtoCellInfo exception");
+        } else {
+            info = (String[]) ar.result;
+
+            if (info.length > 0) {
+
+                if (info[0] != null && info[0].length() > 0) {
+                    mFemtocellDomain = Integer.parseInt(info[0]);
+                    log("onFemtoCellInfo: mFemtocellDomain set to " + mFemtocellDomain);
+                }
+
+                if (info[5] != null && info[5].length() > 0) {
+                   isCsgCell = Integer.parseInt(info[5]);
+                }
+                mIsFemtocell = isCsgCell;
+                log("onFemtoCellInfo: domain= " + mFemtocellDomain + ",isCsgCell= " + isCsgCell);
+
+                if (isCsgCell == 1) {
+                    if (info[6] != null && info[6].length() > 0) {
+                        mCsgId = info[6];
+                        log("onFemtoCellInfo: mCsgId set to " + mCsgId);
+                    }
+
+                    if (info[8] != null && info[8].length() > 0) {
+                        mHhbName = new String(IccUtils.hexStringToBytes(info[8]));
+                        log("onFemtoCellInfo: mHhbName set from " + info[8] + " to " + mHhbName);
+                    } else {
+                        mHhbName = null;
+                        log("onFemtoCellInfo: mHhbName is not available ,set to null");
+                    }
+                } else {
+                    mCsgId = null;
+                    mHhbName = null;
+                    log("onFemtoCellInfo: csgId and hnbName are cleared");
+                }
+                if (isCsgCell != 2 && // ignore LTE & C2K case
+                    (info[1] != null && info[1].length() > 0)  &&
+                    (info[9] != null && info[0].length() > 0)) {
+                    int state = Integer.parseInt(info[1]);
+                    int cause = Integer.parseInt(info[9]);
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        try {
+                            if (mServiceStateExt.needIgnoreFemtocellUpdate(state, cause) == true) {
+                                log("needIgnoreFemtocellUpdate due to state= " + state + ",cause= "
+                                    + cause);
+                                // return here to prevent update variables and broadcast for CSG
+                                return;
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                }
+                Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
+                SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+
+                if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+                    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+                }
+
+                intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, mCurShowSpn);
+                intent.putExtra(TelephonyIntents.EXTRA_SPN, mCurSpn);
+                intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, mCurShowPlmn);
+                intent.putExtra(TelephonyIntents.EXTRA_PLMN, mCurPlmn);
+                // Femtocell (CSG) info
+                intent.putExtra(TelephonyIntents.EXTRA_HNB_NAME, mHhbName);
+                intent.putExtra(TelephonyIntents.EXTRA_CSG_ID, mCsgId);
+                intent.putExtra(TelephonyIntents.EXTRA_DOMAIN, mFemtocellDomain);
+                // isFemtocell (LTE/C2K)
+                intent.putExtra(TelephonyIntents.EXTRA_FEMTO, mIsFemtocell);
+
+                mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+
+                int phoneId = mPhone.getPhoneId();
+                String plmn = mCurPlmn;
+                if((mHhbName == null) && (mCsgId != null)){
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        try {
+                            if (mServiceStateExt.needToShowCsgId() == true) {
+                                plmn += " - ";
+                                plmn += mCsgId;
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    } else {
+                        plmn += " - ";
+                        plmn += mCsgId;
+                    }
+                } else if(mHhbName != null){
+                    plmn += " - ";
+                    plmn += mHhbName;
+                }
+                boolean setResult = mSubscriptionController.setPlmnSpn(phoneId,
+                        mCurShowPlmn, plmn, mCurShowSpn, mCurSpn);
+                if (!setResult) {
+                    mSpnUpdatePending = true;
+                }
+            }
+        }
+    }
+
+    /* ALPS01139189 START */
+    private void broadcastHideNetworkState(String action, int state) {
+        if (DBG) log("broadcastHideNetworkUpdate action=" + action + " state=" + state);
+        Intent intent = new Intent(TelephonyIntents.ACTION_HIDE_NETWORK_STATE);
+        if (TelephonyManager.getDefault().getPhoneCount() == 1) {
+            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        }
+        intent.putExtra(TelephonyIntents.EXTRA_ACTION, action);
+        intent.putExtra(TelephonyIntents.EXTRA_REAL_SERVICE_STATE, state);
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+        mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+    /* ALPS01139189 END */
+
+    //ALPS00248788
+    private void onInvalidSimInfoReceived(AsyncResult ar) {
+        String[] InvalidSimInfo = (String[]) ar.result;
+        String plmn = InvalidSimInfo[0];
+        int cs_invalid = Integer.parseInt(InvalidSimInfo[1]);
+        int ps_invalid = Integer.parseInt(InvalidSimInfo[2]);
+        int cause = Integer.parseInt(InvalidSimInfo[3]);
+        int testMode = -1;
+
+        // do NOT apply IVSR when in TEST mode
+        testMode = SystemProperties.getInt("gsm.gcf.testmode", 0);
+        // there is only one test mode in modem. actually it's not SIM dependent , so remove
+        // testmode2 property here
+
+        log("onInvalidSimInfoReceived testMode:" + testMode + " cause:" + cause + " cs_invalid:"
+                + cs_invalid + " ps_invalid:" + ps_invalid + " plmn:" + plmn
+                + " mEverIVSR:" + mEverIVSR);
+
+        //Check UE is set to test mode or not   (CTA =1,FTA =2 , IOT=3 ...)
+        if (testMode != 0) {
+            log("InvalidSimInfo received during test mode: " + testMode);
+            return;
+        }
+        if (mServiceStateExt.isNeedDisableIVSR()) {
+            log("Disable IVSR");
+            return;
+        }
+         //MTK-ADD Start : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS
+         //only SIM card or CS domain network registeration temporary failure
+         if (cs_invalid == 1) {
+             isCsInvalidCard = true;
+         }
+         //MTK-ADD END : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS
+         //only SIM card or CS domain network registeration temporary failure
+
+        /* check if CS domain ever sucessfully registered to the invalid SIM PLMN */
+        /* Integrate ALPS00286197 with MR2 data only device state update , not to apply CS domain
+           IVSR for data only device */
+        if (mVoiceCapable) {
+            if ((cs_invalid == 1) && (mLastRegisteredPLMN != null)
+                    && (plmn.equals(mLastRegisteredPLMN))) {
+                log("InvalidSimInfo reset SIM due to CS invalid");
+                setEverIVSR(true);
+                mLastRegisteredPLMN = null;
+                mLastPSRegisteredPLMN = null;
+                mCi.setSimPower(RILConstants.SIM_POWER_RESET, null);
+                return;
+            }
+        }
+
+        /* check if PS domain ever sucessfully registered to the invalid SIM PLMN */
+        //[ALPS02261450] - start
+        if ((ps_invalid == 1) && (isAllowRecoveryOnIvsr(ar)) &&
+                (mLastPSRegisteredPLMN != null) && (plmn.equals(mLastPSRegisteredPLMN))){
+        //if ((ps_invalid == 1) && (mLastPSRegisteredPLMN != null) &&
+        //              (plmn.equals(mLastPSRegisteredPLMN)))
+        //[ALPS02261450] - end
+            log("InvalidSimInfo reset SIM due to PS invalid ");
+            setEverIVSR(true);
+            mLastRegisteredPLMN = null;
+            mLastPSRegisteredPLMN = null;
+            mCi.setSimPower(RILConstants.SIM_POWER_RESET, null);
+            return;
+        }
+
+        /* ALPS00324111: to force trigger IVSR */
+        /* ALPS00407923  : The following code is to "Force trigger IVSR even
+                  when MS never register to the
+                  network before"The code was intended to cover the scenario of "invalid
+                  SIM NW issue happen
+                  at the first network registeration during boot-up".
+                  However, it might cause false alarm IVSR ex: certain sim card only register
+                  CS domain network , but PS domain is invalid.
+                  For such sim card, MS will receive invalid SIM at the first PS domain
+                  network registeration In such case , to trigger IVSR will be a false alarm,
+                  which will cause  CS domain network
+                  registeration time longer (due to IVSR impact)
+                  It's a tradeoff. Please think about the false alarm impact
+                  before using the code below.*/
+        /*
+        if ((mEverIVSR == false) && (gprsState != ServiceState.STATE_IN_SERVICE)
+                &&(mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE))
+        {
+            log("InvalidSimInfo set TRM due to never set IVSR");
+            setEverIVSR(true);
+            mLastRegisteredPLMN = null;
+            mLastPSRegisteredPLMN = null;
+            phone.setTRM(3, null);
+            return;
+        }
+        */
+
+    }
+
+    private void onModulationInfoReceived(AsyncResult ar) {
+        if (ar.exception != null || ar.result == null) {
+           loge("onModulationInfoReceived exception");
+        } else {
+            int info[];
+            int modulation;
+            info = (int[]) ar.result;
+            modulation = info[0];
+            log("[onModulationInfoReceived] modulation:" + modulation);
+
+            Intent intent = new Intent(TelephonyIntents.ACTION_NOTIFY_MODULATION_INFO);
+            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            intent.putExtra(TelephonyIntents.EXTRA_MODULATION_INFO, modulation);
+
+            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        }
+    }
+
+    //[ALPS02261450]
+    private boolean isAllowRecoveryOnIvsr(AsyncResult ar) {
+        if (mPhone.isInCall()){
+            log("[isAllowRecoveryOnIvsr] isInCall()=true");
+            Message msg;
+            msg = obtainMessage();
+            msg.what = EVENT_INVALID_SIM_INFO;
+            msg.obj = ar;
+            sendMessageDelayed(msg, POLL_PERIOD_MILLIS);
+            return false;
+        } else {
+            log("isAllowRecoveryOnIvsr() return true");
+            return true;
+        }
+    }
+
+    /**
+     * Post a notification to NotificationManager for network reject cause
+     *
+     * @param cause
+     */
+    private void setRejectCauseNotification(int cause) {
+        if (DBG) log("setRejectCauseNotification: create notification " + cause);
+
+        Context context = mPhone.getContext();
+        mNotificationBuilder = new Notification.Builder(context);
+        mNotificationBuilder.setWhen(System.currentTimeMillis());
+        mNotificationBuilder.setAutoCancel(true);
+        mNotificationBuilder.setSmallIcon(com.android.internal.R.drawable.stat_sys_warning);
+
+        Intent intent = new Intent();
+        mNotificationBuilder.setContentIntent(PendingIntent.
+                getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
+
+        CharSequence details = "";
+        CharSequence title = context.getText(com.mediatek.R.string.RejectCauseTitle);
+        int notificationId = REJECT_NOTIFICATION;
+
+        switch (cause) {
+            case 2:
+                details = context.getText(com.mediatek.R.string.MMRejectCause2);;
+                break;
+            case 3:
+                details = context.getText(com.mediatek.R.string.MMRejectCause3);;
+                break;
+            case 5:
+                details = context.getText(com.mediatek.R.string.MMRejectCause5);;
+                break;
+            case 6:
+                details = context.getText(com.mediatek.R.string.MMRejectCause6);;
+                break;
+            case 13:
+                details = context.getText(com.mediatek.R.string.MMRejectCause13);
+                break;
+            default:
+                break;
+        }
+
+        if (DBG) log("setRejectCauseNotification: put notification " + title + " / " + details);
+        mNotificationBuilder.setContentTitle(title);
+        mNotificationBuilder.setContentText(details);
+
+        NotificationManager notificationManager = (NotificationManager)
+            context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        mNotification = mNotificationBuilder.build();
+        notificationManager.notify(notificationId, mNotification);
+    }
+
+    /**
+     * Post a notification to NotificationManager for spcial icc card type
+     *
+     * @param cause
+     */
+    //[ALPS01558804] MTK-START: send notification for using some spcial icc card
+    private void setSpecialCardTypeNotification(String iccCardType, int titleType, int detailType) {
+        if (DBG) log("setSpecialCardTypeNotification: create notification for " + iccCardType);
+
+        //status notification
+        Context context = mPhone.getContext();
+        int notificationId = SPECIAL_CARD_TYPE_NOTIFICATION;
+
+        mNotificationBuilder = new Notification.Builder(context);
+        mNotificationBuilder.setWhen(System.currentTimeMillis());
+        mNotificationBuilder.setAutoCancel(true);
+        mNotificationBuilder.setSmallIcon(com.android.internal.R.drawable.stat_sys_warning);
+
+        Intent intent = new Intent();
+        mNotificationBuilder.setContentIntent(PendingIntent.
+                getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
+        CharSequence title = "";
+        switch (titleType) {
+            case 0:
+                title = context.getText(
+                        com.mediatek.R.string.Special_Card_Type_Title_Lte_Not_Available);
+                break;
+            default:
+                break;
+        }
+
+        CharSequence details = "";
+        switch (detailType) {
+            case 0:
+                details = context.getText(com.mediatek.R.string.Suggest_To_Change_USIM);
+                break;
+            default:
+                break;
+        }
+
+        if (DBG) log("setSpecialCardTypeNotification: put notification " + title + " / " + details);
+        mNotificationBuilder.setContentTitle(title);
+        mNotificationBuilder.setContentText(details);
+
+
+        NotificationManager notificationManager = (NotificationManager)
+            context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        mNotification = mNotificationBuilder.build();
+        notificationManager.notify(notificationId, mNotification);
+    }
+    //[ALPS01558804] MTK-END: send notification for using some spcial icc card
+
+
+    //MTK-START [ALPS00540036]
+    private int getDstForMcc(int mcc, long when) {
+        int dst = 0;
+
+        if (mcc != 0) {
+            String tzId = MccTable.defaultTimeZoneForMcc(mcc);
+            if (tzId != null) {
+                TimeZone timeZone = TimeZone.getTimeZone(tzId);
+                Date date = new Date(when);
+                boolean isInDaylightTime = timeZone.inDaylightTime(date);
+                if (isInDaylightTime) {
+                    dst = 1;
+                    log("[NITZ] getDstForMcc: dst=" + dst);
+                }
+            }
+        }
+
+        return dst;
+    }
+
+    private int getMobileCountryCode() {
+        int mcc = 0;
+
+        String operatorNumeric = mSS.getOperatorNumeric();
+        if (operatorNumeric != null) {
+            try {
+                mcc = Integer.parseInt(operatorNumeric.substring(0, 3));
+            } catch (NumberFormatException ex) {
+                loge("countryCodeForMcc error" + ex);
+            } catch (StringIndexOutOfBoundsException ex) {
+                loge("countryCodeForMcc error" + ex);
+            }
+        }
+
+        return mcc;
+    }
+    //MTK-END [ALPS00540036]
+
+    //MTK-START: update TimeZone by MCC/MNC
+    //Find TimeZone in manufacturer maintained table for the country has multiple timezone
+    private TimeZone getTimeZonesWithCapitalCity(String iso) {
+        TimeZone tz = null;
+
+        //[ALPS01666276]-Start: don't udpate with capital city when we has received nitz before
+        if ((mZoneOffset == 0) && (mZoneDst == false)) {
+            for (int i = 0; i < mTimeZoneIdOfCapitalCity.length; i++) {
+                if (iso.equals(mTimeZoneIdOfCapitalCity[i][0])) {
+                    tz = TimeZone.getTimeZone(mTimeZoneIdOfCapitalCity[i][1]);
+                    log("uses TimeZone of Capital City:" + mTimeZoneIdOfCapitalCity[i][1]);
+                    break;
+                }
+            }
+        } else {
+            log("don't udpate with capital city, cause we have received nitz");
+        }
+        //[ALPS01666276]-End
+        return tz;
+    }
+
+    // For the case that MccTable.defaultTimeZoneForMcc() returns unexpected timezone
+    private String getTimeZonesByMcc(String mcc) {
+        String tz = null;
+
+        for (int i = 0; i < mTimeZoneIdByMcc.length; i++) {
+            if (mcc.equals(mTimeZoneIdByMcc[i][0])) {
+                tz = mTimeZoneIdByMcc[i][1];
+                log("uses Timezone of GsmSST by mcc: " + mTimeZoneIdByMcc[i][1]);
+                break;
+            }
+        }
+        return tz;
+    }
+
+    //MTK-Add-start : [ALPS01267367] fix timezone by MCC
+    protected void fixTimeZone() {
+        TimeZone zone = null;
+        String iso = "";
+        String operatorNumeric = mSS.getOperatorNumeric();
+        String mcc = null;
+
+        //[ALPS01416062] MTK ADD-START
+        if (operatorNumeric != null && !operatorNumeric.equals("") && isNumeric(operatorNumeric)) {
+        //if (operatorNumeric != null) {
+        //[ALPS01416062] MTK ADD-END
+            mcc = operatorNumeric.substring(0, 3);
+        } else {
+            log("fixTimeZone but not registered and operatorNumeric is null or invalid value");
+            return;
+        }
+
+        try {
+            iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
+        } catch (NumberFormatException ex) {
+            loge("fixTimeZone countryCodeForMcc error" + ex);
+        }
+
+        if (!mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
+
+            // Test both paths if ignore nitz is true
+            boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(
+                        TelephonyProperties.PROPERTY_IGNORE_NITZ, false) &&
+                            ((SystemClock.uptimeMillis() & 1) == 0);
+
+            ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
+            if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
+                zone = uniqueZones.get(0);
+                if (DBG) {
+                   log("fixTimeZone: no nitz but one TZ for iso-cc=" + iso +
+                           " with zone.getID=" + zone.getID() +
+                           " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
+                }
+                setAndBroadcastNetworkSetTimeZone(zone.getID());
+            //MTK-START: [ALPS01262709] update time with MCC/MNC
+            //} else {
+            } else if (uniqueZones.size() > 1) {
+                log("uniqueZones.size=" + uniqueZones.size());
+                zone = getTimeZonesWithCapitalCity(iso);
+                //[ALPS01666276]-Start: don't udpate with capital city when we has received nitz
+                //before
+                if (zone != null) {
+                    setAndBroadcastNetworkSetTimeZone(zone.getID());
+                }
+                //[ALPS01666276]-End
+            //MTK-END: [ALPS01262709] update time with MCC/MNC
+            } else {
+                if (DBG) {
+                    log("fixTimeZone: there are " + uniqueZones.size() +
+                        " unique offsets for iso-cc='" + iso +
+                        " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath +
+                        "', do nothing");
+                }
+            }
+        }
+
+        if (zone != null) {
+            log("fixTimeZone: zone != null zone.getID=" + zone.getID());
+            if (getAutoTimeZone()) {
+                setAndBroadcastNetworkSetTimeZone(zone.getID());
+            }
+            saveNitzTimeZone(zone.getID());
+        } else {
+            log("fixTimeZone: zone == null");
+        }
+    }
+    //[ALPS01416062] MTK ADD-START
+    public boolean isNumeric(String str) {
+        //[ALPS01565135] MTK ADD -START for avoide JE on Pattern.Matcher
+        //Pattern pattern = Pattern.compile("[0-9]*");
+        //Matcher isNum = pattern.matcher(str);
+        //if(!isNum.matches()) {
+        //    return false;
+        //}
+        //return true;
+
+        try {
+            int testNum = Integer.parseInt(str);
+        } catch (NumberFormatException eNFE) {
+            log("isNumeric:" + eNFE.toString());
+            return false;
+        } catch (Exception e) {
+            log("isNumeric:" + e.toString());
+            return false;
+        }
+        return true;
+        //[ALPS01565135] MTK ADD -END
+    }
+    //[ALPS01416062] MTK ADD-END
+
+    //MTK-END:  [ALPS01262709]  update TimeZone by MCC/MNC
+
+    public class timerTask extends TimerTask {
+        public void run() {
+            log("CellInfo Timeout invoke getAllCellInfoByRate()");
+            if ((mCellInfoRate != Integer.MAX_VALUE) && (mCellInfoRate != 0)
+                    && (mCellInfoTimer != null)) {
+                log("timerTask schedule timer with period = " + mCellInfoRate + " ms");
+                mCellInfoTimer.schedule(new timerTask(), mCellInfoRate);
+            }
+
+            new Thread(new Runnable() {
+                public void run() {
+                    log("timerTask invoke getAllCellInfoByRate() in another thread");
+                    getAllCellInfoByRate();
+                }
+            }).start();
+
+        }
+    };
+
+    //MTK-START [ALPS01830723]
+
+    private void onPsNetworkStateChangeResult(AsyncResult ar) {
+        int info[];
+        int newUrcState;
+
+        if (ar.exception != null || ar.result == null) {
+           loge("onPsNetworkStateChangeResult exception");
+        } else {
+            info = (int[]) ar.result;
+            newUrcState = regCodeToServiceState(info[0]);
+            log("onPsNetworkStateChangeResult, mPsRegState:" + mPsRegState + ",new:" + newUrcState
+                    + ",result:" + info[0]);
+            //get the raw state value for roaming
+            mPsRegStateRaw = info[0];
+
+            if (mPsRegState == ServiceState.STATE_IN_SERVICE
+                       && newUrcState != ServiceState.STATE_IN_SERVICE) {
+                log("set flag for ever detach, may notify attach later");
+                bHasDetachedDuringPolling = true;
+            }
+        }
+    }
+
+    private void handlePsRegNotification(int oldState, int newState) {
+
+        boolean hasGprsAttached = false;
+        boolean hasGprsDetached = false;
+        boolean specificNotify = false;
+
+        log("old:" + oldState + " ,mPsRegState:" + mPsRegState + ",new:" + newState);
+
+        // Compare oldState and mPsRegState
+        hasGprsAttached =
+                oldState != ServiceState.STATE_IN_SERVICE
+                && mPsRegState == ServiceState.STATE_IN_SERVICE;
+
+        hasGprsDetached =
+                oldState == ServiceState.STATE_IN_SERVICE
+                && mPsRegState != ServiceState.STATE_IN_SERVICE;
+
+        if (hasGprsAttached) {
+            mAttachedRegistrants.notifyRegistrants();
+            mLastPSRegisteredPLMN = mSS.getOperatorNumeric() ;
+            log("mLastPSRegisteredPLMN= " + mLastPSRegisteredPLMN);
+            bHasDetachedDuringPolling = false;
+        }
+
+        if (hasGprsDetached) {
+            mDetachedRegistrants.notifyRegistrants();
+        }
+
+        // Compare mPsRegState and newState
+        hasGprsAttached =
+                mPsRegState != ServiceState.STATE_IN_SERVICE
+                && newState == ServiceState.STATE_IN_SERVICE;
+
+        hasGprsDetached =
+                mPsRegState == ServiceState.STATE_IN_SERVICE
+                && newState != ServiceState.STATE_IN_SERVICE;
+
+
+        if (!hasGprsAttached &&
+            bHasDetachedDuringPolling && newState == ServiceState.STATE_IN_SERVICE) {
+            // M: It means:   attached -> (detached) -> attached, need to compensate for notifying
+            // this modification is for "network losing enhancement"
+            specificNotify = true;
+            log("need to compensate for notifying");
+        }
+
+        if (hasGprsAttached || specificNotify) {
+            mAttachedRegistrants.notifyRegistrants();
+            mLastPSRegisteredPLMN = mSS.getOperatorNumeric() ;
+            log("mLastPSRegisteredPLMN= " + mLastPSRegisteredPLMN);
+        }
+
+        if (hasGprsDetached) {
+            mDetachedRegistrants.notifyRegistrants();
+        }
+
+        mPsRegState = newState;
+        bHasDetachedDuringPolling = false; // reset flag
+    }
+    //MTK-END [ALPS01830723]
+
+    //MTK-START [ALPS00368272]
+    private void getEINFO(int eventId) {
+        mPhone.invokeOemRilRequestStrings(new String[]{"AT+EINFO?", "+EINFO"},
+                this.obtainMessage(eventId));
+        log("getEINFO for EMMRRS");
+    }
+
+    private void setEINFO(int value, Message onComplete) {
+        String Cmd[] = new String[2];
+        Cmd[0] = "AT+EINFO=" + value;
+        Cmd[1] = "+EINFO";
+        mPhone.invokeOemRilRequestStrings(Cmd, onComplete);
+        log("setEINFO for EMMRRS, ATCmd[0]=" + Cmd[0]);
+    }
+
+    private boolean isCurrentPhoneDataConnectionOn() {
+        int defaultDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+        boolean userDataEnabled = true;
+
+        try {
+            userDataEnabled = TelephonyManager.getIntWithSubId(
+                    mPhone.getContext().getContentResolver(),
+                    Settings.Global.MOBILE_DATA, defaultDataSubId) == 1;
+        } catch (Settings.SettingNotFoundException snfe) {
+            if (DBG) log("isCurrentPhoneDataConnectionOn: SettingNofFoundException snfe=" + snfe);
+        }
+        log("userDataEnabled=" + userDataEnabled + ", defaultDataSubId=" + defaultDataSubId);
+        if (userDataEnabled && (defaultDataSubId
+                == SubscriptionManager.getSubIdUsingPhoneId(mPhone.getPhoneId()))) {
+            return true;
+        }
+        return false;
+    }
+    //MTK-END[ALPS00368272]
+
+    //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+    protected int updateOperatorAlpha(String operatorAlphaLong) {
+        int myPhoneId = mPhone.getPhoneId();
+        if (myPhoneId == PhoneConstants.SIM_ID_1) {
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_ALPHA, operatorAlphaLong);
+        } else if (myPhoneId == PhoneConstants.SIM_ID_2) {
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2, operatorAlphaLong);
+        } else if (myPhoneId == PhoneConstants.SIM_ID_3) {
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_3, operatorAlphaLong);
+        } else if (myPhoneId == PhoneConstants.SIM_ID_4) {
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_4, operatorAlphaLong);
+        }
+        return 1;
+    }
+    //[ALPS01804936]-end
+
+    //[ALPS01810775,ALPS01868743] -Start: update network type at screen off
+    private void updateNetworkInfo(int newRegState, int newNetworkType) {
+        int displayState = mCi.getDisplayState();
+
+        boolean isRegisted = false;
+        if ((newRegState == ServiceState.REGISTRATION_STATE_HOME_NETWORK) ||
+                (newRegState == ServiceState.REGISTRATION_STATE_ROAMING)) {
+            isRegisted = true;
+        } else {
+            isRegisted = false;
+        }
+
+        //Case1: update network type with new type.
+        //
+        //       situation 1): The format of CREG is long format when screen is on.
+        //       situation 2): mIsForceSendScreenOnForUpdateNwInfo is ture
+        //                         means we forec changed format to long at last time.
+        //       situation 3): not camp on network when screen is off
+        //
+        //Case2: change format to update cid , lac and network type
+        //       when camp on network after screen off.
+        //
+        //Case3: update network type with old type.
+        //       screen is off and registered before screen off
+
+        if ((displayState != Display.STATE_OFF) ||
+                mIsForceSendScreenOnForUpdateNwInfo ||
+                ((!isRegisted) && (displayState == Display.STATE_OFF))) {
+            mNewSS.setRilVoiceRadioTechnology(newNetworkType);
+        } else if ((mSS.getVoiceRegState()
+                        == ServiceState.STATE_OUT_OF_SERVICE) &&
+                        (isRegisted) && (displayState == Display.STATE_OFF)) {
+            if (!mIsForceSendScreenOnForUpdateNwInfo) {
+                log("send screen state ON to change format of CREG");
+                mIsForceSendScreenOnForUpdateNwInfo = true;
+                mCi.sendScreenState(true);
+                pollState();
+            }
+        } else if ((displayState == Display.STATE_OFF) && isRegisted) {
+            mNewSS.setRilVoiceRadioTechnology(mSS.getRilVoiceRadioTechnology());
+            log("set Voice network type=" + mNewSS.getRilVoiceRadioTechnology() +
+                    " update network type with old type.");
+        }
+    }
+    //[ALPS01810775,ALPS01868743] -End
+
+    public boolean isSameRadioTechnologyMode(int nRadioTechnology1, int nRadioTechnology2) {
+        if ((nRadioTechnology1 == ServiceState.RIL_RADIO_TECHNOLOGY_LTE &&
+                nRadioTechnology2 == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) ||
+                (nRadioTechnology1 == ServiceState.RIL_RADIO_TECHNOLOGY_GSM &&
+                nRadioTechnology2 == ServiceState.RIL_RADIO_TECHNOLOGY_GSM)) {
+            return true;
+        } else if (((nRadioTechnology1 >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS &&
+                        nRadioTechnology1 <= ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) ||
+                        nRadioTechnology1 == ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP) &&
+                        ((nRadioTechnology2 >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS &&
+                        nRadioTechnology2 <= ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) ||
+                        nRadioTechnology2 == ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP)) {
+            return true;
+        }
+        return false;
+    }
+
+    private void setReceivedNitz(int phoneId, boolean receivedNitz) {
+        log("setReceivedNitz : phoneId = " + phoneId);
+        sReceiveNitz[phoneId] = receivedNitz;
+    }
+
+    private boolean getReceivedNitz() {
+        return sReceiveNitz[mPhone.getPhoneId()];
+    }
+
+    private void onNetworkEventReceived(AsyncResult ar) {
+        if (ar.exception != null || ar.result == null) {
+           loge("onNetworkEventReceived exception");
+        } else {
+            // result[0]: <Act> not used
+            // result[1]: <event_type> 0: for RAU event , 1: for TAU event
+            int nwEventType = ((int[]) ar.result)[1];
+            log("[onNetworkEventReceived] event_type:" + nwEventType);
+
+            Intent intent = new Intent(TelephonyIntents.ACTION_NETWORK_EVENT);
+            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            intent.putExtra(TelephonyIntents.EXTRA_EVENT_TYPE, nwEventType + 1);
+
+            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        }
+    }
+
+
+
+    /**
+     * A complete "service state" from our perspective is
+     * composed of a handful of separate requests to the radio.
+     *
+     * We make all of these requests at once, but then abandon them
+     * and start over again if the radio notifies us that some
+     * event has changed
+     */
+    public void pollState() {
+        pollState(false);
+    }
+    /**
+     * We insist on polling even if the radio says its off.
+     * Used when we get a network changed notification
+     * but the radio is off - part of iwlan hack
+     */
+    private void modemTriggeredPollState() {
+        pollState(true);
+    }
+
+    public void pollState(boolean modemTriggered) {
+
+        //[ALPS01577029]-START:To support auto switch rat mode to 2G only for 3M TDD csfb project
+        //when we are not in china
+        int currentNetworkMode = getPreferredNetworkModeSettings(mPhone.getPhoneId());
+        //[ALPS01577029]-END
+
+        log("pollState RadioState is " + mCi.getRadioState() + ", currentNetworkMode= "
+                + currentNetworkMode + ", mPollingContext="
+                + (mPollingContext != null ? mPollingContext[0] : -1));
+
+        // [ALPS03020226]
+        if ((mPollingContext != null)
+                && (mPollingContext[0] != 0)
+                && (mCi.getRadioState() != CommandsInterface.RadioState.RADIO_UNAVAILABLE)) {
+            hasPendingPollState = true;
+            return;
+        }
+
+        mPollingContext = new int[1];
+        mPollingContext[0] = 0;
+
+        if (mPhone.isPhoneTypeGsm()) {
+            //[ALPS01996342]
+            if (dontUpdateNetworkStateFlag == true) {
+                log("pollState is ignored!!");
+                return;
+            }
+        }
+
+        switch (mCi.getRadioState()) {
+            case RADIO_UNAVAILABLE:
+
+                //M: MTK added for [ALPS01802701]
+                if (!mPhone.isPhoneTypeCdmaLte()) {
+                    // mNewSS.setStateOutOfService();
+                    mNewSS.setStateOff();
+                } else {
+                    mNewSS.setStateOutOfService();
+                }
+                //M: MTK added end
+
+                mNewCellLoc.setStateInvalid();
+                setSignalStrengthDefaultValues();
+                mGotCountryCode = false;
+                mNitzUpdatedTime = false;
+                if (mPhone.isPhoneTypeGsm()) {
+                    //M: MTK added
+                    setNullState();
+                    mPsRegStateRaw = ServiceState.RIL_REG_STATE_NOT_REG;
+                    //M: MTK added end
+                }
+                pollStateDone();
+                break;
+
+            case RADIO_OFF:
+                mNewSS.setStateOff();
+                mNewCellLoc.setStateInvalid();
+                setSignalStrengthDefaultValues();
+                mGotCountryCode = false;
+                mNitzUpdatedTime = false;
+                if (mPhone.isPhoneTypeGsm()) {
+                    //M: MTK added
+                    setNullState();
+                    //M: MTK added end
+                }
+                // don't poll for state when the radio is off
+                // EXCEPT, if the poll was modemTrigged (they sent us new radio data)
+                // or we're on IWLAN
+                if (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                        != mSS.getRilDataRadioTechnology()
+                    //M: MTK added
+                    && ServiceState.STATE_IN_SERVICE
+                        != regCodeToServiceState(mPsRegStateRaw)) {
+                    mPsRegStateRaw = ServiceState.RIL_REG_STATE_NOT_REG;
+                    //M: MTK added end
+                    pollStateDone();
+                    break;
+                }
+
+            default:
+                // Issue all poll-related commands at once then count down the responses, which
+                // are allowed to arrive out-of-order
+                mPollingContext[0]++;
+                mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
+
+                mPollingContext[0]++;
+                mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
+
+                mPollingContext[0]++;
+                mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION,
+                        mPollingContext));
+
+                if (mPhone.isPhoneTypeGsm()) {
+                    mPollingContext[0]++;
+                    mCi.getNetworkSelectionMode(obtainMessage(
+                            EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
+                }
+                break;
+        }
+    }
+
+    //todo: try to merge pollstate functions
+    private void pollStateDone() {
+        if (mPhone.isPhoneTypeGsm()) {
+            pollStateDoneGsm();
+        } else if (mPhone.isPhoneTypeCdma()) {
+            pollStateDoneCdma();
+        } else {
+            pollStateDoneCdmaLte();
+        }
+
+        if (hasPendingPollState) {
+            hasPendingPollState = false;
+            pollState();
+        }
+    }
+
+    // use to share iso, mcc between pollStateDoneGsm, fixTimeZone;
+    private String iso = "";
+    private String mcc = "";
+    private void pollStateDoneGsm() {
+        iso = "";
+        mcc = "";
+
+        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
+            mNewSS.setVoiceRoaming(true);
+            mNewSS.setDataRoaming(true);
+        }
+        useDataRegStateForDataOnlyDevices();
+        resetServiceStateInIwlanMode();
+
+        //if (DBG) {
+            log("Poll ServiceState done: " +
+                    " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" +
+                    " oldMaxDataCalls=" + mMaxDataCalls +
+                    " mNewMaxDataCalls=" + mNewMaxDataCalls +
+                    " oldReasonDataDenied=" + mReasonDataDenied +
+                    " mNewReasonDataDenied=" + mNewReasonDataDenied);
+        //}
+
+        //[ALPS01664312]-Add:Start
+        //change format to update cid , lac and network type when camp on network after screen off
+        if (mIsForceSendScreenOnForUpdateNwInfo) {
+            log("send screen state OFF to restore format of CREG");
+            mIsForceSendScreenOnForUpdateNwInfo = false;
+
+            //[ALPS01810775,ALPS01868743] -Start: update network type at screen off
+            //if (!mIsScreenOn) {
+            if (mCi.getDisplayState() == Display.STATE_OFF) {
+                mCi.sendScreenState(false);
+            }
+        }
+        //[ALPS01664312]-Add:end
+
+        boolean hasRegistered =
+                mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasDeregistered =
+                mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
+
+        boolean hasGprsAttached =
+                mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasGprsDetached =
+                mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
+
+        boolean hasDataRegStateChanged =
+                mSS.getDataRegState() != mNewSS.getDataRegState();
+
+        boolean hasVoiceRegStateChanged =
+                mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
+
+        boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
+
+        // ratchet the new tech up through it's rat family but don't drop back down
+        // until cell change
+        if (hasLocationChanged == false) {
+            mRatRatcheter.ratchetRat(mSS, mNewSS);
+        }
+
+        //[ALPS01507528]-START:udpate Sim Indicate State when +CREG:<state> is changed
+        boolean hasRilVoiceRegStateChanged =
+                mSS.getRilVoiceRegState() != mNewSS.getRilVoiceRegState();
+        //[ALPS01507528]-END
+
+        boolean hasRilVoiceRadioTechnologyChanged =
+                mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
+
+        boolean hasRilDataRadioTechnologyChanged =
+                mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
+
+        ///M: Fix the operator info not update issue.
+        boolean hasChanged = !mNewSS.equals(mSS) || mNeedNotify;
+
+        boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
+
+        boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
+
+        boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingTypeChanged =
+                mSS.getDataRoaming()
+                        && mNewSS.getDataRoaming()
+                        && mSS.getDataRoamingType() != mNewSS.getDataRoamingType();
+
+
+        boolean hasLacChanged =
+                ((GsmCellLocation)mNewCellLoc).getLac() != ((GsmCellLocation)mCellLoc).getLac();
+
+        TelephonyManager tm =
+                (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
+
+        log("pollStateDone,hasRegistered:" + hasRegistered + ",hasDeregistered:" + hasDeregistered
+                + ",hasGprsAttached:" + hasGprsAttached
+                + ",hasRilVoiceRadioTechnologyChanged:" + hasRilVoiceRadioTechnologyChanged
+                + ",hasRilDataRadioTechnologyChanged:" + hasRilDataRadioTechnologyChanged
+                + ",hasVoiceRegStateChanged:" + hasVoiceRegStateChanged + ",hasDataRegStateChanged:"
+                + hasDataRegStateChanged + ",hasChanged:" + hasChanged + ",hasVoiceRoamingOn:"
+                + hasVoiceRoamingOn + ",hasVoiceRoamingOff:" + hasVoiceRoamingOff
+                + ",hasDataRoamingOn:" + hasDataRoamingOn + ",hasDataRoamingOff:"
+                + hasDataRoamingOff + ",hasLocationChanged:" + hasLocationChanged
+                + ",hasLacChanged:" + hasLacChanged
+                + ",sReceiveNitz:" + getReceivedNitz()
+                + ",hasDataRoamingTypeChanged:" + hasDataRoamingTypeChanged);
+
+        // Add an event log when connection state changes
+        if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
+            EventLog.writeEvent(EventLogTags.GSM_SERVICE_STATE_CHANGE,
+                    mSS.getVoiceRegState(), mSS.getDataRegState(),
+                    mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
+        }
+
+        // Add an event log when network type switched
+        // TODO: we may add filtering to reduce the event logged,
+        // i.e. check preferred network setting, only switch to 2G, etc
+        if (hasRilVoiceRadioTechnologyChanged) {
+            int cid = -1;
+            GsmCellLocation loc = (GsmCellLocation)mNewCellLoc;
+            if (loc != null) cid = loc.getCid();
+            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
+            // existing logs were incorrectly using the new state for "network_from"
+            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
+            // to record the correct states.
+            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid,
+                    mSS.getRilVoiceRadioTechnology(),
+                    mNewSS.getRilVoiceRadioTechnology());
+            if (DBG) {
+                log("RAT switched "
+                        + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology())
+                        + " -> "
+                        + ServiceState.rilRadioTechnologyToString(
+                        mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
+            }
+        }
+
+        // swap mSS and mNewSS to put new state in mSS
+        ServiceState tss = mSS;
+        mSS = mNewSS;
+        mNewSS = tss;
+        // clean slate for next time
+        ////mNewSS.setStateOutOfService();
+
+        // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
+        GsmCellLocation tcl = (GsmCellLocation)mCellLoc;
+        mCellLoc = mNewCellLoc;
+        mNewCellLoc = tcl;
+
+        mReasonDataDenied = mNewReasonDataDenied;
+        mMaxDataCalls = mNewMaxDataCalls;
+
+        if (hasRilVoiceRadioTechnologyChanged) {
+            updatePhoneObject();
+        }
+
+        if (hasRilDataRadioTechnologyChanged) {
+            tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
+
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                log("pollStateDone: IWLAN enabled");
+            }
+        }
+
+        if (hasRegistered) {
+            mNetworkAttachedRegistrants.notifyRegistrants();
+
+            mLastRegisteredPLMN = mSS.getOperatorNumeric() ;
+            log("mLastRegisteredPLMN= " + mLastRegisteredPLMN);
+
+            if (DBG) {
+                log("pollStateDone: registering current mNitzUpdatedTime=" +
+                        mNitzUpdatedTime + " changing to false");
+            }
+            mNitzUpdatedTime = false;
+        }
+
+
+        if (explict_update_spn == 1)
+        {
+             /* ALPS00273961 :Screen on, modem explictly send CREG URC , but still not able to
+                update screen due to hasChanged is false
+                In this case , we update SPN display by explict_update_spn */
+             if (!hasChanged)
+             {
+                 log("explict_update_spn trigger to refresh SPN");
+                 updateSpnDisplay();
+             }
+             explict_update_spn = 0;
+        }
+
+        if (hasChanged) {
+            String operatorNumeric;
+
+            updateSpnDisplay();
+
+            ///M: Fix the operator info not update issue.
+            mNeedNotify = false;
+            //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+            // tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
+            //updateOperatorAlpha(mSS.getOperatorAlphaLong());  //remark for [ALPS01965792]
+            //[ALPS01804936]-end
+
+            String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
+            operatorNumeric = mSS.getOperatorNumeric();
+            tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
+            updateCarrierMccMncConfiguration(operatorNumeric,
+                    prevOperatorNumeric, mPhone.getContext());
+            //[ALPS01416062] MTK ADD-START
+            if ((operatorNumeric != null) && (!isNumeric(operatorNumeric))) {
+                if (DBG) log("operatorNumeric is Invalid value, don't update timezone");
+            } else if (TextUtils.isEmpty(operatorNumeric)) {
+                if (DBG) log("operatorNumeric is null");
+                updateCarrierMccMncConfiguration(operatorNumeric,
+                    prevOperatorNumeric, mPhone.getContext());
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
+                mGotCountryCode = false;
+                mNitzUpdatedTime = false;
+            } else {
+                try{
+                    mcc = operatorNumeric.substring(0, 3);
+                    iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
+                } catch ( NumberFormatException ex){
+                    loge("pollStateDone: countryCodeForMcc error" + ex);
+                } catch ( StringIndexOutOfBoundsException ex) {
+                    loge("pollStateDone: countryCodeForMcc error" + ex);
+                }
+
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
+                mGotCountryCode = true;
+
+                TimeZone zone = null;
+
+                if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) &&
+                        getAutoTimeZone()) {
+
+                    // Test both paths if ignore nitz is true
+                    boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(
+                            TelephonyProperties.PROPERTY_IGNORE_NITZ, false) &&
+                            ((SystemClock.uptimeMillis() & 1) == 0);
+
+                    ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
+                    if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
+                        zone = uniqueZones.get(0);
+                        if (DBG) {
+                            log("pollStateDone: no nitz but one TZ for iso-cc=" + iso +
+                                    " with zone.getID=" + zone.getID() +
+                                    " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
+                        }
+                        setAndBroadcastNetworkSetTimeZone(zone.getID());
+                    //MTK-START: [ALPS01262709] update time with MCC/MNC
+                    } else if (uniqueZones.size() > 1) {
+                        log("uniqueZones.size=" + uniqueZones.size() + " iso= " + iso);
+                        zone = getTimeZonesWithCapitalCity(iso);
+                        if (zone != null) {
+                            setAndBroadcastNetworkSetTimeZone(zone.getID());
+                        } else {
+                            log("Can't find time zone for capital city");
+                        }
+                    //MTK-END: [ALPS01262709] update time with MCC/MNC
+                    } else {
+                        if (DBG) {
+                            log("pollStateDone: there are " + uniqueZones.size() +
+                                    " unique offsets for iso-cc='" + iso +
+                                    " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath +
+                                    "', do nothing");
+                        }
+                    }
+                }
+
+                if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric,
+                        mNeedFixZoneAfterNitz)) {
+                    fixTimeZone(iso);
+                }
+            }
+
+            tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mSS.getVoiceRoaming());
+
+            setRoamingType(mSS);
+            log("Broadcasting ServiceState : " + mSS);
+            mPhone.notifyServiceStateChanged(mSS);
+
+            TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
+        }
+
+        if (hasGprsAttached || hasGprsDetached || hasRegistered || hasDeregistered) {
+            logAttachChange();
+        }
+
+        if (hasGprsAttached) {
+            mAttachedRegistrants.notifyRegistrants();
+            mLastPSRegisteredPLMN = mSS.getOperatorNumeric() ;
+            log("mLastPSRegisteredPLMN= " + mLastPSRegisteredPLMN);
+        }
+
+        if (hasGprsDetached) {
+            mDetachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
+            logRatChange();
+        }
+
+        if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
+            notifyDataRegStateRilRadioTechnologyChanged();
+
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
+            } else {
+                mPhone.notifyDataConnection(null);
+            }
+        }
+
+        if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
+            logRoamingChange();
+        }
+
+        if (hasVoiceRoamingOn) {
+            mVoiceRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasVoiceRoamingOff) {
+            mVoiceRoamingOffRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingOn) {
+            showRoamingReminderIfNeeded();
+            mDataRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingOff) {
+            mDataRoamingOffRegistrants.notifyRegistrants();
+
+        } else if (((mNewSS.getRilDataRegState() == ServiceState.REGISTRATION_STATE_HOME_NETWORK &&
+                    (mSS.getRilDataRegState() == ServiceState.REGISTRATION_STATE_HOME_NETWORK ||
+                    mSS.getRilDataRegState() == ServiceState.REGISTRATION_STATE_ROAMING)) ||
+                    (mSS.getRilDataRegState() == ServiceState.REGISTRATION_STATE_ROAMING &&
+                    mDataRoaming == false)) &&
+                    mPsRegStateRaw == ServiceState.RIL_REG_STATE_ROAMING) {
+            //Consider
+            //1. From home plmn -> roaming URC -> home URC -> home plmnand -> recover setup data
+            //2. From home plmn -> roaming URC -> domestic roam -> home plmn -> recover setup data
+            //3. From home(domestic) plmn -> roaming URC -> home(domestic) plmn -> recover setup
+            //   data
+            log("recover setup data for roaming off. OldDataRegState:"
+            + mNewSS.getRilDataRegState() + " NewDataRegState:" + mSS.getRilDataRegState() +
+            " NewRoamingState:" + mSS.getRoaming() + " NewDataRoamingState:" + mDataRoaming +
+            " PsRegState:" + mPsRegStateRaw);
+
+            mPsRegStateRaw = ServiceState.RIL_REG_STATE_HOME;
+            if (!mSS.getRoaming()) {
+                mDataRoamingOffRegistrants.notifyRegistrants();
+            }
+        }
+
+        if (hasDataRoamingTypeChanged) {
+            mDataRoamingTypeChangedRegistrants.notifyRegistrants();
+        }
+
+        if (hasLocationChanged) {
+            mPhone.notifyLocationChanged();
+        }
+
+        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
+            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
+                mStartedGprsRegCheck = true;
+
+                int check_period = Settings.Global.getInt(
+                        mPhone.getContext().getContentResolver(),
+                        Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS,
+                        DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
+                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS),
+                        check_period);
+            }
+        } else {
+            mReportedGprsNoReg = false;
+        }
+    }
+
+    protected void pollStateDoneCdma() {
+        updateRoamingState();
+
+        useDataRegStateForDataOnlyDevices();
+        resetServiceStateInIwlanMode();
+        if (DBG) log("pollStateDone: cdma oldSS=[" + mSS + "] newSS=[" + mNewSS + "]");
+
+        boolean hasRegistered =
+                mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionAttached =
+                mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionDetached =
+                mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionChanged =
+                mSS.getDataRegState() != mNewSS.getDataRegState();
+
+        boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
+
+        // ratchet the new tech up through it's rat family but don't drop back down
+        // until cell change
+        if (hasLocationChanged == false) {
+            mRatRatcheter.ratchetRat(mSS, mNewSS);
+        }
+
+        boolean hasRilVoiceRadioTechnologyChanged =
+                mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
+
+        boolean hasRilDataRadioTechnologyChanged =
+                mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
+
+        boolean hasChanged = !mNewSS.equals(mSS);
+
+        boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
+
+        boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
+
+        boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingTypeChanged =
+                mSS.getDataRoaming()
+                        && mNewSS.getDataRoaming()
+                        && mSS.getDataRoamingType() != mNewSS.getDataRoamingType();
+
+
+        TelephonyManager tm =
+                (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
+
+        // Add an event log when connection state changes
+        if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() ||
+                mSS.getDataRegState() != mNewSS.getDataRegState()) {
+            EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE,
+                    mSS.getVoiceRegState(), mSS.getDataRegState(),
+                    mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
+        }
+
+        ServiceState tss;
+        tss = mSS;
+        mSS = mNewSS;
+        mNewSS = tss;
+        // clean slate for next time
+        mNewSS.setStateOutOfService();
+
+        CdmaCellLocation tcl = (CdmaCellLocation)mCellLoc;
+        mCellLoc = mNewCellLoc;
+        mNewCellLoc = tcl;
+
+        if (hasRilVoiceRadioTechnologyChanged) {
+            updatePhoneObject();
+        }
+
+        if (hasRilDataRadioTechnologyChanged) {
+            tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
+
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                log("pollStateDone: IWLAN enabled");
+            }
+        }
+
+        if (hasRegistered) {
+            mNetworkAttachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasChanged) {
+            updateSpnDisplay();
+
+            String operatorNumeric;
+
+            tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
+
+            String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
+            operatorNumeric = mSS.getOperatorNumeric();
+
+            // try to fix the invalid Operator Numeric
+            if (isInvalidOperatorNumeric(operatorNumeric)) {
+                int sid = mSS.getSystemId();
+                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
+            }
+
+            tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
+            updateCarrierMccMncConfiguration(operatorNumeric,
+                    prevOperatorNumeric, mPhone.getContext());
+
+            if (isInvalidOperatorNumeric(operatorNumeric)) {
+                if (DBG) log("operatorNumeric "+ operatorNumeric +"is invalid");
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
+                mGotCountryCode = false;
+            } else {
+                String isoCountryCode = "";
+                String mcc = operatorNumeric.substring(0, 3);
+                try{
+                    isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(
+                            operatorNumeric.substring(0, 3)));
+                } catch ( NumberFormatException ex){
+                    loge("pollStateDone: countryCodeForMcc error" + ex);
+                } catch ( StringIndexOutOfBoundsException ex) {
+                    loge("pollStateDone: countryCodeForMcc error" + ex);
+                }
+
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
+                mGotCountryCode = true;
+
+                setOperatorIdd(operatorNumeric);
+
+                if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric,
+                        mNeedFixZoneAfterNitz)) {
+                    fixTimeZone(isoCountryCode);
+                }
+            }
+
+            tm.setNetworkRoamingForPhone(mPhone.getPhoneId(),
+                    (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
+
+            // set roaming type
+            setRoamingType(mSS);
+            log("Broadcasting ServiceState : " + mSS);
+            mPhone.notifyServiceStateChanged(mSS);
+
+            TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
+        }
+
+        if (hasCdmaDataConnectionAttached || hasCdmaDataConnectionDetached || hasRegistered) {
+            logAttachChange();
+        }
+
+        if (hasCdmaDataConnectionAttached) {
+            mAttachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasCdmaDataConnectionDetached) {
+            mDetachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
+            logRatChange();
+        }
+
+        if (hasCdmaDataConnectionChanged || hasRilDataRadioTechnologyChanged) {
+            notifyDataRegStateRilRadioTechnologyChanged();
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
+            } else {
+                mPhone.notifyDataConnection(null);
+            }
+        }
+
+        if (hasVoiceRoamingOn) {
+            mVoiceRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasVoiceRoamingOff) {
+            mVoiceRoamingOffRegistrants.notifyRegistrants();
+        }
+
+        if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
+            logRoamingChange();
+        }
+
+        if (hasDataRoamingOn) {
+            showRoamingReminderIfNeeded();
+            mDataRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingOff) {
+            mDataRoamingOffRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingTypeChanged) {
+            mDataRoamingTypeChangedRegistrants.notifyRegistrants();
+        }
+
+        if (hasLocationChanged) {
+            mPhone.notifyLocationChanged();
+        }
+        // TODO: Add CdmaCellIdenity updating, see CdmaLteServiceStateTracker.
+    }
+
+    protected void pollStateDoneCdmaLte() {
+        updateRoamingState();
+
+        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
+            mNewSS.setVoiceRoaming(true);
+            mNewSS.setDataRoaming(true);
+        }
+
+        useDataRegStateForDataOnlyDevices();
+        resetServiceStateInIwlanMode();
+        log("pollStateDone: lte 1 ss=[" + mSS + "] newSS=[" + mNewSS + "]");
+
+        boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE
+                && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE
+                && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionAttached =
+                mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionDetached =
+                mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE
+                        && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
+
+        boolean hasCdmaDataConnectionChanged =
+                mSS.getDataRegState() != mNewSS.getDataRegState();
+
+        boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
+
+        // ratchet the new tech up through it's rat family but don't drop back down
+        // until cell change
+        if (hasLocationChanged == false) {
+            mRatRatcheter.ratchetRat(mSS, mNewSS);
+        }
+
+        boolean hasVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology()
+                != mNewSS.getRilVoiceRadioTechnology();
+
+        boolean hasDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology()
+                != mNewSS.getRilDataRadioTechnology();
+
+        boolean hasChanged = !mNewSS.equals(mSS);
+
+        boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
+
+        boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
+
+        boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
+
+        boolean hasDataRoamingTypeChanged =
+                mSS.getDataRoaming()
+                        && mNewSS.getDataRoaming()
+                        && mSS.getDataRoamingType() != mNewSS.getDataRoamingType();
+
+        boolean has4gHandoff =
+                mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE &&
+                        ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) &&
+                                (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) ||
+                                ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) &&
+                                ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
+
+        boolean hasMultiApnSupport =
+                ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) ||
+                (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) &&
+                (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) &&
+                (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
+
+        boolean hasLostMultiApnSupport =
+                ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) &&
+                        (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
+
+        TelephonyManager tm =
+                (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
+
+        if (DBG) {
+            log("pollStateDone:"
+                    + " hasRegistered=" + hasRegistered
+                    + " hasDeegistered=" + hasDeregistered
+                    + " hasCdmaDataConnectionAttached=" + hasCdmaDataConnectionAttached
+                    + " hasCdmaDataConnectionDetached=" + hasCdmaDataConnectionDetached
+                    + " hasCdmaDataConnectionChanged=" + hasCdmaDataConnectionChanged
+                    + " hasVoiceRadioTechnologyChanged= " + hasVoiceRadioTechnologyChanged
+                    + " hasDataRadioTechnologyChanged=" + hasDataRadioTechnologyChanged
+                    + " hasChanged=" + hasChanged
+                    + " hasVoiceRoamingOn=" + hasVoiceRoamingOn
+                    + " hasVoiceRoamingOff=" + hasVoiceRoamingOff
+                    + " hasDataRoamingOn=" + hasDataRoamingOn
+                    + " hasDataRoamingOff=" + hasDataRoamingOff
+                    + " hasLocationChanged=" + hasLocationChanged
+                    + " has4gHandoff = " + has4gHandoff
+                    + " hasMultiApnSupport=" + hasMultiApnSupport
+                    + " hasLostMultiApnSupport=" + hasLostMultiApnSupport
+                    + " hasDataRoamingTypeChanged=" + hasDataRoamingTypeChanged);
+        }
+        // Add an event log when connection state changes
+        if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState()
+                || mSS.getDataRegState() != mNewSS.getDataRegState()) {
+            EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(),
+                    mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
+        }
+
+        /// M: [CDMALTE] If RAT group changed between 3GPP and 3GPP2, we need to update
+        // signal strenth(isGsm value) because MD won't report CSQ URC if no changes.@{
+        final int oldRilDataRadioTechnology = mSS.getRilDataRadioTechnology();
+        /// @}
+
+        ServiceState tss;
+        tss = mSS;
+        mSS = mNewSS;
+        mNewSS = tss;
+        // clean slate for next time
+        mNewSS.setStateOutOfService();
+
+        CdmaCellLocation tcl = (CdmaCellLocation)mCellLoc;
+        mCellLoc = mNewCellLoc;
+        mNewCellLoc = tcl;
+
+        mNewSS.setStateOutOfService(); // clean slate for next time
+
+        if (hasVoiceRadioTechnologyChanged) {
+            updatePhoneObject();
+        }
+
+        if (hasDataRadioTechnologyChanged) {
+            tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
+
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                log("pollStateDone: IWLAN enabled");
+            }
+
+            /// M: [CDMALTE] If RAT group changed between 3GPP and 3GPP2, we need to update
+            // signal strenth(isGsm value) because MD won't report CSQ URC if no changes.@{
+            if (oldRilDataRadioTechnology == ServiceState.RIL_RADIO_TECHNOLOGY_LTE
+                    || mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
+                log("[CDMALTE]pollStateDone: update signal for RAT switch between diff group");
+                sendMessage(obtainMessage(EVENT_POLL_SIGNAL_STRENGTH));
+            }
+            /// @}
+        }
+
+        if (hasRegistered) {
+            mNetworkAttachedRegistrants.notifyRegistrants();
+        }
+
+        /**
+         * Force to broadcast service state if pollState() is triggered by EVENT_ERI_FILE_LOADED
+         */
+        if (hasChanged || mEriTriggeredPollState) {
+            if (mEriTriggeredPollState) {
+                mEriTriggeredPollState = false;
+            }
+            updateSpnDisplay();
+
+            String operatorNumeric;
+
+            tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
+
+            String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
+            operatorNumeric = mSS.getOperatorNumeric();
+            // try to fix the invalid Operator Numeric
+            if (isInvalidOperatorNumeric(operatorNumeric)) {
+                int sid = mSS.getSystemId();
+                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
+            }
+            tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
+            updateCarrierMccMncConfiguration(operatorNumeric,
+                    prevOperatorNumeric, mPhone.getContext());
+
+            if (isInvalidOperatorNumeric(operatorNumeric)) {
+                if (DBG) log("operatorNumeric is null");
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
+                mGotCountryCode = false;
+            } else {
+                String isoCountryCode = "";
+                String mcc = operatorNumeric.substring(0, 3);
+                try {
+                    isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric
+                            .substring(0, 3)));
+                } catch (NumberFormatException ex) {
+                    loge("countryCodeForMcc error" + ex);
+                } catch (StringIndexOutOfBoundsException ex) {
+                    loge("countryCodeForMcc error" + ex);
+                }
+
+                tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
+                mGotCountryCode = true;
+
+                setOperatorIdd(operatorNumeric);
+
+                if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric,
+                        mNeedFixZoneAfterNitz)) {
+                    fixTimeZone(isoCountryCode);
+                }
+            }
+
+            tm.setNetworkRoamingForPhone(mPhone.getPhoneId(),
+                    (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
+
+            setRoamingType(mSS);
+            log("Broadcasting ServiceState : " + mSS);
+            mPhone.notifyServiceStateChanged(mSS);
+
+            TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
+        }
+
+        if (hasCdmaDataConnectionAttached || has4gHandoff || hasCdmaDataConnectionDetached ||
+                hasRegistered || hasDeregistered) {
+            logAttachChange();
+        }
+
+        if (hasCdmaDataConnectionAttached || has4gHandoff) {
+            mAttachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasCdmaDataConnectionDetached) {
+            mDetachedRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRadioTechnologyChanged || hasVoiceRadioTechnologyChanged) {
+            logRatChange();
+        }
+
+        if ((hasCdmaDataConnectionChanged || hasDataRadioTechnologyChanged)) {
+            notifyDataRegStateRilRadioTechnologyChanged();
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                    == mSS.getRilDataRadioTechnology()) {
+                mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
+            } else {
+                mPhone.notifyDataConnection(null);
+            }
+        }
+
+        if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
+            logRoamingChange();
+        }
+
+        if (hasVoiceRoamingOn) {
+            mVoiceRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasVoiceRoamingOff) {
+            mVoiceRoamingOffRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingOn) {
+            showRoamingReminderIfNeeded();
+            mDataRoamingOnRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingOff) {
+            mDataRoamingOffRegistrants.notifyRegistrants();
+        }
+
+        if (hasDataRoamingTypeChanged) {
+            mDataRoamingTypeChangedRegistrants.notifyRegistrants();
+        }
+
+        if (hasLocationChanged) {
+            mPhone.notifyLocationChanged();
+        }
+    }
+
+    private void updateOperatorNameFromEri() {
+        if (mPhone.isPhoneTypeCdma()) {
+            if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
+                String eriText;
+                // Now the Phone sees the new ServiceState so it can get the new ERI text
+                if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+                    eriText = mPhone.getCdmaEriText();
+                } else {
+                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                    // mRegistrationState 0,2,3 and 4
+                    eriText = mPhone.getContext().getText(
+                            com.android.internal.R.string.roamingTextSearching).toString();
+                }
+                mSS.setOperatorAlphaLong(eriText);
+            }
+        } else if (mPhone.isPhoneTypeCdmaLte()) {
+            boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null &&
+                    mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
+            if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) &&
+                    (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) ||
+                            mPhone.getContext().getResources().getBoolean(com.android.internal.R.
+                                    bool.config_LTE_eri_for_network_name)) &&
+                                    (!mIsSubscriptionFromRuim)) {/// M: [CDMALTE]
+                // Only when CDMA is in service, ERI will take effect
+                String eriText = mSS.getOperatorAlphaLong();
+                // Now the Phone sees the new ServiceState so it can get the new ERI text
+                if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+                    eriText = mPhone.getCdmaEriText();
+                } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
+                    eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
+                    if (TextUtils.isEmpty(eriText)) {
+                        // Sets operator alpha property by retrieving from
+                        // build-time system property
+                        eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
+                    }
+                } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
+                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
+                    // for mRegistrationState 0,2,3 and 4
+                    eriText = mPhone.getContext()
+                            .getText(com.android.internal.R.string.roamingTextSearching).toString();
+                }
+                mSS.setOperatorAlphaLong(eriText);
+            }
+
+            if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY &&
+                    mIccRecords != null && (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE)
+                    && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
+                // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
+                // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
+                // and NID are CDMA only, not applicable to LTE.
+                boolean showSpn =
+                        ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
+                int iconIndex = mSS.getCdmaEriIconIndex();
+
+                if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) &&
+                        isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) &&
+                        mIccRecords != null) {
+                    mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
+                }
+            }
+        }
+    }
+
+    /**
+     * Check whether the specified SID and NID pair appears in the HOME SID/NID list
+     * read from NV or SIM.
+     *
+     * @return true if provided sid/nid pair belongs to operator's home network.
+     */
+    private boolean isInHomeSidNid(int sid, int nid) {
+        // if SID/NID is not available, assume this is home network.
+        if (isSidsAllZeros()) return true;
+
+        // length of SID/NID shold be same
+        if (mHomeSystemId.length != mHomeNetworkId.length) return true;
+
+        if (sid == 0) return true;
+
+        for (int i = 0; i < mHomeSystemId.length; i++) {
+            // Use SID only if NID is a reserved value.
+            // SID 0 and NID 0 and 65535 are reserved. (C.0005 2.6.5.2)
+            if ((mHomeSystemId[i] == sid) &&
+                    ((mHomeNetworkId[i] == 0) || (mHomeNetworkId[i] == 65535) ||
+                            (nid == 0) || (nid == 65535) || (mHomeNetworkId[i] == nid))) {
+                return true;
+            }
+        }
+        // SID/NID are not in the list. So device is not in home network
+        return false;
+    }
+
+    protected void setOperatorIdd(String operatorNumeric) {
+        // Retrieve the current country information
+        // with the MCC got from opeatorNumeric.
+        /// M: Use try catch to avoid Integer pars exception @{
+        String idd = "";
+        try {
+            idd = mHbpcdUtils.getIddByMcc(
+                Integer.parseInt(operatorNumeric.substring(0,3)));
+        } catch (NumberFormatException ex) {
+            loge("setOperatorIdd: idd error" + ex);
+        } catch (StringIndexOutOfBoundsException ex) {
+            loge("setOperatorIdd: idd error" + ex);
+        }
+        /// @}
+        if (idd != null && !idd.isEmpty()) {
+            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING,
+                    idd);
+        } else {
+            // use default "+", since we don't know the current IDP
+            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
+        }
+    }
+
+    protected boolean isInvalidOperatorNumeric(String operatorNumeric) {
+        return operatorNumeric == null || operatorNumeric.length() < 5 ||
+                operatorNumeric.startsWith(INVALID_MCC);
+    }
+
+    protected String fixUnknownMcc(String operatorNumeric, int sid) {
+        if (sid <= 0) {
+            // no cdma information is available, do nothing
+            return operatorNumeric;
+        }
+
+        // resolve the mcc from sid;
+        // if mSavedTimeZone is null, TimeZone would get the default timeZone,
+        // and the fixTimeZone couldn't help, because it depends on operator Numeric;
+        // if the sid is conflict and timezone is unavailable, the mcc may be not right.
+        boolean isNitzTimeZone = false;
+        int timeZone = 0;
+        TimeZone tzone = null;
+        if (mSavedTimeZone != null) {
+            timeZone =
+                    TimeZone.getTimeZone(mSavedTimeZone).getRawOffset()/MS_PER_HOUR;
+            isNitzTimeZone = true;
+        } else {
+            tzone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
+            if (tzone != null)
+                timeZone = tzone.getRawOffset()/MS_PER_HOUR;
+        }
+
+        int mcc = mHbpcdUtils.getMcc(sid,
+                timeZone, (mZoneDst ? 1 : 0), isNitzTimeZone);
+        if (mcc > 0) {
+            operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
+        }
+        return operatorNumeric;
+    }
+
+    protected void fixTimeZone(String isoCountryCode) {
+        TimeZone zone = null;
+        // If the offset is (0, false) and the time zone property
+        // is set, use the time zone property rather than GMT.
+        String zoneName = SystemProperties.get(TIMEZONE_PROPERTY);
+        if (DBG) {
+            log("fixTimeZone zoneName='" + zoneName +
+                    "' mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst +
+                    " iso-cc='" + isoCountryCode +
+                    "' iso-cc-idx=" + Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode));
+        }
+        if ("".equals(isoCountryCode) && mNeedFixZoneAfterNitz) {
+            // Country code not found.  This is likely a test network.
+            // Get a TimeZone based only on the NITZ parameters (best guess).
+            zone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
+            if (DBG) log("pollStateDone: using NITZ TimeZone");
+        } else if ((mZoneOffset == 0) && (mZoneDst == false) && (zoneName != null)
+                && (zoneName.length() > 0)
+                && (Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode) < 0)) {
+            // For NITZ string without time zone,
+            // need adjust time to reflect default time zone setting
+            zone = TimeZone.getDefault();
+            if (mPhone.isPhoneTypeGsm()) {
+                //MTK-ADD-Start: [ALPS01262709] try ot fix timezone by MCC
+                //[ALPS01825832] fix timezone by MCC only if we don't recevice NITZ before
+                if (isAllowFixTimeZone()) {
+                    try {
+                        String mccTz = getTimeZonesByMcc(mcc);
+                        mccTz = (mccTz == null) ?
+                            MccTable.defaultTimeZoneForMcc(Integer.parseInt(mcc)) : mccTz;
+                        if (mccTz != null) {
+                            zone = TimeZone.getTimeZone(mccTz);
+                            if (DBG) log("pollStateDone: try to fixTimeZone mcc:" + mcc
+                                    + " mccTz:" + mccTz + " zone.getID=" + zone.getID());
+                        }
+                    } catch (Exception e) {
+                        log("pollStateDone: parse error: mcc=" + mcc);
+                    }
+                }
+                //MTK-ADD-END: [ALPS01262709] try ot fix timezone by MCC
+            }
+
+            if (mNeedFixZoneAfterNitz) {
+                long ctm = System.currentTimeMillis();
+                long tzOffset = zone.getOffset(ctm);
+                if (DBG) {
+                    log("fixTimeZone: tzOffset=" + tzOffset +
+                            " ltod=" + TimeUtils.logTimeOfDay(ctm));
+                }
+                if (getAutoTime()) {
+                    long adj = ctm - tzOffset;
+                    if (DBG) log("fixTimeZone: adj ltod=" + TimeUtils.logTimeOfDay(adj));
+                    setAndBroadcastNetworkSetTime(adj);
+                } else {
+                    // Adjust the saved NITZ time to account for tzOffset.
+                    mSavedTime = mSavedTime - tzOffset;
+                    if (DBG) log("fixTimeZone: adj mSavedTime=" + mSavedTime);
+                }
+            }
+            if (DBG) log("fixTimeZone: using default TimeZone");
+        } else {
+            zone = TimeUtils.getTimeZone(mZoneOffset, mZoneDst, mZoneTime, isoCountryCode);
+            if (DBG) log("fixTimeZone: using getTimeZone(off, dst, time, iso)");
+        }
+
+        mNeedFixZoneAfterNitz = false;
+
+        if (zone != null) {
+            log("fixTimeZone: zone != null zone.getID=" + zone.getID());
+            if (getAutoTimeZone()) {
+                setAndBroadcastNetworkSetTimeZone(zone.getID());
+            } else {
+                log("fixTimeZone: skip changing zone as getAutoTimeZone was false");
+            }
+            saveNitzTimeZone(zone.getID());
+
+            /// M: [CDMA] Save NITZ timezone ID in system propery for CDMA SMS.@{
+            if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+                TelephonyManager.setTelephonyProperty(
+                        mPhone.getPhoneId(), IPlusCodeUtils.PROPERTY_NITZ_TIME_ZONE_ID,
+                        zone.getID());
+            }
+            /// @}
+        } else {
+            log("fixTimeZone: zone == null, do nothing for zone");
+        }
+    }
+
+    /**
+     * Check if GPRS got registered while voice is registered.
+     *
+     * @param dataRegState i.e. CGREG in GSM
+     * @param voiceRegState i.e. CREG in GSM
+     * @return false if device only register to voice but not gprs
+     */
+    private boolean isGprsConsistent(int dataRegState, int voiceRegState) {
+        return !((voiceRegState == ServiceState.STATE_IN_SERVICE) &&
+                (dataRegState != ServiceState.STATE_IN_SERVICE));
+    }
+
+    /**
+     * Returns a TimeZone object based only on parameters from the NITZ string.
+     */
+    private TimeZone getNitzTimeZone(int offset, boolean dst, long when) {
+        TimeZone guess = findTimeZone(offset, dst, when);
+        if (guess == null) {
+            // Couldn't find a proper timezone.  Perhaps the DST data is wrong.
+            guess = findTimeZone(offset, !dst, when);
+        }
+        if (DBG) log("getNitzTimeZone returning " + (guess == null ? guess : guess.getID()));
+        return guess;
+    }
+
+    private TimeZone findTimeZone(int offset, boolean dst, long when) {
+        log("[NITZ],findTimeZone,offset:" + offset + ",dst:" + dst + ",when:" + when);
+        int rawOffset = offset;
+        if (dst) {
+            rawOffset -= MS_PER_HOUR;
+        }
+        String[] zones = TimeZone.getAvailableIDs(rawOffset);
+        TimeZone guess = null;
+        Date d = new Date(when);
+        for (String zone : zones) {
+            TimeZone tz = TimeZone.getTimeZone(zone);
+            if (tz.getOffset(when) == offset &&
+                    tz.inDaylightTime(d) == dst) {
+                guess = tz;
+                log("[NITZ],find time zone.");
+                break;
+            }
+        }
+
+        return guess;
+    }
+
+    /** code is registration state 0-5 from TS 27.007 7.2 */
+    private int regCodeToServiceState(int code) {
+        switch (code) {
+            case 0:
+            case 2: // 2 is "searching"
+            case 3: // 3 is "registration denied"
+            case 4: // 4 is "unknown" no vaild in current baseband
+            case 10:// same as 0, but indicates that emergency call is possible.
+            case 12:// same as 2, but indicates that emergency call is possible.
+            case 13:// same as 3, but indicates that emergency call is possible.
+            case 14:// same as 4, but indicates that emergency call is possible.
+                return ServiceState.STATE_OUT_OF_SERVICE;
+
+            case 1:
+            case 5: // 5 is "registered, roaming"
+                return ServiceState.STATE_IN_SERVICE;
+
+            default:
+                loge("regCodeToServiceState: unexpected service state " + code);
+                return ServiceState.STATE_OUT_OF_SERVICE;
+        }
+    }
+
+    /** code is registration state 0-5 from TS 27.007 7.2 */
+    private int regCodeToRegState(int code) {
+        switch (code) {
+            case 10:// same as 0, but indicates that emergency call is possible.
+                return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+            case 12:// same as 2, but indicates that emergency call is possible.
+                return ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING;
+            case 13:// same as 3, but indicates that emergency call is possible.
+                return ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED;
+            case 14:// same as 4, but indicates that emergency call is possible.
+                return ServiceState.REGISTRATION_STATE_UNKNOWN;
+            default:
+                return code;
+        }
+    }
+
+    private String getSIMOperatorNumeric() {
+        IccRecords r = mIccRecords;
+        String mccmnc;
+        String imsi;
+
+        if (r != null) {
+            mccmnc = r.getOperatorNumeric();
+
+            //M: [ALPS01591758]Try to get HPLMN from IMSI (getOperatorNumeric might response null
+            //due to mnc length is not available yet)
+            if (mccmnc == null) {
+                imsi = r.getIMSI();
+                if (imsi != null && !imsi.equals("")) {
+                    mccmnc = imsi.substring(0, 5);
+                    log("get MCC/MNC from IMSI = " + mccmnc);
+                }
+            }
+            if (mPhone.isPhoneTypeGsm()) {
+                if (mccmnc == null || mccmnc.equals("")) {
+                    String SimMccMncProp = "gsm.ril.uicc.mccmnc";
+                    if (mPhone.getPhoneId() != 0) {
+                        SimMccMncProp += "." + mPhone.getPhoneId();
+                    }
+                    mccmnc = SystemProperties.get(SimMccMncProp, "");
+                    log("get MccMnc from property(" + SimMccMncProp + "): " + mccmnc);
+                }
+            }
+            return mccmnc;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * code is registration state 0-5 from TS 27.007 7.2
+     * returns true if registered roam, false otherwise
+     */
+    private boolean regCodeIsRoaming (int code) {
+        if (mPhone.isPhoneTypeGsm()) {
+            //M: MTK added
+            boolean isRoaming = false;
+            String strHomePlmn = getSIMOperatorNumeric();
+            String strServingPlmn = mNewSS.getOperatorNumeric();
+            boolean isServingPlmnInGroup = false;
+            boolean isHomePlmnInGroup = false;
+
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                String simType = PhoneFactory.getPhone(mPhone.getPhoneId())
+                        .getIccCard().getIccCardType();
+                try {
+                    if ((strServingPlmn != null)
+                            && (strHomePlmn != null)
+                            && ((simType != null) && (!simType.equals("")) && simType
+                                    .equals("CSIM"))
+                            && mServiceStateExt.isRoamingForSpecialSIM(strServingPlmn,
+                            strHomePlmn)) {
+                        return true;
+                    }
+                } catch (RuntimeException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if (ServiceState.RIL_REG_STATE_ROAMING == code) {
+                isRoaming = true;
+            }
+
+            /* ALPS00236452: check manufacturer maintained table for specific operator with
+               multiple home PLMN id */
+            if ((isRoaming == true) && (strServingPlmn != null) && (strHomePlmn != null)) {
+                log("strServingPlmn = " + strServingPlmn + " strHomePlmn = " + strHomePlmn);
+
+                for (int i = 0; i < customEhplmn.length; i++) {
+                    //reset flag
+                    isServingPlmnInGroup = false;
+                    isHomePlmnInGroup = false;
+
+                    //check if serving plmn or home plmn in this group
+                    for (int j = 0; j < customEhplmn[i].length; j++) {
+                        if (strServingPlmn.equals(customEhplmn[i][j])) {
+                            isServingPlmnInGroup = true;
+                        }
+                        if (strHomePlmn.equals(customEhplmn[i][j])) {
+                            isHomePlmnInGroup = true;
+                        }
+                    }
+
+                    //if serving plmn and home plmn both in the same group
+                    //, do NOT treat it as roaming
+                    if ((isServingPlmnInGroup == true) && (isHomePlmnInGroup == true)) {
+                        isRoaming = false;
+                        log("Ignore roaming");
+                        break;
+                    }
+                }
+            }
+
+            return isRoaming;
+            // M : MTK added end
+        } else {
+            return ServiceState.RIL_REG_STATE_ROAMING == code;
+        }
+    }
+
+    private boolean isSameOperatorNameFromSimAndSS(ServiceState s) {
+        String spn = ((TelephonyManager) mPhone.getContext().
+                getSystemService(Context.TELEPHONY_SERVICE)).
+                getSimOperatorNameForPhone(getPhoneId());
+
+        // NOTE: in case of RUIM we should completely ignore the ERI data file and
+        // mOperatorAlphaLong is set from RIL_REQUEST_OPERATOR response 0 (alpha ONS)
+        String onsl = s.getOperatorAlphaLong();
+        String onss = s.getOperatorAlphaShort();
+
+        if (VDBG) log("isSameNamedOperators(): onsl=" + onsl + ",onss=" + onss + ",spn=" + spn);
+
+        boolean equalsOnsl = !TextUtils.isEmpty(spn) && spn.equalsIgnoreCase(onsl);
+        boolean equalsOnss = !TextUtils.isEmpty(spn) && spn.equalsIgnoreCase(onss);
+
+        return (equalsOnsl || equalsOnss);
+    }
+
+    /**
+     * Set roaming state if operator mcc is the same as sim mcc
+     * and ons is not different from spn
+     *
+     * @param s ServiceState hold current ons
+     * @return true if same operator
+     */
+    private boolean isSameNamedOperators(ServiceState s) {
+        return currentMccEqualsSimMcc(s) && isSameOperatorNameFromSimAndSS(s);
+    }
+
+    /**
+     * Compare SIM MCC with Operator MCC
+     *
+     * @param s ServiceState hold current ons
+     * @return true if both are same
+     */
+    private boolean currentMccEqualsSimMcc(ServiceState s) {
+        String simNumeric = ((TelephonyManager) mPhone.getContext().
+                getSystemService(Context.TELEPHONY_SERVICE)).
+                getSimOperatorNumericForPhone(getPhoneId());
+        String operatorNumeric = s.getOperatorNumeric();
+        boolean equalsMcc = true;
+
+        try {
+            equalsMcc = simNumeric.substring(0, 3).
+                    equals(operatorNumeric.substring(0, 3));
+            if (VDBG) log("currentMccEqualsSimMcc(): equalsMcc=" + equalsMcc + ",simNumeric="
+                    + simNumeric + ",operatorNumeric=" + operatorNumeric);
+        } catch (Exception e){
+        }
+        return equalsMcc;
+    }
+
+    /**
+     * Do not set roaming state in case of oprators considered non-roaming.
+     *
+     * Can use mcc or mcc+mnc as item of config_operatorConsideredNonRoaming.
+     * For example, 302 or 21407. If mcc or mcc+mnc match with operator,
+     * don't set roaming state.
+     *
+     * @param s ServiceState hold current ons
+     * @return false for roaming state set
+     */
+    private boolean isOperatorConsideredNonRoaming(ServiceState s) {
+        String operatorNumeric = s.getOperatorNumeric();
+        String[] numericArray = mPhone.getContext().getResources().getStringArray(
+                com.android.internal.R.array.config_operatorConsideredNonRoaming);
+
+        if (VDBG) log("isOperatorConsideredNonRoaming operatorNumeric= " + operatorNumeric
+                + ",legnth= " + numericArray.length);
+
+        if (numericArray.length == 0 || operatorNumeric == null) {
+            return false;
+        }
+
+        for (String numeric : numericArray) {
+            if (VDBG) log("isOperatorConsideredNonRoaming numeric= " + numeric);
+            if (operatorNumeric.startsWith(numeric)) {
+                if (VDBG) log("isOperatorConsideredNonRoaming return true");
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /** M:[ALPS02503235]add operator considered roaming configures @{ */
+    private boolean isOperatorConsideredRoamingMtk(ServiceState s) {
+        String operatorNumeric = s.getOperatorNumeric();
+        String simOperatorNumeric = ((TelephonyManager) mPhone.getContext()
+                .getSystemService(Context.TELEPHONY_SERVICE))
+                .getSimOperatorNumericForPhone(getPhoneId());
+
+        if (VDBG)
+            log("isOperatorConsideredRoamingMtk operatorNumeric= "
+                    + operatorNumeric + ",legnth= "
+                    + customOperatorConsiderRoamingMcc.length);
+
+        if (customOperatorConsiderRoamingMcc.length == 0
+                || TextUtils.isEmpty(operatorNumeric)
+                || TextUtils.isEmpty(simOperatorNumeric)) {
+            return false;
+        }
+
+        for (String[] numerics : customOperatorConsiderRoamingMcc) {
+            if (simOperatorNumeric.startsWith(numerics[0])) {
+                for (int idx = 1; idx < numerics.length; idx++) {
+                    if (VDBG) {
+                        log("isOperatorConsideredRoamingMtk numeric= "
+                                + numerics[idx]);
+                    }
+                    if (operatorNumeric.startsWith(numerics[idx])) {
+                        if (VDBG) {
+                            log("isOperatorConsideredRoamingMtk return true");
+                        }
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+    /** @} */
+
+
+    private boolean isOperatorConsideredRoaming(ServiceState s) {
+        String operatorNumeric = s.getOperatorNumeric();
+        String[] numericArray = mPhone.getContext().getResources().getStringArray(
+                com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
+
+        if (VDBG) log("isOperatorConsideredRoaming operatorNumeric= " + operatorNumeric
+                + ",legnth= " + numericArray.length);
+
+        if (numericArray.length == 0 || operatorNumeric == null) {
+            return false;
+        }
+
+        for (String numeric : numericArray) {
+            if (VDBG) log("isOperatorConsideredRoaming numeric= " + numeric);
+            if (operatorNumeric.startsWith(numeric)) {
+                if (VDBG) log("isOperatorConsideredRoaming return true");
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Set restricted state based on the OnRestrictedStateChanged notification
+     * If any voice or packet restricted state changes, trigger a UI
+     * notification and notify registrants when sim is ready.
+     *
+     * @param ar an int value of RIL_RESTRICTED_STATE_*
+     */
+    private void onRestrictedStateChanged(AsyncResult ar) {
+        RestrictedState newRs = new RestrictedState();
+
+        if (DBG) log("onRestrictedStateChanged: E rs "+ mRestrictedState);
+
+        if (ar.exception == null) {
+            int[] ints = (int[])ar.result;
+            int state = ints[0];
+
+            newRs.setCsEmergencyRestricted(
+                    ((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) ||
+                            ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0) );
+            //ignore the normal call and data restricted state before SIM READY
+            if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
+                newRs.setCsNormalRestricted(
+                        ((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) ||
+                                ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0) );
+                newRs.setPsRestricted(
+                        (state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL)!= 0);
+            } else if (mPhone.isPhoneTypeGsm()) {
+                log("IccCard state Not ready ");
+                if (mRestrictedState.isCsNormalRestricted() &&
+                    ((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) == 0 &&
+                    (state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) == 0)) {
+                        newRs.setCsNormalRestricted(false);
+                }
+
+                if (mRestrictedState.isPsRestricted()
+                        && ((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) == 0)) {
+                    newRs.setPsRestricted(false);
+                }
+            }
+
+            if (DBG) log("onRestrictedStateChanged: new rs "+ newRs);
+
+            if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
+                mPsRestrictEnabledRegistrants.notifyRegistrants();
+                setNotification(PS_ENABLED);
+            } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
+                if (mPhone.isPhoneTypeGsm()) {
+                    // MTK
+                    if (mPollingContext[0] != 0) {
+                        mPendingPsRestrictDisabledNotify = true;
+                    } else {
+                        mPsRestrictDisabledRegistrants.notifyRegistrants();
+                        setNotification(PS_DISABLED);
+                    }
+                } else {
+                    // AOSP
+                    mPsRestrictDisabledRegistrants.notifyRegistrants();
+                    setNotification(PS_DISABLED);
+                }
+            }
+
+            /**
+             * There are two kind of cs restriction, normal and emergency. So
+             * there are 4 x 4 combinations in current and new restricted states
+             * and we only need to notify when state is changed.
+             */
+            if (mRestrictedState.isCsRestricted()) {
+                if (!newRs.isCsRestricted()) {
+                    // remove all restriction
+                    setNotification(CS_DISABLED);
+                } else if (!newRs.isCsNormalRestricted()) {
+                    // remove normal restriction
+                    setNotification(CS_EMERGENCY_ENABLED);
+                } else if (!newRs.isCsEmergencyRestricted()) {
+                    // remove emergency restriction
+                    setNotification(CS_NORMAL_ENABLED);
+                }
+            } else if (mRestrictedState.isCsEmergencyRestricted() &&
+                    !mRestrictedState.isCsNormalRestricted()) {
+                if (!newRs.isCsRestricted()) {
+                    // remove all restriction
+                    setNotification(CS_DISABLED);
+                } else if (newRs.isCsRestricted()) {
+                    // enable all restriction
+                    setNotification(CS_ENABLED);
+                } else if (newRs.isCsNormalRestricted()) {
+                    // remove emergency restriction and enable normal restriction
+                    setNotification(CS_NORMAL_ENABLED);
+                }
+            } else if (!mRestrictedState.isCsEmergencyRestricted() &&
+                    mRestrictedState.isCsNormalRestricted()) {
+                if (!newRs.isCsRestricted()) {
+                    // remove all restriction
+                    setNotification(CS_DISABLED);
+                } else if (newRs.isCsRestricted()) {
+                    // enable all restriction
+                    setNotification(CS_ENABLED);
+                } else if (newRs.isCsEmergencyRestricted()) {
+                    // remove normal restriction and enable emergency restriction
+                    setNotification(CS_EMERGENCY_ENABLED);
+                }
+            } else {
+                if (newRs.isCsRestricted()) {
+                    // enable all restriction
+                    setNotification(CS_ENABLED);
+                } else if (newRs.isCsEmergencyRestricted()) {
+                    // enable emergency restriction
+                    setNotification(CS_EMERGENCY_ENABLED);
+                } else if (newRs.isCsNormalRestricted()) {
+                    // enable normal restriction
+                    setNotification(CS_NORMAL_ENABLED);
+                }
+            }
+
+            mRestrictedState = newRs;
+        }
+        log("onRestrictedStateChanged: X rs "+ mRestrictedState);
+    }
+
+    /**
+     * @return the current cell location information. Prefer Gsm location
+     * information if available otherwise return LTE location information
+     */
+    public CellLocation getCellLocation() {
+        if (((GsmCellLocation)mCellLoc).getLac() >= 0 &&
+                ((GsmCellLocation)mCellLoc).getCid() >= 0) {
+            if (DBG) log("getCellLocation(): X good mCellLoc=" + mCellLoc);
+            return mCellLoc;
+        } else {
+            List<CellInfo> result = getAllCellInfo();
+            if (result != null) {
+                // A hack to allow tunneling of LTE information via GsmCellLocation
+                // so that older Network Location Providers can return some information
+                // on LTE only networks, see bug 9228974.
+                //
+                // We'll search the return CellInfo array preferring GSM/WCDMA
+                // data, but if there is none we'll tunnel the first LTE information
+                // in the list.
+                //
+                // The tunnel'd LTE information is returned as follows:
+                //   LAC = TAC field
+                //   CID = CI field
+                //   PSC = 0.
+                GsmCellLocation cellLocOther = new GsmCellLocation();
+                for (CellInfo ci : result) {
+                    if (ci instanceof CellInfoGsm) {
+                        CellInfoGsm cellInfoGsm = (CellInfoGsm)ci;
+                        CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
+                        cellLocOther.setLacAndCid(cellIdentityGsm.getLac(),
+                                cellIdentityGsm.getCid());
+                        cellLocOther.setPsc(cellIdentityGsm.getPsc());
+                        if (DBG) log("getCellLocation(): X ret GSM info=" + cellLocOther);
+                        return cellLocOther;
+                    } else if (ci instanceof CellInfoWcdma) {
+                        CellInfoWcdma cellInfoWcdma = (CellInfoWcdma)ci;
+                        CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
+                        cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(),
+                                cellIdentityWcdma.getCid());
+                        cellLocOther.setPsc(cellIdentityWcdma.getPsc());
+                        if (DBG) log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
+                        return cellLocOther;
+                    } else if ((ci instanceof CellInfoLte) &&
+                            ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
+                        // We'll return the first good LTE info we get if there is no better answer
+                        CellInfoLte cellInfoLte = (CellInfoLte)ci;
+                        CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
+                        if ((cellIdentityLte.getTac() != Integer.MAX_VALUE)
+                                && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
+                            cellLocOther.setLacAndCid(cellIdentityLte.getTac(),
+                                    cellIdentityLte.getCi());
+                            cellLocOther.setPsc(0);
+                            if (DBG) {
+                                log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
+                            }
+                        }
+                    }
+                }
+                if (DBG) {
+                    log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
+                }
+                return cellLocOther;
+            } else {
+                if (DBG) {
+                    log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
+                }
+                return mCellLoc;
+            }
+        }
+    }
+
+    /**
+     * nitzReceiveTime is time_t that the NITZ time was posted
+     */
+    private void setTimeFromNITZString (String nitz, long nitzReceiveTime) {
+        // "yy/mm/dd,hh:mm:ss(+/-)tz"
+        // tz is in number of quarter-hours
+
+        long start = SystemClock.elapsedRealtime();
+        if (DBG) {log("NITZ: " + nitz + "," + nitzReceiveTime +
+                " start=" + start + " delay=" + (start - nitzReceiveTime));
+        }
+
+        /// M: [CDMA] @{
+        if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+            if (nitz.length() <= 0) {
+                return;
+            }
+        }
+        /// @}
+
+        try {
+            /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
+             * offset as well (which we won't worry about until later) */
+            Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
+
+            c.clear();
+            c.set(Calendar.DST_OFFSET, 0);
+
+            String[] nitzSubs = nitz.split("[/:,+-]");
+
+            int year = 2000 + Integer.parseInt(nitzSubs[0]);
+            if (year > MAX_NITZ_YEAR) {
+                if (DBG) loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
+                return;
+            }
+            c.set(Calendar.YEAR, year);
+
+            // month is 0 based!
+            int month = Integer.parseInt(nitzSubs[1]) - 1;
+            c.set(Calendar.MONTH, month);
+
+            int date = Integer.parseInt(nitzSubs[2]);
+            c.set(Calendar.DATE, date);
+
+            int hour = Integer.parseInt(nitzSubs[3]);
+            c.set(Calendar.HOUR, hour);
+
+            int minute = Integer.parseInt(nitzSubs[4]);
+            c.set(Calendar.MINUTE, minute);
+
+            int second = Integer.parseInt(nitzSubs[5]);
+            c.set(Calendar.SECOND, second);
+
+            boolean sign = (nitz.indexOf('-') == -1);
+
+            int tzOffset = Integer.parseInt(nitzSubs[6]);
+
+            int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7]) : 0;
+
+            /// M: [CDMA] Save NITZ timezone ID in system propery for CDMA SMS.@{
+            if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+                final int ltmoffset = (sign ? 1 : -1) * tzOffset;
+                if (DBG) {
+                    log("[CDMA] NITZ: year = " + year + ", month = " + month + ", date = " + date
+                            + ", hour = " + hour + ", minute = " + minute + ", second = " + second
+                            + ", tzOffset = " + tzOffset + ", ltmoffset = " + ltmoffset
+                            + ", dst = " + dst);
+                }
+                TelephonyManager.setTelephonyProperty(
+                        mPhone.getPhoneId(), IPlusCodeUtils.PROPERTY_TIME_LTMOFFSET,
+                        Integer.toString(ltmoffset));
+            }
+            /// @}
+
+            //MTK-START [ALPS00540036]
+            if (mPhone.isPhoneTypeGsm()) {
+                dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7])
+                        : getDstForMcc(getMobileCountryCode(), c.getTimeInMillis());
+
+                //int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7])
+                //                                  : 0;
+            }
+            //MTK-END [ALPS00540036]
+
+            // The zone offset received from NITZ is for current local time,
+            // so DST correction is already applied.  Don't add it again.
+            //
+            // tzOffset += dst * 4;
+            //
+            // We could unapply it if we wanted the raw offset.
+
+            tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
+
+            TimeZone    zone = null;
+
+            // As a special extension, the Android emulator appends the name of
+            // the host computer's timezone to the nitz string. this is zoneinfo
+            // timezone name of the form Area!Location or Area!Location!SubLocation
+            // so we need to convert the ! into /
+            if (nitzSubs.length >= 9) {
+                String  tzname = nitzSubs[8].replace('!','/');
+                zone = TimeZone.getTimeZone( tzname );
+                log("[NITZ] setTimeFromNITZString,tzname:" + tzname + " zone:" + zone);
+            }
+
+            String iso = ((TelephonyManager) mPhone.getContext().
+                    getSystemService(Context.TELEPHONY_SERVICE)).
+                    getNetworkCountryIsoForPhone(mPhone.getPhoneId());
+            log("[NITZ] setTimeFromNITZString,mGotCountryCode:" + mGotCountryCode);
+
+            if (zone == null) {
+
+                if (mGotCountryCode) {
+                    if (iso != null && iso.length() > 0) {
+                        zone = TimeUtils.getTimeZone(tzOffset, dst != 0,
+                                c.getTimeInMillis(),
+                                iso);
+                    } else {
+                        // We don't have a valid iso country code.  This is
+                        // most likely because we're on a test network that's
+                        // using a bogus MCC (eg, "001"), so get a TimeZone
+                        // based only on the NITZ parameters.
+                        zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
+                    }
+                }
+            }
+
+            if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))){
+                // We got the time before the country or the zone has changed
+                // so we don't know how to identify the DST rules yet.  Save
+                // the information and hope to fix it up later.
+
+                mNeedFixZoneAfterNitz = true;
+                mZoneOffset  = tzOffset;
+                mZoneDst     = dst != 0;
+                mZoneTime    = c.getTimeInMillis();
+
+                //[ALPS01825832] set flag when receive NITZ
+                setReceivedNitz(mPhone.getPhoneId(), true);
+            }
+            if (DBG) {
+                log("NITZ: tzOffset=" + tzOffset + " dst=" + dst + " zone=" +
+                        (zone!=null ? zone.getID() : "NULL") +
+                        " iso=" + iso + " mGotCountryCode=" + mGotCountryCode +
+                        " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
+            }
+
+            if (zone != null) {
+                if (getAutoTimeZone()) {
+                    setAndBroadcastNetworkSetTimeZone(zone.getID());
+                }
+                saveNitzTimeZone(zone.getID());
+
+                /// M: [CDMA] Save NITZ timezone ID in system propery for CDMA SMS.@{
+                if (mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
+                    TelephonyManager.setTelephonyProperty(
+                            mPhone.getPhoneId(), IPlusCodeUtils.PROPERTY_NITZ_TIME_ZONE_ID,
+                            zone.getID());
+                }
+                /// @}
+            }
+
+            String ignore = SystemProperties.get("gsm.ignore-nitz");
+            if (ignore != null && ignore.equals("yes")) {
+                log("NITZ: Not setting clock because gsm.ignore-nitz is set");
+                return;
+            }
+
+            try {
+                mWakeLock.acquire();
+
+                if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
+                    long millisSinceNitzReceived
+                            = SystemClock.elapsedRealtime() - nitzReceiveTime;
+
+                    if (millisSinceNitzReceived < 0) {
+                        // Sanity check: something is wrong
+                        if (DBG) {
+                            log("NITZ: not setting time, clock has rolled "
+                                    + "backwards since NITZ time was received, "
+                                    + nitz);
+                        }
+                        return;
+                    }
+
+                    if (millisSinceNitzReceived > Integer.MAX_VALUE) {
+                        // If the time is this far off, something is wrong > 24 days!
+                        if (DBG) {
+                            log("NITZ: not setting time, processing has taken "
+                                    + (millisSinceNitzReceived / (1000 * 60 * 60 * 24))
+                                    + " days");
+                        }
+                        return;
+                    }
+
+                    // Note: with range checks above, cast to int is safe
+                    c.add(Calendar.MILLISECOND, (int)millisSinceNitzReceived);
+
+                    if (DBG) {
+                        log("NITZ: Setting time of day to " + c.getTime()
+                                + " NITZ receive delay(ms): " + millisSinceNitzReceived
+                                + " gained(ms): "
+                                + (c.getTimeInMillis() - System.currentTimeMillis())
+                                + " from " + nitz);
+                    }
+                    if (mPhone.isPhoneTypeGsm()) {
+                        setAndBroadcastNetworkSetTime(c.getTimeInMillis());
+                        Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
+                    } else {
+                        if (getAutoTime()) {
+                            /**
+                             * Update system time automatically
+                             */
+                            long gained = c.getTimeInMillis() - System.currentTimeMillis();
+                            long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
+                            int nitzUpdateSpacing = Settings.Global.getInt(mCr,
+                                    Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
+                            int nitzUpdateDiff = Settings.Global.getInt(mCr,
+                                    Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
+
+                            if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing)
+                                    || (Math.abs(gained) > nitzUpdateDiff)) {
+                                if (DBG) {
+                                    log("NITZ: Auto updating time of day to " + c.getTime()
+                                            + " NITZ receive delay=" + millisSinceNitzReceived
+                                            + "ms gained=" + gained + "ms from " + nitz);
+                                }
+
+                                setAndBroadcastNetworkSetTime(c.getTimeInMillis());
+                            } else {
+                                if (DBG) {
+                                    log("NITZ: ignore, a previous update was "
+                                            + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
+                                }
+                                return;
+                            }
+                        }
+                    }
+                }
+                SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
+                saveNitzTime(c.getTimeInMillis());
+                mNitzUpdatedTime = true;
+            } finally {
+                if (DBG) {
+                    long end = SystemClock.elapsedRealtime();
+                    log("NITZ: end=" + end + " dur=" + (end - start));
+                }
+                mWakeLock.release();
+            }
+        } catch (RuntimeException ex) {
+            loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
+        }
+    }
+
+
+    private boolean isAllowFixTimeZone() {
+        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
+            if (sReceiveNitz[i]) {
+                log("Phone" + i + " has received NITZ!!");
+                return false;
+            }
+        }
+        log("Fix time zone allowed");
+        return true;
+    }
+
+    private boolean getAutoTime() {
+        try {
+            return Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME) > 0;
+        } catch (Settings.SettingNotFoundException snfe) {
+            return true;
+        }
+    }
+
+    private boolean getAutoTimeZone() {
+        try {
+            return Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE) > 0;
+        } catch (Settings.SettingNotFoundException snfe) {
+            return true;
+        }
+    }
+
+    private void saveNitzTimeZone(String zoneId) {
+        log("saveNitzTimeZone zoneId:" + zoneId);
+        mSavedTimeZone = zoneId;
+    }
+
+    private void saveNitzTime(long time) {
+        if (DBG) log("saveNitzTime: time=" + time);
+        mSavedTime = time;
+        mSavedAtTime = SystemClock.elapsedRealtime();
+    }
+
+    /**
+     * Set the timezone and send out a sticky broadcast so the system can
+     * determine if the timezone was set by the carrier.
+     *
+     * @param zoneId timezone set by carrier
+     */
+    private void setAndBroadcastNetworkSetTimeZone(String zoneId) {
+        if (DBG) log("setAndBroadcastNetworkSetTimeZone: setTimeZone=" + zoneId);
+        AlarmManager alarm =
+                (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
+        alarm.setTimeZone(zoneId);
+        Intent intent = new Intent(TelephonyIntents.ACTION_NETWORK_SET_TIMEZONE);
+        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra("time-zone", zoneId);
+        mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        if (DBG) {
+            log("setAndBroadcastNetworkSetTimeZone: call alarm.setTimeZone and broadcast zoneId=" +
+                    zoneId);
+        }
+    }
+
+    /**
+     * Set the time and Send out a sticky broadcast so the system can determine
+     * if the time was set by the carrier.
+     *
+     * @param time time set by network
+     */
+    private void setAndBroadcastNetworkSetTime(long time) {
+        if (DBG) log("setAndBroadcastNetworkSetTime: time=" + time + "ms");
+        SystemClock.setCurrentTimeMillis(time);
+        Intent intent = new Intent(TelephonyIntents.ACTION_NETWORK_SET_TIME);
+        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra("time", time);
+        mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+
+        TelephonyMetrics.getInstance().writeNITZEvent(mPhone.getPhoneId(), time);
+    }
+
+    private void revertToNitzTime() {
+        if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME, 0) == 0) {
+            log("[NITZ]:revertToNitz,AUTO_TIME is 0");
+            return;
+        }
+        if (DBG) {
+            log("Reverting to NITZ Time: mSavedTime=" + mSavedTime + " mSavedAtTime=" +
+                    mSavedAtTime + " tz='" + mSavedTimeZone + "'");
+        }
+        if (mSavedTime != 0 && mSavedAtTime != 0) {
+            setAndBroadcastNetworkSetTime(mSavedTime
+                    + (SystemClock.elapsedRealtime() - mSavedAtTime));
+        }
+    }
+
+    private void revertToNitzTimeZone() {
+        if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) {
+            return;
+        }
+        // [ALPS01962013] This phone has received NITZ, so no need to do any fix
+        if (getReceivedNitz()) {
+            if (DBG) log("Reverting to NITZ TimeZone: tz='" + mSavedTimeZone);
+            if (mSavedTimeZone != null) {
+                setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
+            }
+        }
+        // [ALPS01962013] No phone has recieved NITZ, so fix it and update
+        if (isAllowFixTimeZone()) {
+            fixTimeZone();
+            if (DBG) log("Reverting to fixed TimeZone: tz='" + mSavedTimeZone);
+            if (mSavedTimeZone != null) {
+                setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
+            }
+            return;
+        }
+
+        // [ALPS01962013] This phone did't receive NITZ, but other phone did
+        if (DBG) log("Do nothing since other phone has received NITZ, but this phone didn't");
+    }
+
+    /**
+     * Post a notification to NotificationManager for restricted state
+     *
+     * @param notifyType is one state of PS/CS_*_ENABLE/DISABLE
+     */
+    private void setNotification(int notifyType) {
+    /* ALPS00339508 :Remove restricted access change notification */
+    /*
+        if (DBG) log("setNotification: create notification " + notifyType);
+
+        // Needed because sprout RIL sends these when they shouldn't?
+        boolean isSetNotification = mPhone.getContext().getResources().getBoolean(
+                com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
+        if (!isSetNotification) {
+            if (DBG) log("Ignore all the notifications");
+            return;
+        }
+
+        Context context = mPhone.getContext();
+
+
+        CharSequence details = "";
+        CharSequence title = context.getText(com.android.internal.R.string.RestrictedOnData);
+        int notificationId = CS_NOTIFICATION;
+
+        switch (notifyType) {
+            case PS_ENABLED:
+                long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+                if (dataSubId != mPhone.getSubId()) {
+                    return;
+                }
+                notificationId = PS_NOTIFICATION;
+                details = context.getText(com.android.internal.R.string.RestrictedOnData);
+                break;
+            case PS_DISABLED:
+                notificationId = PS_NOTIFICATION;
+                break;
+            case CS_ENABLED:
+                details = context.getText(com.android.internal.R.string.RestrictedOnAllVoice);
+                break;
+            case CS_NORMAL_ENABLED:
+                details = context.getText(com.android.internal.R.string.RestrictedOnNormal);
+                break;
+            case CS_EMERGENCY_ENABLED:
+                details = context.getText(com.android.internal.R.string.RestrictedOnEmergency);
+                break;
+            case CS_DISABLED:
+                // do nothing and cancel the notification later
+                break;
+        }
+
+        if (DBG) log("setNotification: put notification " + title + " / " +details);
+        mNotification = new Notification.Builder(context)
+                .setWhen(System.currentTimeMillis())
+                .setAutoCancel(true)
+                .setSmallIcon(com.android.internal.R.drawable.stat_sys_warning)
+                .setTicker(title)
+                .setColor(context.getResources().getColor(
+                        com.android.internal.R.color.system_notification_accent_color))
+                .setContentTitle(title)
+                .setContentText(details)
+                .build();
+
+        NotificationManager notificationManager = (NotificationManager)
+                context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
+            // cancel previous post notification
+            notificationManager.cancel(notificationId);
+        } else {
+            // update restricted state notification
+            notificationManager.notify(notificationId, mNotification);
+        }
+    */
+    }
+
+    private UiccCardApplication getUiccCardApplication() {
+        if (mPhone.isPhoneTypeGsm()) {
+            return mUiccController.getUiccCardApplication(mPhone.getPhoneId(),
+                    UiccController.APP_FAM_3GPP);
+        } else {
+            return mUiccController.getUiccCardApplication(mPhone.getPhoneId(),
+                    UiccController.APP_FAM_3GPP2);
+        }
+    }
+
+    private void queueNextSignalStrengthPoll() {
+        if (mDontPollSignalStrength) {
+            // The radio is telling us about signal strength changes
+            // we don't have to ask it
+            return;
+        }
+
+        Message msg;
+
+        msg = obtainMessage();
+        msg.what = EVENT_POLL_SIGNAL_STRENGTH;
+
+        long nextTime;
+
+        // TODO Don't poll signal strength if screen is off
+        sendMessageDelayed(msg, POLL_PERIOD_MILLIS);
+    }
+
+    private void notifyCdmaSubscriptionInfoReady() {
+        if (mCdmaForSubscriptionInfoReadyRegistrants != null) {
+            if (DBG) log("CDMA_SUBSCRIPTION: call notifyRegistrants()");
+            mCdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
+        }
+    }
+
+    /**
+     * Registration point for transition into DataConnection attached.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataConnectionAttached(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mAttachedRegistrants.add(r);
+
+        if (getCurrentDataConnectionState() == ServiceState.STATE_IN_SERVICE) {
+            r.notifyRegistrant();
+        }
+    }
+    public void unregisterForDataConnectionAttached(Handler h) {
+        mAttachedRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for transition into DataConnection detached.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataConnectionDetached(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDetachedRegistrants.add(r);
+
+        if (getCurrentDataConnectionState() != ServiceState.STATE_IN_SERVICE) {
+            r.notifyRegistrant();
+        }
+    }
+    public void unregisterForDataConnectionDetached(Handler h) {
+        mDetachedRegistrants.remove(h);
+    }
+
+    /**
+     * Registration for DataConnection RIL Data Radio Technology changing. The
+     * new radio technology will be returned AsyncResult#result as an Integer Object.
+     * The AsyncResult will be in the notification Message#obj.
+     *
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForDataRegStateOrRatChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataRegStateOrRatChangedRegistrants.add(r);
+        notifyDataRegStateRilRadioTechnologyChanged();
+    }
+    public void unregisterForDataRegStateOrRatChanged(Handler h) {
+        mDataRegStateOrRatChangedRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for transition into network attached.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj in Message.obj
+     */
+    public void registerForNetworkAttached(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mNetworkAttachedRegistrants.add(r);
+        if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+            r.notifyRegistrant();
+        }
+    }
+    public void unregisterForNetworkAttached(Handler h) {
+        mNetworkAttachedRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for transition into packet service restricted zone.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForPsRestrictedEnabled(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPsRestrictEnabledRegistrants.add(r);
+
+        if (mRestrictedState.isPsRestricted()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForPsRestrictedEnabled(Handler h) {
+        mPsRestrictEnabledRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for transition out of packet service restricted zone.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForPsRestrictedDisabled(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPsRestrictDisabledRegistrants.add(r);
+
+        if (mRestrictedState.isPsRestricted()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForPsRestrictedDisabled(Handler h) {
+        mPsRestrictDisabledRegistrants.remove(h);
+    }
+
+    /**
+     * Registration point for signal strength changed.
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForSignalStrengthChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSignalStrengthChangedRegistrants.add(r);
+    }
+
+    /**
+     * Unregister registration point for signal strength changed.
+     * @param h handler to notify
+    */
+    public void unregisterForSignalStrengthChanged(Handler h) {
+        mSignalStrengthChangedRegistrants.remove(h);
+    }
+
+
+    /**
+     * Clean up existing voice and data connection then turn off radio power.
+     *
+     * Hang up the existing voice calls to decrease call drop rate.
+     */
+    public void powerOffRadioSafely(DcTracker dcTracker) {
+        synchronized (this) {
+            if (!mPendingRadioPowerOffAfterDataOff) {
+                if (mPhone.isPhoneTypeGsm() || mPhone.isPhoneTypeCdmaLte()) {
+                    int dds = SubscriptionManager.getDefaultDataSubscriptionId();
+                    int phoneSubId = mPhone.getSubId();
+                    // To minimize race conditions we call cleanUpAllConnections on
+                    // both if else paths instead of before this isDisconnected test.
+                    log("powerOffRadioSafely phoneId=" + SubscriptionManager.getPhoneId(dds)
+                            + ", dds=" + dds + ", mPhone.getSubId()=" + mPhone.getSubId()
+                            + ", phoneSubId=" + phoneSubId);
+                    if (dds != SubscriptionManager.INVALID_SUBSCRIPTION_ID
+                            && (dcTracker.isDisconnected() || dds != phoneSubId)) {
+                        // M: remove check peer phone data state
+                        // To minimize race conditions we do this after isDisconnected
+                        dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
+                        if (DBG) log("Data disconnected, turn off radio right away.");
+                        hangupAndPowerOff();
+                    } else if (!mPhone.isPhoneTypeGsm()
+                            && (dcTracker.isDisconnected()
+                                && (dds == mPhone.getSubId()
+                                || (dds != mPhone.getSubId()
+                                && ProxyController.getInstance().isDataDisconnected(dds))))) {
+                        // To minimize race conditions we do this after isDisconnected
+                        dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
+                        if (DBG) log("Data disconnected, turn off radio right away.");
+                        hangupAndPowerOff();
+                    } else {
+                        // hang up all active voice calls first
+                        if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
+                            mPhone.mCT.mRingingCall.hangupIfAlive();
+                            mPhone.mCT.mBackgroundCall.hangupIfAlive();
+                            mPhone.mCT.mForegroundCall.hangupIfAlive();
+                        }
+                        dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
+
+                        if (mPhone.isPhoneTypeGsm()) {
+                            if (dds == SubscriptionManager.INVALID_SUBSCRIPTION_ID
+                                    || SubscriptionManager.getPhoneId(dds)
+                                    == SubscriptionManager.DEFAULT_PHONE_INDEX) {
+                                if (dcTracker.isDisconnected()
+                                        || dcTracker.isOnlyIMSorEIMSPdnConnected()) {
+                                    if (DBG) log("Data disconnected (no data sub), " +
+                                            "turn off radio right away.");
+                                    hangupAndPowerOff();
+                                    return;
+                                } else {
+                                    if (DBG) {
+                                        log("Data is active on.  Wait for all data disconnect");
+                                    }
+                                    mPhone.registerForAllDataDisconnected(this,
+                                            EVENT_ALL_DATA_DISCONNECTED, null);
+                                    mPendingRadioPowerOffAfterDataOff = true;
+                                }
+                            }
+                        } else {
+                            if (dds != mPhone.getSubId()
+                                    && !ProxyController.getInstance().isDataDisconnected(dds)) {
+                                if (DBG) log("Data is active on DDS. "
+                                        + "Wait for all data disconnect");
+                                // Data is not disconnected on DDS.
+                                // Wait for the data disconnect complete
+                                // before sending the RADIO_POWER off.
+                                ProxyController.getInstance().registerForAllDataDisconnected(
+                                        dds, this,
+                                        EVENT_ALL_DATA_DISCONNECTED, null);
+                                mPendingRadioPowerOffAfterDataOff = true;
+                            }
+                        }
+
+                        if (dcTracker.isOnlyIMSorEIMSPdnConnected()) {
+                            if (DBG) {
+                                log("Only IMS or EIMS connected, " +
+                                        "turn off radio right away.");
+                            }
+                            hangupAndPowerOff();
+                            return;
+                        }
+
+                        Message msg = Message.obtain(this);
+                        msg.what = EVENT_SET_RADIO_POWER_OFF;
+                        msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
+                        if (sendMessageDelayed(msg, 5000)) {
+                            if (DBG) {
+                                log("Wait upto 5s for data to disconnect, then turn off radio.");
+                            }
+                            mPendingRadioPowerOffAfterDataOff = true;
+                        } else {
+                            log("Cannot send delayed Msg, turn off radio right away.");
+                            hangupAndPowerOff();
+                            mPendingRadioPowerOffAfterDataOff = false;
+                        }
+                    }
+                } else {
+                    // In some network, deactivate PDP connection cause releasing of RRC connection,
+                    // which MM/IMSI detaching request needs. Without this detaching, network can
+                    // not release the network resources previously attached.
+                    // So we are avoiding data detaching on these networks.
+                    String[] networkNotClearData = mPhone.getContext().getResources()
+                            .getStringArray(com.android.internal.R.array.networks_not_clear_data);
+                    String currentNetwork = mSS.getOperatorNumeric();
+                    if ((networkNotClearData != null) && (currentNetwork != null)) {
+                        for (int i = 0; i < networkNotClearData.length; i++) {
+                            if (currentNetwork.equals(networkNotClearData[i])) {
+                                // Don't clear data connection for this carrier
+                                if (DBG)
+                                    log("Not disconnecting data for " + currentNetwork);
+                                hangupAndPowerOff();
+                                return;
+                            }
+                        }
+                    }
+                    // To minimize race conditions we call cleanUpAllConnections on
+                    // both if else paths instead of before this isDisconnected test.
+                    if (dcTracker.isDisconnected()) {
+                        // To minimize race conditions we do this after isDisconnected
+                        dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
+                        if (DBG) log("Data disconnected, turn off radio right away.");
+                        hangupAndPowerOff();
+                    } else {
+                        dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
+                        Message msg = Message.obtain(this);
+                        msg.what = EVENT_SET_RADIO_POWER_OFF;
+                        msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
+                        if (sendMessageDelayed(msg, 30000)) {
+                            if (DBG)
+                                log("Wait upto 30s for data to disconnect, then turn off radio.");
+                            mPendingRadioPowerOffAfterDataOff = true;
+                        } else {
+                            log("Cannot send delayed Msg, turn off radio right away.");
+                            hangupAndPowerOff();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * process the pending request to turn radio off after data is disconnected
+     *
+     * return true if there is pending request to process; false otherwise.
+     */
+    public boolean processPendingRadioPowerOffAfterDataOff() {
+        synchronized(this) {
+            if (mPendingRadioPowerOffAfterDataOff) {
+                if (DBG) log("Process pending request to turn radio off.");
+                mPendingRadioPowerOffAfterDataOffTag += 1;
+                hangupAndPowerOff();
+                mPendingRadioPowerOffAfterDataOff = false;
+                return true;
+            }
+            return false;
+        }
+    }
+
+    /**
+     * send signal-strength-changed notification if changed Called both for
+     * solicited and unsolicited signal strength updates
+     *
+     * @return true if the signal strength changed and a notification was sent.
+     */
+    protected boolean onSignalStrengthResult(AsyncResult ar) {
+        boolean isGsm = false;
+        //override isGsm for CDMA LTE
+        if (mPhone.isPhoneTypeGsm() ||
+                (mPhone.isPhoneTypeCdmaLte() &&
+                        ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
+            isGsm = true;
+        }
+
+        // This signal is used for both voice and data radio signal so parse
+        // all fields
+
+        if ((ar.exception == null) && (ar.result != null)) {
+            mSignalStrength = (SignalStrength) ar.result;
+            mSignalStrength.validateInput();
+            mSignalStrength.setGsm(isGsm);
+            if (DBG) {
+                log("onSignalStrengthResult():" +
+                        ((mLastSignalStrength != null) ? ("LastSignalStrength="
+                        + mLastSignalStrength.toString()) : "") +
+                        "new mSignalStrength="
+                        + mSignalStrength.toString());
+            }
+        } else {
+            log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
+            mSignalStrength = new SignalStrength(isGsm);
+        }
+
+        boolean ssChanged = notifySignalStrength();
+
+        return ssChanged;
+    }
+
+    /**
+     * Hang up all voice call and turn off radio. Implemented by derived class.
+     */
+    protected void hangupAndPowerOff() {
+        // hang up all active voice calls
+        if (!mPhone.isPhoneTypeGsm() || mPhone.isInCall()) {
+            mPhone.mCT.mRingingCall.hangupIfAlive();
+            mPhone.mCT.mBackgroundCall.hangupIfAlive();
+            mPhone.mCT.mForegroundCall.hangupIfAlive();
+        }
+        //MTK-START some actions must be took before EFUN
+        RadioManager.getInstance().sendRequestBeforeSetRadioPower(false, mPhone.getPhoneId());
+        //MTK-END
+        if (RadioManager.getInstance().isAirplaneMode()) {
+            mCi.setRadioPowerEnhance(false, null);
+        } else {
+            mCi.setRadioPower(false, null);
+        }
+
+    }
+
+    /** Cancel a pending (if any) pollState() operation */
+    protected void cancelPollState() {
+        // This will effectively cancel the rest of the poll requests.
+        mPollingContext = new int[1];
+    }
+
+    /**
+     * Return true if time zone needs fixing.
+     *
+     * @param phone
+     * @param operatorNumeric
+     * @param prevOperatorNumeric
+     * @param needToFixTimeZone
+     * @return true if time zone needs to be fixed
+     */
+    protected boolean shouldFixTimeZoneNow(Phone phone, String operatorNumeric,
+            String prevOperatorNumeric, boolean needToFixTimeZone) {
+        // Return false if the mcc isn't valid as we don't know where we are.
+        // Return true if we have an IccCard and the mcc changed or we
+        // need to fix it because when the NITZ time came in we didn't
+        // know the country code.
+
+        // If mcc is invalid then we'll return false
+        int mcc;
+        try {
+            mcc = Integer.parseInt(operatorNumeric.substring(0, 3));
+        } catch (Exception e) {
+            if (DBG) {
+                log("shouldFixTimeZoneNow: no mcc, operatorNumeric=" + operatorNumeric +
+                        " retVal=false");
+            }
+            return false;
+        }
+
+        // If prevMcc is invalid will make it different from mcc
+        // so we'll return true if the card exists.
+        int prevMcc;
+        try {
+            prevMcc = Integer.parseInt(prevOperatorNumeric.substring(0, 3));
+        } catch (Exception e) {
+            prevMcc = mcc + 1;
+        }
+
+        // Determine if the Icc card exists
+        boolean iccCardExist = false;
+        if (mUiccApplcation != null) {
+            iccCardExist = mUiccApplcation.getState() != AppState.APPSTATE_UNKNOWN;
+        }
+
+        // Determine retVal
+        boolean retVal = ((iccCardExist && (mcc != prevMcc)) || needToFixTimeZone);
+        if (DBG) {
+            long ctm = System.currentTimeMillis();
+            log("shouldFixTimeZoneNow: retVal=" + retVal +
+                    " iccCardExist=" + iccCardExist +
+                    " operatorNumeric=" + operatorNumeric + " mcc=" + mcc +
+                    " prevOperatorNumeric=" + prevOperatorNumeric + " prevMcc=" + prevMcc +
+                    " needToFixTimeZone=" + needToFixTimeZone +
+                    " ltod=" + TimeUtils.logTimeOfDay(ctm));
+        }
+        return retVal;
+    }
+
+    public String getSystemProperty(String property, String defValue) {
+        return TelephonyManager.getTelephonyProperty(mPhone.getPhoneId(), property, defValue);
+    }
+
+    /**
+     * @return all available cell information or null if none.
+     */
+    public List<CellInfo> getAllCellInfo() {
+        CellInfoResult result = new CellInfoResult();
+        // if (DBG) log("SST.getAllCellInfo(): E");
+        String mLog = "SST.getAllCellInfo(): ";
+        int ver = mCi.getRilVersion();
+        if (ver >= 8) {
+            if (isCallerOnDifferentThread()) {
+                if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime)
+                        > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
+                    Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST, result);
+                    synchronized(result.lockObj) {
+                        result.list = null;
+                        mCi.getCellInfoList(msg);
+                        try {
+                            result.lockObj.wait(5000);
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                } else {
+                    // if (DBG) log("SST.getAllCellInfo(): return last, back to back calls");
+                    mLog = mLog + "return last, back to back calls. ";
+                    result.list = mLastCellInfoList;
+                }
+            } else {
+                // if (DBG) log("SST.getAllCellInfo(): return last, same thread can't block");
+                mLog = mLog + "return last, same thread can't block. ";
+                result.list = mLastCellInfoList;
+            }
+        } else {
+            // if (DBG) log("SST.getAllCellInfo(): not implemented");
+            mLog = mLog + "not implemented. ";
+            result.list = null;
+        }
+        synchronized(result.lockObj) {
+            if (result.list != null) {
+                if (VDBG) log(mLog + "X size=" + result.list.size()
+                        + " list=" + result.list);
+                return result.list;
+            } else {
+                mLog = mLog + "X size=0 list=null.";
+                if (DBG) log(mLog);
+                return null;
+            }
+        }
+    }
+
+    //M: MTK START Common
+    protected List<CellInfo> getAllCellInfoByRate() {
+        CellInfoResult result = new CellInfoResult();
+        if (DBG) {
+            log("SST.getAllCellInfoByRate(): enter");
+        }
+        int ver = mCi.getRilVersion();
+        if (ver >= 8) {
+            if (isCallerOnDifferentThread()) {
+                if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime)
+                        > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
+                    Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST_BY_RATE, result);
+                    synchronized (result.lockObj) {
+                        mCi.getCellInfoList(msg);
+                        try {
+                            result.lockObj.wait();
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                            result.list = null;
+                        }
+                    }
+                } else {
+                    if (DBG) {
+                        log("SST.getAllCellInfoByRate(): return last, back to back calls");
+                    }
+                    result.list = mLastCellInfoList;
+                }
+            } else {
+                if (DBG) {
+                    log("SST.getAllCellInfoByRate(): return last, same thread can't block");
+                }
+                result.list = mLastCellInfoList;
+            }
+        } else {
+            if (DBG) log("SST.getAllCellInfoByRate(): not implemented");
+            result.list = null;
+        }
+        if (DBG) {
+            if (result.list != null) {
+                log("SST.getAllCellInfoByRate(): X size=" + result.list.size()
+                    + " list=" + result.list);
+            } else {
+                log("SST.getAllCellInfoByRate(): X size=0 list=null");
+            }
+        }
+        return result.list;
+    }
+
+    public void setCellInfoRate(int rateInMillis) {
+        log("SST.setCellInfoRate()");
+        mCellInfoRate = rateInMillis;
+        updateCellInfoRate();
+    }
+
+    protected void updateCellInfoRate() {
+        log("SST.updateCellInfoRate()");
+        if (mPhone.isPhoneTypeGsm()) {
+            log("updateCellInfoRate(),mCellInfoRate= " + mCellInfoRate);
+            if ((mCellInfoRate != Integer.MAX_VALUE) && (mCellInfoRate != 0)) {
+                if (mCellInfoTimer != null) {
+                    log("cancel previous timer if any");
+                    mCellInfoTimer.cancel();
+                    mCellInfoTimer = null;
+                }
+
+                mCellInfoTimer = new Timer(true);
+
+                log("schedule timer with period = " + mCellInfoRate + " ms");
+                mCellInfoTimer.schedule(new timerTask(), mCellInfoRate);
+            } else if ((mCellInfoRate == 0) || (mCellInfoRate == Integer.MAX_VALUE)) {
+                if (mCellInfoTimer != null) {
+                    log("cancel cell info timer if any");
+                    mCellInfoTimer.cancel();
+                    mCellInfoTimer = null;
+                }
+            }
+        }
+    }
+    // M: MTK END
+
+    /**
+     * @return signal strength
+     */
+    public SignalStrength getSignalStrength() {
+        return mSignalStrength;
+    }
+
+    /**
+     * Registration point for subscription info ready
+     * @param h handler to notify
+     * @param what what code of message when delivered
+     * @param obj placed in Message.obj
+     */
+    public void registerForSubscriptionInfoReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCdmaForSubscriptionInfoReadyRegistrants.add(r);
+
+        if (isMinInfoReady()) {
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForSubscriptionInfoReady(Handler h) {
+        mCdmaForSubscriptionInfoReadyRegistrants.remove(h);
+    }
+
+    /**
+     * Save current source of cdma subscription
+     * @param source - 1 for NV, 0 for RUIM
+     */
+    private void saveCdmaSubscriptionSource(int source) {
+        logd("Storing cdma subscription source: " + source);
+        Settings.Global.putInt(mPhone.getContext().getContentResolver(),
+                Settings.Global.CDMA_SUBSCRIPTION_MODE,
+                source);
+        logd("Read from settings: " + Settings.Global.getInt(mPhone.getContext().getContentResolver(),
+                Settings.Global.CDMA_SUBSCRIPTION_MODE, -1));
+    }
+
+    private void getSubscriptionInfoAndStartPollingThreads() {
+        mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
+
+        // Get Registration Information
+        pollState();
+    }
+
+    private void handleCdmaSubscriptionSource(int newSubscriptionSource) {
+        log("Subscription Source : " + newSubscriptionSource);
+        mIsSubscriptionFromRuim =
+                (newSubscriptionSource == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
+        logd("isFromRuim: " + mIsSubscriptionFromRuim);
+        saveCdmaSubscriptionSource(newSubscriptionSource);
+        if (!mIsSubscriptionFromRuim) {
+            // NV is ready when subscription source is NV
+            sendMessage(obtainMessage(EVENT_NV_READY));
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("ServiceStateTracker:");
+        pw.println(" mSubId=" + mSubId);
+        pw.println(" mSS=" + mSS);
+        pw.println(" mNewSS=" + mNewSS);
+        pw.println(" mVoiceCapable=" + mVoiceCapable);
+        pw.println(" mRestrictedState=" + mRestrictedState);
+        pw.println(" mPollingContext=" + mPollingContext + " - " +
+                (mPollingContext != null ? mPollingContext[0] : ""));
+        pw.println(" mDesiredPowerState=" + mDesiredPowerState);
+        pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
+        pw.println(" mSignalStrength=" + mSignalStrength);
+        pw.println(" mLastSignalStrength=" + mLastSignalStrength);
+        pw.println(" mRestrictedState=" + mRestrictedState);
+        pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
+        pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
+        pw.println(" mCellLoc=" + mCellLoc);
+        pw.println(" mNewCellLoc=" + mNewCellLoc);
+        pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
+        pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
+        pw.println(" mMaxDataCalls=" + mMaxDataCalls);
+        pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
+        pw.println(" mReasonDataDenied=" + mReasonDataDenied);
+        pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
+        pw.println(" mGsmRoaming=" + mGsmRoaming);
+        pw.println(" mDataRoaming=" + mDataRoaming);
+        pw.println(" mEmergencyOnly=" + mEmergencyOnly);
+        pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
+        pw.flush();
+        pw.println(" mZoneOffset=" + mZoneOffset);
+        pw.println(" mZoneDst=" + mZoneDst);
+        pw.println(" mZoneTime=" + mZoneTime);
+        pw.println(" mGotCountryCode=" + mGotCountryCode);
+        pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
+        pw.println(" mSavedTimeZone=" + mSavedTimeZone);
+        pw.println(" mSavedTime=" + mSavedTime);
+        pw.println(" mSavedAtTime=" + mSavedAtTime);
+        pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
+        pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
+        pw.println(" mNotification=" + mNotification);
+        pw.println(" mWakeLock=" + mWakeLock);
+        pw.println(" mCurSpn=" + mCurSpn);
+        pw.println(" mCurDataSpn=" + mCurDataSpn);
+        pw.println(" mCurShowSpn=" + mCurShowSpn);
+        pw.println(" mCurPlmn=" + mCurPlmn);
+        pw.println(" mCurShowPlmn=" + mCurShowPlmn);
+        pw.flush();
+        pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
+        pw.println(" mRoamingIndicator=" + mRoamingIndicator);
+        pw.println(" mIsInPrl=" + mIsInPrl);
+        pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
+        pw.println(" mRegistrationState=" + mRegistrationState);
+        pw.println(" mMdn=" + mMdn);
+        pw.println(" mHomeSystemId=" + mHomeSystemId);
+        pw.println(" mHomeNetworkId=" + mHomeNetworkId);
+        pw.println(" mMin=" + mMin);
+        pw.println(" mPrlVersion=" + mPrlVersion);
+        pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
+        pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
+        pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
+        pw.println(" mCdmaSSM=" + mCdmaSSM);
+        pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
+        pw.println(" mCurrentCarrier=" + mCurrentCarrier);
+        pw.flush();
+        pw.println(" mImsRegistered=" + mImsRegistered);
+        pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
+        pw.println(" mAlarmSwitch=" + mAlarmSwitch);
+        pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
+        pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
+        pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
+        pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
+
+        pw.println(" Roaming Log:");
+        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
+        ipw.increaseIndent();
+        mRoamingLog.dump(fd, ipw, args);
+        ipw.decreaseIndent();
+
+        ipw.println(" Attach Log:");
+        ipw.increaseIndent();
+        mAttachLog.dump(fd, ipw, args);
+        ipw.decreaseIndent();
+
+        ipw.println(" Phone Change Log:");
+        ipw.increaseIndent();
+        mPhoneTypeLog.dump(fd, ipw, args);
+        ipw.decreaseIndent();
+
+        ipw.println(" Rat Change Log:");
+        ipw.increaseIndent();
+        mRatLog.dump(fd, ipw, args);
+        ipw.decreaseIndent();
+    }
+
+    public boolean isImsRegistered() {
+        return mImsRegistered;
+    }
+    /**
+     * Verifies the current thread is the same as the thread originally
+     * used in the initialization of this instance. Throws RuntimeException
+     * if not.
+     *
+     * @exception RuntimeException if the current thread is not
+     * the thread that originally obtained this Phone instance.
+     */
+    protected void checkCorrectThread() {
+        if (Thread.currentThread() != getLooper().getThread()) {
+            throw new RuntimeException(
+                    "ServiceStateTracker must be used from within one thread");
+        }
+    }
+
+    protected boolean isCallerOnDifferentThread() {
+        boolean value = Thread.currentThread() != getLooper().getThread();
+        if (VDBG) log("isCallerOnDifferentThread: " + value);
+        return value;
+    }
+
+    protected void updateCarrierMccMncConfiguration(String newOp, String oldOp, Context context) {
+        // if we have a change in operator, notify wifi (even to/from none)
+        if (((newOp == null) && (TextUtils.isEmpty(oldOp) == false)) ||
+                ((newOp != null) && (newOp.equals(oldOp) == false))) {
+            logd("update mccmnc=" + newOp + " fromServiceState=true");
+            MccTable.updateMccMncConfiguration(context, newOp, true);
+        }
+    }
+
+    /**
+     * Check ISO country by MCC to see if phone is roaming in same registered country
+     */
+    protected boolean inSameCountry(String operatorNumeric) {
+        if (TextUtils.isEmpty(operatorNumeric) || (operatorNumeric.length() < 5)) {
+            // Not a valid network
+            return false;
+        }
+        final String homeNumeric = getHomeOperatorNumeric();
+        if (TextUtils.isEmpty(homeNumeric) || (homeNumeric.length() < 5)) {
+            // Not a valid SIM MCC
+            return false;
+        }
+        boolean inSameCountry = true;
+        final String networkMCC = operatorNumeric.substring(0, 3);
+        final String homeMCC = homeNumeric.substring(0, 3);
+        final String networkCountry = MccTable.countryCodeForMcc(Integer.parseInt(networkMCC));
+        final String homeCountry = MccTable.countryCodeForMcc(Integer.parseInt(homeMCC));
+        if (networkCountry.isEmpty() || homeCountry.isEmpty()) {
+            // Not a valid country
+            return false;
+        }
+        inSameCountry = homeCountry.equals(networkCountry);
+        if (inSameCountry) {
+            return inSameCountry;
+        }
+        // special same country cases
+        if ("us".equals(homeCountry) && "vi".equals(networkCountry)) {
+            inSameCountry = true;
+        } else if ("vi".equals(homeCountry) && "us".equals(networkCountry)) {
+            inSameCountry = true;
+        }
+        return inSameCountry;
+    }
+
+    /**
+     * Set both voice and data roaming type,
+     * judging from the ISO country of SIM VS network.
+     */
+    protected void setRoamingType(ServiceState currentServiceState) {
+        final boolean isVoiceInService =
+                (currentServiceState.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
+        boolean isInternationalRoaming = false;
+        if (isVoiceInService) {
+            if (currentServiceState.getVoiceRoaming()) {
+                if (mPhone.isPhoneTypeGsm()) {
+                    // check roaming type by MCC
+                    if (inSameCountry(currentServiceState.getVoiceOperatorNumeric())) {
+                        currentServiceState.setVoiceRoamingType(
+                                ServiceState.ROAMING_TYPE_DOMESTIC);
+                    } else {
+                        currentServiceState.setVoiceRoamingType(
+                                ServiceState.ROAMING_TYPE_INTERNATIONAL);
+                    }
+
+                    // check operator specified international roaming
+                    try {
+                        isInternationalRoaming =
+                                mServiceStateExt.operatorDefinedInternationalRoaming(
+                                        currentServiceState.getVoiceOperatorNumeric());
+                    } catch (RuntimeException e) {
+                        e.printStackTrace();
+                    }
+
+                    if (isInternationalRoaming) {
+                        log(currentServiceState.getVoiceOperatorNumeric()
+                                + " is in operator defined international roaming list");
+                        currentServiceState.setVoiceRoamingType(
+                                ServiceState.ROAMING_TYPE_INTERNATIONAL);
+                    }
+                } else {
+                    // some carrier defines international roaming by indicator
+                    int[] intRoamingIndicators = mPhone.getContext().getResources().getIntArray(
+                            com.android.internal.R.array.config_cdma_international_roaming_indicators);
+                    if ((intRoamingIndicators != null) && (intRoamingIndicators.length > 0)) {
+                        // It's domestic roaming at least now
+                        currentServiceState.setVoiceRoamingType(ServiceState.ROAMING_TYPE_DOMESTIC);
+                        int curRoamingIndicator = currentServiceState.getCdmaRoamingIndicator();
+                        for (int i = 0; i < intRoamingIndicators.length; i++) {
+                            if (curRoamingIndicator == intRoamingIndicators[i]) {
+                                currentServiceState.setVoiceRoamingType(
+                                        ServiceState.ROAMING_TYPE_INTERNATIONAL);
+                                break;
+                            }
+                        }
+                    } else {
+                        // check roaming type by MCC
+                        if (inSameCountry(currentServiceState.getVoiceOperatorNumeric())) {
+                            currentServiceState.setVoiceRoamingType(
+                                    ServiceState.ROAMING_TYPE_DOMESTIC);
+                        } else {
+                            currentServiceState.setVoiceRoamingType(
+                                    ServiceState.ROAMING_TYPE_INTERNATIONAL);
+                        }
+                    }
+                }
+            } else {
+                currentServiceState.setVoiceRoamingType(ServiceState.ROAMING_TYPE_NOT_ROAMING);
+            }
+        }
+        final boolean isDataInService =
+                (currentServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE);
+        final int dataRegType = currentServiceState.getRilDataRadioTechnology();
+        if (isDataInService) {
+            if (!currentServiceState.getDataRoaming()) {
+                currentServiceState.setDataRoamingType(ServiceState.ROAMING_TYPE_NOT_ROAMING);
+            } else {
+                if (mPhone.isPhoneTypeGsm()) {
+                    if (ServiceState.isGsm(dataRegType)) {
+                        if (isVoiceInService) {
+                            // GSM data should have the same state as voice
+                            currentServiceState.setDataRoamingType(currentServiceState
+                                    .getVoiceRoamingType());
+                        } else {
+                            // we can not decide GSM data roaming type without voice
+                            currentServiceState.setDataRoamingType(ServiceState.ROAMING_TYPE_UNKNOWN);
+                        }
+                    } else {
+                        // we can not decide 3gpp2 roaming state here
+                        currentServiceState.setDataRoamingType(ServiceState.ROAMING_TYPE_UNKNOWN);
+                    }
+                } else {
+                    if (ServiceState.isCdma(dataRegType)) {
+                        if (isVoiceInService) {
+                            // CDMA data should have the same state as voice
+                            currentServiceState.setDataRoamingType(currentServiceState
+                                    .getVoiceRoamingType());
+                        } else {
+                            // we can not decide CDMA data roaming type without voice
+                            // set it as same as last time
+                            currentServiceState.setDataRoamingType(ServiceState.ROAMING_TYPE_UNKNOWN);
+                        }
+                    } else {
+                        // take it as 3GPP roaming
+                        if (inSameCountry(currentServiceState.getDataOperatorNumeric())) {
+                            currentServiceState.setDataRoamingType(ServiceState.ROAMING_TYPE_DOMESTIC);
+                        } else {
+                            currentServiceState.setDataRoamingType(
+                                    ServiceState.ROAMING_TYPE_INTERNATIONAL);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void setSignalStrengthDefaultValues() {
+        mSignalStrength = new SignalStrength(true);
+    }
+
+    private void setNullState() {
+        mGsmRoaming = false;
+        mNewReasonDataDenied = -1;
+        mNewMaxDataCalls = 1;
+        mDataRoaming = false;
+        //[ALPS00423362]
+        mEmergencyOnly = false;
+        updateLocatedPlmn(null);
+        //[ALPS00439473] MTK add - START
+        mDontPollSignalStrength = false;
+        mLastSignalStrength = new SignalStrength(true);
+        //[ALPS00439473] MTK add - END
+        //MTK-ADD : for CS not registered , PS regsitered (ex: LTE PS only mode or 2/3G PS only SIM
+        //card or CS domain network registeration temporary failure
+        isCsInvalidCard = false;
+        //MTK-ADD: ALPS01830723
+        mPsRegState = ServiceState.STATE_OUT_OF_SERVICE;
+    }
+
+    protected String getHomeOperatorNumeric() {
+        String numeric = ((TelephonyManager) mPhone.getContext().
+                getSystemService(Context.TELEPHONY_SERVICE)).
+                getSimOperatorNumericForPhone(mPhone.getPhoneId());
+        if (!mPhone.isPhoneTypeGsm() && TextUtils.isEmpty(numeric)) {
+            numeric = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "");
+        }
+        return numeric;
+    }
+
+    protected int getPhoneId() {
+        return mPhone.getPhoneId();
+    }
+
+    /* Reset Service state when IWLAN is enabled as polling in airplane mode
+     * causes state to go to OUT_OF_SERVICE state instead of STATE_OFF
+     */
+    protected void resetServiceStateInIwlanMode() {
+        if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
+            boolean resetIwlanRatVal = false;
+            log("set service state as POWER_OFF");
+            if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN
+                        == mNewSS.getRilDataRadioTechnology()) {
+                log("pollStateDone: mNewSS = " + mNewSS);
+                log("pollStateDone: reset iwlan RAT value");
+                resetIwlanRatVal = true;
+            }
+            // operator info should be kept in SS
+            String operator = mNewSS.getOperatorAlphaLong();
+            mNewSS.setStateOff();
+            if (resetIwlanRatVal) {
+                mNewSS.setRilDataRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN);
+                mNewSS.setDataRegState(ServiceState.STATE_IN_SERVICE);
+                mNewSS.setOperatorAlphaLong(operator);
+                log("pollStateDone: mNewSS = " + mNewSS);
+            }
+        }
+    }
+
+    /**
+     * Check if device is non-roaming and always on home network.
+     *
+     * @param b carrier config bundle obtained from CarrierConfigManager
+     * @return true if network is always on home network, false otherwise
+     * @see CarrierConfigManager
+     */
+    protected final boolean alwaysOnHomeNetwork(BaseBundle b) {
+        return b.getBoolean(CarrierConfigManager.KEY_FORCE_HOME_NETWORK_BOOL);
+    }
+
+    /**
+     * Check if the network identifier has membership in the set of
+     * network identifiers stored in the carrier config bundle.
+     *
+     * @param b carrier config bundle obtained from CarrierConfigManager
+     * @param network The network identifier to check network existence in bundle
+     * @param key The key to index into the bundle presenting a string array of
+     *            networks to check membership
+     * @return true if network has membership in bundle networks, false otherwise
+     * @see CarrierConfigManager
+     */
+    private boolean isInNetwork(BaseBundle b, String network, String key) {
+        String[] networks = b.getStringArray(key);
+
+        if (networks != null && Arrays.asList(networks).contains(network)) {
+            return true;
+        }
+        return false;
+    }
+
+    protected final boolean isRoamingInGsmNetwork(BaseBundle b, String network) {
+        return isInNetwork(b, network, CarrierConfigManager.KEY_GSM_ROAMING_NETWORKS_STRING_ARRAY);
+    }
+
+    protected final boolean isNonRoamingInGsmNetwork(BaseBundle b, String network) {
+        return isInNetwork(b, network, CarrierConfigManager.KEY_GSM_NONROAMING_NETWORKS_STRING_ARRAY);
+    }
+
+    protected final boolean isRoamingInCdmaNetwork(BaseBundle b, String network) {
+        return isInNetwork(b, network, CarrierConfigManager.KEY_CDMA_ROAMING_NETWORKS_STRING_ARRAY);
+    }
+
+    protected final boolean isNonRoamingInCdmaNetwork(BaseBundle b, String network) {
+        return isInNetwork(b, network, CarrierConfigManager.KEY_CDMA_NONROAMING_NETWORKS_STRING_ARRAY);
+    }
+
+    // MTK add Common
+    protected int getPreferredNetworkModeSettings(int phoneId) {
+        int networkType = -1;
+        int subId[] = SubscriptionManager.getSubId(phoneId);
+        if (subId != null && SubscriptionManager.isValidSubscriptionId(subId[0])) {
+            networkType = PhoneFactory.calculatePreferredNetworkType(
+                mPhone.getContext(), subId[0]);
+        } else {
+            log("Invalid subId, return invalid networkType");
+        }
+        return networkType;
+    }
+    /**
+         * Set the Signal Strength for the phone.
+         * @param ar The param include the Signal Strength.
+         * @param isGsm Mark for the Signal Strength is gsm or not.
+         */
+    // MTK add Common
+    protected void setSignalStrength(AsyncResult ar, boolean isGsm) {
+        SignalStrength oldSignalStrength = mSignalStrength;
+        if ((DBG) && (mLastSignalStrength != null)) {
+            log("Before combine Signal Strength, setSignalStrength(): isGsm = "
+                    + isGsm + " LastSignalStrength = "
+                    + mLastSignalStrength.toString());
+        }
+        // This signal is used for both voice and data radio signal so parse
+        // all fields
+        if ((ar.exception == null) && (ar.result != null)) {
+            mSignalStrength = (SignalStrength) ar.result;
+            mSignalStrength.validateInput();
+            mSignalStrength.setGsm(isGsm);
+            if (DBG) {
+                log("Before combine Signal Strength, setSignalStrength(): isGsm = "
+                        + isGsm + "new mSignalStrength = "
+                        + mSignalStrength.toString());
+            }
+        } else {
+            log("Before combine Signal Strength, setSignalStrength() Exception from RIL : "
+                    + ar.exception);
+            mSignalStrength = new SignalStrength(isGsm);
+        }
+    }
+    /// @}
+
+    /// M: Add for VOLTE @{
+    private final boolean isConcurrentVoiceAndDataAllowedForVolte() {
+        if (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE
+                && ServiceState.isLte(mSS.getRilDataRadioTechnology())
+                && getImsServiceState() == ServiceState.STATE_IN_SERVICE) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private final int getImsServiceState() {
+        final Phone imsPhone = mPhone.getImsPhone();
+        if (imsPhone != null && imsPhone.isVolteEnabled() && mPhone.isImsUseEnabled()) {
+            return imsPhone.getServiceState().getState();
+        }
+        return ServiceState.STATE_OUT_OF_SERVICE;
+    }
+
+    private final boolean mergeEmergencyOnlyCdmaIms(boolean baseEmergencyOnly) {
+        if (baseEmergencyOnly) {
+            return baseEmergencyOnly;
+        }
+
+        if ((mNewSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE)
+                && (mNewSS.getDataRegState() == ServiceState.STATE_OUT_OF_SERVICE)) {
+            final Phone imsPhone = mPhone.getImsPhone();
+            if (imsPhone != null) {
+                return imsPhone.getServiceState().isEmergencyOnly();
+            }
+        }
+
+        return baseEmergencyOnly;
+    }
+
+    /// @}
+
+    /**
+     * Return true if plmn is Home Plmn.
+     * @param plmn
+     * @return true is plmn is home plmn
+     */
+    public boolean isHPlmn(String plmn) {
+        if (mPhone.isPhoneTypeGsm()) {
+            //follow the behavior of modem, according to the length of plmn to compare mcc/mnc
+            //ex: mccmnc: 334030 but plmn:33403 => still be HPLMN
+            String mccmnc = getSIMOperatorNumeric();
+            if (plmn == null) return false;
+
+            if (mccmnc == null || mccmnc.equals("")) {
+                log("isHPlmn getSIMOperatorNumeric error: " + mccmnc);
+                return false;
+            }
+
+            if (plmn.equals(mccmnc)) {
+                return true;
+            } else {
+                if (plmn.length() == 5 && mccmnc.length() == 6
+                    && plmn.equals(mccmnc.substring(0, 5))) {
+                    return true;
+                }
+            }
+
+            /* ALPS01473952 check if plmn in customized EHPLMN table */
+            if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
+                boolean isServingPlmnInGroup = false;
+                boolean isHomePlmnInGroup = false;
+                for (int i = 0; i < customEhplmn.length; i++) {
+                    //reset flag
+                    isServingPlmnInGroup = false;
+                    isHomePlmnInGroup = false;
+
+                    //check if target plmn or home plmn in this group
+                    for (int j = 0; j < customEhplmn[i].length; j++) {
+                        if (plmn.equals(customEhplmn[i][j])) {
+                            isServingPlmnInGroup = true;
+                        }
+                        if (mccmnc.equals(customEhplmn[i][j])) {
+                            isHomePlmnInGroup = true;
+                        }
+                    }
+
+                    //if target plmn and home plmn both in the same group
+                    if ((isServingPlmnInGroup == true) &&
+                            (isHomePlmnInGroup == true)) {
+                        log("plmn:" + plmn + "is in customized ehplmn table");
+                        return true;
+                    }
+                }
+            }
+            /* ALPS01473952 END */
+
+            return false;
+        }
+        return false;
+    }
+
+
+    /** Check if the device is shutting down. */
+    public boolean isDeviceShuttingDown() {
+        return mDeviceShuttingDown;
+    }
+
+
+    /** EONS will possibly be changed due to lac change **/
+    private void hasEonsChanged() {
+        logd("hasEonsChanged OperatorNumeric:" + mNewSS.getOperatorNumeric()
+            + ", Lac: " + ((GsmCellLocation)mNewCellLoc).getLac());
+        SIMRecords simRecords = null;
+        IccRecords r = mPhone.mIccRecords.get();
+        if (r != null) {
+            simRecords = (SIMRecords) r;
+        }
+
+        String sEons = null;
+        String sNewEons = null;
+        try {
+            sEons = (simRecords != null) ? simRecords.getEonsIfExist(mSS.getOperatorNumeric(),
+                    ((GsmCellLocation)mCellLoc).getLac(), true) : null;
+            sNewEons = (simRecords != null) ? simRecords.getEonsIfExist(mNewSS.getOperatorNumeric(),
+                    ((GsmCellLocation)mNewCellLoc).getLac(), true) : null;
+        } catch (RuntimeException ex) {
+            loge("Exception while getEonsIfExist. " + ex);
+        }
+
+        if (sEons == null && sNewEons != null) {
+            log("sNewEons: " + sNewEons);
+            explict_update_spn = 1;
+        } else if (sEons != null && sNewEons == null) {
+            log("sEons: " + sEons);
+            explict_update_spn = 1;
+        } else if ((sEons != null && sNewEons != null) &&
+                !(sEons.equals(sNewEons))) {
+            log("sEons: " + sEons + ", sNewEons: " + sNewEons);
+            explict_update_spn = 1;
+        }
+    }
+
+    private boolean mIsRoamingDialogShown = false;
+    private boolean mAirplaneShowDialog = true;
+    private AlertDialog mRoamingDialog = null;
+    private PendingIntent mPendingIntent;
+
+    private ContentObserver mAirplaneModeObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            int airplaneMode = Settings.Global.getInt(
+                    mPhone.getContext().getContentResolver(),
+                    Settings.Global.AIRPLANE_MODE_ON, 0);
+            if(airplaneMode == 1) {
+                // airplane on
+                mAirplaneShowDialog = false;
+            } else{
+                // airplane off
+                mAirplaneShowDialog = true;
+            }
+        }
+    };
+
+    private void showRoamingReminderIfNeeded() {
+        int showRoamingReminderChoice = android.provider.Settings.Global.getInt(
+                mPhone.getContext().getContentResolver(), android.provider.Settings.Global.
+                PREFERRED_SHOW_ROAMING_REMINDER + mPhone.getSubId(), 0);
+        logd("showRoamingReminderIfNeeded roamingReminderChoice=" + showRoamingReminderChoice);
+
+        if (1 == showRoamingReminderChoice) {
+            // Show roaming reminder once
+            logd("showRoamingReminderIfNeeded mAirplaneShowDialog=" + mAirplaneShowDialog);
+            if (mAirplaneShowDialog) {
+                showDataRoamingConfirmDialog();
+                mAirplaneShowDialog = false;
+            }
+        } else if (0 == showRoamingReminderChoice) {
+            // Show roaming reminder always
+            Intent intent = new Intent(ACTION_SHOW_ROAMING_REMINDER);
+            AlarmManager am = (AlarmManager)mPhone.getContext()
+                .getSystemService(Context.ALARM_SERVICE);
+            if (mPendingIntent != null) {
+                am.cancel(mPendingIntent);
+            }
+
+            mPendingIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent, 0);
+            int interval = 30 * 60 * 1000;
+
+            am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), interval,
+                    mPendingIntent);
+        } else {
+            // Show roaming reminder never, do nothing.
+        }
+    }
+
+    private void showDataRoamingConfirmDialog() {
+        if(isInCryptScreen()) {
+            logd("showDataRoamingConfirmDialog isInCryptScreen, return");
+            return;
+        }
+
+        if(mIsRoamingDialogShown) {
+            logd("[ROAMING]Roaming dialog is shown, abort to recreate the second one");
+            return;
+        }
+
+        logd("showDataRoamingConfirmDialog");
+        int defaultDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+        SubscriptionInfo subInfo = SubscriptionManager.from(
+                mPhone.getContext()).getActiveSubscriptionInfo(defaultDataSubId);
+        boolean sigleSim = TelephonyManager.getDefault().getSimCount() == 1;
+        String opName = subInfo.getDisplayName().toString();
+
+        String msg1 = mPhone.getContext().getResources().getString(sigleSim ?
+                com.android.internal.R.string.roaming_reminder_message_single_sim :
+                com.android.internal.R.string.roaming_reminder_message_multiple_sim);
+        String msg = sigleSim ? msg1 : String.format(msg1, opName);
+        logd("showDataRoamingConfirmDialog sigleSim=" + sigleSim + ", operator="
+                + opName + ", msg=" + msg);
+        final Context context = mPhone.getContext();
+
+        mRoamingDialog = new android.app.AlertDialog.Builder(context,
+                com.android.internal.R.style.Theme_DeviceDefault_Dialog_Alert)
+            .setTitle(com.android.internal.R.string.roaming_reminder_title)
+            .setMessage(msg)
+            .setCancelable(false)
+            .setPositiveButton(com.android.internal.R.string.roaming_reminder_btn_continue,
+                    new android.content.DialogInterface.OnClickListener() {
+
+                        @Override
+                        public void onClick(android.content.DialogInterface dialog, int which) {
+                            mIsRoamingDialogShown  = false;
+                            mDataRoamingOnRegistrants.notifyRegistrants();
+                        }
+                    })
+        .setNegativeButton(com.android.internal.R.string.roaming_reminder_btn_disable,
+                new android.content.DialogInterface.OnClickListener() {
+
+                    @Override
+                    public void onClick(android.content.DialogInterface dialog, int which) {
+                        mIsRoamingDialogShown  = false;
+                        mPhone.setDataRoamingEnabled(false);
+                        mDataRoamingOnRegistrants.notifyRegistrants();
+                    }
+                })
+        .create();
+
+        mRoamingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
+        mRoamingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+
+        mRoamingDialog.show();
+        mIsRoamingDialogShown = true;
+    }
+
+    private boolean isInCryptScreen() {
+        ActivityManager am = (ActivityManager) getPhone().getContext()
+            .getSystemService(Context.ACTIVITY_SERVICE);
+        if(am != null && am.getRunningTasks(1) != null) {
+            List<ActivityManager.RunningTaskInfo> infos = am.getRunningTasks(1);
+
+            if(infos != null && infos.size() != 0) {
+                String currentActivity = infos.get(0).topActivity.getClassName();
+                return "com.android.settings.CryptKeeper".equals(currentActivity);
+            }
+        }
+
+        return false;
+    }
+}
