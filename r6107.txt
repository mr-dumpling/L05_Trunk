Index: device/ausshine/aus6739_66_n1/ProjectConfig.mk
===================================================================
--- device/ausshine/aus6739_66_n1/ProjectConfig.mk	(revision 6106)
+++ device/ausshine/aus6739_66_n1/ProjectConfig.mk	(revision 6107)
@@ -224,7 +224,7 @@
 MTK_BT_SUPPORT = yes
 MTK_BT_WIFI_COEX_RADIO_MODIFY = no
 MTK_BUFFER_COMPRESSION_SUPPORT = no
-MTK_BUILD_VERNO = alps-mp-n1.mp18-V1_aus6739.66.n1_P31
+MTK_BUILD_VERNO = alps-mp-n1.mp18-V1_aus6739.66.n1_P30
 MTK_BWC_SUPPORT = yes
 MTK_C2K_LTE_MODE = 2
 MTK_CACHE_MERGE_SUPPORT = no
Index: device/ausshine/aus6739_36_n1/ProjectConfig.mk
===================================================================
--- device/ausshine/aus6739_36_n1/ProjectConfig.mk	(revision 6106)
+++ device/ausshine/aus6739_36_n1/ProjectConfig.mk	(revision 6107)
@@ -223,7 +223,7 @@
 MTK_BT_SUPPORT = yes
 MTK_BT_WIFI_COEX_RADIO_MODIFY = no
 MTK_BUFFER_COMPRESSION_SUPPORT = no
-MTK_BUILD_VERNO = alps-mp-n1.mp18-V1_aus6739.36.n1_P31
+MTK_BUILD_VERNO = alps-mp-n1.mp18-V1_aus6739.36.n1_P30
 MTK_BWC_SUPPORT = yes
 MTK_C2K_LTE_MODE = 2
 MTK_CACHE_MERGE_SUPPORT = no
Index: kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_notify_sw_vsync.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_notify_sw_vsync.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_notify_sw_vsync.h	(revision 6107)
@@ -30,8 +30,4 @@
 void ged_sodi_start(void);
 void ged_sodi_stop(void);
 
-#if defined(CONFIG_MACH_MT6739)
-extern void MTKFWDump(void);
 #endif
-
-#endif
Index: kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_log.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_log.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/ged/include/ged_log.h	(revision 6107)
@@ -78,8 +78,4 @@
 
 void ged_log_dump(GED_LOG_BUF_HANDLE hLogBuf);
 
-#if defined(CONFIG_MACH_MT6739)
-extern void ged_dump_fw(void);
 #endif
-
-#endif
Index: kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_log.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_log.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_log.c	(revision 6107)
@@ -395,11 +395,6 @@
 	{
 		int i;
 
-#if defined(CONFIG_MACH_MT6739)
-		if (strncmp(psGEDLogBuf->acName, "fw_trace", 8) == 0)
-			ged_dump_fw();
-#endif
-
 		spin_lock_irqsave(&psGEDLogBuf->sSpinLock, psGEDLogBuf->ulIRQFlags);
 
 		if (psGEDLogBuf->acName[0] != '\0')
Index: kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_notify_sw_vsync.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_notify_sw_vsync.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/ged/src/ged_notify_sw_vsync.c	(revision 6107)
@@ -38,9 +38,6 @@
 
 
 static struct workqueue_struct* g_psNotifyWorkQueue = NULL;
-#if defined(CONFIG_MACH_MT6739)
-static struct workqueue_struct *g_psDumpFW;
-#endif
 
 static struct mutex gsVsyncStampLock;
 
@@ -53,12 +50,6 @@
 	unsigned long ul3DFenceDoneTime;
 } GED_NOTIFY_SW_SYNC;
 
-#if defined(CONFIG_MACH_MT6739)
-struct GED_DUMP_FW {
-	struct work_struct	sWork;
-};
-#endif
-
 extern GED_LOG_BUF_HANDLE ghLogBuf_DVFS;
 int (*ged_sw_vsync_event_fp)(bool bMode) = NULL;
 EXPORT_SYMBOL(ged_sw_vsync_event_fp);
@@ -495,31 +486,6 @@
 }
 
 
-#if defined(CONFIG_MACH_MT6739)
-static void ged_dump_fw_handle(struct work_struct *psWork)
-{
-	struct GED_DUMP_FW *psNotify = GED_CONTAINER_OF(psWork, struct GED_DUMP_FW, sWork);
-
-	if (psNotify) {
-		MTKFWDump();
-		ged_free(psNotify, sizeof(struct GED_DUMP_FW));
-	}
-}
-
-void ged_dump_fw(void)
-{
-	struct GED_DUMP_FW *psNotify;
-
-	psNotify = (struct GED_DUMP_FW *)ged_alloc_atomic(sizeof(struct GED_DUMP_FW));
-	if (psNotify) {
-		INIT_WORK(&psNotify->sWork, ged_dump_fw_handle);
-		queue_work(g_psDumpFW, &psNotify->sWork);
-	}
-}
-EXPORT_SYMBOL(ged_dump_fw);
-#endif
-
-
 GED_ERROR ged_notify_sw_vsync_system_init(void)
 {
 	g_psNotifyWorkQueue = create_workqueue("ged_notify_sw_vsync");
@@ -528,15 +494,6 @@
 	{
 		return GED_ERROR_OOM;
 	}
-
-#if defined(CONFIG_MACH_MT6739)
-	g_psDumpFW = NULL;
-	g_psDumpFW = create_workqueue("ged_dump_fw_log");
-
-	if (g_psDumpFW == NULL)
-		return GED_ERROR_OOM;
-#endif
-
 	mutex_init(&gsVsyncStampLock);
 	mutex_init(&gsVsyncModeLock);
 	
@@ -559,16 +516,6 @@
 
 		g_psNotifyWorkQueue = NULL;
 	}
-
-#if defined(CONFIG_MACH_MT6739)
-	if (g_psDumpFW != NULL) {
-		flush_workqueue(g_psDumpFW);
-
-		destroy_workqueue(g_psDumpFW);
-
-		g_psDumpFW = NULL;
-	}
-#endif
 #ifdef ENABLE_COMMON_DVFS			 
 	hrtimer_cancel( &g_HT_hwvsync_emu );
 #endif	
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_eng_mt6739.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_eng_mt6739.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_eng_mt6739.h	(revision 6107)
@@ -77,8 +77,7 @@
 #define PVRSRV_ENABLE_CCCB_UTILISATION_INFO 
 #define PVRSRV_ENABLE_CCCB_UTILISATION_INFO_THRESHOLD 90
 #define PVR_LINUX_PHYSMEM_MAX_POOL_PAGES 10240
-#define PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES 20480
-#define PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES
+#define PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES 32768
 #define PVR_DIRTY_BYTES_FLUSH_THRESHOLD 1048576
 #define PVR_LINUX_HIGHORDER_ALLOCATION_THRESHOLD 256
 #define PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM  2
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/mtk_pp.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/mtk_pp.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/mtk_pp.h	(revision 6107)
@@ -18,13 +18,10 @@
 {
 	MTKPP_ID_FW,
 	MTKPP_ID_SYNC,
-	MTKPP_ID_SHOT_FW,
 
 	MTKPP_ID_SIZE
 } MTKPP_ID;
 
-extern int g_use_id;
-
 typedef enum MTKPP_BUFFERTYPE_TAG
 {
 	MTKPP_BUFFERTYPE_QUEUEBUFFER,
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_user_mt6739.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_user_mt6739.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/include/config_kernel_user_mt6739.h	(revision 6107)
@@ -77,8 +77,7 @@
 #define PVRSRV_ENABLE_CCCB_UTILISATION_INFO 
 #define PVRSRV_ENABLE_CCCB_UTILISATION_INFO_THRESHOLD 90
 #define PVR_LINUX_PHYSMEM_MAX_POOL_PAGES 10240
-#define PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES 20480
-#define PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES
+#define PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES 32768
 #define PVR_DIRTY_BYTES_FLUSH_THRESHOLD 1048576
 #define PVR_LINUX_HIGHORDER_ALLOCATION_THRESHOLD 256
 #define PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM  2
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_pp.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_pp.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_pp.c	(revision 6107)
@@ -397,7 +397,6 @@
 
 #endif
 
-int g_use_id;
 void MTKPP_Init(void)
 {
 	int i;
@@ -410,7 +409,6 @@
 	{
 		{MTKPP_ID_FW,       MTKPP_BUFFERTYPE_QUEUEBUFFER,  248 * 1024,  1 * 1024}, /* 256 KB */
 		{MTKPP_ID_SYNC,     MTKPP_BUFFERTYPE_RINGBUFFER,    56 * 1024,  1 * 1024}, /*  64 KB */
-		{MTKPP_ID_SHOT_FW,	MTKPP_BUFFERTYPE_RINGBUFFER,  248 * 1024,	1 * 1024}, /* 256 KB */
 	};
 
 	for (i = 0; i < MTKPP_ID_SIZE; ++i)
@@ -448,7 +446,6 @@
 	INIT_WORK(&g_MTKPP_worker.sWork, MTKPP_WORKR_Handle);
 #endif
 
-	g_use_id = MTKPP_ID_FW;
 	g_init_done = 1;
 
 err_out:
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_mfgsys.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_mfgsys.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/system/rgx_mt6739/mtk_mfgsys.c	(revision 6107)
@@ -1639,16 +1639,6 @@
 }
 EXPORT_SYMBOL(MTKSaveFrame);
 
-void MTKFWDump(void)
-{
-	PVRSRV_DEVICE_NODE *psDevNode = MTKGetRGXDevNode();
-
-	MTK_PVRSRVDebugRequestSetSilence(IMG_TRUE);
-	PVRSRVDebugRequest(psDevNode, DEBUG_REQUEST_VERBOSITY_MAX, NULL, NULL);
-	MTK_PVRSRVDebugRequestSetSilence(IMG_FALSE);
-}
-EXPORT_SYMBOL(MTKFWDump);
-
 #ifndef ENABLE_COMMON_DVFS  
 module_param(gpu_loading, uint, 0644);
 module_param(gpu_block, uint, 0644);
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/devices/rgx/rgxdebug.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/devices/rgx/rgxdebug.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/devices/rgx/rgxdebug.c	(revision 6107)
@@ -3659,13 +3659,13 @@
 		switch (ui32VerbLevel)
 		{
 			case DEBUG_REQUEST_VERBOSITY_LOW:
-				MTKPP_LOGTIME(g_use_id, "DEBUG_REQUEST_VERBOSITY_LOW");
+				MTKPP_LOGTIME(MTKPP_ID_FW, "DEBUG_REQUEST_VERBOSITY_LOW");
 				break;
 			case DEBUG_REQUEST_VERBOSITY_MEDIUM:
-				MTKPP_LOGTIME(g_use_id, "DEBUG_REQUEST_VERBOSITY_MEDIUM");
+				MTKPP_LOGTIME(MTKPP_ID_FW, "DEBUG_REQUEST_VERBOSITY_MEDIUM");
 				break;
 			case DEBUG_REQUEST_VERBOSITY_HIGH:
-				MTKPP_LOGTIME(g_use_id, "DEBUG_REQUEST_VERBOSITY_HIGH");
+				MTKPP_LOGTIME(MTKPP_ID_FW, "DEBUG_REQUEST_VERBOSITY_HIGH");
 				break;
 		}
 	}
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/include/pvr_notifier.h
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/include/pvr_notifier.h	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/include/pvr_notifier.h	(revision 6107)
@@ -138,14 +138,8 @@
 #include "mtk_pp.h"
 
 #if defined(MTK_DEBUG_PROC_PRINT)
-#define _MTKPP_GPULOG_FW(...) MTKPP_LOG(g_use_id, __VA_ARGS__)
-#define PVR_DUMPDEBUG_LOG(...)\
-	do {\
-		if (pfnDumpDebugPrintf)\
-			pfnDumpDebugPrintf(pvDumpDebugFile, __VA_ARGS__);\
-		else\
-			MTKPP_LOG(g_use_id, __VA_ARGS__);\
-	} while (0)
+#define _MTKPP_GPULOG_FW(...) MTKPP_LOG(MTKPP_ID_FW, __VA_ARGS__)
+#define PVR_DUMPDEBUG_LOG(...)  do { if (pfnDumpDebugPrintf) {pfnDumpDebugPrintf(pvDumpDebugFile, __VA_ARGS__);} else {MTKPP_LOG(MTKPP_ID_FW, __VA_ARGS__);} } while(0)
 #else
 #define PVR_DUMPDEBUG_LOG(...)                                            \
 	do                                                                \
@@ -252,11 +246,4 @@
 				   DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 				   void *pvDumpDebugFile);
 
-/* MTK{ */
-IMG_BOOL
-MTK_PVRSRVDebugRequestGetSilence(void);
-void
-MTK_PVRSRVDebugRequestSetSilence(IMG_BOOL bEnable);
-/* }MTK */
-
 #endif /* !defined(__PVR_NOTIFIER_H__) */
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvrsrv.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvrsrv.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvrsrv.c	(revision 6107)
@@ -126,8 +126,6 @@
  * a day to check for any missed clean-up. */
 #define CLEANUP_THREAD_WAIT_SLEEP_TIMEOUT 28800000000ULL
 
-/*! When unloading try a few times to free everything remaining on the list */
-#define CLEANUP_THREAD_UNLOAD_RETRY 4
 
 #define PVRSRV_PROC_HANDLE_BASE_INIT 10
 
@@ -155,7 +153,6 @@
 {
 	PVRSRV_DATA *psPVRSRVData;
 	PVRSRV_ERROR eError;
-	IMG_UINT32 uiUnloadRetry = 0;
 
 	psPVRSRVData = PVRSRVGetPVRSRVData();
 
@@ -305,7 +302,6 @@
 	IMG_BOOL     bRetryWorkList = IMG_FALSE;
 	IMG_HANDLE	 hOSEvent;
 	PVRSRV_ERROR eRc;
-	IMG_UINT32 uiUnloadRetry = 0;
 
 	/* Store the process id (pid) of the clean-up thread */
 	psPVRSRVData->cleanupThreadPid = OSGetCurrentProcessID();
@@ -321,16 +317,9 @@
 	/* While the driver is in a good state and is not being unloaded
 	 * try to free any deferred items when signalled
 	 */
-	while ((psPVRSRVData->eServicesState == PVRSRV_SERVICES_STATE_OK))
+	while ((psPVRSRVData->eServicesState == PVRSRV_SERVICES_STATE_OK) &&
+			(!psPVRSRVData->bUnload))
 	{
-		if (psPVRSRVData->bUnload) {
-			if (dllist_is_empty(&psPVRSRVData->sCleanupThreadWorkList) ||
-					uiUnloadRetry > CLEANUP_THREAD_UNLOAD_RETRY) {
-				break;
-			}
-			uiUnloadRetry++;
-		}
-
 		/* Wait until signalled for deferred clean up OR wait for a
 		 * short period if the previous deferred clean up was not able
 		 * to release all the resources before trying again.
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvr_notifier.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvr_notifier.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/common/pvr_notifier.c	(revision 6107)
@@ -397,23 +397,7 @@
 	return PVRSRV_OK;
 }
 
-IMG_BOOL bQuiet;
-IMG_BOOL MTK_PVRSRVDebugRequestGetSilence(void)
-{
-	return bQuiet;
-}
-
 void
-MTK_PVRSRVDebugRequestSetSilence(IMG_BOOL bEnable)
-{
-	bQuiet = bEnable;
-	if (bQuiet == IMG_TRUE)
-		g_use_id = MTKPP_ID_SHOT_FW;
-	else
-		g_use_id = MTKPP_ID_FW;
-}
-
-void
 PVRSRVDebugRequest(PVRSRV_DEVICE_NODE *psDevNode,
 				   IMG_UINT32 ui32VerbLevel,
 				   DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
@@ -438,7 +422,6 @@
 		 * Only dump the call stack to the kernel log if the debug text is going
 		 * there.
 		 */
-		if (bQuiet == IMG_FALSE)
 		OSDumpStack();
 	}
 
@@ -463,7 +446,7 @@
 
 	if (!pfnDumpDebugPrintf)
 	{
-		MTKPP_LOGTIME(g_use_id, "Dump Debug Data");
+		MTKPP_LOGTIME(MTKPP_ID_FW, "Dump Debug Data");
 	}
 
 	switch (psPVRSRVData->eServicesState)
Index: kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/env/linux/physmem_osmem_linux.c
===================================================================
--- kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/env/linux/physmem_osmem_linux.c	(revision 6106)
+++ kernel-4.4/drivers/misc/mediatek/gpu/gpu_rgx/m1.8ED4490469/services/server/env/linux/physmem_osmem_linux.c	(revision 6107)
@@ -90,8 +90,6 @@
 #define PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM 0
 static IMG_UINT32 g_uiMaxOrder = 0;
 #endif
-/* Defines how many pages should be mapped at once to the kernel */
-#define PVR_LINUX_PHYSMEM_MAX_KMAP_PAGES 1024 /* 4 MB */
 
 /* Get/Set/Mask out alloc_page/dma_alloc flag */
 #define DMA_GET_ADDR(x)			(((x) >> 1) << 1)
@@ -199,14 +197,10 @@
 					IMG_BOOL bFlush,
 					IMG_UINT32 ui32CPUCacheFlags);
 
-static inline unsigned int
-_GetGFPFlags(IMG_BOOL bZero,
-					PVRSRV_DEVICE_NODE *psDevNode);
-
-/* A struct for our page pool holding an array of zeroed (!) pages.
+/* A struct for our page pool holding an array of pages.
  * We always put units of page arrays to the pool but are
  * able to take individual pages */
-typedef struct
+typedef	struct
 {
 	/* Linkage for page pool LRU list */
 	struct list_head sPagePoolItem;
@@ -213,18 +207,10 @@
 
 	/* How many items are still in the page array */
 	IMG_UINT32 uiItemsRemaining;
-	/* Array of the actual pages */
 	struct page **ppsPageArray;
 
 } LinuxPagePoolEntry;
 
-/* CleanupThread structure to put allocation in page pool */
-typedef struct {
-	PVRSRV_CLEANUP_THREAD_WORK sCleanupWork;
-	IMG_UINT32 ui32CPUCacheMode;
-	LinuxPagePoolEntry *psPoolEntry;
-} LinuxCleanupData;
-
 /* A struct for the unpinned items */
 typedef struct
 {
@@ -236,36 +222,19 @@
 static struct kmem_cache *g_psLinuxPagePoolCache = NULL;
 static struct kmem_cache *g_psLinuxPageArray = NULL;
 
-/* Track what is live, all protected by pool lock. */
-/* x86 needs two page pools because we have to change the memory attributes */
-/* of the pages which is expensive due to an implicit flush. */
-/* See set_pages_array_uc/wc/wb. */
+/* Track what is live */
 static IMG_UINT32 g_ui32UnpinPageCount = 0;
-static IMG_UINT32 g_ui32PagePoolUCCount;
-#if defined(CONFIG_X86)
-static IMG_UINT32 g_ui32PagePoolWCCount;
-#endif
-/* Tracks asynchronous tasks currently accessing the page pool. */
-/* It is incremented if a defer free task */
-/* is created. Both will decrement the value when they finished the work. */
-/* The atomic prevents piling up of deferred work in case the deferred thread */
-/* cannot keep up with the application.*/
-static ATOMIC_T g_iPoolCleanTasks;
-/* We don't want too many asynchronous threads trying to access the page pool */
-/* at the same time */
-#define PVR_LINUX_PHYSMEM_MAX_ASYNC_CLEAN_TASKS 128
+static IMG_UINT32 g_ui32PagePoolEntryCount = 0;
 
-/* Defines how many pages the page cache should hold. */
+/* Pool entry limits */
 #if defined(PVR_LINUX_PHYSMEM_MAX_POOL_PAGES)
 static const IMG_UINT32 g_ui32PagePoolMaxEntries = PVR_LINUX_PHYSMEM_MAX_POOL_PAGES;
+static const IMG_UINT32 g_ui32PagePoolMaxEntries_5Percent= PVR_LINUX_PHYSMEM_MAX_POOL_PAGES / 20;
 #else
 static const IMG_UINT32 g_ui32PagePoolMaxEntries = 0;
+static const IMG_UINT32 g_ui32PagePoolMaxEntries_5Percent = 0;
 #endif
 
-/* We double check if we would exceed this limit if we are below MAX_POOL_PAGES */
-/* and want to add an allocation to the pool. */
-/* This prevents big allocations being given back to the OS just because they */
-/* exceed the MAX_POOL_PAGES limit even though the pool is currently empty. */
 #if defined(PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES)
 static const IMG_UINT32 g_ui32PagePoolMaxExcessEntries = PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES;
 #else
@@ -273,14 +242,16 @@
 #endif
 
 #if defined(CONFIG_X86)
-#define PHYSMEM_OSMEM_NUM_OF_POOLS 2
+#define PHYSMEM_OSMEM_NUM_OF_POOLS 3
 static const IMG_UINT32 g_aui32CPUCacheFlags[PHYSMEM_OSMEM_NUM_OF_POOLS] = {
+	PVRSRV_MEMALLOCFLAG_CPU_CACHED,
 	PVRSRV_MEMALLOCFLAG_CPU_UNCACHED,
 	PVRSRV_MEMALLOCFLAG_CPU_WRITE_COMBINE
 };
 #else
-#define PHYSMEM_OSMEM_NUM_OF_POOLS 1
+#define PHYSMEM_OSMEM_NUM_OF_POOLS 2
 static const IMG_UINT32 g_aui32CPUCacheFlags[PHYSMEM_OSMEM_NUM_OF_POOLS] = {
+	PVRSRV_MEMALLOCFLAG_CPU_CACHED,
 	PVRSRV_MEMALLOCFLAG_CPU_UNCACHED
 };
 #endif
@@ -289,20 +260,11 @@
 static DEFINE_MUTEX(g_sPagePoolMutex);
 
 /* List holding the page array pointers: */
+static LIST_HEAD(g_sPagePoolList_WB);
 static LIST_HEAD(g_sPagePoolList_WC);
 static LIST_HEAD(g_sPagePoolList_UC);
 static LIST_HEAD(g_sUnpinList);
 
-static inline IMG_UINT32
-_PagesInPoolUnlocked(void)
-{
-	IMG_UINT32 uiCnt = g_ui32PagePoolUCCount;
-#if defined(CONFIG_X86)
-	uiCnt += g_ui32PagePoolWCCount;
-#endif
-	return uiCnt;
-}
-
 static inline void
 _PagePoolLock(void)
 {
@@ -370,8 +332,7 @@
 
 static inline IMG_BOOL
 _GetPoolListHead(IMG_UINT32 ui32CPUCacheFlags,
-				 struct list_head **ppsPoolHead,
-				 IMG_UINT32 **ppuiCounter)
+				 struct list_head **ppsPoolHead)
 {
 	switch(PVRSRV_CPU_CACHE_MODE(ui32CPUCacheFlags))
 	{
@@ -384,22 +345,20 @@
 		*/
 
 			*ppsPoolHead = &g_sPagePoolList_WC;
-			*ppuiCounter = &g_ui32PagePoolWCCount;
 			break;
 #endif
 
 		case PVRSRV_MEMALLOCFLAG_CPU_UNCACHED:
 			*ppsPoolHead = &g_sPagePoolList_UC;
-			*ppuiCounter = &g_ui32PagePoolUCCount;
 			break;
 
+		case PVRSRV_MEMALLOCFLAG_CPU_CACHED:
+			*ppsPoolHead = &g_sPagePoolList_WB;
+			break;
+
 		default:
-			PVR_DPF((PVR_DBG_ERROR,
-					"%s: Unknown CPU caching mode. Using default UC pool.",
-					 __func__));
-			*ppsPoolHead = &g_sPagePoolList_UC;
-			*ppuiCounter = &g_ui32PagePoolUCCount;
-			PVR_ASSERT(0);
+			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to get pages from pool, "
+					 "unknown CPU caching mode.", __func__));
 			return IMG_FALSE;
 	}
 	return IMG_TRUE;
@@ -407,11 +366,15 @@
 
 static struct shrinker g_sShrinker;
 
-/* Returning the number of pages that still reside in the page pool. */
+/* Returning the number of pages that still reside in the page pool.
+ * Do not count excess pages that will be freed by the defer free thread. */
 static unsigned long
 _GetNumberOfPagesInPoolUnlocked(void)
 {
-	return _PagesInPoolUnlocked() + g_ui32UnpinPageCount;
+	unsigned int uiEntryCount;
+
+	uiEntryCount = (g_ui32PagePoolEntryCount > g_ui32PagePoolMaxEntries) ? g_ui32PagePoolMaxEntries : g_ui32PagePoolEntryCount;
+	return uiEntryCount + g_ui32UnpinPageCount;
 }
 
 /* Linux shrinker function that informs the OS about how many pages we are caching and
@@ -509,6 +472,12 @@
 	}
 
 e_exit:
+	if (list_empty(&g_sPagePoolList_WC) &&
+		list_empty(&g_sPagePoolList_UC) &&
+		list_empty(&g_sPagePoolList_WB))
+	{
+		PVR_ASSERT(g_ui32PagePoolEntryCount == 0);
+	}
 	if (list_empty(&g_sUnpinList))
 	{
 		PVR_ASSERT(g_ui32UnpinPageCount == 0);
@@ -570,8 +539,6 @@
 		register_shrinker(&g_sShrinker);
 	}
 	_PagePoolUnlock();
-
-	OSAtomicWrite(&g_iPoolCleanTasks, 0);
 }
 
 /* Unregister the shrinker and remove all pages from the pool that are still left */
@@ -579,19 +546,14 @@
 {
 	IMG_UINT32 uiPagesFreed;
 
-	if (OSAtomicRead(&g_iPoolCleanTasks) > 0) {
-		PVR_DPF((PVR_DBG_WARNING, "Still deferred cleanup tasks running "
-				"while deinitialising memory subsystem."));
-	}
-
 	_PagePoolLock();
-	if (_FreePagesFromPoolUnlocked(IMG_UINT32_MAX, &uiPagesFreed) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "Unable to free all pages from page pool when "
-				"deinitialising memory subsystem."));
+	if (_FreePagesFromPoolUnlocked(g_ui32PagePoolEntryCount, &uiPagesFreed) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "Unable to free all pages from page pool when deinitialising."));
 		PVR_ASSERT(0);
 	}
 
-	PVR_ASSERT(_PagesInPoolUnlocked() == 0);
+	PVR_ASSERT(g_ui32PagePoolEntryCount == 0);
 
 	/* Free the page cache */
 	kmem_cache_destroy(g_psLinuxPagePoolCache);
@@ -657,7 +619,6 @@
 	LinuxPagePoolEntry *psPagePoolEntry, *psTempPoolEntry;
 	struct list_head *psPoolHead = NULL;
 	IMG_UINT32  j;
-	IMG_UINT32 *puiCounter;
 
 	pr_debug("\n");
 	/* Empty all pools */
@@ -667,8 +628,10 @@
 		pr_debug("pool = %u \n", j);
 
 		/* Get the correct list for this caching mode */
-		if (!_GetPoolListHead(g_aui32CPUCacheFlags[j], &psPoolHead, &puiCounter))
+		if (!_GetPoolListHead(g_aui32CPUCacheFlags[j], &psPoolHead))
+		{
 			break;
+		}
 
 		list_for_each_entry_safe(psPagePoolEntry,
 								 psTempPoolEntry,
@@ -682,6 +645,121 @@
 #endif
 }
 
+/* Will take excess pages from the pool with acquired pool lock and then free
+ * them without pool lock being held.
+ * Designed to run in the deferred free thread. */
+static PVRSRV_ERROR
+_FreeExcessPagesFromPool(void)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	LIST_HEAD(sPagePoolFreeList);
+	LinuxPagePoolEntry *psPagePoolEntry, *psTempPoolEntry;
+	struct list_head *psPoolHead = NULL;
+	IMG_UINT32 i, j, uiPoolIdx;
+	static IMG_UINT8 uiPoolAccessRandomiser;
+	IMG_BOOL bDone = IMG_FALSE;
+
+	/* Make sure all pools are drained over time */
+	uiPoolAccessRandomiser++;
+
+	/* Empty all pools */
+	for (j = 0; j < PHYSMEM_OSMEM_NUM_OF_POOLS; j++)
+	{
+		uiPoolIdx = (j + uiPoolAccessRandomiser) % PHYSMEM_OSMEM_NUM_OF_POOLS;
+
+		/* Just lock down to collect pool entries and unlock again before freeing them */
+		_PagePoolLock();
+
+		/* Get the correct list for this caching mode */
+		if (!_GetPoolListHead(g_aui32CPUCacheFlags[uiPoolIdx], &psPoolHead))
+		{
+			_PagePoolUnlock();
+			break;
+		}
+
+		/* Traverse pool in reverse order to remove items that exceeded
+		 * the pool size first */
+		list_for_each_entry_safe_reverse(psPagePoolEntry,
+										 psTempPoolEntry,
+										 psPoolHead,
+										 sPagePoolItem)
+		{
+			/* Go to free the pages if we collected enough */
+			if (g_ui32PagePoolEntryCount <= g_ui32PagePoolMaxEntries)
+			{
+				bDone = IMG_TRUE;
+				break;
+			}
+
+			/* Move item to free list so we can free it later without the pool lock */
+			list_del(&psPagePoolEntry->sPagePoolItem);
+			list_add(&psPagePoolEntry->sPagePoolItem, &sPagePoolFreeList);
+
+			/* Update counters */
+			g_ui32PagePoolEntryCount -= psPagePoolEntry->uiItemsRemaining;
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+	/* MemStats usually relies on having the bridge lock held, however
+	 * the page pool code may call PVRSRVStatsIncrMemAllocPoolStat and
+	 * PVRSRVStatsDecrMemAllocPoolStat without the bridge lock held, so
+	 * the page pool lock is used to ensure these calls are mutually
+	 * exclusive
+	 */
+	PVRSRVStatsDecrMemAllocPoolStat(PAGE_SIZE * psPagePoolEntry->uiItemsRemaining);
+#endif
+		}
+
+		_PagePoolUnlock();
+
+
+		/* Free the pages that we removed from the pool */
+		list_for_each_entry_safe(psPagePoolEntry,
+								 psTempPoolEntry,
+								 &sPagePoolFreeList,
+								 sPagePoolItem)
+		{
+#if defined(CONFIG_X86)
+			/* Set the correct page caching attributes on x86 */
+			if (!PVRSRV_CHECK_CPU_CACHED(g_aui32CPUCacheFlags[uiPoolIdx]))
+			{
+				int ret;
+				ret = set_pages_array_wb(psPagePoolEntry->ppsPageArray,
+										 psPagePoolEntry->uiItemsRemaining);
+				if (ret)
+				{
+					PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attributes", __FUNCTION__));
+					eError = PVRSRV_ERROR_FAILED_TO_FREE_PAGES;
+					goto e_exit;
+				}
+			}
+#endif
+			/* Free the actual pages */
+			for (i = 0; i < psPagePoolEntry->uiItemsRemaining; i++)
+			{
+				__free_pages(psPagePoolEntry->ppsPageArray[i], 0);
+				psPagePoolEntry->ppsPageArray[i] = NULL;
+			}
+
+			/* Free the pool entry and page array*/
+			list_del(&psPagePoolEntry->sPagePoolItem);
+			OSFreeMemNoStats(psPagePoolEntry->ppsPageArray);
+			kmem_cache_free(g_psLinuxPagePoolCache, psPagePoolEntry);
+		}
+
+		/* Stop if all excess pages were removed */
+		if (bDone)
+		{
+			eError = PVRSRV_OK;
+			goto e_exit;
+		}
+
+	}
+
+e_exit:
+	_DumpPoolStructure();
+	return eError;
+}
+
 /* Free a certain number of pages from the page pool.
  * Mainly used in error paths or at deinitialisation to
  * empty the whole pool. */
@@ -693,7 +771,6 @@
 	LinuxPagePoolEntry *psPagePoolEntry, *psTempPoolEntry;
 	struct list_head *psPoolHead = NULL;
 	IMG_UINT32 i, j;
-	IMG_UINT32 *puiCounter;
 
 	*puiPagesFreed = uiMaxPagesToFree;
 
@@ -702,8 +779,10 @@
 	{
 
 		/* Get the correct list for this caching mode */
-		if (!_GetPoolListHead(g_aui32CPUCacheFlags[j], &psPoolHead, &puiCounter))
+		if (!_GetPoolListHead(g_aui32CPUCacheFlags[j], &psPoolHead))
+		{
 			break;
+		}
 
 		/* Free the pages and remove page arrays from the pool if they are exhausted */
 		list_for_each_entry_safe(psPagePoolEntry,
@@ -750,7 +829,7 @@
 
 			/* Reduce counters */
 			uiMaxPagesToFree -= uiItemsToFree;
-			*puiCounter -= uiItemsToFree;
+			g_ui32PagePoolEntryCount -= uiItemsToFree;
 			psPagePoolEntry->uiItemsRemaining -= uiItemsToFree;
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
@@ -796,19 +875,22 @@
 	LinuxPagePoolEntry *psPagePoolEntry, *psTempPoolEntry;
 	struct list_head *psPoolHead = NULL;
 	IMG_UINT32 i;
-	IMG_UINT32 *puiCounter;
 
 	*puiNumReceivedPages = 0;
 
 	/* Get the correct list for this caching mode */
-	if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead, &puiCounter))
+	if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead))
+	{
 		return;
+	}
 
 	/* Check if there are actually items in the list */
 	if (list_empty(psPoolHead))
+	{
 		return;
+	}
 
-	PVR_ASSERT(*puiCounter > 0);
+	PVR_ASSERT(g_ui32PagePoolEntryCount > 0);
 
 	/* Receive pages from the pool */
 	list_for_each_entry_safe(psPagePoolEntry,
@@ -842,7 +924,7 @@
 exit_ok:
 
 	/* Update counters */
-	*puiCounter -= *puiNumReceivedPages;
+	g_ui32PagePoolEntryCount -= *puiNumReceivedPages;
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	/* MemStats usually relies on having the bridge lock held, however
@@ -858,6 +940,9 @@
 	return;
 }
 
+/* When is it worth waiting for the page pool? */
+#define PVR_LINUX_PHYSMEM_MIN_PAGES_TO_WAIT_FOR_POOL 64
+
 /* Same as _GetPagesFromPoolUnlocked but handles locking and
  * checks first whether pages from the pool are a valid option. */
 static inline void
@@ -869,21 +954,25 @@
 						struct page **ppsPageArray,
 						IMG_UINT32 *puiPagesFromPool)
 {
-#if defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
-	PVR_UNREFERENCED_PARAMETER(bZero);
-#else
-	/* Don't get pages from pool if it doesn't provide zeroed pages */
-	if (bZero)
-		return;
-#endif
-
-	/* The page pool stores only order 0 pages. If we need zeroed memory we */
-	/* directly allocate from the OS because it is faster than */
-	/* doing it within the driver. */
-	if (uiOrder == 0 &&
-	    !PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags))
+	/* The page pool stores only order 0 pages. If we need zeroed memory we
+	 * directly allocate from the OS because it is faster than doing it ourselves. */
+	if (uiOrder == 0 && !bZero)
 	{
-		_PagePoolLock();
+		if (uiPagesToAlloc < PVR_LINUX_PHYSMEM_MIN_PAGES_TO_WAIT_FOR_POOL)
+		{
+			/* In case the request is a few pages, just try to acquire the pool lock */
+			if (_PagePoolTrylock() == 0)
+			{
+				return;
+			}
+		}
+		else
+		{
+			/* It is worth waiting if many pages were requested.
+			 * Freeing an item to the pool is very fast and
+			 * the defer free thread will release the lock regularly. */
+			_PagePoolLock();
+		}
 
 		_GetPagesFromPoolUnlocked(ui32CPUCacheFlags,
 								  uiPagesToAlloc,
@@ -890,155 +979,145 @@
 								  ppsPageArray,
 								  puiPagesFromPool);
 		_PagePoolUnlock();
+
+		/* Do cache maintenance so allocations from the pool can be
+		 * considered clean */
+		if (PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags) &&
+		    PVRSRV_CHECK_CPU_CACHE_CLEAN(ui32CPUCacheFlags))
+		{
+			_ApplyCacheMaintenance(psDevNode,
+								   ppsPageArray,
+								   *puiPagesFromPool,
+								   IMG_FALSE);
+		}
 	}
 
 	return;
 }
 
-/* Takes a page array and maps it into the kernel to write zeros */
+/* Defer free function to remove excess pages from the page pool.
+ * We do not need the bridge lock for this function */
 static PVRSRV_ERROR
-_ZeroPageArray(IMG_UINT32 uiNumToClean,
-						struct page **ppsCleanArray,
-						pgprot_t pgprot)
+_CleanupThread_FreePoolPages(void *pvData)
 {
-	IMG_CPU_VIRTADDR pvAddr;
-	IMG_UINT32 uiMaxPagesToMap = PVR_LINUX_PHYSMEM_MAX_KMAP_PAGES;
+	PVRSRV_ERROR eError;
 
-	/* Map and fill the pages with zeros. */
-	/* For large page arrays do it PVR_LINUX_PHYSMEM_MAX_KMAP_SIZE */
-	/* at a time. */
-	while (uiNumToClean != 0) {
-		IMG_UINT32 uiToClean = (uiNumToClean >= uiMaxPagesToMap) ?
-								uiMaxPagesToMap :
-								uiNumToClean;
+	/* Free all that is necessary */
+	eError = _FreeExcessPagesFromPool();
+	if(eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: _FreeExcessPagesFromPool failed", __func__));
+		goto e_exit;
+	}
 
-		pvAddr = vm_map_ram(ppsCleanArray, uiToClean, -1, pgprot);
-		if (!pvAddr) {
-			if (uiMaxPagesToMap <= 1) {
-				PVR_DPF((PVR_DBG_ERROR,
-						"%s: Out of vmalloc memory, unable to map pages for zeroing.",
-						__func__));
-				return PVRSRV_ERROR_OUT_OF_MEMORY;
-			} else {
-				/* Half the pages to map at once and try again. */
-				uiMaxPagesToMap = uiMaxPagesToMap >> 1;
-				continue;
-			}
-		}
+	OSFreeMem(pvData);
 
-		OSDeviceMemSet(pvAddr, 0, PAGE_SIZE * uiToClean);
-		vm_unmap_ram(pvAddr, uiToClean);
-
-		ppsCleanArray = &(ppsCleanArray[uiToClean]);
-		uiNumToClean -= uiToClean;
-	}
-
-	return PVRSRV_OK;
+e_exit:
+	return eError;
 }
 
-static PVRSRV_ERROR
-_CleanupThread_CleanPages(void *pvData)
+/* Signal the defer free thread that there are pages in the pool to be cleaned up.
+ * MUST NOT HOLD THE PAGE POOL LOCK! */
+static void
+_SignalDeferFree(void)
 {
-	PVRSRV_ERROR eError;
-	LinuxCleanupData *psCleanupData = (LinuxCleanupData *) pvData;
-	LinuxPagePoolEntry *psPagePoolEntry = psCleanupData->psPoolEntry;
-	struct list_head *psPoolHead = NULL;
-	pgprot_t pgprot;
-	IMG_UINT32 *puiCounter = NULL;
+	PVRSRV_CLEANUP_THREAD_WORK *psCleanupThreadFn;
+	psCleanupThreadFn = OSAllocMem(sizeof(*psCleanupThreadFn));
 
-	/* Get the correct pool for this caching mode. */
-	_GetPoolListHead(psCleanupData->ui32CPUCacheMode, &psPoolHead, &puiCounter);
-
-	switch (PVRSRV_CPU_CACHE_MODE(psCleanupData->ui32CPUCacheMode)) {
-	case PVRSRV_MEMALLOCFLAG_CPU_UNCACHED:
-#if defined(CONFIG_X86)
-		/* For x86 we can only map with the same attributes */
-		/* as in the PAT settings */
-		pgprot = pgprot_noncached(PAGE_KERNEL);
-		break;
-#endif
-
-	case PVRSRV_MEMALLOCFLAG_CPU_WRITE_COMBINE:
-		pgprot = pgprot_writecombine(PAGE_KERNEL);
-		break;
-
-	default:
+	if(!psCleanupThreadFn)
+	{
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: Unknown caching mode to set page protection flags.",
-				__func__));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto eExit;
+				 "%s: Failed to get memory for deferred page pool cleanup. "
+				 "Trying to free pages immediately",
+				 __FUNCTION__));
+		goto e_oom_exit;
 	}
 
-#if defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
-	/* Map and fill the pages with zeros. */
-	/* For large page arrays do it PVR_LINUX_PHYSMEM_MAX_KMAP_SIZE */
-	/* at a time. */
-	eError = _ZeroPageArray(psPagePoolEntry->uiItemsRemaining,
-							psPagePoolEntry->ppsPageArray,
-							pgprot);
-	if (eError != PVRSRV_OK)
-		goto eExit;
-#endif
+	psCleanupThreadFn->pfnFree = _CleanupThread_FreePoolPages;
+	psCleanupThreadFn->pvData = psCleanupThreadFn;
+	psCleanupThreadFn->ui32RetryCount = CLEANUP_THREAD_RETRY_COUNT_DEFAULT;
+	/* We must not hold the pool lock when calling AddWork because it might call us back to
+	 * free pooled pages directly when unloading the driver	 */
+	PVRSRVCleanupThreadAddWork(psCleanupThreadFn);
 
-	/* Lock down pool and add item */
-	_PagePoolLock();
+	return;
 
-	/* Pool counters were already updated so don't do it here again*/
+e_oom_exit:
+	{
+		/* In case we are not able to signal the defer free thread
+		 * we have to cleanup the pool now. */
+		IMG_UINT32 uiPagesFreed;
 
-	list_add_tail(&psPagePoolEntry->sPagePoolItem, psPoolHead);
+		_PagePoolLock();
+		if (_FreePagesFromPoolUnlocked(g_ui32PagePoolEntryCount - g_ui32PagePoolMaxEntries,
+									   &uiPagesFreed) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+					 "%s: Unable to free pooled pages!",
+					 __FUNCTION__));
+		}
+		_PagePoolUnlock();
 
-	_DumpPoolStructure();
-	_PagePoolUnlock();
+		return;
+	}
+}
 
-	OSFreeMem(pvData);
-	OSAtomicDecrement(&g_iPoolCleanTasks);
+/* Moves a page array to the page pool.
+ *
+ * If this function is successful the ppsPageArray is unusable and needs to be
+ * reallocated in case the _PMR_OSPAGEARRAY_DATA_ will be reused.
+ * This function expects cached pages to be not in the cache anymore,
+ * invalidate them before, ideally without using the pool lock. */
+static IMG_BOOL
+_PutPagesToPoolUnlocked(IMG_UINT32 ui32CPUCacheFlags,
+						struct page **ppsPageArray,
+						IMG_UINT32 uiEntriesInArray)
+{
+	LinuxPagePoolEntry *psPagePoolEntry;
+	struct list_head *psPoolHead = NULL;
 
-	return PVRSRV_OK;
+	/* Check if there is still space in the pool */
+	if ( (g_ui32PagePoolEntryCount + uiEntriesInArray) >=
+		 (g_ui32PagePoolMaxEntries + g_ui32PagePoolMaxExcessEntries) )
+	{
+		return IMG_FALSE;
+	}
 
-eExit:
-	/* If this was the last retry, give up and free pages to OS */
-	if ((psCleanupData->sCleanupWork.ui32RetryCount - 1) == 0)
+	/* Get the correct list for this caching mode */
+	if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead))
 	{
-		IMG_UINT32 i;
+		return IMG_FALSE;
+	}
 
-		PVR_DPF((PVR_DBG_ERROR,
-						"%s: Deferred task error, freeing pages to OS.",
-						__func__));
-		_PagePoolLock();
+	/* Fill the new pool entry structure and add it to the pool list */
+	psPagePoolEntry = kmem_cache_alloc(g_psLinuxPagePoolCache, GFP_KERNEL);
+	psPagePoolEntry->ppsPageArray = ppsPageArray;
+	psPagePoolEntry->uiItemsRemaining = uiEntriesInArray;
 
-		*puiCounter -= psPagePoolEntry->uiItemsRemaining;
+	list_add_tail(&psPagePoolEntry->sPagePoolItem, psPoolHead);
 
- #if defined(PVRSRV_ENABLE_PROCESS_STATS)
-		/* MemStats usually relies on having the bridge lock held, however */
-		/* the page pool code may call PVRSRVStatsIncrMemAllocPoolStat and */
-		/* PVRSRVStatsDecrMemAllocPoolStat without the bridge lock held, so */
-		/* the page pool lock is used to ensure these calls are mutually */
-		/* exclusive */
-		PVRSRVStatsDecrMemAllocPoolStat(PAGE_SIZE * psCleanupData->psPoolEntry->uiItemsRemaining);
- #endif
+	/* Update counters */
+	g_ui32PagePoolEntryCount += uiEntriesInArray;
 
-		_PagePoolUnlock();
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+	/* MemStats usually relies on having the bridge lock held, however
+	 * the page pool code may call PVRSRVStatsIncrMemAllocPoolStat and
+	 * PVRSRVStatsDecrMemAllocPoolStat without the bridge lock held, so
+	 * the page pool lock is used to ensure these calls are mutually
+	 * exclusive
+	 */
+	PVRSRVStatsIncrMemAllocPoolStat(PAGE_SIZE * uiEntriesInArray);
+#endif
 
-		for (i = 0; i < psCleanupData->psPoolEntry->uiItemsRemaining; i++) {
-			_FreeOSPage(0,
-						IMG_TRUE,
-						psPagePoolEntry->ppsPageArray[i]);
-		}
-		OSFreeMemNoStats(psPagePoolEntry->ppsPageArray);
-		kmem_cache_free(g_psLinuxPagePoolCache, psPagePoolEntry);
-		OSFreeMem(psCleanupData);
-
-		OSAtomicDecrement(&g_iPoolCleanTasks);
-	}
-
-	return eError;
+	_DumpPoolStructure();
+	return IMG_TRUE;
 }
 
+/* Minimal amount of pages that will go to the pool, everything below is freed directly */
+#define PVR_LINUX_PHYSMEM_MIN_PAGES_TO_ADD_TO_POOL 16
 
-/* Put page array to the page pool. */
-/* Handles locking and checks whether the pages are */
-/* suitable to be stored in the pool. */
+/* Same as _PutPagesToPoolUnlocked but handles locking and checks whether the pages are
+ * suitable to be stored in the page pool. */
 static inline IMG_BOOL
 _PutPagesToPoolLocked(IMG_UINT32 ui32CPUCacheFlags,
 					  struct page **ppsPageArray,
@@ -1046,109 +1125,45 @@
 					  IMG_UINT32 uiOrder,
 					  IMG_UINT32 uiNumPages)
 {
-	LinuxCleanupData *psCleanupData;
-	PVRSRV_CLEANUP_THREAD_WORK *psCleanupThreadFn;
-
 	if (uiOrder == 0 &&
 		!bUnpinned &&
-		!PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags)) {
-		IMG_UINT32 uiEntries;
-		IMG_UINT32 *puiCounter;
-		struct list_head *psPoolHead;
-
+		uiNumPages >= PVR_LINUX_PHYSMEM_MIN_PAGES_TO_ADD_TO_POOL)
+	{
 		_PagePoolLock();
 
-		uiEntries = _PagesInPoolUnlocked();
-
-		/* Check for number of current page pool entries and whether */
-		/* we have other asynchronous tasks in-flight */
-		if ((uiEntries < g_ui32PagePoolMaxEntries) &&
-			((uiEntries + uiNumPages) <
-			(g_ui32PagePoolMaxEntries + g_ui32PagePoolMaxExcessEntries))) {
-			if (OSAtomicIncrement(&g_iPoolCleanTasks) <=
-					PVR_LINUX_PHYSMEM_MAX_ASYNC_CLEAN_TASKS) {
-				psCleanupData = OSAllocMem(sizeof(*psCleanupData));
-
-				if (!psCleanupData) {
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get memory for deferred page pool cleanup. "
-							 "Trying to free pages immediately",
-							 __FUNCTION__));
-					goto eDecrement;
-				}
-
-				psCleanupThreadFn = &psCleanupData->sCleanupWork;
-				psCleanupData->ui32CPUCacheMode = ui32CPUCacheFlags;
-				psCleanupData->psPoolEntry = kmem_cache_alloc(g_psLinuxPagePoolCache, GFP_KERNEL);
-
-				if (!psCleanupData->psPoolEntry) {
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get memory for deferred page pool cleanup. "
-							 "Trying to free pages immediately",
-							 __FUNCTION__));
-					goto eFreeCleanupData;
-				}
-
-				if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead, &puiCounter)) {
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get correct page pool",
-							 __FUNCTION__));
-					goto eFreePoolEntry;
-				}
-
-				/* Increase counter here to avoid deferred cleanup tasks piling up */
-				*puiCounter = *puiCounter + uiNumPages;
-
-				psCleanupData->psPoolEntry->ppsPageArray = ppsPageArray;
-				psCleanupData->psPoolEntry->uiItemsRemaining = uiNumPages;
-
-				psCleanupThreadFn->pfnFree = _CleanupThread_CleanPages;
-				psCleanupThreadFn->pvData = psCleanupData;
-				psCleanupThreadFn->ui32RetryCount = CLEANUP_THREAD_RETRY_COUNT_DEFAULT;
-				/* psCleanupThreadFn->bDependsOnHW = IMG_FALSE; */
-	#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-				/* MemStats usually relies on having the bridge lock held, however */
-				/* the page pool code may call PVRSRVStatsIncrMemAllocPoolStat and */
-				/* PVRSRVStatsDecrMemAllocPoolStat without the bridge lock held, so */
-				/* the page pool lock is used to ensure these calls are mutually */
-				/* exclusive */
-				PVRSRVStatsIncrMemAllocPoolStat(PAGE_SIZE * uiNumPages);
-	#endif
-
-				/* We must not hold the pool lock when calling AddWork because it might call us back to
-				 * free pooled pages directly when unloading the driver	 */
+		/* Try to quickly move page array to the pool */
+		if (_PutPagesToPoolUnlocked(ui32CPUCacheFlags,
+									ppsPageArray,
+									uiNumPages) )
+		{
+			if (g_ui32PagePoolEntryCount > (g_ui32PagePoolMaxEntries + g_ui32PagePoolMaxEntries_5Percent))
+			{
+				/* Signal defer free to clean up excess pages from pool.
+				 * Allow a little excess before signalling to avoid oscillating behaviour */
 				_PagePoolUnlock();
+				_SignalDeferFree();
+			}
+			else
+			{
+				_PagePoolUnlock();
+			}
 
-				PVRSRVCleanupThreadAddWork(psCleanupThreadFn);
+			/* All done */
+			return IMG_TRUE;
+		}
 
-			} else
-				goto eDecrement;
+		/* Could not move pages to pool, continue and free them now  */
+		_PagePoolUnlock();
+	}
 
-		} else
-			goto eUnlock;
-	} else
-		goto eExitFalse;
-
-	return IMG_TRUE;
-
-eFreePoolEntry:
-	OSFreeMem(psCleanupData->psPoolEntry);
-eFreeCleanupData:
-	OSFreeMem(psCleanupData);
-eDecrement:
-	OSAtomicDecrement(&g_iPoolCleanTasks);
-eUnlock:
-	_PagePoolUnlock();
-eExitFalse:
 	return IMG_FALSE;
 }
 
 /* Get the GFP flags that we pass to the page allocator */
 static inline unsigned int
-_GetGFPFlags(IMG_BOOL bZero,
-					PVRSRV_DEVICE_NODE *psDevNode)
+_GetGFPFlags(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 {
-	struct device *psDev = psDevNode->psDevConfig->pvOSDevice;
+	struct device *psDev = psPageArrayData->psDevNode->psDevConfig->pvOSDevice;
 	unsigned int gfp_flags = 0;
 	gfp_flags = GFP_USER | __GFP_NOWARN | __GFP_NOMEMALLOC;
 
@@ -1170,8 +1185,10 @@
 		gfp_flags |= __GFP_HIGHMEM;
 	}
 
-	if (bZero)
+	if (psPageArrayData->bZero)
+	{
 		gfp_flags |= __GFP_ZERO;
+	}
 
 	return gfp_flags;
 }
@@ -1368,72 +1385,46 @@
 					   IMG_BOOL bFlush)
 {
 	PVRSRV_ERROR eError = PVRSRV_ERROR_RETRY;
-	void *pvAddr;
+	IMG_UINT32 ui32Idx;
 
-
-	if ((uiNumPages << PAGE_SHIFT) >= PVR_DIRTY_BYTES_FLUSH_THRESHOLD) {
+	if ((uiNumPages << PAGE_SHIFT) >= PVR_DIRTY_BYTES_FLUSH_THRESHOLD)
+	{
 		/* May fail so fallback to range-based flush */
 		eError = OSCPUOperation(PVRSRV_CACHE_OP_FLUSH);
 	}
 
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
+	{
+		for (ui32Idx = 0; ui32Idx < uiNumPages;  ++ui32Idx)
+		{
+			IMG_CPU_PHYADDR sCPUPhysAddrStart, sCPUPhysAddrEnd;
+			void *pvPageVAddr;
 
-		if (OSCPUCacheOpAddressType(PVRSRV_CACHE_OP_FLUSH) == PVRSRV_CACHE_OP_ADDR_TYPE_VIRTUAL) {
-			pgprot_t pgprot = PAGE_KERNEL;
+			pvPageVAddr = kmap(ppsPage[ui32Idx]);
+			sCPUPhysAddrStart.uiAddr = page_to_phys(ppsPage[ui32Idx]);
+			sCPUPhysAddrEnd.uiAddr = sCPUPhysAddrStart.uiAddr + PAGE_SIZE;
 
-			IMG_UINT32 uiNumToClean = uiNumPages;
-			struct page **ppsCleanArray = ppsPage;
-
-			/* Map and flush page.
-			 * For large page arrays do it PVR_LINUX_PHYSMEM_MAX_KMAP_SIZE
-			 * at a time. */
-			while (uiNumToClean != 0) {
-				IMG_UINT32 uiToClean = (uiNumToClean >= PVR_LINUX_PHYSMEM_MAX_KMAP_PAGES) ?
-											PVR_LINUX_PHYSMEM_MAX_KMAP_PAGES :
-											uiNumToClean;
-				IMG_CPU_PHYADDR sCPUPhysAddrStart, sCPUPhysAddrEnd;
-
-				pvAddr = vm_map_ram(ppsCleanArray, uiToClean, -1, pgprot);
-				if (!pvAddr) {
-					PVR_DPF((PVR_DBG_ERROR,
-							"Unable to flush page cache for new allocation, skipping flush."));
-					return;
-				}
-
+			/* If we're zeroing, we need to make sure the cleared memory is pushed out
+			   of the cache before the cache lines are invalidated */
+			if (bFlush)
+			{
 				OSFlushCPUCacheRangeKM(psDevNode,
-									   pvAddr,
-									   pvAddr + PAGE_SIZE,
+									   pvPageVAddr,
+									   pvPageVAddr + PAGE_SIZE,
 									   sCPUPhysAddrStart,
 									   sCPUPhysAddrEnd);
-
-				vm_unmap_ram(pvAddr, uiToClean);
-
-				ppsCleanArray = &(ppsCleanArray[uiToClean]);
-				uiNumToClean -= uiToClean;
 			}
-		} else {
-			IMG_UINT32 ui32Idx;
-
-			for (ui32Idx = 0; ui32Idx < uiNumPages;  ++ui32Idx)
+			else
 			{
-				IMG_CPU_PHYADDR sCPUPhysAddrStart, sCPUPhysAddrEnd;
+				OSInvalidateCPUCacheRangeKM(psDevNode,
+											pvPageVAddr,
+											pvPageVAddr + PAGE_SIZE,
+											sCPUPhysAddrStart,
+											sCPUPhysAddrEnd);
+			}
 
-				pvAddr = kmap(ppsPage[ui32Idx]);
-				sCPUPhysAddrStart.uiAddr = page_to_phys(ppsPage[ui32Idx]);
-				sCPUPhysAddrEnd.uiAddr = sCPUPhysAddrStart.uiAddr + PAGE_SIZE;
-
-				/* If we're zeroing, we need to make sure the cleared memory is pushed out
-				   of the cache before the cache lines are invalidated */
-				OSFlushCPUCacheRangeKM(psDevNode,
-									   pvAddr,
-									   pvAddr + PAGE_SIZE,
-									   sCPUPhysAddrStart,
-									   sCPUPhysAddrEnd);
-
-				kunmap(ppsPage[ui32Idx]);
-			}
+			kunmap(ppsPage[ui32Idx]);
 		}
-
 	}
 }
 
@@ -1497,23 +1488,26 @@
 		}
 		else
 #endif
+		/* Cache maintenance if:
+		 *     cached && (cleanFlag || bFlush)
+		 * OR
+		 *     uncached || write-combine
+		 */
+		if ( (bCPUCached && (PVRSRV_CHECK_CPU_CACHE_CLEAN(ui32CPUCacheFlags) || bFlush)) ||
+		      bCPUUncached || bCPUWriteCombine )
 		{
-			if (bFlush ||
-				bCPUUncached || bCPUWriteCombine ||
-				(bCPUCached && PVRSRV_CHECK_CPU_CACHE_CLEAN(ui32CPUCacheFlags))) {
-				/*  We can be given pages which still remain in the cache.
-					In order to make sure that the data we write through our mappings
-					doesn't get overwritten by later cache evictions we invalidate the
-					pages that are given to us.
+			/*  We can be given pages which still remain in the cache.
+				In order to make sure that the data we write through our mappings
+				doesn't get overwritten by later cache evictions we invalidate the
+				pages that are given to us.
 
-					Note:
-					This still seems to be true if we request cold pages, it's just less
-					likely to be in the cache. */
-				_ApplyCacheMaintenance(psDevNode,
-									   ppsPage,
-									   uiNumPages,
-									   bFlush);
-			}
+				Note:
+				This still seems to be true if we request cold pages, it's just less
+				likely to be in the cache. */
+			_ApplyCacheMaintenance(psDevNode,
+								   ppsPage,
+								   uiNumPages,
+								   bFlush);
 		}
 	}
 
@@ -1647,8 +1641,7 @@
 	IMG_UINT32 uiPagesToAlloc;
 	IMG_UINT32 uiPagesFromPool = 0;
 
-	unsigned int gfp_flags = _GetGFPFlags(ui32MinOrder ? psPageArrayData->bZero : IMG_FALSE, /* Zero all pages later as batch */
-										psPageArrayData->psDevNode);
+	unsigned int gfp_flags = _GetGFPFlags(psPageArrayData);
 	IMG_UINT32 ui32GfpFlags;
 	IMG_UINT32 ui32HighOrderGfpFlags = ((gfp_flags & ~__GFP_RECLAIM) | __GFP_NORETRY);
 
@@ -1806,17 +1799,6 @@
 		}
 	}
 
-	if (psPageArrayData->bZero && ui32MinOrder == 0) {
-		eError = _ZeroPageArray(uiPagesToAlloc - uiPagesFromPool,
-					   ppsPageAttributeArray,
-					   PAGE_KERNEL);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR, "Failed to zero pages"));
-			goto e_free_pages;
-		}
-	}
-
-
 	/* Do the cache management as required */
 	eError = _ApplyOSPagesAttribute(psPageArrayData->psDevNode,
 									ppsPageAttributeArray,
@@ -1823,12 +1805,17 @@
 									uiPagesToAlloc - uiPagesFromPool,
 									psPageArrayData->bZero,
 									psPageArrayData->ui32CPUCacheFlags);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
+	{
 		PVR_DPF((PVR_DBG_ERROR, "Failed to set page attributes"));
 		goto e_free_pages;
-	} else {
+	}
+	else
+	{
 		if (psPageArrayData->bIsCMA)
+		{
 			OSFreeMem(ppsPageAttributeArray);
+		}
 	}
 
 	/* Update metadata */
@@ -1840,15 +1827,19 @@
 	{
 		IMG_UINT32 ui32PageToFree;
 
-		if (psPageArrayData->bIsCMA) {
+		if (psPageArrayData->bIsCMA)
+		{
 			IMG_UINT32 uiDevArrayIndex = uiArrayIndex >> ui32Order;
 			IMG_UINT32 uiDevPageSize = PAGE_SIZE << ui32Order;
 			PVR_ASSERT(ui32Order == ui32MinOrder);
 
 			if (ppsPageAttributeArray)
+			{
 				OSFreeMem(ppsPageAttributeArray);
+			}
 
-			for (ui32PageToFree = 0; ui32PageToFree < uiDevArrayIndex; ui32PageToFree++) {
+			for (ui32PageToFree = 0; ui32PageToFree < uiDevArrayIndex; ui32PageToFree++)
+			{
 				_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
 								uiDevPageSize,
 								ui32MinOrder,
@@ -1859,9 +1850,12 @@
 				psPageArrayData->dmavirtarray[ui32PageToFree] = NULL;
 				ppsPageArray[ui32PageToFree] = INVALID_PAGE;
 			}
-		} else {
+		}
+		else
+		{
 			/* Free the pages we got from the pool */
-			for (ui32PageToFree = 0; ui32PageToFree < uiPagesFromPool; ui32PageToFree++) {
+			for(ui32PageToFree = 0; ui32PageToFree < uiPagesFromPool; ui32PageToFree++)
+			{
 				_FreeOSPage(ui32MinOrder,
 							psPageArrayData->bUnsetMemoryType,
 							ppsPageArray[ui32PageToFree]);
@@ -1868,7 +1862,8 @@
 				ppsPageArray[ui32PageToFree] = INVALID_PAGE;
 			}
 
-			for (ui32PageToFree = uiPagesFromPool; ui32PageToFree < uiArrayIndex; ui32PageToFree++) {
+			for (ui32PageToFree = uiPagesFromPool; ui32PageToFree < uiArrayIndex; ui32PageToFree++)
+			{
 				_FreeOSPage(ui32MinOrder, IMG_FALSE, ppsPageArray[ui32PageToFree]);
 				ppsPageArray[ui32PageToFree] = INVALID_PAGE;
 			}
@@ -1892,10 +1887,9 @@
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
 	struct page **ppsPageArray = psPageArrayData->pagearray;
-	IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+	IMG_UINT32 uiOrder;
 	IMG_UINT32 uiPagesFromPool = 0;
-	unsigned int gfp_flags = _GetGFPFlags(uiOrder ? psPageArrayData->bZero : IMG_FALSE, /* Zero pages later as batch */
-											psPageArrayData->psDevNode);
+	unsigned int gfp_flags = _GetGFPFlags(psPageArrayData);
 
 	 /* We use this page array to receive pages from the pool and then reuse it afterwards to
 	 * store pages that need their cache attribute changed on x86*/
@@ -1912,6 +1906,8 @@
 		goto e_exit;
 	}
 
+	uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+
 	/* Check the requested number of pages if they fit in the page array */
 	if(psPageArrayData->uiTotalNumPages < \
 				(psPageArrayData->iNumPagesAllocated + uiPagesToAlloc))
@@ -1999,16 +1995,6 @@
 	}
 	EnableOOMKiller();
 
-	if (psPageArrayData->bZero && uiOrder == 0) {
-		eError = _ZeroPageArray(uiTempPageArrayIndex,
-								ppsTempPageArray,
-								PAGE_KERNEL);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR, "Failed to zero pages"));
-			goto e_free_pages;
-		}
-	}
-
 	/* Do the cache management as required */
 	eError = _ApplyOSPagesAttribute(psPageArrayData->psDevNode,
 									ppsTempPageArray,
@@ -2015,7 +2001,8 @@
 									uiTempPageArrayIndex,
 									psPageArrayData->bZero,
 									psPageArrayData->ui32CPUCacheFlags);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
+	{
 		PVR_DPF((PVR_DBG_ERROR, "Failed to set page attributes"));
 		goto e_free_pages;
 	}
@@ -2035,7 +2022,8 @@
 		EnableOOMKiller();
 
 		/* Free the pages we got from the pool */
-		for (ui32PageToFree = 0; ui32PageToFree < uiPagesFromPool; ui32PageToFree++) {
+		for(ui32PageToFree = 0; ui32PageToFree < uiPagesFromPool; ui32PageToFree++)
+		{
 			_FreeOSPage(0,
 						psPageArrayData->bUnsetMemoryType,
 						ppsTempPageArray[ui32PageToFree]);
@@ -2042,7 +2030,8 @@
 		}
 
 		/* Free the pages we just allocated from the OS */
-		for (ui32PageToFree = uiPagesFromPool; ui32PageToFree < i; ui32PageToFree++) {
+		for(ui32PageToFree = uiPagesFromPool; ui32PageToFree < i; ui32PageToFree++)
+		{
 			_FreeOSPage(0,
 						IMG_FALSE,
 						ppsPageArray[puiAllocIndices[ui32PageToFree]]);
@@ -2299,6 +2288,22 @@
 	ppsPageArray = psPageArrayData->pagearray;
 	uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
 
+	/* Poison if necessary */
+	if (psPageArrayData->bPoisonOnFree)
+	{
+		for (i  = 0; i  < uiNumPages; i ++)
+		{
+			uiPageIndex = pai32FreeIndices ? pai32FreeIndices[i] : i ;
+			if(INVALID_PAGE != ppsPageArray[uiPageIndex])
+			{
+				_PoisonPages(ppsPageArray[uiPageIndex],
+							 0,
+							 _FreePoison,
+							 _FreePoisonSize);
+			}
+		}
+	}
+
 	/* Put pages in a contiguous array so further processing is easier */
 	uiTempIdx = 0;
 	for (i = 0; i < uiNumPages; i++)
@@ -2323,30 +2328,25 @@
 		goto exit_ok;
 	}
 
-	/* Poison if necessary */
-	if (psPageArrayData->bPoisonOnFree) {
-		for (i = 0; i < uiTempIdx; i++) {
-				_PoisonPages(ppsTempPageArray[i],
-							 0,
-							 _FreePoison,
-							 _FreePoisonSize);
-		}
-	}
-
 	/* Free pages and reset page caching attributes on x86 */
 #if defined(CONFIG_X86)
-	if (uiTempIdx != 0 && psPageArrayData->bUnsetMemoryType == IMG_TRUE) {
+	if (uiTempIdx != 0 && psPageArrayData->bUnsetMemoryType == IMG_TRUE)
+	{
 		int iError;
 		iError = set_pages_array_wb(ppsTempPageArray, uiTempIdx);
 
 		if (iError)
+		{
 			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attributes", __FUNCTION__));
+		}
 	}
 #endif
 
 	/* Free the pages */
 	for (i = 0; i < uiTempIdx; i++)
+	{
 		__free_pages(ppsTempPageArray[i], uiOrder);
+	}
 
 	/* Free the temp page array here if it did not move to the pool */
 	OSFreeMemNoStats(ppsTempPageArray);
@@ -2373,6 +2373,17 @@
 	/* We really should have something to free before we call this */
 	PVR_ASSERT(psPageArrayData->iNumPagesAllocated != 0);
 
+	/* Poison pages if necessary */
+	if (psPageArrayData->bPoisonOnFree)
+	{
+		for (i = 0; i < uiNumPages; i++)
+		{
+			_PoisonPages(ppsPageArray[i],
+						 0,
+						 _FreePoison,
+						 _FreePoisonSize);
+		}
+	}
 
 	/* Try to move the page array to the pool */
 	bSuccess = _PutPagesToPoolLocked(psPageArrayData->ui32CPUCacheFlags,
@@ -2386,16 +2397,6 @@
 		goto exit_ok;
 	}
 
-	/* Poison pages if necessary */
-	if (psPageArrayData->bPoisonOnFree) {
-		for (i = 0; i < uiNumPages; i++) {
-			_PoisonPages(ppsPageArray[i],
-						 0,
-						 _FreePoison,
-						 _FreePoisonSize);
-		}
-	}
-
 	if (psPageArrayData->bIsCMA)
 	{
 		IMG_UINT32 uiDevNumPages = uiNumPages >> uiOrder;
@@ -2880,8 +2881,8 @@
 	IMG_UINT32 ui32Index = 0;
 	IMG_UINT32 uiAllocpgidx ;
 	IMG_UINT32 uiFreepgidx;
+	IMG_UINT32 ui32Order =  psPMRPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
 
-
 	/* Check SPARSE flags and calculate pages to allocate and free */
 	if (SPARSE_RESIZE_BOTH == (uiFlags & SPARSE_RESIZE_BOTH))
 	{
@@ -3039,6 +3040,27 @@
 			psPMRMapTable->aui32Translation[uiFreepgidx] = uiFreepgidx;
 			psPMRMapTable->aui32Translation[uiAllocpgidx] = uiAllocpgidx;
 		}
+
+		/* Be sure to honour the attributes associated with the allocation
+		 * such as zeroing, poisoning etc. */
+		if (psPMRPageArrayData->bPoisonOnAlloc)
+		{
+			_PoisonPages(psPageArray[uiAllocpgidx],
+			             ui32Order,
+			             _AllocPoison,
+			             _AllocPoisonSize);
+		}
+		else
+		{
+			if (psPMRPageArrayData->bZero)
+			{
+				char a = 0;
+				_PoisonPages(psPageArray[uiAllocpgidx],
+				             ui32Order,
+				             &a,
+				             1);
+			}
+		}
 	}
 
 	/* Free the additional free pages */
@@ -3184,12 +3206,6 @@
 		goto errorOnParam;
 	}
 
-#if defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
-	/* Overwrite flags and always zero pages that could go back to UM */
-	bZero = IMG_TRUE;
-	bPoisonOnAlloc = IMG_FALSE;
-#endif
-
 	/* Create Array structure that hold the physical pages */
 	eError = _AllocOSPageArray(psDevNode,
 							   uiChunkSize,
Index: vendor/ausshine/libs/libmtk-art-runtime/arm64/libmtk-art-runtime.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/ausshine/libs/libmtk-art-runtime/arm/libmtk-art-runtime.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/ausshine/libs/libmtk-art-runtimed/arm64/libmtk-art-runtimed.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/ausshine/libs/libmtk-art-runtimed/x86_64/libmtk-art-runtimed.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/ausshine/libs/libmtk-art-runtimed/arm/libmtk-art-runtimed.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/ausshine/libs/libmtk-art-runtimed/x86/libmtk-art-runtimed.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user/rgx.fw.signed.22.49.21.16
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user/libsrv_um.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user/libGLESv2_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/pvrsrvctl
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/rgx.fw.signed.22.49.21.16
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/pvrtld
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/libIMGegl.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/pvrdebug
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/libpvrANDROID_WSEGL.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/libsrv_um.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/libGLESv2_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/hwperfbin2jsont
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/hwcomposer.rogue.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/pvrhtb2txt
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/sensors.rogue.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng64/libGLESv1_CM_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/sensors.rogue.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/libGLESv1_CM_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/pvrsrvctl
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/rgx.fw.signed.22.49.21.16
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/libIMGegl.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/pvrtld
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/pvrdebug
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/libpvrANDROID_WSEGL.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/libsrv_um.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/hwperfbin2jsont
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/libGLESv2_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/hwcomposer.rogue.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/user64/pvrhtb2txt
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng/rgx.fw.signed.22.49.21.16
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng/libsrv_um.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/hardware/gpu_img/rgx/mt6739/eng/libGLESv2_mtk.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
