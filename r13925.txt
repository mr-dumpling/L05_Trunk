Index: vendor/branch/5058I/packages/apps/Settings/src/com/android/settings/datausage/CellDataPreference.java
===================================================================
--- vendor/branch/5058I/packages/apps/Settings/src/com/android/settings/datausage/CellDataPreference.java	(revision 0)
+++ vendor/branch/5058I/packages/apps/Settings/src/com/android/settings/datausage/CellDataPreference.java	(revision 13925)
@@ -0,0 +1,514 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.android.settings.datausage;
+
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.NetworkPolicyManager;
+import android.net.NetworkTemplate;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.provider.Settings.Global;
+import android.support.v7.preference.PreferenceViewHolder;
+import android.telecom.TelecomManager;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.widget.Checkable;
+import android.widget.Toast;
+
+import com.android.internal.logging.MetricsLogger;
+import com.android.internal.logging.MetricsProto.MetricsEvent;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.settings.CustomDialogPreference;
+import com.android.settings.R;
+import com.android.settings.Utils;
+import com.android.settings.sim.SimDialogActivity;
+import com.mediatek.settings.UtilsExt;
+import com.mediatek.settings.cdma.CdmaUtils;
+import com.mediatek.settings.ext.IDataUsageSummaryExt;
+import com.mediatek.settings.sim.TelephonyUtils;
+
+import java.util.List;
+
+public class CellDataPreference extends CustomDialogPreference implements TemplatePreference {
+
+    private static final String TAG = "CellDataPreference";
+
+    public int mSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+    public boolean mChecked;
+    public boolean mMultiSimDialog;
+    private TelephonyManager mTelephonyManager;
+    private SubscriptionManager mSubscriptionManager;
+
+    public CellDataPreference(Context context, AttributeSet attrs) {
+        super(context, attrs, android.R.attr.switchPreferenceStyle);
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Parcelable s) {
+        CellDataState state = (CellDataState) s;
+        super.onRestoreInstanceState(state.getSuperState());
+        mTelephonyManager = TelephonyManager.from(getContext());
+        mChecked = state.mChecked;
+        mMultiSimDialog = state.mMultiSimDialog;
+        if (mSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            mSubId = state.mSubId;
+            setKey(getKey() + mSubId);
+        }
+        notifyChanged();
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        CellDataState state = new CellDataState(super.onSaveInstanceState());
+        state.mChecked = mChecked;
+        state.mMultiSimDialog = mMultiSimDialog;
+        state.mSubId = mSubId;
+        return state;
+    }
+
+    @Override
+    public void onAttached() {
+        log("onAttached...");
+        super.onAttached();
+
+        /// M: for plug-in @{
+        mDataUsageSummaryExt = UtilsExt.getDataUsageSummaryPlugin(getContext()
+                .getApplicationContext());
+
+        mListener.setListener(true, mSubId, getContext());
+        /// M: check airplane mode
+        mIsAirplaneModeOn = TelephonyUtils.isAirplaneModeOn(getContext());
+
+        /// M: observe more event @{
+        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        /// M: [C2K solution2 enhancement] @{
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE);
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_FAILED);
+        intentFilter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
+        /// @}
+
+        /// M: for cmcc plugin, when is cmcc + other card,
+        /// cmcc card data enable, other disable data
+        mDataUsageSummaryExt.customReceiver(intentFilter);
+        /// @}
+
+        getContext().registerReceiver(mReceiver, intentFilter);
+        /// @}
+
+        /// M: check enabled condition
+        updateScreenEnableState();
+
+        /// M: for plug-in OP07 @{
+        if (mDataUsageSummaryExt != null) {
+            mDataUsageSummaryExt.setPreferenceSummary(this);
+        }
+    }
+
+    @Override
+    public void onDetached() {
+        log("onDetached...");
+        mListener.setListener(false, mSubId, getContext());
+        super.onDetached();
+        /// M:
+        getContext().unregisterReceiver(mReceiver);
+        /// M: For CR ALPS02994620, to fix notify timing issue, reset this flag.
+        mAlertForCdmaCompetition = false;
+    }
+
+    @Override
+    public void setTemplate(NetworkTemplate template, int subId, NetworkServices services) {
+        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            throw new IllegalArgumentException("CellDataPreference needs a SubscriptionInfo");
+        }
+        mSubscriptionManager = SubscriptionManager.from(getContext());
+        mTelephonyManager = TelephonyManager.from(getContext());
+        if (mSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            mSubId = subId;
+            setKey(getKey() + subId);
+        }
+        updateChecked();
+    }
+
+    private void updateChecked() {
+        SubscriptionInfo sir = mSubscriptionManager.getDefaultDataSubscriptionInfo();
+        SubscriptionManager subscriptionManager = SubscriptionManager.from(getContext());
+        int subId = subscriptionManager.getDefaultDataSubscriptionId();
+        if (sir == null) {
+            setChecked(false);
+        } else if (subId == mSubId) {
+            setChecked(mTelephonyManager.getDataEnabled(mSubId));
+        } else {
+            setChecked(false);
+        }
+    }
+
+    private void createRoamingDialog(boolean enabled) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
+		builder.setTitle(R.string.warning);
+		builder.setMessage(R.string.data_roam_warning_message);
+		builder.setIcon(com.android.internal.R.drawable.stat_sys_warning);		
+		builder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+			
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				// TODO Auto-generated method stub
+				mTelephonyManager.setDataEnabled(mSubId, enabled);
+                setChecked(enabled);
+                Global.putInt(getContext().getContentResolver(), Global.DATA_ROAMING, 1);
+			}
+		});
+		builder.setNegativeButton(R.string.cacel, new DialogInterface.OnClickListener() {
+			
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				// TODO Auto-generated method stub
+				dialog.dismiss();
+			}
+		});
+		AlertDialog d = builder.create();
+		d.show();
+    }
+	
+    @Override
+    protected void performClick(View view) {
+        log("performClick, checked = " + mChecked);
+        MetricsLogger.action(getContext(), MetricsEvent.ACTION_CELL_DATA_TOGGLE, !mChecked);
+        final SubscriptionInfo currentSir = mSubscriptionManager.getActiveSubscriptionInfo(
+                mSubId);
+        final SubscriptionInfo nextSir = mSubscriptionManager.getDefaultDataSubscriptionInfo();
+        if (mChecked) {
+            // If the device is single SIM or is enabling data on the active data SIM then forgo
+            // the pop-up.
+            if (!Utils.showSimCardTile(getContext()) ||
+                    (nextSir != null && currentSir != null &&
+                            currentSir.getSubscriptionId() == nextSir.getSubscriptionId())) {
+                setMobileDataEnabled(false);
+                if (nextSir != null && currentSir != null &&
+                        currentSir.getSubscriptionId() == nextSir.getSubscriptionId() &&
+                        mDataUsageSummaryExt.isAllowDataDisableForOtherSubscription()) {
+                    disableDataForOtherSubscriptions(mSubId);
+                }
+                return;
+            }
+
+            // disabling data; show confirmation dialog which eventually
+            // calls setMobileDataEnabled() once user confirms.
+            mMultiSimDialog = false;
+            super.performClick(view);
+        } else {
+            // If we are showing the Sim Card tile then we are a Multi-Sim device.
+            /// M: Don't show dialog when enable default data sim and null sim.
+            if (Utils.showSimCardTile(getContext()) && currentSir != null && (nextSir != null &&
+                    currentSir.getSubscriptionId() != nextSir.getSubscriptionId()
+                    || nextSir == null)) {
+                /// M: [C2K solution 2 enhancement] @{
+                // start a dialog for cdma competition before switch default data
+                if (CdmaUtils.isCdmaCardCompetionForData(getContext())) {
+                    log("alert Cdma Competition..., subId = " + mSubId);
+                    CdmaUtils.startAlertCdmaDialog(getContext(), mSubId,
+                            SimDialogActivity.DATA_PICK);
+                    mAlertForCdmaCompetition = true;
+                    return;
+                }
+                /// @}
+                mMultiSimDialog = true;
+                if (nextSir != null && currentSir != null &&
+                        currentSir.getSubscriptionId() == nextSir.getSubscriptionId()) {
+                    setMobileDataEnabled(true);
+                    if(mDataUsageSummaryExt.isAllowDataDisableForOtherSubscription()) {
+                        disableDataForOtherSubscriptions(mSubId);
+                    }
+                    return;
+                }
+                super.performClick(view);
+            } else {
+                setMobileDataEnabled(true);
+            }
+        }
+    }
+
+    private void setMobileDataEnabled(boolean enabled) {
+        if (DataUsageSummary.LOGD) log("setMobileDataEnabled(" + enabled + ","
+                + mSubId + ")");
+        
+        boolean isRoam = mTelephonyManager.isNetworkRoaming();        
+        boolean isDataRoamingEnabled = Global.getInt(getContext().getContentResolver(), Global.DATA_ROAMING, 0) == 1;//if data roaming switch open
+
+        log("xiawei isRoam = " + isRoam + ",isDataRoamingEnabled = "+ isDataRoamingEnabled);
+        if (isRoam && !isDataRoamingEnabled && enabled) {
+            createRoamingDialog(true);
+        } else {
+            mTelephonyManager.setDataEnabled(mSubId, enabled);
+            setChecked(enabled);
+        }
+    }
+
+    private void setChecked(boolean checked) {
+        log("setChecked " + checked);
+        if (mChecked == checked) return;
+        mChecked = checked;
+        notifyChanged();
+    }
+
+    @Override
+    public void onBindViewHolder(PreferenceViewHolder holder) {
+        super.onBindViewHolder(holder);
+        View switchView = holder.findViewById(android.R.id.switch_widget);
+		
+		TelephonyManager telMgr = (TelephonyManager)
+                getContext().getSystemService(Context.TELEPHONY_SERVICE);
+        int simState = telMgr.getSimState();
+        boolean result = true;
+        switch (simState) {
+            case TelephonyManager.SIM_STATE_ABSENT:
+                result = false; // no SIM card
+                break;
+            case TelephonyManager.SIM_STATE_UNKNOWN:
+                result = false;
+                break;
+        }
+		log("chaoxuhai getSimState = " + result);
+		if(result == false){
+			mChecked = false;
+		}
+        switchView.setClickable(false);
+        ((Checkable) switchView).setChecked(mChecked);
+
+        /// M: for plug-in to customize onClickListener @{
+        mDataUsageSummaryExt.onBindViewHolder(getContext(), holder.itemView,
+                new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                performClick(v);
+            }
+        });
+        /// @}
+    }
+
+    @Override
+    protected void onPrepareDialogBuilder(AlertDialog.Builder builder,
+            DialogInterface.OnClickListener listener) {
+        if (mMultiSimDialog) {
+            showMultiSimDialog(builder, listener);
+        } else {
+            /// M: for plug-in
+            if (mDataUsageSummaryExt.onDisablingData(mSubId)) {
+                showDisableDialog(builder, listener);
+            }
+        }
+    }
+
+    private void showDisableDialog(AlertDialog.Builder builder,
+            DialogInterface.OnClickListener listener) {
+        builder.setTitle(null)
+                .setMessage(R.string.data_usage_disable_mobile)
+                .setPositiveButton(android.R.string.ok, listener)
+                .setNegativeButton(android.R.string.cancel, null);
+    }
+
+    private void showMultiSimDialog(AlertDialog.Builder builder,
+            DialogInterface.OnClickListener listener) {
+        final SubscriptionInfo currentSir = mSubscriptionManager.getActiveSubscriptionInfo(mSubId);
+        final SubscriptionInfo nextSir = mSubscriptionManager.getDefaultDataSubscriptionInfo();
+
+        final String previousName = (nextSir == null)
+            ? getContext().getResources().getString(R.string.sim_selection_required_pref)
+            : nextSir.getDisplayName().toString();
+
+        builder.setTitle(R.string.sim_change_data_title);
+        builder.setMessage(getContext().getString(R.string.sim_change_data_message,
+                String.valueOf(currentSir != null ? currentSir.getDisplayName() : null),
+                previousName));
+
+        builder.setPositiveButton(R.string.okay, listener);
+        builder.setNegativeButton(R.string.cancel, null);
+    }
+
+    private void disableDataForOtherSubscriptions(int subId) {
+        List<SubscriptionInfo> subInfoList = mSubscriptionManager.getActiveSubscriptionInfoList();
+        if (subInfoList != null) {
+            for (SubscriptionInfo subInfo : subInfoList) {
+                if (subInfo.getSubscriptionId() != subId) {
+                    mTelephonyManager.setDataEnabled(subInfo.getSubscriptionId(), false);
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onClick(DialogInterface dialog, int which) {
+        if (which != DialogInterface.BUTTON_POSITIVE) {
+            return;
+        }
+        log("onClick, mMultiSimDialog = " + mMultiSimDialog);
+        if (mMultiSimDialog) {
+            /// M: if in call, do not switch data @{
+            if (TelecomManager.from(getContext()).isInCall()) {
+                Toast.makeText(getContext(), R.string.default_data_switch_err_msg1,
+                        Toast.LENGTH_SHORT).show();
+                log("in Call, RETURN!");
+                return;
+            }
+            /// @}
+
+            mSubscriptionManager.setDefaultDataSubId(mSubId);
+            setMobileDataEnabled(true);
+            if(mDataUsageSummaryExt.isAllowDataDisableForOtherSubscription()) {
+                disableDataForOtherSubscriptions(mSubId);
+            }
+        } else {
+            // TODO: extend to modify policy enabled flag.
+            setMobileDataEnabled(false);
+        }
+    }
+
+    private final DataStateListener mListener = new DataStateListener() {
+        @Override
+        public void onChange(boolean selfChange) {
+            log("data state changed");
+            updateChecked();
+        }
+    };
+
+    public abstract static class DataStateListener extends ContentObserver {
+        public DataStateListener() {
+            super(new Handler(Looper.getMainLooper()));
+        }
+
+        public void setListener(boolean listening, int subId, Context context) {
+            if (listening) {
+                Uri uri = Global.getUriFor(Global.MOBILE_DATA);
+                if (TelephonyManager.getDefault().getSimCount() != 1) {
+                    uri = Global.getUriFor(Global.MOBILE_DATA + subId);
+                }
+                context.getContentResolver().registerContentObserver(uri, false, this);
+            } else {
+                context.getContentResolver().unregisterContentObserver(this);
+            }
+        }
+    }
+
+    public static class CellDataState extends BaseSavedState {
+        public int mSubId;
+        public boolean mChecked;
+        public boolean mMultiSimDialog;
+
+        public CellDataState(Parcelable base) {
+            super(base);
+        }
+
+        public CellDataState(Parcel source) {
+            super(source);
+            mChecked = source.readByte() != 0;
+            mMultiSimDialog = source.readByte() != 0;
+            mSubId = source.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+            dest.writeByte((byte) (mChecked ? 1 : 0));
+            dest.writeByte((byte) (mMultiSimDialog ? 1 : 0));
+            dest.writeInt(mSubId);
+        }
+
+        public static final Creator<CellDataState> CREATOR = new Creator<CellDataState>() {
+            @Override
+            public CellDataState createFromParcel(Parcel source) {
+                return new CellDataState(source);
+            }
+
+            @Override
+            public CellDataState[] newArray(int size) {
+                return new CellDataState[size];
+            }
+        };
+    }
+
+
+    ///------------------------------------MTK------------------------------------------------
+    private boolean mIsAirplaneModeOn;
+    private View mDataEnabled;
+    private IDataUsageSummaryExt mDataUsageSummaryExt;
+
+    /// [C2K solution 2 enhancement] @{
+    // add for c2k solution 2. mark data enable click event.
+    private boolean mAlertForCdmaCompetition = false;
+
+    // add a BroadcastReceiver to update status when the phone states changed
+    // for the MSIM phone.
+   private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+
+       @Override
+       public void onReceive(Context context, Intent intent) {
+
+           String action = intent.getAction();
+           log("onReceive broadcast , action =  " + action);
+
+           if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+              mIsAirplaneModeOn = intent.getBooleanExtra("state", false);
+              updateScreenEnableState();
+           } else if (action.equals(
+                   TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
+               onCdmaCompetitionHandled(intent);
+               updateScreenEnableState();
+            } else if (action.equals(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE)
+                    || action.equals(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_FAILED)
+                    || mDataUsageSummaryExt.customDualReceiver(action)) {
+               updateScreenEnableState();
+           }
+       }
+   };
+
+    private void onCdmaCompetitionHandled(Intent intent) {
+        int defaultDataSubId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+        log("defaultDataSubId: " + defaultDataSubId + " mAlertForCdmaCompetition: "
+                + mAlertForCdmaCompetition);
+        if (mAlertForCdmaCompetition && (defaultDataSubId == mSubId)) {
+            setMobileDataEnabled(true);
+            if(mDataUsageSummaryExt.isAllowDataDisableForOtherSubscription()) {
+                disableDataForOtherSubscriptions(mSubId);
+            }
+            mAlertForCdmaCompetition = false;
+        }
+    }
+
+   private void updateScreenEnableState() {
+        boolean isCapabilitySwitching = TelephonyUtils.isCapabilitySwitching();
+        log("updateScreenEnableState, mIsAirplaneModeOn = " + mIsAirplaneModeOn
+                + ", isCapabilitySwitching = " + isCapabilitySwitching);
+        setEnabled(!mIsAirplaneModeOn && !isCapabilitySwitching
+                && mDataUsageSummaryExt.isAllowDataEnable(mSubId));
+   }
+
+    private void log(String msg) {
+        Log.d(TAG + "[" + mSubId + "]", msg);
+    }
+}
Index: vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/TelephonyIcons.java
===================================================================
--- vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/TelephonyIcons.java	(revision 0)
+++ vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/TelephonyIcons.java	(revision 13925)
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import com.android.systemui.R;
+import com.android.systemui.statusbar.policy.MobileSignalController.MobileIconGroup;
+
+class TelephonyIcons {
+    //***** Signal strength icons
+
+    static final int TELEPHONY_NUM_LEVELS = 5;
+
+    //GSM/UMTS
+    static final int TELEPHONY_NO_NETWORK = R.drawable.stat_sys_signal_null;
+
+    static final int[][] TELEPHONY_SIGNAL_STRENGTH = {
+        { R.drawable.stat_sys_signal_0,
+          R.drawable.stat_sys_signal_1,
+          R.drawable.stat_sys_signal_2,
+          R.drawable.stat_sys_signal_3,
+          R.drawable.stat_sys_signal_4 },
+        { R.drawable.stat_sys_signal_0_fully,
+          R.drawable.stat_sys_signal_1_fully,
+          R.drawable.stat_sys_signal_2_fully,
+          R.drawable.stat_sys_signal_3_fully,
+          R.drawable.stat_sys_signal_4_fully }
+    };
+
+    static final int QS_TELEPHONY_NO_NETWORK = R.drawable.ic_qs_signal_no_signal;
+
+    static final int[][] QS_TELEPHONY_SIGNAL_STRENGTH = {
+        { R.drawable.ic_qs_signal_0,
+          R.drawable.ic_qs_signal_1,
+          R.drawable.ic_qs_signal_2,
+          R.drawable.ic_qs_signal_3,
+          R.drawable.ic_qs_signal_4 },
+        { R.drawable.ic_qs_signal_full_0,
+          R.drawable.ic_qs_signal_full_1,
+          R.drawable.ic_qs_signal_full_2,
+          R.drawable.ic_qs_signal_full_3,
+          R.drawable.ic_qs_signal_full_4 }
+    };
+
+    static final int[][] TELEPHONY_SIGNAL_STRENGTH_ROAMING = {
+        { R.drawable.stat_sys_signal_0,
+          R.drawable.stat_sys_signal_1,
+          R.drawable.stat_sys_signal_2,
+          R.drawable.stat_sys_signal_3,
+          R.drawable.stat_sys_signal_4 },
+        { R.drawable.stat_sys_signal_0_fully,
+          R.drawable.stat_sys_signal_1_fully,
+          R.drawable.stat_sys_signal_2_fully,
+          R.drawable.stat_sys_signal_3_fully,
+          R.drawable.stat_sys_signal_4_fully }
+    };
+
+    //CarrierNetworkChange
+    static final int[][] TELEPHONY_CARRIER_NETWORK_CHANGE = {
+            { R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation },
+            { R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation,
+              R.drawable.stat_sys_signal_carrier_network_change_animation }
+        };
+
+    static final int[][] QS_TELEPHONY_CARRIER_NETWORK_CHANGE = {
+        { R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation },
+        { R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation,
+          R.drawable.ic_qs_signal_carrier_network_change_animation }
+    };
+
+    static final int QS_DATA_R = R.drawable.ic_qs_signal_r;
+
+    //***** Data connection icons
+
+    //GSM/UMTS
+    static final int[][] DATA_G = {
+            { R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g },
+            { R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g,
+              R.drawable.stat_sys_data_fully_connected_g }
+        };
+
+    static final int QS_DATA_G = R.drawable.ic_qs_signal_g;
+
+    static final int[][] DATA_3G = {
+            { R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g },
+            { R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g,
+              R.drawable.stat_sys_data_fully_connected_3g }
+        };
+
+    static final int QS_DATA_3G = R.drawable.ic_qs_signal_3g;
+
+    static final int[][] DATA_E = {
+            { R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e },
+            { R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e,
+              R.drawable.stat_sys_data_fully_connected_e }
+        };
+
+    static final int QS_DATA_E = R.drawable.ic_qs_signal_e;
+
+    //3.5G
+    static final int[][] DATA_H = {
+            { R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h },
+            { R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h,
+              R.drawable.stat_sys_data_fully_connected_h }
+    };
+
+    static final int QS_DATA_H = R.drawable.ic_qs_signal_h;
+
+    //CDMA
+    // Use 3G icons for EVDO data and 1x icons for 1XRTT data
+    static final int[][] DATA_1X = {
+            { R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x },
+            { R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x,
+              R.drawable.stat_sys_data_fully_connected_1x }
+            };
+
+    static final int QS_DATA_1X = R.drawable.ic_qs_signal_1x;
+
+    // LTE and eHRPD
+    static final int[][] DATA_4G = {
+            { R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g },
+            { R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g,
+              R.drawable.stat_sys_data_fully_connected_4g }
+        };
+
+    static final int QS_DATA_4G = R.drawable.ic_qs_signal_4g;
+
+    static final int[][] DATA_4G_PLUS = {
+            { R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus },
+            { R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus,
+              R.drawable.stat_sys_data_fully_connected_4g_plus }
+    };
+
+    static final int QS_DATA_4G_PLUS = R.drawable.ic_qs_signal_4g_plus;
+
+    // LTE branded "LTE"
+    static final int[][] DATA_LTE = {
+            { R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte },
+            { R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte,
+                    R.drawable.stat_sys_data_fully_connected_lte }
+    };
+
+    static final int QS_DATA_LTE = R.drawable.ic_qs_signal_lte;
+    static final int QS_DATA_LTE_PLUS = R.drawable.ic_qs_signal_lte_plus;
+
+    static final int FLIGHT_MODE_ICON = R.drawable.stat_sys_airplane_mode;
+    static final int ROAMING_ICON = R.drawable.stat_sys_data_fully_connected_roam;
+    static final int ROAMING_LTE_ICON = R.drawable.roaming_lte;
+    static final int ROAMING_H_ICON = R.drawable.roaming_h;
+    static final int ROAMING_4G_ICON = R.drawable.roaming_4g;
+    static final int ROAMING_3G_ICON = R.drawable.roaming_3g;
+    static final int ROAMING_E_ICON = R.drawable.roaming_e;
+    
+    static final int ICON_LTE = R.drawable.stat_sys_data_fully_connected_lte;
+
+    static final int ICON_LTE_PLUS = R.drawable.stat_sys_data_fully_connected_lte_plus;
+
+    static final int ICON_G = R.drawable.stat_sys_data_fully_connected_g;
+    static final int ICON_E = R.drawable.stat_sys_data_fully_connected_e;
+    static final int ICON_H = R.drawable.stat_sys_data_fully_connected_h;
+    static final int ICON_3G = R.drawable.stat_sys_data_fully_connected_3g;
+    static final int ICON_4G = R.drawable.stat_sys_data_fully_connected_4g;
+    static final int ICON_4G_PLUS = R.drawable.stat_sys_data_fully_connected_4g_plus;
+    static final int ICON_1X = R.drawable.stat_sys_data_fully_connected_1x;
+    static final int ICON_CARRIER_NETWORK_CHANGE =
+            R.drawable.stat_sys_signal_carrier_network_change_animation;
+
+    static final int ICON_DATA_DISABLED = R.drawable.stat_sys_data_disabled;
+
+    static final int QS_ICON_LTE = R.drawable.ic_qs_signal_lte;
+    static final int QS_ICON_3G = R.drawable.ic_qs_signal_3g;
+    static final int QS_ICON_4G = R.drawable.ic_qs_signal_4g;
+    static final int QS_ICON_4G_PLUS = R.drawable.ic_qs_signal_4g_plus;
+    static final int QS_ICON_1X = R.drawable.ic_qs_signal_1x;
+    static final int QS_ICON_CARRIER_NETWORK_CHANGE =
+            R.drawable.ic_qs_signal_carrier_network_change_animation;
+
+    static final int QS_ICON_DATA_DISABLED = R.drawable.ic_qs_data_disabled;
+
+    static final MobileIconGroup CARRIER_NETWORK_CHANGE = new MobileIconGroup(
+            "CARRIER_NETWORK_CHANGE",
+            TelephonyIcons.TELEPHONY_CARRIER_NETWORK_CHANGE,
+            TelephonyIcons.QS_TELEPHONY_CARRIER_NETWORK_CHANGE,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.ICON_CARRIER_NETWORK_CHANGE,
+            TelephonyIcons.QS_ICON_CARRIER_NETWORK_CHANGE,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_carrier_network_change_mode,
+            0,
+            false,
+            0
+            );
+
+    static final MobileIconGroup THREE_G = new MobileIconGroup(
+            "3G",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_3g,
+            TelephonyIcons.ICON_3G,
+            true,
+            TelephonyIcons.QS_DATA_3G
+            );
+
+    static final MobileIconGroup WFC = new MobileIconGroup(
+            "WFC",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            0, 0, false, 0
+            );
+
+    static final MobileIconGroup UNKNOWN = new MobileIconGroup(
+            "Unknown",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            0, 0, false, 0
+            );
+
+    static final MobileIconGroup E = new MobileIconGroup(
+            "E",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_edge,
+            TelephonyIcons.ICON_E,
+            false,
+            TelephonyIcons.QS_DATA_E
+            );
+
+    static final MobileIconGroup ONE_X = new MobileIconGroup(
+            "1X",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_cdma,
+            TelephonyIcons.ICON_1X,
+            true,
+            TelephonyIcons.QS_DATA_1X
+            );
+
+    static final MobileIconGroup G = new MobileIconGroup(
+            "G",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_gprs,
+            TelephonyIcons.ICON_G,
+            false,
+            TelephonyIcons.QS_DATA_G
+            );
+
+    static final MobileIconGroup H = new MobileIconGroup(
+            "H",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_3_5g,
+            TelephonyIcons.ICON_H,
+            false,
+            TelephonyIcons.QS_DATA_H
+            );
+
+    static final MobileIconGroup FOUR_G = new MobileIconGroup(
+            "4G",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_4g,
+            TelephonyIcons.ICON_4G,
+            true,
+            TelephonyIcons.QS_DATA_4G
+            );
+
+    static final MobileIconGroup FOUR_G_PLUS = new MobileIconGroup(
+            "4G+",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0,0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_4g_plus,
+            TelephonyIcons.ICON_4G_PLUS,
+            true,
+            TelephonyIcons.QS_DATA_4G_PLUS
+            );
+
+    static final MobileIconGroup LTE = new MobileIconGroup(
+            "LTE",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_lte,
+            TelephonyIcons.ICON_LTE,
+            true,
+            TelephonyIcons.QS_DATA_LTE
+            );
+    static final MobileIconGroup LTE_PLUS = new MobileIconGroup(
+            "LTE+",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_lte_plus,
+            TelephonyIcons.ICON_LTE_PLUS,
+            true,
+            TelephonyIcons.QS_DATA_LTE_PLUS
+            );
+    static final MobileIconGroup ROAMING = new MobileIconGroup(
+            "Roaming",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_roaming,
+            TelephonyIcons.ROAMING_ICON,
+            false,
+            TelephonyIcons.QS_DATA_R
+            );
+    static final MobileIconGroup FOUR_G_R = new MobileIconGroup(
+            "4G_R",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_4g,
+            TelephonyIcons.ROAMING_4G_ICON,
+            true,
+            TelephonyIcons.ROAMING_4G_ICON
+            );
+    static final MobileIconGroup THREE_G_R = new MobileIconGroup(
+            "3G_R",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_3g,
+            TelephonyIcons.ROAMING_3G_ICON,
+            true,
+            TelephonyIcons.ROAMING_3G_ICON
+            );
+    static final MobileIconGroup H_PLUS_R = new MobileIconGroup(
+            "H+_R",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_3_5g,
+            TelephonyIcons.ROAMING_H_ICON,
+            true,
+            TelephonyIcons.ROAMING_H_ICON
+            );
+    static final MobileIconGroup E_R = new MobileIconGroup(
+            "E_R",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_edge,
+            TelephonyIcons.ROAMING_E_ICON,
+            true,
+            TelephonyIcons.ROAMING_E_ICON
+            );
+    static final MobileIconGroup LTE_R = new MobileIconGroup(
+            "LTE_R",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_data_connection_lte,
+            TelephonyIcons.ROAMING_LTE_ICON,
+            true,
+            TelephonyIcons.ROAMING_LTE_ICON
+            );
+    static final MobileIconGroup DATA_DISABLED = new MobileIconGroup(
+            "DataDisabled",
+            TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH,
+            TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH,
+            0, 0,
+            TelephonyIcons.TELEPHONY_NO_NETWORK,
+            TelephonyIcons.QS_TELEPHONY_NO_NETWORK,
+            AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0],
+            R.string.accessibility_cell_data_off,
+            TelephonyIcons.ICON_DATA_DISABLED,
+            false,
+            TelephonyIcons.QS_ICON_DATA_DISABLED
+            );
+}
+
Index: vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
===================================================================
--- vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java	(revision 0)
+++ vendor/branch/5058I/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java	(revision 13925)
@@ -0,0 +1,902 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.systemui.statusbar.policy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.NetworkCapabilities;
+import android.os.Looper;
+import android.os.SystemProperties;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.telephony.PreciseDataConnectionState;
+
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.ims.ImsManager;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsException;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.cdma.EriInfo;
+import com.android.systemui.R;
+import com.android.systemui.statusbar.policy.NetworkController.IconState;
+import com.android.systemui.statusbar.policy.NetworkController.SignalCallback;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl.Config;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl.SubscriptionDefaults;
+import com.mediatek.systemui.ext.IMobileIconExt;
+import com.mediatek.systemui.ext.ISystemUIStatusBarExt;
+import com.mediatek.systemui.PluginManager;
+import com.mediatek.systemui.statusbar.networktype.NetworkTypeUtils;
+
+import com.mediatek.telephony.TelephonyManagerEx;
+
+import java.io.PrintWriter;
+import java.util.BitSet;
+import java.util.Objects;
+
+
+public class MobileSignalController extends SignalController<
+        MobileSignalController.MobileState, MobileSignalController.MobileIconGroup> {
+    private static final String TAG = "MobileSignalController";
+
+    private final TelephonyManager mPhone;
+    private final SubscriptionDefaults mDefaults;
+    private final String mNetworkNameDefault;
+    private final String mNetworkNameSeparator;
+    @VisibleForTesting
+    final PhoneStateListener mPhoneStateListener;
+    // Save entire info for logging, we only use the id.
+    /// M: Fix bug ALPS02416794
+    /*final*/ SubscriptionInfo mSubscriptionInfo;
+
+    // @VisibleForDemoMode
+    final SparseArray<MobileIconGroup> mNetworkToIconLookup;
+
+    // Since some pieces of the phone state are interdependent we store it locally,
+    // this could potentially become part of MobileState for simplification/complication
+    // of code.
+    private int mDataNetType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+    private int mDataState = TelephonyManager.DATA_DISCONNECTED;
+    private ServiceState mServiceState;
+    private SignalStrength mSignalStrength;
+    private MobileIconGroup mDefaultIcons;
+    private Config mConfig;
+	private String mApnType = "unknow";
+
+    /// M: Add for Plugin feature. @ {
+    private IMobileIconExt mMobileIconExt;
+    private ISystemUIStatusBarExt mStatusBarExt;
+    /// @ }
+
+    // TODO: Reduce number of vars passed in, if we have the NetworkController, probably don't
+    // need listener lists anymore.
+    public MobileSignalController(Context context, Config config, boolean hasMobileData,
+            TelephonyManager phone, CallbackHandler callbackHandler,
+            NetworkControllerImpl networkController, SubscriptionInfo info,
+            SubscriptionDefaults defaults, Looper receiverLooper) {
+        super("MobileSignalController(" + info.getSubscriptionId() + ")", context,
+                NetworkCapabilities.TRANSPORT_CELLULAR, callbackHandler,
+                networkController);
+        mNetworkToIconLookup = new SparseArray<>();
+        mConfig = config;
+        mPhone = phone;
+        mDefaults = defaults;
+        mSubscriptionInfo = info;
+        /// M: Init plugin @ {
+        mMobileIconExt = PluginManager.getMobileIconExt(context);
+        mStatusBarExt = PluginManager.getSystemUIStatusBarExt(context);
+        /// @ }
+        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
+                receiverLooper);
+        mNetworkNameSeparator = getStringIfExists(R.string.status_bar_network_name_separator);
+        mNetworkNameDefault = getStringIfExists(
+                com.android.internal.R.string.lockscreen_carrier_default);
+
+        mapIconSets();
+
+        String networkName = info.getCarrierName() != null ? info.getCarrierName().toString()
+                : mNetworkNameDefault;
+        mLastState.networkName = mCurrentState.networkName = networkName;
+        mLastState.networkNameData = mCurrentState.networkNameData = networkName;
+        mLastState.enabled = mCurrentState.enabled = hasMobileData;
+        mLastState.iconGroup = mCurrentState.iconGroup = mDefaultIcons;
+        /// M: Support volte icon
+        initImsRegisterState();
+        // Get initial data sim state.
+        updateDataSim();
+    }
+
+    /// M: Support volte icon @{
+    private void initImsRegisterState(){
+        int phoneId = SubscriptionManager.getPhoneId(mSubscriptionInfo.getSubscriptionId());
+        try {
+            boolean imsRegStatus = ImsManager
+                    .getInstance(mContext, phoneId).getImsRegInfo();
+            mCurrentState.imsRegState = imsRegStatus
+                    ? ServiceState.STATE_IN_SERVICE : ServiceState.STATE_OUT_OF_SERVICE;
+            Log.d(mTag, "init imsRegState:" + mCurrentState.imsRegState
+                    + ",phoneId:" + phoneId);
+        } catch (ImsException ex) {
+            Log.e(mTag, "Fail to get Ims Status");
+        }
+    }
+    /// @}
+    public void setConfiguration(Config config) {
+        mConfig = config;
+        mapIconSets();
+        updateTelephony();
+    }
+
+    public int getDataContentDescription() {
+        return getIcons().mDataContentDescription;
+    }
+
+    public void setAirplaneMode(boolean airplaneMode) {
+        mCurrentState.airplaneMode = airplaneMode;
+        notifyListenersIfNecessary();
+    }
+
+    public void setUserSetupComplete(boolean userSetup) {
+        mCurrentState.userSetup = userSetup;
+        notifyListenersIfNecessary();
+    }
+
+    @Override
+    public void updateConnectivity(BitSet connectedTransports, BitSet validatedTransports) {
+        boolean isValidated = validatedTransports.get(mTransportType);
+        mCurrentState.isDefault =
+                connectedTransports.get(mTransportType) &&
+                // M: Add one more condition to judge whether the cellular connection is this subid
+                mNetworkController.isCellularConnected(mSubscriptionInfo.getSubscriptionId());
+
+        // Only show this as not having connectivity if we are default.
+        mCurrentState.inetCondition = (isValidated || !mCurrentState.isDefault) ? 1 : 0;
+        Log.d(mTag,"mCurrentState.inetCondition = " + mCurrentState.inetCondition);
+        /// M: Disable inetCondition check as this condition is not sufficient in some cases.
+        /// So always set it is in net with value 1. @ {
+        mCurrentState.inetCondition =
+                mMobileIconExt.customizeMobileNetCondition(1);
+        /// @}
+        notifyListenersIfNecessary();
+    }
+
+    public void setCarrierNetworkChangeMode(boolean carrierNetworkChangeMode) {
+        mCurrentState.carrierNetworkChangeMode = carrierNetworkChangeMode;
+        updateTelephony();
+    }
+
+    /**
+     * Start listening for phone state changes.
+     */
+    public void registerListener() {
+        mPhone.listen(mPhoneStateListener,
+                PhoneStateListener.LISTEN_SERVICE_STATE
+                        | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS
+                        | PhoneStateListener.LISTEN_CALL_STATE
+                        | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE
+                        | PhoneStateListener.LISTEN_DATA_ACTIVITY
+                        | PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE
+                        | PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE);
+        mStatusBarExt.registerOpStateListener();
+    }
+
+    /**
+     * Stop listening for phone state changes.
+     */
+    public void unregisterListener() {
+        mPhone.listen(mPhoneStateListener, 0);
+    }
+
+    /**
+     * Produce a mapping of data network types to icon groups for simple and quick use in
+     * updateTelephony.
+     */
+    private void mapIconSets() {
+        mNetworkToIconLookup.clear();
+
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
+
+        if (!mConfig.showAtLeast3G) {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN,
+                    TelephonyIcons.UNKNOWN);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
+
+            mDefaultIcons = TelephonyIcons.G;
+        } else {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT,
+                    TelephonyIcons.THREE_G);
+            mDefaultIcons = TelephonyIcons.THREE_G;
+        }
+
+        MobileIconGroup hGroup = TelephonyIcons.THREE_G;
+        if (mConfig.hspaDataDistinguishable) {
+            hGroup = TelephonyIcons.H;
+        }
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
+
+        if (mConfig.show4gForLte) {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
+            if (mConfig.hideLtePlus) {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.FOUR_G);
+            } else {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.FOUR_G_PLUS);
+            }
+        } else {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
+            if (mConfig.hideLtePlus) {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.LTE);
+            } else {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.LTE_PLUS);
+            }
+        }
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
+    }
+
+    @Override
+    public void notifyListeners(SignalCallback callback) {
+        MobileIconGroup icons = getIcons();
+
+        String contentDescription = getStringIfExists(getContentDescription());
+        String dataContentDescription = getStringIfExists(icons.mDataContentDescription);
+        final boolean dataDisabled = mCurrentState.iconGroup == TelephonyIcons.DATA_DISABLED
+                && mCurrentState.userSetup;
+
+        /// M: Customize the signal strength icon id. @ {
+        int iconId = getCurrentIconId();
+        iconId = mStatusBarExt.getCustomizeSignalStrengthIcon(
+                    mSubscriptionInfo.getSubscriptionId(),
+                    iconId,
+                    mSignalStrength,
+                    mDataNetType,
+                    mServiceState);
+        /// @ }
+
+        // Show icon in QS when we are connected or need to show roaming or data is disabled.
+        boolean showDataIcon = mCurrentState.dataConnected
+                || mCurrentState.iconGroup == TelephonyIcons.ROAMING
+                || dataDisabled;
+        IconState statusIcon = new IconState(mCurrentState.enabled && !mCurrentState.airplaneMode,
+                iconId, contentDescription);
+
+        int qsTypeIcon = 0;
+        IconState qsIcon = null;
+        String description = null;
+        // Only send data sim callbacks to QS.
+        if (mCurrentState.dataSim) {
+            qsTypeIcon = showDataIcon ? icons.mQsDataType : 0;
+            qsIcon = new IconState(mCurrentState.enabled
+                    && !mCurrentState.isEmergency, getQsCurrentIconId(), contentDescription);
+            description = mCurrentState.isEmergency ? null : mCurrentState.networkName;
+        }
+        boolean activityIn = mCurrentState.dataConnected
+                        && !mCurrentState.carrierNetworkChangeMode
+                        && mCurrentState.activityIn;
+        boolean activityOut = mCurrentState.dataConnected
+                        && !mCurrentState.carrierNetworkChangeMode
+                        && mCurrentState.activityOut;
+        showDataIcon &= mCurrentState.isDefault
+                || mCurrentState.iconGroup == TelephonyIcons.ROAMING
+                || dataDisabled || mApnType.equals("mms");
+        int typeIcon = showDataIcon ? icons.mDataType : 0;
+        /** M: Support [Network Type on StatusBar], change the implement methods.
+          * Get the network icon base on service state.
+          * Add one more parameter for network type.
+          * @ { **/
+        int networkIcon = mCurrentState.networkIcon;
+
+        /// M: Support volte icon.Bug fix when airplane mode is on go to hide volte icon
+        int volteIcon = mCurrentState.airplaneMode && !isWfcEnable()
+                ? 0 : mCurrentState.volteIcon;
+
+        /// M: when data disabled, common show data icon as x, but op do not need show it @ {
+        mStatusBarExt.isDataDisabled(mSubscriptionInfo.getSubscriptionId(), dataDisabled);
+        /// @ }
+
+        /// M: Customize the data type icon id. @ {
+        typeIcon = mStatusBarExt.getDataTypeIcon(
+                        mSubscriptionInfo.getSubscriptionId(),
+                        typeIcon,
+                        mDataNetType,
+                        mCurrentState.dataConnected ? TelephonyManager.DATA_CONNECTED :
+                            TelephonyManager.DATA_DISCONNECTED,
+                        mServiceState);
+        /// @ }
+        /// M: Customize the network type icon id. @ {
+        networkIcon = mStatusBarExt.getNetworkTypeIcon(
+                        mSubscriptionInfo.getSubscriptionId(),
+                        networkIcon,
+                        mDataNetType,
+                        mServiceState);
+        /// @ }
+
+        callback.setMobileDataIndicators(statusIcon, qsIcon, typeIcon, networkIcon, volteIcon,
+                qsTypeIcon, activityIn, activityOut, dataContentDescription, description,
+                icons.mIsWide, mSubscriptionInfo.getSubscriptionId());
+        /** @ }*/
+
+        /// M: update plmn label @{
+        mNetworkController.refreshPlmnCarrierLabel();
+        /// @}
+    }
+
+    @Override
+    protected MobileState cleanState() {
+        return new MobileState();
+    }
+
+    private boolean hasService() {
+        if (mServiceState != null) {
+            // Consider the device to be in service if either voice or data
+            // service is available. Some SIM cards are marketed as data-only
+            // and do not support voice service, and on these SIM cards, we
+            // want to show signal bars for data service as well as the "no
+            // service" or "emergency calls only" text that indicates that voice
+            // is not available.
+            switch (mServiceState.getVoiceRegState()) {
+                case ServiceState.STATE_POWER_OFF:
+                    return false;
+                case ServiceState.STATE_OUT_OF_SERVICE:
+                case ServiceState.STATE_EMERGENCY_ONLY:
+                    return mServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+                default:
+                    return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isCdma() {
+        return (mSignalStrength != null) && !mSignalStrength.isGsm();
+    }
+
+    public boolean isEmergencyOnly() {
+        return (mServiceState != null && mServiceState.isEmergencyOnly());
+    }
+
+    private boolean isRoaming() {
+        if (isCdma()) {
+            /// M: fix ALPS02742814
+            if (mServiceState == null) {
+                return false;
+            }
+            final int iconMode = mServiceState.getCdmaEriIconMode();
+            return mServiceState != null
+                    && mServiceState.getCdmaEriIconIndex() != EriInfo.ROAMING_INDICATOR_OFF
+                    && (iconMode == EriInfo.ROAMING_ICON_MODE_NORMAL
+                        || iconMode == EriInfo.ROAMING_ICON_MODE_FLASH);
+        } else {
+            boolean isInRoaming =  mServiceState != null && mServiceState.getRoaming();
+            return mStatusBarExt.needShowRoamingIcons(isInRoaming);
+        }
+    }
+
+    /// M: Support VoLte @{
+    public boolean isLteNetWork() {
+        return (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE
+            || mDataNetType == TelephonyManager.NETWORK_TYPE_LTE_CA);
+    }
+    /// M: @}
+
+    private boolean isCarrierNetworkChangeActive() {
+        return mCurrentState.carrierNetworkChangeMode;
+    }
+
+    public void handleBroadcast(Intent intent) {
+        String action = intent.getAction();
+        if (action.equals(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION)) {
+            updateNetworkName(intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_SPN, false),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_SPN),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_DATA_SPN),
+                    intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_PLMN, false),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_PLMN));
+            notifyListenersIfNecessary();
+        } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
+            updateDataSim();
+            notifyListenersIfNecessary();
+        } else if (action.equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+          /// M: support dual Ims. @{
+            handleImsAction(intent);
+            notifyListenersIfNecessary();
+            /// @}
+        }
+    }
+
+    /// M: Add for volte @{
+    private void handleImsAction(Intent intent){
+        mCurrentState.imsRegState = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY,
+                ServiceState.STATE_OUT_OF_SERVICE);
+        mCurrentState.imsCap = getImsEnableCap(intent);
+        mCurrentState.volteIcon = getVolteIcon();
+        /// M: add for disconnected volte feature. @{
+        mStatusBarExt.setImsRegInfo(mSubscriptionInfo.getSubscriptionId(),
+                mCurrentState.imsRegState, isImsOverWfc());
+        /// @}
+        Log.d(mTag, "handleImsAction imsRegstate=" + mCurrentState.imsRegState + ",imsCap = " +
+                mCurrentState.imsCap + ",volteIconId=" + mCurrentState.volteIcon);
+    }
+    private int getVolteIcon() {
+        int icon = 0;
+        if (isImsOverWfc()) {
+            boolean isNonSsProject
+                = !(SystemProperties.get("persist.radio.multisim.config", "ss").equals("ss"));
+            if (isNonSsProject) {
+                icon = NetworkTypeUtils.WFC_ICON;
+            }
+        } else if (isImsOverVoice() && isLteNetWork() &&
+            mCurrentState.imsRegState == ServiceState.STATE_IN_SERVICE) {
+            icon = NetworkTypeUtils.VOLTE_ICON;
+        }
+        return icon;
+    }
+    private int getImsEnableCap(Intent intent) {
+        int cap = ImsConfig.FeatureConstants.FEATURE_TYPE_UNKNOWN;
+        boolean[] enabledFeatures =
+                intent.getBooleanArrayExtra(ImsManager.EXTRA_IMS_ENABLE_CAP_KEY);
+        if (enabledFeatures != null) {
+            if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI]) {
+                cap = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+            } else if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE]) {
+                cap = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+            }
+        }
+        return cap;
+    }
+    public boolean isImsOverWfc() {
+        return mCurrentState.imsCap == ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+    }
+    private boolean isImsOverVoice() {
+        return mCurrentState.imsCap == ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+    }
+
+    public boolean isWfcEnable() {
+        boolean isWfcEnabled = TelephonyManagerEx.getDefault().isWifiCallingEnabled(
+            mSubscriptionInfo.getSubscriptionId());
+        return isWfcEnabled;
+    }
+    /// @}
+
+    private void updateDataSim() {
+        int defaultDataSub = mDefaults.getDefaultDataSubId();
+        if (SubscriptionManager.isValidSubscriptionId(defaultDataSub)) {
+            mCurrentState.dataSim = defaultDataSub == mSubscriptionInfo.getSubscriptionId();
+        } else {
+            // There doesn't seem to be a data sim selected, however if
+            // there isn't a MobileSignalController with dataSim set, then
+            // QS won't get any callbacks and will be blank.  Instead
+            // lets just assume we are the data sim (which will basically
+            // show one at random) in QS until one is selected.  The user
+            // should pick one soon after, so we shouldn't be in this state
+            // for long.
+            mCurrentState.dataSim = true;
+        }
+    }
+
+    /**
+     * Updates the network's name based on incoming spn and plmn.
+     */
+    void updateNetworkName(boolean showSpn, String spn, String dataSpn,
+            boolean showPlmn, String plmn) {
+        if (CHATTY) {
+            Log.d("CarrierLabel", "updateNetworkName showSpn=" + showSpn
+                    + " spn=" + spn + " dataSpn=" + dataSpn
+                    + " showPlmn=" + showPlmn + " plmn=" + plmn);
+        }
+        StringBuilder str = new StringBuilder();
+        StringBuilder strData = new StringBuilder();
+        if (showPlmn && plmn != null) {
+            str.append(plmn);
+            strData.append(plmn);
+        }
+        if (showSpn && spn != null) {
+            if (str.length() != 0) {
+                str.append(mNetworkNameSeparator);
+            }
+            str.append(spn);
+        }
+        if (str.length() != 0) {
+            mCurrentState.networkName = str.toString();
+        } else {
+            mCurrentState.networkName = mNetworkNameDefault;
+        }
+        if (showSpn && dataSpn != null) {
+            if (strData.length() != 0) {
+                strData.append(mNetworkNameSeparator);
+            }
+            strData.append(dataSpn);
+        }
+
+        // M: ALPS02744648 for C2K, there isn't dataspn parameter, when no plmn
+        // and no dataspn, show spn instead "no service" here @{
+        if (strData.length() == 0 && showSpn && spn != null) {
+            Log.d("CarrierLabel", "show spn instead 'no service' here: " + spn);
+            strData.append(spn);
+        }
+        // @}
+
+        if (strData.length() != 0) {
+            mCurrentState.networkNameData = strData.toString();
+        } else {
+            mCurrentState.networkNameData = mNetworkNameDefault;
+        }
+    }
+
+    /**
+     * Updates the current state based on mServiceState, mSignalStrength, mDataNetType,
+     * mDataState, and mSimState.  It should be called any time one of these is updated.
+     * This will call listeners if necessary.
+     */
+    private final void updateTelephony() {
+        if (DEBUG) {
+            Log.d(mTag, "updateTelephonySignalStrength: hasService=" + hasService()
+                    + " ss=" + mSignalStrength);
+        }
+        mCurrentState.connected = hasService() && mSignalStrength != null;
+        handleIWLANNetwork();
+        if (mCurrentState.connected) {
+            if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
+                mCurrentState.level = mSignalStrength.getCdmaLevel();
+            } else {
+                mCurrentState.level = mSignalStrength.getLevel();
+            }
+            /// M: Customize the signal strength level. @ {
+            mCurrentState.level = mStatusBarExt.getCustomizeSignalStrengthLevel(
+                    mCurrentState.level, mSignalStrength, mServiceState);
+            /// @ }
+        }
+        if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
+            mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
+        } else {
+            mCurrentState.iconGroup = mDefaultIcons;
+        }
+        /// M: Add for data network type.
+        mCurrentState.dataNetType = mDataNetType;
+        mCurrentState.dataConnected = mCurrentState.connected
+                && mDataState == TelephonyManager.DATA_CONNECTED;
+        /// M: Add for op network tower type.
+        mCurrentState.customizedState = mStatusBarExt.getCustomizeCsState(mServiceState,
+                mCurrentState.customizedState);
+        /// M: Add for op signal strength tower icon.
+        mCurrentState.customizedSignalStrengthIcon = mStatusBarExt.getCustomizeSignalStrengthIcon(
+                mSubscriptionInfo.getSubscriptionId(),
+                mCurrentState.customizedSignalStrengthIcon,
+                mSignalStrength,
+                mDataNetType,
+                mServiceState);
+
+        if (isCarrierNetworkChangeActive()) {
+            mCurrentState.iconGroup = TelephonyIcons.CARRIER_NETWORK_CHANGE;
+        } else if (isRoaming()) {
+            if (mCurrentState.dataConnected) {
+                if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_GPRS ||
+                    mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_EDGE) {
+                    mCurrentState.iconGroup = TelephonyIcons.E_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_UMTS ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSPA ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSPAP) {
+                    mCurrentState.iconGroup = TelephonyIcons.THREE_G_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSDPA ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSUPA) {
+                    mCurrentState.iconGroup = TelephonyIcons.H_PLUS_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_LTE) {
+                    mCurrentState.iconGroup = TelephonyIcons.FOUR_G_R;
+                }
+            } else {
+                mCurrentState.iconGroup = TelephonyIcons.ROAMING;
+            }
+        } else if (isDataDisabled()) {
+            //mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
+        }
+        if (isEmergencyOnly() != mCurrentState.isEmergency) {
+            mCurrentState.isEmergency = isEmergencyOnly();
+            mNetworkController.recalculateEmergency();
+        }
+        // Fill in the network name if we think we have it.
+        if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null
+                && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
+            mCurrentState.networkName = mServiceState.getOperatorAlphaShort();
+        }
+        /// M: For network type big icon.
+        mCurrentState.networkIcon =
+            NetworkTypeUtils.getNetworkTypeIcon(mServiceState, mConfig, hasService());
+        /// M: For volte type icon.
+        mCurrentState.volteIcon = getVolteIcon();
+
+        notifyListenersIfNecessary();
+    }
+
+    private boolean isDataDisabled() {
+        return !mPhone.getDataEnabled(mSubscriptionInfo.getSubscriptionId());
+    }
+
+    /// M: bug fix for ALPS02603527.
+    /** IWLAN is special case in which the transmission via WIFI, no need cellular network, then
+    whenever PS type is IWLAN, cellular network is not connected. However, in special case, CS may
+    still connect under IWLAN with valid network type.
+    **/
+     private void handleIWLANNetwork() {
+        /// M: fix ALPS02742814
+        if (mCurrentState.connected && mServiceState != null &&
+            mServiceState.getDataNetworkType() == TelephonyManager.NETWORK_TYPE_IWLAN &&
+            mServiceState.getVoiceNetworkType() == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
+            Log.d(mTag,"Current is IWLAN network only, no cellular network available");
+            mCurrentState.connected = false;
+        }
+        /// M: Add for plugin wifi-only mode.
+        mCurrentState.connected = mStatusBarExt.updateSignalStrengthWifiOnlyMode(
+            mServiceState, mCurrentState.connected);
+    }
+
+    @VisibleForTesting
+    void setActivity(int activity) {
+        mCurrentState.activityIn = activity == TelephonyManager.DATA_ACTIVITY_INOUT
+                || activity == TelephonyManager.DATA_ACTIVITY_IN;
+        mCurrentState.activityOut = activity == TelephonyManager.DATA_ACTIVITY_INOUT
+                || activity == TelephonyManager.DATA_ACTIVITY_OUT;
+        notifyListenersIfNecessary();
+    }
+
+    @Override
+    public void dump(PrintWriter pw) {
+        super.dump(pw);
+        pw.println("  mSubscription=" + mSubscriptionInfo + ",");
+        pw.println("  mServiceState=" + mServiceState + ",");
+        pw.println("  mSignalStrength=" + mSignalStrength + ",");
+        pw.println("  mDataState=" + mDataState + ",");
+        pw.println("  mDataNetType=" + mDataNetType + ",");
+    }
+
+    class MobilePhoneStateListener extends PhoneStateListener {
+        public MobilePhoneStateListener(int subId, Looper looper) {
+            super(subId, looper);
+        }
+
+        @Override
+        public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+            if (DEBUG) {
+                Log.d(mTag, "onSignalStrengthsChanged signalStrength=" + signalStrength +
+                        ((signalStrength == null) ? "" : (" level=" + signalStrength.getLevel())));
+            }
+            mSignalStrength = signalStrength;
+            updateTelephony();
+        }
+
+        @Override
+        public void onServiceStateChanged(ServiceState state) {
+            if (DEBUG) {
+                Log.d(mTag, "onServiceStateChanged voiceState=" + state.getVoiceRegState()
+                        + " dataState=" + state.getDataRegState());
+            }
+            mServiceState = state;
+            mDataNetType = state.getDataNetworkType();
+            //TODO:: Double check with FWK
+            if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null &&
+                    mServiceState.isUsingCarrierAggregation()) {
+                mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
+            }
+            updateTelephony();
+        }
+
+        @Override
+        public void onDataConnectionStateChanged(int state, int networkType) {
+            if (DEBUG) {
+                Log.d(mTag, "onDataConnectionStateChanged: state=" + state
+                        + " type=" + networkType);
+            }
+            mDataState = state;
+            mDataNetType = networkType;
+            //TODO:: Double check with FWK
+            if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null &&
+                    mServiceState.isUsingCarrierAggregation()) {
+                mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
+            }
+            updateTelephony();
+        }
+		@Override 
+		public void onPreciseDataConnectionStateChanged(PreciseDataConnectionState dataConnectionState){
+			if (DEBUG) {
+				Log.d(mTag, "onPreciseDataConnectionStateChanged: dataConnectionState=" + dataConnectionState);
+	 		}
+        	if ((mDataState==dataConnectionState.getDataConnectionState())&&(mDataNetType==dataConnectionState.getDataConnectionNetworkType()))
+        	{
+            	mApnType = dataConnectionState.getDataConnectionAPNType();
+            	Log.d(TAG, "mtk onPreciseDataConnectionStateChanged mApnType: " + mApnType);
+            	notifyListenersIfNecessary();
+        	}
+		}
+
+        @Override
+        public void onDataActivity(int direction) {
+            if (DEBUG) {
+                Log.d(mTag, "onDataActivity: direction=" + direction);
+            }
+            setActivity(direction);
+        }
+
+        @Override
+        public void onCarrierNetworkChange(boolean active) {
+            if (DEBUG) {
+                Log.d(mTag, "onCarrierNetworkChange: active=" + active);
+            }
+            mCurrentState.carrierNetworkChangeMode = active;
+
+            updateTelephony();
+        }
+    };
+
+    static class MobileIconGroup extends SignalController.IconGroup {
+        final int mDataContentDescription; // mContentDescriptionDataType
+        final int mDataType;
+        final boolean mIsWide;
+        final int mQsDataType;
+
+        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
+                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
+                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
+                int qsDataType) {
+            super(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
+                    qsDiscState, discContentDesc);
+            mDataContentDescription = dataContentDesc;
+            mDataType = dataType;
+            mIsWide = isWide;
+            mQsDataType = qsDataType;
+        }
+    }
+
+    static class MobileState extends SignalController.State {
+        String networkName;
+        String networkNameData;
+        boolean dataSim;
+        boolean dataConnected;
+        boolean isEmergency;
+        boolean airplaneMode;
+        boolean carrierNetworkChangeMode;
+        boolean isDefault;
+        boolean userSetup;
+
+        /// M: For network type big icon.
+        int networkIcon;
+        /// M: Add for data network type.
+        int dataNetType;
+        /// M: Add for op network tower type.
+        int customizedState;
+        /// M: Add for op signal strength tower icon.
+        int customizedSignalStrengthIcon;
+        /// M: Add for volte @{
+        int imsRegState = ServiceState.STATE_POWER_OFF;
+        int imsCap;
+        int volteIcon;
+        /// @}
+        @Override
+        public void copyFrom(State s) {
+            super.copyFrom(s);
+            MobileState state = (MobileState) s;
+            dataSim = state.dataSim;
+            networkName = state.networkName;
+            networkNameData = state.networkNameData;
+            dataConnected = state.dataConnected;
+            isDefault = state.isDefault;
+            isEmergency = state.isEmergency;
+            airplaneMode = state.airplaneMode;
+            carrierNetworkChangeMode = state.carrierNetworkChangeMode;
+            userSetup = state.userSetup;
+
+            /// M: For network type big icon.
+            networkIcon = state.networkIcon;
+            /// M: Add for data network type.
+            dataNetType = state.dataNetType;
+            /// M: Add for op network tower type.
+            customizedState = state.customizedState;
+            /// M: Add for op signal strength tower icon.
+            customizedSignalStrengthIcon = state.customizedSignalStrengthIcon;
+            /// M: Add for volte
+            imsRegState = state.imsRegState;
+            imsCap = state.imsCap;
+            volteIcon = state.volteIcon;
+        }
+
+        @Override
+        protected void toString(StringBuilder builder) {
+            super.toString(builder);
+            builder.append(',');
+            builder.append("dataSim=").append(dataSim).append(',');
+            builder.append("networkName=").append(networkName).append(',');
+            builder.append("networkNameData=").append(networkNameData).append(',');
+            builder.append("dataConnected=").append(dataConnected).append(',');
+            builder.append("isDefault=").append(isDefault).append(',');
+            builder.append("isEmergency=").append(isEmergency).append(',');
+            builder.append("airplaneMode=").append(airplaneMode).append(',');
+            builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode)
+                    .append(',');
+            builder.append("userSetup=").append(userSetup);
+
+            /// M: For network type big icon.
+            builder.append("networkIcon").append(networkIcon).append(',');
+            /// M: Add for data network type.
+            builder.append("dataNetType").append(dataNetType).append(',');
+            /// M: Add for op network tower type.
+            builder.append("customizedState").append(customizedState).append(',');
+            /// M: Add for op signal strength tower icon.
+            builder.append("customizedSignalStrengthIcon").append(customizedSignalStrengthIcon)
+                    .append(',');
+            /// M: Add for volte.
+            builder.append("imsRegState=").append(imsRegState).append(',');
+            builder.append("imsCap=").append(imsCap).append(',');
+            builder.append("volteIconId=").append(volteIcon).append(',');
+            builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return super.equals(o)
+                    && Objects.equals(((MobileState) o).networkName, networkName)
+                    && Objects.equals(((MobileState) o).networkNameData, networkNameData)
+                    && ((MobileState) o).dataSim == dataSim
+                    && ((MobileState) o).dataConnected == dataConnected
+                    && ((MobileState) o).isEmergency == isEmergency
+                    && ((MobileState) o).airplaneMode == airplaneMode
+                    && ((MobileState) o).carrierNetworkChangeMode == carrierNetworkChangeMode
+                    /// M: For network type big icon.
+                    && ((MobileState) o).networkIcon == networkIcon
+                    && ((MobileState) o).volteIcon == volteIcon
+                    /// M: Add for data network type.
+                    && ((MobileState) o).dataNetType == dataNetType
+                    /// M: Add for op network tower type.
+                    && ((MobileState) o).customizedState == customizedState
+                    /// M: Add for op signal strength tower icon.
+                    && ((MobileState) o).customizedSignalStrengthIcon ==
+                                             customizedSignalStrengthIcon
+                    && ((MobileState) o).userSetup == userSetup
+                    && ((MobileState) o).isDefault == isDefault;
+        }
+    }
+
+    /// M: Support for PLMN. @{
+    public SubscriptionInfo getControllerSubInfo() {
+        return mSubscriptionInfo;
+    }
+
+    public boolean getControllserHasService() {
+        return hasService();
+    }
+    /// M: Support for PLMN. @}
+}
