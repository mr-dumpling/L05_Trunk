Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values-zh-rCN/strings.xml
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values-zh-rCN/strings.xml	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values-zh-rCN/strings.xml	(revision 2619)
@@ -0,0 +1,394 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- 
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_label" msgid="1503967887341230795">"信息"</string>
+    <string name="new_message" msgid="1530369762346003973">"新信息"</string>
+    <string name="menu_call_back" msgid="7538482331117914146">"呼叫<xliff:g id="NAME">%s</xliff:g>"</string>
+    <string name="menu_send_email" msgid="671366308915241664">"发送电子邮件至<xliff:g id="NAME">%s</xliff:g>"</string>
+    <string name="menu_compose_new" msgid="3763437973691046238">"撰写"</string>
+    <string name="menu_preferences" msgid="4693148116114749414">"设置"</string>
+    <string name="menu_add_address_to_contacts" msgid="8013282802147375764">"将 <xliff:g id="CONTACTEMAILORNUMBER">%s</xliff:g> 添加到通讯录"</string>
+    <string name="storage_warning_title" msgid="7124740686325942375">"您手机的存储空间已满"</string>
+    <string name="storage_warning_content" msgid="1100367816649962354">"您将无法收到新的短信/彩信"</string>
+    <string name="label_mms_send_outbox_msg" msgid="3395185162973061099">"彩信激活"</string>
+    <string name="desc_mms_send_outbox_msg" msgid="1837156781311437148">"将发件箱内的所有彩信发送至网络"</string>
+    <string name="sending_disabled_not_default_app" msgid="6685337318181265136">"发送功能已停用"</string>
+    <string name="compose_disabled_toast" msgid="1838175321052707875">"无法写短信，因为此应用不是默认的短信应用。"</string>
+    <string name="banner_sms_promo_title_initial" msgid="510014388581481569">"“短信”不是您的短信应用"</string>
+    <string name="banner_sms_promo_title_application" msgid="8123569785369713254">"“<xliff:g id="APPNAME">%s</xliff:g>”是您的短信应用"</string>
+    <string name="banner_sms_promo_message" msgid="3536714414252763826">"您可以在“设置”中更改此设置。"</string>
+    <string name="menu_call" msgid="5877123227307074690">"呼叫"</string>
+    <string name="menu_search" msgid="2289469305728821360">"搜索"</string>
+    <string name="menu_delete_all" msgid="808729454898114735">"删除所有会话"</string>
+    <string name="menu_delete" msgid="1851666911396479006">"删除会话"</string>
+    <string name="menu_view" msgid="7448852683948080108">"查看会话"</string>
+    <string name="menu_debug_dump" msgid="6855869130206549643">"DEBUG DUMP"</string>
+    <string name="refreshing" msgid="987335057871404222">"正在刷新..."</string>
+    <string name="has_draft" msgid="2487465595514636160">"草稿"</string>
+    <string name="no_subject_view" msgid="7795086723069563537">"（无主题）"</string>
+    <string name="messagelist_sender_self" msgid="3579016854116401602">"我"</string>
+    <string name="view_slideshow" msgid="4990460971211388453">"观看幻灯片演示"</string>
+    <string name="view_message_details" msgid="7613457646645796831">"查看详情"</string>
+    <string name="view_delivery_report" msgid="8219095994071575215">"查看报告"</string>
+    <string name="delete_message" msgid="6442394955910357234">"删除"</string>
+    <string name="expire_on" msgid="4436268382742593921">"过期时间：<xliff:g id="DATE">%s</xliff:g>"</string>
+    <string name="kilobyte" msgid="534782148965716631">"KB"</string>
+    <string name="undelivered_msg_dialog_title" msgid="7479433403599785755">"信息未传送出去"</string>
+    <string name="undelivered_msg_dialog_body" msgid="4789268239627694551">"无法发送此短信。\n尝试发送时间：<xliff:g id="MESSAGE">%s</xliff:g>。"</string>
+    <string name="undelivered_sms_dialog_body" msgid="6755818550013032420">"无法发送此信息。"</string>
+    <string name="delete_thread" msgid="757258847736632791">"删除会话"</string>
+    <string name="menu_forward" msgid="9026858380050046756">"转发"</string>
+    <string name="download" msgid="4488877642230207631">"下载"</string>
+    <string name="downloading" msgid="1779557575565350637">"正在下载"</string>
+    <string name="inline_subject" msgid="4057621785274119260">"&lt;主题：<xliff:g id="SUBJECT">%s</xliff:g>&gt;"</string>
+    <string name="drm_protected_text" msgid="1396394157870730742">"* 受 DRM 保护的文本 *"</string>
+    <string name="insufficient_drm_rights" msgid="6989074725969164383">"检测到 DRM 权限不足。"</string>
+    <string name="copy_message_text" msgid="4296252229544252834">"复制文字"</string>
+    <string name="message_options" msgid="6838806653341967550">"信息选项"</string>
+    <string name="slideshow_options" msgid="3501759384739796431">"幻灯片选项"</string>
+    <string name="move_up" msgid="7307578107431739359">"上移"</string>
+    <string name="move_down" msgid="6356509518429479053">"下移"</string>
+    <string name="remove_slide" msgid="2225604354024914900">"删除幻灯片"</string>
+    <string name="add_slide" msgid="9140721399423564187">"添加幻灯片"</string>
+    <string name="add_slide_hint" msgid="563319570849475501">"选择以创建新幻灯片。"</string>
+    <string name="discard_slideshow" msgid="5054239124146413609">"舍弃幻灯片"</string>
+    <string name="slide_show_part" msgid="5077675385448696846">"第 <xliff:g id="PART">%1$s</xliff:g> 部分，共 <xliff:g id="TOTAL">%2$s</xliff:g> 部分"</string>
+    <string name="remove_text" msgid="2164068850029476539">"删除文本"</string>
+    <string name="add_picture" msgid="7819574884962571479">"添加图片"</string>
+    <string name="remove_picture" msgid="6378701749074289096">"删除图片"</string>
+    <string name="add_music" msgid="3827442822987116233">"添加音乐"</string>
+    <string name="remove_music" msgid="858889733416015223">"删除音乐"</string>
+    <string name="add_video" msgid="7816866867806595144">"添加视频"</string>
+    <string name="remove_video" msgid="5258603891528497799">"删除视频"</string>
+    <string name="to_hint" msgid="224029549150332986">"接收者"</string>
+    <string name="subject_hint" msgid="4296714962311604126">"主题"</string>
+    <string name="add_attachment" msgid="7103751293360532684">"附件"</string>
+    <string name="add_subject" msgid="7616134948428265870">"添加主题"</string>
+    <string name="discard" msgid="1624800293064498479">"舍弃"</string>
+    <string name="view" msgid="7929667761715467136">"查看"</string>
+    <string name="replace" msgid="7587904998114459388">"替换"</string>
+    <string name="remove" msgid="4625444913256213175">"删除"</string>
+    <string name="send" msgid="4589898724889248486">"发送"</string>
+    <string name="mms" msgid="1587631213714914559">"彩信"</string>
+    <string name="loading_conversations">"正在加载会话。"</string>
+    <string name="send_mms" msgid="2933162044872550662">"发送彩信"</string>
+    <string name="all_threads" msgid="2663426830306307194">"所有会话"</string>
+    <string name="type_to_compose_text_enter_to_send" msgid="3539985471008581265">"键入信息"</string>
+    <string name="open_keyboard_to_compose_message" msgid="7860109685511253191">"打开键盘键入讯息"</string>
+    <string name="compressing" msgid="1961357529661045180">"图片过大。正在压缩…"</string>
+    <string name="unsupported_media_format" msgid="5037111178813903722">"不支持<xliff:g id="NAME">%1$s</xliff:g>格式"</string>
+    <string name="select_different_media" msgid="7573116916321879964">"请选择另一个<xliff:g id="NAME">%1$s</xliff:g>。"</string>
+    <string name="exceed_message_size_limitation" msgid="6027753647094742437">"已达到信息大小上限。"</string>
+    <string name="omh_exceed_message_size_limitation" msgid="6027753647094742437">"已达到R-UIM卡信息上限大小"</string>
+    <string name="message_too_big_for_video" msgid="2639367545165352543">"彩信内容过大，无法添加视频。"</string>
+    <string name="failed_to_add_media" msgid="8272471485019037446">"抱歉，您无法将此<xliff:g id="NAME">%1$s</xliff:g>添加到信息。"</string>
+    <string name="failed_to_resize_image" msgid="5608354151631833669">"未调整图片大小。"</string>
+    <string name="resize_image_error_information" msgid="4897031754321114959">"抱歉，此图片缩小后仍太大，无法发送。"</string>
+    <string name="forward_prefix" msgid="276280492803486464">"转发: "</string>
+    <string name="discard_message" msgid="6078326880056142781">"舍弃"</string>
+    <string name="discard_message_reason" msgid="2667664943003796133">"您的信息没有有效的接收者，将被舍弃。"</string>
+    <string name="has_invalid_recipient" msgid="1485388396900997383">"无效接收者：&lt;<xliff:g id="NAME">%1$s</xliff:g>&gt;"</string>
+    <string name="invalid_destination" msgid="4573835601024786416">"目标地址无效。"</string>
+    <string name="service_not_activated" msgid="9178218144019626176">"该服务尚未在网络上激活。"</string>
+    <string name="service_message_not_found" msgid="1908877102600048515">"信息已过期或无法查看。"</string>
+    <string name="service_network_problem" msgid="5418984934499160536">"错误：网络出现问题。"</string>
+    <string name="invalid_recipient_message" msgid="7315539322634238519">"请更正接收者，否则他们将无法收到信息。"</string>
+    <string name="cannot_send_message" msgid="3918913277571649400">"无法发送此信息"</string>
+    <string name="cannot_send_message_reason" msgid="8745080126044054343">"您的信息没有有效的接收者。"</string>
+    <string name="cannot_forward_drm_obj" msgid="84606990079390099">"无法转发信息中包含的 DRM 对象。"</string>
+    <string name="converting_to_picture_message" msgid="2980023239017588627">"正在转换为彩信…"</string>
+    <string name="converting_to_text_message" msgid="6374423235426015422">"正在转换为短信…"</string>
+    <string name="cannot_add_slide_anymore" msgid="8437666385579890987">"无法再添加幻灯片。"</string>
+    <string name="cannot_add_picture_and_video" msgid="4721981351130823908">"无法将视频和图片添加到同一张幻灯片。"</string>
+    <string name="cannot_save_message" msgid="5026354972915392301">"无法保存信息。"</string>
+    <string name="message_saved_as_draft" msgid="2503018972659880692">"信息已存为草稿。"</string>
+    <string name="too_many_recipients" msgid="4239709214735078881">"此信息的收件人太多 (<xliff:g id="CURRENTCOUNT">%1$s</xliff:g>)。收件人数上限为 <xliff:g id="MAXLIMIT">%2$s</xliff:g> 个。"</string>
+    <string name="too_many_attachments" msgid="3774037894899750070">"附件数量上限为 <xliff:g id="MAXLIMIT">%1$s</xliff:g> 个。只会添加前 <xliff:g id="CURRENTCOUNT">%2$s</xliff:g> 个。"</string>
+    <string name="adding_attachments_title" msgid="2034535554212405529">"正在添加附件"</string>
+    <string name="adding_attachments" msgid="2423616900586221924">"正在向幻灯片添加项，请稍候。"</string>
+    <string name="building_slideshow_title" msgid="1232338692400726385">"正在构建幻灯片"</string>
+    <string name="cannot_play_audio" msgid="575086601128003093">"无法播放音频。"</string>
+    <string name="preview" msgid="5438149136136446756">"预览"</string>
+    <string name="preview_slideshow" msgid="6824095909448728427">"预览"</string>
+    <string name="replace_image" msgid="3171240952601443619">"替换图片"</string>
+    <string name="duration_sec" msgid="6617032324007824096">"持续时间（<xliff:g id="DURATION">%s</xliff:g>秒）"</string>
+    <string name="duration_selector_title" msgid="5981097971537625852">"幻灯片持续时间 "</string>
+    <string name="layout_selector_title" msgid="7344600117972450771">"幻灯片布局 "</string>
+    <string name="layout_top" msgid="6811021650398972346">"布局（顶部）"</string>
+    <string name="layout_bottom" msgid="5822765871095491843">"布局（底部）"</string>
+    <string name="type_to_compose_text_or_leave_blank" msgid="7769792471457574059">"键入讯息或留空"</string>
+    <string name="duration_not_a_number" msgid="8005480904677546322">"时长必须为数字"</string>
+    <string name="duration_zero" msgid="109945354056393575">"时长必须大于 0 秒"</string>
+    <string name="secs" msgid="6886003523109967972">"秒"</string>
+  <string-array name="select_dialog_items">
+    <item msgid="4840183714016984112">"1 秒"</item>
+    <item msgid="3734955613666864447">"2 秒"</item>
+    <item msgid="6032232473048379828">"3 秒"</item>
+    <item msgid="5978471781525927827">"4 秒"</item>
+    <item msgid="4888440297621208402">"5 秒"</item>
+    <item msgid="6047246213264166841">"6 秒"</item>
+    <item msgid="2327501250056533797">"7 秒"</item>
+    <item msgid="3400770414689795703">"8 秒"</item>
+    <item msgid="4358760614161107970">"9 秒"</item>
+    <item msgid="2618179407176906471">"10 秒"</item>
+    <item msgid="6238597861937337981">"其他…"</item>
+  </string-array>
+    <string name="menu_view_contact" msgid="1414670584423909451">"查看联系人"</string>
+    <string name="menu_add_to_contacts" msgid="1258127580972228970">"添加到通讯录"</string>
+    <string name="hidden_sender_address" msgid="2776075636669924968">"隐藏的发送者地址"</string>
+    <string name="yes" msgid="3246158147503160811">"确定"</string>
+    <string name="no" msgid="4289742508556913860">"取消"</string>
+    <string name="set" msgid="4642365398263275979">"设置"</string>
+    <string name="play" msgid="1888432400937785115">"播放"</string>
+    <string name="edit" msgid="5912118407791492696">"编辑"</string>
+    <string name="try_to_send" msgid="1996751738286080976">"尝试发送"</string>
+    <string name="preferences_title" msgid="6650089610332670157">"设置"</string>
+    <string name="restore_default" msgid="7165341506551155053">"还原默认设置"</string>
+    <string name="pref_notification_settings_title" msgid="4860726154770053004">"通知"</string>
+    <string name="pref_mms_settings_title" msgid="2573616208360684392">"彩信 (MMS) 设置"</string>
+    <string name="pref_sms_settings_title" msgid="9088516111717417514">"短信 (SMS) 设置"</string>
+    <string name="pref_sms_storage_title" msgid="2531726671883516470">"存储设置"</string>
+    <string name="pref_title_sms_disabled" msgid="1441894740130104326">"短信功能已关闭"</string>
+    <string name="pref_summary_sms_disabled" msgid="8975773722051230744">"触摸即可将“短信”设为您的默认短信应用"</string>
+    <string name="pref_title_sms_enabled" msgid="1857849790200375277">"短信功能已开启"</string>
+    <string name="pref_summary_sms_enabled" msgid="2106125420361911250">"触摸即可更改您的默认短信应用"</string>
+    <string name="pref_summary_manage_sim_messages" msgid="4141349892597640864">"管理SIM卡中存储的信息"</string>
+    <string name="pref_summary_mms_delivery_reports" msgid="4874657984217756112">"要求每次发送信息后都返回发送报告"</string>
+    <string name="pref_summary_mms_read_reports" msgid="2748323864008907440">"要求每次发送信息后都返回已读回执"</string>
+    <string name="pref_summary_sms_delivery_reports" msgid="5852207702358546129">"要求每次发送信息后都返回发送报告"</string>
+    <string name="pref_summary_auto_delete" msgid="7719538116486177613">"达到数量上限时删除旧信息"</string>
+    <string name="pref_summary_delete_limit" msgid="597128041393045216">"每���会话限存储 <xliff:g id="COUNT">%1$s</xliff:g> 条信息"</string>
+    <string name="pref_summary_mms_group_mms" msgid="2266928687440696745">"使用彩信将单条信息发送给多个收件人"</string>
+    <string name="pref_title_manage_sim_messages" msgid="7820895261757881177">"管理SIM卡中的信息"</string>
+    <string name="pref_title_mms_delivery_reports" msgid="6666857926679451910">"要求发送报告"</string>
+    <string name="pref_title_mms_group_mms" msgid="1251698526583908432">"群发信息"</string>
+    <string name="pref_title_mms_read_reports" msgid="4882179829495828541">"要求已读报告"</string>
+    <string name="pref_title_sms_delivery_reports" msgid="876064208254451038">"要求发送报告"</string>
+    <string name="pref_title_auto_delete" msgid="7227835692631701134">"删除旧短信"</string>
+    <string name="pref_title_sms_delete" msgid="6890538316799296878">"短信限制"</string>
+    <string name="pref_title_mms_delete" msgid="7265878070847351664">"彩信限制"</string>
+    <string name="pref_title_notification_enabled" msgid="9118792213953729414">"通知"</string>
+    <string name="pref_title_notification_vibrateWhen" msgid="4251208067092761057">"振动"</string>
+    <string name="pref_title_notification_ringtone" msgid="8667533917574559659">"提示音"</string>
+    <string name="pref_messages_to_save" msgid="3202539743892934926">"设置要保存的信息数量"</string>
+    <string name="silent_ringtone" msgid="7981237991326592780">"静音"</string>
+    <string name="pref_title_mms_auto_retrieval" msgid="4021878285474431355">"自动获取"</string>
+    <string name="pref_summary_mms_auto_retrieval" msgid="925163257363757048">"自动获取信息"</string>
+    <string name="pref_title_mms_retrieval_during_roaming" msgid="6016227402731817804">"漫游时自动获取"</string>
+    <string name="pref_summary_mms_retrieval_during_roaming" msgid="2427892806582531020">"漫游时自动获取信息"</string>
+    <string name="confirm_dialog_title" msgid="5810813994465120375">"删除"</string>
+    <string name="confirm_dialog_locked_title" msgid="8179085718150932242">"是否删除锁定的讯息？"</string>
+  <plurals name="confirm_delete_conversation">
+    <item quantity="one" msgid="350118636090800360">"系统将会删除 1 个会话"</item>
+    <item quantity="other" msgid="6918094955792544014">"系统将会删除 <xliff:g id="NUMBER">%1$s</xliff:g> 个会话。"</item>
+  </plurals>
+    <string name="confirm_delete_conversation" msgid="6115966687389279855">"将会删除整个会话。"</string>
+    <string name="confirm_delete_all_conversations" msgid="9036166685235092757">"将会删除所有会话。"</string>
+    <string name="confirm_delete_message" msgid="9121480656609809591">"将会删除此信息。"</string>
+    <string name="confirm_delete_locked_message" msgid="5863578342246077057">"确定要删除此锁定信息吗？"</string>
+    <string name="confirm_delete_all_SIM_messages" msgid="8693652297557966665">"系统会删除SIM卡上的所有短信。"</string>
+    <string name="confirm_delete_SIM_message" msgid="767624259182679915">"SIM 卡上的这条信息会被删除。"</string>
+    <string name="delete_unlocked" msgid="7545321606698162261">"删除锁定信息"</string>
+    <string name="delete" msgid="1409973060081564612">"删除"</string>
+    <string name="select_conversations" msgid="5754828781497722394">"选择会话"</string>
+    <string name="no_conversations" msgid="2095684444005566703">"无会话"</string>
+    <string name="cannot_get_details" msgid="6493664168168047746">"无法获取详细信息"</string>
+    <string name="message_details_title" msgid="9223295113731634528">"消息详情"</string>
+    <string name="message_type_label" msgid="7975373966795945566">"类型： "</string>
+    <string name="text_message" msgid="8196464345251877972">"短信"</string>
+    <string name="multimedia_message" msgid="1512644521083533071">"彩信"</string>
+    <string name="multimedia_notification" msgid="4124031788554972308">"彩信通知"</string>
+    <string name="from_label" msgid="2055117571548171397">"发送者： "</string>
+    <string name="to_address_label" msgid="5837363600471845801">"接收者： "</string>
+    <string name="bcc_label" msgid="530867161453958774">"密送： "</string>
+    <string name="sent_label" msgid="2722190650145251584">"发送时间： "</string>
+    <string name="received_label" msgid="8618029024731693906">"接收时间： "</string>
+    <string name="saved_label" msgid="4183160415593488207">"保存时间： "</string>
+    <string name="subject_label" msgid="8721241914144101631">"主题： "</string>
+    <string name="message_size_label" msgid="4698016210013319786">"信息大小： "</string>
+    <string name="priority_label" msgid="7397600367853359607">"优先级： "</string>
+    <string name="priority_high" msgid="5627897207952009214">"高"</string>
+    <string name="priority_normal" msgid="5715227727384683550">"正常"</string>
+    <string name="priority_low" msgid="8928782666023373987">"低"</string>
+    <string name="message_class_label" msgid="5115748690481550562">"信息类别： "</string>
+    <string name="error_code_label" msgid="5810068247647058769">"错误代码： "</string>
+    <string name="menu_edit" msgid="3056513240155967777">"编辑"</string>
+    <string name="menu_delete_messages" msgid="2610286783513247420">"删除信息"</string>
+    <string name="menu_delete_all_messages">"删除所有信息"</string>
+    <string name="menu_lock" msgid="7603793126077557472">"锁定"</string>
+    <string name="menu_unlock" msgid="6662865558677424039">"解锁"</string>
+    <string name="sim_copy_to_phone_memory" product="tablet" msgid="3721000641648594602">"复制到平板电脑内存"</string>
+    <string name="sim_copy_to_phone_memory" product="default" msgid="5895767417844881971">"复制到手机内存"</string>
+    <string name="sim_delete" msgid="610790510655316922">"删除"</string>
+    <string name="sim_manage_messages_title" msgid="3989147182100584333">"SIM卡上的短信"</string>
+    <string name="sim_view" msgid="1997173541766393706">"查看"</string>
+    <string name="sim_empty" msgid="2356766833071636297">"SIM卡中无短信。"</string>
+    <string name="delivery_header_title" msgid="5361719578869045764">"报告"</string>
+    <string name="status_none" msgid="8253075950774894961">"(无)"</string>
+    <string name="status_pending" msgid="2739860824607984892">"待接收"</string>
+    <string name="status_read" msgid="7576195253780627332">"阅读"</string>
+    <string name="status_received" msgid="7264334589461906965">"已收到"</string>
+    <string name="status_failed" msgid="1998776666856593544">"失败"</string>
+    <string name="status_unread" msgid="8555305495998700198">"未读"</string>
+    <string name="status_rejected" msgid="2613641949065942678">"已拒绝"</string>
+    <string name="recipient_label" msgid="3922667485312634446">"接收者： "</string>
+    <string name="status_label" msgid="7283375460919181660">"状态： "</string>
+    <string name="attach_image" msgid="6439985727687107742">"照片"</string>
+    <string name="attach_take_photo" msgid="4280601313184373837">"拍摄照片"</string>
+    <string name="attach_video" msgid="4264272693501538294">"视频"</string>
+    <string name="attach_record_video" msgid="3099814114743078615">"拍摄视频"</string>
+    <string name="attach_sound" msgid="3149325985970669609">"音频"</string>
+    <string name="attach_record_sound" msgid="6011431304469858929">"录音"</string>
+    <string name="attach_slideshow" msgid="3497422151091037063">"幻灯片"</string>
+    <string name="select_bottom_text" msgid="4201966447623311931">"底部文本"</string>
+    <string name="select_top_text" msgid="6734183477539197815">"顶部文本"</string>
+    <string name="delivery_toast_body" msgid="5960519861835727013">"%s收到了短信。"</string>
+    <string name="notification_multiple" msgid="7684007285202109490">"<xliff:g id="COUNT">%s</xliff:g> 条未读信息。"</string>
+    <string name="notification_multiple_title" msgid="332602028959557541">"新信息"</string>
+    <string name="notification_failed_multiple" msgid="4081781748475686236">"<xliff:g id="COUNT">%s</xliff:g> 条信息无法发送。"</string>
+    <string name="notification_failed_multiple_title" msgid="1112032024904397126">"信息未发送"</string>
+    <string name="sim_full_title" msgid="1809829051697702810">"SIM卡已满"</string>
+    <string name="sim_full_body" msgid="6241664980790322925">"删除部分信息以腾出更多空间。"</string>
+    <string name="sms_full_title" msgid="6041287140125011854">"短信内存已满"</string>
+    <string name="sms_full_body" msgid="7757490997215434514">"存储空间已满，无法接收传入的信息，请删除旧信息。"</string>
+    <string name="sms_rejected_title" msgid="8548394922491529811">"短信遭拒"</string>
+    <string name="sms_rejected_body" msgid="7187754586609631934">"由于未知的原因，导致传入的短信被拒收。"</string>
+    <string name="type_audio" msgid="3842064092332309756">"音频"</string>
+    <string name="type_picture" msgid="4091928975383609443">"图片"</string>
+    <string name="type_video" msgid="8521556159545168441">"视频"</string>
+    <string name="confirm" msgid="3155110885840591914">"确认"</string>
+    <string name="message_send_read_report" msgid="6997117678914261250">"将会发送已读报告。"</string>
+    <string name="message_queued" msgid="8869479754825264671">"当前无法发送信息，将在服务恢复后发送。"</string>
+    <string name="fdn_check_failure" msgid="7880740763778173551">"您只能向固定拨号号码发送信息。"</string>
+    <string name="no_subject" msgid="4168963736134552285">"（无主题）"</string>
+    <string name="unknown_sender" msgid="4929330613278853635">"未知发送者"</string>
+    <string name="dl_failure_notification" msgid="2457080452886498701">"下载来自<xliff:g id="FROM">%2$s</xliff:g>的<xliff:g id="SUBJECT">%1$s</xliff:g>信息失败。"</string>
+    <string name="rate_limit_surpassed" msgid="1347801608211628177">"确认"</string>
+    <string name="confirm_rate_limit" msgid="234228299751243067">"即将发送多条彩信。确定要这样做吗？"</string>
+    <string name="message_download_failed_title" msgid="5722226064394767921">"信息未下载"</string>
+    <string name="message_send_failed_title" msgid="3469894907399046372">"信息未发送"</string>
+    <string name="message_failed_body" msgid="2740907094762116644">"选择以检查信息并重试。"</string>
+    <string name="download_later" msgid="4486286146421650880">"当前无法下载。请稍后再试。"</string>
+    <string name="no_apn" msgid="505932916503312015">"设备上未指定任何 APN。"</string>
+    <string name="select_audio" msgid="3120822451872772124">"选择音频"</string>
+    <string name="copy_to_sdcard" msgid="757028609638184856">"保存附件"</string>
+    <string name="copy_to_sdcard_success" msgid="6940309183311068648">"附件已保存"</string>
+    <string name="copy_to_sdcard_fail" msgid="4209780336940754675">"无法保存附件"</string>
+    <string name="save_ringtone" msgid="2310157075045201051">"另存为铃声"</string>
+    <string name="saved_ringtone" msgid="6616730290861857836">"铃声已保存"</string>
+    <string name="saved_ringtone_fail" msgid="5447210504935083544">"无法保存铃声"</string>
+    <string name="menu_insert_smiley" msgid="4964504393061025071">"插入表情符号"</string>
+    <string name="menu_group_participants" msgid="4288356090262299071">"群组参与者"</string>
+    <string name="select_link_title" msgid="600168208731216059">"选择操作"</string>
+    <string name="slide_number" msgid="1923958526266726635">"幻灯片 <xliff:g id="NUMBER">%s</xliff:g>"</string>
+  <plurals name="slide_duration">
+    <item quantity="one" msgid="1654101988340583935">"<xliff:g id="NUMBER">%s</xliff:g>秒"</item>
+    <item quantity="few" msgid="7887190171856293871">"<xliff:g id="NUMBER">%s</xliff:g>秒"</item>
+    <item quantity="other" msgid="3736425355579939863">"<xliff:g id="NUMBER">%s</xliff:g>秒"</item>
+  </plurals>
+    <string name="delivery_report_activity" msgid="2957463094232916364">"发送报告"</string>
+    <string name="storage_limits_activity" msgid="8810530813311077716">"存储限制"</string>
+    <string name="change_duration_activity" msgid="7048606979485031693">"更改持续时间"</string>
+    <string name="edit_slideshow_activity" msgid="8751493388760050529">"编辑幻灯片"</string>
+    <string name="recipient_list_activity" msgid="1254938236543727019">"群组参与者"</string>
+    <string name="edit_slide_activity" msgid="8752829671778696983">"编辑幻灯片"</string>
+    <string name="slideshow_activity" msgid="5658249461317434432">"播放幻灯片"</string>
+    <string name="class_0_message_activity" msgid="8474176218999130627">"0 类信息"</string>
+    <string name="search_label" msgid="6042598929386174964">"信息"</string>
+    <string name="search_hint" msgid="7183732852849365466">"搜索信息"</string>
+    <string name="search" msgid="7560238620274735199">"信息"</string>
+    <string name="search_setting_description" msgid="4104004595086437572">"消息中的文字"</string>
+    <string name="search_empty" msgid="645052646985297065">"没有匹配项"</string>
+  <plurals name="search_results_title">
+    <item quantity="one" msgid="4657073733087431350">"<xliff:g id="NUMBER">%1$s</xliff:g> 条符合“<xliff:g id="SEARCH">%2$s</xliff:g>”的搜索结果"</item>
+    <item quantity="other" msgid="6196382287749539209">"<xliff:g id="NUMBER">%1$s</xliff:g> 条符合“<xliff:g id="SEARCH">%2$s</xliff:g>”的搜索结果"</item>
+  </plurals>
+    <string name="search_history" msgid="4127805495662693154">"<xliff:g id="COUNT">%1$s</xliff:g> 项符合“<xliff:g id="SEARCH">%2$s</xliff:g>”的搜索结果"</string>
+    <string name="confirm_clear_search_title" msgid="8510295993632032904">"清除"</string>
+    <string name="confirm_clear_search_text" msgid="8731877031837077478">"搜索记录将被清除。"</string>
+    <string name="pref_mms_clear_search_history_title" msgid="6159758850628148164">"清除搜索记录"</string>
+    <string name="pref_mms_clear_search_history_summary" msgid="7960005384066460035">"清除以前的短信搜索记录，使其不再出现在“搜索”框中"</string>
+    <string name="save" msgid="6847069284991531310">"保存"</string>
+    <string name="storage_limits_title" msgid="7074684882530693016">"限制短信数"</string>
+    <string name="storage_limits_message" msgid="8729608389698270388">"是否要限制每个会话存储的短信数？"</string>
+    <string name="storage_limits_setting" msgid="4952781049308537373">"设置限制"</string>
+    <string name="storage_limits_setting_dismiss" msgid="1433841310158458034">"无限制"</string>
+    <string name="too_many_unsent_mms" msgid="8005932837414848242">"目前不能发送消息。未发送的彩信过多。"</string>
+    <string name="sending_message" msgid="2054406576361149715">"正在发送..."</string>
+    <string name="pick_too_many_recipients" msgid="650087588867628044">"收件人过多"</string>
+    <string name="adding_recipients" msgid="2962810172527532357">"正在添加收件人..."</string>
+    <string name="draft_separator" msgid="5402575086540243019">"， "</string>
+    <string name="message_count_format" msgid="4434763220590778012">" <xliff:g id="NUMBER">%1$s</xliff:g>"</string>
+    <string name="error_state" msgid="5177386717626893507">"状态不一致"</string>
+    <string name="error_state_text" msgid="7918866106335387710">"会话和收件人的状态不一致。请为错误截图，并通过 http://go/droidanizer 向我们报告这一问题"</string>
+  <plurals name="recipient_count">
+    <item quantity="other" msgid="7338580381574463136">"<xliff:g id="NUMBER">%1$s</xliff:g> 个人"</item>
+  </plurals>
+  <string name="message_timestamp_format" msgid="4188999027493614617">"<xliff:g id="STRING_0">%1$s</xliff:g> - <xliff:g id="STRING_1">%2$s</xliff:g>"</string>
+
+  <string name="file_attachment_common_name">多个文件(<xliff:g id="text">%s</xliff:g>)</string>
+    <string name="file_attachment_contains">包含 </string>
+		<string name="file_attachment_files"> 个文件</string>    
+		<string name="save_attachment">保存附件</string>
+    <string name="save_multi_attachment_notes">该文件包含多个内容，是否查看并保存？</string>
+		<string name="save_single_attachment_notes">彩信不支持阅读本格式文件，是否保存到文件管理器？</string>    
+		<string name="multi_files">多个附件</string>
+    <string name="save_single_supportformat_attachment_notes">是否保存到文件管理器？</string>
+    <string name="menu_cell_broadcasts">"小区广播"</string>
+    <string name="delivered_label">"已发送： "</string>
+    <string name="message_count_notification">"<xliff:g id="NUMBER">%1$s</xliff:g> 条新信息"</string>
+    <plurals name="message_count_notification_overflow">
+        <item quantity="one">"+<xliff:g id="NUMBER">%1$s</xliff:g> 条其他信息"</item>
+        <item quantity="other">"+<xliff:g id="NUMBER">%1$s</xliff:g> 条其他信息"</item>
+    </plurals>
+    <string name="view_more_conversations">"查看更多会话"</string>
+    <string name="attachment_audio">"音频"</string>
+    <string name="attachment_slideshow">"幻灯片"</string>
+    <string name="attachment_video">"视频"</string>
+    <string name="attachment_picture">"图片"</string>
+    <string name="notification_separator">"  "</string>
+    <string name="enumeration_comma">"、 "</string>
+
+    <string name="exceed_editor_size_limitation">"已达到字符上限。"</string>
+
+    <string name="add_top_slide">"添加幻灯片(顶部)"</string>
+    <string name="add_bottom_slide">"添加幻灯片(底部)"</string>
+
+<string name="prefDialogTitle_vibrateWhen">振动</string>
+    <plurals name="notification_multiple">
+     <item quantity="one">%d 条未读信息。</item>
+     <item quantity="other">%d 条未读信息。</item>
+   </plurals>
+    <string name="cell_broadcast">小区广播</string>
+    <string name="cell_broadcast_title">小区广播设置</string>
+    <string name="cell_broadcast_settings">SIM卡小区广播设置</string>
+    <string name="menu_insert_quick_text">"﻿插入常用短语"</string>
+    <string name="select_quick_text">"选择常用短语"</string>
+    <string name="add">"添加"</string>
+    <string name="quick_text_editor">编辑常用短语</string>
+    <string name="modify_successful">修改成功</string>
+    <string name="modify_unsuccessful">修改失败！</string>
+    <string name="delete_successful">删除成功</string>
+    <string name="delete_unsuccessful">删除失败！</string>
+    <string name="add_quick_text_successful">成功添加短语</string>
+    <string name="already_have_quick_text">此短语已存在！</string>
+</resources>

Property changes on: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values-zh-rCN/strings.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml	(revision 2619)
@@ -0,0 +1,849 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- The name of the SMS/MMS app as it appears to the user in the Home screen, task switcher, etc. -->
+    <string name="app_label">Messaging</string>
+
+    <!-- Command name to open a Compose screen; displays in conversation list.
+         Also used as accessibility text for widget's new message button -->
+    <string name="new_message">New message</string>
+    <!-- Context menu item on an individual message for dialing the sender's phone number -->
+    <string name="menu_call_back">Call <xliff:g id="name">%s</xliff:g></string>
+    <!-- Context menu item on an individual message for emailing the sender -->
+    <string name="menu_send_email">Send email to <xliff:g id="name">%s</xliff:g></string>
+
+    <!-- Menu item for starting a new conversation -->
+    <string name="menu_compose_new">Compose</string>
+    <!-- Menu item for accessing application settings -->
+    <string name="menu_preferences">Settings</string>
+    <!-- Menu shown in the context menu when long pressing on a message when the message contains
+         one or more phone numbers and/or email addresses and the number or email is new to
+         contacts. [CHAR LIMIT=50] -->
+    <string name="menu_add_address_to_contacts">Add <xliff:g id="contactEmailOrNumber">%s</xliff:g> to Contacts</string>
+    <!-- Menu item to call the recipient of the conversation on the phone (imperative verb) -->
+    <string name="menu_call">Call</string>
+    <!-- Menu item for search -->
+    <string name="menu_search">Search</string>
+    <!-- Menu item for deleting all conversations -->
+    <string name="menu_delete_all">Delete all threads</string>
+    <!-- Context menu item on an individual conversation for deleting that conversation -->
+    <string name="menu_delete">Delete thread</string>
+    <!-- Context menu item on an individual conversation for viewing that conversation -->
+    <string name="menu_view">View thread</string>
+    <!-- Menu item for debugging - do not localize -->
+    <string name="menu_debug_dump">DEBUG DUMP</string>
+    <!-- Message that appears on screen while SIM card messages are retrieved -->
+    <string name="refreshing">Refreshing\u2026</string>
+
+    <!-- Menu item to show received cell broadcasts. [CHAR LIMIT=30] -->
+    <string name="menu_cell_broadcasts">Cell broadcasts</string>
+
+    <!-- Tag appearing on conversations in the conversation list that contain a draft message -->
+    <string name="has_draft">Draft</string>
+
+    <!-- Subject to display in the conversation list if there is no subject -->
+    <string name="no_subject_view">(No subject)</string>
+
+    <!-- Name of the local user when displaying sender of an outgoing message (personal pronoun) -->
+    <string name="messagelist_sender_self">Me</string>
+    <!-- Context menu item on an individual message for viewing an attached slideshow -->
+    <string name="view_slideshow">View slideshow</string>
+    <!-- Context menu item on an individual message for viewing message details such as time and date -->
+    <string name="view_message_details">View details</string>
+    <!-- Context menu item on an individual message for viewing a delivery report -->
+    <string name="view_delivery_report">View report</string>
+    <!-- Context menu item on an individual message for deleting only that message -->
+    <string name="delete_message">Delete</string>
+    <!-- Time and date a message is due to expire -->
+    <string name="expire_on">"Expires: <xliff:g id="date">%s</xliff:g>"</string>
+    <!-- Abbreviation for "kilobyte" -->
+    <string name="kilobyte">KB</string>
+
+    <!-- Dialog box title brought up when warning the user that a message could not be delivered -->
+    <string name="undelivered_msg_dialog_title">Undelivered message</string>
+    <!-- Dialog box message indicating that a message could not be delivered, including the time of last attempt -->
+    <string name="undelivered_msg_dialog_body">Unable to send this message.\nAttempt made: <xliff:g id="message">%s</xliff:g>.</string>
+    <!-- Dialog box message indicating that a message could not be delivered -->
+    <string name="undelivered_sms_dialog_body">Unable to send this message.</string>
+    <!-- Menu item for deleting the entire conversation currently being viewed -->
+    <string name="delete_thread">Delete thread</string>
+    <!-- Context menu item on an individual message for forwarding it to another recipient -->
+    <string name="menu_forward">Forward</string>
+    <!-- Text of a button appearing for MMS messages that have not yet been downloaded, causing the message
+         to be downloaded (imperative verb) -->
+    <string name="download">Download</string>
+    <!-- Message displayed in place of the "download message" button once it has been pressed,
+         indicating that the download is in progress -->
+    <string name="downloading">Downloading</string>
+    <!-- Formatting for subject displayed inline, prepended to MMS message text -->
+    <string name="inline_subject">"&lt;Subject: <xliff:g id="subject">%s</xliff:g>&gt;"</string>
+    <!-- Text to display when the actual text is inaccessible due to DRM protection -->
+    <string name="drm_protected_text">"* DRM protected text *"</string>
+    <!-- Error message to display when DRM rights are insufficient to access some data -->
+    <string name="insufficient_drm_rights">Insufficient DRM rights detected.</string>
+    <!-- Individual message context menu item -->
+    <string name="copy_message_text">Copy text</string>
+    <!-- Header for context menu on an individual message -->
+    <string name="message_options">Message options</string>
+    <!-- Header for context menu on an individual slideshow -->
+    <string name="slideshow_options">Slideshow options</string>
+
+    <!-- Menu item in slideshow edit screen for moving the selected slide up in the order -->
+    <string name="move_up">Move up</string>
+    <!-- Menu item in slideshow edit screen for moving the selected slide down in the order -->
+    <string name="move_down">Move down</string>
+    <!-- Menu item in slideshow edit screen for removing the selected slide from the slideshow -->
+    <string name="remove_slide">Remove slide</string>
+    <!-- Menu item in slideshow edit screen for adding a new slide to the slideshow -->
+    <string name="add_slide">Add slide</string>
+    <!-- Text displayed below "Add slide" item in slideshow edit screen -->
+    <string name="add_slide_hint">Select to create new slide.</string>
+    <!-- Menu item in slideshow edit screen for discarding the entire slideshow -->
+    <string name="discard_slideshow">Discard slideshow</string>
+    <!-- Header of slideshow showing which slide is being displayed -->
+    <string name="slide_show_part">Part <xliff:g id="part">%1$s</xliff:g>/<xliff:g id="total">%2$s</xliff:g></string>
+
+
+    <!-- Menu item in slide edit screen for removing the text from the slide being edited -->
+    <string name="remove_text">Remove text</string>
+    <!-- Menu item in slide edit screen for adding a picture to the slide being edited -->
+    <string name="add_picture">Add picture</string>
+    <!-- Menu item in slide edit screen for removing the picture from the slide being edited -->
+    <string name="remove_picture">Remove picture</string>
+    <!-- Menu item in slide edit screen for adding music to the slide being edited -->
+    <string name="add_music">Add music</string>
+    <!-- Menu item in slide edit screen for removing the music from the slide being edited -->
+    <string name="remove_music">Remove music</string>
+    <!-- Menu item in slide edit screen for adding a video to the slide being edited -->
+    <string name="add_video">Add video</string>
+    <!-- Menu item in slide edit screen for removing the video from the slide being edited -->
+    <string name="remove_video">Remove video</string>
+
+    <!-- Hint displayed in message recipient text box when starting a new conversation -->
+    <string name="to_hint">To</string>
+    <!-- Hint displayed in subject edit text box when adding a subject -->
+    <string name="subject_hint">Subject</string>
+
+    <!-- Menu item in conversation screen for attaching something to the message being composed -->
+    <string name="add_attachment">Attach</string>
+    <!-- Menu item in conversation screen for adding a subject to the message being composed -->
+    <string name="add_subject">Add subject</string>
+    <!-- Menu item in conversation screen for discarding the message currently being composed -->
+    <string name="discard">Discard</string>
+
+    <!-- Button next to an attachment during message composition to view the attachment (imperative verb) -->
+    <string name="view">View</string>
+    <!-- Button next to an attachment during message composition to replace the attachment (imperative verb) -->
+    <string name="replace">Replace</string>
+    <!-- Button next to an attachment during message composition to remove the attachment (imperative verb) -->
+    <string name="remove">Remove</string>
+
+    <!-- Button in conversation screen for sending the SMS message currently being composed (imperative verb) -->
+    <string name="send">Send</string>
+    <!-- Text to appear directly below the "Send" text on the SMS/MMS send button. The "MMS" text is on a second line in a smaller font. This is similar to saying "Send (mms)". -->
+    <string name="mms">MMS</string>
+    <!-- Content description for the send button when sending an mms (imperative verb) -->
+    <string name="send_mms">Send MMS</string>
+
+    <!-- Menu item in conversation screen for returning to the conversation list -->
+    <string name="all_threads">All threads</string>
+
+    <!-- Hint text in message body field when keyboard is exposed -->
+    <string name="type_to_compose_text_enter_to_send">Type message</string>
+    <!-- Hint text in message body field when keyboard is hidden -->
+    <string name="open_keyboard_to_compose_message">Open keyboard to type message</string>
+    <!-- Hint text when we are not the default SMS app -->
+    <string name="sending_disabled_not_default_app">Sending disabled</string>
+    <!-- Toast text when user tries to compose while we are not the default SMS app -->
+    <string name="compose_disabled_toast">Can\'t compose. Not default SMS app.</string>
+    <!-- Toast message while an image is being resized -->
+    <string name="compressing">Picture too large. Compressing\u2026</string>
+
+    <!-- Error message indicating the format for the specified media type (e.g. "picture") is unsupported -->
+    <string name="unsupported_media_format">Unsupported <xliff:g id="name">%1$s</xliff:g> format</string>
+    <!-- Message prompting the user to select a different item; item string as type-appropriate (e.g. "picture") -->
+    <string name="select_different_media">Please select a different <xliff:g id="name">%1$s</xliff:g>.</string>
+    <!-- Message indicating that the message size limit has been reached -->
+    <string name="exceed_message_size_limitation">Message size limit reached.</string>
+    <string name="omh_exceed_message_size_limitation">R-UIM message size limit reached</string>
+    <!-- Message indicating that the message is too big and there is no space to attach a video -->
+    <string name="message_too_big_for_video">The message is too big to attach a video.</string>
+    <!-- Error message indicating that the item trying to be attached could not be added -->
+    <string name="failed_to_add_media">Sorry, you cannot add this <xliff:g id="name">%1$s</xliff:g> to your message.</string>
+    <!-- Error message indicating that the picture being attached and resized could not be resized -->
+    <string name="failed_to_resize_image">Picture not resized.</string>
+    <!-- Error message indicating that an image being attached is still too large to send even after resize -->
+    <string name="resize_image_error_information">Sorry, even when resized this picture is too large to send.</string>
+    <!-- String prepended to forwarded messages to indicate they were forwarded -->
+    <string name="forward_prefix">Fwd:\u0020</string>
+    <!-- Dialog box title that appears when a draft message will not be saved due to invalid recipients -->
+    <string name="discard_message">Discard</string>
+    <!-- Dialog message text explaining that a draft message will not be saved due to invalid recipients -->
+    <string name="discard_message_reason">Your message will be discarded because it has no valid recipients.</string>
+    <!-- Dialog box title indicating which recipients are invalid when the user tries to send a message with invalid recipients -->
+    <string name="has_invalid_recipient">Invalid recipient(s): &lt;<xliff:g id="name">%1$s</xliff:g>&gt;</string>
+    <!-- While sending a message, if it has invalid recipient, display this message. -->
+    <string name="invalid_destination">Invalid destination address.</string>
+    <!-- While sending a message, this error is expected to be generated when user does not have
+         MMS enabled on his account. [CHAR LIMIT=NONE] -->
+    <string name="service_not_activated">Service not activated on network.</string>
+    <!-- If a message has expired and is no longer available on MMSC, show this toast. [CHAR LIMIT=NONE] -->
+    <string name="service_message_not_found">Message expired or not available.</string>
+    <!-- If a message can't be sent because of a MMSC network problem, show this toast. [CHAR LIMIT=NONE] -->
+    <string name="service_network_problem">Error network problem.</string>
+    <!-- Dialog message text when the user tries to send a message with invalid recipients -->
+    <string name="invalid_recipient_message">Please correct the recipient(s) or they will not receive the message.</string>
+    <!-- Dialog box title indicating the message cannot be sent because there are no valid recipients -->
+    <string name="cannot_send_message">Cannot send this message</string>
+    <!-- Dialog message text indicating the message cannot be sent because there are no valid recipients -->
+    <string name="cannot_send_message_reason">Your message has no valid recipients.</string>
+    <!-- Error message displayed when the user attempts to forward a message with DRM-locked contents -->
+    <string name="cannot_forward_drm_obj">The DRM object included in the message cannot be forwarded.</string>
+
+    <!-- Brief message that appears when converting a message from SMS to MMS. -->
+    <string name="converting_to_picture_message">Converting to multimedia message\u2026</string>
+    <!-- Brief message that appears when converting a message from MMS to SMS. -->
+    <string name="converting_to_text_message">Converting to text message\u2026</string>
+    <!-- Brief message that appears when the maximum number of slides has been reached -->
+    <string name="cannot_add_slide_anymore">Cannot add more slides.</string>
+    <!-- Brief message that appears when user tries to add picture to a slide which already has a video. -->
+    <string name="cannot_add_picture_and_video">Cannot add video and picture to one slide.</string>
+    <!-- Brief message that appears when the message cannot be saved -->
+    <string name="cannot_save_message">Cannot save message.</string>
+    <!-- Brief message that appears when a message has automatically been saved as a draft -->
+    <string name="message_saved_as_draft">Message saved as draft.</string>
+    <!-- Brief message that appears when too many recipients have been added -->
+    <string name="too_many_recipients">This message has too many recipients (<xliff:g id="currentCount">%1$s</xliff:g>). There is a limit of <xliff:g id="maxLimit">%2$s</xliff:g> recipients.</string>
+    <!-- Brief message that appears when too many videos/pictures are imported -->
+    <string name="too_many_attachments">There is a limit of <xliff:g id="maxLimit">%1$s</xliff:g> attachments. Only the first <xliff:g id="currentCount">%2$s</xliff:g> will be added.</string>
+    <!-- Alert dialog title when adding attachments is taking a while -->
+    <string name="adding_attachments_title">Adding attachments</string>
+    <!-- Alert dialog when adding attachments is taking a while -->
+    <string name="adding_attachments">Please wait while the items are added to the slideshow.</string>
+    <!-- Alert dialog title when creating a slideshow [CHAR LIMIT=none] -->
+    <string name="building_slideshow_title">Building slideshow</string>
+
+    <!-- Error message indicating that an audio attachment cannot be played -->
+    <string name="cannot_play_audio">Cannot play audio.</string>
+
+    <!-- Button in the slide editor screen used to preview the slide (imperative verb) -->
+    <string name="preview">Preview</string>
+    <!-- Menu item in the slide editor screen used to preview the entire slideshow (imperative verb) -->
+    <string name="preview_slideshow">Preview</string>
+    <!-- Button in the slide editor screen used to replace the attached picture -->
+    <string name="replace_image">Replace picture</string>
+    <!-- String for slide duration in seconds -->
+    <string name="duration_sec">Duration (<xliff:g id="duration">%s</xliff:g> sec)</string>
+    <!-- Dialog box title for duration selector -->
+    <string name="duration_selector_title">"Duration for slide "</string>
+    <!-- Dialog box title for slide layout selector -->
+    <string name="layout_selector_title">"Slideshow layout "</string>
+    <!-- Slide layout option for layout at the top -->
+    <string name="layout_top">Layout (top)</string>
+    <!-- Slide layout option for layout at the bottom -->
+    <string name="layout_bottom">Layout (bottom)</string>
+    <!-- Hint in slide text field before text is typed -->
+    <string name="type_to_compose_text_or_leave_blank">Type message, or leave blank</string>
+    <!-- Toast when the user enters a non-numeric value for the duration of a slide -->
+    <string name="duration_not_a_number">Duration must be a number</string>
+    <!-- Toast when the user enters a zero value for the duration of a slide -->
+    <string name="duration_zero">Duration must be greater than zero seconds</string>
+
+    <!-- In duration selection dialog box, short version of "seconds" -->
+    <string name="secs">secs</string>
+    <!-- Options for slide duration in duration selection dialog box -->
+    <string-array name="select_dialog_items">
+         <item>1 second</item>
+         <item>2 seconds</item>
+         <item>3 seconds</item>
+         <item>4 seconds</item>
+         <item>5 seconds</item>
+         <item>6 seconds</item>
+         <item>7 seconds</item>
+         <item>8 seconds</item>
+         <item>9 seconds</item>
+         <item>10 seconds</item>
+         <item>Other\u2026</item>
+    </string-array>
+
+    <!-- Context menu item on a message recipient for viewing their contact info -->
+    <string name="menu_view_contact">View contact</string>
+    <!-- Context menu item on a message recipient for adding them to the user's
+         contacts (used if the recipient is not already in the address book) -->
+    <string name="menu_add_to_contacts">Add to Contacts</string>
+
+    <!-- Sender to be used if the sender address has been hidden -->
+    <string name="hidden_sender_address">Hidden sender address</string>
+
+    <!-- Text to be used for affirmative response button in dialog boxes -->
+    <string name="yes">OK</string>
+    <!-- Text to be used for negative response button in dialog boxes -->
+    <string name="no">Cancel</string>
+    <!-- Text to be used for affirmative response button in setting SMS limits dialog box -->
+    <string name="set">Set</string>
+
+    <!-- Button text used for playing an attachment or slideshow (imperative verb) -->
+    <string name="play">Play</string>
+    <!-- Button text used for editing a slideshow (imperative verb) -->
+    <string name="edit">Edit</string>
+    <!-- Button used for trying to send a message that has some valid recipients and some
+         invalid recipients, in spite of the warning presented to the user -->
+    <string name="try_to_send">Try to send</string>
+
+    <!-- Title of Settings screen -->
+    <string name="preferences_title">"Settings"</string>
+    <!-- Settings screen menu item for restoring all settings to default -->
+    <string name="restore_default">"Restore default settings"</string>
+
+    <!-- Settings screen, section heading for notifications -->
+    <string name="pref_notification_settings_title">Notification settings</string>
+    <!-- Settings screen, section heading for MMS-specific settings -->
+    <string name="pref_mms_settings_title">"Multimedia message (MMS) settings"</string>
+    <!-- Settings screen, section heading for SMS-specific settings -->
+    <string name="pref_sms_settings_title">"Text message (SMS) settings"</string>
+    <!-- Settings screen, section heading for storage-specific settings -->
+    <string name="pref_sms_storage_title">Storage settings</string>
+    <!-- Title for SMS Disabled -->
+    <string name="pref_title_sms_disabled">SMS Disabled</string>
+    <!-- Summary for SMS Disabled -->
+    <string name="pref_summary_sms_disabled">Touch to make Messaging your default SMS app</string>
+    <!-- Title for SMS Enabled -->
+    <string name="pref_title_sms_enabled">SMS Enabled</string>
+    <!-- Summary for SMS Enabled -->
+    <string name="pref_summary_sms_enabled">Touch to change your default SMS app</string>
+
+    <!-- Settings item description for entering SIM card message screen -->
+    <string name="pref_summary_manage_sim_messages">Manage messages stored on your SIM card</string>
+    <!-- Settings item description for boolean MMS delivery report setting -->
+    <string name="pref_summary_mms_delivery_reports">Request a delivery report for each message you send</string>
+    <!-- Settings item description for boolean MMS read report setting -->
+    <string name="pref_summary_mms_read_reports">Request a read report for each message you send</string>
+    <!-- Settings item description for boolean SMS delivery report setting -->
+    <string name="pref_summary_sms_delivery_reports">Request a delivery report for each message you send</string>
+    <!-- Settings item description for boolean auto-delete messages setting -->
+    <string name="pref_summary_auto_delete">Delete old messages as limits are reached</string>
+    <!-- Settings item description for integer auto-delete sms message limit -->
+    <string name="pref_summary_delete_limit"><xliff:g id="count">%1$s</xliff:g> messages per conversation</string>
+    <!-- Settings item description for boolean MMS enable group MMS setting -->
+    <string name="pref_summary_mms_group_mms">Use MMS to send a single message when there are multiple recipients</string>
+    <!-- Settings item for entering SIM card message screen -->
+    <string name="pref_title_manage_sim_messages">Manage SIM card messages</string>
+    <!-- Settings item for boolean option to enable/disable MMS delivery reports -->
+    <string name="pref_title_mms_delivery_reports">Request delivery report</string>
+    <!-- Settings item for boolean option to enable/disable MMS group messages -->
+    <string name="pref_title_mms_group_mms">Group messaging</string>
+    <!-- Settings item for boolean option to enable/disable MMS read reports -->
+    <string name="pref_title_mms_read_reports">Request read report</string>
+    <!-- Settings item for boolean option to enable/disable SMS delivery reports -->
+    <string name="pref_title_sms_delivery_reports">Request delivery report</string>
+    <!-- Settings item for boolean option to enable/disable auto-deletion of messages -->
+    <string name="pref_title_auto_delete">Delete old messages</string>
+    <!-- Settings item for integer option to set SMS delete limit -->
+    <string name="pref_title_sms_delete">Text message limit</string>
+    <!-- Settings item for integer option to set MMS delete limit -->
+    <string name="pref_title_mms_delete">Multimedia message limit</string>
+    <!-- Settings item for boolean option to display message notifications -->
+    <string name="pref_title_notification_enabled">Message notifications</string>
+    <!-- Settings item for boolean option to vibrate during message notification -->
+    <string name="pref_title_notification_vibrateWhen">Vibrate</string>
+    <!-- Settings item for entering ringtone selection screen -->
+    <string name="pref_title_notification_ringtone">Sound</string>
+    <!-- Settings item for setting the number of message to save for each conversation -->
+    <string name="pref_messages_to_save">Set number of messages to save</string>
+    <!-- Settings screen, what to display for Ringtone when the user chooses "silent" [CHAR LIMIT=100]-->
+    <string name="silent_ringtone">Silent</string>
+
+    <!-- The value to use when migrating from old versions for a true vibrate setting -->
+    <string translatable="false" name="prefDefault_vibrate_true">always</string>
+    <!-- The value to use when migrating from old versions for a false vibrate setting -->
+    <string translatable="false" name="prefDefault_vibrate_false">never</string>
+
+    <!-- The vibrateWhen values -->
+    <string-array translatable="false" name="prefValues_vibrateWhen">
+        <item>always</item>
+        <item>silent</item>
+        <item>never</item>
+    </string-array>
+
+    <!-- Dialog title for the Vibrate dialog -->
+    <string name="prefDialogTitle_vibrateWhen">Vibrate</string>
+
+    <!-- Settings item for boolean option to auto-retrieve incoming MMS messages -->
+    <string name="pref_title_mms_auto_retrieval">Auto-retrieve</string>
+    <!-- Settings item description for boolean MMS auto-retrieve option -->
+    <string name="pref_summary_mms_auto_retrieval">Automatically retrieve messages</string>
+    <!-- Settings item for boolean option to auto-retrieve incoming MMS messages while roaming -->
+    <string name="pref_title_mms_retrieval_during_roaming">Roaming auto-retrieve</string>
+    <!-- Settings item description for boolean MMS auto-retrieve while roaming option -->
+    <string name="pref_summary_mms_retrieval_during_roaming">Automatically retrieve messages while roaming</string>
+
+    <!-- Confirm Delete -->
+    <!-- Delete confirmation dialog title -->
+    <string name="confirm_dialog_title">Delete</string>
+    <!-- Delete confirmation dialog title for locked messages -->
+    <string name="confirm_dialog_locked_title">Delete locked message?</string>
+    <!-- This message is displayed in a confirmation dialog when the user selects one or more
+         conversations and then taps the "Delete" button. -->
+    <plurals name="confirm_delete_conversation">
+        <!-- Case of 1 result. -->
+        <item quantity="one">One conversation will be deleted.</item>
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> conversations will be deleted</item>
+    </plurals>
+    <string name="confirm_delete_conversation">The entire thread will be deleted.</string>
+    <!-- Delete all threads confirmation dialog message -->
+    <string name="confirm_delete_all_conversations">All threads will be deleted.</string>
+    <!-- Delete message confirmation dialog message -->
+    <string name="confirm_delete_message">The message will be deleted.</string>
+    <!-- Delete message confirmation dialog message for a locked message -->
+    <string name="confirm_delete_locked_message">Are you sure you want to delete this locked message?</string>
+    <!-- Delete all the messages on the SIM dialog message -->
+    <string name="confirm_delete_all_SIM_messages">All messages on the SIM will be deleted.</string>
+    <!-- Delete the selected message on the SIM dialog message -->
+    <string name="confirm_delete_SIM_message">This message on the SIM will be deleted.</string>
+    <!-- Delete unlocked checkbox title -->
+    <string name="delete_unlocked">Delete locked messages</string>
+    <!-- Delete button title -->
+    <string name="delete">Delete</string>
+    <!-- Action bar mode title when multi-selecting conversations -->
+    <string name="select_conversations">Select conversations</string>
+    <!-- Show this in the middle of the main activity when there are no conversations [CHAR LIMIT=none] -->
+    <string name="no_conversations">No conversations</string>
+    <!-- Show this in the middle of the main activity when loading conversations [CHAR LIMIT=none] -->
+    <string name="loading_conversations">Loading conversations.</string>
+
+    <!-- When the user tries to view message details and some error occurs while
+         retrieving those details, this message will be shown. -->
+    <string name="cannot_get_details">Cannot get details</string>
+    <!-- Title of "Message details" dialog -->
+    <string name="message_details_title">Message details</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_type_label">Type:\u0020</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="text_message">Text message</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="multimedia_message">Multimedia message</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="multimedia_notification">Multimedia message notification</string>
+    <!-- Label in "Message details" dialog showing who sent the message. -->
+    <string name="from_label">From:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="to_address_label">To:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="bcc_label">Bcc:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="sent_label">Sent:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="received_label">Received:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="saved_label">Saved:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="subject_label">Subject:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_size_label">Message size:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="priority_label">Priority:\u0020</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_high">High</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_normal">Normal</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_low">Low</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_class_label">Message class:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="error_code_label">Error code:\u0020</string>
+
+   <!-- Menu title for editing a message -->
+   <string name="menu_edit">Edit</string>
+   <!-- Menu title for deleting undelivered messages or messages on
+        the SIM card. -->
+   <string name="menu_delete_messages">Delete messages</string>
+   <string name="menu_delete_all_messages">Delete all messages</string>
+   <!-- Menu title for locking a message -->
+   <string name="menu_lock">Lock</string>
+   <!-- Menu title for unlocking a message -->
+   <string name="menu_unlock">Unlock</string>
+
+    <!-- Manage SIM Messages -->
+    <!-- Menu title to copy a selected message from the SIM card to the phone. -->
+    <string name="sim_copy_to_phone_memory" product="tablet">Copy to tablet memory</string>
+    <!-- Menu title to copy a selected message from the SIM card to the phone. -->
+    <string name="sim_copy_to_phone_memory" product="default">Copy to phone memory</string>
+    <!-- Menu title to delete a selected messaged from the SIM card. -->
+    <string name="sim_delete">Delete</string>
+    <!-- Title of screen displaying messages on SIM card -->
+    <string name="sim_manage_messages_title">Text messages on SIM card</string>
+    <!-- Context menu item but currently commented out in 1.0. -->
+    <string name="sim_view">View</string>
+    <!-- Message that appears on the "SMS messges on SIM card" screen when there are no messages on the SIM card -->
+    <string name="sim_empty">No messages on the SIM card.</string>
+
+    <!-- Delivery Header View -->
+    <!-- Title of "Report" window -->
+    <string name="delivery_header_title">Report</string>
+
+    <!-- Delivery Report Activity -->
+    <!-- Status in "Report" window -->
+    <string name="status_none">(None)</string>
+    <!-- Status in "Report" window -->
+    <string name="status_pending">Pending</string>
+    <!-- Status in "Report" window -->
+    <string name="status_read">Read</string>
+    <!-- Status in "Report" window -->
+    <string name="status_received">Received</string>
+    <!-- Status in "Report" window -->
+    <string name="status_failed">Unsuccessful</string>
+    <!-- Status in "Report" window -->
+    <string name="status_unread">Unread</string>
+    <!-- Status in "Report" window -->
+    <string name="status_rejected">Rejected</string>
+    <!-- Label in "Report" window -->
+    <string name="recipient_label">Recipient:\u0020</string>
+    <!-- Label in "Report" window -->
+    <string name="status_label">Status:\u0020</string>
+    <!-- Label in "Report" window [CHAR LIMIT=50]-->
+    <string name="delivered_label">Delivered:\u0020</string>
+
+
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_image">Pictures</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_take_photo">Capture picture</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_video">Videos</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_record_video">Capture video</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_sound">Audio</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_record_sound">Record audio</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_slideshow">Slideshow</string>
+
+    <!-- Layout Selector Adapter. Slideshow layout dialog option for aligning an icon. -->
+    <string name="select_bottom_text">Text on bottom</string>
+    <!-- Layout Selector Adapter. Slideshow layout dialog option for aligning an icon. -->
+    <string name="select_top_text">Text on top</string>
+
+    <!-- Delivery Report Toast dialog content -->
+    <string name="delivery_toast_body">Message received by %s</string>
+
+    <!-- Unread message Notification dialog text. -->
+    <plurals name="notification_multiple">
+        <item quantity="one">%d unread message.</item>
+        <item quantity="other">%d unread messages.</item>
+    </plurals>
+    <!-- Unread message Notification dialog title. -->
+    <string name="notification_multiple_title">New messages</string>
+
+    <!-- Failed to send/download Notification dialog title. -->
+    <string name="notification_failed_multiple"><xliff:g id="count">%s</xliff:g> messages could not be sent.</string>
+    <!-- Failed to send/download Notification dialog title. -->
+    <string name="notification_failed_multiple_title">Messages not sent</string>
+
+    <!-- Sim Full Notification dialog title. -->
+    <string name="sim_full_title">SIM card full</string>
+    <!-- Sim Full Notification dialog text. -->
+    <string name="sim_full_body">Delete some messages to make room for more.</string>
+
+    <!-- Device Full Notification dialog title. -->
+    <string name="sms_full_title">Message memory full</string>
+    <!-- Device Full Notification dialog text. -->
+    <string name="sms_full_body">Incoming message rejected due to full memory. Please delete old messages.</string>
+
+    <!-- Sms's Being Rejected Notification dialog title. -->
+    <string name="sms_rejected_title">Text message rejected</string>
+    <!-- Sms's Being Rejected Notification dialog text. -->
+    <string name="sms_rejected_body">Incoming message rejected due to unknown reason.</string>
+
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this audio to your message. -->
+    <string name="type_audio">audio</string>
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this picture to your message. -->
+    <string name="type_picture">picture</string>
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this video to your message. -->
+    <string name="type_video">video</string>
+
+    <!-- Dialog title for the Read Report dialog. -->
+    <string name="confirm">Confirm</string>
+    <!-- Dialog text for the Read Report dialog. -->
+    <string name="message_send_read_report">A read report will be sent.</string>
+
+    <!-- This is the text of a toast message briefly displayed when a problem occurs
+         while sending. -->
+    <string name="message_queued">Currently unable to send your message. It will be sent when the service becomes available.</string>
+
+    <!-- dialog error message when only is FDN is allowed. -->
+    <string name="fdn_check_failure">You can only send messages to your fixed dialing numbers.</string>
+
+    <!-- Download Manager -->
+    <!-- When an error occurs downloading a new message and a subject isn't available, substitute
+         this default subject. -->
+    <string name="no_subject">(No subject)</string>
+    <!-- When an error occurs downloading a new message and the sender is unknown, substitute
+         this default text. -->
+    <string name="unknown_sender">Unknown sender</string>
+    <!-- When an error occurs downloading a new message, display this message.
+         An example: Download of message Wanna get pizza from dorkman was unsuccessful. -->
+    <string name="dl_failure_notification">Download of message <xliff:g id="subject">%1$s</xliff:g> from <xliff:g id="from">%2$s</xliff:g> was unsuccessful.</string>
+
+    <!-- This is the confirm rate limit alert dialog title. -->
+    <string name="rate_limit_surpassed">Confirm</string>
+    <!-- This is the confirm rate limit alert dialog text. -->
+    <string name="confirm_rate_limit">A large number of multimedia messages are being sent. Is this OK?</string>
+
+    <!-- Message Failed Notification -->
+    <!-- Dialog box title when receiving a message failed. -->
+    <string name="message_download_failed_title">Message not downloaded</string>
+    <!-- Dialog box title when sending a message failed. -->
+    <string name="message_send_failed_title">Message not sent</string>
+    <!-- Dialog box message text when failure occurs sending a message. -->
+    <string name="message_failed_body">Select to review the message and try again.</string>
+    <!-- Dialog box message when there's a problem retrieving messages. -->
+    <string name="download_later">Currently unable to download. Please try again later.</string>
+    <!-- Dialog box message when there's no APN specified on the device. -->
+    <string name="no_apn">No APN specified on the device.</string>
+
+    <!-- Title for audio file picker -->
+    <string name="select_audio">Select audio</string>
+    <!-- Menu title to copy an attachment to the shared storage [CHAR LIMIT=25] -->
+    <string name="copy_to_sdcard">Save attachment</string>
+    <!-- Toast message on successful copy to shared storage [CHAR LIMIT=30] -->
+    <string name="copy_to_sdcard_success">Attachment saved</string>
+    <!-- Toast message on failed copy to shared storage [CHAR LIMIT=30] -->
+    <string name="copy_to_sdcard_fail">Unable to save attachment</string>
+    <!-- Menu title to save a sound as a ringtone -->
+    <string name="save_ringtone">Save as ringtone</string>
+    <!-- Toast message on successful copying ringtone to drm provider -->
+    <string name="saved_ringtone">Ringtone saved</string>
+    <!-- Toast message on failed copying ringtone to drm provider -->
+    <string name="saved_ringtone_fail">Saving ringtone failed</string>
+    <!-- Menu item -->
+    <string name="menu_insert_smiley">Insert smiley</string>
+    <!-- Menu item  [CHAR LIMIT=40] -->
+    <string name="menu_group_participants">Group participants</string>
+
+    <!-- This is the dialog title for the "Select link" dialog, shown when the user clicks on a
+    chat in the chat history view if there are links in the chat message. The dialog displays the
+    links if there are any -->
+    <string name="select_link_title">Select action</string>
+
+    <!-- Name of the Nth slide, shown in the list in the slideshow editor. -->
+    <string name="slide_number">Slide <xliff:g id="number" example="5">%s</xliff:g></string>
+    <!-- Duration of the slide, shown in the list in the slideshow editor -->
+    <plurals name="slide_duration">
+        <!-- Case of 1-second duration. -->
+        <item quantity="one"><xliff:g id="number" example="1">%s</xliff:g> sec</item>
+        <!-- Case of "few" (small number of) seconds of duration. -->
+        <item quantity="few"><xliff:g id="number" example="2">%s</xliff:g> secs</item>
+        <!-- Case of multiple-second duration. -->
+        <item quantity="other"><xliff:g id="number" example="15">%s</xliff:g> secs</item>
+    </plurals>
+
+    <!-- Title of the delivery report activity. -->
+    <string name="delivery_report_activity">Delivery report</string>
+
+    <!-- Title of the activity that tells the user about storage limits. -->
+    <string name="storage_limits_activity">Storage limits</string>
+
+    <!-- Title of the slide duration editor activity. -->
+    <string name="change_duration_activity">Change duration</string>
+
+    <!-- Title of the slideshow editor activity. -->
+    <string name="edit_slideshow_activity">Edit slideshow</string>
+
+    <!-- Title of the recipient list activity. [CHAR LIMIT=NONE] -->
+    <string name="recipient_list_activity">Group participants</string>
+
+    <!-- Title of the slide editor activity. -->
+    <string name="edit_slide_activity">Edit slide</string>
+
+    <!-- Title of the slideshow activity. -->
+    <string name="slideshow_activity">Slideshow</string>
+
+    <!-- Title of the class-0 message activity. -->
+    <string name="class_0_message_activity">Class 0 Message</string>
+
+    <!-- Application name shown when searching -->
+    <string name="search_label">Messaging</string>
+
+    <!-- Search hint -->
+    <string name="search_hint">Search Messaging</string>
+
+    <!-- Search activity name -->
+    <string name="search">Messaging</string>
+    <!-- Search setting description -->
+    <string name="search_setting_description">Text in your messages</string>
+
+    <!--  Search empty results -->
+    <string name="search_empty">No matches</string>
+
+    <!--  Search results title -->
+    <plurals name="search_results_title">
+        <!-- Case of 1 result. -->
+        <item quantity="one"><xliff:g id="number" example="1">%1$s</xliff:g> result for \"<xliff:g id="search" example="???">%2$s</xliff:g>\"</item>
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> results for \"<xliff:g id="search" example="???">%2$s</xliff:g>\"</item>
+    </plurals>
+
+    <!--- String saved in history searches. -->
+    <string name="search_history"><xliff:g id="count">%1$s</xliff:g> results for \"<xliff:g id="search">%2$s</xliff:g>\"</string>
+
+    <!-- Button title in Messaging preferences. -->
+    <string name="confirm_clear_search_title">Clear</string>
+    <!-- Text for the preferences button. -->
+    <string name="confirm_clear_search_text">Search history will be cleared.</string>
+    <!--- Button title in preferences to clear the search history. It's a verb action that takes place
+          immediately when clicked. -->
+    <string name="pref_mms_clear_search_history_title">Clear search history</string>
+    <!--- Button description in preferences to clear the search history. -->
+    <string name="pref_mms_clear_search_history_summary">Clear previous Messaging searches from showing up in the Search box</string>
+
+    <!-- Dialog text for display mode save dialog. -->
+    <string name="save">Save</string>
+
+    <!-- Dialog title for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_title">Limit messages</string>
+
+    <!-- Dialog message for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_message">Do you want to limit the number of messages you save per conversation?</string>
+
+    <!-- Button title for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_setting">Set limits</string>
+
+    <!-- Button title to dismiss dialog that informs user about new storage settings. -->
+    <string name="storage_limits_setting_dismiss">No limits</string>
+
+    <!-- Toast message when a user tries to send a Mms message when there are already too many
+         outstanding unsent message. -->
+    <string name="too_many_unsent_mms">Can\'t send message right now. There are too many unsent multimedia messages.</string>
+
+    <!-- Brief small label shown to right of message when it is being sent. -->
+    <string name="sending_message">Sending\u2026</string>
+
+    <!-- Title of progress dialog for picker -->
+    <string name="pick_too_many_recipients">Too many recipients</string>
+
+    <!-- Message of progress dialog for picker -->
+    <string name="adding_recipients">Adding recipients\u2026</string>
+
+    <!-- In conversation list items, this is the separator between a contact's name
+         and the draft stamp [CHAR LIMIT=5] -->
+    <string name="draft_separator">,\u0020</string>
+
+    <!-- In conversation list items, this comes after the receipient's name and contains
+         the number of messages in the thread [CHAR LIMIT=5] -->
+    <string name="message_count_format">\u00a0<xliff:g id="number" example="1">%1$s</xliff:g></string>
+
+    <!-- When showing a multi-message notification, this is the title [CHAR LIMIT=none] -->
+    <string name="message_count_notification"><xliff:g id="number" example="3">%1$s</xliff:g> new messages</string>
+    <!-- In digest notifications when we show N messages, but there are N+M outstanding messages,
+         this text is displayed at the bottom of the notification. [CHAR LIMIT=50] -->
+    <plurals name="message_count_notification_overflow">
+        <!-- Case of 1 result. -->
+        <item quantity="one">+<xliff:g id="number" example="1">%1$s</xliff:g> other message"</item>
+        <!-- Case of 2 or more results. -->
+        <item quantity="other">+<xliff:g id="number" example="15">%1$s</xliff:g> other messages"</item>
+    </plurals>
+
+    <!-- For debugging: Dialog box title indicating there's a situation where data has unexpectedly
+         changed -->
+    <string name="error_state">Inconsistent state</string>
+    <!-- For debugging: Dialog box text indicating there's a situation where data has unexpectedly
+         changed -->
+    <string name="error_state_text">The state of threads and recipients is inconsistent. Please capture a bug report and report it via http://go/droidanizer </string>
+
+    <!-- In the title of the compose message activity, when there are multiple recipients, we show
+         the number of recipients in the subtitle of the action bar. There's never a case of one. [CHAR LIMIT=50] -->
+    <plurals name="recipient_count">
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> people</item>
+    </plurals>
+   <!-- Displayed at the end of the conversation list in the widget. Tapping on this will open the default conversation list. [CHAR LIMIT=35] -->
+    <string name="view_more_conversations">View more conversations</string>
+
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_audio">Audio</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_slideshow">Slideshow</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_video">Video</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_picture">Picture</string>
+
+    <!-- Separator between parts of a notification in each line of an inboxStyle notification. [CHAR LIMIT=2] -->
+    <string name="notification_separator">\u0020\u0020</string>
+
+    <!-- An enumeration comma for separating multiple names in notifications. [CHAR LIMIT=2] -->
+    <string name="enumeration_comma">,\u0020</string>
+
+    <!-- In message list items, this string builds the timestamp line when the message is in a group [CHAR LIMIT=NONE] -->
+    <string name="message_timestamp_format"><xliff:g id="string" example="Fred Flinstone">%1$s</xliff:g>\u0020-\u0020<xliff:g id="string" example="9:39AM">%2$s</xliff:g></string>
+
+    <string name="storage_warning_title">"Your phone's storage is full"</string>
+    <string name="storage_warning_content">"You won't receive new SMS/MMS messages"</string>
+
+    <!-- Cell broadcast SMS strings -->
+    <string name="cell_broadcast">Cell broadcast</string>
+    <string name="cell_broadcast_title">Cell broadcast settings</string>
+    <string name="cell_broadcast_settings">SIM card cell broadcast settings</string>
+    <!-- Quick text -->
+    <string name="menu_insert_quick_text">Insert quick text</string>
+    <string name="select_quick_text">Select quick text</string>
+    <string name="add">Add</string>
+    <string name="quick_text_editor">Edit quick text</string>
+    <string name="modify_successful">Modify successfully</string>
+    <string name="modify_unsuccessful">Modify unsuccessfully!</string>
+    <string name="delete_successful">Delete successfully</string>
+    <string name="delete_unsuccessful">Delete unsuccessfully!</string>
+    <string name="add_quick_text_successful">Add quick text successfully</string>
+    <string name="already_have_quick_text">You have this quick text already!</string>
+    <!-- add by feng for attachment -->
+    <string name="file_attachment_common_name">Multi file(<xliff:g id="text">%s</xliff:g>)</string>
+    <string name="file_attachment_contains">contains</string>
+    <string name="file_attachment_files">files</string>
+    <string name="save_attachment">Save Attachment</string>
+    <string name="save_multi_attachment_notes">The multi-file contains several files. Check and save them?</string>
+    <string name="save_single_attachment_notes">It is an nonsupported format file in MMS. Save it to Filemanager?</string>
+    <string name="multi_files">Multi-files</string>
+    <string name="save_single_supportformat_attachment_notes">Save it to Filemanager?</string>
+
+    <!-- add for editor lenght limitation -->
+    <string name="exceed_editor_size_limitation">Text limit reached.</string>
+
+    <string name="add_top_slide">Add slide to top</string>
+    <string name="add_bottom_slide">Add slide to bottom</string>
+    <!--  Strings used forh MMS push of messages in outbox -->
+    <string name="label_mms_send_outbox_msg">MMS Wakeup</string>
+    <string name="desc_mms_send_outbox_msg">Sends out all MMSs from the outbox to the network</string>
+    <!-- Banner in conversation list for making Messaging the default SMS app -->
+    <string name="banner_sms_promo_title_initial">Messaging is not your SMS app</string>
+    <string name="banner_sms_promo_title_application"><xliff:g id="appName">%s</xliff:g> is your SMS app</string>
+    <string name="banner_sms_promo_message">You can change this in Settings</string>
+	<!-- add lei.shi for [task1149499][CBC notification with pop up and tone alert + vibrate in CHILE] at 2015.12.14 begin -->
+    <string name="hide_imm_cb_dialog">Hide</string>
+    <string name="title_imm_cb_dialog">Emergency Alert</string>
+    <!-- add lei.shi for [task1149499][CBC notification with pop up and tone alert + vibrate in CHILE] at 2015.12.14 end -->
+</resources>
+

Property changes on: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java	(revision 2619)
@@ -0,0 +1,185 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2008 Esmertec AG.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.transaction;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SqliteWrapper;
+import android.net.Uri;
+import android.preference.PreferenceManager;
+import android.provider.Telephony.Sms;
+import android.provider.Telephony.Sms.Inbox;
+import android.util.Log;
+
+import com.android.mms.LogTag;
+import com.android.mms.MmsApp;
+import com.android.mms.util.MmsLog;
+import com.google.android.mms.MmsException;
+
+import com.mediatek.mms.ext.IOpSmsMessageSenderExt;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.SmsPreferenceActivity;
+
+
+public class SmsMessageSender implements MessageSender {
+    protected final Context mContext;
+    protected final int mNumberOfDests;
+    private final String[] mDests;
+    protected final String mMessageText;
+    protected final String mServiceCenter;
+    protected final long mThreadId;
+    protected int mSubId;
+    protected long mTimestamp;
+    private static final String TAG = "SmsMessageSender";
+
+    // Default preference values
+    private static final boolean DEFAULT_DELIVERY_REPORT_MODE  = false;
+
+    private static final String[] SERVICE_CENTER_PROJECTION = new String[] {
+        Sms.Conversations.REPLY_PATH_PRESENT,
+        Sms.Conversations.SERVICE_CENTER,
+    };
+
+    private static final int COLUMN_REPLY_PATH_PRESENT = 0;
+    private static final int COLUMN_SERVICE_CENTER     = 1;
+
+    // M: add for op
+    private IOpSmsMessageSenderExt mOpSmsMessageSender = null;
+
+    public SmsMessageSender(Context context, String[] dests, String msgText, long threadId,
+            int subId) {
+        mContext = context;
+        mMessageText = msgText;
+        if (dests != null) {
+            mNumberOfDests = dests.length;
+            mDests = new String[mNumberOfDests];
+            System.arraycopy(dests, 0, mDests, 0, mNumberOfDests);
+        } else {
+            mNumberOfDests = 0;
+            mDests = null;
+        }
+        mTimestamp = System.currentTimeMillis();
+        mThreadId = threadId;
+        mSubId = subId;
+        mServiceCenter = getOutgoingServiceCenter(mThreadId);
+        mOpSmsMessageSender = OpMessageUtils.getOpMessagePlugin()
+                .getOpSmsMessageSenderExt();
+    }
+
+    public boolean sendMessage(long token) throws MmsException {
+        // In order to send the message one by one, instead of sending now, the message will split,
+        // and be put into the queue along with each destinations
+        return queueMessage(token);
+    }
+
+    private boolean queueMessage(long token) throws MmsException {
+        /// M:
+        MmsLog.i(MmsApp.TXN_TAG, "queueMessage()");
+        if ((mMessageText == null) || mMessageText.isEmpty() || (mNumberOfDests == 0)) {
+            // Don't try to send an empty message.
+            throw new MmsException("Null message body or dest.");
+        }
+
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mContext);
+        boolean requestDeliveryReport =
+            prefs.getBoolean(mSubId + "_" + SmsPreferenceActivity.SMS_DELIVERY_REPORT_MODE,
+                DEFAULT_DELIVERY_REPORT_MODE);
+        MmsLog.d(MmsApp.TXN_TAG, "SMS DR request=" + requestDeliveryReport);
+        /// @}
+        long timeStamp = System.currentTimeMillis();
+        for (int i = 0; i < mNumberOfDests; i++) {
+            try {
+                if (LogTag.DEBUG_SEND) {
+                    MmsLog.vpi(TAG, "queueMessage mDests[i]: " +
+                     mDests[i] + " mThreadId: " + mThreadId);
+                }
+
+                Uri smsUri = mOpSmsMessageSender.queueMessage(mNumberOfDests,
+                        mContext.getContentResolver(), mDests[i], mMessageText, mTimestamp,
+                        requestDeliveryReport, mThreadId, mSubId, -timeStamp);
+
+                if (smsUri == null) {
+                    Sms.addMessageToUri(mSubId,
+                            mContext.getContentResolver(),
+                            Uri.parse("content://sms/queued"), mDests[i],
+                            mMessageText, null, mTimestamp,
+                            true /* read */,
+                            requestDeliveryReport,
+                            mThreadId);
+                }
+            } catch (SQLiteException e) {
+                if (LogTag.DEBUG_SEND) {
+                    Log.e(TAG, "queueMessage SQLiteException", e);
+                }
+                SqliteWrapper.checkSQLiteException(mContext, e);
+            }
+        }
+        // Notify the SmsReceiverService to send the message out
+        mContext.sendBroadcast(new Intent(SmsReceiverService.ACTION_SEND_MESSAGE,
+                null,
+                mContext,
+                SmsReceiver.class));
+        return false;
+    }
+
+    /**
+     * Get the service center to use for a reply.
+     *
+     * The rule from TS 23.040 D.6 is that we send reply messages to
+     * the service center of the message to which we're replying, but
+     * only if we haven't already replied to that message and only if
+     * <code>TP-Reply-Path</code> was set in that message.
+     *
+     * Therefore, return the service center from the most recent
+     * message in the conversation, but only if it is a message from
+     * the other party, and only if <code>TP-Reply-Path</code> is set.
+     * Otherwise, return null.
+     */
+    private String getOutgoingServiceCenter(long threadId) {
+        Cursor cursor = null;
+
+        try {
+            cursor = SqliteWrapper.query(mContext, mContext.getContentResolver(),
+                            Inbox.CONTENT_URI, SERVICE_CENTER_PROJECTION,
+                            "thread_id = " + threadId, null, "date DESC");
+
+            if ((cursor == null) || !cursor.moveToFirst()) {
+                return null;
+            }
+
+            boolean replyPathPresent = (1 == cursor.getInt(COLUMN_REPLY_PATH_PRESENT));
+            return replyPathPresent ? cursor.getString(COLUMN_SERVICE_CENTER) : null;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    private void log(String msg) {
+        Log.d(LogTag.TAG, "[SmsMsgSender] " + msg);
+    }
+}

Property changes on: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 2619)
@@ -0,0 +1,3332 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+ /*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.data;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDiskIOException;
+import android.database.sqlite.SqliteWrapper;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.preference.PreferenceManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.provider.Telephony.Threads;
+import android.provider.Telephony.MmsSms.PendingMessages;
+import android.provider.Telephony.MmsSms.WordsTable;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.android.common.contacts.DataUsageStatUpdater;
+import com.android.common.userhappiness.UserHappinessSignals;
+import com.android.mms.ContentRestrictionException;
+import com.android.mms.ExceedMessageSizeException;
+import com.android.mms.LogTag;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.R;
+import com.android.mms.ResolutionException;
+import com.android.mms.RestrictedResolutionException;
+import com.android.mms.UnsupportContentTypeException;
+import com.android.mms.draft.DraftManager;
+import com.android.mms.draft.IDraftInterface;
+import com.android.mms.draft.MmsDraftData;
+import com.android.mms.model.AudioModel;
+import com.android.mms.model.ImageModel;
+import com.android.mms.model.MediaModel;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.model.VideoModel;
+import com.android.mms.model.SlideshowModel.MediaType;
+import com.android.mms.transaction.MessageSender;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.transaction.MmsMessageSender;
+import com.android.mms.transaction.SmsMessageSender;
+import com.android.mms.ui.ComposeMessageActivity;
+import com.android.mms.ui.MessageUtils;
+import com.android.mms.ui.SlideshowEditor;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.MmsLog;
+import com.android.mms.util.Recycler;
+import com.android.mms.util.ThumbnailManager;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.google.android.mms.ContentType;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.SendReq;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.mms.callback.IConversationCallback;
+import com.mediatek.mms.callback.ISplitToMmsAndSmsConversationCallback;
+import com.mediatek.mms.callback.IWorkingMessageCallback;
+import com.mediatek.mms.ext.IOpWorkingMessageExt;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.util.FileAttachmentUtils;
+import com.mediatek.mms.util.MmsSizeUtils;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.MmsPreferenceActivity;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Contains all state related to a message being edited by the user.
+ */
+public class WorkingMessage implements IWorkingMessageCallback {
+    private static final String TAG = "WorkingMessage";
+    private static final String TAG_DRAFT = "[Mms][Draft][WorkingMessage]";
+    private static final boolean DEBUG = false;
+
+    // Public intents
+    public static final String ACTION_SENDING_SMS = "android.intent.action.SENDING_SMS";
+
+    // Intent extras
+    public static final String EXTRA_SMS_MESSAGE = "android.mms.extra.MESSAGE";
+    public static final String EXTRA_SMS_RECIPIENTS = "android.mms.extra.RECIPIENTS";
+    public static final String EXTRA_SMS_THREAD_ID = "android.mms.extra.THREAD_ID";
+
+    //for save message uri when MMS is stoping, and when recreate MMS, it can be read
+    public static final String SAVE_MSG_URI_KEY = "pref_msg_uri_key";
+    public static final String SAVE_MSG_THREADID_KEY = "pref_msg_threadid_key";
+
+    // Database access stuff
+    private final Activity mActivity;
+    private final ContentResolver mContentResolver;
+
+    // States that can require us to save or send a message as MMS.
+    private static final int RECIPIENTS_REQUIRE_MMS = (1 << 0);     // 1
+    private static final int HAS_SUBJECT = (1 << 1);                // 2
+    private static final int HAS_ATTACHMENT = (1 << 2);             // 4
+    private static final int LENGTH_REQUIRES_MMS = (1 << 3);        // 8
+    private static final int FORCE_MMS = (1 << 4);                  // 16
+    /// M: google JB.MR1 patch, group mms
+    private static final int MULTIPLE_RECIPIENTS = (1 << 5);        // 32
+
+    // A bitmap of the above indicating different properties of the message;
+    // any bit set will require the message to be sent via MMS.
+    private int mMmsState;
+
+    // Errors from setAttachment()
+    public static final int OK = 0;
+    public static final int UNKNOWN_ERROR = -1;
+    public static final int MESSAGE_SIZE_EXCEEDED = -2;
+    public static final int UNSUPPORTED_TYPE = -3;
+    public static final int IMAGE_TOO_LARGE = -4;
+
+    // Attachment types
+    public static final int TEXT = 0;
+    public static final int IMAGE = 1;
+    public static final int VIDEO = 2;
+    public static final int AUDIO = 3;
+    public static final int SLIDESHOW = 4;
+
+    // Current attachment type of the message; one of the above values.
+    private int mAttachmentType;
+
+    // Conversation this message is targeting.
+    private Conversation mConversation;
+
+    // Text of the message.
+    private CharSequence mText;
+    // Slideshow for this message, if applicable.  If it's a simple attachment,
+    // i.e. not SLIDESHOW, it will contain only one slide.
+    private SlideshowModel mSlideshow;
+    // Data URI of an MMS message if we have had to save it.
+    private Uri mMessageUri;
+    // MMS subject line for this message
+    private CharSequence mSubject;
+
+    // Set to true if this message has been discarded.
+    private boolean mDiscarded = false;
+
+    // Track whether we have drafts
+    private volatile boolean mHasMmsDraft;
+    private volatile boolean mHasSmsDraft;
+
+    // Cached value of mms enabled flag
+    private static boolean sMmsEnabled = MmsConfig.getMmsEnabled();
+
+    // Our callback interface
+    private final MessageStatusListener mStatusListener;
+    private List<String> mWorkingRecipients;
+
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not send
+    /// MMS anymore after send several MMS fail . @{
+    private static final String[] MMS_OUTBOX_PROJECTION = {
+        Mms._ID,            // 0
+        Mms.MESSAGE_SIZE,   // 1
+        Mms.STATUS
+    };
+    /// @}
+
+    /// M: Modify @{
+    private static final String FDN_URI = "content://icc/fdn/subId/";
+    private static final String[] FDN_PROJECTION = new String[] {
+        "index",
+        "name",
+        "number"
+    };
+    private static final int FDN_COLUMN_INDEX = 0;
+    private static final int FDN_COLUMN_NAME = 1;
+    private static final int FDN_COLUMN_NUMBER = 2;
+    /// @}
+
+    private static final int MMS_MESSAGE_SIZE_INDEX  = 1;
+
+    /// M:
+    private static final String M_TAG = "Mms/WorkingMessage";
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public static final int ATTACHMENT = 5;
+    public static final int VCARD = 6;
+    /// @}
+    /// M: Code analyze 035, For new feature ALPS00249336,  add vCalendar support . @{
+    public static final int VCALENDAR = 7;
+    /// @}
+
+    /// M: Code analyze 036, For bug ALPS00270539, mms draft edit lock. at any
+    /// time, only one thread can modify a mms draft. here currently use a static
+    /// lock is ok, because WorkingMessage is only one at any time. if the condition
+    /// is changed this must be changed too . @{
+    public static Object sDraftMmsLock = new Object();
+    /// @}
+
+    private long mOldThreadId;
+
+    /// M: Fix CR : ALPS01012417 @{
+    private long mOldSmsSaveThreadId;
+    /// @}
+
+    /// M: Fix CR : ALPS01078057 @{
+    private long mOldMmsSaveThreadId = 0;
+    /// @}
+
+    /// M : FIX CR : ALPS01795853 @{
+    private boolean mIsTurnToChooseAttach;
+    /// @}
+
+    /// M: Fix CR: ALPS01234459 @{
+    private boolean mIsLoadingDraft;
+    /// @}
+
+    // Draft message stuff
+    private static final String[] MMS_DRAFT_PROJECTION = {
+        Mms._ID,                // 0
+        Mms.SUBJECT,            // 1
+        Mms.SUBJECT_CHARSET     // 2
+    };
+
+    private static final int MMS_ID_INDEX         = 0;
+    private static final int MMS_SUBJECT_INDEX    = 1;
+    private static final int MMS_SUBJECT_CS_INDEX = 2;
+
+    /// M: Code analyze 039, For new feature ALPS00233419, Creation mode . @{
+    private static final String CREATION_MODE_RESTRICTED = "RESTRICTED";
+    private static final String CREATION_MODE_WARNING    = "WARNING";
+    private static final String CREATION_MODE_FREE       = "FREE";
+
+    public static final int WARNING_TYPE    = -10;
+    public static final int RESTRICTED_TYPE = -11;
+    public static final int RESTRICTED_RESOLUTION = -12;
+
+    public static int sCreationMode  = 0;
+    /// @}
+
+    //Set resizedto true if the image is
+    private boolean mResizeImage = false;
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not
+    /// send MMS anymore after send several MMS fail . @{
+    private static final int MMS_MESSAGE_STATUS_INDEX  = 2;
+    /// @}
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft
+    /// when save Latest Mms message as draft . @{
+    private boolean mNeedDeleteOldMmsDraft;
+    /// @}
+
+    /// M: Code analyze 043, For bug ALPS00117913, Mms Basic Coding Convention Correction . @{
+    private static final String FILE_NOT_FOUND = "File not found.";
+
+    private static final String READ_WRITE_FAILURE = "Read or write file failure.";
+
+    private boolean mIsDeleteDraftWhenLoad = false;
+    /// @}
+
+    /// M: fix bug ALPS00513231, force update threadId @{
+    private boolean mForceUpdateThreadId = false;
+
+    public void setForceUpdateThreadId(boolean update) {
+        mForceUpdateThreadId = update;
+    }
+    /// @}
+
+    private Bundle mBundle;
+
+    public IOpWorkingMessageExt mOpWorkingMessageExt = null;
+
+    /**
+     * Callback interface for communicating important state changes back to
+     * ComposeMessageActivity.
+     */
+    public interface MessageStatusListener {
+        /**
+         * Called when the protocol for sending the message changes from SMS
+         * to MMS, and vice versa.
+         *
+         * @param mms If true, it changed to MMS.  If false, to SMS.
+         */
+        /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+        void onProtocolChanged(boolean mms, boolean needToast);
+        /// @}
+
+        /**
+         * Called when an attachment on the message has changed.
+         */
+        void onAttachmentChanged();
+
+        /**
+         * Called just before the process of sending a message.
+         */
+        void onPreMessageSent();
+
+        /**
+         * Called once the process of sending a message, triggered by
+         * {@link send} has completed. This doesn't mean the send succeeded,
+         * just that it has been dispatched to the network.
+         */
+        void onMessageSent();
+
+        /**
+         * Called if there are too many unsent messages in the queue and we're not allowing
+         * any more Mms's to be sent.
+         */
+        void onMaxPendingMessagesReached();
+
+        /**
+         * Called if there's an attachment error while resizing the images just before sending.
+         */
+        void onAttachmentError(int error);
+
+        /** M:Code analyze 045, For bug ALPS00241360, to solve White screen
+         * appears about 3 seconds when sending MMS. Called just before the
+         * process of sending a mms.
+         */
+        void onPreMmsSent();
+    }
+
+    private WorkingMessage(ComposeMessageActivity activity) {
+        MmsLog.d(TAG, "new WorkingMessage(Composer)");
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = activity;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        this.mInterface = new DraftInterface();
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    /**
+     * Creates a new working message.
+     */
+    public static WorkingMessage createEmpty(ComposeMessageActivity activity) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity);
+        return msg;
+    }
+
+    /**
+     * Create a new WorkingMessage from the specified data URI, which typically
+     * contains an MMS message.
+     */
+    public static WorkingMessage load(ComposeMessageActivity activity, Uri uri) {
+        // If the message is not already in the draft box, move it there.
+        if (!uri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+            PduPersister persister = PduPersister.getPduPersister(activity);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "load: moving %s to drafts" + uri);
+            }
+            try {
+                uri = persister.move(uri, Mms.Draft.CONTENT_URI);
+            } catch (MmsException e) {
+                MmsLog.epi(TAG, "Can't move %s to drafts" + uri);
+                return null;
+            }
+        }
+
+        WorkingMessage msg = new WorkingMessage(activity);
+        /// M: Code analyze 046, For bug ALPS00114670, to solve JE happen
+        /// when tap discard slidehsow . @{
+        msg.setConversation(activity.getConversation());
+        /// @}
+        long threadId = 0;
+        boolean noRecipientes = activity.getConversation().getRecipients().isEmpty();
+        if (!noRecipientes) {
+            threadId = activity.getConversation().ensureThreadId();
+        }
+
+        MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                threadId, uri, activity, null);
+        if (mdd == null) {
+            Log.d(TAG_DRAFT, "[load] load from DraftManager result is null!!");
+            return null;
+        }
+        Log.d(TAG_DRAFT, "[load] boolean result is : " + mdd.getBooleanResult());
+        if (mdd.getBooleanResult()) {
+            msg.mHasMmsDraft = true;
+            msg.mSlideshow = mdd.getSlideshow();
+            msg.mMessageUri = mdd.getMessageUri();
+            msg.syncTextFromSlideshow();
+            msg.correctAttachmentState();
+            MmsLog.dpi(TAG_DRAFT, "[load] message uri : " + msg.mMessageUri);
+            return msg;
+        }
+
+        return null;
+    }
+
+    public void correctAttachmentState() {
+        int slideCount = mSlideshow.size();
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        final int fileAttachCount = mSlideshow.sizeOfFilesAttach();
+        /// @}
+        // If we get an empty slideshow, tear down all MMS
+        // state and discard the unnecessary message Uri.
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        if (0 == fileAttachCount) {
+        /// @}
+            if (slideCount == 0 || isEmptySlide()) {
+                //add for attachment enhance
+                MmsLog.d(TAG, "WorkingMessage CorrectAttachmentState RemoveAttachment");
+                removeAttachment(true);
+            } else if (slideCount > 1) {
+                mAttachmentType = SLIDESHOW;
+            } else {
+                SlideModel slide = mSlideshow.get(0);
+                if (slide.hasImage()) {
+                    mAttachmentType = IMAGE;
+                } else if (slide.hasVideo()) {
+                    mAttachmentType = VIDEO;
+                } else if (slide.hasAudio()) {
+                    mAttachmentType = AUDIO;
+                }
+            }
+        } else { /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            mAttachmentType = ATTACHMENT;
+        }
+        /// @}
+
+        updateState(HAS_ATTACHMENT, hasAttachment(), false);
+    }
+
+//add for attachment enhance
+     private boolean isEmptySlide() {
+        int slideCount = mSlideshow.size();
+
+        if (slideCount == 1) {
+            if (mSlideshow != null) {
+                MmsLog.d(TAG, "mSlideshow != null");
+               if (mSlideshow.get(0) != null) {
+                    //Xlog.e(TAG, "contentType = " + mSlideshow.get(0).get(0).getContentType());
+                    MmsLog.d(TAG, "mAttachmentType = " + mAttachmentType);
+                    //MmsLog.e(TAG, "mSlideshow.get(0).get(0) "+ mSlideshow.get(0).get(0));
+
+                    if (mSlideshow.get(0).get(0) != null && mSlideshow.get(0).size() == 1) {
+                        MmsLog.d(TAG, "mSlideshow.get(0).get(0).size " + mSlideshow.get(0).size());
+                        if (mSlideshow.get(0).get(0).getContentType()
+                                .compareTo(ContentType.TEXT_PLAIN) == 0
+                        && (mAttachmentType == VCARD || mAttachmentType == VCALENDAR ||
+                        mAttachmentType == ATTACHMENT)) {
+                            MmsLog.d(TAG, "isEmptySlide return true");
+                            return true;
+                        }
+                    } else if (mSlideshow.get(0).size() == 0 || mSlideshow.get(0).get(0) == null) {
+                        ///M: Modify for ALPS01253847
+                        return true;
+                    }
+               }
+           }
+        }
+
+        MmsLog.d(TAG, "isEmptySlide return false");
+        return false;
+    }
+
+    /**
+     * Load the draft message for the specified conversation, or a new empty message if
+     * none exists.
+     */
+    public static WorkingMessage loadDraft(final ComposeMessageActivity activity,
+                                           final Conversation conv,
+                                           final Runnable onDraftLoaded) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "loadDraft " + conv);
+        }
+
+        final WorkingMessage msg = createEmpty(activity);
+        /// M: Code analyze 037, For bug ALPS00291328,  save conversation to avoid JE . @{
+        msg.setConversation(conv);
+        /// @}
+        if (conv.getThreadId() <= 0) {
+            if (onDraftLoaded != null) {
+                onDraftLoaded.run();
+            }
+            return msg;
+        }
+
+        final long threadId = conv.getThreadId();
+        msg.mOldThreadId = threadId;
+
+        /// M: modify for fix alps01194967  && alps01208583 &&
+        /// alps01224306, load sms draft in backGround. @{
+        new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                MmsLog.dpi(TAG_DRAFT, "[loadDraft] draftText : " + draftText);
+                if (TextUtils.isEmpty(draftText)) {
+                    msg.mInterface.loadRunnable = onDraftLoaded;
+                    /// M: Fix CR : ALPS01234459, while loading draft, can't set text @{
+                    msg.mIsLoadingDraft = true;
+                    /// @}
+                    DraftManager.getInstance().loadDraft(DraftManager.ASYNC_LOAD_ACTION,
+                            threadId, null, activity, msg.mInterface);
+                } else {
+                    msg.mHasSmsDraft = true;
+                    if (onDraftLoaded != null && activity != null) {
+                        activity.runOnUiThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                msg.setText(draftText);
+                                onDraftLoaded.run();
+                            }
+                        });
+                    }
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+        /// @}
+        return msg;
+    }
+
+    private DraftInterface mInterface;
+
+    private class DraftInterface implements IDraftInterface {
+        private Handler mHanlder;
+        DraftInterface() {
+            mHanlder = new Handler();
+        }
+
+        public Runnable loadRunnable;
+
+        public void loadFinished(MmsDraftData mdd) {
+            if (mdd != null) {
+                MmsLog.dpi(TAG_DRAFT, "[loadFinished] enter, and uri : "
+                        + mdd.getMessageUri() + ", subject : " + mdd.getSubject());
+
+                String subject = mdd.getSubject();
+                if (subject != null && subject.length() != 0) {
+                    mHasMmsDraft = true;
+                    setSubject(subject, false);
+                }
+
+                mOpWorkingMessageExt.opLoadFinished(mdd.mIOpMmsDraftDataExt);
+
+                Log.d(TAG_DRAFT, "[loadFinished] boolean result : " + mdd.getBooleanResult());
+                if (mdd.getBooleanResult()) {
+                    mHasMmsDraft = true;
+                    SlideshowModel slideshow = mdd.getSlideshow();
+                    mMessageUri = mdd.getMessageUri();
+
+                    mSlideshow = slideshow;
+                    syncTextFromSlideshow();
+                    correctAttachmentState();
+                    if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+                        Log.d(TAG_DRAFT, "[loadFinished] defualt sms, do delete mms draft");
+                        if (getSlideshow() != null && getSlideshow().size() == 1
+                                && !getSlideshow().get(0).hasAudio()
+                                && !getSlideshow().get(0).hasImage()
+                                && !getSlideshow().get(0).hasVideo()
+                                && getSlideshow().sizeOfFilesAttach() == 0
+                                && TextUtils.isEmpty(subject)
+                                && TextUtils.isEmpty(getText())) {
+                            Log.d(TAG_DRAFT, "[loadFinished] delete");
+                            asyncDeleteDraftMmsMessage(mConversation);
+                            removeAllFileAttaches();
+                            removeAttachment(false);
+                            setSubject(subject, false);
+                            if (mConversation.getMessageCount() <= 0) {
+                                mConversation.clearThreadId();
+                            }
+                        }
+                    }
+                }
+            }
+            /// M Fix CR : ALPS01234459 @{
+            mIsLoadingDraft = false;
+            /// M @}
+            if (loadRunnable != null) {
+                mHanlder.post(loadRunnable);
+            }
+            /// M Fix CR : ALPS01071659 @{
+            deleteGruoupMmsDraft();
+            /// @}
+        }
+
+        public void updateAfterSaveDraftFinished(final Uri msgUri,
+                final int create, final boolean result) {
+            MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] msgUri is : " + msgUri
+                   + ", create : " + create);
+            // use a thread to enhance the quit compose performance which can quit to
+            // conversation list quickly
+            try {
+                if (msgUri == null && create == 1 && !result) {
+                    Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + " MmsException happened, and save failed!");
+                    removeAllFileAttaches();
+                    removeAttachment(true);
+                    mActivity.runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            // TODO Auto-generated method stub
+                            MessageUtils.showErrorDialog(mActivity,
+                                    android.R.string.dialog_alert_title,
+                                    R.string.error_add_attachment, 0, R.string.type_common_file);
+                        }
+                    });
+                    return;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] before msg uri : "
+                                                   + mMessageUri);
+                if (msgUri != null) {
+                    mMessageUri = msgUri;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] after msg uri : "
+                                                   + mMessageUri);
+
+                // / which if the save req is create, quit compose and mms maybe
+                // be killed
+                // / so store the uri into bundle, and start MMs again, which
+                // can load from preference.xml @{
+                if (mMessageUri != null && mBundle != null && create == 1) {
+                    // /M: fix bug: ALPS00568220,
+                    // /M: save message Uri in preference, some times MMS
+                    // will be killed by system
+                    SharedPreferences sp = PreferenceManager
+                            .getDefaultSharedPreferences(mActivity);
+                    SharedPreferences.Editor editor = sp.edit();
+                    editor.putString(SAVE_MSG_URI_KEY, mMessageUri.toString());
+                    MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + "save message uri to preference : " + mMessageUri.toString());
+                    editor.apply();
+                }
+                // / @}
+                if (mMessageUri != null) {
+                    if (!mConversation.getRecipients().isEmpty()) {
+                        mConversation.ensureThreadId();
+                        if (mBundle != null) {
+                            SharedPreferences sp1 =
+                                PreferenceManager.getDefaultSharedPreferences(mActivity);
+                            SharedPreferences.Editor editor1 = sp1.edit();
+                            Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                                    + "save thread id to preference : "
+                                    + mConversation.getThreadId());
+                            editor1.putLong(SAVE_MSG_THREADID_KEY, mConversation.getThreadId());
+                            editor1.apply();
+                        }
+                    }
+                    mConversation.setDraftState(true);
+                } else {
+                    mConversation.setDraftState(false);
+                }
+                // / @}
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "updateAfterSaveDraftFinished conv: "
+                            + mConversation + " uri: " + mMessageUri);
+                }
+
+                // / @}
+
+                // Be paranoid and delete any SMS drafts that might be lying
+                // around. Must do
+                // this after ensureThreadId so conv has the correct thread
+                // id.
+                asyncDeleteDraftSmsMessage(mConversation);
+
+                /// M : Fix CR : ALPS01031682
+                /// press home key, will saveDraft(Sms), and after change the recipients saveMms
+                /// the draft will update to the old thread @{
+                if (mOldSmsSaveThreadId > 0) {
+                    if (mOldSmsSaveThreadId != mConversation.getThreadId()) {
+                        deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                        ///M: add for fix issue ALPS01078057. when delete the saved sms
+                        /// should update the old thread's draft state to false.
+                        DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+                    }
+                }
+                /// M Fix CR: ALPS01105564 two draft will show in the conversation list
+                /// because the sound recorder will finish itself, when lock the screnn.
+                /// under this situtation, will send 2 save req to draftmanager,
+                /// meanwhile the mMessageUri is null
+                /// which will create 2 pdu id in the DB and bind to the origin thread .
+                /// after change the recipients, the thread will not be deleted,
+                /// so 2 threads showed in the conversationlist @{
+                deleteOldMmsDraft(mMessageUri, mConversation.getThreadId());
+                /// @}
+
+                /// M: Fix CR : ALPS01078057. when the thread changed,
+                /// if the old thread saved Mms draft before,
+                /// should reset the old thread's draft state @{
+                if (mOldMmsSaveThreadId != 0
+                        && mOldMmsSaveThreadId != mConversation.getThreadId()) {
+                    asyncDeleteOldMmsDraft(mOldMmsSaveThreadId);
+                    DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+                }
+                mOldMmsSaveThreadId = mConversation.getThreadId();
+                /// @}
+
+                // / M: Code analyze 042, For bug ALPS00117913, Delete old
+                // Mms draft when save Latest
+                // / Mms message as draft . @{
+                if (mNeedDeleteOldMmsDraft) {
+                    mNeedDeleteOldMmsDraft = false;
+                    asyncDeleteOldMmsDraft(mConversation.getThreadId());
+                }
+            } finally {
+                Log.d(TAG, "updateAfterSaveDraftFinished setSavingDraft(false)");
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+        }
+    }
+
+    /**
+     * Sets the text of the message to the specified CharSequence.
+     */
+    public void setText(CharSequence s) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setText: s = " + s);
+        }
+        /// M Fix CR : ALPS01234459, while loading draft, no need to set text @{
+        if (mIsLoadingDraft) {
+            Log.d(TAG, "[setText] run loading draft, do not need to set text");
+            return;
+        }
+        /// M @}
+        mText = s;
+        /// M: @{
+        if (mText != null && TextUtils.getTrimmedLength(mText) >= 0) {
+            syncTextToSlideshow();
+        }
+        if (mText == null || mText.length() == 0) {
+            /// M: fix bug ALPS00945813, remove MmsDraft when Length_Mms_Text are deleted
+            if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                asyncDeleteDraftMmsMessage(mConversation);
+                clearConversation(mConversation, true);
+            }
+            /// @}
+            /// M Fix CR ALPS01141440, which still has mms draft after forward message @{
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                    asyncDelete(mMessageUri, null, null);
+                    clearConversation(mConversation, true);
+                    mMessageUri = null;
+                }
+            }
+            /// @}
+        }
+
+    }
+
+    /**
+     * Returns the current message text.
+     */
+    public CharSequence getText() {
+        return mText;
+    }
+
+    /**
+     * @return True if the message has any text. A message with just whitespace is not considered
+     * to have text.
+     */
+    public boolean hasText() {
+        if (requiresMms()) {
+            return mText != null && TextUtils.getTrimmedLength(mText) > 0;
+        } else {
+            return mText != null && !TextUtils.isEmpty(mText);
+        }
+    }
+
+    public void removeAttachment(boolean notify) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT,
+                    "[removeAttachment] not default sms, can't remove attachment,just return!!");
+            return;
+        }
+        MmsLog.d(TAG, "WorkingMessage RemoveAttachment");
+        removeThumbnailsFromCache(mSlideshow);
+        /// M: fix bug ALPS00956551, need clear mText when add attachment twice
+        if (hasSlideshow()) {
+            mText = "";
+        }
+        mAttachmentType = TEXT;
+        /// M: fix bug ALPS02141556 @{
+        synchronized (this) {
+            mSlideshow = null;
+        }
+        /// @}
+        if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+        // mark this message as no longer having an attachment
+        updateState(HAS_ATTACHMENT, false, notify);
+        if (notify) {
+            // Tell ComposeMessageActivity (or other listener) that the attachment has changed.
+            // In the case of ComposeMessageActivity, it will remove its attachment panel because
+            // this working message no longer has an attachment.
+            mStatusListener.onAttachmentChanged();
+        }
+
+        clearConversation(mConversation, true);
+    }
+
+    public static void removeThumbnailsFromCache(SlideshowModel slideshow) {
+        if (slideshow != null) {
+            ThumbnailManager thumbnailManager = MmsApp.getApplication().getThumbnailManager();
+            boolean removedSomething = false;
+            Iterator<SlideModel> iterator = slideshow.iterator();
+            while (iterator.hasNext()) {
+                SlideModel slideModel = iterator.next();
+                if (slideModel.hasImage()) {
+                    /// M: change thumbnail's uri @{
+                    ImageModel im = slideModel.getImage();
+                    Uri uri = ThumbnailManager.getThumbnailUri(im);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                } else if (slideModel.hasVideo()) {
+                    /// M: change thumbnail's uri @{
+                    VideoModel vm = slideModel.getVideo();
+                    Uri uri = ThumbnailManager.getThumbnailUri(vm);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                }
+            }
+            if (removedSomething) {
+                // HACK: the keys to the thumbnail cache are the part uris, such as mms/part/3
+                // Because the part table doesn't have auto-increment ids, the part ids are reused
+                // when a message or thread is deleted. For now, we're clearing the whole thumbnail
+                // cache so we don't retrieve stale images when part ids are reused. This will be
+                // fixed in the next release in the mms provider.
+                MmsApp.getApplication().getThumbnailManager().clearBackingStore();
+            }
+        }
+    }
+
+    /**
+     * Adds an attachment to the message, replacing an old one if it existed.
+     * @param type Type of this attachment, such as {@link IMAGE}
+     * @param dataUri Uri containing the attachment data (or null for {@link TEXT})
+     * @param append true if we should add the attachment to a new slide
+     * @return An error code such as {@link UNKNOWN_ERROR} or {@link OK} if successful
+     */
+    public int setAttachment(int type, Uri dataUri, boolean append) {
+        MmsLog.dpi(TAG, "setAttachment type = " + type + " uri = " + dataUri);
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setAttachment type= " + type + "uri " + dataUri);
+        }
+        int result = OK;
+        SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+
+        // Special case for deleting a slideshow. When ComposeMessageActivity gets told to
+        // remove an attachment (search for AttachmentEditor.MSG_REMOVE_ATTACHMENT), it calls
+        // this function setAttachment with a type of TEXT and a null uri. Basically, it's turning
+        // the working message from an MMS back to a simple SMS. The various attachment types
+        // use slide[0] as a special case. The call to ensureSlideshow below makes sure there's
+        // a slide zero. In the case of an already attached slideshow, ensureSlideshow will do
+        // nothing and the slideshow will remain so that if a user adds a slideshow again, they'll
+        // see their old slideshow they previously deleted. Here we really delete the slideshow.
+        if (type == TEXT && mAttachmentType == SLIDESHOW && mSlideshow != null && dataUri == null
+                && !append) {
+            slideShowEditor.removeAllSlides();
+        }
+
+        /// M: This is added for failed to share only one picture with message. @{
+        if (mSlideshow == null) {
+            append = true;
+        }
+        /// @}
+
+        // Make sure mSlideshow is set up and has a slide.
+        ensureSlideshow();      // mSlideshow can be null before this call, won't be afterwards
+        slideShowEditor.setSlideshow(mSlideshow);
+
+        // Change the attachment and translate the various underlying
+        // exceptions into useful error codes.
+        try {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (type >= ATTACHMENT) {
+                if (mSlideshow == null) {
+                    mSlideshow = SlideshowModel.createNew(mActivity);
+                }
+                new FileAttachmentUtils().setOrAppendFileAttachment(
+                        mActivity, mSlideshow, mText, type, dataUri, append);
+            } else { /// @}
+                if (append) {
+                    appendMedia(type, dataUri);
+                } else {
+                    changeMedia(type, dataUri);
+                }
+            }
+            /// @}
+        } catch (MmsException e) {
+            /// M:
+            MmsLog.e(TAG, e.getMessage() != null ? e.getMessage() : "setAttachment MmsException");
+            result = UNKNOWN_ERROR;
+        } catch (UnsupportContentTypeException e) {
+            /// M: fix bug ALPS604911, modify toast msg
+            result = UNSUPPORTED_TYPE;
+        } catch (ExceedMessageSizeException e) {
+            result = MESSAGE_SIZE_EXCEEDED;
+        } catch (ResolutionException e) {
+            result = IMAGE_TOO_LARGE;
+        /// M: @{
+        } catch (ContentRestrictionException e) {
+            result = sCreationMode;
+        } catch (RestrictedResolutionException e) {
+            result = RESTRICTED_RESOLUTION;
+        } catch (IllegalStateException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (IllegalArgumentException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (SecurityException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        }
+        /// @}
+
+        MmsLog.d(TAG, "setAttachment result = " + result);
+
+        // If we were successful, update mAttachmentType and notify
+        // the listener than there was a change.
+        if (result == OK) {
+            mAttachmentType = type;
+            /// M: @{
+            if (mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+            if (mSlideshow.size() > 1) {
+                mAttachmentType = SLIDESHOW;
+            }
+            /// @}
+        } else if (append) {
+            // We added a new slide and what we attempted to insert on the slide failed.
+            // Delete that slide, otherwise we could end up with a bunch of blank slides.
+//            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            /// M: @{
+            if (slideShowEditor == null || mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+             /// @}
+
+            /// M: Modify ALPS00566470 @{
+            if (!mOpWorkingMessageExt.setAttachment(type, ATTACHMENT,
+                    slideShowEditor)) {
+                slideShowEditor.removeSlide(mSlideshow.size() - 1);
+            }
+        }
+
+        // correctAttachmentState();
+        mIsUpdateAttachEditor = true;
+
+        if (mSlideshow != null && type == IMAGE) {
+            // Prime the image's cache; helps A LOT when the image is coming from the network
+            // (e.g. Picasa album). See b/5445690.
+            int numSlides = mSlideshow.size();
+            if (numSlides > 0) {
+                ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+                if (imgModel != null) {
+                    cancelThumbnailLoading();
+                    imgModel.loadThumbnailBitmap(null);
+                }
+            }
+        }
+        mStatusListener.onAttachmentChanged();  // have to call whether succeeded or failed,
+                                                // because a replace that fails, removes the slide
+
+        if (!MmsConfig.getMultipartSmsEnabled()) {
+            if (!append && mAttachmentType == TEXT && type == TEXT) {
+                int[] params = SmsMessage.calculateLength(getText(), false);
+                /* SmsMessage.calculateLength returns an int[4] with:
+                *   int[0] being the number of SMS's required,
+                *   int[1] the number of code units used,
+                *   int[2] is the number of code units remaining until the next message.
+                *   int[3] is the encoding type that should be used for the message.
+                */
+                int msgCount = params[0];
+                /** M; change 4.1 google default
+                // if (msgCount > 1) {
+                //    // The provider doesn't support multi-part sms's so as soon as the user types
+                //    // an sms longer than one segment, we have to turn the message into an mms.
+                 */
+                if (msgCount >= MmsConfig.getSmsToMmsTextThreshold()) {
+                    setLengthRequiresMms(true, false);
+                } else {
+                    updateState(HAS_ATTACHMENT, hasAttachment(), true);
+                }
+            } else {
+                updateState(HAS_ATTACHMENT, hasAttachment(), true);
+            }
+        } else {
+            // Set HAS_ATTACHMENT if we need it.
+            updateState(HAS_ATTACHMENT, hasAttachment(), true);
+        }
+        correctAttachmentState();
+        if (type != IMAGE && mActivity instanceof ComposeMessageActivity) {
+            ((ComposeMessageActivity) mActivity).setWaitingAttachment(false);
+        }
+        return result;
+    }
+
+    /**
+     * Returns true if this message contains anything worth saving.
+     */
+    public boolean isWorthSaving() {
+        /// M:
+        MmsLog.d(M_TAG, "isWorthSaving(): hasText()="
+                + hasText() + ", hasSubject()=" + hasSubject()
+                + ", hasAttachment()=" + hasAttachment() + ", hasSlideshow()=" + hasSlideshow());
+        // If it actually contains anything, it's of course not empty.
+        if (hasText() || hasSubject() || hasAttachment() || hasSlideshow()) {
+            return true;
+        }
+        // When saveAsMms() has been called, we set FORCE_MMS to represent
+        // sort of an "invisible attachment" so that the message isn't thrown
+        // away when we are shipping it off to other activities.
+        if (isFakeMmsForDraft()) {
+            return true;
+        }
+        return false;
+    }
+
+    private void cancelThumbnailLoading() {
+        int numSlides = mSlideshow != null ? mSlideshow.size() : 0;
+        if (numSlides > 0) {
+            ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+            if (imgModel != null) {
+                imgModel.cancelThumbnailLoading();
+            }
+        }
+    }
+
+    /**
+     * Returns true if FORCE_MMS is set.
+     * When saveAsMms() has been called, we set FORCE_MMS to represent
+     * sort of an "invisible attachment" so that the message isn't thrown
+     * away when we are shipping it off to other activities.
+     */
+    public boolean isFakeMmsForDraft() {
+        return (mMmsState & FORCE_MMS) > 0;
+    }
+
+    /**
+     * Makes sure mSlideshow is set up.
+     */
+    private void ensureSlideshow() {
+        if (mSlideshow != null) {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (mSlideshow.size() > 0) {
+                return;
+            } else {
+                ///M: Modify for ALPS01250908
+                try {
+                    mSlideshow.add(new SlideModel(mSlideshow));
+                } catch (ContentRestrictionException e) {
+                    Log.e(TAG, "throw a ContentRestrictionException in ensureSlideshow");
+                }
+                return;
+            }
+            /// @}
+        }
+
+        SlideshowModel slideshow = SlideshowModel.createNew(mActivity);
+        SlideModel slide = new SlideModel(slideshow);
+        slideshow.add(slide);
+
+        mSlideshow = slideshow;
+    }
+
+    /**
+     * Change the message's attachment to the data in the specified Uri.
+     * Used only for single-slide ("attachment mode") messages.
+     */
+    private void changeMedia(int type, Uri uri) throws MmsException {
+        SlideModel slide = mSlideshow.get(0);
+
+        MediaModel media;
+        Uri uriTemp = null;
+        if (slide == null) {
+            Log.w(LogTag.TAG, "[WorkingMessage] changeMedia: no slides!");
+            return;
+        }
+
+        /// M: add for attachment enhance @{
+        /// M: If we're changing to text, just bail out. @{
+        if (type == TEXT) {
+            if (mSlideshow != null && mSlideshow.size() > 0) {
+                /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support. @{
+                if (mOpWorkingMessageExt.removeAllAttachFiles()) {
+                    mSlideshow.removeAllAttachFiles();
+                }
+                mSlideshow.clear();
+                mSlideshow = null;
+                ensureSlideshow();
+                if (isResizeImage()) {
+                    // Delete our MMS message, if there is one.
+                    if (mMessageUri != null) {
+                        asyncDelete(mMessageUri, null, null);
+                        setResizeImage(false);
+                    }
+                }
+            }
+            return;
+        }
+        /// M: get thumbnail uri @{
+        if (slide.hasImage()) {
+            ImageModel imageModel = slide.getImage();
+            uriTemp = Uri.parse(imageModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + imageModel.getSrc());
+        } else if (slide.hasVideo()) {
+            VideoModel videoModel = slide.getVideo();
+            uriTemp = Uri.parse(videoModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + videoModel.getSrc());
+        }
+        /// @}
+
+        // Make a correct MediaModel for the type of attachment.
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+        /// M: Code analyze 041, For new feature , add drm support . @{
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        int increaseSize = media.getMediaPackagedSize()
+                + MmsSizeUtils.getSlideshowReserveSize()
+                - mSlideshow.getCurrentSlideshowSize();
+        // OP01
+        increaseSize = mOpWorkingMessageExt.changeMedia(increaseSize,
+                mSlideshow.getAttachFilesPackagedSize());
+        if (increaseSize > 0) {
+            mSlideshow.checkMessageSize(increaseSize);
+        }
+
+        // Remove any previous attachments.
+        removeSlideAttachments(slide);
+
+        slide.add(media);
+
+        if (uriTemp != null) {
+            MmsApp.getApplication().getThumbnailManager().removeThumbnail(uriTemp);
+        }
+        /// @}
+        // For video and audio, set the duration of the slide to that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Add the message's attachment to the data in the specified Uri to a new slide.
+     */
+    private void appendMedia(int type, Uri uri) throws MmsException {
+
+        // If we're changing to text, just bail out.
+        if (type == TEXT) {
+            return;
+        }
+
+        // The first time this method is called, mSlideshow.size() is going to be
+        // one (a newly initialized slideshow has one empty slide). The first time we
+        // attach the picture/video to that first empty slide. From then on when this
+        // function is called, we've got to create a new slide and add the picture/video
+        // to that new slide.
+        boolean addNewSlide = true;
+        if (mSlideshow.size() == 1 && !mSlideshow.isSimple()) {
+            addNewSlide = false;
+        }
+        if (mSlideshow.size() == 1 && mSlideshow.get(0) != null
+                && mSlideshow.get(0).hasAudio() && mSlideshow.get(0).hasImage()) {
+            addNewSlide = true;
+        }
+        if (addNewSlide) {
+            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            if (!slideShowEditor.addNewSlide()) {
+                return;
+            }
+        }
+        mIsUpdateAttachEditor = false;
+        // Make a correct MediaModel for the type of attachment.
+        MediaModel media;
+        SlideModel slide = mSlideshow.get(mSlideshow.size() - 1);
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.IMAGE);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.VIDEO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.AUDIO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        slide.add(media);
+
+        /// M: for vcard, since we append a media, remove vCard
+        removeAllFileAttaches();
+
+        // For video and audio, set the duration of the slide to
+        // that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Returns true if the message has an attachment (including slideshows).
+     */
+    public boolean hasAttachment() {
+        return (mAttachmentType > TEXT);
+    }
+
+    /**
+     * Returns the slideshow associated with this message.
+     */
+    public SlideshowModel getSlideshow() {
+        return mSlideshow;
+    }
+
+    /**
+     * Returns true if the message has a real slideshow, as opposed to just
+     * one image attachment, for example.
+     */
+    public boolean hasSlideshow() {
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        return (mSlideshow != null && mSlideshow.size() > 1);
+        /// @}
+    }
+
+    /**
+     * Sets the MMS subject of the message.  Passing null indicates that there
+     * is no subject.  Passing "" will result in an empty subject being added
+     * to the message, possibly triggering a conversion to MMS.  This extra
+     * bit of state is needed to support ComposeMessageActivity converting to
+     * MMS when the user adds a subject.  An empty subject will be removed
+     * before saving to disk or sending, however.
+     */
+    public void setSubject(CharSequence s, boolean notify) {
+        /// M: @{
+        boolean flag = ((s != null) && TextUtils.getTrimmedLength(s) > 0);
+        mSubject = s;
+        if (flag) {
+            updateState(HAS_SUBJECT, flag, notify);
+        } else {
+            updateState(HAS_SUBJECT, flag, notify);
+        }
+        /// @}
+        /// M Fix CR ALPS01141440 @{
+        if (mSubject == null || mSubject.length() == 0) {
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == 0) {
+                    asyncDelete(mMessageUri, null, null);
+                    if (mConversation != null) {
+                        clearConversation(mConversation, true);
+                    }
+                    mMessageUri = null;
+                }
+            }
+        }
+       /// @}
+    }
+
+    /**
+     * Returns the MMS subject of the message.
+     */
+    public CharSequence getSubject() {
+        return mSubject;
+    }
+
+    /**
+     * Returns true if this message has an MMS subject. A subject has to be more than just
+     * whitespace.
+     * @return
+     */
+    public boolean hasSubject() {
+        return mSubject != null && TextUtils.getTrimmedLength(mSubject) > 0;
+    }
+
+    /**
+     * Moves the message text into the slideshow.  Should be called any time
+     * the message is about to be sent or written to disk.
+     */
+    private synchronized void syncTextToSlideshow() {
+        /// M: Because progress run async, so get the value first.
+        boolean waitingAttachment = false;
+        if (mActivity instanceof ComposeMessageActivity) {
+            waitingAttachment = ((ComposeMessageActivity) mActivity).isWaitingAttachment();
+        }
+
+        /// M: fix bug ALPS01365426, must calculate mIsExceedSize
+        if (mSlideshow != null && !TextUtils.isEmpty(mText)
+                && TextUtils.getTrimmedLength(mText) >= 0) {
+            int currentSize = getCurrentMessageSize();
+            if (currentSize > MmsConfig.getUserSetMmsSizeLimit(true) && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+        }
+        /// @}
+
+        if (mSlideshow == null || mSlideshow.size() != 1)
+            return;
+        try {
+            SlideModel slide = mSlideshow.get(0);
+            TextModel text;
+            /// M: change google default. @{
+            TextModel oldText = null;
+            if (slide != null) {
+                oldText = slide.getText();
+            }
+            /// M: fix bug ALPS01013522, workaround avoiding mSlideshow NPE
+            MmsLog.d(TAG, "syncTextToSlideshow() mSlideshow = "
+                    + String.valueOf(mSlideshow == null));
+            // Add a TextModel to slide 0 if one doesn't already exist
+            text = new TextModel(mActivity, ContentType.TEXT_PLAIN, "text_0.txt",
+                    mSlideshow != null ? mSlideshow.getLayout().getTextRegion()
+                                   : SlideshowModel.createNew(mActivity)
+                                           .getLayout().getTextRegion(),
+                    (!TextUtils.isEmpty(mText) &&
+                            TextUtils.getTrimmedLength(mText) >= 0)
+                                    ? (mText.toString()).getBytes() : null);
+
+            //klocwork issue pid:18444
+            if (slide != null) {
+                int oldLength = (oldText != null && oldText.getText() != null)
+                                ? oldText.getText().getBytes().length : 0;
+                int newLength = mText != null ? mText.toString().getBytes().length : 0;
+                if (newLength - oldLength > 0) {
+                    if (getCurrentMessageSize() + (newLength - oldLength)
+                                > MmsConfig.getUserSetMmsSizeLimit(true)) {
+                        throw new ExceedMessageSizeException();
+                    }
+                }
+                slide.add(text);
+            }
+        } catch (ExceedMessageSizeException e) {
+            if (!TextUtils.isEmpty(mText) && TextUtils.getTrimmedLength(mText) >= 0
+                    && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+            return;
+        } catch (ArrayIndexOutOfBoundsException e) {
+            /// M: fix bug ALPS01659457
+            Log.e(TAG, "syncTextToSlideshow ArrayIndexOutOfBoundsException");
+            return;
+        }
+        /// @}
+    }
+
+    /**
+     * Sets the message text out of the slideshow.  Should be called any time
+     * a slideshow is loaded from disk.
+     */
+    private void syncTextFromSlideshow() {
+        // Don't sync text for real slideshows.
+        if (mSlideshow.size() != 1) {
+            return;
+        }
+
+        SlideModel slide = mSlideshow.get(0);
+        if (slide == null || !slide.hasText()) {
+            return;
+        }
+
+        mText = slide.getText().getText();
+    }
+
+    /**
+     * Removes the subject if it is empty, possibly converting back to SMS.
+     */
+    private void removeSubjectIfEmpty(boolean notify) {
+        if (!hasSubject()) {
+            setSubject(null, notify);
+        }
+    }
+
+    /**
+     * Gets internal message state ready for storage.  Should be called any
+     * time the message is about to be sent or written to disk.
+     */
+    private void prepareForSave(boolean notify) {
+        // Make sure our working set of recipients is resolved
+        // to first-class Contact objects before we save.
+        syncWorkingRecipients();
+
+        if (requiresMms()) {
+            ensureSlideshow();
+            syncTextToSlideshow();
+            /// M:
+            removeSubjectIfEmpty(notify);
+        }
+    }
+
+    /**
+     * Resolve the temporary working set of recipients to a ContactList.
+     */
+    public void syncWorkingRecipients() {
+        if (mWorkingRecipients != null) {
+            ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+            mConversation.setRecipients(recipients);    // resets the threadId to zero
+            /// M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(recipients.size() > 1, true);
+            mWorkingRecipients = null;
+        }
+    }
+
+    public void updateStateForGroupMmsChanged() {
+        ContactList recipients = mConversation.getRecipients();
+        setHasMultipleRecipients(recipients.size() > 1, false);
+    }
+
+    public String getWorkingRecipients() {
+        // this function is used for DEBUG only
+        if (mWorkingRecipients == null) {
+            return null;
+        }
+        ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+        return recipients.serialize();
+    }
+
+    // Call when we've returned from adding an attachment. We're no longer forcing the message
+    // into a Mms message. At this point we either have the goods to make the message a Mms
+    // or we don't. No longer fake it.
+    public void removeFakeMmsForDraft() {
+        updateState(FORCE_MMS, false, false);
+    }
+
+    /**
+     * Force the message to be saved as MMS and return the Uri of the message.
+     * Typically used when handing a message off to another activity.
+     */
+    /// M: add synchronized.
+    public synchronized Uri saveAsMms(boolean notify) {
+        if (DEBUG) LogTag.debug("saveAsMms mConversation=%s", mConversation);
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveAsMms] Non-default sms, cann't save,just return!!");
+            return mMessageUri;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG, "saveAsMms mDiscarded: true mConversation: " + mConversation +
+                    " returning NULL uri and bailing");
+            return null;
+        }
+
+        // FORCE_MMS behaves as sort of an "invisible attachment", making
+        // the message seem non-empty (and thus not discarded).  This bit
+        // is sticky until the last other MMS bit is removed, at which
+        // point the message will fall back to SMS.
+        updateState(FORCE_MMS, true, notify);
+
+        // Collect our state to be written to disk.
+        prepareForSave(true /* notify */);
+
+        try {
+            // Make sure we are saving to the correct thread ID.
+            DraftCache.getInstance().setSavingDraft(true);
+            if (!mConversation.getRecipients().isEmpty()) {
+                mConversation.ensureThreadId();
+            }
+            mConversation.setDraftState(true);
+
+            //PduPersister persister = PduPersister.getPduPersister(mActivity);
+            SendReq sendReq = makeSendReq(mConversation, mSubject);
+
+            sendReq = mOpWorkingMessageExt.opSaveAsMms(sendReq);
+
+            long threadId = mConversation.getThreadId();
+
+            Log.d(TAG_DRAFT, "[saveAsMms] threadId : " + threadId);
+
+            MmsDraftData mdd =
+                DraftManager.getInstance().saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mMessageUri, mSlideshow, sendReq, mActivity, null);
+            if (mdd != null) {
+//                if (mMessageUri == null) {
+                    mMessageUri = mdd.getMessageUri();
+                    if (mdd.getCreateOrUpdate() == 1) {
+                        if (mMessageUri == null && !mdd.getBooleanResult()) {
+                            Log.d(TAG_DRAFT, "[saveAsMms] MmsException happened,and save failed!");
+                            removeAllFileAttaches();
+                            removeAttachment(true);
+                            mActivity.runOnUiThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    // TODO Auto-generated method stub
+                                    MessageUtils.showErrorDialog(mActivity,
+                                                    android.R.string.dialog_alert_title,
+                                                    R.string.error_add_attachment, 0,
+                                                    R.string.type_common_file);
+                                }
+                            });
+                        }
+                    }
+                    MmsLog.dpi(TAG_DRAFT,
+                            "[saveAsMms] call draft manager return , and mMessageUri : "
+                            + mMessageUri);
+                    asyncDeleteDraftSmsMessage(mConversation);
+//                }
+            }
+
+            /// M: google jb.mr1 patch
+            // If we don't already have a Uri lying around, make a new one.  If we do
+            // have one already, make sure it is synced to disk.
+
+            mHasMmsDraft = true;
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+        return mMessageUri;
+    }
+
+    /// M : FIX CR : ALPS01795853
+    /// While exist A MMS draft, then create a new composer, input A phone number
+    /// and input some text, then add image from gallery, this will cause delete the
+    /// MMS draft whcih saved before
+    ///
+    /// Root cause : while enter the document UI, composer will enter the onStop,
+    ///              which will save the sms draft that the content is inputted text
+    ///              after save finished, will delete the MMS draft @{
+    public void setTruntoChooseAttach(boolean chooseOrNot) {
+        Log.d(TAG_DRAFT, "[setTruntoChooseAttach] set to be : " + chooseOrNot);
+        mIsTurnToChooseAttach = chooseOrNot;
+    }
+    /// @}
+
+    /**
+     * Save this message as a draft in the conversation previously specified
+     * to {@link setConversation}.
+     */
+    public void saveDraft(final boolean isStopping) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveDraft] not default sms, no need to save draft, just return!!");
+            return;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG_DRAFT, "saveDraft mDiscarded: true mConversation: " + mConversation +
+                " skipping saving draft and bailing");
+            return;
+        }
+
+        // Make sure setConversation was called.
+        if (mConversation == null) {
+            throw new IllegalStateException("saveDraft() called with no conversation");
+        }
+
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "saveDraft for mConversation " + mConversation);
+        }
+
+        // Get ready to write to disk. But don't notify message status when saving draft
+        prepareForSave(false /* notify */);
+
+        if (requiresMms()) {
+            asyncUpdateDraftMmsMessage(mConversation, isStopping, mInterface);
+            mHasMmsDraft = true;
+
+            /// M: Update state of the draft cache.
+            mConversation.setDraftState(true);
+        } else {
+            String content = mText.toString();
+
+            // bug 2169583: don't bother creating a thread id only to delete the thread
+            // because the content is empty. When we delete the thread in updateDraftSmsMessage,
+            // we didn't nullify conv.mThreadId, causing a temperary situation where conv
+            // is holding onto a thread id that isn't in the database. If a new message arrives
+            // and takes that thread id (because it's the next thread id to be assigned), the
+            // new message will be merged with the draft message thread, causing confusion!
+            if (!TextUtils.isEmpty(content)) {
+                asyncUpdateDraftSmsMessage(mConversation, content);
+                mHasSmsDraft = true;
+            } else {
+                // When there's no associated text message, we have to handle the case where there
+                // might have been a previous mms draft for this message. This can happen when a
+                // user turns an mms back into a sms, such as creating an mms draft with a picture,
+                // then removing the picture.
+                /// Which used to fix load draft from widget, the compose will flicker
+                /// while flicking, this will delete mms draft @{
+                //asyncDeleteDraftMmsMessage(mConversation);
+                /// @}
+                mMessageUri = null;
+            }
+        }
+        // Update state of the draft cache.
+        /// M: coomment google default.
+        // mConversation.setDraftState(true);
+
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    synchronized public void discard() {
+        discard(true);
+    }
+    /// @}
+
+    public void unDiscard() {
+        if (DEBUG) LogTag.debug("unDiscard");
+
+        mDiscarded = false;
+    }
+
+    /**
+     * Returns true if discard() has been called on this message.
+     */
+    public boolean isDiscarded() {
+        return mDiscarded;
+    }
+
+    /**
+     * To be called from our Activity's onSaveInstanceState() to give us a chance
+     * to stow our state away for later retrieval.
+     *
+     * @param bundle The Bundle passed in to onSaveInstanceState
+     */
+    public void writeStateToBundle(Bundle bundle) {
+        mBundle = bundle;
+        if (hasSubject()) {
+            bundle.putString("subject", mSubject.toString());
+        }
+
+        if (mMessageUri != null) {
+            bundle.putParcelable("msg_uri", mMessageUri);
+        } else if (hasText()) {
+            bundle.putString("sms_body", mText.toString());
+        }
+        /// M: fix bug ALPS00779871
+        if (mMessageUri == null) {
+            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+            SharedPreferences.Editor editor = sp.edit();
+            editor.putString(SAVE_MSG_URI_KEY, "");
+            editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+            editor.apply();
+        }
+    }
+
+    /**
+     * To be called from our Activity's onCreate() if the activity manager
+     * has given it a Bundle to reinflate
+     * @param bundle The Bundle passed in to onCreate
+     */
+    public void readStateFromBundle(Bundle bundle) {
+        if (bundle == null) {
+            return;
+        }
+
+        String subject = bundle.getString("subject");
+        setSubject(subject, false);
+
+        Uri uri = (Uri) bundle.getParcelable("msg_uri");
+        ///M: fix bug: ALPS00568220,
+        ///M: load message Uri from preference, because some times MMS will be killed by system
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+        long threadId = sp.getLong(SAVE_MSG_THREADID_KEY, -1);
+        if (uri == null && mConversation != null && mConversation.getThreadId() == threadId
+                && threadId != -1) {
+            String uriString = sp.getString(SAVE_MSG_URI_KEY, null);
+            if (uriString != null && !uriString.equals("")) {
+                uri = Uri.parse(uriString);
+            }
+        }
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(SAVE_MSG_URI_KEY, "");
+        editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+        editor.apply();
+
+        if (uri != null) {
+            threadId = 0L;
+            if (mConversation != null) {
+                threadId = mConversation.getThreadId();
+                if (threadId <= 0 && !mConversation.getRecipients().isEmpty()) {
+                    threadId = mConversation.ensureThreadId();
+                }
+            }
+
+            MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                    threadId, uri, mActivity, null);
+            if (mdd != null && mdd.getBooleanResult()) {
+                mSlideshow = mdd.getSlideshow();
+                mMessageUri = mdd.getMessageUri();
+                syncTextFromSlideshow();
+                correctAttachmentState();
+            }
+//            loadFromUri(uri);
+            /// M: fix bug ALPS00779135
+            if (mSlideshow != null) {
+                mHasMmsDraft = true;
+            }
+            return;
+        } else {
+            String body = bundle.getString("sms_body");
+            /// M: Code analyze 049, For bug ALPS00106234, to solve the
+            /// "JE" pops up after you press Back key . @{
+            if (body == null) {
+                mText = "";
+            } else {
+                mText = body;
+            }
+            /// @}
+        }
+    }
+
+    /**
+     * Update the temporary list of recipients, used when setting up a
+     * new conversation.  Will be converted to a ContactList on any
+     * save event (send, save draft, etc.)
+     */
+    public void setWorkingRecipients(List<String> numbers) {
+        mWorkingRecipients = numbers;
+        String s = null;
+        if (numbers != null) {
+            int size = numbers.size();
+            switch (size) {
+            case 1:
+                s = numbers.get(0);
+                break;
+            case 0:
+                s = "empty";
+                break;
+            default:
+                s = "{...} len=" + size;
+            }
+        }
+        /// M:
+        MmsLog.dpi(TAG, "setWorkingRecipients: numbers=" + s);
+    }
+
+    private void dumpWorkingRecipients() {
+        Log.i(TAG, "-- mWorkingRecipients:");
+
+        if (mWorkingRecipients != null) {
+            int count = mWorkingRecipients.size();
+            for (int i = 0; i < count; i++) {
+                Log.d(TAG, "   [" + i + "] " + mWorkingRecipients.get(i));
+            }
+            Log.i(TAG, "");
+        }
+    }
+
+    public void dump() {
+        Log.i(TAG, "WorkingMessage:");
+        dumpWorkingRecipients();
+        if (mConversation != null) {
+            MmsLog.dpi(TAG, "mConversation: " + mConversation.toString());
+        }
+    }
+
+    /**
+     * Set the conversation associated with this message.
+     */
+    public void setConversation(Conversation conv) {
+        if (DEBUG) {
+            MmsLog.dpi(TAG, "setConversation " + mConversation + " -> " + conv);
+        }
+
+        mConversation = conv;
+
+        // Convert to MMS if there are any email addresses in the recipient list.
+        if (conv != null) {
+            ContactList contactList = conv.getRecipients();
+            setHasEmail(contactList.containsEmail(), false);
+            // / M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(contactList.size() > 1, false);
+        }
+    }
+
+    public Conversation getConversation() {
+        return mConversation;
+    }
+
+    /**
+     * Hint whether or not this message will be delivered to an
+     * an email address.
+     */
+    public void setHasEmail(boolean hasEmail, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.setHasEmail(" + hasEmail + ", " + notify + ")");
+        if (MmsConfig.getEmailGateway() != null) {
+            updateState(RECIPIENTS_REQUIRE_MMS, false, notify);
+        } else {
+            updateState(RECIPIENTS_REQUIRE_MMS, hasEmail, notify);
+        }
+    }
+    /** google JB.MR1 patch, group mms
+     * Set whether this message will be sent to multiple recipients. This is a hint whether the
+     * message needs to be sent as an mms or not. If MmsConfig.getGroupMmsEnabled is false, then
+     * the fact that the message is sent to multiple recipients is not a factor in determining
+     * whether the message is sent as an mms, but the other factors (such as, "has a picture
+     * attachment") still hold true.
+     */
+    public void setHasMultipleRecipients(boolean hasMultipleRecipients, boolean notify) {
+        updateState(MULTIPLE_RECIPIENTS,
+                hasMultipleRecipients &&
+                MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity),
+                notify);
+    }
+
+    /**
+     * Returns true if this message would require MMS to send.
+     */
+    public boolean requiresMms() {
+        return (mMmsState > 0);
+    }
+
+    /**
+     * Set whether or not we want to send this message via MMS in order to
+     * avoid sending an excessive number of concatenated SMS messages.
+     * @param: mmsRequired is the value for the LENGTH_REQUIRES_MMS bit.
+     * @param: notify Whether or not to notify the user.
+     */
+    public void setLengthRequiresMms(boolean mmsRequired, boolean notify) {
+        updateState(LENGTH_REQUIRES_MMS, mmsRequired, notify);
+    }
+
+    private static String stateString(int state) {
+        if (state == 0)
+            return "<none>";
+
+        StringBuilder sb = new StringBuilder();
+        if ((state & RECIPIENTS_REQUIRE_MMS) > 0)
+            sb.append("RECIPIENTS_REQUIRE_MMS | ");
+        if ((state & HAS_SUBJECT) > 0)
+            sb.append("HAS_SUBJECT | ");
+        if ((state & HAS_ATTACHMENT) > 0)
+            sb.append("HAS_ATTACHMENT | ");
+        if ((state & LENGTH_REQUIRES_MMS) > 0)
+            sb.append("LENGTH_REQUIRES_MMS | ");
+        if ((state & FORCE_MMS) > 0)
+            sb.append("FORCE_MMS | ");
+        /// M: google JB.MR1 patch, group mms
+        if ((state & MULTIPLE_RECIPIENTS) > 0)
+            sb.append("MULTIPLE_RECIPIENTS | ");
+
+        if (sb.length() > 3) {
+            sb.delete(sb.length() - 3, sb.length());
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Sets the current state of our various "MMS required" bits.
+     *
+     * @param state The bit to change, such as {@link HAS_ATTACHMENT}
+     * @param on If true, set it; if false, clear it
+     * @param notify Whether or not to notify the user
+     */
+    private void updateState(int state, boolean on, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.updateState(" + state + ", " + on + ", " + notify + ")");
+        if (!sMmsEnabled) {
+            // If Mms isn't enabled, the rest of the Messaging UI should not be using any
+            // feature that would cause us to to turn on any Mms flag and show the
+            // "Converting to multimedia..." message.
+            return;
+        }
+        int oldState = mMmsState;
+        if (on) {
+            mMmsState |= state;
+            /// M: Code analyze 048, For bug ALPS00338410, The message only with recipients
+            /// should not be saved as draft display in the all
+            /// messages list after you press "Back" . @{
+            if ((mMmsState & ~FORCE_MMS) > 0) {
+                mMmsState = (mMmsState & ~FORCE_MMS);
+            }
+            /// @}
+        } else {
+            mMmsState &= ~state;
+        }
+
+        // If we are clearing the last bit that is not FORCE_MMS,
+        // expire the FORCE_MMS bit.
+        if (mMmsState == FORCE_MMS && ((oldState & ~FORCE_MMS) > 0)) {
+            mMmsState = 0;
+        }
+        /// M:
+        MmsLog.d(M_TAG, "updateState(): notify=" + notify
+                + ", oldState=" + oldState + ", mMmsState=" + mMmsState);
+        // Notify the listener if we are moving from SMS to MMS
+        // or vice versa.
+        if (notify) {
+            if (oldState == 0 && mMmsState != 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(true, true);
+                /// @}
+            } else if (oldState != 0 && mMmsState == 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(false, true);
+                /// @}
+            }
+        }
+
+        if (oldState != mMmsState) {
+            MmsLog.d(TAG, stateString(mMmsState) + mMmsState);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) LogTag.debug("updateState: %s%s = %s",
+                    on ? "+" : "-",
+                    stateString(state), stateString(mMmsState));
+        }
+    }
+
+    /**
+     * Send this message over the network.  Will call back with onMessageSent() once
+     * it has been dispatched to the telephony stack.  This WorkingMessage object is
+     * no longer useful after this method has been called.
+     *
+     * @throws ContentRestrictionException if sending an MMS and uaProfUrl is not defined
+     * in mms_config.xml.
+     * M: Code analyze 047, For new feature ALPS00316567,
+     * extend this method for msim, add a parameter for subId
+     */
+    public void send(final String recipientsInUI, final int subId) {
+        MmsLog.d(MmsApp.TXN_TAG, "Enter send(). subId = " + subId);
+        final long origThreadId = mConversation.getThreadId();
+
+        if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            LogTag.debug("send origThreadId: " + origThreadId);
+        }
+
+        removeSubjectIfEmpty(true /* notify */);
+
+        // Get ready to write to disk.
+        prepareForSave(true /* notify */);
+
+        // We need the recipient list for both SMS and MMS.
+        final Conversation conv = mConversation;
+        final String msgTxt = mText.toString();
+        final SplitToMmsAndSmsConversation spliter =
+            new SplitToMmsAndSmsConversation(conv, msgTxt);
+
+         if (spliter.getMMSConversation() != null) {
+            // uaProfUrl setting in mms_config.xml must be present to send an MMS.
+            // However, SMS service will still work in the absence of a uaProfUrl address.
+            if (MmsConfig.getUaProfUrl() == null) {
+                String err = "WorkingMessage.send MMS sending failure. mms_config.xml is " +
+                        "missing uaProfUrl setting.  uaProfUrl is required for MMS service, " +
+                        "but can be absent for SMS.";
+                RuntimeException ex = new NullPointerException(err);
+                Log.e(TAG, err, ex);
+                // now, let's just crash.
+                throw ex;
+            }
+
+            // Make local copies of the bits we need for sending a message,
+            // because we will be doing it off of the main thread, which will
+            // immediately continue on to resetting some of this state.
+            final Uri mmsUri = mMessageUri;
+            final PduPersister persister = PduPersister.getPduPersister(mActivity);
+
+            final SlideshowModel slideshow = mSlideshow;
+            final CharSequence subject = mSubject;
+
+            if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "Send mmsUri: " + mmsUri);
+            }
+
+            // Do the dirty work of sending the message off of the main UI thread.
+            new Thread(new Runnable() {
+                public void run() {
+                    SendReq sendReq = makeSendReq(spliter.getMMSConversation(), subject);
+
+                    sendReq = mOpWorkingMessageExt.opSendThreadRun(sendReq);
+
+                    // Make sure the text in slide 0 is no longer holding onto a reference to
+                    // the text in the message text box.
+                    slideshow.prepareForSend();
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for gemini . @{
+                    if (spliter.getSMSConversation() != null) {
+                        ///M: Message got split into SMS & MMS. Need to
+                        /// set the mmsuri as NULL to again update it.
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                null, persister, slideshow, sendReq, subId);
+                    }
+                    else {
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                mmsUri, persister, slideshow, sendReq, subId);
+                    }
+                    /// @}
+
+                    updateSendStats(spliter.getMMSConversation());
+
+                    if (origThreadId > 0 && origThreadId != conv.getThreadId()) {
+                        boolean isHasDraft = DraftCache.refreshDraft(mActivity, origThreadId);
+                        Log.d(TAG,
+                                "[send] origThreadId : " + origThreadId
+                                + " isHasDraft : " + isHasDraft);
+                        DraftCache.getInstance().setDraftState(origThreadId, isHasDraft);
+                    }
+                }
+            }, "WorkingMessage.send MMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getMMSConversation().getThreadId(),
+                    spliter.getMMSConversation().getRecipients());
+        }
+        if (spliter.getSMSConversation() != null) {
+            new Thread(new Runnable() {
+                public void run() {
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for msim . @{
+                    preSendSmsWorker(spliter.getSMSConversation(), msgTxt, recipientsInUI, subId,
+                            (spliter.getMMSConversation() != null) ? true : false);
+                    /// @}
+                    updateSendStats(spliter.getSMSConversation());
+                }
+            }, "WorkingMessage.send SMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getSMSConversation().getThreadId(),
+                    spliter.getSMSConversation().getRecipients());
+        }
+
+        // Mark the message as discarded because it is "off the market" after being sent.\
+        /// M: comment google default.
+        // mDiscarded = true;
+    }
+
+    // Check for the Partial Compliant conditions
+    private boolean isPartiallySMSCompliant() {
+         boolean result = false;
+         if (((mMmsState & FORCE_MMS) == 0)
+             // NO slideshow that will convert the whole message for the whole
+             // recipients into MMS
+         && ((mMmsState & LENGTH_REQUIRES_MMS) == 0)
+             // DO NOT exceed a particular threshold of SMS truncation that
+             // will convert the whole message for the whole recipients into
+             // MMS
+         && ((mMmsState & HAS_ATTACHMENT) == 0)
+             // NO attachment that will convert the whole message for the
+             // whole recipients into MMS
+         && ((mMmsState & HAS_SUBJECT) == 0)) {
+             // NO subject that will convert the whole message for the whole
+             // recipients into MMS
+             // DO NOT check RECIPIENTS_REQUIRE_MMS to allow email & alias as
+             // recipients
+            result = true;
+             // Conversation where MMS could not be mandatory for some
+             // recipients : aka phone numbers.
+        }
+        return result;
+    }
+
+    // set conversation and split it into SMS & MMS conversation
+    private class SplitToMmsAndSmsConversation implements ISplitToMmsAndSmsConversationCallback {
+        private Conversation mSmsConv;
+
+        private Conversation mMmsConv;
+
+        private ContactList listSms;
+
+        private ContactList listMms;
+
+        // Split if necessary the initial conversation in one MMS conversation
+        // or/and one SMS conversation
+        // Allow to send SMS with phone numbers recipients when the conversation
+        // is still SMS compliant.
+
+        public SplitToMmsAndSmsConversation(final Conversation conv, final String msgTxt) {
+            mMmsConv = null;
+            mSmsConv = null;
+            Log.d(TAG, "setConversationToSplitAsSmsMms");
+
+            if (!mOpWorkingMessageExt.onCreateSplitToMmsAndSmsConv(this, conv)) {
+                if (requiresMms() || addressContainsEmailToMms(conv, msgTxt)) {
+                    mMmsConv = conv;
+                } else {
+                    mSmsConv = conv;
+                }
+                return;
+            }
+        }
+
+        private void splitConv(final Conversation conv) {
+            ContactList list = null;
+            Contact contact = null;
+            String number = null;
+            listSms = null;
+            listMms = null;
+
+            // Conversation with SMS/MMS Split is supported
+            if (conv != null) {
+                list = conv.getRecipients();
+                if (list != null) {
+                    if (requiresMms()) {
+                        if (isPartiallySMSCompliant()) {
+                            for (int i = 0; i < list.size(); i++) {
+                                contact = list.get(i);
+                                if (contact != null) {
+                                    number = contact.getNumber();
+                                    if (!TextUtils.isEmpty(number)) {
+                                        if (Mms.isPhoneNumber(number)) {
+                                            addContactAsSms(contact);
+                                        } else {
+                                            addContactAsMms(contact);
+                                        }
+                                    } else {
+                                        addContactAsMms(contact);
+                                    }
+                                } // contact
+                            }
+                        } else {
+                            listMms = list;
+                        } // isPartiallySMSCompliant
+                    } else {
+                        listSms = list;
+                    } // requiresMms
+
+                    if (listMms != null) {
+                        mMmsConv = conv;
+                        mMmsConv.setRecipients(listMms);
+                        if (listSms != null) {
+                            mSmsConv = Conversation.createNew(mActivity.getApplicationContext());
+                            mSmsConv.setRecipients(listSms);
+                        }
+                    } else if (listSms != null) {
+                        mSmsConv = conv;
+                        mSmsConv.setRecipients(listSms);
+                    }
+                }
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsMms(Contact contact) {
+            if (listMms == null) {
+                listMms = new ContactList();
+            }
+            if (!listMms.contains(contact)) {
+                listMms.add(contact);
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsSms(Contact contact) {
+            if (listSms == null) {
+                listSms = new ContactList();
+            }
+            if (!listSms.contains(contact)) {
+                listSms.add(contact);
+            }
+        }
+
+        protected Conversation getSMSConversation() {
+            return mSmsConv;
+        }
+
+        protected Conversation getMMSConversation() {
+            return mMmsConv;
+        }
+
+        /// M: @{
+        public void splitConvCallback(final IConversationCallback conv) {
+            splitConv((Conversation) conv);
+        }
+        /// @}
+    }
+
+    // Be sure to only call this on a background thread.
+    private void updateSendStats(final Conversation conv) {
+        String[] dests = conv.getRecipients().getNumbers();
+        final ArrayList<String> phoneNumbers = new ArrayList<String>(Arrays.asList(dests));
+
+        DataUsageStatUpdater updater = new DataUsageStatUpdater(mActivity);
+        updater.updateWithPhoneNumber(phoneNumbers);
+    }
+
+    private boolean addressContainsEmailToMms(Conversation conv, String text) {
+        if (MmsConfig.getEmailGateway() != null) {
+            String[] dests = conv.getRecipients().getNumbers();
+            int length = dests.length;
+            for (int i = 0; i < length; i++) {
+                if (Mms.isEmailAddress(dests[i]) || MessageUtils.isAlias(dests[i])) {
+                    String mtext = dests[i] + " " + text;
+                    int[] params = SmsMessage.calculateLength(mtext, false);
+                    if (params[0] > 1) {
+                        updateState(RECIPIENTS_REQUIRE_MMS, true, true);
+                        ensureSlideshow();
+                        syncTextToSlideshow();
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    // Message sending stuff
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void preSendSmsWorker(Conversation conv, String msgText, String recipientsInUI,
+            int subId, boolean hasBeenSplit) {
+    /// @}
+        // If user tries to send the message, it's a signal the inputted text is what they wanted.
+        UserHappinessSignals.userAcceptedImeText(mActivity);
+
+        mStatusListener.onPreMessageSent();
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        long origThreadId = conv.getThreadId();
+
+        if (mForceUpdateThreadId) {
+            conv.setNeedForceUpdateThreadId(true);
+            mForceUpdateThreadId = false;
+        }
+
+        // Make sure we are still using the correct thread ID for our recipient set.
+        long threadId = conv.ensureThreadId();
+
+        String semiSepRecipients = conv.getRecipients().serialize();
+
+        // recipientsInUI can be empty when the user types in a number and hits send
+        if (LogTag.SEVERE_WARNING && ((origThreadId != 0 && origThreadId != threadId) ||
+               ((!hasBeenSplit) && (!semiSepRecipients.equals(recipientsInUI))
+                       && !TextUtils.isEmpty(recipientsInUI)))) {
+            String msg = origThreadId != 0 && origThreadId != threadId ?
+                    "WorkingMessage.preSendSmsWorker threadId changed or " +
+                    "recipients changed. origThreadId: " +
+                    origThreadId + " new threadId: " + threadId +
+                    " also mConversation.getThreadId(): " +
+                    mConversation.getThreadId()
+                :
+                    "Recipients in window: \"" +
+                    recipientsInUI + "\" differ from recipients from conv: \"" +
+                    semiSepRecipients + "\"";
+
+            //LogTag.warnPossibleRecipientMismatch(msg, mActivity);
+        }
+
+        // just do a regular send. We're already on a non-ui thread so no need to fire
+        // off another thread to do this work.
+        /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+        sendSmsWorker(msgText, semiSepRecipients, threadId, subId);
+        /// @}
+
+        // Be paranoid and clean any draft SMS up.
+        deleteDraftSmsMessage(threadId);
+        /// M Fix CR:ALPS01268191 which is google issue. while save a mms draft, enter the
+        /// draft, change the recipients to be phone number, and send the sms. @{
+        Log.d(TAG_DRAFT, "[preSendSmsWorker] mOldThreadId : " + mOldThreadId);
+        if (mOldThreadId != 0) {
+//            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+                DraftCache.getInstance().setDraftState(mOldThreadId, false);
+//            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendSmsWorker(String msgText,
+            String semiSepRecipients, long threadId, int subId) {
+    /// @}
+        String[] dests = TextUtils.split(semiSepRecipients, ";");
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            MmsLog.dpi(LogTag.TRANSACTION, "sendSmsWorker sending message: recipients=" +
+                    semiSepRecipients + ", threadId=" + threadId);
+        }
+        MessageSender sender = new SmsMessageSender(mActivity, dests, msgText, threadId, subId);
+
+        try {
+            sender.sendMessage(threadId);
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getSmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send SMS message, threadId=" + threadId, e);
+        }
+
+        mStatusListener.onMessageSent();
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendMmsWorker(Conversation conv, Uri mmsUri, PduPersister persister,
+            SlideshowModel slideshow, SendReq sendReq, int subId) {
+    /// @}
+        long threadId = 0;
+        Cursor cursor = null;
+        boolean newMessage = false;
+        try {
+            // Put a placeholder message in the database first
+            DraftCache.getInstance().setSavingDraft(true);
+            mStatusListener.onPreMessageSent();
+
+            // Make sure we are still using the correct thread ID for our
+            // recipient set.
+            if (mForceUpdateThreadId) {
+                conv.setNeedForceUpdateThreadId(true);
+                mForceUpdateThreadId = false;
+            }
+            threadId = conv.ensureThreadId();
+            conv.setNeedForceUpdateThreadId(false);
+
+            MmsLog.dpi(TAG, "sendMmsWorker: update draft MMS message " + mmsUri +
+                        " threadId: " + threadId);
+
+            // One last check to verify the address of the recipient.
+            String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+            if (dests.length == 1) {
+                // verify the single address matches what's in the database. If we get a different
+                // address back, jam the new value back into the SendReq.
+                String newAddress =
+                    Conversation.verifySingleRecipient(mActivity, conv.getThreadId(), dests[0]);
+
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "sendMmsWorker: newAddress " + newAddress +
+                            " dests[0]: " + dests[0]);
+                }
+
+                if (!newAddress.equals(dests[0])) {
+                    dests[0] = newAddress;
+                    EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+                    if (encodedNumbers != null) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("sendMmsWorker: REPLACING number!!!");
+                        }
+                        sendReq.setTo(encodedNumbers);
+                    }
+                }
+            }
+            newMessage = mmsUri == null;
+            if (newMessage) {
+                // check if a draft is already present for current thread
+                final String selection = Mms.THREAD_ID + " = " + threadId;
+                cursor = SqliteWrapper.query(mActivity, mContentResolver, Mms.Draft.CONTENT_URI,
+                        MMS_DRAFT_PROJECTION, selection, null, null);
+                if (cursor == null) {
+                    Log.d(TAG, "[readDraftMmsMessage] cursor is null");
+                }
+                try {
+                    if (cursor != null) {
+                        if (cursor.moveToFirst()) {
+                            Uri uri = ContentUris.withAppendedId(Mms.Draft.CONTENT_URI,
+                                    cursor.getLong(MMS_ID_INDEX));
+                            Log.d(TAG, "retrieved uri = " + uri);
+                            mMessageUri = mmsUri = uri;
+                            newMessage = mmsUri == null;
+                        }
+                    }
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+
+            }
+            if (newMessage) {
+                // Write something in the database so the new message will appear as sending
+                ContentValues values = new ContentValues();
+                values.put(Mms.MESSAGE_BOX, Mms.MESSAGE_BOX_OUTBOX);
+                values.put(Mms.THREAD_ID, threadId);
+                values.put(Mms.MESSAGE_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim. @{
+                values.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+                /// @}
+                mmsUri = SqliteWrapper.insert(mActivity, mContentResolver, Mms.Outbox.CONTENT_URI,
+                        values);
+            }
+//            mStatusListener.onMessageSent();
+
+            // If user tries to send the message, it's a signal the inputted text is
+            // what they wanted.
+            UserHappinessSignals.userAcceptedImeText(mActivity);
+
+            // First make sure we don't have too many outstanding unsent message.
+            cursor = SqliteWrapper.query(mActivity, mContentResolver,
+                    Mms.Outbox.CONTENT_URI, MMS_OUTBOX_PROJECTION, null, null, null);
+            if (cursor != null) {
+                long maxMessageSize = MmsConfig.getMaxSizeScaleForPendingMmsAllowed() *
+                    /// M: change google default. @{
+                    MmsConfig.getUserSetMmsSizeLimit(true);
+                    /// @}
+                long totalPendingSize = 0;
+                while (cursor.moveToNext()) {
+                      /// M: change google default. @{
+                    if (PduHeaders.STATUS_UNREACHABLE
+                            != cursor.getLong(MMS_MESSAGE_STATUS_INDEX)) {
+                        totalPendingSize += cursor.getLong(MMS_MESSAGE_SIZE_INDEX);
+                    }
+                    /// @}
+                }
+                if (totalPendingSize >= maxMessageSize) {
+                    unDiscard();    // it wasn't successfully sent. Allow it to be saved as a draft.
+                    mStatusListener.onMaxPendingMessagesReached();
+                    markMmsMessageWithError(mmsUri, subId);
+
+                    /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+                    /// the conversation message count will set to be 0, and the threadid will be
+                    /// set to be 0, so while unlock the screen, the message
+                    /// will not show in the message list @{
+                    mStatusListener.onMessageSent();
+                    /// M @}
+
+                    MmsLog.d(MmsApp.TXN_TAG,
+                            "totalPendingSize >= maxMessageSize, totalPendingSize = "
+                            + totalPendingSize);
+                    return;
+                }
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        try {
+            MmsDraftData res = DraftManager.getInstance()
+                    .saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mmsUri, slideshow, sendReq, mActivity, null);
+            if (res != null) {
+                if (res.getMessageUri() != null) {
+                    MmsLog.dpi(TAG_DRAFT, "[sendMmsWorker] mmsUir : " + mmsUri);
+                    mmsUri = res.getMessageUri();
+                }
+            }
+            /*if (newMessage) {
+                // Create a new MMS message if one hasn't been made yet.
+                mmsUri = createDraftMmsMessage(persister, sendReq, slideshow, mmsUri,
+                        mActivity);
+            } else {
+                // Otherwise, sync the MMS message in progress to disk.
+                updateDraftMmsMessage(mmsUri, persister, slideshow, sendReq);
+            }*/
+
+            // Be paranoid and clean any draft SMS up.
+            deleteDraftSmsMessage(threadId);
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+
+        if (isAbortSendingMmsByFdnList(conv, subId)) {
+            MmsLog.d(TAG, "Abort Sending By FDN");
+            if (!mmsUri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+                ContentValues values = new ContentValues();
+                values.put(PendingMessages.PROTO_TYPE, MmsSms.MMS_PROTO);
+                values.put(PendingMessages.MSG_ID, ContentUris.parseId(mmsUri));
+                values.put(PendingMessages.MSG_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                values.put(PendingMessages.ERROR_TYPE, 0);
+                values.put(PendingMessages.ERROR_CODE, 0);
+                values.put(PendingMessages.RETRY_INDEX, 0);
+                values.put(PendingMessages.DUE_TIME, 0);
+
+                SqliteWrapper.insert(mActivity, mActivity.getContentResolver(),
+                        PendingMessages.CONTENT_URI, values);
+            }
+            markMmsMessageWithError(mmsUri, subId);
+            MessagingNotification.notifySendFailed(mActivity, true);
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            new Thread() {
+                public void run() {
+                    Looper.prepare();
+                    Toast.makeText(mActivity, mActivity.getString(R.string.fdn_check_failure),
+                            Toast.LENGTH_SHORT).show();
+                    Looper.loop();
+                };
+            } .start();
+            return;
+        }
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        try {
+            MessageSender sender = new MmsMessageSender(mActivity, mmsUri,
+                    slideshow.getCurrentSlideshowSize(), subId);
+            if (!sender.sendMessage(threadId)) {
+                // The message was sent through SMS protocol, we should
+                // delete the copy which was previously saved in MMS drafts.
+                SqliteWrapper.delete(mActivity, mContentResolver, mmsUri, null, null);
+            }
+            /// M: add for fix issue ALPS00804679 @{
+            else {
+                Log.d(TAG, "sendMmsWorker: sendMessage success, mark draft false. threadId = "
+                        + threadId);
+                DraftCache.getInstance().setSavingDraft(true);
+                conv.setDraftState(false);
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+            ///@}
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getMmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send message: " + mmsUri + ", threadId=" + threadId, e);
+        }
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    private boolean isAbortSendingMmsByFdnList(Conversation conv, int subId) {
+        boolean isFdnEnabled = false;
+        try {
+            ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(ServiceManager
+                    .getService("phoneEx"));
+            if (telephonyEx != null && telephonyEx.isFdnEnabled(subId)) {
+                isFdnEnabled = true;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "[isAbortSendingMmsByFdnList]catch exception:");
+            e.printStackTrace();
+            isFdnEnabled = false;
+        }
+        Log.d(TAG, "isAbortSendingMmsByFdnList, isFdnEnabled = " + isFdnEnabled);
+        if (!isFdnEnabled) {
+            return false;
+        } else {
+            Uri uri = null;
+            ContactList contactlist = conv.getRecipients();
+            String[] numbers = contactlist.getNumbers();
+            uri = Uri.parse(FDN_URI + subId);
+
+            Cursor cursor = SqliteWrapper.query(mActivity, mActivity.getContentResolver(),
+                    uri, FDN_PROJECTION, null, null, null);
+            ArrayList<String> fdnList = new ArrayList<String>();
+            if (cursor != null) {
+                try {
+                    while (cursor.moveToNext()) {
+                        String number = cursor.getString(FDN_COLUMN_NUMBER);
+                        if (number != null) {
+                            fdnList.add(number);
+                        }
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+            for (String contactNumber : numbers) {
+                MmsLog.dpi(TAG, "isAbortSending, contactNumber = " + contactNumber);
+                if (!isInStringArray(contactNumber, fdnList)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    private boolean isInStringArray(String string, ArrayList<String> arrayList) {
+        for (String oneString : arrayList) {
+            if (string.equals(oneString)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void markMmsMessageWithError(Uri mmsUri, int subId) {
+        try {
+            PduPersister p = PduPersister.getPduPersister(mActivity);
+            // Move the message into MMS Outbox. A trigger will create an entry in
+            // the "pending_msgs" table.
+            p.move(mmsUri, Mms.Outbox.CONTENT_URI);
+
+            // Now update the pending_msgs table with an error for that new item.
+            /// M Fix CR ALPS00584603
+            /// update pending_sim_id column which in pending_msgs table @{
+            ContentValues valuePendingTable = new ContentValues(2);
+            valuePendingTable.put(PendingMessages.ERROR_TYPE, MmsSms.ERR_TYPE_GENERIC_PERMANENT);
+            valuePendingTable.put(Telephony.MmsSms.PendingMessages.SUBSCRIPTION_ID, subId);
+            long msgId = ContentUris.parseId(mmsUri);
+            SqliteWrapper.update(mActivity, mContentResolver,
+                    PendingMessages.CONTENT_URI,
+                    valuePendingTable, PendingMessages.MSG_ID + "=" + msgId, null);
+            /// @}
+            /// M update sim_id column in pdu table @{
+            ContentValues valuePduTable = new ContentValues(1);
+            valuePduTable.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+            valuePduTable.put(Mms.READ, 0);
+            SqliteWrapper.update(mActivity, mContentResolver, mmsUri, valuePduTable, null, null);
+            /// @}
+        } catch (MmsException e) {
+            // Not much we can do here. If the p.move throws an exception, we'll just
+            // leave the message in the draft box.
+            Log.e(TAG, "Failed to move message to outbox and mark as error: " + mmsUri, e);
+        }
+    }
+
+    /**
+     * makeSendReq should always return a non-null SendReq, whether the dest addresses are
+     * valid or not.
+     */
+    private static SendReq makeSendReq(Conversation conv, CharSequence subject) {
+        /// M: change google default, @{
+        // String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+        String[] dests = conv.getRecipients().getNumbers(false /*don't scrub for MMS address */);
+        // @}
+
+        SendReq req = new SendReq();
+        EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+        if (encodedNumbers != null) {
+            req.setTo(encodedNumbers);
+        }
+
+        if (!TextUtils.isEmpty(subject)) {
+            req.setSubject(new EncodedStringValue(subject.toString()));
+        }
+
+        req.setDate(System.currentTimeMillis() / 1000L);
+
+        return req;
+    }
+
+    private void asyncUpdateDraftMmsMessage(final Conversation conv,
+            final boolean isStopping, final IDraftInterface callback) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncUpdateDraftMmsMessage conv= " + conv + " mMessageUri= "
+                                + mMessageUri);
+        }
+
+        DraftCache.getInstance().setSavingDraft(true);
+
+        SendReq sendReq = makeSendReq(conv, mSubject);
+
+        sendReq = mOpWorkingMessageExt.opAsyncUpdateDraftMmsMessage(sendReq);
+
+        long threadId = conv.getThreadId();
+
+        Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] before thread id : " + threadId);
+        if (threadId <= 0 && !conv.getRecipients().isEmpty()) {
+            threadId = conv.ensureThreadId();
+            Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] after thread id : " + threadId);
+        }
+
+        DraftManager.getInstance().saveDraft(DraftManager.ASYNC_SAVE_ACTION, threadId,
+                mMessageUri, mSlideshow, sendReq, mActivity, callback);
+    }
+
+    private static final String SMS_DRAFT_WHERE = Sms.TYPE + "=" + Sms.MESSAGE_TYPE_DRAFT;
+    private static final String[] SMS_BODY_PROJECTION = { Sms.BODY };
+    private static final int SMS_BODY_INDEX = 0;
+
+    /**
+     * Reads a draft message for the given thread ID from the database,
+     * if there is one, deletes it from the database, and returns it.
+     * @return The draft message or an empty string.
+     */
+    private String readDraftSmsMessage(Conversation conv) {
+        long thread_id = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "readDraftSmsMessage conv: " + conv);
+        }
+        // If it's an invalid thread or we know there's no draft, don't bother.
+        if (thread_id <= 0/* || !conv.hasDraft()*/) {
+            return "";
+        }
+
+        Uri thread_uri = ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, thread_id);
+        String body = "";
+
+        Cursor c = SqliteWrapper.query(mActivity, mContentResolver,
+                        thread_uri, SMS_BODY_PROJECTION, SMS_DRAFT_WHERE, null, null);
+        boolean haveDraft = false;
+        if (c != null) {
+            try {
+                if (c.moveToFirst()) {
+                    body = c.getString(SMS_BODY_INDEX);
+                    haveDraft = true;
+                }
+            } finally {
+                c.close();
+            }
+        }
+
+        // We found a draft, and if there are no messages in the conversation,
+        // that means we deleted the thread, too. Must reset the thread id
+        // so we'll eventually create a new thread.
+        if (haveDraft && (conv.getMessageCount() == 0 || FolderModeUtils.getMmsDirMode())) {
+            asyncDeleteDraftSmsMessage(conv);
+
+            // Clean out drafts for this thread -- if the recipient set changes,
+            // we will lose track of the original draft and be unable to delete
+            // it later.  The message will be re-saved if necessary upon exit of
+            // the activity.
+            clearConversation(conv, true);
+        }
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("readDraftSmsMessage haveDraft: ", !TextUtils.isEmpty(body));
+        }
+
+        return body;
+    }
+
+    public void clearConversation(final Conversation conv, boolean resetThreadId) {
+        /// M: Code analyze 052, For bug ALPS00047256, to solve shows a wrong thread . @{
+        int messageCount = 0;
+        final Uri sAllThreadsUri =
+            Threads.CONTENT_URI.buildUpon().appendQueryParameter("simple", "true").build();
+
+        if (conv.getMessageCount() == 0) {
+            Cursor cursor = SqliteWrapper.query(
+                mActivity,
+                mContentResolver,
+                sAllThreadsUri,
+                new String[] {Threads.MESSAGE_COUNT, Threads._ID} ,
+                Threads._ID + "=" + conv.getThreadId(), null, null);
+            if (cursor != null) {
+                try {
+                    if (cursor.moveToFirst()) {
+                        messageCount =
+                            cursor.getInt(cursor.getColumnIndexOrThrow(Threads.MESSAGE_COUNT));
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+        }
+        if (resetThreadId && conv.getMessageCount() == 0 && messageCount == 0) {
+            LogTag.debug("clearConversation calling clearThreadId");
+            conv.clearThreadId();
+        }
+
+        conv.setDraftState(false);
+    }
+
+    private void asyncUpdateDraftSmsMessage(final Conversation conv, final String contents) {
+        new Thread(new Runnable() {
+            public void run() {
+                try {
+                    DraftCache.getInstance().setSavingDraft(true);
+                    if (conv.getRecipients().isEmpty()) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("asyncUpdateDraftSmsMessage no recipients, not saving");
+                        }
+                        return;
+                    }
+                    /// M: Code analyze 054, For bug ALPS00120202, Message]can't save draft
+                    /// if enter message from messageDirect widget Sometimes thread id is
+                    /// deleted as obsolete thread, so need to guarantee it exists . @{
+                    conv.guaranteeThreadId();
+                    /// @}
+                    conv.setDraftState(true);
+                    updateDraftSmsMessage(conv, contents);
+                } finally {
+                    DraftCache.getInstance().setSavingDraft(false);
+                }
+            }
+        }, "WorkingMessage.asyncUpdateDraftSmsMessage").start();
+    }
+
+    private void updateDraftSmsMessage(final Conversation conv, String contents) {
+        final long threadId = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "updateDraftSmsMessage tid=" + threadId + ", contents= " + contents);
+        }
+        // If we don't have a valid thread, there's nothing to do.
+        if (threadId <= 0) {
+            return;
+        }
+
+        ContentValues values = new ContentValues(3);
+        values.put(Sms.THREAD_ID, threadId);
+        values.put(Sms.BODY, contents);
+        values.put(Sms.TYPE, Sms.MESSAGE_TYPE_DRAFT);
+        SqliteWrapper.insert(mActivity, mContentResolver, Sms.CONTENT_URI, values);
+        Log.d(TAG_DRAFT,
+                "[updateDraftSmsMessage] mIsTurnToChooseAttach : " + mIsTurnToChooseAttach);
+        if (!mIsTurnToChooseAttach) {
+            asyncDeleteDraftMmsMessage(conv);
+        }
+
+        if (mOldThreadId != 0) {
+            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+            }
+        }
+        /// M : Fix CR : ALPS01012417  Two threads showed in ConversationList
+        /// new message, input phone number, content, press home key, press message icon
+        /// will load the last sms message, change phone number,back to conversationlist. @{
+        if (mOldSmsSaveThreadId > 0) {
+            if (mOldSmsSaveThreadId != threadId) {
+                deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                ///M: add for fix issue ALPS01078057. when delete the saved sms, should update the
+                /// old thread's draft state to false.
+                DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+            }
+        }
+        mOldSmsSaveThreadId = threadId;
+        /// @}
+
+        /// M: Fix CR : ALPS01078057. when the thread changed,
+        /// if the old thread saved Mms draft before,
+        /// should reset the old thread's draft state @{
+        if (mOldMmsSaveThreadId != 0 && mOldMmsSaveThreadId != threadId) {
+            asyncDeleteDraftMmsMessage(mOldMmsSaveThreadId);
+            DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+            mOldMmsSaveThreadId = 0;
+        }
+        /// @}
+        mMessageUri = null;
+    }
+
+    private void asyncDelete(final Uri uri, final String selection, final String[] selectionArgs) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncDelete " + uri + " where " + selection);
+        }
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+            }
+        }, "WorkingMessage.asyncDelete").start();
+    }
+
+    public void checkDraftSmsMessage(final Conversation conv) {
+        final WorkingMessage msg = this;
+          new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                Log.d(TAG_DRAFT, "checkDraftSmsMessage draftText : " + draftText);
+                if (!TextUtils.isEmpty(draftText)) {
+                    msg.mHasSmsDraft = true;
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+    }
+
+    public void asyncDeleteDraftSmsMessage(Conversation conv) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+        }
+    }
+
+    //M: Add for modify issue ALPS01812929
+    public void asyncDeleteDraftSmsMessage(Conversation conv, final Runnable r) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null, r);
+        }
+    }
+
+    private void deleteDraftSmsMessage(long threadId) {
+        SqliteWrapper.delete(mActivity, mContentResolver,
+                ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+    }
+
+    public void asyncDeleteDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+        /// M: Reset MMS's message URI because the MMS is deleted */
+        mMessageUri = null;
+
+        }
+    }
+
+    public void asyncDeleteDraftMmsMessage(final long threadId) {
+        mHasMmsDraft = false;
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+            /// M: Reset MMS's message URI because the MMS is deleted */
+            mMessageUri = null;
+        }
+    }
+
+    /// M:
+    public int getCurrentMessageSize() {
+        if (mSlideshow != null) {
+            int currentMessageSize = mSlideshow.getCurrentSlideshowSize();
+            return currentMessageSize;
+        }
+        return 0;
+    }
+
+    /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't take
+    /// effect immediately after modify in settings Should update static variable
+    /// after peference is changed . @{
+    public static void updateCreationMode(Context context) {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
+        String creationMode =
+            sp.getString(MmsPreferenceActivity.CREATION_MODE, CREATION_MODE_FREE);
+        if (creationMode.equals(CREATION_MODE_WARNING)) {
+            sCreationMode = WARNING_TYPE;
+        } else if (creationMode.equals(CREATION_MODE_RESTRICTED)) {
+            sCreationMode = RESTRICTED_TYPE;
+        } else {
+            sCreationMode = OK;
+        }
+    }
+    /// @}
+
+    public boolean isResizeImage() {
+        return mResizeImage;
+    }
+
+    public void setResizeImage(boolean resizeImage) {
+        this.mResizeImage = resizeImage;
+    }
+
+    public Uri getMessageUri() {
+        return this.mMessageUri;
+    }
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft when save
+    /// Latest Mms message as draft . @{
+    public void  setNeedDeleteOldMmsDraft(Boolean delete) {
+        mNeedDeleteOldMmsDraft = delete;
+    }
+    /// @}
+
+    /**
+    * Fix CR : ALPS01105564
+    *  which used to delete the thread which has 2 mms drafts. only remain the last draft(pdu)
+    */
+    private void deleteOldMmsDraft(Uri msgUri, long tid) {
+        if (msgUri != null && tid > 0) {
+            String pduId = msgUri.getLastPathSegment();
+            final String where = Mms.THREAD_ID + "=" + tid + " and " + WordsTable.ID
+                 + " < " + pduId;
+            Log.d(TAG, "deleteOldMmsDraft where : " + where);
+            delete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+
+    /// M: Code analyze 055, For bug ALPS00234739, Remove old Mms draft in
+    /// conversation list instead of compose view . @}
+    private void asyncDeleteOldMmsDraft(final long threadId) {
+        MessageUtils.addRemoveOldMmsThread(new Runnable() {
+            public void run() {
+                if (mMessageUri != null && threadId > 0) {
+                    String pduId = mMessageUri.getLastPathSegment();
+                    final String where = Mms.THREAD_ID + "=" + threadId + " and " + WordsTable.ID
+                            + " != " + pduId;
+                    delete(Mms.Draft.CONTENT_URI, where, null);
+                }
+            }
+        });
+    }
+    /// @}
+
+    /**
+     * Delete all drafts of current thread by threadId.
+     *
+     * @param threadId
+     */
+    public void asyncDeleteAllMmsDraft(final long threadId) {
+        if (threadId > 0) {
+            MmsLog.d(TAG, "asyncDeleteAllMmsDraft");
+            final String where = Mms.THREAD_ID + "=" + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+    private WorkingMessage(Activity activity, MessageStatusListener l) {
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = l;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    public static WorkingMessage createEmpty(Activity activity, MessageStatusListener l) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity, l);
+        return msg;
+    }
+
+    public void setHasMmsDraft(boolean hasMmsDraft) {
+        mHasMmsDraft = hasMmsDraft;
+    }
+
+    public boolean checkSizeBeforeAppend() {
+        if (mSlideshow == null) {
+            return true;
+        }
+        mSlideshow.checkMessageSize(0);
+        return true;
+    }
+
+    private void removeSlideAttachments(SlideModel slide) {
+        slide.removeImage();
+        slide.removeVideo();
+        slide.removeAudio();
+
+        /// M: add for attachment enhance, For new feature ALPS00231349, add vCard support. @{
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public void removeAllFileAttaches() {
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    public boolean hasMediaAttachments() {
+        if (mSlideshow == null) {
+            return false;
+        }
+        if (hasSlideshow()) {
+            return true;
+        }
+        final SlideModel slide = mSlideshow.get(0);
+        return (slide != null) && (slide.hasAudio() || slide.hasVideo() || slide.hasImage());
+    }
+
+
+
+    public boolean hasAttachedFiles() {
+        return mSlideshow != null && mSlideshow.sizeOfFilesAttach() > 0;
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    public synchronized void discard(boolean isDiscard) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[discard] not default sms, cann't discard, just return!!");
+            return;
+        }
+
+        MmsLog.d(M_TAG, "discard(): Start. mConversation.ThreadId=" + mConversation.getThreadId()
+                + ", MessageCount=" + mConversation.getMessageCount());
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("[WorkingMessage] discard");
+        }
+
+        if (mDiscarded) {
+            return;
+        }
+
+        // Mark this message as discarded in order to make saveDraft() no-op.
+        mDiscarded = isDiscard;
+        cancelThumbnailLoading();
+
+        // Delete any associated drafts if there are any.
+        if (mHasMmsDraft) {
+            asyncDeleteCurrentDraftMmsMessage(mConversation);
+        }
+        if (mHasSmsDraft) {
+            /// M: fix bug ALPS01471051, ensureThreadId before discard sms draft
+            if (mConversation.getThreadId() == 0) {
+                mConversation.ensureThreadId();
+                Log.d(TAG_DRAFT, "[discard] ensureThreadId before discard sms draft");
+            }
+            //M: Add for modify issue ALPS01812929
+            asyncDeleteDraftSmsMessage(mConversation, new Runnable() {
+                            public void run() {
+                                if (mConversation != null) {
+                                    mConversation.setDraftState(false);
+                                }
+                            }
+                        });
+        }
+        if (mConversation.getThreadId() > 0) {
+            clearConversation(mConversation, true);
+        }
+    }
+    /// @}
+
+    private void delete(final Uri uri, final String selection, final String[] selectionArgs) {
+        /// M: Code analyze 056, For bug ALPS00094352, to solve JE
+        /// of MMS occured when I received serveral SM  . @}
+        if (uri != null) {
+            int result = -1; // if delete is unsuccessful, the delete()
+            // method will return -1
+            int retryCount = 0;
+            int maxRetryCount = 10;
+            while (result == -1 && retryCount < maxRetryCount) {
+                try {
+                    result = SqliteWrapper.delete(mActivity,
+                            mContentResolver, uri, selection, selectionArgs);
+
+                } catch (SQLiteDiskIOException e) {
+                    MmsLog.e(TAG, "asyncDelete(): SQLiteDiskIOException:"
+                            + " delete thread unsuccessful! Try time=" + retryCount);
+                } finally {
+                    retryCount++;
+                }
+            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 057, For bug ALPS00234653, to solve Can't continue
+    /// to play the vedio after share a video in mms . @}
+    private void asyncDeleteCurrentDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+
+            asyncDelete(mMessageUri, where, null, new Runnable() {
+                public void run() {
+                    if (mConversation != null) {
+                        mConversation.setDraftState(false);
+                    }
+                }
+            });
+
+            // / @}
+            mMessageUri = null;
+        } else if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+    }
+    /// @}
+
+    ///M: add for fix ALPS00452425 @{
+    private void asyncDelete(final Uri uri, final String selection,
+            final String[] selectionArgs, final Runnable r) {
+
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+                MmsLog.dpi(TAG, "delete finish, uri = " + uri);
+                if (r != null) {
+                    r.run();
+                }
+            }
+        }, "WorkingMessage.asyncDelete2").start();
+    }
+    /// @}
+
+    /// M Fix CR : ALPS01071659
+    /// First group message, save a mms draft,which only contain text,
+    /// back to conversationlist ,change to not normal message,
+    /// the enter the mms draft send the message,
+    /// back to conversationlist, the group mms draft still there
+    /// when loafFinished, call this to delete the mms draft
+    /// which is not group message, and only contains text @{
+    public void deleteGruoupMmsDraft() {
+        if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+            if (!MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity)
+                    && mConversation.getRecipients().size() > 1
+                    && mMmsState != RECIPIENTS_REQUIRE_MMS) {
+                if (!hasAttachedFiles() && !hasSlideshow() && !hasAttachment()
+                         && !hasMediaAttachments() && !hasSubject()) {
+                    asyncDeleteDraftMmsMessage(mConversation);
+                    clearConversation(mConversation, true);
+                }
+            }
+        }
+    }
+    /// @}
+
+    /// M: fix bug ALPS00712509, show toast when paste many word and > 300k
+    private boolean mIsExceedSize;
+
+    public boolean isExceedSize() {
+        return mIsExceedSize;
+    }
+
+    public void setIsExceedSize(boolean isExceedSize) {
+        mIsExceedSize = isExceedSize;
+    }
+    /// @}
+
+    private boolean mIsUpdateAttachEditor = true;
+
+    public boolean getIsUpdateAttachEditor() {
+        if (!mIsUpdateAttachEditor) {
+            MmsLog.d(TAG, "mIsUpdateAttachEditor == false");
+        }
+        return mIsUpdateAttachEditor;
+    }
+
+    public void setIsUpdateAttachEditor(boolean update) {
+        mIsUpdateAttachEditor = update;
+    }
+
+    /// M: fix bug ALPS01265824, need remove FileAttachment when text + attachmentSize > limit
+    public boolean isRemoveFileAttachment() {
+        if (mSlideshow != null
+                && mSlideshow.getCurrentSlideshowSize() > MmsConfig.getUserSetMmsSizeLimit(true)) {
+            return true;
+        }
+        return false;
+    }
+
+    // Add for IpMessage callback
+    public boolean requiresIpMms() {
+        return requiresMms();
+    }
+
+    public void setIpText(CharSequence s) {
+        setText(s);
+    }
+
+    public CharSequence getIpText() {
+        return getText();
+    }
+
+    public void syncWorkingIpRecipients() {
+        syncWorkingRecipients();
+    }
+
+    public void setIpSubject(CharSequence s, boolean notify) {
+        setSubject(s, notify);
+    }
+
+    public boolean hasDrmMedia() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMedia();
+    }
+
+    public boolean hasDrmMediaRight() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMediaRight();
+    }
+
+    public IWorkingMessageCallback loadCallback(Object activity, Uri uri) {
+        return load((ComposeMessageActivity) activity, uri);
+    }
+
+    public boolean hasMediaAttachmentsCallback() {
+        return hasMediaAttachments();
+    }
+
+    public void removeAllFileAttachesCallback() {
+        removeAllFileAttaches();
+    }
+
+    public int getState() {
+        return mMmsState;
+    }
+
+    public void correctAttachmentStateCallback() {
+        correctAttachmentState();
+    }
+
+    public boolean isIpWorthSaving() {
+        return isWorthSaving();
+    }
+
+    public CharSequence getIpSubject() {
+        return getSubject();
+    }
+
+    public void onAttachmentChangedCallback() {
+        mStatusListener.onAttachmentChanged();
+    }
+
+    public void discardCallback() {
+        discard();
+    }
+
+    public void updateStateExt(int state, boolean on, boolean notify) {
+        updateState(state, on, notify);
+    }
+
+    public void setLengthRequiresMmsCallback(boolean mmsRequired, boolean notify) {
+        setLengthRequiresMms(mmsRequired, notify);
+    }
+}

Property changes on: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/ComposeMessageActivity.java
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/ComposeMessageActivity.java	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/ComposeMessageActivity.java	(revision 2619)
@@ -0,0 +1,11298 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2008 Esmertec AG.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.ui;
+
+import static android.content.res.Configuration.KEYBOARDHIDDEN_NO;
+import static com.android.mms.transaction.ProgressCallbackEntity.PROGRESS_ABORT;
+import static com.android.mms.transaction.ProgressCallbackEntity.PROGRESS_COMPLETE;
+import static com.android.mms.transaction.ProgressCallbackEntity.PROGRESS_START;
+import static com.android.mms.transaction.ProgressCallbackEntity.PROGRESS_STATUS_ACTION;
+import static com.android.mms.ui.MessageListAdapter.COLUMN_ID;
+import static com.android.mms.ui.MessageListAdapter.COLUMN_MSG_TYPE;
+import static com.android.mms.ui.MessageListAdapter.PROJECTION;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.ProgressDialog;
+import android.app.StatusBarManager;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SqliteWrapper;
+import android.drm.DrmStore;
+import android.graphics.drawable.Drawable;
+import android.media.RingtoneManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcelable;
+import android.os.SystemClock;
+import android.preference.PreferenceManager;
+import android.provider.ContactsContract;
+import android.provider.MediaStore;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.provider.ContactsContract.CommonDataKinds;
+import android.provider.ContactsContract.CommonDataKinds.Email;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.Contacts;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.Intents;
+import android.provider.MediaStore.Audio;
+import android.provider.MediaStore.Images;
+import android.provider.MediaStore.Video;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.Sms;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.SpannableString;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.text.method.TextKeyListener;
+import android.text.style.URLSpan;
+import android.text.util.Linkify;
+import android.util.Log;
+import android.view.ContextMenu;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewStub;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.View.OnCreateContextMenuListener;
+import android.view.View.OnKeyListener;
+import android.view.View.OnTouchListener;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.webkit.MimeTypeMap;
+import android.widget.AdapterView;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.QuickContactBadge;
+import android.widget.SimpleAdapter;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.browser.provider.Browser;
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.mms.ExceedMessageSizeException;
+import com.android.mms.LogTag;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.TempFileProvider;
+import com.android.mms.data.Contact;
+import com.android.mms.data.ContactList;
+import com.android.mms.data.Conversation;
+import com.android.mms.data.Conversation.ConversationQueryHandler;
+import com.android.mms.data.WorkingMessage;
+import com.android.mms.data.WorkingMessage.MessageStatusListener;
+import com.android.mms.draft.DraftManager;
+import com.android.mms.draft.DraftService;
+import com.android.mms.drm.DrmUtils;
+import com.android.mms.model.AudioModel;
+import com.android.mms.model.MediaModel;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.R;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.transaction.MmsSystemEventReceiver.OnShutDownListener;
+import com.android.mms.transaction.MmsSystemEventReceiver.OnSubInforChangedListener;
+import com.android.mms.transaction.SmsReceiverService;
+import com.android.mms.transaction.Transaction;
+import com.android.mms.transaction.TransactionBundle;
+import com.android.mms.transaction.TransactionService;
+import com.android.mms.ui.MessageUtils.ResizeImageResultCallback;
+import com.android.mms.ui.RecipientsEditor.RecipientContextMenuInfo;
+import com.android.mms.ui.SubSelectDialog.SubClickAndDismissListener;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.FeatureOption;
+import com.android.mms.util.MessageResource;
+import com.android.mms.util.MmsContentType;
+import com.android.mms.util.MmsLog;
+import com.android.mms.util.SendingProgressTokenManager;
+import com.android.mms.util.ThreadCountManager;
+import com.android.mms.util.ThumbnailManager;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.android.mtkex.chips.MTKRecipientEditTextView;
+import com.android.mtkex.chips.RecipientEntry;
+import com.android.mtkex.chips.MTKRecipientEditTextView.ChipProcessListener;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.PduBody;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPart;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.SendReq;
+
+import com.mediatek.cta.CtaUtils;
+import com.mediatek.internal.telephony.CellConnMgr;
+import com.mediatek.internal.telephony.DefaultSmsSimSettings;
+import com.mediatek.internal.telephony.MmsConfigInfo;
+import com.mediatek.ipmsg.util.IpMessageUtils;
+import com.mediatek.mms.callback.IComposeActivityCallback;
+import com.mediatek.mms.callback.ITextSizeAdjustHost;
+import com.mediatek.mms.callback.IWorkingMessageCallback;
+import com.mediatek.mms.ext.IOpComposeExt;
+import com.mediatek.mms.ext.IOpWorkingMessageExt;
+import com.mediatek.mms.folder.ui.FolderViewList;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.ipmessage.IIpComposeActivityExt;
+import com.mediatek.mms.ipmessage.IIpConversationExt;
+import com.mediatek.mms.model.FileAttachmentModel;
+import com.mediatek.mms.ui.VCardAttachment;
+import com.mediatek.mms.util.DrmUtilsEx;
+import com.mediatek.mms.util.MmsDialogNotifyUtils;
+import com.mediatek.mms.util.MmsSizeUtils;
+import com.mediatek.mms.util.PermissionCheckUtil;
+import com.mediatek.mms.util.VCardUtils;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.GeneralPreferenceActivity;
+import com.mediatek.setting.MmsPreferenceActivity;
+import com.mediatek.setting.SettingListActivity;
+import com.mediatek.storage.StorageManagerEx;
+import com.mediatek.telephony.TelephonyManagerEx;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.lang.ref.WeakReference;
+import java.net.URLDecoder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+/**
+ * This is the main UI for:
+ * 1. Composing a new message;
+ * 2. Viewing/managing message history of a conversation.
+ *
+ * This activity can handle following parameters from the intent
+ * by which it's launched.
+ * thread_id long Identify the conversation to be viewed. When creating a
+ *         new message, this parameter shouldn't be present.
+ * msg_uri Uri The message which should be opened for editing in the editor.
+ * address String The addresses of the recipients in current conversation.
+ * exit_on_sent boolean Exit this activity after the message is sent.
+ */
+public class ComposeMessageActivity extends Activity
+        implements View.OnClickListener, TextView.OnEditorActionListener,
+        MessageStatusListener, Contact.UpdateListener, OnShutDownListener,
+ OnSubInforChangedListener,
+        ITextSizeAdjustHost, SubClickAndDismissListener {
+    public static final int REQUEST_CODE_ATTACH_IMAGE     = 100;
+    public static final int REQUEST_CODE_TAKE_PICTURE     = 101;
+    public static final int REQUEST_CODE_ATTACH_VIDEO     = 102;
+    public static final int REQUEST_CODE_TAKE_VIDEO       = 103;
+    public static final int REQUEST_CODE_ATTACH_SOUND     = 104;
+    public static final int REQUEST_CODE_RECORD_SOUND     = 105;
+    public static final int REQUEST_CODE_CREATE_SLIDESHOW = 106;
+    public static final int REQUEST_CODE_ECM_EXIT_DIALOG  = 107;
+    public static final int REQUEST_CODE_ADD_CONTACT      = 108;
+    public static final int REQUEST_CODE_PICK             = 109;
+
+    /// M: fix bug ALPS00490684, update group mms state from GROUP_PARTICIPANTS to setting @{
+    public static final int REQUEST_CODE_GROUP_PARTICIPANTS = 130;
+    /// @}
+    /// M: fix bug ALPS00448677, update or delete Contact Chip
+    public static final int REQUEST_CODE_VIEW_CONTACT     = 111;
+    private Contact mInViewContact;
+    /// @}
+
+    private static final String TAG = "Mms/compose";
+    private static final String TAG_OMH = "OMH_MMS";
+    /// M: add for ip message
+    private static final String TAG_DIVIDER = "Mms/divider";
+
+    private static final boolean DEBUG = false;
+    private static final boolean TRACE = false;
+    private static final boolean LOCAL_LOGV = false;
+
+    // Menu ID
+    private static final int MENU_ADD_SUBJECT           = 0;
+    private static final int MENU_DELETE_THREAD         = 1;
+    private static final int MENU_ADD_ATTACHMENT        = 2;
+    private static final int MENU_DISCARD               = 3;
+    private static final int MENU_SEND                  = 4;
+    private static final int MENU_CALL_RECIPIENT        = 5;
+    private static final int MENU_CONVERSATION_LIST     = 6;
+    private static final int MENU_DEBUG_DUMP            = 7;
+
+    // Context menu ID
+    private static final int MENU_VIEW_CONTACT          = 12;
+    private static final int MENU_ADD_TO_CONTACTS       = 13;
+
+    private static final int MENU_EDIT_MESSAGE          = 14;
+    private static final int MENU_VIEW_SLIDESHOW        = 16;
+    private static final int MENU_VIEW_MESSAGE_DETAILS  = 17;
+    private static final int MENU_DELETE_MESSAGE        = 18;
+    private static final int MENU_SEARCH                = 19;
+    private static final int MENU_DELIVERY_REPORT       = 20;
+    private static final int MENU_FORWARD_MESSAGE       = 21;
+    private static final int MENU_CALL_BACK             = 22;
+    private static final int MENU_SEND_EMAIL            = 23;
+    private static final int MENU_COPY_MESSAGE_TEXT     = 24;
+    private static final int MENU_COPY_TO_SDCARD        = 25;
+    private static final int MENU_INSERT_SMILEY         = 26;
+    private static final int MENU_ADD_ADDRESS_TO_CONTACTS = 27;
+    private static final int MENU_LOCK_MESSAGE          = 28;
+    private static final int MENU_UNLOCK_MESSAGE        = 29;
+    private static final int MENU_SAVE_RINGTONE         = 30;
+    private static final int MENU_PREFERENCES           = 31;
+    /// M: google jb.mr1 patch
+    private static final int MENU_GROUP_PARTICIPANTS    = 32;
+
+    private static final int MENU_SELECT_MESSAGE = 101;
+
+    private static final int MENU_COPY = 207;
+
+    private static final int MESSAGE_LIST_QUERY_TOKEN = 9527;
+    private static final int MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN = 9528;
+
+    private static final int DELETE_MESSAGE_TOKEN  = 9700;
+
+    private static final int CHARS_REMAINING_BEFORE_COUNTER_SHOWN = 10;
+
+    private static final long NO_DATE_FOR_DIALOG = -1L;
+
+    private static final String KEY_EXIT_ON_SENT = "exit_on_sent";
+    private static final String KEY_FORWARDED_MESSAGE = "forwarded_message";
+    private static final String KEY_APPEND_MESSAGE = "append_attachment";
+
+    private static final String EXIT_ECM_RESULT = "exit_ecm_result";
+
+    // When the conversation has a lot of messages and a new message is sent, the list is scrolled
+    // so the user sees the just sent message. If we have to scroll the list more than 20 items,
+    // then a scroll shortcut is invoked to move the list near the end before scrolling.
+    private static final int MAX_ITEMS_TO_INVOKE_SCROLL_SHORTCUT = 20;
+
+    // Any change in height in the message list view greater than this threshold will not
+    // cause a smooth scroll. Instead, we jump the list directly to the desired position.
+    private static final int SMOOTH_SCROLL_THRESHOLD = 200;
+
+    ///M: ALPS00592380: status of detection
+    private static final int DETECT_INIT = 0;
+    private static final int DETECT_ANGLE_BRACKETS = 1;
+    private static final int DETECT_ANGLE_BRACKETS_WITH_WORD = 2;
+
+    int TOAST_TYPE_FOR_SAVE_DRAFT = 0;
+    int TOAST_TYPE_FOR_SEND_MSG = 1;
+    int TOAST_TYPE_FOR_ATTACH = 2;
+
+    String USING_COLON = "USE_COLON";
+
+    String SELECTION_CONTACT_RESULT = "contactId";
+    String NUMBERS_SEPARATOR_COLON = ":";
+    String NUMBERS_SEPARATOR_SIMCOLON = ";";
+    String NUMBERS_SEPARATOR_COMMA = ",";
+
+    private ContentResolver mContentResolver;
+
+    private BackgroundQueryHandler mBackgroundQueryHandler;
+
+    private Conversation mConversation;     // Conversation we are working in
+
+    private boolean mExitOnSent;            // Should we finish() after sending a message?
+                                            // TODO: mExitOnSent is obsolete -- remove
+    private boolean mForwardMessageMode;
+
+    private View mTopPanel;                 // View containing the recipient and subject editors
+    private View mBottomPanel;              // View containing the text editor, send button, ec.
+    private EnhanceEditText mTextEditor;           // Text editor to type your message into
+    private TextView mTextCounter;          // Shows the number of characters used in text editor
+    private TextView mSendButtonMms;        // Press to send mms
+    private ImageButton mSendButtonSms;     // Press to send sms
+    private EditText mSubjectTextEditor;    // Text editor for MMS subject
+
+    private TextView mTypingStatus;
+    private TextView mRemoteStrangerText;
+
+    private AttachmentEditor mAttachmentEditor;
+    private View mAttachmentEditorScrollView;
+
+    private MessageListView mMsgListView;        // ListView for messages in this conversation
+    /// M: @{
+    public MessageListAdapter mMsgListAdapter = null;  // and its corresponding ListAdapter
+    /// @}
+    private RecipientsEditor mRecipientsEditor;  // UI control for editing recipients
+    private ImageButton mRecipientsPicker;       // UI control for recipients picker
+
+    private boolean mIsKeyboardOpen;             // Whether the hardware keyboard is visible
+    /// M: fix bug ALPS00419856, set TextEditor Height = four when unlock screen @{
+    private boolean mIsSoftKeyBoardShow;
+    private static final int SOFT_KEY_BOARD_MIN_HEIGHT = 150;
+    /// @}
+    private boolean mIsLandscape;                // Whether we're in landscape mode
+
+    private boolean mPossiblePendingNotification;   // If the message list has changed, we may have
+                                                    // a pending notification to deal with.
+
+    private boolean mToastForDraftSave;   // Whether to notify the user that a draft is being saved
+
+    private boolean mSentMessage;       // true if the user has sent a message while in this
+                                        // activity. On a new compose message case, when the first
+                                        // message is sent is a MMS w/ attachment, the list blanks
+                                        // for a second before showing the sent message. But we'd
+                                        // think the message list is empty, thus show the recipient
+                                        // editor thinking it's a draft message. This flag should
+                                        // help clarify the situation.
+
+    private WorkingMessage mWorkingMessage;         // The message currently being composed.
+
+    private AlertDialog mSmileyDialog;
+
+    private AlertDialog mDiscardDraftDialog;
+
+    private boolean mWaitingForSubActivity;
+    private int mLastRecipientCount;    // Used for warning the user on too many recipients.
+    private AttachmentTypeSelectorAdapter mAttachmentTypeSelectorAdapter;
+
+    private boolean mSendingMessage;    // Indicates the message is sending, and not send again.
+
+    private Intent mAddContactIntent;   // Intent used to add a new contact
+
+    private Uri mTempMmsUri;            // Only used as a temporary to hold a slideshow uri
+    private long mTempThreadId;         // Only used as a temporary to hold a threadId
+    /// M: fix bug for ConversationList select all performance ,update selected threads array.@{
+    private long mSelectedThreadId = 0;
+    /// @}
+
+    private AsyncDialog mAsyncDialog;   // Used for background tasks.
+
+    private String mDebugRecipients;
+    private int mLastSmoothScrollPosition;
+    private boolean mScrollOnSend;      // Flag that we need to scroll the list to the end.
+
+    private int mSavedScrollPosition = -1;  // we save the ListView's scroll position in onPause(),
+                                            // so can remember it after re-entering the activity.
+                                            // If the value >= 0, then we jump to that line. If the
+                                            // value is maxint, then we jump to the end.
+    private long mLastMessageId;
+
+    ///M: ALPS00726802, this int save the position in cursor of the clicked item
+    private int mClickedItemPosition = -1;
+
+    private boolean  mErrorDialogShown = true;
+    /**
+     * Whether this activity is currently running (i.e. not paused)
+     */
+    private boolean mIsRunning;
+    // key for extras and icicles
+    public static final String THREAD_ID = "thread_id";
+
+    ///M: add for fix issue ALPS00380788
+    private ProgressDialog mCellProgressDialog;
+
+    /// M: fix bug ALPS00397146, removeThumbnailManager uri
+    // (Content://media/external/images/media/) when it rotated
+    private static final HashMap<String, Integer> sDegreeMap = new HashMap<String, Integer>();
+    /// @}
+
+    private String mBeforeTextChangeString = "";
+
+    //public static final String SELECTED_ID = "SELECTID";
+
+    private InputMethodManager mInputMethodManager = null;
+
+    private AlertDialog mPlaneModeDialog = null;
+
+    ///M: actionbar customer view
+    private View mActionBarCustomView;
+    private TextView mTopTitle;
+    private ImageView mMuteLogo;
+    private TextView mTopSubtitle;
+
+    private boolean mHadToSlideShowEditor = false;
+
+    /// M: record cell progress dialog is showing or not
+    private boolean mIsCellDialogShowing = false;
+
+    private boolean mForwardingMessage = false;
+
+    /// M: fix bug ALPS01258201, mAsyncTaskNum for count asyncTask number
+    //  ShowRunnable can avoid dismiss progressDialog.
+    private int mAsyncTaskNum;
+
+    /// M: fix bug ALPS01505548, delete VCard temp file
+    private ArrayList<String> mVCardFiles = new ArrayList<String>();
+
+    // add for ipmessage
+    public IIpComposeActivityExt mIpCompose;
+    public ComposeActivityCallback mIpComposeCallback = new ComposeActivityCallback();
+
+    // add for Op plugin
+    public IOpComposeExt mOpComposeExt;
+
+    private ContextMenu mChipViewMenu = null;
+
+    private boolean mIsActivityPaused = true;
+    private boolean mIsActivityStoped = true;
+
+    // add for Runtime permission
+    private boolean mNeedRequestPermissins = false;
+    private Bundle mSavedInstanceState = null;
+
+    /// M: ALPS03562153 @{
+    private boolean mCreateFromSendTo = false;
+    /// @}
+
+    private void dismissProgressDialog() {
+        Log.d(TAG, "Composer reduce mAsyncTaskNum = " + (--mAsyncTaskNum));
+        if (mAsyncTaskNum == 0) {
+            runOnUiThread(new Runnable() {
+                public void run() {
+                    getAsyncDialog().dismissProgressDialog();
+                    getAsyncDialog().resetProgressDialog();
+                }
+            });
+        }
+    }
+
+    class ShowRunnable implements Runnable {
+        public void run() {
+        }
+    }
+
+    private Runnable mQueryMsgListRunnable = new Runnable() {
+        public void run() {
+            // add for op plugin
+            Uri conversationUri = mOpComposeExt.onQueryMsgListRun(mConversation.getUri(),
+                    mConversation.getThreadId());
+            if (conversationUri == null) {
+                log("##### startMsgListQuery: conversationUri is null, bail!");
+                return;
+            }
+            final long threadId = mConversation.getThreadId();
+
+            boolean queryed = mIpCompose.onIPQueryMsgList(mBackgroundQueryHandler,
+                    MESSAGE_LIST_QUERY_TOKEN, threadId, conversationUri,
+                    PROJECTION, null, null, null);
+            if (!queryed) {
+                mBackgroundQueryHandler.startQuery(
+                        MESSAGE_LIST_QUERY_TOKEN, threadId, conversationUri,
+                        PROJECTION, null, null, null);
+            }
+        }
+    };
+    /// @}
+
+    public Handler mHandler = new Handler() {
+        public void handleMessage(Message msg) {
+            if (mIpCompose.handleIpMessage(msg)) {
+                super.handleMessage(msg);
+                return;
+            }
+            super.handleMessage(msg);
+        }
+    };
+
+    @SuppressWarnings("unused")
+    public static void log(String logMsg) {
+        Thread current = Thread.currentThread();
+        long tid = current.getId();
+        StackTraceElement[] stack = current.getStackTrace();
+        String methodName = stack[3].getMethodName();
+        // Prepend current thread ID and name of calling method to the message.
+        logMsg = "[" + tid + "] [" + methodName + "] " + logMsg;
+        Log.d(TAG, logMsg);
+    }
+
+    //==========================================================
+    // Inner classes
+    //==========================================================
+
+    private void editSlideshow() {
+        // The user wants to edit the slideshow. That requires us to persist the slideshow to
+        // disk as a PDU in saveAsMms. This code below does that persisting in a background
+        // task. If the task takes longer than a half second, a progress dialog is displayed.
+        // Once the PDU persisting is done, another runnable on the UI thread get executed to start
+        // the SlideshowEditActivity.
+
+        /// M: fix bug ALPS00520531, Do not load draft when compose is going to edit slideshow
+//        mContentResolver.unregisterContentObserver(mDraftChangeObserver);
+
+        getAsyncDialog().runAsync(new Runnable() {
+            @Override
+            public void run() {
+                // This runnable gets run in a background thread.
+                mTempMmsUri = mWorkingMessage.saveAsMms(false);
+            }
+        }, new Runnable() {
+            @Override
+            public void run() {
+                // Once the above background thread is complete, this runnable is run
+                // on the UI thread.
+                if (mTempMmsUri == null) {
+                    mWaitingForSubActivity = false;
+                    return;
+                }
+                long threadId = mConversation.getThreadId();
+                if (threadId <= 0) {
+                    if (!mConversation.getRecipients().isEmpty()) {
+                        threadId = mConversation.ensureThreadId();
+                    }
+                }
+                /// M: add for fix ALPS01317511 @{
+                mOpComposeExt.editSlideshow(mHadToSlideShowEditor);
+                /// @}
+                Intent intent = new Intent(ComposeMessageActivity.this,
+                        SlideshowEditActivity.class);
+                intent.setData(mTempMmsUri);
+                intent.putExtra("thread_id", threadId);
+                startActivityForResult(intent, REQUEST_CODE_CREATE_SLIDESHOW);
+            }
+        // M: fix bug ALPS00351027
+        }, R.string.sync_mms_to_db);
+    }
+
+    private final Handler mAttachmentEditorHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            MmsLog.d(TAG, "mAttachmentEditorHandler, handleMessage = " + msg.what);
+            /// M: Code analyze 026, If the two clicks are too close. @{
+
+            long oldTime = mAttachClickTime;
+            mAttachClickTime = SystemClock.elapsedRealtime();
+            if ((mAttachClickTime - oldTime < 500) && (mAttachClickTime - oldTime > 0)) {
+                MmsLog.d(TAG, "mAttachmentEditorHandler, ignore a click if too close");
+                return;
+            }
+
+            /// M: OP01
+            if (mOpComposeExt.handleAttachmentEditorHandlerMessage(msg,
+                    mSendButtonCanResponse, mWorkingMessage,
+                    mWorkingMessage.getSlideshow(), mCompressingImage)) {
+                return;
+            }
+            switch (msg.what) {
+                case AttachmentEditor.MSG_EDIT_SLIDESHOW: {
+                    /// M: Code analyze 024, If the click operator can be responsed. @{
+                    if (mClickCanResponse) {
+                        mClickCanResponse = false;
+                        /// M: Code analyze 038, If the user is editing slideshow now.
+                        /// Do not allow the activity finish but return
+                        /// directly when back key is entered. @{
+                        mIsEditingSlideshow = true;
+                        /// @}
+                        editSlideshow();
+                    }
+                    /// @}
+                    break;
+                }
+                case AttachmentEditor.MSG_SEND_SLIDESHOW: {
+                    if (isPreparedForSending()) {
+                        /// M: Code analyze 028, Before sending message,check the recipients count
+                        /// and add sub card selection dialog if multi sub cards exist.@{
+                        // ComposeMessageActivity.this.confirmSendMessageIfNeeded();
+                        checkRecipientsCount();
+                        /// @}
+                    }
+                    break;
+                }
+                case AttachmentEditor.MSG_VIEW_IMAGE:
+                case AttachmentEditor.MSG_PLAY_VIDEO:
+                case AttachmentEditor.MSG_PLAY_AUDIO:
+                case AttachmentEditor.MSG_PLAY_SLIDESHOW:
+                    /// M: Code analyze 024, If the click operator can be responsed. @{
+                    if (mClickCanResponse) {
+                        mClickCanResponse = false;
+                        viewMmsMessageAttachment(msg.what);
+                    }
+                    /// @}
+                    /// M: Code analyze 051, Hide input keyboard.@{
+                    hideInputMethod();
+                    /// @}
+                    break;
+
+                case AttachmentEditor.MSG_REPLACE_IMAGE:
+                    /// M: @{
+                    getSharedPreferences("SetDefaultLayout", 0)
+                        .edit().putBoolean("SetDefaultLayout", false).commit();
+                    /// @}
+                case AttachmentEditor.MSG_REPLACE_VIDEO:
+                case AttachmentEditor.MSG_REPLACE_AUDIO:
+                    /// M: Code analyze 051, Hide input keyboard.@{
+                    hideInputMethod();
+                    /// @}
+                    showAddAttachmentDialog(false);
+                    break;
+
+                case AttachmentEditor.MSG_REMOVE_ATTACHMENT:
+                    /// M: fix bug ALPS01538338
+                    if (!mSendButtonCanResponse) {
+                        MmsLog.d(TAG, "handle MSG_REMOVE_ATTACHMENT return");
+                        return;
+                    }
+                    mWorkingMessage.removeAttachment(true);
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+
+    private void viewMmsMessageAttachment(final int requestCode) {
+        final SlideshowModel slideshow = mWorkingMessage.getSlideshow();
+        if (slideshow == null) {
+            /// M: ALPS01846425. If mms has been sent, slideshow is null. @{
+//            throw new IllegalStateException("mWorkingMessage.getSlideshow() == null");
+            MmsLog.e(TAG, "viewMmsMessageAttachment slideshow is null",
+                    new IllegalStateException("mWorkingMessage.getSlideshow() == null"));
+            return;
+            /// @}
+        }
+        /// M: Code analyze 035, The audio becomes "simple" slideshow.
+        /// Launch the slideshow activity or MmsPlayerActivity to play/view media attachment. @{
+        SlideModel slideOne = slideshow.get(0);
+        if (slideshow.isSimple() && slideOne != null && !slideOne.hasAudio()) {
+            MessageUtils.viewSimpleSlideshow(this, slideshow);
+        } else {
+
+            // M: change feature ALPS01751464
+            if (slideshow.isSimple() && slideOne != null && slideOne.hasAudio()) {
+                MediaModel model = slideOne.getAudio();
+                if (model != null && model.hasDrmContent()) {
+                    DrmUtilsEx.showDrmAlertDialog(ComposeMessageActivity.this);
+                    return;
+                }
+            }
+
+            // The user wants to view the slideshow. That requires us to persist the slideshow to
+            // disk as a PDU in saveAsMms. This code below does that persisting in a background
+            // task. If the task takes longer than a half second, a progress dialog is displayed.
+            // Once the PDU persisting is done, another runnable on the UI thread get executed to
+            // start the SlideshowActivity.
+            getAsyncDialog().runAsync(new Runnable() {
+                @Override
+                public void run() {
+                    // This runnable gets run in a background thread.
+                    mTempMmsUri = mWorkingMessage.saveAsMms(false);
+                }
+            }, new Runnable() {
+                @Override
+                public void run() {
+                    // Once the above background thread is complete, this runnable is run
+                    // on the UI thread.
+                    // Launch the slideshow activity to play/view.
+                    Intent intent;
+                    SlideModel slide = slideshow.get(0);
+                    /// M: play the only audio directly
+                    if ((slideshow.isSimple() && slide != null && slide.hasAudio())
+                        || (requestCode == AttachmentEditor.MSG_PLAY_AUDIO)) {
+                        intent = new Intent(ComposeMessageActivity.this, SlideshowActivity.class);
+                    } else {
+                        intent = new Intent(ComposeMessageActivity.this, MmsPlayerActivity.class);
+                    }
+                    intent.setData(mTempMmsUri);
+                    if (mTempMmsUri == null) {
+                        MmsLog.d(TAG, "viewMmsMessageAttachment mTempMmsUri == null");
+                        return;
+                    }
+                    if (requestCode > 0) {
+                        startActivityForResult(intent, requestCode);
+                    } else {
+                        startActivity(intent);
+                    }
+                    /// @}
+                }
+            // M: fix bug ALPS00351027
+            }, R.string.sync_mms_to_db);
+        }
+    }
+
+    // Whether or not we are currently enabled for SMS. This field is updated in onStart to make
+    // sure we notice if the user has changed the default SMS app.
+    private boolean mIsSmsEnabled;
+
+    private final Handler mMessageListItemHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            MessageItem msgItem = (MessageItem) msg.obj;
+                /// M: move if into switch, we have item not use it.
+                /// M: Code analyze, fix bug ALPS00358964
+            if (msgItem != null && mIpCompose.onIpMessageListItemHandler(msg.what, msgItem.mMsgId,
+                    mConversation.getThreadId(), msgItem.mSubId)) {
+                return;
+            }
+
+            if (msgItem != null
+                    && mOpComposeExt.onMessageListItemHandler(msg, msgItem.mTimestamp)) {
+                return;
+            }
+
+                switch (msg.what) {
+                    case MessageListItem.MSG_LIST_DETAILS:
+                        if (msgItem != null) {
+                            showMessageDetails(msgItem);
+                        }
+                        break;
+
+                    case MessageListItem.MSG_LIST_EDIT:
+                        if (msgItem != null && mIsSmsEnabled) {
+                            editMessageItem(msgItem);
+                            updateSendButtonState();
+                            drawBottomPanel();
+                        }
+                        break;
+
+                    case MessageListItem.MSG_LIST_PLAY:
+                        if (msgItem != null) {
+                            switch (msgItem.mAttachmentType) {
+                                case WorkingMessage.IMAGE:
+                                case WorkingMessage.VIDEO:
+                                case WorkingMessage.AUDIO:
+                                case WorkingMessage.SLIDESHOW:
+                                    MessageUtils.viewMmsMessageAttachment(
+                                            ComposeMessageActivity.this,
+                                            msgItem.mMessageUri, msgItem.mSlideshow,
+                                            getAsyncDialog());
+                                    break;
+                            }
+                        }
+                        break;
+
+                    /// M: Code analyze 039, When the cache add new item,
+                    /// notifiy ComposeMessageAcitivity the data has been changed .@{
+                    case MessageListAdapter.MSG_LIST_NEED_REFRASH: {
+                        boolean isClearCache =
+                            msg.arg1 == MessageListAdapter.MESSAGE_LIST_REFRASH_WITH_CLEAR_CACHE;
+                        MmsLog.d(MessageListAdapter.CACHE_TAG,
+                                "mMessageListItemHandler.handleMessage(): " +
+                                    "run adapter notify in isClearCache = " + isClearCache);
+                        mMsgListAdapter.setClearCacheFlag(isClearCache);
+                        mMsgListAdapter.notifyDataSetChanged();
+                        return;
+                    }
+                    /// @
+                    /// M:,Support messages multi-delete opeartor. @{
+                    case MessageListItem.ITEM_CLICK: { // can be deleted!!!
+                        mMsgListAdapter.changeSelectedState(msg.arg1);
+                        return;
+                    }
+                    /// @}
+                    default:
+                        Log.w(TAG, "Unknown message: " + msg.what);
+                        return;
+                }
+        }
+    };
+
+    private boolean showMessageDetails(MessageItem msgItem) {
+        /// M: Code analyze 040, The function getMessageDetails
+        /// use MessageItem but not cursor now.@{
+        /*
+        Cursor cursor = mMsgListAdapter.getCursorForItem(msgItem);
+        if (cursor == null) {
+            return false;
+        }
+        */
+        if (mIpCompose.showIpMessageDetails(msgItem.mIpMessageItem)) {
+            return true;
+        }
+
+        if (mOpComposeExt.showMessageDetails(String.valueOf(msgItem.mIpMessageId))) {
+            return true;
+        }
+
+        String messageDetails = MessageUtils.getMessageDetails(
+               //ComposeMessageActivity.this, cursor, msgItem.mMessageSize);
+                ComposeMessageActivity.this, msgItem);
+        /// @}
+        MmsLog.dpi(TAG, "showMessageDetails. messageDetails:" + messageDetails);
+        new AlertDialog.Builder(ComposeMessageActivity.this)
+                .setTitle(R.string.message_details_title)
+                .setMessage(messageDetails)
+                .setCancelable(true)
+                .show();
+        return true;
+    }
+
+    private final OnKeyListener mSubjectKeyListener = new OnKeyListener() {
+        @Override
+        public boolean onKey(View v, int keyCode, KeyEvent event) {
+            if (event.getAction() != KeyEvent.ACTION_DOWN) {
+                return false;
+            }
+
+            // When the subject editor is empty, press "DEL" to hide the input field.
+            if ((keyCode == KeyEvent.KEYCODE_DEL) && (mSubjectTextEditor.length() == 0)) {
+                showSubjectEditor(false);
+                mWorkingMessage.setSubject(null, true);
+                /// M: add for character counter
+                updateCounter(mWorkingMessage.getText(), 0, 0, 0);
+                return true;
+            }
+            return false;
+        }
+    };
+
+    /**
+     * Return the messageItem associated with the type ("mms" or "sms") and message id.
+     * @param type Type of the message: "mms" or "sms"
+     * @param msgId Message id of the message. This is the _id of the sms or pdu row and is
+     * stored in the MessageItem
+     * @param createFromCursorIfNotInCache true if item is not found in the MessageListAdapter's
+     * cache and the code can create a new MessageItem based on the position of the current cursor.
+     * If false, the function returns null if the MessageItem isn't in the cache.
+     * @return MessageItem or null if not found and createFromCursorIfNotInCache is false
+     */
+    private MessageItem getMessageItem(String type, long msgId,
+            boolean createFromCursorIfNotInCache) {
+        return mMsgListAdapter.getCachedMessageItem(type, msgId,
+                createFromCursorIfNotInCache ? mMsgListAdapter.getCursor() : null);
+    }
+
+    private boolean isCursorValid() {
+        // Check whether the cursor is valid or not.
+        Cursor cursor = mMsgListAdapter.getCursor();
+        if (cursor.isClosed() || cursor.isBeforeFirst() || cursor.isAfterLast()) {
+            Log.e(TAG, "Bad cursor.", new RuntimeException());
+            return false;
+        }
+        return true;
+    }
+
+    /*** M: remove Google default code
+    private void resetCounter() {
+        /// M: Code analyze 032, According to the message state to update text counter.@{
+        mTextEditor.setText(mWorkingMessage.getText());
+        /// M: once updateCounter.
+        updateCounter(mWorkingMessage.getText(), 0, 0, 0);
+        if (mWorkingMessage.requiresMms()) {
+            mTextCounter.setVisibility(View.GONE);
+        } else {
+            mTextCounter.setVisibility(View.VISIBLE);
+        }
+        /// @}
+    }
+    */
+
+    private void updateCounter(CharSequence text, int start, int before, int count) {
+        if (!mIsSmsEnabled) {
+            MmsLog.w(TAG, "updateCounter(): sms is disabled!");
+            mTextCounter.setVisibility(View.GONE);
+            return;
+        }
+        if (text == null) {
+            MmsLog.w(TAG, "updateCounter(): text is null!");
+            return;
+        }
+
+        if (mOpComposeExt.updateCounter(text, mTextCounter, mWorkingMessage)) {
+            return;
+        }
+
+        if (text.length() == 0) {
+            mTextCounter.setVisibility(View.GONE);
+            mWorkingMessage.setLengthRequiresMms(false, true);
+            return;
+        }
+
+        // add for ipmessage
+        if (mIpCompose.onIpUpdateCounter(text, start, before, count)) {
+            return;
+        }
+
+        /// M: Code analyze 031, Add encode type for calculating message lenght and always show
+        /// text counter if it is in sms mode.@{
+        /*
+        WorkingMessage workingMessage = mWorkingMessage;
+        if (workingMessage.requiresMms()) {
+            // If we're not removing text (i.e. no chance of converting back to SMS
+            // because of this change) and we're in MMS mode, just bail out since we
+            // then won't have to calculate the length unnecessarily.
+            final boolean textRemoved = (before > count);
+            if (!textRemoved) {
+                showSmsOrMmsSendButton(workingMessage.requiresMms());
+                return;
+            }
+        }
+        */
+        int[] params = null;
+
+        int encodingType = SmsMessage.ENCODING_UNKNOWN;
+
+        encodingType = mOpComposeExt.getSmsEncodingType(encodingType, ComposeMessageActivity.this);
+
+        params = SmsMessage.calculateLength(text, false, encodingType);
+            /* SmsMessage.calculateLength returns an int[4] with:
+             *   int[0] being the number of SMS's required,
+             *   int[1] the number of code units used,
+             *   int[2] is the number of code units remaining until the next message.
+             *   int[3] is the encoding type that should be used for the message.
+             */
+        final int msgCount = params[0];
+        final int remainingInCurrentMessage = params[2];
+        /*
+        if (!MmsConfig.getMultipartSmsEnabled()) {
+            mWorkingMessage.setLengthRequiresMms(
+                    msgCount >= MmsConfig.getSmsToMmsTextThreshold(), true);
+        }
+
+        // Show the counter only if:
+        // - We are not in MMS mode
+        // - We are going to send more than one message OR we are getting close
+        boolean showCounter = false;
+        if (!workingMessage.requiresMms() &&
+                (msgCount > 1 ||
+                 remainingInCurrentMessage <= CHARS_REMAINING_BEFORE_COUNTER_SHOWN)) {
+            showCounter = true;
+        }
+
+        showSmsOrMmsSendButton(workingMessage.requiresMms());
+
+        if (showCounter) {
+            // Update the remaining characters and number of messages required.
+            String counterText = msgCount > 1 ? remainingInCurrentMessage + " / " + msgCount
+                    : String.valueOf(remainingInCurrentMessage);
+            mTextCounter.setText(counterText);
+            mTextCounter.setVisibility(View.VISIBLE);
+        } else {
+            mTextCounter.setVisibility(View.GONE);
+        }
+         */
+        mWorkingMessage.setLengthRequiresMms(
+            msgCount >= MmsConfig.getSmsToMmsTextThreshold(), true);
+        MmsLog.d(TAG, "updateCounter(): message msgCount = " + msgCount
+                + " TextThreshold() = " + MmsConfig.getSmsToMmsTextThreshold()
+                + " remainingInCurrentMessage = " + remainingInCurrentMessage);
+        /// M: Show the counter
+        /// M: Update the remaining characters and number of messages required.
+        if (msgCount >= MmsConfig.getSmsToMmsTextThreshold()) {
+            mTextCounter.setVisibility(View.GONE);
+            return;
+        }
+        mUiHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                if (mOpComposeExt.updateCounterUiRun(mTextEditor, remainingInCurrentMessage,
+                        msgCount, mWorkingMessage)) {
+                    return;
+                }
+
+                MmsLog.d(TAG, "updateCounter requiresMms = " + mWorkingMessage.requiresMms()
+                        + " line count = " + mTextEditor.getLineCount());
+                if (mWorkingMessage.requiresMms() || /*mTextEditor.getLineCount() <= 1*/TextUtils.isEmpty(mTextEditor.getText().toString().trim())) {
+                    mTextCounter.setVisibility(View.GONE);
+                    return;
+                }
+                mTextCounter.setVisibility(View.VISIBLE);
+                String counterText = remainingInCurrentMessage + "/" + msgCount;
+                mTextCounter.setText(counterText);
+            }
+        }, 100);
+        /// @}
+    }
+
+    @Override
+    public void startActivityForResult(Intent intent, int requestCode) {
+        if (mNeedRequestPermissins) {
+            super.startActivityForResult(intent, requestCode);
+            return;
+        }
+
+        // requestCode >= 0 means the activity in question is a sub-activity.
+        if (requestCode >= 0) {
+            mWaitingForSubActivity = true;
+        }
+
+        /// M : FIX CR : ALPS01795853 @{
+        if (mWorkingMessage.getText().toString().trim().length() != 0) {
+            if (requestCode == REQUEST_CODE_ATTACH_IMAGE
+                    || requestCode == REQUEST_CODE_ATTACH_VIDEO
+                    || requestCode == REQUEST_CODE_ADD_CONTACT
+                    || requestCode == REQUEST_CODE_ATTACH_SOUND
+                    || requestCode == REQUEST_CODE_ATTACH_RINGTONE
+                    || requestCode == REQUEST_CODE_ATTACH_VCALENDAR
+                    || requestCode == REQUEST_CODE_ATTACH_VCARD
+                    || requestCode == REQUEST_CODE_RECORD_SOUND
+                    || requestCode == REQUEST_CODE_TAKE_PICTURE
+                    || requestCode == REQUEST_CODE_TAKE_VIDEO
+                    || requestCode == REQUEST_CODE_TEXT_VCARD) {
+                mWorkingMessage.setTruntoChooseAttach(true);
+            }
+        }
+        /// @}
+
+
+        if (mIsKeyboardOpen) {
+            hideKeyboard();  // camera and other activities take a long time to hide the keyboard
+        }
+
+        /// M: Code analyze 041, Add exception handling for starting activity.@{
+        if (null != intent && null != intent.getData()
+                && intent.getData().getScheme().equals("mailto")) {
+            try {
+                super.startActivityForResult(intent, requestCode);
+            } catch (ActivityNotFoundException e) {
+                MmsLog.e(TAG,
+                        "[ActivityNotFoundException] Failed to startActivityForResult: " + intent);
+                Intent mchooserIntent = Intent.createChooser(intent, null);
+                super.startActivityForResult(mchooserIntent, requestCode);
+            } catch (Exception e) {
+                MmsLog.e(TAG, "[Exception] Failed to startActivityForResult: " + intent);
+                Toast.makeText(this, getString(R.string.message_open_email_fail),
+                      Toast.LENGTH_SHORT).show();
+          }
+        } else {
+            try {
+                super.startActivityForResult(intent, requestCode);
+            } catch (ActivityNotFoundException e) {
+                if (requestCode == REQUEST_CODE_PICK) {
+                    misPickContatct = false;
+                    mShowingContactPicker = false;
+                }
+                Intent mchooserIntent = Intent.createChooser(intent, null);
+                super.startActivityForResult(mchooserIntent, requestCode);
+            }
+        }
+        /// @}
+    }
+
+    private void toastConvertInfo(boolean toMms) {
+        if (mIpCompose.toastIpConvertInfo(toMms)) {
+            return;
+        }
+        final int resId = toMms ? R.string.converting_to_picture_message
+                : R.string.converting_to_text_message;
+        Toast.makeText(this, resId, Toast.LENGTH_SHORT).show();
+    }
+
+    private class DeleteMessageListener implements OnClickListener {
+        private final MessageItem mMessageItem;
+
+        public DeleteMessageListener(MessageItem messageItem) {
+            mMessageItem = messageItem;
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int whichButton) {
+            dialog.dismiss();
+
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    if (mMessageItem.isMms()) {
+                        WorkingMessage.removeThumbnailsFromCache(mMessageItem.getSlideshow());
+
+                        MmsApp.getApplication().getPduLoaderManager()
+                            .removePdu(mMessageItem.mMessageUri);
+                        // Delete the message *after* we've removed the thumbnails because we
+                        // need the pdu and slideshow for removeThumbnailsFromCache to work.
+                    }
+                    // add for ipmessage
+                    mIpCompose.onIpDeleteMessageListenerClick(mMessageItem.mIpMessageItem);
+
+                    /// M: google jb.mr1 patch, Conversation should scroll to the bottom
+                    /// when incoming received @{
+                    Boolean deletingLastItem = false;
+                    Cursor cursor = mMsgListAdapter != null ? mMsgListAdapter.getCursor() : null;
+                    if (cursor != null) {
+                        cursor.moveToLast();
+                        long msgId = cursor.getLong(COLUMN_ID);
+                        deletingLastItem = msgId == mMessageItem.mMsgId;
+                    }
+                    Uri deleteUri = mMessageItem.mMessageUri;
+                    MmsLog.dpi(TAG, "deleteUri " + deleteUri
+                            + " deleteUri.host " + deleteUri.getHost());
+
+                    if (mOpComposeExt.onDeleteMessageListenerClick(mBackgroundQueryHandler,
+                            mMessageItem.mMsgId, mMessageItem.mIpMessageId)) {
+                        return;
+                    }
+
+                    mBackgroundQueryHandler.startDelete(DELETE_MESSAGE_TOKEN,
+                            deletingLastItem, mMessageItem.mMessageUri,
+                            mMessageItem.mLocked ? null : "locked=0", null);
+                    /// @}
+                    return;
+                }
+            }).start();
+        }
+    }
+
+    private class DiscardDraftListener implements OnClickListener {
+        @Override
+        public void onClick(DialogInterface dialog, int whichButton) {
+            mWorkingMessage.discard();
+            dialog.dismiss();
+            mOpComposeExt.onDiscardDraftListenerClick();
+            /// M: Code analyze 042, If you discard the draft message manually.@{
+            mHasDiscardWorkingMessage = true;
+            /// @}
+            // add for ipmessage
+            mIpCompose.onIpDiscardDraftListenerClick();
+            finish();
+            mDiscardDraftDialog = null;
+        }
+    }
+
+    private class SendIgnoreInvalidRecipientListener implements OnClickListener {
+        @Override
+        public void onClick(DialogInterface dialog, int whichButton) {
+            /// M: Code analyze 030, Check condition before sending message.@{
+            checkConditionsAndSendMessage(true);
+            /// @}
+            dialog.dismiss();
+        }
+    }
+
+    private class CancelSendingListener implements OnClickListener {
+        @Override
+        public void onClick(DialogInterface dialog, int whichButton) {
+            if (isRecipientsEditorVisible()) {
+                mRecipientsEditor.requestFocus();
+            }
+            dialog.dismiss();
+            /// M: @{
+            updateSendButtonState();
+            /// @}
+        }
+    }
+
+    /// M: fix bug ALPS00484778
+    private ContactList mCutRecipients;
+
+    private class CancelSendingListenerForInvalidRecipient implements OnClickListener {
+        @Override
+        public void onClick(DialogInterface dialog, int whichButton) {
+            if (isRecipientsEditorVisible()) {
+                if (mCutRecipients != null) {
+                        mRecipientsEditor.removeChipChangedListener(mChipWatcher);
+                        mRecipientsEditor.populate(new ContactList());
+                        mRecipientsEditor.addChipChangedListener(mChipWatcher);
+                        mRecipientsEditor.populate(mCutRecipients);
+                        mCutRecipients = null;
+                } else {
+                    mRecipientsEditor.requestFocus();
+                }
+            }
+            dialog.dismiss();
+            /// M: @{
+            updateSendButtonState();
+            /// @}
+        }
+    }
+    /// @}
+
+    private void setSubId(int subId) {
+        if (subId != 0) {
+            mSelectedSubId = subId;
+        }
+    }
+
+    private boolean isOmhSizeLimitDialog() {
+        TelephonyManagerEx telephonyManagerEx;
+        MmsConfigInfo mmsConfigInfo = null;
+        boolean isOmhEnable = false;
+        boolean isOmhCard = false;
+        int omhMessageMaxSize = 0;
+        try {
+            telephonyManagerEx = TelephonyManagerEx.getDefault();
+            mmsConfigInfo = telephonyManagerEx.getMmsConfigInfo(mSelectedSubId);
+            isOmhEnable = telephonyManagerEx.isOmhEnable(mSelectedSubId);
+            isOmhCard = telephonyManagerEx.isOmhCard(mSelectedSubId);
+            MmsLog.d(TAG_OMH, "ComposeMessageActivity.isOmhSizeLimitDialog:isOmhEnable="
+                    + isOmhEnable + " isOmhCard=" + isOmhCard);
+            if (mmsConfigInfo != null) {
+                omhMessageMaxSize = mmsConfigInfo.mMessageMaxSize;
+                MmsLog.d(TAG_OMH, "ComposeMessageActivity.isOmhSizeLimitDialog:"
+                        + " mmsConfigInfo != null"
+                        + " mmsConfigInfo.mMessageMaxSize =" + omhMessageMaxSize);
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+        }
+        if (isOmhEnable && isOmhCard && mmsConfigInfo != null && omhMessageMaxSize != 0) {
+            int mmsSizeLimit = omhMessageMaxSize;
+            mmsSizeLimit = mmsSizeLimit / 1024;
+            SlideshowModel slideShow = mWorkingMessage.getSlideshow();
+            if (slideShow != null) {
+                int showSize = (slideShow.getCurrentSlideshowSize() - 1) / 1024 + 1;
+                if (mmsSizeLimit < showSize) {
+                    MmsLog.d(TAG_OMH, "ComposeMessageActivity.isOmhSizeLimitDialog:"
+                            + "mmsSizeLimit < showSize start"
+                            + " mSelectedSubId=" + mSelectedSubId);
+                    String info = "(" + showSize + "K/" + mmsSizeLimit + "K)";
+                    String titleView = getString(R.string.omh_exceed_message_size_limitation);
+                    titleView = titleView + info;
+                    String messageView = getString(R.string.omh_failed_to_add_image);
+                    AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                    /// M: replace error icon.
+                    builder.setIcon(R.drawable.size_limited);
+                    builder.setTitle(titleView);
+                    builder.setMessage(messageView);
+                    builder.setPositiveButton(android.R.string.ok, new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            if (which == DialogInterface.BUTTON_POSITIVE) {
+                                dialog.dismiss();
+                            }
+                        }
+                    });
+                    builder.create().show();
+                    mSendButtonCanResponse = true;
+                    updateSendButtonState(true);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void confirmSendMessageIfNeeded() {
+        if (isOmhSizeLimitDialog()) {
+            return;
+        }
+        if (!isRecipientsEditorVisible()) {
+            /// M: Code analyze 030, Check condition before sending message.@{
+            checkConditionsAndSendMessage(true);
+            /// @}
+            return;
+        }
+
+        boolean isMms = mWorkingMessage.requiresMms();
+        if (mOpComposeExt.confirmSendMessageIfNeeded(isRecipientsEditorVisible(),
+                mRecipientsEditor.hasInvalidRecipient(isMms))) {
+            return;
+        }
+
+        if (mRecipientsEditor.hasInvalidRecipient(isMms)) {
+            /// M: Code analyze 054, Even if there are some invalid recipients , we also try to
+            /// send messag.Now, We do not disgingush there are some or all invalid recipients. @{
+            updateSendButtonState();
+                String title = getResourcesString(R.string.has_invalid_recipient,
+                        mRecipientsEditor.formatInvalidNumbers(isMms));
+                new AlertDialog.Builder(this)
+                    .setCancelable(false)
+                    .setIconAttribute(android.R.attr.alertDialogIcon)
+                    .setTitle(title)
+                    .setMessage(R.string.invalid_recipient_message)
+                    .setPositiveButton(R.string.try_to_send,
+                            new SendIgnoreInvalidRecipientListener())
+                    .setNegativeButton(R.string.no, new CancelSendingListenerForInvalidRecipient())
+                    .setOnKeyListener(new DialogInterface.OnKeyListener() {
+                        @Override
+                        public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
+                            if (keyCode == KeyEvent.KEYCODE_BACK) {
+                                dialog.dismiss();
+                            }
+                            return false;
+                        }
+                    })
+                    .show();
+        } else {
+             /// M: Code analyze 030, Check condition before
+            /// sending message.(All recipients are valid.)@{
+            checkConditionsAndSendMessage(true);
+             /// @}
+        }
+    }
+
+    /// M: Recipient Control refactory, don't use TextWatcher: replace with ChipWatcher,
+    /// to reduce the frequency of notify. and to sync recipients. @{
+    private final MTKRecipientEditTextView.ChipWatcher mChipWatcher =
+        new MTKRecipientEditTextView.ChipWatcher() {
+        public void onChipChanged(ArrayList<RecipientEntry> allChips,
+                ArrayList<String> changedChipAddresses, String lastString) {
+            /// M: ALPS01843842, when chip changed ,close the contact view context menu.
+            if (mChipViewMenu != null) {
+                mChipViewMenu.close();
+                mChipViewMenu = null;
+            }
+            if (!isRecipientsEditorVisible()) {
+                Log.w(TAG, "ChipWatcher: onChipChanged called with invisible mRecipientsEditor");
+                return;
+            }
+
+            Log.i(TAG, "ChipWatcher onChipChanged begin.");
+            ContactList LastContacts = mRecipientsEditor.getContactsFromChipWatcher();
+            int updateLimit = getLimitedContact();
+            /// @}
+            mRecipientsEditor.parseRecipientsFromChipWatcher(allChips,
+                    changedChipAddresses, lastString, updateLimit);
+            List<String> numbers = mRecipientsEditor.getNumbersFromChipWatcher();
+            // google steps in textchange
+            mWorkingMessage.setWorkingRecipients(numbers);
+            /// M: google JB.MR1 patch, group mms
+            boolean multiRecipients = numbers != null && numbers.size() > 1;
+            boolean isGroupMms =
+                MmsPreferenceActivity.getIsGroupMmsEnabled(ComposeMessageActivity.this)
+                                                        && multiRecipients;
+            mMsgListAdapter.setIsGroupConversation(isGroupMms);
+            mWorkingMessage.setHasMultipleRecipients(multiRecipients, true);
+            mWorkingMessage.setHasEmail(mRecipientsEditor.containsEmailFromChipWatcher(), true);
+            int recipientCount = (numbers != null ? numbers.size() : 0);
+            checkForTooManyRecipients(recipientCount);
+            // google steps end
+            ContactList contacts = mRecipientsEditor.getContactsFromChipWatcher();
+            if (!contacts.equals(LastContacts)
+                    || (changedChipAddresses != null && changedChipAddresses.size() > 0)) {
+                updateTitle(contacts);
+            }
+            updateSendButtonState();
+            mIpCompose.onIpRecipientsChipChanged(contacts.size());
+        }
+    };
+    /// @}
+
+    private void checkForTooManyRecipients(int recipientCount) {
+        /// M: Code analyze 056,Now,the sms recipient limit is different from mms.
+        /// We can set limit for sms or mms individually. @{
+        final int recipientLimit = MmsConfig.getSmsRecipientLimit();
+        /// @}
+        if (recipientLimit != Integer.MAX_VALUE && recipientLimit > 0) {
+
+            //final int recipientCount = recipientCount();
+            boolean tooMany = recipientCount > recipientLimit;
+
+            if (recipientCount != mLastRecipientCount) {
+                // Don't warn the user on every character they type when they're over the limit,
+                // only when the actual # of recipients changes.
+                mLastRecipientCount = recipientCount;
+                if (tooMany) {
+                    String tooManyMsg = getString(R.string.too_many_recipients, recipientCount,
+                            recipientLimit);
+                    Toast.makeText(ComposeMessageActivity.this,
+                            tooManyMsg, Toast.LENGTH_LONG).show();
+                }
+            }
+        }
+    }
+
+    private final OnCreateContextMenuListener mRecipientsMenuCreateListener =
+        new OnCreateContextMenuListener() {
+        @Override
+        public void onCreateContextMenu(ContextMenu menu, View v,
+                ContextMenuInfo menuInfo) {
+            mChipViewMenu = menu;
+            mOpComposeExt.chipOnCreateContextMenu(mChipViewMenu);
+            if (menuInfo != null) {
+                Contact c = ((RecipientContextMenuInfo) menuInfo).recipient;
+                RecipientsMenuClickListener l = new RecipientsMenuClickListener(c);
+
+                menu.setHeaderTitle(c.getName());
+
+                if (c.existsInDatabase()) {
+                    menu.add(0, MENU_VIEW_CONTACT, 0, R.string.menu_view_contact)
+                            .setOnMenuItemClickListener(l);
+                /// M: Code analyze 043, Whether the address can be added to contacts app. @{
+                } else if (MessageUtils.canAddToContacts(c)) {
+                /// @}
+                    menu.add(0, MENU_ADD_TO_CONTACTS, 0, R.string.menu_add_to_contacts)
+                            .setOnMenuItemClickListener(l);
+                }
+            }
+        }
+    };
+
+    private final class RecipientsMenuClickListener implements MenuItem.OnMenuItemClickListener {
+        private final Contact mRecipient;
+
+        RecipientsMenuClickListener(Contact recipient) {
+            mRecipient = recipient;
+        }
+
+        @Override
+        public boolean onMenuItemClick(MenuItem item) {
+            switch (item.getItemId()) {
+                // Context menu handlers for the recipients editor.
+                case MENU_VIEW_CONTACT: {
+                    Uri contactUri = mRecipient.getUri();
+                    /// M: fix bug ALPS00448677, update or delete Contact Chip
+                    mInViewContact = mRecipient;
+                    /// @}
+                    Intent intent = new Intent(Intent.ACTION_VIEW, contactUri);
+                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                    startActivityForResult(intent, REQUEST_CODE_VIEW_CONTACT);
+                    return true;
+                }
+                case MENU_ADD_TO_CONTACTS: {
+                    /// M: fix bug ALPS00448677, update or delete Contact Chip
+                    mInViewContact = null;
+                    /// @}
+                    mAddContactIntent = ConversationList.createAddContactIntent(
+                            mRecipient.getNumber());
+                    ComposeMessageActivity.this.startActivityForResult(mAddContactIntent,
+                            REQUEST_CODE_ADD_CONTACT);
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    private boolean canAddToContacts(Contact contact) {
+        // There are some kind of automated messages, like STK messages, that we don't want
+        // to add to contacts. These names begin with special characters, like, "*Info".
+        final String name = contact.getName();
+        if (!TextUtils.isEmpty(contact.getNumber())) {
+            char c = contact.getNumber().charAt(0);
+            if (isSpecialChar(c)) {
+                return false;
+            }
+        }
+        if (!TextUtils.isEmpty(name)) {
+            char c = name.charAt(0);
+            if (isSpecialChar(c)) {
+                return false;
+            }
+        }
+        if (!(Mms.isEmailAddress(name) ||
+                Telephony.Mms.isPhoneNumber(name) ||
+                contact.isMe())) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean isSpecialChar(char c) {
+        return c == '*' || c == '%' || c == '$';
+    }
+
+    private void addPositionBasedMenuItems(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
+        AdapterView.AdapterContextMenuInfo info;
+
+        try {
+            info = (AdapterView.AdapterContextMenuInfo) menuInfo;
+        } catch (ClassCastException e) {
+            Log.e(TAG, "bad menuInfo");
+            return;
+        }
+        final int position = info.position;
+
+        addUriSpecificMenuItems(menu, v, position);
+    }
+
+    private Uri getSelectedUriFromMessageList(ListView listView, int position) {
+        // If the context menu was opened over a uri, get that uri.
+        MessageListItem msglistItem = (MessageListItem) listView.getChildAt(position);
+        if (msglistItem == null) {
+            // FIXME: Should get the correct view. No such interface in ListView currently
+            // to get the view by position. The ListView.getChildAt(position) cannot
+            // get correct view since the list doesn't create one child for each item.
+            // And if setSelection(position) then getSelectedView(),
+            // cannot get corrent view when in touch mode.
+            return null;
+        }
+
+        TextView textView;
+        CharSequence text = null;
+        int selStart = -1;
+        int selEnd = -1;
+
+        //check if message sender is selected
+        textView = (TextView) msglistItem.findView(MessageListItem.text_view);
+        if (textView != null) {
+            text = textView.getText();
+            selStart = textView.getSelectionStart();
+            selEnd = textView.getSelectionEnd();
+        }
+
+        /// M: Code analyze 044,If sender is not being selected, it may be in the message body.@{
+        if (selStart == -1) {
+            textView = (TextView) msglistItem.findView(MessageListItem.text_view);
+            if (textView != null) {
+                text = textView.getText();
+                selStart = textView.getSelectionStart();
+                selEnd = textView.getSelectionEnd();
+            }
+        }
+        /// @}
+
+        // Check that some text is actually selected, rather than the cursor
+        // just being placed within the TextView.
+        if (selStart != selEnd) {
+            int min = Math.min(selStart, selEnd);
+            int max = Math.max(selStart, selEnd);
+
+            URLSpan[] urls = ((Spanned) text).getSpans(min, max,
+                                                        URLSpan.class);
+
+            if (urls.length == 1) {
+                return Uri.parse(urls[0].getURL());
+            }
+        }
+
+        //no uri was selected
+        return null;
+    }
+
+    private void addUriSpecificMenuItems(ContextMenu menu, View v, int position) {
+        Uri uri = getSelectedUriFromMessageList((ListView) v, position);
+
+        if (uri != null) {
+            Intent intent = new Intent(null, uri);
+            intent.addCategory(Intent.CATEGORY_SELECTED_ALTERNATIVE);
+            menu.addIntentOptions(0, 0, 0,
+                    new android.content.ComponentName(this, ComposeMessageActivity.class),
+                    null, intent, 0, null);
+        }
+    }
+
+    private final void addCallAndContactMenuItems(
+            ContextMenu menu, MsgListMenuClickListener l, MessageItem msgItem) {
+        if (TextUtils.isEmpty(msgItem.mBody)) {
+            return;
+        }
+        SpannableString msg = new SpannableString(msgItem.mBody);
+        Linkify.addLinks(msg, Linkify.ALL);
+        ArrayList<String> uris =
+            MessageUtils.extractUris(msg.getSpans(0, msg.length(), URLSpan.class));
+        /// M: Code analyze 022, Add bookmark. Clear the List.@{
+        mURLs.clear();
+        /// @}
+        // Remove any dupes so they don't get added to the menu multiple times
+        HashSet<String> collapsedUris = new HashSet<String>();
+        for (String uri : uris) {
+            collapsedUris.add(uri.toLowerCase());
+        }
+        for (String uriString : collapsedUris) {
+            String prefix = null;
+            int sep = uriString.indexOf(":");
+            if (sep >= 0) {
+                prefix = uriString.substring(0, sep);
+                /// M: Code analyze 022, Add bookmark. @{
+                if ("mailto".equalsIgnoreCase(prefix) || "tel".equalsIgnoreCase(prefix)) {
+                    uriString = uriString.substring(sep + 1);
+                }
+                /// @}
+            }
+            Uri contactUri = null;
+            boolean knownPrefix = true;
+            if ("mailto".equalsIgnoreCase(prefix))  {
+                contactUri = getContactUriForEmail(uriString);
+            } else if ("tel".equalsIgnoreCase(prefix)) {
+                contactUri = getContactUriForPhoneNumber(uriString);
+            } else {
+                knownPrefix = false;
+
+                /// M: Code analyze 022, Add bookmark. Maybe exist multi URL address @{
+                if (msgItem.isSms() && mURLs.size() <= 0) {
+                    //menu.add(0, MENU_ADD_TO_BOOKMARK, 0, R.string.menu_add_to_bookmark)
+                    //.setOnMenuItemClickListener(l);
+                }
+                /// @}
+
+                /// M: Code analyze 022, Add bookmark. fix bug ALPS00783237 @{
+                for (String uri : uris) {
+                    if (uri != null && uri.equalsIgnoreCase(uriString)) {
+                        mURLs.add(uri);
+                        break;
+                    }
+                }
+                /// @}
+            }
+            if (knownPrefix && contactUri == null) {
+                Intent intent = ConversationList.createAddContactIntent(uriString);
+
+                String addContactString = getString(R.string.menu_add_address_to_contacts,
+                        uriString);
+                menu.add(0, MENU_ADD_ADDRESS_TO_CONTACTS, 0, addContactString)
+                    .setOnMenuItemClickListener(l)
+                    .setIntent(intent);
+            }
+        }
+        /// M: New plugin API @{
+        mOpComposeExt.addCallAndContactMenuItems(
+                this, menu, MENU_ADD_TO_BOOKMARK, mURLs, msgItem);
+        /// @}
+    }
+
+    private Uri getContactUriForEmail(String emailAddress) {
+        Cursor cursor = SqliteWrapper.query(this, getContentResolver(),
+                Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(emailAddress)),
+                new String[] { Email.CONTACT_ID, Contacts.DISPLAY_NAME }, null, null, null);
+
+        if (cursor != null) {
+            try {
+                while (cursor.moveToNext()) {
+                    String name = cursor.getString(1);
+                    if (!TextUtils.isEmpty(name)) {
+                        return ContentUris.withAppendedId(Contacts.CONTENT_URI, cursor.getLong(0));
+                    }
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+
+    private Uri getContactUriForPhoneNumber(String phoneNumber) {
+        Contact contact = Contact.get(phoneNumber, true);
+        if (contact.existsInDatabase()) {
+            return contact.getUri();
+        }
+        return null;
+    }
+
+    private final OnCreateContextMenuListener mMsgListMenuCreateListener =
+        new OnCreateContextMenuListener() {
+        @Override
+        public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
+            if (!isCursorValid()) {
+                return;
+            }
+            Cursor cursor = mMsgListAdapter.getCursor();
+            String type = cursor.getString(COLUMN_MSG_TYPE);
+            long msgId = cursor.getLong(COLUMN_ID);
+            ///M: ALPS00726802, save the position in cursor of the clicked item
+            mClickedItemPosition = cursor.getPosition();
+
+            MmsLog.i(TAG, "onCreateContextMenu(): msgId=" + msgId);
+            addPositionBasedMenuItems(menu, v, menuInfo);
+
+            MessageItem msgItem = mMsgListAdapter.getCachedMessageItem(type, msgId, cursor);
+            if (msgItem == null) {
+                Log.w(TAG, "Cannot load message item for type = " + type
+                        + ", msgId = " + msgId);
+                return;
+            }
+
+            menu.setHeaderTitle(R.string.message_options);
+
+            MsgListMenuClickListener l = new MsgListMenuClickListener(msgItem);
+
+            // add for ipmessage
+            boolean isForwardEnabled =
+                msgItem.isSms() || (msgItem.isDownloaded() && isForwardable(msgId));
+
+            if (msgItem.isSms()) {
+                menu.add(0, MENU_COPY, 0, R.string.ipmsg_copy)
+                .setOnMenuItemClickListener(l);
+            }
+
+            // Forward is not available for undownloaded messages.
+            if (mIsSmsEnabled) {
+                if (isForwardEnabled) {
+                    menu.add(0, MENU_FORWARD_MESSAGE, 0,
+                            R.string.menu_forward).setOnMenuItemClickListener(l);
+                }
+            }
+            if (mIsSmsEnabled) {
+                menu.add(0, MENU_DELETE_MESSAGE, 0, R.string.delete_message)
+                        .setOnMenuItemClickListener(l);
+            }
+
+            if (mIsSmsEnabled) {
+                if (msgItem.mLocked) {
+                    menu.add(0, MENU_UNLOCK_MESSAGE, 0, R.string.menu_unlock)
+                            .setOnMenuItemClickListener(l);
+                } else if (mIsSmsEnabled) {
+                    menu.add(0, MENU_LOCK_MESSAGE, 0, R.string.menu_lock)
+                            .setOnMenuItemClickListener(l);
+                }
+            }
+
+            if (msgItem.isMms()) {
+                switch (msgItem.mAttachmentType) {
+                    case WorkingMessage.SLIDESHOW:
+                        menu.add(0, MENU_VIEW_SLIDESHOW, 0, R.string.view_slideshow)
+                                .setOnMenuItemClickListener(l);
+                        if (haveSomethingToCopyToSDCard(msgItem.mMsgId)) {
+                            menu.add(0, MENU_COPY_TO_SDCARD, 0, R.string.copy_to_sdcard)
+                                    .setOnMenuItemClickListener(l);
+                        }
+                        break;
+                    default:
+                        if (haveSomethingToCopyToSDCard(msgItem.mMsgId)) {
+                            menu.add(0, MENU_COPY_TO_SDCARD, 0, R.string.copy_to_sdcard)
+                                    .setOnMenuItemClickListener(l);
+                        }
+                        break;
+                }
+            }
+
+            addCallAndContactMenuItems(menu, l, msgItem);
+
+            menu.add(0, MENU_VIEW_MESSAGE_DETAILS, 0, R.string.view_message_details)
+                .setOnMenuItemClickListener(l);
+
+            if (msgItem.mDeliveryStatus != MessageItem.DeliveryStatus.NONE
+                    || msgItem.mReadReport) {
+                menu.add(0, MENU_DELIVERY_REPORT, 0, R.string.view_delivery_report)
+                        .setOnMenuItemClickListener(l);
+            }
+
+            /// M: Code analyze 016, Add for select text copy. @{
+            if (!TextUtils.isEmpty(msgItem.mBody)
+                    && msgItem.mMessageType != PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND) {
+                menu.add(0, MENU_SELECT_TEXT, 0, R.string.select_text)
+                        .setOnMenuItemClickListener(l);
+            }
+            /// @}
+
+            if (!mOpComposeExt.onCreateContextMenu(mIsSmsEnabled, msgItem.isSms(),
+                    mSubCount, msgItem.isSending(), l, menu, v, menuInfo, msgItem.mIpMessageId,
+                    mConversation.getMessageCount())) {
+                if (mIsSmsEnabled) {
+                    if (msgItem.isSms()) {
+                        if (mSubCount > 0 && !msgItem.isSending()) {
+                            menu.add(0, MENU_SAVE_MESSAGE_TO_SUB, 0, R.string.save_message_to_sim)
+                                    .setOnMenuItemClickListener(l);
+                        }
+                    }
+                }
+            }
+
+            mIpCompose.onIpCreateContextMenu(menu, mIsSmsEnabled, isForwardEnabled,
+                    msgItem.mIpMessageItem);
+        }
+    };
+
+    private void editMessageItem(MessageItem msgItem) {
+        if ("sms".equals(msgItem.mType)) {
+            if (mWorkingMessage.hasSlideshow()) {
+                /// M: it's a real slideshow, ignore edit request, show a toast.
+                String message = getString(R.string.failed_to_add_media,
+                        getString(R.string.viewer_title_sms));
+                Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
+                return;
+            } else {
+                editSmsMessageItem(msgItem);
+            }
+        } else {
+            editMmsMessageItem(msgItem);
+            mWorkingMessage.setHasMmsDraft(true);
+        }
+        MessagingNotification.nonBlockingUpdateSendFailedNotification(ComposeMessageActivity.this);
+        /// M: @{
+        if ((msgItem.isFailedMessage() || msgItem.isSending()
+                || (msgItem.mDeliveryStatus == MessageItem.DeliveryStatus.FAILED))
+                && mMsgListAdapter.getCount() <= 1) {
+            // For messages with bad addresses, let the user re-edit the recipients.
+            initRecipientsEditor(null);
+            /// M: Code analyze 046, Whether the recipientedit control has been initialized. @{
+            isInitRecipientsEditor = true;
+            /// @}
+            mMsgListAdapter.changeCursor(null);
+            invalidateOptionsMenu();
+        }
+    }
+
+    private void editSmsMessageItem(MessageItem msgItem) {
+        // When the message being edited is the only message in the conversation, the delete
+        // below does something subtle. The trigger "delete_obsolete_threads_pdu" sees that a
+        // thread contain no messages and silently deletes the thread. Meanwhile, the mConversation
+        // object still holds onto the old thread_id and code thinks there's a backing thread in
+        // the DB when it really has been deleted. Here we try and notice that situation and
+        // clear out the thread_id. Later on, when Conversation.ensureThreadId() is called, we'll
+        // create a new thread if necessary.
+        synchronized (mConversation) {
+            /// M: @{
+            //if (mConversation.getMessageCount() <= 1) {
+            if (mMsgListAdapter.getCursor().getCount() <= 1) {
+            /// @}
+                mConversation.clearThreadId();
+                MessagingNotification.setCurrentlyDisplayedThreadId(
+                    MessagingNotification.THREAD_NONE);
+            }
+        }
+        // Delete the old undelivered SMS and load its content.
+        Uri uri = ContentUris.withAppendedId(Sms.CONTENT_URI, msgItem.mMsgId);
+        SqliteWrapper.delete(ComposeMessageActivity.this,
+                mContentResolver, uri, null, null);
+
+        mWorkingMessage.setConversation(mConversation);
+        mWorkingMessage.setText(msgItem.mBody);
+    }
+
+    private void editMmsMessageItem(MessageItem msgItem) {
+        /// M: fix bug ALPS00834025. ignore a click if too close.
+        long oldTime = mEditClickTime;
+        mEditClickTime = SystemClock.elapsedRealtime();
+        if ((mEditClickTime - oldTime < 1500) && (mEditClickTime - oldTime > 0)) {
+            MmsLog.w(TAG, "editMmsMessageItem, ignore a click if too close");
+            return;
+        }
+
+        /// M: make a failed message editable, the count should reduce too.
+        if (mConversation.getMessageCount() == 1) {
+            mConversation.setMessageCount(0);
+        }
+        /// M: Discard the current message in progress.
+        mWorkingMessage.discard();
+
+        // Load the selected message in as the working message.
+        WorkingMessage newWorkingMessage = WorkingMessage.load(this, msgItem.mMessageUri);
+        if (newWorkingMessage == null) {
+            MmsLog.w(TAG, "editMmsMessageItem, load returns null message");
+            return;
+        }
+        mWorkingMessage = newWorkingMessage;
+        mWorkingMessage.setConversation(mConversation);
+        invalidateOptionsMenu();
+        /// M: @{
+        mAttachmentEditor.update(mWorkingMessage);
+        updateTextEditorHeightInFullScreen();
+        /// @}
+        drawTopPanel(false);
+
+        // WorkingMessage.load() above only loads the slideshow. Set the
+        // subject here because we already know what it is and avoid doing
+        // another DB lookup in load() just to get it.
+        mWorkingMessage.setSubject(msgItem.mSubject, false);
+
+        if (mWorkingMessage.hasSubject()) {
+            showSubjectEditor(true);
+        }
+
+        mOpComposeExt.editMmsMessageItem(mWorkingMessage.mOpWorkingMessageExt);
+
+        /// M: fix bug ALPS00433858, update read==1(readed) when reload failed-mms
+        final MessageItem item = msgItem;
+        new Thread(new Runnable() {
+            public void run() {
+                // TODO Auto-generated method stub
+                Uri uri = ContentUris.withAppendedId(Mms.CONTENT_URI, item.mMsgId);
+                ContentValues values = new ContentValues(1);
+                values.put(Mms.READ, 1);
+                SqliteWrapper.update(ComposeMessageActivity.this,
+                        mContentResolver, uri, values, null, null);
+            }
+        }).start();
+    }
+
+    private void copyToClipboard(String str) {
+        ClipboardManager clipboard =
+            (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+        clipboard.setPrimaryClip(ClipData.newPlainText(null, str));
+    }
+
+    private void forwardMessage(final MessageItem msgItem) {
+        /// M: Code analyze 051, Hide input keyboard
+        /// (add for input method covered Compose UI issue).@{
+        hideInputMethod();
+        /// @}
+
+        mTempThreadId = 0;
+        // The user wants to forward the message. If the message is an mms message, we need to
+        // persist the pdu to disk. This is done in a background task.
+        // If the task takes longer than a half second, a progress dialog is displayed.
+        // Once the PDU persisting is done, another runnable on the UI thread get executed to start
+        // the ForwardMessageActivity.
+        getAsyncDialog().runAsync(new Runnable() {
+            @Override
+            public void run() {
+                // This runnable gets run in a background thread.
+                if (msgItem.mType.equals("mms")) {
+                    SendReq sendReq = new SendReq();
+                    String subject = getString(R.string.forward_prefix);
+                    if (msgItem.mSubject != null) {
+                        subject += msgItem.mSubject;
+                    }
+                    sendReq.setSubject(new EncodedStringValue(subject));
+                    sendReq.setBody(msgItem.mSlideshow.makeCopy());
+
+                    mTempMmsUri = null;
+                    try {
+                        PduPersister persister =
+                                PduPersister.getPduPersister(ComposeMessageActivity.this);
+                        // Copy the parts of the message here.
+                        /// M: google jb.mr1 patch, group mms
+                        mTempMmsUri = persister.persist(sendReq, Mms.Draft.CONTENT_URI, true,
+                                MmsPreferenceActivity
+                                    .getIsGroupMmsEnabled(ComposeMessageActivity.this), null);
+                        mTempThreadId = MessagingNotification.getThreadId(
+                                ComposeMessageActivity.this, mTempMmsUri);
+                    } catch (MmsException e) {
+                        Log.e(TAG, "Failed to copy message: " + msgItem.mMessageUri);
+                        runOnUiThread(new Runnable() {
+                            public void run() {
+                                Toast.makeText(ComposeMessageActivity.this,
+                                        R.string.cannot_save_message, Toast.LENGTH_SHORT).show();
+                            }
+                        });
+                        return;
+                    }
+                }
+            }
+        }, new Runnable() {
+            @Override
+            public void run() {
+                // Once the above background thread is complete, this runnable is run
+                // on the UI thread.
+                Intent intent = createIntent(ComposeMessageActivity.this, 0);
+                intent.putExtra(KEY_FORWARDED_MESSAGE, true);
+                if (mTempThreadId > 0) {
+                    intent.putExtra("thread_id", mTempThreadId);
+                }
+
+                if (msgItem.mType.equals("sms")) {
+                    intent.putExtra("sms_body", msgItem.mBody);
+                } else {
+                    intent.putExtra("msg_uri", mTempMmsUri);
+                    String subject = getString(R.string.forward_prefix);
+                    if (msgItem.mSubject != null) {
+                        subject += msgItem.mSubject;
+                    }
+                    intent.putExtra("subject", subject);
+                }
+
+                Contact contact = Contact.get(msgItem.mAddress, false);
+                String nameAndNumber = Contact.formatNameAndNumber(
+                        contact.getName(), contact.getNumber(), "");
+                if (!mOpComposeExt.forwardMessage(
+                        ComposeMessageActivity.this, msgItem, nameAndNumber, intent)) {
+                    intent.putExtra(KEY_EXIT_ON_SENT, true);
+                }
+
+                // ForwardMessageActivity is simply an alias in the manifest for
+                // ComposeMessageActivity. We have to make an alias because ComposeMessageActivity
+                // launch flags specify singleTop. When we forward a message, we want to start a
+                // separate ComposeMessageActivity. The only way to do that is to override the
+                // singleTop flag, which is impossible to do in code. By creating an alias to the
+                // activity, without the singleTop flag, we can launch a separate
+                // ComposeMessageActivity to edit the forward message.
+                intent.setClassName(ComposeMessageActivity.this,
+                        "com.android.mms.ui.ForwardMessageActivity");
+                startActivity(intent);
+            }
+        }, R.string.sync_mms_to_db);
+    }
+
+    /**
+     * Context menu handlers for the message list view.
+     */
+    private final class MsgListMenuClickListener implements MenuItem.OnMenuItemClickListener {
+        private MessageItem mMsgItem;
+
+        public MsgListMenuClickListener(MessageItem msgItem) {
+            mMsgItem = msgItem;
+        }
+
+        @Override
+        public boolean onMenuItemClick(MenuItem item) {
+            if (mMsgItem == null) {
+                return false;
+            }
+            if (mIpCompose.onIpMenuItemClick(item, mMsgItem.mIpMessageItem)) {
+                return true;
+            }
+
+            Intent deliveryIntent = new Intent(
+                    ComposeMessageActivity.this, DeliveryReportActivity.class);
+            Intent intentMultiSave = new Intent(
+                    ComposeMessageActivity.this, MultiSaveActivity.class);
+            if (mOpComposeExt.onMenuItemClick(
+                    item, mMsgItem.mOpMessageItemExt, intentMultiSave, deliveryIntent)) {
+                return true;
+            }
+
+            switch (item.getItemId()) {
+                case MENU_EDIT_MESSAGE:
+                    editMessageItem(mMsgItem);
+                    drawBottomPanel();
+                    return true;
+                case MENU_COPY:
+                case MENU_COPY_MESSAGE_TEXT:
+                    /// M: keep original string when copy, if delete '\r', search will failed. @{
+                    if (mMsgItem.mBody != null) {
+                        copyToClipboard(mMsgItem.mBody);
+                    } else {
+                        MmsLog.w(TAG, "onMenuItemClick, mMsgItem.mBody == null");
+                        return false;
+                    }
+                    /// @}
+                    return true;
+
+                case MENU_FORWARD_MESSAGE:
+                    /// M: @{
+                    final MessageItem mRestrictedItem = mMsgItem;
+                    if (WorkingMessage.sCreationMode == 0 ||
+                      !MessageUtils.isRestrictedType(ComposeMessageActivity.this,
+                              mMsgItem.mMsgId)) {
+                        runOnUiThread(new Runnable() {
+                            public void run() {
+                                forwardMessage(mRestrictedItem);
+                            }
+                        });
+                    } else if (WorkingMessage.sCreationMode == WorkingMessage.WARNING_TYPE) {
+                        new AlertDialog.Builder(ComposeMessageActivity.this)
+                        .setTitle(R.string.restricted_forward_title)
+                        .setIconAttribute(android.R.attr.alertDialogIcon)
+                        .setMessage(R.string.restricted_forward_message)
+                        .setPositiveButton(android.R.string.ok,
+                                new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    int createMode = WorkingMessage.sCreationMode;
+                                    WorkingMessage.sCreationMode = 0;
+                                    runOnUiThread(new Runnable() {
+                                        public void run() {
+                                            forwardMessage(mRestrictedItem);
+                                        }
+                                    });
+                                    WorkingMessage.sCreationMode = createMode;
+                                }
+                            })
+                        .setNegativeButton(android.R.string.cancel, null)
+                        .show();
+                    }
+                    /// @}
+                    return true;
+
+                case MENU_VIEW_SLIDESHOW:
+                    /// M: Code analyze 024, If the click operator can be responsed. @{
+                    if (mClickCanResponse) {
+                        mClickCanResponse = false;
+                        MessageUtils.viewMmsMessageAttachment(ComposeMessageActivity.this,
+                                ContentUris.withAppendedId(Mms.CONTENT_URI, mMsgItem.mMsgId), null,
+                                getAsyncDialog());
+                    return true;
+                    }
+                    /// @}
+                case MENU_VIEW_MESSAGE_DETAILS:
+                    return showMessageDetails(mMsgItem);
+
+                case MENU_DELETE_MESSAGE: {
+                    DeleteMessageListener l = new DeleteMessageListener(mMsgItem);
+
+                    /// M: Code analyze 027,Add for deleting one message.@{
+                    // (Why only query sms table?)
+                    String where = Telephony.Mms._ID + "=" + mMsgItem.mMsgId;
+                    String[] projection = new String[] { Sms.Inbox.THREAD_ID };
+                    MmsLog.d(TAG, "where:" + where);
+                    Cursor queryCursor = Sms.query(getContentResolver(), // query uri:content://sms
+                            projection, where, null);
+
+                    if (queryCursor != null) {
+                        if (queryCursor.moveToFirst()) {
+                            mThreadId = queryCursor.getLong(0);
+                        }
+                        queryCursor.close();
+                    }
+                    /// @}
+                    confirmDeleteDialog(l, mMsgItem.mLocked);
+                    return true;
+                }
+                case MENU_DELIVERY_REPORT:
+                    showDeliveryReport(mMsgItem.mMsgId, mMsgItem.mType);
+                    return true;
+
+                case MENU_COPY_TO_SDCARD: {
+                    /// M: Code analyze 021, Copy valid parts of the attachment(pdu) to SD card.
+                    /// This opeartor will be removed to a separate activity.  @{
+                    /// M: new feature, change default disk when storage is full
+                    long availSize = MessageUtils.getAvailableBytesInFileSystemAtGivenRoot
+                                                    (StorageManagerEx.getDefaultPath());
+                    boolean haveExSD = MessageUtils.existingSD(ComposeMessageActivity.this, true);
+                    boolean haveInSD = MessageUtils.existingSD(ComposeMessageActivity.this, false);
+
+                    /// M: fix bug ALPS00574679, modify toast string when haven't SD Card @{
+                    if (!haveExSD && !haveInSD) {
+                        Toast.makeText(ComposeMessageActivity.this,
+                                getString(R.string.no_sdcard_suggestion),
+                                Toast.LENGTH_LONG).show();
+                        return false;
+                    }
+                    /// @}
+
+                    if (mMsgItem.mMessageSize > availSize) {
+                        if ((haveInSD && !haveExSD) || (!haveInSD && haveExSD)) {
+                            Toast.makeText(ComposeMessageActivity.this,
+                                    getString(R.string.export_disk_problem),
+                                    Toast.LENGTH_LONG).show();
+                            return false;
+                        } else {
+                            new AlertDialog.Builder(ComposeMessageActivity.this)
+                            .setTitle(R.string.copy_to_sdcard_fail)
+                            .setIconAttribute(android.R.attr.alertDialogIcon)
+                            .setMessage(R.string.change_default_disk)
+                            .setPositiveButton(R.string.change,
+                                    new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    Intent intent = new Intent(
+                                            "android.settings.MEMORY_CARD_SETTINGS");
+                                    startActivity(intent);
+                                }
+                            })
+                            .setNegativeButton(android.R.string.cancel, null)
+                            .show();
+                        }
+                    } else {
+
+                        intentMultiSave.putExtra("msgid", mMsgItem.mMsgId);
+                        startActivityForResult(intentMultiSave, REQUEST_CODE_MULTI_SAVE);
+                     }
+                    return true;
+                }
+
+                case MENU_SAVE_RINGTONE: {
+                    int resId = getDrmMimeSavedStringRsrc(mMsgItem.mMsgId,
+                            saveRingtone(mMsgItem.mMsgId));
+                    Toast.makeText(ComposeMessageActivity.this, resId, Toast.LENGTH_SHORT).show();
+                    return true;
+                }
+                case MENU_LOCK_MESSAGE: {
+                    lockMessage(mMsgItem, true);
+                    return true;
+                }
+                case MENU_UNLOCK_MESSAGE: {
+                    lockMessage(mMsgItem, false);
+                    return true;
+                }
+
+                /// M: Code analyze 022, Add bookmark. Maybe exist multi URL addresses. @{
+                case MENU_ADD_TO_BOOKMARK: {
+                    if (mURLs.size() == 1) {
+                        Browser.saveBookmark(ComposeMessageActivity.this, null, mURLs.get(0));
+                    } else if (mURLs.size() > 1) {
+                        CharSequence[] items = new CharSequence[mURLs.size()];
+                        for (int i = 0; i < mURLs.size(); i++) {
+                            items[i] = mURLs.get(i);
+                        }
+                        new AlertDialog.Builder(ComposeMessageActivity.this)
+                            .setTitle(R.string.menu_add_to_bookmark)
+                            .setIcon(MessageResource.drawable.ic_dialog_menu_generic)
+                            .setItems(items, new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    Browser.saveBookmark(ComposeMessageActivity.this,
+                                            null, mURLs.get(which));
+                                    }
+                                })
+                            .show();
+                    }
+                    return true;
+                }
+
+                /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+                case MENU_SAVE_MESSAGE_TO_SUB: {
+                    mSaveMsgThread = new SaveMsgThread(mMsgItem.mType, mMsgItem.mMsgId);
+                    mSaveMsgThread.start();
+                    return true;
+                }
+                /// @}
+
+                /// M: Code analyze 016, Add for select text copy. @{
+                case MENU_SELECT_TEXT: {
+                    AdapterView.AdapterContextMenuInfo info =
+                        (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
+                    Log.i(TAG, "onMenuItemClick(): info.position = " + info.position);
+                    mMsgListAdapter.getItemId(info.position);
+                    MessageListItem msglistItem = (MessageListItem) info.targetView;
+                    if (msglistItem != null) {
+                        Log.i(TAG, "msglistItem != null");
+                        TextView textView =
+                            (TextView) msglistItem.findView(MessageListItem.text_view);
+                        AlertDialog.Builder builder =
+                            new AlertDialog.Builder(ComposeMessageActivity.this);
+                        LayoutInflater factory = LayoutInflater.from(builder.getContext());
+                        final View textEntryView =
+                            factory.inflate(R.layout.alert_dialog_text_entry, null);
+                        EditText contentSelector =
+                            (EditText) textEntryView.findViewById(R.id.content_selector);
+                        contentSelector.setText(textView.getText());
+                        builder.setTitle(R.string.select_text)
+                               .setView(textEntryView)
+                               .setPositiveButton(R.string.yes, null)
+                               .show();
+                    }
+                    return true;
+                }
+                case MENU_ADD_ADDRESS_TO_CONTACTS: {
+                    mAddContactIntent = item.getIntent();
+                    startActivityForResult(mAddContactIntent, REQUEST_CODE_ADD_CONTACT);
+                    return true;
+                }
+                /// @}
+
+                default:
+                    return false;
+            }
+        }
+    }
+
+    private void lockMessage(final MessageItem msgItem, final boolean locked) {
+        final Uri uri;
+        if ("sms".equals(msgItem.mType)) {
+            uri = Sms.CONTENT_URI;
+        } else {
+            uri = Mms.CONTENT_URI;
+        }
+        final Uri lockUri = ContentUris.withAppendedId(uri, msgItem.mMsgId);
+
+        final ContentValues values = new ContentValues(1);
+        values.put("locked", locked ? 1 : 0);
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                if (mIpCompose.lockMessage(getApplicationContext(), msgItem.mIpMessageItem,
+                        locked)) {
+                    return;
+                }
+                if (mOpComposeExt.lockMessage(getApplicationContext(), uri, msgItem.mMsgId,
+                        msgItem.mIpMessageId, locked)) {
+                    return;
+                }
+                getContentResolver().update(lockUri, values, null, null);
+            }
+        }, "ComposeMessageActivity.lockMessage").start();
+    }
+
+    /**
+     * Looks to see if there are any valid parts of the attachment that can be copied to a SD card.
+     * @param msgId
+     */
+    private boolean haveSomethingToCopyToSDCard(long msgId) {
+        PduBody body = null;
+        try {
+            body = SlideshowModel.getPduBody(this,
+                        ContentUris.withAppendedId(Mms.CONTENT_URI, msgId));
+        } catch (MmsException e) {
+            Log.e(TAG, "haveSomethingToCopyToSDCard can't load pdu body: " + msgId);
+        }
+        if (body == null) {
+            return false;
+        }
+
+        boolean result = false;
+        int partNum = body.getPartsNum();
+        for (int i = 0; i < partNum; i++) {
+            PduPart part = body.getPart(i);
+            // M: fix bug ALPS00355917
+            byte[] fileName = part.getFilename();
+            String mSrc = null;
+            if (fileName == null) {
+                fileName = part.getContentLocation();
+            }
+            if (fileName != null) {
+                mSrc = new String(fileName);
+            }
+            String type =  MessageUtils.getContentType(new String(part.getContentType()), mSrc);
+            part.setContentType(type.getBytes());
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                log("[CMA] haveSomethingToCopyToSDCard: part[" + i + "] contentType=" + type);
+            }
+            /// M: Code analyze 057,Now, if the pdu type is "application/ogg" or
+            /// vcard and vcalender attachment can be saved to sdcard.
+            if (MmsContentType.isImageType(type) || MmsContentType.isVideoType(type) ||
+                    MmsContentType.isAudioType(type) || DrmUtils.isDrmType(type) ||
+                    "application/ogg".equalsIgnoreCase(type)
+                    || FileAttachmentModel.isSupportedFile(part)
+                    /// M: fix bug ALPS00446644, support dcf (0ct-stream) file to save
+                    || (mSrc != null && mSrc.toLowerCase().endsWith(".dcf"))) {
+            /// @}
+                return true;
+            }
+        }
+
+        /// M: add for attachment enhance
+        // Justify weather there are attachments in parts but not in slides
+        // SlideshowModel mSlideShowModel = mWorkingMessage.getSlideshow();
+        return mOpComposeExt.haveSomethingToCopyToSDCard(this, body);
+    }
+
+    /**
+     * Copies media from an Mms to the DrmProvider
+     * @param msgId
+     */
+    private boolean saveRingtone(long msgId) {
+        boolean result = true;
+        PduBody body = null;
+        try {
+            body = SlideshowModel.getPduBody(this,
+                        ContentUris.withAppendedId(Mms.CONTENT_URI, msgId));
+        } catch (MmsException e) {
+            Log.e(TAG, "copyToDrmProvider can't load pdu body: " + msgId);
+        }
+        if (body == null) {
+            return false;
+        }
+
+        int partNum = body.getPartsNum();
+        for (int i = 0; i < partNum; i++) {
+            PduPart part = body.getPart(i);
+            String type = new String(part.getContentType());
+
+            if (DrmUtils.isDrmType(type)) {
+                // All parts (but there's probably only a single one) have to be successful
+                // for a valid result.
+                result &= copyPart(part, Long.toHexString(msgId));
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Returns true if any part is drm'd audio with ringtone rights.
+     * @param msgId
+     * @return true if one of the parts is drm'd audio with rights to save as a ringtone.
+     */
+    private boolean isDrmRingtoneWithRights(long msgId) {
+        PduBody body = null;
+        try {
+            body = SlideshowModel.getPduBody(this,
+                        ContentUris.withAppendedId(Mms.CONTENT_URI, msgId));
+        } catch (MmsException e) {
+            Log.e(TAG, "isDrmRingtoneWithRights can't load pdu body: " + msgId);
+        }
+        if (body == null) {
+            return false;
+        }
+
+        int partNum = body.getPartsNum();
+        for (int i = 0; i < partNum; i++) {
+            PduPart part = body.getPart(i);
+            String type = new String(part.getContentType());
+
+            if (DrmUtils.isDrmType(type)) {
+                String mimeType = MmsApp.getApplication().getDrmManagerClient()
+                        .getOriginalMimeType(part.getDataUri());
+                if (MmsContentType.isAudioType(mimeType)
+                        && DrmUtils.haveRightsForAction(part.getDataUri(),
+                        DrmStore.Action.RINGTONE)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if all drm'd parts are forwardable.
+     * @param msgId
+     * @return true if all drm'd parts are forwardable.
+     */
+    private boolean isForwardable(long msgId) {
+        PduBody body = null;
+        try {
+            body = SlideshowModel.getPduBody(this,
+                        ContentUris.withAppendedId(Mms.CONTENT_URI, msgId));
+        } catch (MmsException e) {
+            Log.e(TAG, "getDrmMimeType can't load pdu body: " + msgId);
+        }
+        if (body == null) {
+            return false;
+        }
+
+        int partNum = body.getPartsNum();
+        for (int i = 0; i < partNum; i++) {
+            PduPart part = body.getPart(i);
+            String type = new String(part.getContentType());
+            if (DrmUtils.isDrmType(type) && !DrmUtils.haveRightsForAction(part.getDataUri(),
+                    DrmStore.Action.TRANSFER)) {
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    private int getDrmMimeMenuStringRsrc(long msgId) {
+        if (isDrmRingtoneWithRights(msgId)) {
+            return R.string.save_ringtone;
+        }
+        return 0;
+    }
+
+    private int getDrmMimeSavedStringRsrc(long msgId, boolean success) {
+        if (isDrmRingtoneWithRights(msgId)) {
+            return success ? R.string.saved_ringtone : R.string.saved_ringtone_fail;
+        }
+        return 0;
+    }
+
+    /**
+     * Copies media from an Mms to the "download" directory on the SD card. If any of the parts
+     * are audio types, drm'd or not, they're copied to the "Ringtones" directory.
+     * @param msgId
+     */
+    private boolean copyMedia(long msgId) {
+        boolean result = true;
+        PduBody body = null;
+        try {
+            body = SlideshowModel.getPduBody(this,
+                        ContentUris.withAppendedId(Mms.CONTENT_URI, msgId));
+        } catch (MmsException e) {
+            Log.e(TAG, "copyMedia can't load pdu body: " + msgId);
+        }
+        if (body == null) {
+            return false;
+        }
+
+        int partNum = body.getPartsNum();
+        for (int i = 0; i < partNum; i++) {
+            PduPart part = body.getPart(i);
+
+            // all parts have to be successful for a valid result.
+            result &= copyPart(part, Long.toHexString(msgId));
+        }
+        return result;
+    }
+
+    private boolean copyPart(PduPart part, String fallback) {
+        Uri uri = part.getDataUri();
+        String type = new String(part.getContentType());
+        boolean isDrm = DrmUtils.isDrmType(type);
+        if (isDrm) {
+            type = MmsApp.getApplication().getDrmManagerClient()
+                    .getOriginalMimeType(part.getDataUri());
+        }
+        if (!MmsContentType.isImageType(type) && !MmsContentType.isVideoType(type) &&
+                !MmsContentType.isAudioType(type)) {
+            return true;    // we only save pictures, videos, and sounds. Skip the text parts,
+                            // the app (smil) parts, and other type that we can't handle.
+                            // Return true to pretend that we successfully saved the part so
+                            // the whole save process will be counted a success.
+        }
+        InputStream input = null;
+        FileOutputStream fout = null;
+        try {
+            input = mContentResolver.openInputStream(uri);
+            if (input instanceof FileInputStream) {
+                FileInputStream fin = (FileInputStream) input;
+
+                byte[] location = part.getName();
+                if (location == null) {
+                    location = part.getFilename();
+                }
+                if (location == null) {
+                    location = part.getContentLocation();
+                }
+
+                String fileName;
+                if (location == null) {
+                    // Use fallback name.
+                    fileName = fallback;
+                } else {
+                    // For locally captured videos, fileName can end up being something like this:
+                    //      /mnt/sdcard/Android/data/com.android.mms/cache/.temp1.3gp
+                    fileName = new String(location);
+                }
+                File originalFile = new File(fileName);
+                fileName = originalFile.getName();  // Strip the full path of where the "part" is
+                                                    // stored down to just the leaf filename.
+
+                // Depending on the location, there may be an
+                // extension already on the name or not. If we've got audio, put the attachment
+                // in the Ringtones directory.
+                String dir = Environment.getExternalStorageDirectory() + "/"
+                                + (MmsContentType.isAudioType(type) ?
+                                        Environment.DIRECTORY_RINGTONES :
+                                    Environment.DIRECTORY_DOWNLOADS)  + "/";
+                String extension;
+                int index = fileName.lastIndexOf('.');
+                if (index == -1) {
+                    extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(type);
+                } else {
+                    extension = fileName.substring(index + 1, fileName.length());
+                    fileName = fileName.substring(0, index);
+                }
+                MmsLog.i(TAG, "Save part extension name is: " + extension);
+                if (isDrm) {
+                    extension += DrmUtils.getConvertExtension(type);
+                }
+                // Remove leading periods. The gallery ignores files starting with a period.
+                fileName = fileName.replaceAll("^.", "");
+
+                File file = getUniqueDestination(dir + fileName, extension);
+
+                // make sure the path is valid and directories created for this file.
+                File parentFile = file.getParentFile();
+                if (!parentFile.exists() && !parentFile.mkdirs()) {
+                    MmsLog.wpi(TAG, " copyPart: mkdirs for " + parentFile.getPath() + " failed!");
+                    return false;
+                }
+
+                fout = new FileOutputStream(file);
+
+                byte[] buffer = new byte[8000];
+                int size = 0;
+                while ((size = fin.read(buffer)) != -1) {
+                    fout.write(buffer, 0, size);
+                }
+
+                // Notify other applications listening to scanner events
+                // that a media file has been added to the sd card
+                sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,
+                        Uri.fromFile(file)));
+            }
+        } catch (IOException e) {
+            // Ignore
+            Log.e(TAG, "IOException caught while opening or reading stream", e);
+            return false;
+        } finally {
+            if (null != input) {
+                try {
+                    input.close();
+                } catch (IOException e) {
+                    // Ignore
+                    Log.e(TAG, "IOException caught while closing stream", e);
+                    return false;
+                }
+            }
+            if (null != fout) {
+                try {
+                    fout.close();
+                } catch (IOException e) {
+                    // Ignore
+                    Log.e(TAG, "IOException caught while closing stream", e);
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    private File getUniqueDestination(String base, String extension) {
+        File file = new File(base + "." + extension);
+
+        for (int i = 2; file.exists(); i++) {
+            file = new File(base + "_" + i + "." + extension);
+        }
+        return file;
+    }
+
+    private void showDeliveryReport(long messageId, String type) {
+        Intent intent = new Intent(this, DeliveryReportActivity.class);
+        intent.putExtra("message_id", messageId);
+        intent.putExtra("message_type", type);
+
+        startActivity(intent);
+    }
+
+    private final IntentFilter mHttpProgressFilter = new IntentFilter(PROGRESS_STATUS_ACTION);
+
+    private final BroadcastReceiver mHttpProgressReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (PROGRESS_STATUS_ACTION.equals(intent.getAction())) {
+                long token = intent.getLongExtra("token",
+                                    SendingProgressTokenManager.NO_TOKEN);
+                if (token != mConversation.getThreadId()) {
+                    return;
+                }
+
+                int progress = intent.getIntExtra("progress", 0);
+                switch (progress) {
+                    case PROGRESS_START:
+                        setProgressBarVisibility(true);
+                        break;
+                    case PROGRESS_ABORT:
+                    case PROGRESS_COMPLETE:
+                        setProgressBarVisibility(false);
+                        break;
+                    default:
+                        setProgress(100 * progress);
+                }
+            }
+        }
+    };
+
+    private static ContactList sEmptyContactList;
+
+    private ContactList getRecipients() {
+        // If the recipients editor is visible, the conversation has
+        // not really officially 'started' yet.  Recipients will be set
+        // on the conversation once it has been saved or sent.  In the
+        // meantime, let anyone who needs the recipient list think it
+        // is empty rather than giving them a stale one.
+        if (isRecipientsEditorVisible()) {
+            if (sEmptyContactList == null) {
+                sEmptyContactList = new ContactList();
+            }
+            return sEmptyContactList;
+        }
+        return mConversation.getRecipients();
+    }
+
+    private void updateTitle(ContactList list) {
+        String title = null;
+        String subTitle = null;
+        Drawable avatarIcon = null;
+        int cnt = list.size();
+        ArrayList<String> titles = new ArrayList<String>();
+        MmsLog.d(TAG, "updateTitle(): list.size()" + list.size());
+        switch (cnt) {
+            case 0: {
+                /// M: only show "new message" string if list size is 0, if a number
+                /// end without "," or ";" should not display on title.
+                title = getString(R.string.new_message);
+                break;
+            }
+            case 1: {
+                title = list.get(0).getName();      // get name returns the number if there's no
+                                                    // name available.
+                Drawable sDefaultContactImage = this.getResources().getDrawable(
+                    R.drawable.ic_contact_picture);
+                avatarIcon = list.get(0).getAvatar(this, sDefaultContactImage,
+                                                    mConversation != null
+                                                    ? mConversation.getThreadId() : -1);
+                String number = list.get(0).getNumber();
+                String numberAfterFormat;
+//                ImageView ipCustomView = (ImageView) mActionBarCustomView
+//                        .findViewById(R.id.iv_full_integrated);
+
+                // add for ipmessage
+//                if (mIpCompose.onIpUpdateTitle(number, title, ipCustomView, titles)) {
+//                    title = titles.get(0);
+//                    subTitle = titles.get(1);
+//                }
+
+                if (!title.equals(number)) {
+                    numberAfterFormat = MessageUtils.formatNumber(number,
+                            this.getApplicationContext());
+                    if (!title.equals(numberAfterFormat)) {
+                        subTitle = numberAfterFormat;
+                    }
+                }
+                /// M: fix bug ALPS00488976, group mms @{
+                if (mMsgListAdapter.isGroupConversation()) {
+                    mMsgListAdapter.setIsGroupConversation(false);
+                }
+                /// @}
+                break;
+            }
+            default: {
+                // Handle multiple recipients
+                avatarIcon = this.getResources().getDrawable(R.drawable.ic_contact_picture);
+                title = list.formatNames(", ");
+                subTitle = getResources().getQuantityString(R.plurals.recipient_count, cnt, cnt);
+                break;
+            }
+        }
+        mDebugRecipients = list.serialize();
+
+        ActionBar actionBar = getActionBar();
+        if (actionBar == null) {
+            return;
+        }
+        if (avatarIcon != null) {
+            actionBar.setIcon(avatarIcon);
+        }
+
+        if (actionBar.getCustomView() == null) {
+            actionBar.setCustomView(R.layout.actionbar_message_title);
+        }
+        mActionBarCustomView = actionBar.getCustomView();
+        mTopTitle = (TextView) mActionBarCustomView.findViewById(R.id.tv_top_title);
+        mTopSubtitle = (TextView) mActionBarCustomView.findViewById(R.id.tv_top_subtitle);
+        String number = null;
+        if (!list.isEmpty())
+        {
+            number = list.get(0).getNumber();
+            MmsLog.dpi(TAG, "updateTitle(): list.1 number" + number);
+        }
+        // add for ipmessage
+        ImageView ipCustomView = (ImageView) mActionBarCustomView
+                .findViewById(R.id.iv_full_integrated);
+        if (mIpCompose.onIpUpdateTitle(number, null, ipCustomView, titles)) {
+            title = titles.get(0);
+            subTitle = titles.get(1);
+        }
+
+        subTitle = mOpComposeExt.updateTitle(cnt, number, subTitle);
+
+        asyncUpdateThreadMuteIcon();
+        ///M: ALPS00772324 The recipient didn't shown completely after input a recipient's numbers
+        ///M: and put the cursor to the text field.
+        ///M: setMaxWidth to a very large value for textView can width can be wrap_content
+        mTopTitle.setMaxWidth(3000);
+        mTopTitle.setText(title);
+		setTextMarquee(mTopTitle);
+        if (TextUtils.isEmpty(subTitle)) {
+            if (cnt == 0) {
+                actionBar.setIcon(R.drawable.ic_launcher_smsmms);
+            }
+            mTopSubtitle.setVisibility(View.GONE);
+        } else {
+            mTopSubtitle.setText(subTitle);
+            mTopSubtitle.setVisibility(View.VISIBLE);
+        }
+        actionBar.setDisplayShowCustomEnabled(true);
+        actionBar.setDisplayShowTitleEnabled(false);
+    }
+
+	public static void setTextMarquee(TextView textView) {
+        if (textView != null) {
+            textView.setEllipsize(TextUtils.TruncateAt.MARQUEE);
+			textView.setMarqueeRepeatLimit(6);
+            textView.setSingleLine(true);
+            textView.setSelected(true);
+            textView.setFocusable(true);
+            textView.setFocusableInTouchMode(true);
+        }
+    }
+
+    private void asyncUpdateThreadMuteIcon() {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                boolean value = false;
+                if (mConversation != null && mConversation.getThreadId() > 0) {
+                    value = MessageUtils.checkNeedNotify(ComposeMessageActivity.this,
+                            mConversation.getThreadId(), null);
+                } else {
+                    value = MessageUtils.checkNeedNotify(ComposeMessageActivity.this, 0, null);
+                }
+                final boolean needNotify = value;
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        MmsLog.d(TAG, "asyncUpdateThreadMuteIcon: meedNotify is " + needNotify);
+                        ActionBar actionBar = getActionBar();
+                        if (actionBar.getCustomView() == null) {
+                            actionBar.setCustomView(R.layout.actionbar_message_title);
+                        }
+                        mActionBarCustomView = actionBar.getCustomView();
+                        mMuteLogo = (ImageView) mActionBarCustomView.findViewById(R.id.iv_silent);
+                        mMuteLogo.setVisibility(needNotify ? View.INVISIBLE : View.VISIBLE);
+                    }
+                });
+            }
+        }, "check and update mute icon").start();
+    }
+
+    // Get the recipients editor ready to be displayed onscreen.
+    private void initRecipientsEditor(Bundle bundle) {
+        /// M: Code analyze 046, Whether the recipientedit control has been initialized. @{
+        if (isRecipientsEditorVisible() && isInitRecipientsEditor) {
+        /// @}
+            return;
+        }
+        // Must grab the recipients before the view is made visible because getRecipients()
+        // returns empty recipients when the editor is visible.
+        ContactList recipients = getRecipients();
+        /// M: Code analyze 058, Remove exceed recipients.
+        while (!recipients.isEmpty() && recipients.size() > RECIPIENTS_LIMIT_FOR_SMS) {
+            recipients.remove(RECIPIENTS_LIMIT_FOR_SMS);
+        }
+        /// @}
+
+        ViewStub stub = (ViewStub) findViewById(R.id.recipients_editor_stub);
+        if (stub != null) {
+            View stubView = stub.inflate();
+            mRecipientsEditor = (RecipientsEditor) stubView.findViewById(R.id.recipients_editor);
+            mRecipientsPicker = (ImageButton) stubView.findViewById(R.id.recipients_picker);
+        } else {
+            mRecipientsEditor = (RecipientsEditor) findViewById(R.id.recipients_editor);
+            mRecipientsEditor.setVisibility(View.VISIBLE);
+            mRecipientsPicker = (ImageButton) findViewById(R.id.recipients_picker);
+            /// M: Code analyze 059, Set the pick button visible or
+            /// invisible the same as recipient editor.
+            mRecipientsPicker.setVisibility(View.VISIBLE);
+            /// @}
+        }
+        mRecipientsPicker.setOnClickListener(this);
+        mRecipientsEditor.removeChipChangedListener(mChipWatcher);
+        mRecipientsEditor.addChipChangedListener(mChipWatcher);
+
+        mRecipientsPicker.setEnabled(mIsSmsEnabled);
+        mRecipientsEditor.setEnabled(mIsSmsEnabled);
+        mRecipientsEditor.setFocusableInTouchMode(mIsSmsEnabled);
+        mRecipientsEditor.setIsTouchable(mIsSmsEnabled);
+
+        // M: indicate contain email address or not in RecipientsEditor candidates. @{
+        SharedPreferences prefs =
+            PreferenceManager.getDefaultSharedPreferences(ComposeMessageActivity.this);
+        boolean showEmailAddress =
+            prefs.getBoolean(GeneralPreferenceActivity.SHOW_EMAIL_ADDRESS, true);
+        MmsLog.d(TAG, "initRecipientsEditor(), showEmailAddress = " + showEmailAddress);
+        /// M: fix bug ALPS00380930
+        if (mRecipientsEditor.getAdapter() == null) {
+            ChipsRecipientAdapter chipsAdapter = new ChipsRecipientAdapter(this);
+            chipsAdapter.setShowEmailAddress(showEmailAddress);
+            mRecipientsEditor.setAdapter(chipsAdapter);
+            mRecipientsEditor.setGalSearchDelayer();
+        } else {
+            ((ChipsRecipientAdapter) mRecipientsEditor
+                    .getAdapter()).setShowEmailAddress(showEmailAddress);
+        }
+        // @}
+        if (bundle == null) {
+            mRecipientsEditor.populate(new ContactList());
+            mRecipientsEditor.populate(recipients);
+        }
+        mRecipientsEditor.setOnCreateContextMenuListener(mRecipientsMenuCreateListener);
+        // TODO : Remove the max length limitation due to the multi phone picker is added and the
+        // user is able to select a large number of recipients from the Contacts. The coming
+        // potential issue is that it is hard for user to edit a recipient from hundred of
+        // recipients in the editor box. We may redesign the editor box UI for this use case.
+        // mRecipientsEditor.setFilters(new InputFilter[] {
+        //         new InputFilter.LengthFilter(RECIPIENTS_MAX_LENGTH) });
+
+        mRecipientsEditor.setOnSelectChipRunnable(new Runnable() {
+            public void run() {
+                // After the user selects an item in the pop-up contacts list, move the
+                // focus to the text editor if there is only one recipient.  This helps
+                // the common case of selecting one recipient and then typing a message,
+                // but avoids annoying a user who is trying to add five recipients and
+                // keeps having focus stolen away.
+                if (mRecipientsEditor.getRecipientCount() == 1) {
+                    // if we're in extract mode then don't request focus
+                    final InputMethodManager inputManager = mInputMethodManager;
+                    if (inputManager == null || !inputManager.isFullscreenMode()) {
+                        if (mBottomPanel != null && mBottomPanel.getVisibility() == View.VISIBLE) {
+                            mTextEditor.requestFocus();
+                        }
+                    }
+                }
+            }
+        });
+
+        mRecipientsEditor.setOnFocusChangeListener(new View.OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (hasFocus) {
+                    /// M: add for ip message
+                    MmsLog.d(TAG, "onFocusChange(): mRecipientsEditor get focus.");
+                    if (mIsLandscape) {
+                        mTextEditor.setMaxHeight(
+                                mReferencedTextEditorTwoLinesHeight
+                                * mCurrentMaxHeight / mReferencedMaxHeight);
+                    } else {
+                        updateTextEditorHeightInFullScreen();
+                    }
+                }
+                // add for ipmessage
+                mIpCompose.onIpRecipientsEditorFocusChange(
+                        hasFocus, mRecipientsEditor.getNumbers());
+                mOpComposeExt.onRecipientsEditorFocusChange(hasFocus);
+            }
+        });
+
+        mRecipientsEditor.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                mIpCompose.onIpRecipientsEditorTouch();
+                mOpComposeExt.onRecipientsEditorTouch();
+                return false;
+            }
+        });
+
+        mRecipientsEditor.setChipProcessListener(new ChipProcessListener() {
+            public void onChipProcessDone() {
+                mIsPopulatingRecipients = false;
+                if (mIsConvertToastDelayed) {
+                    mIsConvertToastDelayed = false;
+                    toastConvertInfo(mIsConvertMms);
+                }
+            }
+        });
+
+        // M: fix bug ALPS00355897
+        // PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(this, mRecipientsEditor);
+
+        mTopPanel.setVisibility(View.VISIBLE);
+        /// M: Code analyze 013, Get contacts from Contact app . @{
+        if (mIsRecipientHasIntentNotHandle && (mIntent != null)) {
+            processPickResult(mIntent);
+            mIsRecipientHasIntentNotHandle = false;
+            mIntent = null;
+        }
+        /// @}
+        mIpCompose.initRecipientsEditor(mRecipientsEditor);
+    }
+
+    //==========================================================
+    // Activity methods
+    //==========================================================
+
+    public static boolean cancelFailedToDeliverNotification(Intent intent, Context context) {
+        if (MessagingNotification.isFailedToDeliver(intent)) {
+            // Cancel any failed message notifications
+            MessagingNotification.cancelNotification(context,
+                        MessagingNotification.MESSAGE_FAILED_NOTIFICATION_ID);
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean cancelFailedDownloadNotification(Intent intent, Context context) {
+        if (MessagingNotification.isFailedToDownload(intent)) {
+            // Cancel any failed download notifications
+            MessagingNotification.cancelNotification(context,
+                        MessagingNotification.DOWNLOAD_FAILED_NOTIFICATION_ID);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        mIsSmsEnabled = MmsConfig.isSmsEnabled(this);
+        super.onCreate(savedInstanceState);
+        mSavedInstanceState = savedInstanceState;
+
+        if (requestAllPermissions()) {
+            MmsLog.d(TAG, "onCreate() requestAllPermissions return !!");
+            mNeedRequestPermissins = true;
+            return;
+        } else {
+            if (DraftCache.getInstance() == null) {
+                MmsApp.getApplication().onRequestPermissionsResult();
+            }
+        }
+
+        mForwardingMessage = false;
+
+        /// M: If cell dialog is showed before, do not show it. @{
+        if (savedInstanceState != null
+                && savedInstanceState.getBoolean("cell_dialog_showing", false)) {
+            MmsLog.d(TAG, "cell progress dialog is showed before, do not show it now");
+            savedInstanceState.putBundle("android:savedDialogs", null);
+        }
+        /// @}
+
+        // add for ipmessage
+        mIpCompose = IpMessageUtils.getIpMessagePlugin(this).getIpComposeActivity();
+        // add for op plugin
+        mOpComposeExt = OpMessageUtils.getOpMessagePlugin().getOpComposeExt();
+
+        mMessageSubId = (int) Settings.System.getLong(getContentResolver(),
+                Settings.System.SMS_SIM_SETTING, Settings.System.DEFAULT_SIM_NOT_SET);
+
+        mInputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+
+        /// M: Code analyze 002,  If a new ComposeMessageActivity is created, kill old one
+        Activity compose = sCompose == null ? null : sCompose.get();
+        /// M Fix CR : ALPS01275735, which has mms draft for conversation A, enter it.
+        /// change recipients froam A to B, then come a B notification , click the notification,
+        /// enter the thread A, it will show wrong composer UI.
+        /// because conversation from cache is the same. @{
+        if (compose != null && compose instanceof ComposeMessageActivity) {
+            Intent in = this.getIntent();
+            /// M : Fix issue ALPS01767850 @{
+            if (in.getBooleanExtra("from_notification", false)) {
+                boolean b = ((ComposeMessageActivity) compose).hasValidRecipient();
+                if (b) {
+                    mLastThreadIdFromNotification
+                            = ((ComposeMessageActivity) compose).mConversation.ensureThreadId();
+                    if (!((ComposeMessageActivity) compose).mWorkingMessage.hasAttachment()) {
+                        sTextEditorText
+                                = ((ComposeMessageActivity) compose)
+                                        .mWorkingMessage.getText().toString();
+                    } else {
+                        sTextEditorText = null;
+                    }
+                }
+            }
+            /// @}
+
+            long thid = in.getLongExtra("thread_id_from_notification", -1);
+            if (((ComposeMessageActivity) compose).mConversation != null) {
+                if (thid == ((ComposeMessageActivity) compose).mConversation.getThreadId()) {
+                    ((ComposeMessageActivity) compose).mConversation.clearThreadId();
+                }
+            }
+        }
+        /// @}
+
+        if (compose != null && !compose.isFinishing() && savedInstanceState == null) {
+            MmsLog.d(TAG, "onCreate finish old compose");
+            compose.finish();
+        }
+        sCompose = new WeakReference(this);
+        /// @}
+        /// M: Code analyze 003,  Set or get max mms size.
+        initMessageSettings();
+        /// @}
+        resetConfiguration(getResources().getConfiguration());
+        /// M: Code analyze 004, Set max height for text editor. @{
+        WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+        if (mIsLandscape) {
+            mCurrentMaxHeight = windowManager.getDefaultDisplay().getWidth();
+        } else {
+            mCurrentMaxHeight = windowManager.getDefaultDisplay().getHeight();
+        }
+        MmsLog.d(TAG, "onCreate(): mCurrentMaxHeight = " + mCurrentMaxHeight);
+        /// @}
+        setContentView(R.layout.compose_message_activity);
+        setProgressBarVisibility(false);
+
+        mIpCompose.onIpComposeActivityCreate(this, mIpComposeCallback, mHandler, mUiHandler,
+                (ImageButton) findViewById(R.id.send_button_sms),
+                (TextView) findViewById(R.id.ip_message_typing_status),
+                (TextView) findViewById(R.id.ipmsg_joyn_stranger_remind),
+                findViewById(R.id.bottom_panel), savedInstanceState,
+                (ImageButton) findViewById(R.id.share_button),
+                (LinearLayout) findViewById(R.id.panel_container),
+                (EditText) findViewById(R.id.embedded_text_editor));
+
+        /// M: add for update sub state dynamically. @{
+        IntentFilter intentFilter =
+            new IntentFilter(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        mOpComposeExt.onCreate(mIpComposeCallback, getIntent(), intentFilter, compose, this,
+                savedInstanceState, mUiHandler, (ImageButton) findViewById(R.id.share_button),
+                (LinearLayout) findViewById(R.id.panel_container),
+                (EditText) findViewById(R.id.embedded_text_editor));
+        /// @}
+
+        /// M: Code analyze 005, Set input mode. @{
+        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
+        /// @}
+
+        // Initialize members for UI elements.
+        initResourceRefs();
+        /// M: Code analyze 006, Control Sub indicator on status bar. @{
+        mStatusBarManager = (StatusBarManager) getSystemService(Context.STATUS_BAR_SERVICE);
+        mComponentName = getComponentName();
+        /// @}
+
+        /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+        mSubCount = 0;
+        /// @}
+
+        mContentResolver = getContentResolver();
+        mBackgroundQueryHandler = new BackgroundQueryHandler(mContentResolver);
+
+        initialize(savedInstanceState, 0, false);
+
+        if (TRACE) {
+            android.os.Debug.startMethodTracing("compose");
+        }
+        /// M: Code analyze 008,unkown . @{
+        mDestroy = false;
+
+        /// @}
+        /// M: Code analyze 009,Show attachment dialog . @{
+        mSoloAlertDialog = new SoloAlertDialog(this);
+        /// @}
+        /// M: Code analyze 007, Get information from Sub or
+        /// save message to Sub.(Get all Sub info) @{
+        mGetSubInfoRunnable.run();
+        /// @} for ALPS00475359 end
+
+        this.registerReceiver(mSubReceiver, intentFilter);
+        /// @}
+    }
+
+    private void showSubjectEditor(boolean show) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            log("showSubjectEditor: " + show);
+        }
+
+        if (mSubjectTextEditor == null) {
+            // Don't bother to initialize the subject editor if
+            // we're just going to hide it.
+            if (show == false) {
+                return;
+            }
+            mSubjectTextEditor = (EditText) findViewById(R.id.subject);
+            /// M: Code analyze 068, Unknown. Why delete these code? @{
+            /// mSubjectTextEditor.setFilters(new InputFilter[] {
+            ///     new LengthFilter(MmsConfig.getMaxSubjectLength())});
+            /// @}
+            /// M: Code analyze 001, Plugin opeartor. @{
+            mOpComposeExt.showSubjectEditor(mSubjectTextEditor);
+            /// @}
+       }
+
+        mSubjectTextEditor.setOnKeyListener(show ? mSubjectKeyListener : null);
+
+        mSubjectTextEditor.removeTextChangedListener(mSubjectEditorWatcher);
+        if (show) {
+            mSubjectTextEditor.addTextChangedListener(mSubjectEditorWatcher);
+        }
+
+        if ((mBottomPanel != null) && (mBottomPanel.getVisibility() == View.VISIBLE)) {
+            if (!show) {
+                mTextEditor.requestFocus();
+            }
+            //mSubjectTextEditor.setNextFocusDownId(R.id.embedded_text_editor);
+            mSubjectTextEditor.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+            mSubjectTextEditor.setImeActionLabel(getText(
+                    com.android.internal.R.string.ime_action_next), EditorInfo.IME_ACTION_NEXT);
+        } else {
+            //mSubjectTextEditor.setNextFocusDownId(-1);
+            mSubjectTextEditor.setImeOptions(EditorInfo.IME_ACTION_DONE);
+            mSubjectTextEditor.setImeActionLabel(
+                    getText(com.android.internal.R.string.ime_action_done),
+                    EditorInfo.IME_ACTION_DONE);
+        }
+        CharSequence subjectText = mWorkingMessage.getSubject();
+        if (subjectText != null && show) {
+            mSubjectTextEditor.setTextKeepState(subjectText);
+            try {
+                mSubjectTextEditor.setSelection(mSubjectTextEditor.getText().toString().length());
+            } catch (IndexOutOfBoundsException e) {
+                mSubjectTextEditor.setSelection(
+                        mSubjectTextEditor.getText().toString().length() - 1);
+            }
+        } else {
+            mSubjectTextEditor.setText("");
+        }
+
+        mSubjectTextEditor.setVisibility(show ? View.VISIBLE : View.GONE);
+
+        mSubjectTextEditor.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                mIpCompose.onIpSubjectTextEditorTouch();
+                mOpComposeExt.onSubjectTextEditorTouch();
+                return false;
+            }
+        });
+
+        mSubjectTextEditor.setOnFocusChangeListener(new View.OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(View v, boolean hasFocus) {
+                mIpCompose.onIpSubjectTextEditorFocusChange(hasFocus);
+                mOpComposeExt.onSubjectTextEditorFocusChange(hasFocus);
+            }
+        });
+
+        mSubjectTextEditor.setOnEditorActionListener(new TextView.OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_NEXT) {
+                    if ((mBottomPanel != null) && (mBottomPanel.getVisibility() == View.VISIBLE)) {
+                        mTextEditor.requestFocus();
+                        return true;
+                    }
+                }
+                return false;
+            }
+        });
+        hideOrShowTopPanel();
+    }
+
+    private void hideOrShowTopPanel() {
+        if (mOpComposeExt.hideOrShowTopPanel(mTopPanel)) {
+            return;
+        }
+        boolean anySubViewsVisible = (isSubjectEditorVisible() || isRecipientsEditorVisible());
+        mTopPanel.setVisibility(anySubViewsVisible ? View.VISIBLE : View.GONE);
+    }
+
+    /// M : Fix issue ALPS01767850 @{
+    /// If there a mms draft with thread id 1, and create a new sms message with threadid 1
+    /// Then send a threadid 1 message, and click the notification to enter the 1 thread
+    /// The sms message will disapre which just edit in the editor box
+    private boolean needLoadDraftWhileFromNotification(Intent intent) {
+        if (intent == null) {
+            return true;
+        }
+        // check from notification or not
+        boolean isFromNotification = intent.getBooleanExtra("from_notification", false);
+
+        if (!isFromNotification) {
+            Log.d(TAG,
+                    "[needLoadDraftWhileFromNotification] NOT from notification, need load draft");
+            return true;
+        }
+
+        // check exist text or not
+        if (sTextEditorText == null || sTextEditorText.trim().length() == 0) {
+            Log.d(TAG, "[needLoadDraftWhileFromNotification] NO" +
+                    " EXIST text in the editor, need load draft");
+            return true;
+        }
+        // check the thread id from notification and the thread id from last compose is the same
+        boolean isSameThread = false;
+
+        long threadIdFromNotification = intent.getLongExtra("thread_id_from_notification", -1);
+
+        if (mLastThreadIdFromNotification == -1 || threadIdFromNotification == -1) {
+            isSameThread = false;
+        } else if (mLastThreadIdFromNotification == threadIdFromNotification) {
+            isSameThread = true;
+        }
+
+        Log.d(TAG, "[needLoadDraftWhileFromNotification] mLastThreadIdFromNotification : "
+                + mLastThreadIdFromNotification
+                + ", threadIdFromNotification : " + threadIdFromNotification);
+
+        if (!isSameThread) {
+            Log.d(TAG, "[needLoadDraftWhileFromNotification] NOT the same thread, load draft");
+            return true;
+        }
+
+        mLastThreadIdFromNotification = -1;
+        Log.d(TAG, "[needLoadDraftWhileFromNotification] return false");
+
+        return false;
+    }
+    ///@}
+
+    public void initialize(Bundle savedInstanceState, long originalThreadId,
+                           boolean fromPremissionresult) {
+        /// M: Code analyze 010, Support dirtory mode. @{
+        Intent intent = getIntent();
+        boolean showInput = false;
+        boolean hiderecipient = false;
+        boolean isMustRecipientEditable = false;
+        if (FolderModeUtils.getMmsDirMode()) {
+            mHomeBox = intent.getIntExtra("folderbox", 0);
+            showInput = intent.getBooleanExtra("showinput", false);
+            hiderecipient = intent.getBooleanExtra("hiderecipient", false);
+            isMustRecipientEditable = true;
+        }
+        /// @}
+
+        // Create a new empty working message.
+        mWorkingMessage = WorkingMessage.createEmpty(this);
+
+        // add for ipmessage
+//        mIpCompose.onIpInitialize(intent, mWorkingMessage);
+
+        // Read parameters or previously saved state of this activity. This will load a new
+        // mConversation
+        initActivityState(savedInstanceState);
+
+        if (LogTag.SEVERE_WARNING && originalThreadId != 0 &&
+                originalThreadId == mConversation.getThreadId()) {
+            LogTag.warnPossibleRecipientMismatch("ComposeMessageActivity.initialize: " +
+                    " threadId didn't change from: " + originalThreadId, this);
+        }
+
+        log("savedInstanceState = " + savedInstanceState +
+            ", intent = " + intent +
+            ", originalThreadId = " + originalThreadId +
+            ", mConversation = " + mConversation);
+
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (!FolderModeUtils.getMmsDirMode()) {
+            if (cancelFailedToDeliverNotification(getIntent(), this)
+                    && savedInstanceState == null) {
+                // Show a pop-up dialog to inform user the message was
+                // failed to deliver.
+                undeliveredMessageDialog(getMessageDate(null));
+            }
+            cancelFailedDownloadNotification(getIntent(), this);
+        }
+        ///  @}
+        // Set up the message history ListAdapter
+        initMessageList();
+        /// M: fix bug for ConversationList select all performance ,update selected thread array.@{
+        mSelectedThreadId = mConversation.getThreadId();
+        /// @}
+        // Load the draft for this thread, if we aren't already handling
+        // existing data, such as a shared picture or forwarded message.
+        boolean isForwardedMessage = false;
+        // We don't attempt to handle the Intent.ACTION_SEND when saveInstanceState is non-null.
+        // saveInstanceState is non-null when this activity is killed. In that case, we already
+        // handled the attachment or the send, so we don't try and parse the intent again.
+        boolean intentHandled = savedInstanceState == null &&
+        /// M: unknown @{
+            (handleSendIntent() || (handleForwardedMessage() && !mConversation.hasDraft()));
+        /// @}
+
+        /// M: ALPS03562153 @{
+        String action = intent.getAction();
+        if ((action != null) && Intent.ACTION_SENDTO.equals(action)) {
+            Log.d(TAG, "[initialize] action: " + action);
+            mCreateFromSendTo = true;
+        }
+        /// @}
+
+        /// M : Fix issue ALPS01767850
+        boolean need = needLoadDraftWhileFromNotification(intent);
+        Log.d(TAG, "[initialize] need : " + need);
+        if (!intentHandled && need) {
+            MmsLog.d(TAG, "Composer init load Draft.");
+            loadDraft();
+        } else if (!need) {
+            mTextEditor.setText(sTextEditorText);
+        }
+
+        sTextEditorText = null;
+
+        // Let the working message know what conversation it belongs to
+        mWorkingMessage.setConversation(mConversation);
+
+        // need init cc editor no matter recipient editor show or not
+        mOpComposeExt.onInitialize(intent, mWorkingMessage.mOpWorkingMessageExt);
+        mOpComposeExt.initRecipientsEditor(savedInstanceState,
+                (RecipientsEditor) findViewById(R.id.recipients_cc_editor));
+
+        // Show the recipients editor if we don't have a valid thread. Hide it otherwise.
+        /// M: @{
+        //  if (mConversation.getThreadId() <= 0) {
+        if (mConversation.getThreadId() <= 0L
+            || (mConversation.getMessageCount() <= 0
+                    && (intent.getAction() != null || mConversation.hasDraft()))
+            || (mConversation.getThreadId() > 0L && mConversation.getMessageCount() <= 0)
+            || isMustRecipientEditable) {
+         /// @}
+            // Hide the recipients editor so the call to initRecipientsEditor won't get
+            // short-circuited.
+            hideRecipientEditor();
+            if (fromPremissionresult == true) {
+                initRecipientsEditor(null);
+            } else {
+                initRecipientsEditor(savedInstanceState);
+            }
+
+            // Bring up the softkeyboard so the user can immediately enter recipients. This
+            // call won't do anything on devices with a hard keyboard.
+            if (mIsSmsEnabled) {
+                getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                    WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+            }
+        } else {
+            hideRecipientEditor();
+        }
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (FolderModeUtils.getMmsDirMode()) {
+            if (showInput) {
+                getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                        WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+            } else {
+                getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                        WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
+            }
+            if (hiderecipient) {
+                if (isRecipientsEditorVisible()) {
+                    hideRecipientEditor();
+                }
+            }
+        }
+        /// M: @{
+
+        invalidateOptionsMenu();    // do after show/hide of recipients editor because the options
+                                    // menu depends on the recipients, which depending upon the
+                                    // visibility of the recipients editor, returns a different
+                                    // value (see getRecipients()).
+
+        updateSendButtonState();
+
+        drawTopPanel(false);
+        if (intentHandled) {
+            // We're not loading a draft, so we can draw the bottom panel immediately.
+            drawBottomPanel();
+        }
+
+        onKeyboardStateChanged();
+
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "update title, mConversation=" + mConversation.toString());
+        }
+
+        // no longer update title in onResume, so set "New Message" here.
+        updateTitle(new ContactList());
+
+        if (isForwardedMessage && isRecipientsEditorVisible()) {
+            // The user is forwarding the message to someone. Put the focus on the
+            // recipient editor rather than in the message editor.
+            mRecipientsEditor.requestFocus();
+        }
+
+        /// M: google JB.MR1 patch, group mms
+        boolean isGroupMms = mConversation.getRecipients().size() > 1;
+        mMsgListAdapter.setIsGroupConversation(isGroupMms);
+        mIpCompose.onIpInitialize(intent, mWorkingMessage);
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        if (requestAllPermissions()) {
+            mNeedRequestPermissins = true;
+            return;
+        }
+
+        MmsLog.dpi(TAG, "onNewIntent: intent = " + intent.toString());
+      /// M: add for fix ALPS01317511 @{
+        if (!mOpComposeExt.onNewIntent(intent, mHadToSlideShowEditor, mTempMmsUri, mWorkingMessage,
+                this, mRecipientsEditor, FolderViewList.OPTION_INBOX)) {
+            processNewIntent(intent);
+        }
+        /// @}
+    }
+
+   private void processNewIntent(Intent intent) {
+        setIntent(intent);
+        /// M: reload working message if it is not correct.
+        if (!mOpComposeExt.processNewIntent(intent)) {
+            if (!intent.getBooleanExtra(FORWARD_MESSAGE, false)) {
+                reloadWorkingMessage();
+                resetConfiguration(getResources().getConfiguration());
+            }
+        }
+
+        mWaitingAttachment = false;
+
+        if (mQuickTextDialog != null && mQuickTextDialog.isShowing()) {
+            mQuickTextDialog.dismiss();
+            mQuickTextDialog = null;
+        }
+
+        if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+            mSubSelectDialog.dismiss();
+            mSubSelectDialog = null;
+        }
+
+        Conversation conversation = null;
+        mSentMessage = false;
+
+        // If we have been passed a thread_id, use that to find our
+        // conversation.
+
+        // Note that originalThreadId might be zero but if this is a draft and we save the
+        // draft, ensureThreadId gets called async from WorkingMessage.asyncUpdateDraftSmsMessage
+        // the thread will get a threadId behind the UI thread's back.
+        long originalThreadId = mConversation.getThreadId();
+        long threadId = intent.getLongExtra("thread_id", 0);
+        Uri intentUri = intent.getData();
+
+        boolean sameThread = false;
+        if (threadId > 0) {
+            conversation = Conversation.get(getApplicationContext(), threadId, false);
+        } else {
+            if (mConversation.getThreadId() == 0) {
+                // We've got a draft. Make sure the working recipients are synched
+                // to the conversation so when we compare conversations later in this function,
+                // the compare will work.
+                mWorkingMessage.syncWorkingRecipients();
+            }
+            // Get the "real" conversation based on the intentUri. The intentUri might specify
+            // the conversation by a phone number or by a thread id. We'll typically get a threadId
+            // based uri when the user pull down a notification while in ComposeMessageActivity and
+            // we end up here in onNewIntent. mConversation can have a threadId of zero when we're
+            // working on a draft. When a new message comes in for that same recipient, a
+            // conversation will get created behind CMA's back when the message is inserted into
+            // the database and the corresponding entry made in the threads table. The code should
+            // use the real conversation as soon as it can rather than finding out the threadId
+            // when sending with "ensureThreadId".
+            conversation = Conversation.get(getApplicationContext(), intentUri, false);
+        }
+
+        /// M: Fix bug: ALPS00444760, The keyboard display under the MMS after
+        // you tap shortcut enter this thread.
+        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
+        /// @}
+
+        ///M @{
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "onNewIntent: data=" + intentUri + ", thread_id extra is " + threadId +
+                    ", new conversation=" + conversation + ", mConversation=" + mConversation);
+        }
+
+        // this is probably paranoid to compare both thread_ids and recipient lists,
+        // but we want to make double sure because this is a last minute fix for Froyo
+        // and the previous code checked thread ids only.
+        // (we cannot just compare thread ids because there is a case where mConversation
+        // has a stale/obsolete thread id (=1) that could collide against the new thread_id(=1),
+        // even though the recipient lists are different)
+        sameThread = ((conversation.getThreadId() == mConversation.getThreadId() ||
+                mConversation.getThreadId() == 0) &&
+                conversation.equals(mConversation));
+
+        if (sameThread) {
+            log("onNewIntent: same conversation");
+            /// M Fix CR:ALPS01081972 which cannot show received message in the composer @{
+            if (intent.getBooleanExtra("finish", false) == true) {
+                Activity compose = sCompose == null ? null : sCompose.get();
+                if (compose != null && !compose.isFinishing()) {
+                    Log.d("[Mms][ComposeMessageActivity]",
+                            "[onNewIntent] same conversation call finish composer");
+                    compose.finish();
+                    this.startActivity(intent);
+                    return;
+                }
+            }
+            /// @}
+            if (mConversation.getThreadId() == 0) {
+                mConversation = conversation;
+                mWorkingMessage.setConversation(mConversation);
+                updateThreadIdIfRunning();
+                invalidateOptionsMenu();
+            }
+        } else {
+            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                log("onNewIntent: different conversation");
+            }
+            /// M: @{
+            /// M: Don't let any markAsRead DB updates occur before we've loaded the messages for
+            /// M: the thread.
+            conversation.blockMarkAsRead(true);
+            /// @}
+            if ((!isRecipientsEditorVisible())
+                    || (mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms()))) {
+                    //For ALPS00457252
+                    if (!mWorkingMessage.isWorthSaving()) {
+                        mWorkingMessage.discard();
+                    } else {
+                        saveDraft(false); // if we've got a draft, save it first
+                    }
+            }
+            /// if is not the same thread, to cancel progress dialog @{
+            mUiHandler.removeCallbacks(this.mContactPickRunnable);
+            if (mContactPickDialog != null && mContactPickDialog.isShowing()) {
+                mContactPickDialog.dismiss();
+            }
+            mContactPickDialog = null;
+            /// @}
+            if (mAsyncDialog != null) {
+                mAsyncDialog.dismissProgressDialog();
+            }
+            /// if from shortcut, finish origin compoer, and start again @{
+            if (intent.getBooleanExtra("finish", false) == true) {
+                Activity compose = sCompose == null ? null : sCompose.get();
+                if (compose != null && !compose.isFinishing()) {
+                    Log.d("[Mms][ComposeMessageActivity]", "[onNewIntent] call finish composer");
+                    compose.finish();
+                    this.startActivity(intent);
+                    return;
+                }
+            }
+            /// @}
+            /// M: @{
+            mMsgListAdapter.changeCursor(null);
+            mConversation = conversation;
+            /// @}
+
+            initialize(null, originalThreadId, false);
+            /// M: add for attach dialog do not dismiss when enter other thread. @{
+            if (!mSoloAlertDialog.needShow()) {
+                mSoloAlertDialog.dismiss();
+            }
+            /// @}
+            /// M: fix bug ALPS00941735
+            mIsSameConv = false;
+            MmsLog.d(TAG, "onNewIntent not same thread");
+        }
+        loadMessageContent();
+
+        if (mMsgListAdapter != null && mMsgListAdapter.getCount() == 0) {
+            showKeyBoard(true);
+            if (mRecipientsEditor != null) {
+                mRecipientsEditor.requestFocus();
+            }
+        }
+   }
+
+    private void sanityCheckConversation() {
+        if (mWorkingMessage.getConversation() != mConversation) {
+            LogTag.warnPossibleRecipientMismatch(
+                    "ComposeMessageActivity: mWorkingMessage.mConversation=" +
+                    mWorkingMessage.getConversation() + ", mConversation=" +
+                    mConversation + ", MISMATCH!", this);
+        }
+    }
+
+    @Override
+    protected void onRestart() {
+        super.onRestart();
+
+        if (mNeedRequestPermissins) {
+            MmsLog.d(TAG, "onRestart() mNeedRequestPermissins return !!" + mNeedRequestPermissins);
+            return;
+        }
+        if (requestAllPermissions()) {
+            MmsLog.d(TAG, "onRestart() requestAllPermissions return !!");
+            mNeedRequestPermissins = true;
+            return;
+        }
+
+         /// M: For fix bug ALPS00542156 The "_" still display under the SubA after
+        /// you change it to the "Always ask" or "SubB.@{
+        sCompose = null;
+        sCompose = new WeakReference(this);
+        /// @}
+
+        if (mWorkingMessage != null && mWorkingMessage.isDiscarded()) {
+            // If the message isn't worth saving, don't resurrect it. Doing so can lead to
+            // a situation where a new incoming message gets the old thread id of the discarded
+            // draft. This activity can end up displaying the recipients of the old message with
+            // the contents of the new message. Recognize that dangerous situation and bail out
+            // to the ConversationList where the user can enter this in a clean manner.
+            mWorkingMessage.unDiscard();    // it was discarded in onStop().
+            if (mWorkingMessage.isWorthSaving()) {
+                if (LogTag.VERBOSE) {
+                    log("onRestart: mWorkingMessage.unDiscard()");
+                }
+                //mWorkingMessage.unDiscard();    // it was discarded in onStop().
+
+                sanityCheckConversation();
+            } else if (isRecipientsEditorVisible()) {
+                if (LogTag.VERBOSE) {
+                    log("onRestart: goToConversationList");
+                }
+                goToConversationList();
+            } else {
+                if (LogTag.VERBOSE) {
+                    log("onRestart: loadDraft");
+                }
+                /// M: @{
+                //loadDraft();
+                /// @}
+                mWorkingMessage.setConversation(mConversation);
+                mAttachmentEditor.update(mWorkingMessage);
+                updateTextEditorHeightInFullScreen();
+                invalidateOptionsMenu();
+            }
+        }
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        MmsLog.d(TAG, "onStart() enter!!");
+
+        if (mNeedRequestPermissins) {
+            return;
+        }
+
+        mIsActivityStoped = false;
+        boolean isSmsEnabled = MmsConfig.isSmsEnabled(this);
+        if (isSmsEnabled != mIsSmsEnabled) {
+            mIsSmsEnabled = isSmsEnabled;
+            invalidateOptionsMenu();
+        }
+        /// M: For fix bug ALPS00688631 The "_" still display under the SubA after
+        /// you change it to the "Always ask" or "SubB.@{
+        sCompose = null;
+        sCompose = new WeakReference(this);
+        /// @}
+        /// M Fix CR : ALPS01257113, when sub select dialog showed in default sms. after change to
+        /// non-default sms, dismiss the sub select dialog @{
+        if (!mIsSmsEnabled) {
+            if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+                mSubSelectDialog.dismiss();
+            }
+        }
+        /// @}
+
+        /// M: Code analyze 036, Change text size if adjust font size.@{
+        float textSize = MessageUtils.getPreferenceValueFloat(this,
+                SettingListActivity.TEXT_SIZE, 18);
+        setTextSize(textSize);
+        /// @}
+
+        /// M: Code analyze 013, Get contacts from Contact app . @{
+        misPickContatct = false;
+        /// @}
+        // M:for ALPS01065027,just for compose messagelist in scrolling
+        mMsgListView.setOnScrollListener(mScrollListener);
+        mScrollListener.setIsNeedRefresh(true);
+        mScrollListener.setThreadId(mConversation.getThreadId(), ComposeMessageActivity.this);
+        initFocus();
+
+        // Register a BroadcastReceiver to listen on HTTP I/O process.
+        registerReceiver(mHttpProgressReceiver, mHttpProgressFilter);
+        mOpComposeExt.onStart(this, this);
+        loadMessageContent();
+
+        // Update the fasttrack info in case any of the recipients' contact info changed
+        // while we were paused. This can happen, for example, if a user changes or adds
+        // an avatar associated with a contact.
+        /// M: @{
+        if (mConversation.getThreadId() == 0) {
+            mWorkingMessage.syncWorkingRecipients();
+        }
+        /// @}
+
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "onStart: update title, mConversation=" + mConversation.toString());
+        }
+
+        ActionBar actionBar = getActionBar();
+        /// M: Add log. @{
+        if (actionBar == null) {
+            MmsLog.e(TAG, "ACTION BAR is null, window feature FEATURE_ACTION_BAR: "
+                    + getWindow().hasFeature(Window.FEATURE_ACTION_BAR)
+                    + ", feature FEATURE_NO_TITLE: "
+                    + getWindow().hasFeature(Window.FEATURE_NO_TITLE));
+        } else {
+            actionBar.setDisplayHomeAsUpEnabled(true);
+        }
+        /// @}
+
+        /// M: Code analyze 047, Extra uri from message body and get number from uri.
+        /// Then use this number to update contact cache. @{
+        mNeedUpdateContactForMessageContent = true;
+        /// @}
+
+        /// M: Code analyze 001, Plugin opeartor. @{
+        new MmsDialogNotifyUtils(this).closeMsgDialog();
+        /// @}
+
+        if (isRecipientsEditorVisible() && mIsSmsEnabled &&
+                getResources().getConfiguration().orientation
+                    != Configuration.ORIENTATION_LANDSCAPE) {
+            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                    WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+        }
+        ///M: WFC: Show notification ticker @ {
+        if (ImsManager.isWfcEnabledByPlatform(getApplicationContext())) {
+//            MessagingNotification.showWfcNotification(getApplicationContext());
+        }
+        /// @}
+        if (mMsgListAdapter != null) {
+            mMsgListAdapter.setOnDataSetChangedListener(mDataSetChangedListener);
+        }
+        addRecipientsListeners();
+    }
+
+    public void loadMessageContent() {
+        // Don't let any markAsRead DB updates occur before we've loaded the messages for
+        // the thread. Unblocking occurs when we're done querying for the conversation
+        // items.
+        MmsLog.d(TAG, "loadMessageContent()");
+        ///M: for fix ALPS01026162, for folder mode, no content loaded.must not mark as read. @{
+        if (!FolderModeUtils.getMmsDirMode()) {
+            mConversation.blockMarkAsRead(true);
+            mConversation.markAsRead();         // dismiss any notifications for this convo
+            /// M: mark conversation as seen, update new messages notification.
+            /// M: fix bug ALPS01065220. onStart() will update message seen = 1.
+            /// But if before update start,
+            /// do not update it.{@
+            mConversation.setComposeIsPaused(false);
+            /// @}
+            mConversation.markAsSeen();
+        }
+        /// @}
+        startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 0);
+        updateSendFailedNotification();
+        updateDownloadFailedNotification();
+        drawBottomPanel();
+    }
+
+    private void updateSendFailedNotification() {
+        final long threadId = mConversation.getThreadId();
+        if (threadId <= 0)
+            return;
+
+        // updateSendFailedNotificationForThread makes a database call, so do the work off
+        // of the ui thread.
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                MessagingNotification.updateSendFailedNotificationForThread(
+                        ComposeMessageActivity.this, threadId);
+            }
+        }, "ComposeMessageActivity.updateSendFailedNotification").start();
+    }
+
+    private void updateDownloadFailedNotification() {
+        final long threadId = mConversation.getThreadId();
+        if (threadId <= 0)
+            return;
+
+        // updateSendFailedNotificationForThread makes a database call, so do the work off
+        // of the ui thread.
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                MessagingNotification.updateDownloadFailedNotificationForThread(
+                        ComposeMessageActivity.this, threadId);
+            }
+        }, "ComposeMessageActivity.updateSendFailedNotificationForThread").start();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        /// M: Code analyze 033, Save some useful information in order to restore the draft when
+        /// activity restarting.@{
+        // super is commented for a bug work around see MessageUtils.showErrorDialog()
+        super.onSaveInstanceState(outState); //why delete this line?
+        if (mNeedRequestPermissins) {
+            return;
+        }
+        String number = "";
+
+        mOpComposeExt.onSaveInstanceState(outState);
+
+        // save recipients of this coversation
+        if (mRecipientsEditor != null && isRecipientsEditorVisible()) {
+            // TODO need re-coding for below code
+            //outState.putString("recipients", mRecipientsEditor.allNumberToString());
+            /// M: We are compressing the image, so save the thread id in order to restore the
+            /// M: draft when activity restarting.
+            if (mCompressingImage) {
+                outState.putLong("thread", mConversation.ensureThreadId());
+            } else if (mRecipientsEditor.getRecipientCount() < 1) {
+                outState.putLong("thread", mConversation.ensureThreadId());
+                if ((mBackgroundQueryHandler != null) && (mConversation.getThreadId() > 0)) {
+                    Conversation.asyncDeleteObsoleteThreadID(
+                            mBackgroundQueryHandler, mConversation.getThreadId());
+                }
+            } else if (mRecipientsEditor.getRecipientCount() > 0) {
+                ArrayList<String> numbers = (ArrayList<String>) (mRecipientsEditor.getNumbers());
+                outState.putString("recipients", TextUtils.join(";", numbers.toArray()));
+            }
+        } else {
+            /// M: save the current thread id
+            outState.putLong("thread", mConversation.getThreadId());
+            MmsLog.i(TAG, "saved thread id:" + mConversation.getThreadId());
+        }
+        outState.putBoolean("compressing_image", mCompressingImage);
+        // add for ipmessage
+        mIpCompose.onIpSaveInstanceState(outState, mConversation.getThreadId());
+        /// @}
+        mWorkingMessage.writeStateToBundle(outState);
+
+        if (mExitOnSent) {
+            outState.putBoolean(KEY_EXIT_ON_SENT, mExitOnSent);
+        }
+        if (mForwardMessageMode) {
+            outState.putBoolean(KEY_FORWARDED_MESSAGE, mForwardMessageMode);
+        }
+        if (!mAppendAttachmentSign) {
+            MmsLog.d(TAG, "onSaveInstanceState mAppendAttachmentSign : " + mAppendAttachmentSign);
+            outState.putBoolean(KEY_APPEND_MESSAGE, mAppendAttachmentSign);
+        }
+        /// M: save cell progress dialog is showing or not
+        outState.putBoolean("cell_dialog_showing", mIsCellDialogShowing);
+    }
+
+    @Override
+    protected void onResume() {
+        /// M: fix bug ALPS00444752, set false to enable to Show ContactPicker
+        mShowingContactPicker = false;
+        super.onResume();
+        if (mNeedRequestPermissins) {
+            return;
+        }
+
+        mIsActivityPaused = false;
+        mNeedSaveDraftAfterStop = false;
+        boolean isSmsEnabled = MmsConfig.isSmsEnabled(this);
+        if (isSmsEnabled != mIsSmsEnabled) {
+            mIsSmsEnabled = isSmsEnabled;
+            invalidateOptionsMenu();
+        }
+        initFocus();
+        getAsyncDialog().resetShowProgressDialog();
+         /// M: Code analyze 005, Set input mode. @{
+        Configuration config = getResources().getConfiguration();
+        MmsLog.d(TAG, "onResume - config.orientation = " + config.orientation);
+        if (config.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+            MmsLog.e(TAG, "onResume Set setSoftInputMode to 0x" +
+                    Integer.toHexString(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                            WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN));
+            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                    WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
+        }
+        /// @}
+
+        /// M: Code analyze 024, If the click operator can be responsed. @{
+        //  button can response to start other activity
+        mClickCanResponse = true;
+        /// @}
+        /// M: Code analyze 038, If the user is editing slideshow now.
+        /// Do not allow the activity finish but return directly when back key is entered. @{
+        mIsEditingSlideshow = false;
+        /// @}
+        String text = null;
+        if (mWorkingMessage != null && mWorkingMessage.getText() != null) {
+            text = mWorkingMessage.getText().toString();
+        }
+
+        mOpComposeExt.initResourceRefsOnResume(
+                        (LinearLayout) findViewById(R.id.button_with_counter),
+                        (TextView) findViewById(R.id.ct_text_counter),
+                        mAttachmentEditor.mOpAttachmentEditorExt);
+
+        mOpComposeExt.onResume(mSubCount, text, mIsSmsEnabled,
+                mRecipientsEditor, mSubjectTextEditor);
+
+        if (mDrawBottomPanel) {
+            drawBottomPanel();
+        }
+        // OLD: get notified of presence updates to update the titlebar.
+        // NEW: we are using ContactHeaderWidget which displays presence, but updating presence
+        //      there is out of our control.
+        //Contact.startPresenceObserver();
+
+        //addRecipientsListeners();
+
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "onResume: update title, mConversation=" + mConversation.toString());
+        }
+
+        // There seems to be a bug in the framework such that setting the title
+        // here gets overwritten to the original title.  Do this delayed as a
+        // workaround.
+        if (isRecipientsEditorVisible()) {
+            asyncUpdateThreadMuteIcon();
+        } else {
+            new Thread(new Runnable() {
+                public void run() {
+                    /// M: Fix CR ALPS00558119
+                    /// When the Contact phone is long enough ,after add audio,
+                    /// The title will show only phony number @{
+                    ///@M:fix bug ALPS00871320 tablet has wide space to show more contact
+                    int limite = getLimitedContact();
+                    ///@
+                    final ContactList recipients = getRecipients();
+                    int min = Math.min(limite, recipients.size());
+                    MmsLog.d(TAG, "onResume reload recipients size = " + recipients.size());
+                    for (int i = 0; i < min; i++) {
+                        recipients.get(i).reload();
+                    }
+                    mMessageListItemHandler.postDelayed(new Runnable() {
+                        public void run() {
+                            updateTitle(recipients);
+                        }
+                    }, 10);
+                }
+            }).start();
+        }
+
+        mIsRunning = true;
+        updateThreadIdIfRunning();
+
+        // add for ipmessage
+        mIpCompose.onIpComposeActivityResume(isSmsEnabled,
+                mTextEditor, mTextEditorWatcher, mTextCounter,
+                mRecipientsEditor, mSubjectTextEditor);
+        /// M: just update state but didn't notify will miss some mms/sms switch toast.
+        //mWorkingMessage.updateStateForGroupMmsChanged();
+
+        updateSendButtonState();
+
+        if (mOldThreadID == -1 && mConversation != null) {
+            mOldThreadID = mConversation.getThreadId();
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        MmsLog.d(TAG, "onPause() enter!!");
+        if (mNeedRequestPermissins) {
+            return;
+        }
+        mIsActivityPaused = true;
+        if (FeatureOption.MTK_GMO_ROM_OPTIMIZE) {
+            MmsLog.d(TAG, "onPause() start Draft Service");
+            startService(new Intent(this, DraftService.class));
+        }
+        /// M: fix bug ALPS00421362. Allow any blocked calls to update the thread's read status.
+        /// M: fix bug ALPS01026162.for folder mode, no content loaded.must not mark as read.
+        if (this.isFinishing() && !isRecipientsEditorVisible()
+                && !FolderModeUtils.getMmsDirMode()) {
+            mConversation.blockMarkAsRead(false);
+            mConversation.markAsRead();
+        }
+
+        mDrawBottomPanel = true;
+
+        // OLD: stop getting notified of presence updates to update the titlebar.
+        // NEW: we are using ContactHeaderWidget which displays presence, but updating presence
+        //      there is out of our control.
+        //Contact.stopPresenceObserver();
+        //removeRecipientsListeners();
+
+        // remove any callback to display a progress spinner
+        if (mAsyncDialog != null) {
+            mAsyncDialog.clearPendingProgressDialog();
+        }
+
+        // Remember whether the list is scrolled to the end when we're paused so we can rescroll
+        // to the end when resumed.
+        if (mMsgListAdapter != null &&
+                mMsgListView.getLastVisiblePosition() >= mMsgListAdapter.getCount() - 1) {
+            mSavedScrollPosition = Integer.MAX_VALUE;
+        } else {
+            mSavedScrollPosition = mMsgListView.getFirstVisiblePosition();
+        }
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            Log.v(TAG, "onPause: mSavedScrollPosition=" + mSavedScrollPosition);
+        }
+
+        mIsRunning = false;
+        mErrorDialogShown = true;
+
+        // add for ipmessage
+        mIpCompose.onIpComposeActivityPause();
+
+        /// M: Stop in conversation notification sound
+        MessagingNotification.stopInConversationNotificationSound();
+        /// @}
+
+        checkObsoleteThreadId();
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+
+        if (mNeedRequestPermissins) {
+            MmsLog.d(TAG, "onStop() no permissions");
+            return;
+        }
+
+        mIsActivityStoped = true;
+//        mContentResolver.unregisterContentObserver(mDraftChangeObserver);
+        /// M: fix bug ALPS01065220. onStart() will update message seen = 1.
+        /// But if before update start,
+        /// do not update it.{@
+        mConversation.setComposeIsPaused(true);
+        /// @}
+        /// M: Code analyze 013, Get contacts from Contact app . @{
+        if (misPickContatct) {
+            stopDraftService();
+            return;
+        }
+        /// @}
+        // Allow any blocked calls to update the thread's read status.
+      /// M: fix bug ALPS01026162.for folder mode, no content loaded.must not mark as read.
+        if (!isRecipientsEditorVisible() && !FolderModeUtils.getMmsDirMode()) {
+            mConversation.blockMarkAsRead(false);
+            mConversation.markAsRead();
+        }
+
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            log("onStop: save draft");
+        }
+        MessagingNotification.setCurrentlyDisplayedThreadId(MessagingNotification.THREAD_NONE);
+        /// M: If image is being compressed, wait for it
+        if (isFinishing()) {
+            waitForCompressing();
+        }
+        /// M: @{
+        if ((!isRecipientsEditorVisible()) ||
+                (mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms()))) {
+            if (isWorthSaving() && MessageUtils.allowSafeDraft(this,
+                    MmsConfig.getDeviceStorageFullStatus(), false, TOAST_TYPE_FOR_SAVE_DRAFT)) {
+                if (!mCompressingImage) {
+                    saveDraft(true);
+                } else {
+                    mNeedSaveDraftAfterStop = true;
+                    log("onStop: skip save draft");
+                }
+                if (mConversation.getMessageCount() == 0) {
+                    ConversationListAdapter.removeSelectedState(mSelectedThreadId);
+                }
+            }
+        }
+        /// @}
+        /// M: @{
+        MmsWidgetProvider.notifyDatasetChanged(getApplicationContext());
+        MmsLog.i(TAG,
+                "onStop(): mWorkingMessage.isDiscarded() == " + mWorkingMessage.isDiscarded());
+        /// @}
+        // Cleanup the BroadcastReceiver.
+        unregisterReceiver(mHttpProgressReceiver);
+        /// M: fix bug ALPS00380930, fix RecipientsAdapter cursor leak @{
+        //if (mRecipientsEditor != null && isFinishing()) {
+        //    CursorAdapter recipientsAdapter = (CursorAdapter)mRecipientsEditor.getAdapter();
+        //    if (recipientsAdapter != null) {
+        //        recipientsAdapter.changeCursor(null);
+        //    }
+        //}
+        /// @}
+
+        // / M: fix bug ALPS00451836, remove FLAG_DISMISS_KEYGUARD flags
+        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD |
+                                   WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
+        stopDraftService();
+
+        ///M: WFC: Stop notification ticker @ {
+        if (ImsManager.isWfcEnabledByPlatform(getApplicationContext())) {
+//            MessagingNotification.stopWfcNotification(getApplicationContext());
+        }
+        if (mMsgListAdapter != null) {
+            MmsLog.d(TAG, "set OnDataSetChangedListener null");
+            mMsgListAdapter.setOnDataSetChangedListener(null);
+        }
+        removeRecipientsListeners();
+    }
+
+
+    private void dismissmDiscardDraftDialog() {
+        if (mDiscardDraftDialog != null && mDiscardDraftDialog.isShowing()) {
+            MmsLog.d(TAG, "dismissmDiscardDraftDialog");
+            mDiscardDraftDialog.dismiss();
+            mDiscardDraftDialog = null;
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        if (mNeedRequestPermissins) {
+            super.onDestroy();
+            MmsLog.d(TAG, "onDestroy() no permissions");
+            return;
+        }
+        dismissmDiscardDraftDialog();
+        /// it will not show draft icon in the conversationlist @{
+       if (!mWorkingMessage.isWorthSaving()) {
+                                   Log.i(TAG, "delete unsavedempty draft: ");
+            mWorkingMessage.discard();
+            mHasDiscardWorkingMessage = true;
+            new Thread(new Runnable() {
+               public void run() {
+                   long threadId = mConversation.getThreadId();
+                   boolean isHasDraft =
+                       DraftCache.refreshDraft(ComposeMessageActivity.this, threadId);
+                   Log.i(TAG, "onDestroy, nothing to be save, reset threadId : "
+                           + threadId + ", isHasDraft : " + isHasDraft);
+                   DraftCache.getInstance().setDraftState(threadId, isHasDraft);
+               }
+           }, "Composer.resetDraftCache").start();
+        }
+        stopDraftService();
+        /// M: fix bug ALPS00473488, delete ObsoleteThread through threadID when discard()
+        if (mConversation.getMessageCount() == 0
+                && (!mWorkingMessage.isWorthSaving()
+                        || mWorkingMessage.isDiscarded())
+                && isRecipientsEditorVisible()) {
+            Conversation.asyncDeleteObsoleteThreads(mBackgroundQueryHandler,
+                    ConversationList.DELETE_OBSOLETE_THREADS_TOKEN);
+            mConversation.setDiscardThreadId(0);
+        }
+        mIsStartMultiDeleteActivity = false;
+        /// @}
+        MmsLog.d(TAG, "onDestroy()");
+        if (TRACE) {
+            android.os.Debug.stopMethodTracing();
+        }
+
+        mUiHandler.removeCallbacks(mContactPickRunnable);
+        if (mContactPickDialog != null && mContactPickDialog.isShowing()) {
+            mContactPickDialog.dismiss();
+        }
+        mContactPickDialog = null;
+
+        unregisterReceiver(mSubReceiver);
+
+        /// @}
+        mDestroy = true;
+        mScrollListener.destroyThread();
+        /// M: Stop not started queries @{
+        if (mBackgroundQueryHandler != null) {
+            MmsLog.d(TAG, "clear pending queries in onDestroy");
+            mBackgroundQueryHandler.cancelOperation(MESSAGE_LIST_QUERY_TOKEN);
+            mBackgroundQueryHandler.removeCallbacks(mQueryMsgListRunnable);
+        }
+        /// @}
+        if (mMsgListAdapter != null) {
+            mMsgListAdapter.destroyTaskStack();
+            /// M: we need unregister cursor, so no more callback
+            mMsgListAdapter.changeCursor(null);
+        }
+        mIpCompose.onIpComposeActivityDestroy();
+        mOpComposeExt.onDestroy();
+
+        /// M: ALPS03562153 @{
+        if (mCreateFromSendTo == true) {
+            MmsLog.d(TAG, "to clear contact cache");
+            Contact.invalidateCache();
+        }
+        /// @}
+
+        super.onDestroy();
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        MmsLog.d(TAG, "onConfigurationChanged-Start");
+        super.onConfigurationChanged(newConfig);
+        if (mNeedRequestPermissins) {
+            return;
+        }
+        mIpCompose.onIpConfig(newConfig);
+        mOpComposeExt.onConfigurationChanged();
+        if (LOCAL_LOGV) {
+            Log.v(TAG, "onConfigurationChanged: " + newConfig);
+        }
+
+        if (resetConfiguration(newConfig)) {
+            // Have to re-layout the attachment editor because we have different layouts
+            // depending on whether we're portrait or landscape.
+            drawTopPanel(isSubjectEditorVisible());
+        }
+        onKeyboardStateChanged();
+        MmsLog.d(TAG, "onConfigurationChanged-End");
+    }
+
+    private boolean mUpdateForScrnOrientationChanged = false;
+    // returns true if landscape/portrait configuration has changed
+    private boolean resetConfiguration(Configuration config) {
+        mIsKeyboardOpen = config.keyboardHidden == KEYBOARDHIDDEN_NO;
+        boolean isLandscape = config.orientation == Configuration.ORIENTATION_LANDSCAPE;
+        mIpCompose.resetIpConfiguration(mIsLandscape, isLandscape, mIsSoftKeyBoardShow);
+        mOpComposeExt.resetConfiguration(mIsLandscape, isLandscape, mIsSoftKeyBoardShow);
+
+        /// M: Code analyze 004, Set max height for text editor. @{
+        if ((mTextEditor != null)
+                && (mTextEditor.getVisibility() == View.VISIBLE) && isLandscape) {
+            mUiHandler.postDelayed(new Runnable() {
+                public void run() {
+                    MmsLog.d(TAG, "resetConfiguration(): mTextEditor.setMaxHeight: "
+                            + mReferencedTextEditorThreeLinesHeight);
+                    mTextEditor.setMaxHeight(mReferencedTextEditorTwoLinesHeight *
+                            mCurrentMaxHeight / mReferencedMaxHeight);
+                }
+            }, 100);
+        }
+        /// @}
+
+        MmsLog.d(TAG, "resetConfiguration(): isLandscape = " + isLandscape + ", mIsKeyboardOpen = "
+                + mIsKeyboardOpen);
+
+        if (mIsLandscape != isLandscape) {
+            MmsLog.d(TAG, "resetConfiguration-mUpdateForScrnOrientationChanged mIsLandscape = "
+                    + mIsLandscape);
+            mUpdateForScrnOrientationChanged = true;
+            mIsLandscape = isLandscape;
+            return true;
+        }
+        return false;
+    }
+
+    private void onKeyboardStateChanged() {
+        // If the keyboard is hidden, don't show focus highlights for
+        // things that cannot receive input.
+        mTextEditor.setEnabled(mIsSmsEnabled);
+        if (!mIsSmsEnabled) {
+            if (mRecipientsEditor != null) {
+                mRecipientsEditor.setFocusableInTouchMode(false);
+                mRecipientsEditor.setIsTouchable(false);
+            }
+            if (mSubjectTextEditor != null) {
+                mSubjectTextEditor.setFocusableInTouchMode(false);
+            }
+            mTextEditor.setFocusableInTouchMode(false);
+            mTextEditor.setHint(R.string.sending_disabled_not_default_app);
+        } else if (mIsKeyboardOpen) {
+            if (mRecipientsEditor != null) {
+                mRecipientsEditor.setFocusableInTouchMode(true);
+                mRecipientsEditor.setIsTouchable(true);
+            }
+            if (mSubjectTextEditor != null) {
+                mSubjectTextEditor.setFocusableInTouchMode(true);
+            }
+            mTextEditor.setFocusableInTouchMode(true);
+            /// M: add for ip message
+            updateTextEditorHint();
+        } else {
+            if (mRecipientsEditor != null) {
+                mRecipientsEditor.setFocusable(false);
+                mRecipientsEditor.setIsTouchable(false);
+            }
+            if (mSubjectTextEditor != null) {
+                mSubjectTextEditor.setFocusable(false);
+            }
+            mTextEditor.setFocusable(false);
+            mTextEditor.setHint(R.string.open_keyboard_to_compose_message);
+        }
+    }
+
+    @Override
+    public void onUserInteraction() {
+        checkPendingNotification();
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        Log.d(TAG, "onKeyDown(): keyCode = " + keyCode);
+        if (mNeedRequestPermissins) {
+            return false;
+        }
+        if (mIpCompose != null && mIpCompose.onIpKeyDown(keyCode, event)) {
+            return true;
+        }
+        if (mOpComposeExt != null && mOpComposeExt.onKeyDown(keyCode, event)) {
+            return true;
+        }
+
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DEL:
+                if ((mMsgListAdapter != null) && (mMsgListView != null) && mMsgListView.isFocused()) {
+                    Cursor cursor;
+                    try {
+                        cursor = (Cursor) mMsgListView.getSelectedItem();
+                    } catch (ClassCastException e) {
+                        Log.e(TAG, "Unexpected ClassCastException.", e);
+                        return super.onKeyDown(keyCode, event);
+                    }
+
+                    if (cursor != null) {
+                        String type = cursor.getString(COLUMN_MSG_TYPE);
+                        long msgId = cursor.getLong(COLUMN_ID);
+                        MessageItem msgItem = mMsgListAdapter.getCachedMessageItem(type, msgId,
+                                cursor);
+                        if (msgItem != null) {
+                            DeleteMessageListener l = new DeleteMessageListener(msgItem);
+                            confirmDeleteDialog(l, msgItem.mLocked);
+                        }
+                        return true;
+                    }
+                }
+                break;
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+                /// M: @{
+                break;
+                /// @}
+            case KeyEvent.KEYCODE_ENTER:
+                /// M: Code analyze 028, Before sending message,check the recipients count
+                /// and add sub card selection dialog if multi sim cards exist.@{
+                /** Fix bug ALPS001070636
+                if (isPreparedForSending()) {
+                    checkRecipientsCount();
+                    return true;
+                } else {
+                    unpreparedForSendingAlert();
+                /// @}
+                }
+                **/
+                break;
+            case KeyEvent.KEYCODE_BACK:
+                /// M: Code analyze 038, If the user is editing slideshow now.
+                /// Do not allow the activity finish but return directly
+                /// when back key is entered. @{
+                if (mIsEditingSlideshow) {
+                    return true;
+                }
+                /// @}
+
+                // M: when out of composemessageactivity,try to send read report
+                if (FeatureOption.MTK_SEND_RR_SUPPORT) {
+                    checkAndSendReadReport();
+                }
+                /// @}
+                mIsCheckObsolete = true;
+                exitComposeMessageActivity(new Runnable() {
+                    @Override
+                    public void run() {
+                        finish();
+                    }
+                });
+                return true;
+            case KeyEvent.KEYCODE_MENU:
+                invalidateOptionsMenu();
+                return false;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    private void unpreparedForSendingAlert() {
+        if (!isHasRecipientCount()) {
+            new AlertDialog.Builder(this).setIconAttribute(
+                    android.R.attr.alertDialogIcon).setTitle(
+                    R.string.cannot_send_message).setMessage(
+                    R.string.cannot_send_message_reason).setPositiveButton(
+                    R.string.yes, new CancelSendingListener()).show();
+        } else {
+            new AlertDialog.Builder(this).setIconAttribute(
+                    android.R.attr.alertDialogIcon).setTitle(
+                    R.string.cannot_send_message).setMessage(
+                    R.string.cannot_send_message_reason_no_content)
+                    .setPositiveButton(R.string.yes,
+                            new CancelSendingListener()).show();
+        }
+    }
+
+    private void exitComposeMessageActivity(final Runnable exit) {
+          VideoThumbnailCache.clear();
+        // If the message is empty, just quit -- finishing the
+        // activity will cause an empty draft to be deleted.
+        if (!mWorkingMessage.isWorthSaving()) {
+            /// M: Code analyze 042, If you discard the draft message manually.@{
+            if (mMsgListAdapter.getCount() == 0) {
+                ConversationListAdapter.removeSelectedState(mSelectedThreadId);
+            }
+            mWorkingMessage.discard();
+            mHasDiscardWorkingMessage = true;
+            /// @}
+            /// M Fix CR: ALPS01222344. new message input a contact and some content,
+            /// incoming a messae which is the same contact as the draft.
+            /// it will not show draft icon in the conversationlist @{
+            new Thread(new Runnable() {
+                public void run() {
+                    long threadId = mConversation.getThreadId();
+                    boolean isHasDraft =
+                        DraftCache.refreshDraft(ComposeMessageActivity.this, threadId);
+                    Log.d(TAG, "exitComposeMessageActivity, nothing to be save, reset threadId : "
+                            + threadId + ", isHasDraft : " + isHasDraft);
+                    DraftCache.getInstance().setDraftState(threadId, isHasDraft);
+                }
+            }, "Composer.resetDraftCache").start();
+            /// @}
+            exit.run();
+            return;
+        }
+
+        if (isRecipientsEditorVisible() &&
+                !mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms())) {
+            mDiscardDraftDialog = MessageUtils.showDiscardDraftConfirmDialog(
+                                this, new DiscardDraftListener());
+            return;
+        }
+
+        if (needSaveDraft()) {
+            if (MessageUtils.allowSafeDraft(this, MmsConfig.getDeviceStorageFullStatus(), true,
+                    TOAST_TYPE_FOR_SAVE_DRAFT)) {
+                /// M: for requery searchactivity.
+                SearchActivity.setNeedRequery();
+                if (mIsSmsEnabled) {
+                    SearchActivity.setWaitSaveDraft();
+                }
+                DraftCache.getInstance().setSavingDraft(true);
+            }
+        }
+        mWorkingMessage.setNeedDeleteOldMmsDraft(true);
+        mToastForDraftSave = true;
+        exit.run();
+    }
+
+    private void goToConversationList() {
+        finish();
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (FolderModeUtils.getMmsDirMode()) {
+            Intent it = new Intent(this, FolderViewList.class);
+            it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                    | Intent.FLAG_ACTIVITY_SINGLE_TOP
+                    | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            it.putExtra("floderview_key", mHomeBox);
+            startActivity(it);
+        } else {
+        ///  @}
+        /// M: add extra flags
+        Intent it = new Intent(this, ConversationList.class);
+        it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_SINGLE_TOP
+                | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        startActivity(it);
+        }
+    }
+
+    private void hideRecipientEditor() {
+        if (mRecipientsEditor != null) {
+            Log.d(TAG, "hideRecipientEditor");
+            mRecipientsEditor.removeChipChangedListener(mChipWatcher);
+            mRecipientsEditor.setVisibility(View.GONE);
+            /// M: Code analyze 059, Set the pick button visible or
+            /// invisible the same as recipient editor.
+            mRecipientsPicker.setVisibility(View.GONE);
+            /// @}
+            hideOrShowTopPanel();
+            mRecipientsEditor.recycleBitmap();
+        }
+    }
+
+    private boolean isRecipientsEditorVisible() {
+        return (null != mRecipientsEditor)
+                    && (View.VISIBLE == mRecipientsEditor.getVisibility());
+    }
+
+    private boolean isSubjectEditorVisible() {
+        return (null != mSubjectTextEditor)
+                    && (View.VISIBLE == mSubjectTextEditor.getVisibility());
+    }
+
+    @Override
+    public void onAttachmentChanged() {
+        // Have to make sure we're on the UI thread. This function can be called off of the UI
+        // thread when we're adding multi-attachments
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                drawBottomPanel();
+                updateSendButtonState();
+                drawTopPanel(isSubjectEditorVisible());
+                if (null != mRecipientsEditor) {
+                    if (mWorkingMessage.hasSlideshow()) {
+                        mRecipientsEditor.setImeActionLabel(
+                                getString(MessageResource.string.ime_action_done),
+                                EditorInfo.IME_ACTION_DONE);
+                        mRecipientsEditor.setImeOptions(EditorInfo.IME_ACTION_DONE);
+                    } else {
+                        mRecipientsEditor.setImeActionLabel(
+                                getString(MessageResource.string.ime_action_next),
+                                EditorInfo.IME_ACTION_NEXT);
+                        mRecipientsEditor.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+                    }
+                }
+
+                mInputMethodManager.restartInput(mRecipientsEditor);
+            }
+        });
+    }
+    private boolean mIsConvertToastDelayed = false;
+    /// M: Code analyze 060, For bug ALPS00050082, When the protocol has been changed,
+    /// whether show a toast . @{
+    private boolean mIsConvertMms = false;
+    @Override
+    public void onProtocolChanged(final boolean mms, final boolean needToast) {
+        // Have to make sure we're on the UI thread. This function can be called off of the UI
+        // thread when we're adding multi-attachments
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                //toastConvertInfo(mms);
+                /// M: fix ALPS01033728, don't call showSmsOrMmsSendButton() here, method
+                /// updateSendButtonState() will call it.
+                //showSmsOrMmsSendButton(mms);
+                mIpCompose.onIpProtocolChanged(mms, needToast);
+                updateSendButtonState();
+
+                if (mOpComposeExt.onProtocolChanged(mms, mWorkingMessage.getText())) {
+                    if (mms) {
+                        // In the case we went from a long sms with a counter to an mms because
+                        // the user added an attachment or a subject, hide the counter --
+                        // it doesn't apply to mms.
+                        mTextCounter.setVisibility(View.GONE);
+                    } else {
+                        if (mTextEditor.getLineCount() <= 1) {
+                            mTextCounter.setVisibility(View.GONE);
+                        } else {
+                            mTextCounter.setVisibility(View.VISIBLE);
+                        }
+                    }
+                }
+
+                if (needToast) {
+                    if (mIsPopulatingRecipients) {
+                        mIsConvertToastDelayed = true;
+                        mIsConvertMms = mms;
+                    } else {
+                        toastConvertInfo(mms);
+                    }
+                }
+            }
+        });
+    }
+    /// @}
+
+    // Show or hide the Sms or Mms button as appropriate. Return the view so that the caller
+    // can adjust the enableness and focusability.
+    private View showSmsOrMmsSendButton(boolean isMms) {
+        View showButton = null;
+        View hideButton = null;
+        // add for ipmessage
+
+        if (isMms) {
+            if (mSubCount == 0 || (isRecipientsEditorVisible()
+                    && TextUtils.isEmpty(mRecipientsEditor.getText()))
+                    /// M: fix bug ALPS00563318, show gray mms_send_button
+                /// when haven't subject, text and attachment
+                || ((mSubjectTextEditor == null || (mSubjectTextEditor != null
+                        && TextUtils.isEmpty(mSubjectTextEditor.getText().toString().trim())))
+                        && mTextEditor != null
+                        && TextUtils.isEmpty(mTextEditor.getText().toString().trim())
+                        && !mWorkingMessage.hasAttachment())
+                        || !mIsSmsEnabled) {
+            mSendButtonMms.setCompoundDrawablesWithIntrinsicBounds(null, null, null,
+                getResources().getDrawable(R.drawable.ic_send_sms_unsend));
+        } else {
+            mSendButtonMms.setCompoundDrawablesWithIntrinsicBounds(null, null, null,
+                    getResources().getDrawable(R.drawable.ic_send_ipmsg));
+            }
+            showButton = mSendButtonMms;
+            hideButton = mSendButtonSms;
+        } else {
+            if (!mIpCompose.onIpShowSmsOrMmsSendButton(isMms)) {
+                if ((mTextEditor.getText().toString().isEmpty())
+                        || mSubCount == 0
+                        || (isRecipientsEditorVisible()
+                                && TextUtils.isEmpty(mRecipientsEditor.getText()))
+                        || recipientCount() > MmsConfig.getSmsRecipientLimit()
+                        || !mIsSmsEnabled) {
+                    ///@}
+                    mSendButtonSms.setImageResource(R.drawable.ic_send_sms_unsend);
+                } else {
+                    mSendButtonSms.setImageResource(R.drawable.ic_send_ipmsg);
+                }
+            }
+            showButton = mSendButtonSms;
+            hideButton = mSendButtonMms;
+        }
+
+        if (showButton != null) {
+            showButton.setVisibility(View.VISIBLE);
+        }
+        if (hideButton != null) {
+            hideButton.setVisibility(View.GONE);
+        }
+        updateTextEditorHint();
+        return showButton;
+    }
+
+    Runnable mResetMessageRunnable = new Runnable() {
+        @Override
+        public void run() {
+            resetMessage();
+        }
+    };
+
+    @Override
+    public void onPreMessageSent() {
+        runOnUiThread(mResetMessageRunnable);
+    }
+
+    @Override
+    public void onMessageSent() {
+        // This callback can come in on any thread; put it on the main thread to avoid
+        // concurrency problems
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                /// M: @{
+                mWaitingForSendMessage = false;
+                /// @}
+                // If we already have messages in the list adapter, it
+                // will be auto-requerying; don't thrash another query in.
+                // TODO: relying on auto-requerying seems unreliable when priming an MMS into the
+                // outbox. Need to investigate.
+//                if (mMsgListAdapter.getCount() == 0) {
+                    if (LogTag.VERBOSE) {
+                        log("onMessageSent");
+                    }
+                    startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 0);
+//                }
+
+                // The thread ID could have changed if this is a new message that we just inserted
+                // into the database (and looked up or created a thread for it)
+                updateThreadIdIfRunning();
+            }
+        });
+    }
+
+    @Override
+    public void onMaxPendingMessagesReached() {
+        saveDraft(false);
+
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(ComposeMessageActivity.this, R.string.too_many_unsent_mms,
+                        Toast.LENGTH_LONG).show();
+                mSendingMessage = false;
+                updateSendButtonState();
+            }
+        });
+    }
+
+    @Override
+    public void onAttachmentError(final int error) {
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                handleAddAttachmentError(error, R.string.type_picture);
+                onMessageSent();        // now requery the list of messages
+            }
+        });
+    }
+
+    // We don't want to show the "call" option unless there is only one
+    // recipient and it's a phone number.
+    private boolean isRecipientCallable() {
+        ContactList recipients = getRecipients();
+        if (mIpCompose.isIpRecipientCallable(recipients.getNumbers())) {
+            return true;
+        }
+        return (recipients.size() == 1 && !recipients.containsEmail());
+    }
+    /// M: Code analyze 061, Add video call menu.
+    private void dialRecipient(Boolean isVideoCall) {
+        if (isRecipientCallable()) {
+            String number = getRecipients().get(0).getNumber();
+            number = mIpCompose.dialIpRecipient(number);
+            Intent dialIntent ;
+            if (isVideoCall) {
+                dialIntent = new Intent(Intent.ACTION_CALL, Uri.parse("tel:" + number));
+                dialIntent.putExtra("com.android.phone.extra.video", true);
+            } else {
+                dialIntent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + number));
+            }
+            hideInputMethod();
+            startActivity(dialIntent);
+        }
+    }
+    /// @}
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        super.onPrepareOptionsMenu(menu) ;
+
+        if (mNeedRequestPermissins) {
+            return false;
+        }
+
+        menu.clear();
+        /// M: google JB.MR1 patch, group mms
+        if (mIsSmsEnabled) {
+            if (getRecipients().size() > 1) {
+                menu.add(0, MENU_GROUP_PARTICIPANTS, 0, R.string.menu_group_participants);
+            }
+        }
+
+        if (!isRecipientsEditorVisible()) {
+            MmsLog.d(TAG, "onPrepareOptionsMenu recipient editor is not visible!");
+            if (getRecipients().size() == 1) {
+                Contact contact = getRecipients().get(0);
+                contact.reload(true);
+                if (contact.existsInDatabase()) {
+                    MmsLog.dpi(TAG,
+                            "onPrepareOptionsMenu contact is in database: " + contact.getUri());
+                    menu.add(0, MENU_SHOW_CONTACT, 0, R.string.menu_view_contact)
+                        .setIcon(R.drawable.ic_menu_recipients)
+                        .setTitle(R.string.menu_view_contact)
+                        .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+                    mQuickContact.assignContactUri(contact.getUri());
+                } else if (MessageUtils.canAddToContacts(contact)) {
+                    menu.add(0, MENU_CREATE_CONTACT, 0, R.string.menu_add_to_contacts)
+                        .setIcon(R.drawable.ic_menu_recipients)
+                        .setTitle(R.string.menu_add_to_contacts)
+                        .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+                    String number = contact.getNumber();
+                    if (Mms.isEmailAddress(number)) {
+                        mQuickContact.assignContactFromEmail(number, true);
+                    } else {
+                        mQuickContact.assignContactFromPhone(number, true);
+                    }
+                }
+
+            }
+
+            if (mIsSmsEnabled) {
+                menu.add(0, MENU_SELECT_MESSAGE, 0, R.string.select_message);
+            }
+
+        }
+
+        /// M: Code analyze 061, Add video call menu.
+        TelephonyManager telephony =
+            (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+        if (telephony != null && telephony.isVoiceCapable() && isRecipientCallable()) {
+            MenuItem item = menu.add(0, MENU_CALL_RECIPIENT, 0, R.string.menu_call)
+                .setIcon(R.drawable.ic_menu_call)
+                .setTitle(R.string.menu_call);
+            if (!isRecipientsEditorVisible()) {
+                // If we're not composing a new message, show the call icon in the actionbar
+                item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+            }
+        /// @}
+        }
+
+        /// M: Code analyze 014, Add quick text. @{
+        if (mIsSmsEnabled) {
+            if (!mWorkingMessage.hasSlideshow()
+                    || (mSubjectTextEditor != null && mSubjectTextEditor.isFocused())) {
+                menu.add(0, MENU_ADD_QUICK_TEXT, 0, R.string.menu_insert_quick_text).setIcon(
+                    R.drawable.ic_menu_quick_text);
+            }
+        }
+        /// @}
+
+        /// M: Code analyze 015, Add text vcard. @{
+        if (mIsSmsEnabled) {
+            if (!mWorkingMessage.hasSlideshow()) {
+                menu.add(0, MENU_ADD_TEXT_VCARD, 0, R.string.menu_insert_text_vcard);
+            }
+        }
+        /// @}
+        if (mIsSmsEnabled) {
+            if (!isSubjectEditorVisible()) {
+                menu.add(0, MENU_ADD_SUBJECT, 0,
+                        R.string.add_subject).setIcon(R.drawable.ic_menu_edit);
+            }
+
+            menu.add(0, MENU_ADD_ATTACHMENT, 0, R.string.add_attachment)
+                    .setIcon(R.drawable.ic_menu_attachment)
+                .setTitle(R.string.add_attachment)
+                    .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);    // add to actionbar
+        }
+        buildAddAddressToContactMenuItem(menu);
+
+        if (LogTag.DEBUG_DUMP) {
+            menu.add(0, MENU_DEBUG_DUMP, 0, R.string.menu_debug_dump);
+        }
+
+        int contactSize = 0;
+        if (mConversation.getRecipients() != null) {
+            contactSize = mConversation.getRecipients().size();
+        }
+
+        if (isRecipientsEditorVisible() && mIsSmsEnabled) {
+            menu.add(0, MENU_DISCARD, 0, R.string.discard).setIcon(
+                android.R.drawable.ic_menu_delete);
+        }
+
+        mOpComposeExt.onPrepareOptionsMenu(menu, mIsSmsEnabled,
+                isRecipientsEditorVisible(), contactSize, mConversation.getThreadId());
+
+        // add for ipmessage
+        mIpCompose.onIpPrepareOptionsMenu(mConversation.getIpConv(this), menu);
+
+        return true;
+    }
+
+    private void buildAddAddressToContactMenuItem(Menu menu) {
+        // Look for the first recipient we don't have a contact for and create a menu item to
+        // add the number to contacts.
+        for (Contact c : getRecipients()) {
+            /// M: Code analyze 043, Whether the address can be added to contacts app. @{
+            if (!c.existsInDatabase() && MessageUtils.canAddToContacts(c)) {
+            /// @}
+                Intent intent = ConversationList.createAddContactIntent(c.getNumber());
+                menu.add(0, MENU_ADD_ADDRESS_TO_CONTACTS, 0, R.string.menu_add_to_contacts)
+                    .setIcon(android.R.drawable.ic_menu_add)
+                    .setIntent(intent);
+                break;
+            }
+        }
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (mNeedRequestPermissins) {
+            return false;
+        }
+        // add for ipmessage
+        if (mIpCompose.onIpMsgOptionsItemSelected(
+                mConversation.getIpConv(this), item, mConversation.getThreadId())) {
+            return true;
+        }
+        if (mOpComposeExt.onOptionsItemSelected(item, mWorkingMessage.mOpWorkingMessageExt,
+                mInputMethodManager)) {
+            return true;
+        }
+
+        switch (item.getItemId()) {
+            case MENU_ADD_SUBJECT:
+                showSubjectEditor(true);
+                mWorkingMessage.setSubject("", true);
+                /// M: Code analyze 052, Show input keyboard.@{
+                mInputMethodManager.showSoftInput(
+                        getCurrentFocus(), InputMethodManager.SHOW_IMPLICIT);
+                /// @}
+                updateSendButtonState();
+                mSubjectTextEditor.requestFocus();
+                break;
+            case MENU_ADD_ATTACHMENT:
+                // Launch the add-attachment list dialog
+                /// M: Code analyze 051, Hide input keyboard.@{
+                hideInputMethod();
+                showAddAttachmentDialog(!mWorkingMessage.hasAttachedFiles());
+                MmsLog.d(TAG, "Attach: showAddAttachmentDialog(!hasAttachedFiles)");
+                break;
+            /// M: Code analyze 014, Add quick text. @{
+            case MENU_ADD_QUICK_TEXT:
+                showQuickTextDialog();
+                break;
+            /// @}
+            /// M: Code analyze 015, Add text vcard. @{
+            case MENU_ADD_TEXT_VCARD: {
+                Intent intent =
+                    new Intent("android.intent.action.contacts.list.PICKMULTICONTACTS");
+                intent.setType(Contacts.CONTENT_TYPE);
+                startActivityForResult(intent, REQUEST_CODE_TEXT_VCARD);
+                break;
+            }
+            /// @}
+            case MENU_DISCARD:
+                /// M: fix bug for ConversationList select all performance,
+                /// update selected threads array.@{
+                ConversationListAdapter.removeSelectedState(mSelectedThreadId);
+                /// @}
+                /// M: Fix bug of inputmethod not disappear
+                hideInputMethod();
+                mWorkingMessage.discard();
+                finish();
+                break;
+            case MENU_SEND:
+                if (isPreparedForSending()) {
+                    /// M: Code analyze 028, Before sending message,check the recipients count
+                    /// and add sub card selection dialog if multi sub cards exist.@{
+                    updateSendButtonState(false);
+                    checkRecipientsCount();
+                    mSendButtonCanResponse = true;
+                    /// @}
+                }
+                break;
+            case MENU_SEARCH:
+                onSearchRequested();
+                break;
+            case MENU_DELETE_THREAD:
+                /// M: Code analyze 012, add for multi-delete @{
+                Intent it = new Intent(this, MultiDeleteActivity.class);
+                it.putExtra("thread_id", mConversation.getThreadId());
+                startActivityForResult(it, REQUEST_CODE_FOR_MULTIDELETE);
+                /// @}
+                break;
+
+            case android.R.id.home:
+                mIsCheckObsolete = true;
+                mConversation.setDiscardThreadId(mConversation.getThreadId());
+            case MENU_CONVERSATION_LIST:
+                exitComposeMessageActivity(new Runnable() {
+                    @Override
+                    public void run() {
+                        goToConversationList();
+                    }
+                });
+                break;
+            case MENU_CALL_RECIPIENT:
+                dialRecipient(false);
+                break;
+            /// M: Code analyze 061, Add video call menu.
+            case MENU_CALL_RECIPIENT_BY_VT:
+                dialRecipient(true);
+                break;
+            /// @}
+            /// M: google jb.mr1 patch, group mms
+            case MENU_GROUP_PARTICIPANTS: {
+                Intent intent = new Intent(this, RecipientListActivity.class);
+                intent.putExtra(THREAD_ID, mConversation.getThreadId());
+                startActivityForResult(intent, REQUEST_CODE_GROUP_PARTICIPANTS);
+                break;
+            }
+            case MENU_VIEW_CONTACT: {
+                // View the contact for the first (and only) recipient.
+                ContactList list = getRecipients();
+                if (list.size() == 1 && list.get(0).existsInDatabase()) {
+                    Uri contactUri = list.get(0).getUri();
+                    Intent intent = new Intent(Intent.ACTION_VIEW, contactUri);
+                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                    startActivity(intent);
+                }
+                break;
+            }
+            case MENU_ADD_ADDRESS_TO_CONTACTS:
+                mAddContactIntent = item.getIntent();
+                startActivityForResult(mAddContactIntent, REQUEST_CODE_ADD_CONTACT);
+                break;
+            case MENU_PREFERENCES: {
+                Intent settingIntent = null;
+                settingIntent = new Intent(this, SettingListActivity.class);
+                startActivityIfNeeded(settingIntent, -1);
+                break;
+            }
+            case MENU_DEBUG_DUMP:
+                mWorkingMessage.dump();
+                Conversation.dump();
+                LogTag.dumpInternalTables(this);
+                break;
+            case MENU_ADD_TO_CONTACTS: {
+                mAddContactIntent =
+                    ConversationList.createAddContactIntent(getRecipients().get(0).getNumber());
+                startActivityForResult(mAddContactIntent, REQUEST_CODE_ADD_CONTACT);
+                break;
+            }
+            /// M: show contact detail or create new contact. @{
+            case MENU_SHOW_CONTACT:
+            case MENU_CREATE_CONTACT:
+                hideInputMethod();
+                mQuickContact.onClick(mActionBarCustomView);
+                break;
+            /// @}
+            case MENU_SELECT_MESSAGE:
+                Intent intentSelectMessage = new Intent(this, MultiDeleteActivity.class);
+                intentSelectMessage.putExtra("thread_id", mConversation.getThreadId());
+                startActivityForResult(intentSelectMessage, REQUEST_CODE_FOR_MULTIDELETE);
+                mIsStartMultiDeleteActivity = true;
+                break;
+            default:
+                MmsLog.d(TAG, "unkown option.");
+                break;
+        }
+
+        return true;
+    }
+
+    private void addAttachment(int type, boolean append) {
+        if (!MessageUtils.allowSafeDraft(this, MmsConfig.getDeviceStorageFullStatus(), true,
+                TOAST_TYPE_FOR_ATTACH)) {
+            return;
+        }
+        mWaitingAttachment = true;
+        // Calculate the size of the current slide if we're doing a replace so the
+        // slide size can optionally be used in computing how much room is left for an attachment.
+        int currentSlideSize = 0;
+        SlideshowModel slideShow = mWorkingMessage.getSlideshow();
+
+        /// M: Code analyze 025, Add video or audio attachment and check the attachment size.@{
+        if (append) {
+            mAppendAttachmentSign = true;
+        } else {
+            mAppendAttachmentSign = false;
+        }
+        /// @}
+
+        if (slideShow != null) {
+            if (!(append && type == AttachmentTypeSelectorAdapter.ADD_SOUND)) {
+                WorkingMessage.removeThumbnailsFromCache(slideShow);
+            }
+            SlideModel slide = slideShow.get(0);
+            currentSlideSize = slide == null ? 0 : slide.getSlideSize();
+        }
+        /// M: Code analyze 025, Add video or audio attachment and check the attachment size.@{
+        if ((type != AttachmentTypeSelectorAdapter.ADD_SLIDESHOW)
+                && (type != AttachmentTypeSelectorAdapter.ADD_VCARD)
+            && (!checkSlideCount(mAppendAttachmentSign))) {
+            return;
+        }
+        /// @}
+        switch (type) {
+            case AttachmentTypeSelectorAdapter.ADD_IMAGE:
+                MessageUtils.selectImage(this, REQUEST_CODE_ATTACH_IMAGE);
+                break;
+
+            case AttachmentTypeSelectorAdapter.TAKE_PICTURE: {
+                MessageUtils.capturePicture(this, REQUEST_CODE_TAKE_PICTURE);
+                break;
+            }
+
+            case AttachmentTypeSelectorAdapter.ADD_VIDEO:
+                MessageUtils.selectVideo(this, REQUEST_CODE_ATTACH_VIDEO);
+                break;
+
+            case AttachmentTypeSelectorAdapter.RECORD_VIDEO: {
+                /// M: Code analyze 025, Add video or audio attachment
+                /// and check the attachment size.@{
+                long sizeLimit = 0;
+                if (mAppendAttachmentSign) {
+                    sizeLimit = computeAttachmentSizeLimit(slideShow, 0);
+                } else {
+                    sizeLimit = computeAttachmentSizeLimit(slideShow, currentSlideSize);
+                }
+                /// M: fix bug ALPS01221817 & ALPS01231411, Should subtract mText Size
+                if ((slideShow == null || !mAppendAttachmentSign)
+                        && !TextUtils.isEmpty(mWorkingMessage.getText())) {
+                    int textSize = mWorkingMessage.getText().toString().getBytes().length;
+                    sizeLimit -= textSize;
+                }
+                if (sizeLimit > MIN_SIZE_FOR_CAPTURE_VIDEO) {
+                    MessageUtils.recordVideo(this, REQUEST_CODE_TAKE_VIDEO, sizeLimit);
+                } else {
+                    Toast.makeText(this,
+                            getString(R.string.space_not_enough),
+                            Toast.LENGTH_SHORT).show();
+                }
+                /// @}
+            }
+            break;
+
+            case AttachmentTypeSelectorAdapter.ADD_SOUND:
+                /// M: Code analyze 018, Add ringtone for sound attachment.  @{
+                //MessageUtils.selectAudio(this, REQUEST_CODE_ATTACH_SOUND);
+                AlertDialog.Builder alertBuilder = new AlertDialog.Builder(this);
+                alertBuilder.setTitle(getString(R.string.add_music));
+                String[] items = new String[2];
+                items[0] = getString(R.string.attach_ringtone);
+                items[1] = getString(R.string.attach_sound);
+                alertBuilder.setItems(items, new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        switch (which) {
+                            case 0:
+                                MessageUtils.selectRingtone(ComposeMessageActivity.this,
+                                        REQUEST_CODE_ATTACH_RINGTONE);
+                                break;
+                            case 1:
+                                if (!Environment.getExternalStorageState()
+                                        .equals(Environment.MEDIA_MOUNTED)) {
+                                    Toast.makeText(ComposeMessageActivity.this,
+                                                    getString(R.string.Insert_sdcard),
+                                                    Toast.LENGTH_LONG).show();
+                                    return;
+                                }
+                                MessageUtils.selectAudio(ComposeMessageActivity.this,
+                                        REQUEST_CODE_ATTACH_SOUND);
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                });
+                alertBuilder.create().show();
+               /// @}
+                break;
+
+            case AttachmentTypeSelectorAdapter.RECORD_SOUND:
+                /// M: Code analyze 025, Add video or audio attachment
+                /// and check the attachment size.@{
+                long sizeLimit = 0;
+                if (mAppendAttachmentSign) {
+                    sizeLimit = computeAttachmentSizeLimit(slideShow, 0);
+                } else {
+                    sizeLimit = computeAttachmentSizeLimit(slideShow, currentSlideSize);
+                }
+                /// M: fix bug ALPS01221817 & ALPS01231411, Should subtract mText Size
+                if ((slideShow == null || !mAppendAttachmentSign)
+                        && !TextUtils.isEmpty(mWorkingMessage.getText())) {
+                    int textSize = mWorkingMessage.getText().toString().getBytes().length;
+                    sizeLimit -= textSize;
+                }
+                if (sizeLimit > ComposeMessageActivity.MIN_SIZE_FOR_RECORD_AUDIO) {
+                    MessageUtils.recordSound(this, REQUEST_CODE_RECORD_SOUND, sizeLimit);
+                } else {
+                    Toast.makeText(this, getString(R.string.space_not_enough_for_audio),
+                            Toast.LENGTH_SHORT).show();
+                }
+                /// @}
+                break;
+
+            case AttachmentTypeSelectorAdapter.ADD_SLIDESHOW:
+                editSlideshow();
+                break;
+            /// M: Code analyze 019, Add vcard attachment.@{
+            case AttachmentTypeSelectorAdapter.ADD_VCARD:
+                Intent intent =
+                    new Intent("android.intent.action.contacts.list.PICKMULTICONTACTS");
+                intent.setType(Contacts.CONTENT_TYPE);
+                startActivityForResult(intent, REQUEST_CODE_ATTACH_VCARD);
+                break;
+            /// @}
+            /// M: Code analyze 020, Add vcalendar attachment.  @{
+            case AttachmentTypeSelectorAdapter.ADD_VCALENDAR:
+                Intent i = new Intent("android.intent.action.CALENDARCHOICE");
+                i.setType("text/x-vcalendar");
+                i.putExtra("request_type", 0);
+                startActivityForResult(i, REQUEST_CODE_ATTACH_VCALENDAR);
+                break;
+            /// @}
+            default:
+                break;
+        }
+    }
+
+    public static long computeAttachmentSizeLimit(SlideshowModel slideShow, int currentSlideSize) {
+        // Computer attachment size limit. Subtract 1K for some text.
+        /// M: Code analyze 003,  Set or get max mms size.
+        long sizeLimit = MmsConfig.getUserSetMmsSizeLimit(true) - SlideshowModel.SLIDESHOW_SLOP;
+        /// @}
+        if (slideShow != null) {
+            sizeLimit -= slideShow.getCurrentSlideshowSize();
+
+            // We're about to ask the camera to capture some video (or the sound recorder
+            // to record some audio) which will eventually replace the content on the current
+            // slide. Since the current slide already has some content (which was subtracted
+            // out just above) and that content is going to get replaced, can add the size of the
+            // current slide into the available space used to capture a video (or audio).
+            sizeLimit += currentSlideSize;
+        } else {
+            sizeLimit -= MmsSizeUtils.getSlideshowHeaderSize();
+        }
+        return sizeLimit;
+    }
+
+    private void showAddAttachmentDialog(final boolean append) {
+        /// M: Code analyze 009,Show attachment dialog . Create a new class to @{
+        mSoloAlertDialog.show(append);
+        /// @}
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+            log("requestCode=" + requestCode + ", resultCode=" + resultCode + ", data=" + data);
+        if (!isAllPermissionGranted() || mWorkingMessage == null) {
+            return;
+        }
+        mWaitingForSubActivity = false;          // We're back!
+
+        /// M : FIX CR : ALPS01795853 @{
+        mWorkingMessage.setTruntoChooseAttach(false);
+        ///@}
+
+        // M: fix bug ALPS00354728
+        boolean mNeedAppendAttachment = true;
+
+        MmsLog.d(TAG, "onActivityResult mAppendAttachmentSign : " + mAppendAttachmentSign);
+        if (mAppendAttachmentSign) {
+            mNeedAppendAttachment = true;
+        } else if (!mAppendAttachmentSign) {
+            mNeedAppendAttachment = false;
+        }
+
+        /// @}
+        if (mWorkingMessage.isFakeMmsForDraft()) {
+            // We no longer have to fake the fact we're an Mms. At this point we are or we aren't,
+            // based on attachments and other Mms attrs.
+            mWorkingMessage.removeFakeMmsForDraft();
+        }
+
+        // add for ipmessage
+        mIpCompose.onIpMsgActivityResult(this, requestCode, resultCode, data);
+
+         /// M: Code analyze 012, add for multi-delete @{
+         if (requestCode == REQUEST_CODE_FOR_MULTIDELETE && resultCode == RESULT_OK) {
+             ContactList recipients = mConversation.getRecipients();
+             mConversation = Conversation.upDateThread(getApplicationContext(),
+                     mConversation.getThreadId(), false);
+             mIsStartMultiDeleteActivity = false;
+             if (mConversation.getMessageCount() <= 0 || mConversation.getThreadId() <= 0) {
+                 mMsgListAdapter.changeCursor(null);
+                 if (needSaveDraft() && (recipients != null)) {
+                     makeDraftEditable(recipients);
+                 } else {
+                     mWorkingMessage.discard();
+
+                     /// M: Rebuild the contacts cache now that a thread and its associated unique
+                     /// M: recipients have been deleted.
+                     Contact.init(getApplicationContext());
+
+                     /// M: Make sure the conversation cache reflects the threads in the DB.
+                     Conversation.init(getApplicationContext());
+                     /// M: fix bug for ConversationList select all performance,
+                     /// update selected threads array.@{
+                     ConversationListAdapter.removeSelectedState(mSelectedThreadId);
+                     /// @}
+                     finish();
+                 }
+             }
+            return;
+        }
+        /// @}
+        if (requestCode == REQUEST_CODE_PICK && MmsConfig.isSmsEnabled(this)) {
+            mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
+        }
+
+        /// M: fix bug ALPS00490684, update group mms state from GROUP_PARTICIPANTS to setting @{
+        if (requestCode == REQUEST_CODE_GROUP_PARTICIPANTS) {
+            boolean multiRecipients = mConversation.getRecipients().size() > 1;
+            boolean isGroupMms = MmsPreferenceActivity.getIsGroupMmsEnabled(
+                    ComposeMessageActivity.this) && multiRecipients;
+            mMsgListAdapter.setIsGroupConversation(isGroupMms);
+            mWorkingMessage.setHasMultipleRecipients(multiRecipients, true);
+            mWorkingMessage.deleteGruoupMmsDraft();
+        }
+        /// @}
+
+        if (requestCode == REQUEST_CODE_ADD_CONTACT) {
+            // The user might have added a new contact. When we tell contacts to add a contact
+            // and tap "Done", we're not returned to Messaging. If we back out to return to
+            // messaging after adding a contact, the resultCode is RESULT_CANCELED. Therefore,
+            // assume a contact was added and get the contact and force our cached contact to
+            // get reloaded with the new info (such as contact name). After the
+            // contact is reloaded, the function onUpdate() in this file will get called
+            // and it will update the title bar, etc.
+            if (!isRecipientsEditorVisible()) {
+                if (mAddContactIntent != null) {
+                    String address =
+                        mAddContactIntent.getStringExtra(ContactsContract.Intents.Insert.EMAIL);
+                    if (address == null) {
+                        address = mAddContactIntent.getStringExtra(
+                                ContactsContract.Intents.Insert.PHONE);
+                    }
+                    if (address != null) {
+                        Contact contact = Contact.get(address, false);
+                        if (contact != null) {
+                            contact.reload();
+                        }
+                    }
+                }
+            }
+        }
+
+        if (resultCode != RESULT_OK && requestCode == REQUEST_CODE_CREATE_SLIDESHOW
+                && mWorkingMessage != null) {
+            mWorkingMessage.setForceUpdateThreadId(true);
+        }
+
+        if (resultCode != RESULT_OK) {
+            if (LogTag.VERBOSE) log("bail due to resultCode=" + resultCode);
+            mWaitingAttachment = false;
+            return;
+        }
+
+        /// M: disable when non-default sms
+        if (!MmsConfig.isSmsEnabled(this) && requestCode != REQUEST_CODE_ECM_EXIT_DIALOG
+                && requestCode != REQUEST_CODE_MULTI_SAVE
+                && requestCode != REQUEST_CODE_CREATE_SLIDESHOW) {
+            Toast.makeText(ComposeMessageActivity.this,
+                    R.string.compose_disabled_toast, Toast.LENGTH_SHORT).show();
+            return;
+        }
+
+        WorkingMessage newMessage = null;
+        IOpWorkingMessageExt newOpWorkingMessageExt = null;
+        if (requestCode == REQUEST_CODE_CREATE_SLIDESHOW && data != null) {
+            newMessage = WorkingMessage.load(this, data.getData());
+            if (newMessage != null) {
+                newOpWorkingMessageExt = newMessage.mOpWorkingMessageExt;
+            }
+        }
+
+        if (mOpComposeExt.onActivityResult(requestCode, data, newOpWorkingMessageExt,
+                mWorkingMessage.mOpWorkingMessageExt)) {
+            //return;
+        }
+
+        switch (requestCode) {
+            case REQUEST_CODE_CREATE_SLIDESHOW:
+                if (data != null) {
+                    mWaitingAttachment = false;
+                    int slideSize = 0;
+                    if (newMessage != null && newMessage.getSlideshow() != null) {
+                        slideSize = newMessage.getSlideshow().size();
+                        MmsLog.i(TAG, "REQUEST_CODE_CREATE_SLIDESHOW" +
+                                    " newWorkingMessage Slideshow num = " + slideSize);
+                    } else {
+                        MmsLog.i(TAG, "REQUEST_CODE_CREATE_SLIDESHOW" +
+                                " newWorkingMessage Slideshow = null or newMessage = null");
+                    }
+
+                    if (newMessage != null) {
+                        /// M: Code analyze 053, If exist vcard attachment, move it before
+                        /// creating a new slideshow.Because the Workingmessage object  has been
+                        /// changed, reset subject and tell the convertion to user.@{
+                        /// M: add for vcard, vcard is exclusive with other attach, so remove them
+                        if (newMessage.hasMediaAttachments()) {
+                            newMessage.removeAllFileAttaches();
+                        }
+                        boolean isMmsBefore = mWorkingMessage.requiresMms();
+                        newMessage.setSubject(mWorkingMessage.getSubject(), false);
+
+                        /// M: fix bug ALPS01265824, need remove FileAttachment
+                        /// when text + attachmentSize > limit
+                        if (newMessage.isRemoveFileAttachment()) {
+                            int[] params = null;
+                            int encodingType = SmsMessage.ENCODING_UNKNOWN;
+                            encodingType = mOpComposeExt.getSmsEncodingType(encodingType,
+                                    ComposeMessageActivity.this);
+                            params = SmsMessage.calculateLength(newMessage.getText(),
+                                    false, encodingType);
+                            final int msgCount = params[0];
+                            newMessage.setLengthRequiresMms(
+                                    msgCount >= MmsConfig.getSmsToMmsTextThreshold(), false);
+
+                            newMessage.removeAllFileAttaches();
+                            newMessage.correctAttachmentState();
+                        }
+
+                        mWorkingMessage = newMessage;
+                        updateThreadIdIfRunning();
+                        drawTopPanel(isSubjectEditorVisible());
+                        updateSendButtonState();
+                        invalidateOptionsMenu();
+
+                        boolean isMmsAfter = mWorkingMessage.requiresMms();
+                        if (!isMmsAfter) {
+                            mWorkingMessage.asyncDeleteDraftMmsMessage(
+                                    newMessage.getConversation().getThreadId());
+                            DraftCache.getInstance().setDraftState(
+                                    newMessage.getConversation().getThreadId(), false);
+                        }
+                        if (isMmsAfter && !isMmsBefore) {
+                            toastConvertInfo(true);
+                        } else if (!isMmsAfter && isMmsBefore) {
+                            toastConvertInfo(false);
+                        } else if (!isMmsAfter && !isMmsBefore) {
+                            mWorkingMessage.setForceUpdateThreadId(true);
+                        }
+                        /// @}
+
+                        if (null != mRecipientsEditor) {
+                            if (mWorkingMessage.hasSlideshow()) {
+                                mRecipientsEditor.setImeActionLabel(
+                                        getString(MessageResource.string.ime_action_done),
+                                        EditorInfo.IME_ACTION_DONE);
+                                mRecipientsEditor.setImeOptions(EditorInfo.IME_ACTION_DONE);
+                            } else {
+                                mRecipientsEditor.setImeActionLabel(
+                                        getString(MessageResource.string.ime_action_next),
+                                        EditorInfo.IME_ACTION_NEXT);
+                                mRecipientsEditor.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+                            }
+                        }
+                    }
+                }
+                // M: fix bug ALPS00354728
+                MmsLog.i(TAG, "mNeedAppendAttachment = " + mNeedAppendAttachment);
+
+                break;
+
+            case REQUEST_CODE_TAKE_PICTURE: {
+                // create a file based uri and pass to addImage(). We want to read the JPEG
+                // data directly from file (using UriImage) instead of decoding it into a Bitmap,
+                // which takes up too much memory and could easily lead to OOM.
+
+                /// M: fix bug ALPS00408589
+                String scrappath = TempFileProvider.getScrapPath(this);
+                if (scrappath != null) {
+                    File file = new File(scrappath);
+                    Uri uri = Uri.fromFile(file);
+
+                    // Remove the old captured picture's thumbnail from the cache
+                    MmsApp.getApplication().getThumbnailManager().removeThumbnail(uri);
+
+                    addImageAsync(uri, mNeedAppendAttachment);
+                }
+                break;
+            }
+
+            case REQUEST_CODE_ATTACH_IMAGE: {
+                if (data != null) {
+                    addImageAsync(data.getData(), mNeedAppendAttachment);
+                }
+                break;
+            }
+            case REQUEST_CODE_TAKE_VIDEO:
+                Uri videoUri = TempFileProvider.renameScrapVideoFile(System.currentTimeMillis()
+                        + ".3gp", null, this);
+                // Remove the old captured video's thumbnail from the cache
+                MmsApp.getApplication().getThumbnailManager().removeThumbnail(videoUri);
+
+                addVideoAsync(videoUri, mNeedAppendAttachment);      // can handle null videoUri
+                break;
+
+            case REQUEST_CODE_ATTACH_VIDEO:
+                if (data != null) {
+                    addVideoAsync(data.getData(), mNeedAppendAttachment);
+                }
+                break;
+
+            case REQUEST_CODE_ATTACH_SOUND: {
+                Uri uri = (Uri) data.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);
+                if (Settings.System.getUriFor(Settings.System.RINGTONE).equals(uri)) {
+                    break;
+                }
+                addAudioAsync(data.getData(), mNeedAppendAttachment);
+                break;
+            }
+
+            case REQUEST_CODE_RECORD_SOUND:
+                if (data != null) {
+                    addAudioAsync(data.getData(), mNeedAppendAttachment);
+                }
+                break;
+
+            /// M: @{
+            case REQUEST_CODE_ATTACH_RINGTONE:
+                Uri uri = (Uri) data.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);
+                if (Settings.System.getUriFor(Settings.System.RINGTONE).equals(uri)) {
+                    break;
+                }
+                addAudioAsync(uri, mNeedAppendAttachment);
+                break;
+            /// @}
+
+            case REQUEST_CODE_ECM_EXIT_DIALOG:
+                boolean outOfEmergencyMode = data.getBooleanExtra(EXIT_ECM_RESULT, false);
+                if (outOfEmergencyMode) {
+                    sendMessage(false);
+                }
+                break;
+
+            case REQUEST_CODE_PICK:
+                /// M: Code analyze 013, Get contacts from Contact app . @{
+                if (data != null) {
+                    if (mRecipientsEditor != null) {
+                        processPickResult(data);
+                    } else {
+                        mIsRecipientHasIntentNotHandle = true;
+                        mIntent = data;
+                    }
+                }
+                misPickContatct = false;
+                return;
+                /// @}
+            /// M: Code analyze 015, Add text vcard. @{
+            case REQUEST_CODE_TEXT_VCARD:
+                if (data != null) {
+                    long[] contactIds =
+                        data.getLongArrayExtra("com.mediatek.contacts.list.pickcontactsresult");
+                    addTextVCardAsync(contactIds);
+                } else {
+                    MmsLog.wpi(TAG, "data should not be null," + "requestCode=" + requestCode
+                            + ", resultCode=" + resultCode + ", data=" + data);
+                }
+                misPickContatct = false;
+                return;
+            /// @}
+            /// M: Code analyze 019, Add vcard attachment.@{
+            case REQUEST_CODE_ATTACH_VCARD:
+                asyncAttachVCardByContactsId(data);
+                misPickContatct = false;
+                isInitRecipientsEditor = false;
+                return;
+            /// @}
+            /// M: Code analyze 020, Add vcalendar attachment.  @{
+            case REQUEST_CODE_ATTACH_VCALENDAR:
+                asyncAttachVCalendar(data.getData());
+                misPickContatct = false;
+                isInitRecipientsEditor = false;
+                return;
+            /// @}
+            /// M: Code analyze 021, Copy all valid parts of the attachment(pdu) to SD card.
+            /// This opeartor will be removed to a separate activity.  @{
+            case REQUEST_CODE_MULTI_SAVE:
+                boolean succeeded = false;
+                if (data != null && data.hasExtra("multi_save_result")) {
+                    succeeded = data.getBooleanExtra("multi_save_result", false);
+                    int resId =
+                        succeeded ? R.string.copy_to_sdcard_success : R.string.copy_to_sdcard_fail;
+                    Toast.makeText(ComposeMessageActivity.this, resId, Toast.LENGTH_SHORT).show();
+                }
+                return;
+            /// @}
+            default:
+                if (LogTag.VERBOSE) log("bail due to unknown requestCode=" + requestCode);
+                break;
+        }
+        /// M: @{
+        isInitRecipientsEditor = false; /// why add this variable here???
+    }
+
+    /**
+     * Handle duplicate selected contacts and put new selected contact to list.
+     * @param mSelectContactsNumbers the result of selected contacts number.
+     * @param editor the current recipientEditor.
+     * @param contactsId the result of selected contacts id.
+     * @param list the new select contacts.
+     * @param allList all contacts.
+     * @return whether has duplicate recipients.
+     */
+    private boolean processDuplicatePickResult(String mSelectContactsNumbers,
+            RecipientsEditor editor, long[] contactsId,
+            ContactList list, ContactList allList) {
+        boolean isDuplicate = false;
+        try {
+            /// M: @{
+            //list = ContactList.blockingGetByUris(uris);
+            /// M: add for ip message
+            /// M: To append recipients into RecipientsEditor, no need to load avatar,
+            /// because Editor will query and notify avatar info to MMS later. If append
+            /// 100 recipients, will saving almost 3s.
+            Contact.sNeedLoadAvatar = false;
+            ContactList selected = TextUtils.isEmpty(mSelectContactsNumbers) ?
+                 ContactList.blockingGetByIds(contactsId) :
+                     ContactList.getByNumbers(mSelectContactsNumbers, false, false);
+            Contact.sNeedLoadAvatar = true;
+            final List<String> numbers = editor.getNumbers();
+
+            /** M: better merge strategy.
+             * Avoid the use of mRecipientsEditor.contrcutionContactsFromInput()
+             * all Contacts in selected list should be added.
+             * */
+            /// M: remove duplicated numbers and format
+            List<String> selectedNumbers = Arrays.asList(selected.getProtosomaitcNumbers());
+            if (selectedNumbers.size() < selected.size()) {
+                isDuplicate = true;
+            }
+            String selectedNumberAfterFormat = "";
+            if (numbers.size() > 0) {
+                for (String number : numbers) {
+                    if (!number.trim().equals("")) {
+                        Contact c = Contact.get(number, false);
+                        allList.add(c);
+                    }
+                }
+                /// M: format existing numbers(remove "-" and " ")
+                List<String> formatedNumbers = Arrays.asList(allList.getNumbers(true));
+                for (String selectedNumber : selectedNumbers) {
+                    selectedNumberAfterFormat = MessageUtils.parseMmsAddress(selectedNumber);
+                    if (selectedNumberAfterFormat != null
+                            && !selectedNumberAfterFormat.trim().equals("")) {
+                        if (!formatedNumbers.contains(selectedNumberAfterFormat)) {
+                            Contact c = Contact.get(selectedNumber, false);
+                            list.add(c);
+                        } else {
+                            //M: ALPS01831885, fix contact cache error.
+                            Contact c = Contact.get(selectedNumber, false);
+                            c.removeFromCache();
+                            isDuplicate = true;
+                        }
+                    }
+                }
+                allList.addAll(list);
+            } else {
+                for (String selectedNumber : selectedNumbers) {
+                    selectedNumberAfterFormat = MessageUtils.parseMmsAddress(selectedNumber);
+                    if (selectedNumberAfterFormat != null && !selectedNumber.trim().equals("")) {
+                        Contact c = Contact.get(selectedNumber, false);
+                        list.add(c);
+                    }
+                }
+                allList.addAll(list);
+            }
+            /// @}
+        } finally {
+            Message msg = mUiHandler.obtainMessage();
+            msg.what = MSG_DISMISS_CONTACT_PICK_DIALOG;
+            mUiHandler.sendMessage(msg);
+            return isDuplicate;
+        }
+    }
+
+    private ProgressDialog mContactPickDialog;
+
+    private Runnable mContactPickRunnable = new Runnable() {
+        public void run() {
+            if (mContactPickDialog != null) {
+                mContactPickDialog.show();
+            }
+        }
+    };
+
+    public String getNumbersFromIntent(Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+        boolean usingColon = intent.getBooleanExtra(USING_COLON, false);
+        String selectContactsNumbers = intent.getStringExtra(SELECTION_CONTACT_RESULT);
+        if (usingColon) {
+            if (selectContactsNumbers == null || selectContactsNumbers.length() < 1) {
+                return null;
+            }
+            String[] numberArray = selectContactsNumbers.split(NUMBERS_SEPARATOR_COLON);
+            String numberTempl = "";
+            int simcolonIndex = -1;
+            int colonIndex = -1;
+            int separatorIndex = -1;
+            for (int index = 0; index < numberArray.length; index++) {
+                numberTempl = numberArray[index];
+                simcolonIndex = numberTempl.indexOf(NUMBERS_SEPARATOR_SIMCOLON);
+                colonIndex = numberTempl.indexOf(NUMBERS_SEPARATOR_COMMA);
+                if (simcolonIndex > 0) {
+                    if (colonIndex < 0) {
+                        separatorIndex = simcolonIndex;
+                    } else if (simcolonIndex < colonIndex) {
+                        separatorIndex = simcolonIndex;
+                    } else if (colonIndex > 0) {
+                        separatorIndex = colonIndex;
+                    }
+                } else {
+                    if (colonIndex > 0) {
+                        separatorIndex = colonIndex;
+                    }
+                }
+                if (separatorIndex > 0) {
+                    numberArray[index] = numberTempl.substring(0, separatorIndex);
+                }
+                simcolonIndex = -1;
+                colonIndex = -1;
+                separatorIndex = -1;
+            }
+            return TextUtils.join(NUMBERS_SEPARATOR_SIMCOLON, numberArray);
+        }
+        return selectContactsNumbers;
+    }
+
+    private void processPickResult(final Intent data) {
+        // The EXTRA_PHONE_URIS stores the phone's urls that were selected by user in the
+        // multiple phone picker.
+        /// M: Code analyze 013, Get contacts from Contact app . @{
+        /*final Parcelable[] uris =
+            data.getParcelableArrayExtra(Intents.EXTRA_PHONE_URIS);
+
+        final int recipientCount = uris != null ? uris.length : 0;*/
+
+        final long[] contactsId =
+            data.getLongArrayExtra("com.mediatek.contacts.list.pickdataresult");
+        final String mSelectContactsNumbers = getNumbersFromIntent(data);
+        MmsLog.dpi(TAG,
+                "processPickResult, data = " + data.toString() + ", contactsId = "
+                        + Arrays.toString(contactsId) + ", mSelectContactsNumbers = "
+                        + mSelectContactsNumbers);
+        if ((contactsId == null || contactsId.length <= 0)
+                && TextUtils.isEmpty(mSelectContactsNumbers)) {
+            return;
+        }
+        int recipientCount = mRecipientsEditor.getRecipientCount();
+        if (!TextUtils.isEmpty(mSelectContactsNumbers)) {
+            recipientCount += mSelectContactsNumbers.split(";").length;
+        } else {
+            recipientCount += contactsId.length;
+        }
+        /// @}
+        /// M: Code analyze 056,Now,the sms recipient limit is different from mms.
+        /// We can set limit for sms or mms individually. @{
+        final int recipientLimit = MmsConfig.getSmsRecipientLimit();
+        /// @}
+        if (recipientLimit != Integer.MAX_VALUE && recipientCount > recipientLimit) {
+            new AlertDialog.Builder(this)
+                    .setTitle(R.string.pick_too_many_recipients)
+                    .setIconAttribute(android.R.attr.alertDialogIcon)
+                    .setMessage(getString(R.string.too_many_recipients,
+                            recipientCount, recipientLimit))
+                    .setPositiveButton(android.R.string.ok, null)
+                    .create().show();
+            return;
+        }
+
+        /// M: @{
+//        final Handler handler = new Handler();
+        if (mContactPickDialog == null) {
+            mContactPickDialog = new ProgressDialog(this);
+            mContactPickDialog.setMessage(getText(R.string.adding_recipients));
+            mContactPickDialog.setIndeterminate(true);
+            mContactPickDialog.setCancelable(false);
+        }
+
+        // Only show the progress dialog if we can not finish off parsing the return data in 1s,
+        // otherwise the dialog could flicker.
+        mUiHandler.postDelayed(mContactPickRunnable, 500);
+        new Thread(new Runnable() {
+            public void run() {
+                final ContactList list = new ContactList();
+                final ContactList allList = new ContactList();
+                final boolean isDuplicate = processDuplicatePickResult(mSelectContactsNumbers,
+                        mRecipientsEditor, contactsId, list, allList);
+                // TODO: there is already code to update the contact header widget and recipients
+                // editor if the contacts change. we can re-use that code.
+                final Runnable populateWorker = new Runnable() {
+                    public void run() {
+                        mConversation.setRecipients(allList);
+                        if (list.size() > 0) {
+                            // Fix ALPS01594370, if has attach, recipient eidtor always on focus.
+                            // And adding a recipient bebind the editable recipient is not allowed.
+                            if ((mBottomPanel == null)
+                                    || (mBottomPanel.getVisibility() != View.VISIBLE)) {
+                                mRecipientsEditor.clearFocus();
+                            }
+                            mIsPopulatingRecipients = true;
+                            mRecipientsEditor.populate(list);
+                        }
+                        if (mRecipientsEditor != null && isRecipientsEditorVisible()) {
+                            mRecipientsEditor.requestFocus();
+                        }
+                        if (isDuplicate) {
+                            Toast.makeText(ComposeMessageActivity.this,
+                                    R.string.add_duplicate_recipients, Toast.LENGTH_SHORT).show();
+                        }
+                    }
+                };
+                mUiHandler.post(populateWorker);
+            }
+        }, "ComoseMessageActivity.processPickResult").start();
+    }
+
+    private boolean mIsPopulatingRecipients = false;
+    /// M: Code analyze 062, Resize image. @{
+    private final ResizeImageResultCallback mResizeImageCallback =
+        new ResizeImageResultCallback() {
+        // TODO: make this produce a Uri, that's what we want anyway
+        @Override
+        public void onResizeResult(PduPart part, boolean append) {
+            mNeedSaveAsMms = false;
+            if (part == null) {
+                MmsLog.d(TAG, "onResizeResult part == null");
+                notifyCompressingDone();
+                handleAddAttachmentError(WorkingMessage.UNKNOWN_ERROR, R.string.type_picture);
+                return;
+            }
+
+            mWorkingMessage.setResizeImage(true);
+            Context context = ComposeMessageActivity.this;
+            PduPersister persister = PduPersister.getPduPersister(context);
+            int result;
+            if (mWorkingMessage.isDiscarded()) {
+                notifyCompressingDone();
+                return;
+            }
+            Uri messageUri = mWorkingMessage.getMessageUri();
+            if (null == messageUri) {
+                try {
+                    messageUri = mWorkingMessage.saveAsMms(true);
+                } catch (IllegalStateException e) {
+                    notifyCompressingDone();
+                    MmsLog.e(TAG, e.getMessage() + ", go to ConversationList!");
+                    goToConversationList();
+                }
+            }
+            if (messageUri == null) {
+                MmsLog.d(TAG, "onResizeResult messageUri == null");
+                result = WorkingMessage.UNKNOWN_ERROR;
+            } else {
+                try {
+                    /// M: it is modifying the mms draft, maybe
+                    /// interlaced with WorkingMessage.saveDraft!
+                    Uri dataUri;
+                    int mode;
+                    synchronized (WorkingMessage.sDraftMmsLock) {
+                        dataUri = persister.persistPart(part,
+                                ContentUris.parseId(messageUri), null);
+                        mode = mWorkingMessage.sCreationMode;
+                        mWorkingMessage.sCreationMode = 0;
+                        result = mWorkingMessage.setAttachment(WorkingMessage.IMAGE,
+                                dataUri, append);
+                        /// M: fix bug ALPS00914391, remove redundancy part
+                        if (result != mWorkingMessage.OK
+                                && mWorkingMessage.getSlideshow() != null) {
+                            try {
+                                PduBody pb = mWorkingMessage.getSlideshow().toPduBody();
+                                MessageUtils.updatePartsIfNeeded(mWorkingMessage.getSlideshow(),
+                                        PduPersister.getPduPersister(context),
+                                        messageUri, pb, null);
+                                if (pb != null) {
+                                    mWorkingMessage.getSlideshow().sync(pb);
+                                }
+                            }  catch (MmsException e) {
+                                Log.e(TAG, "Cannot update the message: " + messageUri, e);
+                            }
+                        }
+
+                    }
+                    mWorkingMessage.sCreationMode = mode;
+                    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                        log("ResizeImageResultCallback: dataUri=" + dataUri);
+                    }
+                } catch (MmsException e) {
+                    result = WorkingMessage.UNKNOWN_ERROR;
+                }
+            }
+
+            /// M:added for bug ALPS00317889 begin,for not pop up alertDialog if
+            // attachment size is reaching limited size
+            if (!mShowDialogForMultiImage) {
+                handleAddAttachmentError(result, R.string.type_picture);
+            }
+            if (result == WorkingMessage.MESSAGE_SIZE_EXCEEDED) {
+                mShowDialogForMultiImage = true;
+            }
+            /// M:added for bug ALPS00317889 end
+            if (result == WorkingMessage.OK) {
+                try {
+                    if (mWorkingMessage.saveAsMms(false) != null) {
+                        mHasDiscardWorkingMessage = true;
+                    }
+                } catch (IllegalStateException e) {
+                    MmsLog.e(TAG, e.getMessage() + ", go to ConversationList!");
+                    notifyCompressingDone();
+                    goToConversationList();
+                }
+                mNeedSaveDraftAfterStop = false;
+            }
+            notifyCompressingDone();
+            mWaitingAttachment = false;
+        }
+    };
+    /// @}
+
+    private void handleAddAttachmentError(final int error, final int mediaTypeStringId) {
+        if (error == WorkingMessage.OK) {
+            return;
+        }
+        Log.d(TAG, "handleAddAttachmentError: " + error);
+
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                int titleId;
+                int messageId;
+                mWorkingMessage.removeFakeMmsForDraft();
+                updateSendButtonState();
+
+                MmsLog.d(TAG, "Error Code:" + error);
+                switch(error) {
+                /// M: Code analyze 063, For new feature ALPS00233419, Creation mode . @{
+                case WorkingMessage.WARNING_TYPE:
+                /// @}
+                case WorkingMessage.UNKNOWN_ERROR:
+                    Resources res = getResources();
+                    String mediaType = res.getString(mediaTypeStringId);
+                    String message = res.getString(R.string.error_add_attachment, mediaType);
+                    Toast.makeText(ComposeMessageActivity.this,
+                            message, Toast.LENGTH_SHORT).show();
+                    return;
+                case WorkingMessage.UNSUPPORTED_TYPE:
+                /// M: Code analyze 063, For new feature ALPS00233419, Creation mode . @{
+                case WorkingMessage.RESTRICTED_TYPE:
+                /// @}
+                    titleId = R.string.unsupport_media_type;
+                    messageId = R.string.select_different_media_type;
+                    break;
+                case WorkingMessage.MESSAGE_SIZE_EXCEEDED:
+                    titleId = R.string.exceed_message_size_limitation;
+                    messageId = R.string.failed_to_add_image;
+                    break;
+                case WorkingMessage.IMAGE_TOO_LARGE:
+                    titleId = R.string.failed_to_resize_image;
+                    messageId = R.string.resize_image_error_information;
+                    break;
+                 /// M: Code analyze 063, For new feature ALPS00233419, Creation mode . @{
+                case WorkingMessage.RESTRICTED_RESOLUTION:
+                    titleId = R.string.select_different_media_type;
+                    messageId = R.string.image_resolution_too_large;
+                    break;
+                /// @}
+                default:
+                    throw new IllegalArgumentException("unknown error " + error);
+                }
+                if (mErrorDialogShown) {
+                    MessageUtils.showErrorDialog(ComposeMessageActivity.this, titleId, messageId,
+                            0, 0);
+                    mErrorDialogShown = false;
+                }
+            }
+        });
+    }
+
+    /// M: Code analyze 064, Add image attachment. @{
+    private void addImageAsync(final Uri uri, final boolean append) {
+        mCompressingImage = true;
+        getAsyncDialog().runAsync(new Runnable() {
+            @Override
+            public void run() {
+                mShowDialogForMultiImage = false; /// M:added for bug ALPS00317889
+                addImage(uri, append);
+                if (mNeedSaveAsMms) {
+                    saveAsMms(false);
+                } else if (mNeedSaveDraftAfterStop) {
+                    if ((!isRecipientsEditorVisible()) ||
+                            (mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms()))) {
+                        if (MessageUtils.allowSafeDraft(ComposeMessageActivity.this,
+                                MmsConfig.getDeviceStorageFullStatus(), false,
+                                TOAST_TYPE_FOR_SAVE_DRAFT)) {
+                            saveDraft(true);
+                            Log.v(TAG, "save draft if needed after compressing" +
+                                    " image after onStop and update MmsWidget");
+                            MmsWidgetProvider.notifyDatasetChanged(getApplicationContext());
+                        }
+                    }
+                }
+             }
+        }, null, R.string.adding_attachments_title);
+    }
+
+    private void addImage(final Uri uri, final boolean append) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "addImage: append=" + append + ", uri=" + uri);
+        }
+        mNeedSaveAsMms = true;
+        int result = WorkingMessage.OK;
+        try {
+            if (append) {
+                mWorkingMessage.checkSizeBeforeAppend();
+            }
+        } catch (ExceedMessageSizeException e) {
+            result = WorkingMessage.MESSAGE_SIZE_EXCEEDED;
+            notifyCompressingDone();
+            handleAddAttachmentError(result, R.string.type_picture);
+            mNeedSaveAsMms = false;
+            return;
+        }
+
+        result = mWorkingMessage.setAttachment(WorkingMessage.IMAGE, uri, append);
+
+        if (result != WorkingMessage.IMAGE_TOO_LARGE &&
+                result != WorkingMessage.MESSAGE_SIZE_EXCEEDED) {
+            mWaitingAttachment = false;
+        }
+        if (result == WorkingMessage.IMAGE_TOO_LARGE ||
+            result == WorkingMessage.MESSAGE_SIZE_EXCEEDED) {
+            MmsLog.dpi(TAG, "addImage: resize image " + uri);
+
+            /// M: Adjust whether its a DRM IMAGE
+            if (FeatureOption.MTK_DRM_APP) {
+                if (!DrmUtilsEx.checkUriContainsDrm(this, uri)) {
+                    mToastCountForResizeImage++;
+                    if (mToastCountForResizeImage == 1) {
+                        MessageUtils.resizeImage(this, uri,
+                                mAttachmentEditorHandler, mResizeImageCallback, append,
+                            true);
+                    } else {
+                        MessageUtils.resizeImage(this, uri,
+                                mAttachmentEditorHandler, mResizeImageCallback, append,
+                            false);
+                    }
+                } else {
+                    notifyCompressingDone();
+                    handleAddAttachmentError(result, R.string.type_picture);
+                    mNeedSaveAsMms = false;
+                }
+            } else {
+                mToastCountForResizeImage++;
+                if (mToastCountForResizeImage == 1) {
+                    MessageUtils.resizeImage(this, uri,
+                            mAttachmentEditorHandler, mResizeImageCallback, append, true);
+                } else {
+                    MessageUtils.resizeImage(this, uri,
+                            mAttachmentEditorHandler, mResizeImageCallback, append, false);
+                }
+            }
+            return;
+        } else if (result == WorkingMessage.WARNING_TYPE) {
+            mNeedSaveAsMms = false;
+            notifyCompressingDone();
+            runOnUiThread(new Runnable() {
+                public void run() {
+                    showConfirmDialog(uri, append,
+                            WorkingMessage.IMAGE, R.string.confirm_restricted_image);
+                }
+            });
+            return;
+        }
+        notifyCompressingDone();
+        if (result != WorkingMessage.OK) {
+            mNeedSaveAsMms = false;
+        }
+        handleAddAttachmentError(result, R.string.type_picture);
+    }
+    /// @}
+
+    /// M: Code analyze 065, Add video attachment. @{
+    private void addVideoAsync(final Uri uri, final boolean append) {
+        getAsyncDialog().runAsyncInThreadPool(new Runnable() {
+            @Override
+            public void run() {
+                addVideo(uri, append);
+                saveAsMms(false);
+           }
+        }, null, R.string.adding_attachments_title);
+    }
+
+    private void addVideo(final Uri uri, final boolean append) {
+        mNeedSaveAsMms = false;
+        if (uri != null) {
+            mNeedSaveAsMms = true;
+            int result = WorkingMessage.OK;
+            try {
+                if (append) {
+                    mWorkingMessage.checkSizeBeforeAppend();
+                }
+            } catch (ExceedMessageSizeException e) {
+                result = WorkingMessage.MESSAGE_SIZE_EXCEEDED;
+                handleAddAttachmentError(result, R.string.type_video);
+                mNeedSaveAsMms = false;
+                return;
+            }
+            result = mWorkingMessage.setAttachment(WorkingMessage.VIDEO, uri, append);
+            if (result == WorkingMessage.WARNING_TYPE) {
+                mNeedSaveAsMms = false;
+                runOnUiThread(new Runnable() {
+                    public void run() {
+                        showConfirmDialog(uri, append,
+                                WorkingMessage.VIDEO, R.string.confirm_restricted_video);
+                    }
+                });
+            } else {
+                handleAddAttachmentError(result, R.string.type_video);
+                if (result != WorkingMessage.OK) {
+                    mNeedSaveAsMms = false;
+                }
+            }
+        }
+    }
+    /// @}
+
+    private void addAudioAsync(final Uri uri, final boolean append) {
+        getAsyncDialog().runAsync(new Runnable() {
+            @Override
+            public void run() {
+                addAudio(uri, append);
+                saveAsMms(false);
+            }
+        }, null, R.string.adding_attachments_title);
+    }
+
+    AsyncDialog getAsyncDialog() {
+        if (mAsyncDialog == null) {
+            mAsyncDialog = new AsyncDialog(this);
+        }
+        return mAsyncDialog;
+    }
+
+    public boolean getForwordingState() {
+        return mForwardingMessage;
+    }
+
+    /// M: Code analyze 017, Handle forwarded message.(see:forwardMessage())@{
+    private boolean handleForwardedMessage() {
+        Intent intent = getIntent();
+
+        // If this is a forwarded message, it will have an Intent extra
+        // indicating so.  If not, bail out.
+        if (!mForwardMessageMode) {
+            mForwardingMessage = false;
+            return false;
+        }
+        mForwardingMessage = true;
+
+        Uri uri = intent.getParcelableExtra("msg_uri");
+
+        if (Log.isLoggable(LogTag.APP, Log.DEBUG)) {
+            MmsLog.dpi(TAG, "handle forwarded message " + uri);
+        }
+
+        if (uri != null) {
+            mWorkingMessage = WorkingMessage.load(this, uri);
+            if (mWorkingMessage != null) {
+                mWorkingMessage.setSubject(intent.getStringExtra("subject"), false);
+                SlideshowModel mSlideshowModel = mWorkingMessage.getSlideshow();
+                if (mSlideshowModel != null) {
+                    int mSsmSize = mSlideshowModel.size();
+                    for (int index = 0; index < mSsmSize; index++) {
+                        SlideModel mSlideModel = mSlideshowModel.get(index);
+                        if (mSlideModel != null) {
+                            if (mSlideModel.hasText()) {
+                                TextModel mTextModel = mSlideModel.getText();
+                                String textChar = mTextModel.getText();
+                                long textLength = textChar.length();
+                                if (textLength > MmsConfig.getMaxTextLimit()) {
+                                    mTextModel.setText(
+                                            textChar.substring(0, MmsConfig.getMaxTextLimit()));
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } else {
+            String smsAddress = null;
+            if (intent.hasExtra(SMS_ADDRESS)) {
+                smsAddress = intent.getStringExtra(SMS_ADDRESS);
+                if (smsAddress != null) {
+                   //TODO need re-coding
+                   //mRecipientsEditor.addRecipient(smsAddress, true);
+                }
+            }
+            mWorkingMessage.setText(intent.getStringExtra(SMS_BODY));
+        }
+        /// M:
+        // add for ipmessage
+        mIpCompose.onIpHandleForwardedMessage(intent);
+        // let's clear the message thread for forwarded messages
+        mMsgListAdapter.changeCursor(null);
+
+        return true;
+    }
+    /// @}
+
+    // Handle send actions, where we're told to send a picture(s) or text.
+    private boolean handleSendIntent() {
+        Intent intent = getIntent();
+        Bundle extras = intent.getExtras();
+        if (extras == null) {
+            return false;
+        }
+        /// M: Code analyze 066,Handle intent. @{
+        /// M: add for saveAsMms
+        mWorkingMessage.setConversation(mConversation);
+        final String mimeType = intent.getType();
+        String action = intent.getAction();
+        MmsLog.i(TAG, "Get mimeType: " + mimeType + " Get action: " + action);
+        /// M: disable when non-default sms
+        if (!mIsSmsEnabled) {
+            Toast.makeText(ComposeMessageActivity.this,
+                    R.string.compose_disabled_toast, Toast.LENGTH_SHORT).show();
+            return false;
+        }
+        if (Intent.ACTION_SEND.equals(action)) {
+            if (extras.containsKey(Intent.EXTRA_STREAM)) {
+                final Uri uri = (Uri) extras.getParcelable(Intent.EXTRA_STREAM);
+                if (uri == null) {
+                    MmsLog.w(TAG, "handleSendIntent uri == null");
+                    return false;
+                }
+                if (mimeType.equals("text/plain")) {
+                    String fileName = "";
+                    if (uri != null) {
+                        if (uri.getScheme() != null && uri.getScheme().equals("file")) {
+                            String mUriStr = Uri.decode(uri.toString());
+                            fileName = mUriStr.substring(mUriStr.lastIndexOf("/") + 1,
+                                    mUriStr.length());
+                        } else {
+                            Cursor c = mContentResolver.query(uri, null, null, null, null);
+                            if (c != null) {
+                                try {
+                                    if (c.getCount() == 1 && c.moveToFirst()) {
+                                        fileName = c.getString(
+                                                c.getColumnIndex(Images.Media.DISPLAY_NAME));
+                                    }
+                                } catch (Exception e) {
+                                    e.printStackTrace();
+                                } finally {
+                                    c.close();
+                                }
+                            }
+                        }
+                    }
+
+                    String mMessage = this.getString(R.string.failed_to_add_media, fileName);
+                    Toast.makeText(this, mMessage, Toast.LENGTH_SHORT).show();
+                    return false;
+                }
+                getAsyncDialog().runAsync(new Runnable() {
+                    @Override
+                    public void run() {
+                        /// M: fix bug ALPS00397146, removeThumbnailManager uri
+                        // (Content://media/external/images/media/) when it rotated
+                        String fileName = "";
+                        int degree = 0;
+                        String uriStr = uri.toString();
+                        if (uriStr.startsWith("content://media/external/images/media")) {
+                            Cursor c = mContentResolver.query(uri, null, null, null, null);
+                            if (c != null) {
+                                try {
+                                    if (c.getCount() == 1 && c.moveToFirst()) {
+                                        fileName = c.getString(
+                                                c.getColumnIndex(Images.Media.DISPLAY_NAME));
+                                        degree = c.getInt(
+                                                c.getColumnIndex(Images.Media.ORIENTATION));
+                                    }
+                                } catch (Exception e) {
+                                    e.printStackTrace();
+                                } finally {
+                                    c.close();
+                                }
+                            }
+
+                            if (sDegreeMap != null && sDegreeMap.containsKey(uriStr)) {
+                                if (sDegreeMap.get(uriStr).intValue() != degree) {
+                                    Uri thumbnailUri =
+                                        Uri.parse(uriStr + ThumbnailManager.FLAG_FNAME + fileName);
+                                    MmsApp.getApplication().getThumbnailManager()
+                                                                    .removeThumbnail(thumbnailUri);
+                                    sDegreeMap.remove(uriStr);
+                                    sDegreeMap.put(uriStr, degree);
+                                }
+                            } else if (sDegreeMap != null) {
+                                sDegreeMap.put(uriStr, degree);
+                            }
+                        }
+                        /// @}
+                        Uri tempUri = uri;
+                        if (uri.toString().contains(TempFileProvider.SCRAP_VIDEO_URI.toString())) {
+                            File file = new File(TempFileProvider
+                                    .getScrapVideoPath(ComposeMessageActivity.this));
+                            if (file != null && file.exists()) {
+                                tempUri = Uri.fromFile(file);
+                            }
+                        }
+
+                        String scheme = tempUri.getScheme();
+                        if (scheme != null && scheme.equals("file")) {
+                            /// M: fix bug ALPS01400468, workaround for GoogleDrive Audio Uri
+                            if (uri.toString().contains(AudioModel.sAuthorityForGoogleDrive)) {
+                                AudioModel.sTypeForGoogleDrive = mimeType;
+                            }
+                            addFileAttachment(mimeType, tempUri, false);
+                        } else {
+                            String type = MessageUtils.queryContentType(
+                                    ComposeMessageActivity.this, (Uri) uri);
+                            if (TextUtils.isEmpty(type)) {
+                                type = mimeType;
+                            }
+                            addAttachment(type, tempUri, false);
+                        }
+                        SlideshowModel slides = mWorkingMessage.getSlideshow();
+                        if (slides != null && (slides.size() > 0
+                                || slides.sizeOfFilesAttach() > 0)) {
+                            mWorkingMessage.saveAsMms(false);
+                        }
+                        VCardUtils.deleteVCardTempFiles(getApplicationContext(), mVCardFiles);
+                    }
+                }, null, R.string.adding_attachments_title);
+                intent.setAction(SIGN_CREATE_AFTER_KILL_BY_SYSTEM);
+                return true;
+            } else if (extras.containsKey(Intent.EXTRA_TEXT)) {
+                mWorkingMessage.setText(extras.getString(Intent.EXTRA_TEXT));
+                intent.setAction(SIGN_CREATE_AFTER_KILL_BY_SYSTEM);
+                return true;
+            }
+        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action) &&
+                extras.containsKey(Intent.EXTRA_STREAM)) {
+            SlideshowModel slideShow = mWorkingMessage.getSlideshow();
+            final ArrayList<Parcelable> uris = extras.getParcelableArrayList(Intent.EXTRA_STREAM);
+            int currentSlideCount = slideShow != null ? slideShow.size() : 0;
+            int importCount = uris.size();
+            if (importCount + currentSlideCount > SlideshowEditor.MAX_SLIDE_NUM) {
+                importCount = Math.min(SlideshowEditor.MAX_SLIDE_NUM - currentSlideCount,
+                        importCount);
+            }
+
+            // Attach all the pictures/videos asynchronously off of the UI thread.
+            // Show a progress dialog if adding all the slides hasn't finished
+            // within half a second.
+            final int numberToImport = importCount;
+            MmsLog.i(TAG, "numberToImport: " + numberToImport);
+            final WorkingMessage msg = mWorkingMessage;
+            getAsyncDialog().runAsync(new Runnable() {
+                @Override
+                public void run() {
+                    mToastCountForResizeImage = 0;
+                    for (int i = 0; i < numberToImport; i++) {
+                        Parcelable uri = uris.get(i);
+
+                        String scheme = ((Uri) uri).getScheme();
+                        String authority = ((Uri) uri).getAuthority();
+                        if (scheme != null && scheme.equals("file")) {
+                            // change "file://..." Uri to "Content://....,
+                            // and attemp to add this attachment"
+                            /// M: fix bug ALPS604911, change MmsContentType
+                            /// when share multi-file from FileManager @{
+                            String type = MessageUtils.getContentType((Uri) uri);
+                            if (TextUtils.isEmpty(type)) {
+                                type = mimeType;
+                            }
+                            /// @}
+                            addFileAttachment(type, (Uri) uri, true);
+                        } else if (authority != null && (authority.contains("com.android.email")
+                                || (authority.equals(MediaStore.AUTHORITY)
+                                        && mimeType != null && mimeType.contains("*")))) {
+                            addAttachment(mimeType, (Uri) uri, true);
+                        } else {
+                            String type = MessageUtils.queryContentType(
+                                    ComposeMessageActivity.this, (Uri) uri);
+                            if (TextUtils.isEmpty(type)) {
+                                type = mimeType;
+                            }
+                            addAttachment(type, (Uri) uri, true);
+                        }
+                    }
+                    mToastCountForResizeImage = 0;
+                    SlideshowModel slides = mWorkingMessage.getSlideshow();
+                    if (slides != null && (slides.size() > 0 || slides.sizeOfFilesAttach() > 0)) {
+                        mWorkingMessage.saveAsMms(false);
+                    }
+                    VCardUtils.deleteVCardTempFiles(getApplicationContext(), mVCardFiles);
+                }
+            }, null, R.string.adding_attachments_title);
+            intent.setAction(SIGN_CREATE_AFTER_KILL_BY_SYSTEM);
+            return true;
+        } else if (SIGN_CREATE_AFTER_KILL_BY_SYSTEM.equals(action)) {
+        /// @}
+            return true;
+        }
+        return false;
+    }
+
+    // mVideoUri will look like this: content://media/external/video/media
+    private static final String mVideoUri = Video.Media.getContentUri("external").toString();
+    // mImageUri will look like this: content://media/external/images/media
+    private static final String mImageUri = Images.Media.getContentUri("external").toString();
+
+    private void addAttachment(String type, Uri uri, boolean append) {
+        if (uri != null) {
+            // When we're handling Intent.ACTION_SEND_MULTIPLE, the passed in items can be
+            // videos, and/or images, and/or some other unknown types we don't handle. When
+            // a single attachment is "shared" the type will specify an image or video. When
+            // there are multiple types, the type passed in is "*/*". In that case, we've got
+            // to look at the uri to figure out if it is an image or video.
+            try
+            {
+                boolean wildcard = "*/*".equals(type);
+                MmsLog.i(TAG, "Got send intent mimeType :" + type);
+            if (type == null) {
+                handleAddAttachmentError(WorkingMessage.UNSUPPORTED_TYPE, R.string.type_picture);
+            }
+            else if (type.startsWith("image/") || (wildcard &&
+                           uri.toString().startsWith(mImageUri))) {
+                    addImage(uri, append);
+                } else if (type.startsWith("video/") ||
+                        (wildcard && uri.toString().startsWith(mVideoUri))) {
+                    addVideo(uri, append);
+                }
+                 /// M: Code analyze 067, Add audio attachment. @{
+                else if (type.startsWith("audio/") || type.equals("application/ogg")
+                    || (wildcard && uri.toString().startsWith(mAudioUri))) {
+                    addAudio(uri, append);
+                /// @}
+                /// M: Code analyze 019, Add vcard attachment.  @{
+                } else if (type.equalsIgnoreCase("text/x-vcard")) {
+                    VCardAttachment va = new VCardAttachment(ComposeMessageActivity.this);
+                    String fileName = va.getVCardFileNameByUri(uri);
+                    setFileAttachment(fileName, WorkingMessage.VCARD, false);
+                    mVCardFiles.add(fileName);
+                 /// M: Code analyze 020, Add vcalendar attachment.  @{
+                } else if (type.equalsIgnoreCase("text/x-vcalendar")) {
+                    attachVCalendar(uri);
+                } else {
+                    handleAddAttachmentError(WorkingMessage.UNSUPPORTED_TYPE, R.string.type_audio);
+                }
+            } catch (NullPointerException  e) {
+                   Log.e(TAG, "Null mimetype", e);
+                }
+            /// @}
+        }
+    }
+
+    private String getResourcesString(int id, String mediaName) {
+        Resources r = getResources();
+        return r.getString(id, mediaName);
+    }
+
+    private void drawBottomPanel() {
+        // Reset the counter for text editor.
+        /// M: @{
+        mDrawBottomPanel = false;
+        /// M: remove Google default code
+        // Reset the counter for text editor.
+        //resetCounter();
+
+        mOpComposeExt.drawBottomPanel(mWorkingMessage.hasSlideshow(),
+                mWorkingMessage.getIsUpdateAttachEditor(), mIsSmsEnabled);
+
+        if (mWorkingMessage.hasSlideshow()) {
+            if (mWorkingMessage.getIsUpdateAttachEditor()) {
+                mBottomPanel.setVisibility(View.GONE);
+                if (mSubjectTextEditor != null) {
+                    //mSubjectTextEditor.setNextFocusDownId(-1);
+                    mSubjectTextEditor.setImeOptions(EditorInfo.IME_ACTION_DONE);
+                    mSubjectTextEditor.setImeActionLabel(
+                            getText(com.android.internal.R.string.ime_action_done),
+                            EditorInfo.IME_ACTION_DONE);
+                }
+
+                mAttachmentEditor.update(mWorkingMessage);
+                mAttachmentEditor.requestFocus();
+            } else {
+                MmsLog.d(TAG, "drawBottomPanel, isUpdateAttachEditor == false");
+            }
+            if (mRecipientsEditor != null) {
+                mRecipientsEditor.setEnabled(mIsSmsEnabled);
+                mRecipientsEditor.setFocusableInTouchMode(mIsSmsEnabled);
+                mRecipientsEditor.setIsTouchable(mIsSmsEnabled);
+            }
+            if (mSubjectTextEditor != null) {
+                mSubjectTextEditor.setEnabled(mIsSmsEnabled);
+                mSubjectTextEditor.setFocusableInTouchMode(mIsSmsEnabled);
+            }
+            if (mRecipientsPicker != null) {
+                mRecipientsPicker.setEnabled(mIsSmsEnabled);
+            }
+            return;
+        }
+
+        mAttachmentEditor.update(mWorkingMessage);
+        updateTextEditorHeightInFullScreen();
+        /// @}
+        mBottomPanel.setVisibility(View.VISIBLE);
+        if (mSubjectTextEditor != null) {
+            //mSubjectTextEditor.setNextFocusDownId(R.id.embedded_text_editor);
+            mSubjectTextEditor.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+            mSubjectTextEditor.setImeActionLabel(
+                    getText(com.android.internal.R.string.ime_action_next),
+                    EditorInfo.IME_ACTION_NEXT);
+        }
+
+        CharSequence text = mWorkingMessage.getText();
+
+        // TextView.setTextKeepState() doesn't like null input.
+        mTextEditor.removeTextChangedListener(mTextEditorWatcher);
+        if (mIsSmsEnabled) {
+            mTextEditor.addTextChangedListener(mTextEditorWatcher);
+            if (text != null) {
+                mTextEditor.setTextKeepState(text);
+                /// M: @{
+                try {
+                    mTextEditor.setSelection(mTextEditor.getText().toString().length());
+                } catch (IndexOutOfBoundsException e) {
+                    mTextEditor.setSelection(mTextEditor.getText().toString().length() - 1);
+                }
+                /// @}
+            } else {
+                mTextEditor.setText("");
+            }
+        } else {
+            mTextEditor.setText("");
+            mTextEditor.setHint(R.string.sending_disabled_not_default_app);
+            mTextEditor.setFocusable(false);
+        }
+        mTextEditor.setEnabled(mIsSmsEnabled);
+        mTextEditor.setFocusableInTouchMode(mIsSmsEnabled);
+
+        if (mRecipientsEditor != null) {
+            mRecipientsEditor.setEnabled(mIsSmsEnabled);
+            mRecipientsEditor.setFocusableInTouchMode(mIsSmsEnabled);
+            mRecipientsEditor.setIsTouchable(mIsSmsEnabled);
+        }
+        if (mSubjectTextEditor != null) {
+            mSubjectTextEditor.setEnabled(mIsSmsEnabled);
+            mSubjectTextEditor.setFocusableInTouchMode(mIsSmsEnabled);
+        }
+        if (mRecipientsPicker != null) {
+            mRecipientsPicker.setEnabled(mIsSmsEnabled);
+        }
+
+        /// M: add for character counter
+        // Reset the counter for text editor.
+        updateCounter(mWorkingMessage.getText(), 0, 0, 0);
+    }
+
+    private void drawTopPanel(boolean showSubjectEditor) {
+        /// M: why ? @{
+        //boolean showingAttachment = mAttachmentEditor.update(mWorkingMessage);
+        //mAttachmentEditorScrollView.setVisibility(showingAttachment ? View.VISIBLE : View.GONE);
+        //mAttachmentEditorScrollView.setVisibility(showingAttachment ? View.VISIBLE : View.GONE);
+        mOpComposeExt.drawTopPanel(isRecipientsEditorVisible(),
+                mWorkingMessage.mOpWorkingMessageExt);
+
+        boolean isHasSubject = false;
+        if (mWorkingMessage == null) {
+            isHasSubject = false;
+        } else {
+            isHasSubject = mWorkingMessage.hasSubject();
+        }
+        boolean isDeleteMode = false;
+        if (mMsgListAdapter == null) {
+            isDeleteMode = false;
+        } else {
+            isDeleteMode = mMsgListAdapter.mIsDeleteMode;
+        }
+        showSubjectEditor((showSubjectEditor || isHasSubject) && !isDeleteMode);
+        mAttachmentEditor.update(mWorkingMessage);
+        updateTextEditorHeightInFullScreen();
+        /// @}
+    }
+
+    //==========================================================
+    // Interface methods
+    //==========================================================
+
+    @Override
+    public void onClick(View v) {
+        /// M: Code analyze 028, Before sending message,check the recipients count
+        /// and add sub card selection dialog if multi sub cards exist.@{
+        /*if ((v == mSendButtonSms || v == mSendButtonMms) && isPreparedForSending()){
+            confirmSendMessageIfNeeded();
+        }
+        */
+
+        if (mOpComposeExt.onClick(v, mRecipientsPicker)) {
+            return;
+        }
+        if (v == mSendButtonSms || v == mSendButtonMms) {
+            MmsLog.d(TAG, "onClick send button click!");
+            if (mSendButtonCanResponse) {
+                ///M: WFC: Show pop-up, if condition satisfy @ {
+/*                if (showWfcSendButtonPopUp()) {
+                    return;
+                }
+                */
+                /// @}
+                mSendButtonCanResponse = false;
+                if (isPreparedForSending()) {
+                    /// M: Since sending message here, why not disable button 'Send'??
+                    updateSendButtonState(false);
+                    checkRecipientsCount();
+                    mUiHandler.sendEmptyMessageDelayed(MSG_RESUME_SEND_BUTTON,
+                            RESUME_BUTTON_INTERVAL);
+                } else {
+                    mSendButtonCanResponse = true;
+                    unpreparedForSendingAlert();
+                }
+            }
+        /// @}
+        } else if ((v == mRecipientsPicker)) {
+             /// M: Code analyze 013, Get contacts from Contact app . @{
+             //launchMultiplePhonePicker();
+            if (recipientCount() >= RECIPIENTS_LIMIT_FOR_SMS) {
+                Toast.makeText(ComposeMessageActivity.this,
+                        R.string.cannot_add_recipient, Toast.LENGTH_SHORT).show();
+            } else {
+                /// M: fix bug ALPS00444752, dis-clickble when showing ContactPicker
+                if (!mShowingContactPicker) {
+                    addContacts(mRecipientsEditor != null
+                            ? (RECIPIENTS_LIMIT_FOR_SMS - mRecipientsEditor.getNumbers().size())
+                                    : RECIPIENTS_LIMIT_FOR_SMS, REQUEST_CODE_PICK);
+                }
+            }
+             /// @}
+        }
+    }
+
+    /// M: fix bug ALPS00444752, set false to enable to Show ContactPicker
+    private boolean mShowingContactPicker = false;
+
+    private void launchMultiplePhonePicker() {
+        Intent intent = new Intent(Intents.ACTION_GET_MULTIPLE_PHONES);
+        intent.addCategory("android.intent.category.DEFAULT");
+        intent.setType(Phone.CONTENT_TYPE);
+        // We have to wait for the constructing complete.
+        ContactList contacts = mRecipientsEditor.constructContactsFromInput(true);
+        int urisCount = 0;
+        Uri[] uris = new Uri[contacts.size()];
+        urisCount = 0;
+        for (Contact contact : contacts) {
+            if (Contact.CONTACT_METHOD_TYPE_PHONE == contact.getContactMethodType()) {
+                    uris[urisCount++] = contact.getPhoneUri();
+            }
+        }
+        if (urisCount > 0) {
+            intent.putExtra(Intents.EXTRA_PHONE_URIS, uris);
+        }
+        startActivityForResult(intent, REQUEST_CODE_PICK);
+    }
+
+    @Override
+    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+        if (event != null) {
+            // if shift key is down, then we want to insert the '\n' char in the TextView;
+            // otherwise, the default action is to send the message.
+            if (!event.isShiftPressed()) {
+                if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                    return false;
+                }
+                /// M: Code analyze 028, Before sending message,check the recipients count
+                /// and add sub card selection dialog if multi sub cards exist.@{
+                if (isPreparedForSending()) {
+                    checkRecipientsCount();
+                } else {
+                    unpreparedForSendingAlert();
+                    }
+                /// @}
+                return true;
+            }
+            return false;
+        }
+        /// M: Code analyze 028, Before sending message,check the recipients count
+        /// and add sub card selection dialog if multi sub cards exist.@{
+        if (isPreparedForSending()) {
+            //confirmSendMessageIfNeeded();
+            checkRecipientsCount();
+        } else {
+            unpreparedForSendingAlert();
+        }
+        /// @}
+        return true;
+    }
+
+    private final TextWatcher mTextEditorWatcher = new TextWatcher() {
+        private int mStart;
+
+        /// M: fix bug ALPS00612093, postDelay for ANR
+        private Runnable mUpdateRunnable = new Runnable() {
+            public void run() {
+                updateSendButtonState();
+            }
+        };
+
+        private Runnable mRunnable = new Runnable() {
+            public void run() {
+                Toast.makeText(ComposeMessageActivity.this, R.string.dialog_sms_limit,
+                        Toast.LENGTH_SHORT).show();
+            }
+        };
+
+        @Override
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            mBeforeTextChangeString = s.toString();
+            MmsLog.d(TAG, "beforeTextChanged count = " + count + " after =" + after);
+        }
+
+        @Override
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            // This is a workaround for bug 1609057. Since onUserInteraction() is
+            // not called when the user touches the soft keyboard, we pretend it was
+            // called when textfields changes.  This should be removed when the bug
+            // is fixed.
+            onUserInteraction();
+
+            mWorkingMessage.setText(s);
+            /// M: fix bug ALPS00712509, show toast when paste many word and > 300k
+            if (mWorkingMessage.isExceedSize()) {
+                mWorkingMessage.setIsExceedSize(false);
+                mUiHandler.removeCallbacks(mRunnable);
+                mUiHandler.postDelayed(mRunnable, 200);
+            }
+            /// M: @{
+            mAttachmentEditor.onTextChangeForOneSlide();
+            /// @}
+
+            /// M: fix bug ALPS00612093, postDelay for ANR
+            mUiHandler.removeCallbacks(mUpdateRunnable);
+            mUiHandler.postDelayed(mUpdateRunnable, 100);
+
+            updateCounter(s, start, before, count);
+            mStart = start;
+            /// M: @{
+            //ensureCorrectButtonHeight();
+            /// @}
+
+            // add for ipmessage
+            mIpCompose.onIpTextChanged(s, start, before, count);
+        }
+
+        @Override
+        public void afterTextChanged(Editable s) {
+            // add for ipmessage
+            mIpCompose.onIpAfterTextChanged(s, mBeforeTextChangeString);
+        }
+    };
+
+    /**
+     * Ensures that if the text edit box extends past two lines then the
+     * button will be shifted up to allow enough space for the character
+     * counter string to be placed beneath it.
+     */
+    /*** M: remove Google default code
+    private void ensureCorrectButtonHeight() {
+        int currentTextLines = mTextEditor.getLineCount();
+        if (currentTextLines <= 2) {
+            mTextCounter.setVisibility(View.GONE);
+        }
+        else if (currentTextLines > 2 && mTextCounter.getVisibility() == View.GONE) {
+            // Making the counter invisible ensures that it is used to correctly
+            // calculate the position of the send button even if we choose not to
+            // display the text.
+            mTextCounter.setVisibility(View.INVISIBLE);
+        }
+    }
+    */
+
+    private final TextWatcher mSubjectEditorWatcher = new TextWatcher() {
+        @Override
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) { }
+
+        @Override
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            mWorkingMessage.setSubject(s, true);
+            if (s != null && TextUtils.getTrimmedLength(s) > 0) {
+                /// M: Code analyze 032, According to the message state to update text counter.@{
+                mTextCounter.setVisibility(View.GONE);
+                // / @}
+                // updateSendButtonState();
+            }
+            // / M: for fixed ALPS00562999,when change subject to null,update send button.@{
+            updateSendButtonState();
+            // / @}
+        }
+
+        @Override
+        public void afterTextChanged(Editable s) {
+            String subjectString = s.toString();
+            if (subjectString.length() == 0) {
+                Log.d(TAG, "[mSubjectEditorWatcher.afterTextChanged] subject lenght is 0,"
+                    + "current mms or sms : " + mWorkingMessage.requiresMms());
+                if (!mWorkingMessage.requiresMms()) {
+                    if (mConversation != null && mWorkingMessage != null) {
+                        mWorkingMessage.asyncDeleteDraftMmsMessage(mConversation);
+                        mWorkingMessage.clearConversation(mConversation, true);
+                    }
+                }
+            }
+        }
+    };
+
+    //==========================================================
+    // Private methods
+    //==========================================================
+
+    /**
+     * Initialize all UI elements from resources.
+     */
+    private void initResourceRefs() {
+        /// M: Code analyze 004, Set max height for text editor. @{
+        mHeightChangedLinearLayout =
+            (HeightChangedLinearLayout) findViewById(R.id.changed_linear_layout);
+        mHeightChangedLinearLayout.setLayoutSizeChangedListener(mLayoutSizeChangedListener);
+        /// @}
+        mMsgListView = (MessageListView) findViewById(R.id.history);
+        mMsgListView.setDivider(null);      // no divider so we look like IM conversation.
+        mMsgListView.setDividerHeight(getResources()
+                .getDimensionPixelOffset(R.dimen.ipmsg_message_list_divier_height));
+
+        // called to enable us to show some padding between the message list and the
+        // input field but when the message list is scrolled that padding area is filled
+        // in with message content
+        mMsgListView.setClipToPadding(false);
+
+        /** M: 4.1  used this code.
+        mMsgListView.setOnSizeChangedListener(new OnSizeChangedListener() {
+            public void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
+                // The message list view changed size, most likely because the keyboard
+                // appeared or disappeared or the user typed/deleted chars in the message
+                // box causing it to change its height when expanding/collapsing to hold more
+                // lines of text.
+                smoothScrollToEnd(false, height - oldHeight);
+            }
+        });
+        */
+
+        /// M: turn off children clipping because we draw the border outside of our own
+        /// M: bounds at the bottom.  The background is also drawn in code to avoid drawing
+        /// M: the top edge.
+        mMsgListView.setClipChildren(false);
+
+        mBottomPanel = findViewById(R.id.bottom_panel);
+        mTextEditor = (EnhanceEditText) findViewById(R.id.embedded_text_editor);
+        /// M: @{
+        //  mTextEditor.setOnEditorActionListener(this);
+        /// @}
+        mTextEditor.removeTextChangedListener(mTextEditorWatcher);
+        mTextEditor.addTextChangedListener(mTextEditorWatcher);
+        mTextEditor.setFilters(new InputFilter[] {
+                new TextLengthFilter(MmsConfig.getMaxTextLimit())});
+        mTextEditor.setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                // add for ipmessage
+                mIpCompose.onIpTextEditorKey(v, keyCode, event);
+                return false;
+            }
+        });
+
+        mTextEditor.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                mIpCompose.onIpTextEditorTouch();
+                mOpComposeExt.onTextEditorTouch();
+                return false;
+            }
+        });
+
+        mTextEditor.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
+            @Override
+            public void onLayoutChange(View v, int left, int top, int right,
+                    int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                    MmsLog.v(TAG, "mTextEditor onLayoutChange mUpdateForScrnOrientationChanged = "
+                            + mUpdateForScrnOrientationChanged);
+                }
+                if (mUpdateForScrnOrientationChanged) {
+                    mUiHandler.postDelayed(new Runnable() {
+                        @Override
+                        public void run() {
+                            updateCounter(mWorkingMessage.getText(), 0, 0, 0);
+                        }
+                    }, 1000);
+                    mUpdateForScrnOrientationChanged = false;
+                }
+            }
+        });
+
+        mTextCounter = (TextView) findViewById(R.id.text_counter);
+        mSendButtonMms = (TextView) findViewById(R.id.send_button_mms);
+        mSendButtonSms = (ImageButton) findViewById(R.id.send_button_sms);
+        mTypingStatus = (TextView) findViewById(R.id.ip_message_typing_status);
+        mRemoteStrangerText = (TextView) findViewById(R.id.ipmsg_joyn_stranger_remind);
+        mSendButtonMms.setOnClickListener(this);
+        mSendButtonSms.setOnClickListener(this);
+        mTopPanel = findViewById(R.id.recipients_subject_linear);
+        mTopPanel.setFocusable(false);
+        mAttachmentEditor = (AttachmentEditor) findViewById(R.id.attachment_editor);
+        mAttachmentEditor.setHandler(mAttachmentEditorHandler);
+        //mAttachmentEditorScrollView = findViewById(R.id.attachment_editor_scroll_view);
+        mQuickContact = (QuickContactBadge) findViewById(R.id.avatar);
+        mOpComposeExt.initResourceRefs((LinearLayout) findViewById(R.id.button_with_counter),
+                (TextView) findViewById(R.id.ct_text_counter),
+                mAttachmentEditor.mOpAttachmentEditorExt);
+    }
+
+    private void confirmDeleteDialog(OnClickListener listener, boolean locked) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        /// M: Code analyze 027,Add for deleting one message.@{
+        // Set different title and icon for locked message.
+        builder.setTitle(locked ? R.string.confirm_dialog_locked_title :
+            R.string.confirm_dialog_title);
+        builder.setIconAttribute(android.R.attr.alertDialogIcon);
+        /// @}
+        builder.setCancelable(true);
+        builder.setMessage(locked ? R.string.confirm_delete_locked_message :
+                    R.string.confirm_delete_message);
+        builder.setPositiveButton(R.string.delete, listener);
+        builder.setNegativeButton(R.string.no, null);
+        builder.show();
+    }
+
+    void undeliveredMessageDialog(long date) {
+        String body;
+
+        if (date >= 0) {
+            body = getString(R.string.undelivered_msg_dialog_body,
+                    MessageUtils.formatTimeStampString(this, date));
+        } else {
+            // FIXME: we can not get sms retry time.
+            body = getString(R.string.undelivered_sms_dialog_body);
+        }
+
+        Toast.makeText(this, body, Toast.LENGTH_LONG).show();
+    }
+
+    private void startMsgListQuery() {
+        startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 100);
+    }
+
+    private void startMsgListQuery(final int token, int delay) {
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (FolderModeUtils.getMmsDirMode()) {
+            return;
+        }
+        /// @}
+        if (isRecipientsEditorVisible()) {
+            return;
+        }
+
+        final Uri conversationUri = mOpComposeExt.startMsgListQuery(
+                mConversation.getUri(), mConversation.getThreadId());
+
+        MmsLog.dpi(TAG, "startMsgListQuery, uri= " + conversationUri + " timeout = " + delay);
+        if (conversationUri == null) {
+            log("##### startMsgListQuery: conversationUri is null, bail!");
+            return;
+        }
+
+        final long threadId = mConversation.getThreadId();
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "startMsgListQuery for " + conversationUri + ", threadId=" + threadId);
+        }
+
+        try {
+            if (token == MESSAGE_LIST_QUERY_TOKEN) {
+                mBackgroundQueryHandler.postDelayed(mQueryMsgListRunnable, delay);
+                 return;
+            }
+
+            // Kick off the new query
+            /// M: @{
+            // mBackgroundQueryHandler.startQuery(
+            mBackgroundQueryHandler.postDelayed(new Runnable() {
+                public void run() {
+                    /// M: If no listener, no need query anymore @{
+                        MmsLog.d(TAG, "mListQueryRunnable, to query, "
+                                + "activity=" + ComposeMessageActivity.this);
+                        if (mMsgListAdapter.getOnDataSetChangedListener() == null) {
+                            MmsLog.d(TAG, "mListQueryRunnable, no listener");
+                            return;
+                        }
+                    /// @}
+                    ///M: add for ipmessage
+                    boolean queryed = mIpCompose.startMsgListQuery(mBackgroundQueryHandler,
+                            token, threadId, conversationUri, PROJECTION, null, null, null);
+                    if (queryed) {
+                        return;
+                    }
+                    mBackgroundQueryHandler.startQuery(
+                            token,
+                            threadId /* cookie */,
+                            conversationUri,
+                            PROJECTION,
+                            null, null, null);
+                }
+            }, delay);
+            /// @}
+        } catch (SQLiteException e) {
+            SqliteWrapper.checkSQLiteException(this, e);
+        }
+    }
+
+    private void initMessageList() {
+        if (mMsgListAdapter != null) {
+            return;
+        }
+
+        String highlightString = getIntent().getStringExtra("highlight");
+        Pattern highlight = highlightString == null
+            ? null
+        /// M: ALPS00619099, highlight all matched search string, not only on word border @ {
+            : Pattern.compile(Pattern.quote(highlightString), Pattern.CASE_INSENSITIVE);
+        /// @}
+
+        // Initialize the list adapter with a null cursor.
+        mMsgListAdapter = new MessageListAdapter(this, null, mMsgListView, true, highlight);
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (FolderModeUtils.getMmsDirMode()) {
+            mMsgListView.setVisibility(View.GONE);
+            return;
+        }
+        /// @}
+        mMsgListAdapter.setMsgListItemHandler(mMessageListItemHandler);
+        mMsgListView.setAdapter(mMsgListAdapter);
+        mMsgListView.setSelector(android.R.color.transparent);
+        mMsgListView.setItemsCanFocus(false);
+        mMsgListView.setVisibility(View.VISIBLE);
+        mMsgListView.setOnCreateContextMenuListener(mMsgListMenuCreateListener);
+        mMsgListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                MmsLog.d(MessageListItem.TAG_DIVIDER, "OnItemClickListener(): view = " + view);
+                if (view != null) {
+                    ((MessageListItem) view).onMessageListItemClick();
+                }
+            }
+        });
+        /// M: Code analyze 050, Add scroll listener and touch listener for MessageListView.@{
+        /**
+         * M: Adjust the velocity scale and friction of messages list view,
+         * and The below two values are just experience
+         * values. For density > 2 which usually on FHD devices with larger(1.5x)
+         * friction, set Velocity scale to 0.6 For
+         * density <= 2, still use Velocity scale 0.4
+         */
+        final float density = getResources().getDisplayMetrics().density;
+        final float DEFAULT_DENSITY = 2.0f;
+        final float FHD_VELOCITY_SCALE = 0.6f;
+        final float DEFAULT_VELOCITY_SCALE = 0.4f;
+        final float DEFAULT_FRICTION = 0.005f;
+        Log.d(TAG, "getDisplayMetrics().density: " + density);
+
+        mMsgListView.setVelocityScale(density > DEFAULT_DENSITY
+                ? FHD_VELOCITY_SCALE : DEFAULT_VELOCITY_SCALE);
+        mMsgListView.setFriction(DEFAULT_FRICTION);
+        mMsgListView.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                hideInputMethod();
+                return false;
+            }
+        });
+        // add for ipmessage
+        mIpCompose.onIpInitMessageList(mMsgListView, mMsgListAdapter.mIpMessageListAdapter);
+    }
+
+    private void loadDraft() {
+        if (mWorkingMessage.isWorthSaving()) {
+            Log.w(TAG, "loadDraft() called with non-empty working message");
+            mWorkingMessage.checkDraftSmsMessage(mConversation);
+            return;
+        }
+
+        // add for ipmessage
+        if (mIpCompose.loadIpMessagDraft(mConversation.getThreadId())) {
+            return;
+        }
+
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            log("loadDraft() call WorkingMessage.loadDraft");
+        }
+
+        /// M:[Just Comment] 4.1 Code.  There may be a bug.
+        mWorkingMessage = WorkingMessage.loadDraft(this, mConversation,
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        drawTopPanel(false);
+                        drawBottomPanel();
+                        updateSendButtonState();
+                    }
+                });
+//        if (mConversation != null && mConversation.getRecipients() != null
+//                && mConversation.getRecipients().size() > 20) {
+//            MmsLog.d(TAG, "register mDraftChangeObserver");
+//            mContentResolver.registerContentObserver(
+//                    Mms.CONTENT_URI, true, mDraftChangeObserver);
+//        }
+    }
+
+    private void saveDraft(boolean isStopping) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("saveDraft");
+        }
+
+        // add for ipmessage
+        mIpCompose.onIpSaveDraft(mConversation.getThreadId());
+        /// @}
+        // TODO: Do something better here.  Maybe make discard() legal
+        // to call twice and make isEmpty() return true if discarded
+        // so it is caught in the clause above this one?
+        if (mWorkingMessage.isDiscarded()) {
+            return;
+        }
+
+        if (!mWaitingForSubActivity && !mWorkingMessage.isWorthSaving() &&
+                (!isRecipientsEditorVisible() || recipientCount() == 0
+                /* M: ALPS01821584. discard when onStop */ || isStopping)) {
+            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                log("not worth saving, discard WorkingMessage and bail");
+            }
+            mWorkingMessage.discard(false);
+            return;
+        }
+        /// M : Fix CR: ALPS00996195
+        /// group message, more than one recipients, no need to saveDraft,
+        /// is going to MultiDeleteActivity, just return. if contains draft, discard it @{
+        if (mIsStartMultiDeleteActivity) {
+            if (MmsPreferenceActivity.getIsGroupMmsEnabled(this) && !needSaveDraft()
+                && mConversation.getRecipients().size() > 1) {
+                Log.d("[Mms][Draft][ComposeMessageActivity]", "[saveDraft] group message & "
+                        + " no need save drat & mIsStartMultiDeleteActivity"
+                        + " true, then just return!");
+                if (mConversation.hasDraft()) {
+                    Log.d("[Mms][Draft][ComposeMessageActivity]",
+                            "[saveDraft] mConversation has draft, then delete it");
+                    mWorkingMessage.discard(false);
+                }
+                return;
+            }
+            /// M Fix CR ALPS01201355, which will save draft the contact contains email address.
+            /// when start multideleteactivity. if contains mms draft ,discard it @{
+            if (getRecipients().containsEmail() && !needSaveDraft()) {
+                Log.d("[Mms][Draft][ComposeMessageActivity]", "[saveDraft] contains email address"
+                    + ",no need to save draft, just return!!");
+                if (mConversation.hasDraft()) {
+                    Log.d("[Mms][Draft][ComposeMessageActivity]",
+                            "[saveDraft] mConversation has draft, then delete it");
+                    mWorkingMessage.discard(false);
+                }
+                return;
+            }
+            /// @}
+        }
+        /// @}
+
+        mOpComposeExt.saveDraft(mWorkingMessage.mOpWorkingMessageExt);
+
+        Log.d("[Mms][Draft][ComposeMessageActivity]", "[saveDraft] call workingmessage.saveDraft");
+        mWorkingMessage.saveDraft(isStopping);
+
+        if (mToastForDraftSave && MmsConfig.isSmsEnabled(this)) {
+            Toast.makeText(this, R.string.message_saved_as_draft,
+                    Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    private boolean isPreparedForSending() {
+        /// M: Code analyze 029,Add sub card state as a ready condition. @{
+        /*
+        int recipientCount = recipientCount();
+
+        return recipientCount > 0 && recipientCount <= MmsConfig.getRecipientLimit() &&
+            (mWorkingMessage.hasAttachment() ||
+                    mWorkingMessage.hasText() ||
+                    mWorkingMessage.hasSubject());
+        */
+
+        if (isRecipientsEditorVisible()) {
+            String recipientText = mRecipientsEditor.getText() == null ?
+                    "" : mRecipientsEditor.getText().toString();
+
+            return mSubCount > 0 && !TextUtils.isEmpty(recipientText) && mIsSmsEnabled
+                    && (mWorkingMessage.hasAttachment() || mWorkingMessage.hasText()
+                            || mWorkingMessage.hasSubject());
+        } else {
+            return mSubCount > 0 && mIsSmsEnabled && (mWorkingMessage.hasAttachment()
+                    || mWorkingMessage.hasText()
+                            || mWorkingMessage.hasSubject());
+        }
+        /// @}
+    }
+
+    private int recipientCount() {
+        int recipientCount;
+
+        // To avoid creating a bunch of invalid Contacts when the recipients
+        // editor is in flux, we keep the recipients list empty.  So if the
+        // recipients editor is showing, see if there is anything in it rather
+        // than consulting the empty recipient list.
+        if (isRecipientsEditorVisible()) {
+            recipientCount = mRecipientsEditor.getRecipientCount();
+        } else {
+            recipientCount = getRecipients().size();
+        }
+        return recipientCount;
+    }
+
+    public void sendMessage(boolean bCheckEcmMode) {
+        if (mWorkingMessage.requiresMms() && (mWorkingMessage.hasSlideshow()
+                || mWorkingMessage.hasAttachment())) {
+            int messageSize = 0;
+            messageSize = mWorkingMessage.getCurrentMessageSize();
+            MmsLog.d(TAG, "Compose.sendMessage(): messageSize=" + messageSize);
+            if (messageSize > MmsConfig.getUserSetMmsSizeLimit(true)) {
+                MessageUtils.showErrorDialog(ComposeMessageActivity.this,
+                        R.string.exceed_message_size_limitation,
+                        R.string.exceed_message_size_limitation, 0, 0);
+                updateSendButtonState();
+                return;
+            }
+        }
+
+        if (bCheckEcmMode) {
+            // TODO: expose this in telephony layer for SDK build
+            int phoneId = SubscriptionManager.getPhoneId(mSelectedSubId);
+            String inEcm = TelephonyManager.getTelephonyProperty(phoneId,
+                    TelephonyProperties.PROPERTY_INECM_MODE, null);
+            //String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE);
+            if (Boolean.parseBoolean(inEcm)) {
+                try {
+                    startActivityForResult(
+                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),
+                            REQUEST_CODE_ECM_EXIT_DIALOG);
+                    return;
+                } catch (ActivityNotFoundException e) {
+                    // continue to send message
+                    Log.e(TAG, "Cannot find EmergencyCallbackModeExitDialog", e);
+                }
+            }
+        }
+
+        if (mOpComposeExt.sendMessage(mWorkingMessage.mOpWorkingMessageExt, mSelectedSubId)) {
+            return;
+        }
+
+        /// M: Fix bug ALPS00407718
+        if (mExitOnSent) {
+            hideKeyboard();
+        }
+        /// M: Code analyze 011, use another method for performance.(update mDebugRecipients)@{
+        ContactList contactList = isRecipientsEditorVisible() ?
+                mRecipientsEditor.constructContactsFromInput(false) : getRecipients();
+        mDebugRecipients = contactList.serialize();
+        /// @}
+
+        if (!mSendingMessage) {
+            if (LogTag.SEVERE_WARNING) {
+                String sendingRecipients = mConversation.getRecipients().serialize();
+                if (!sendingRecipients.equals(mDebugRecipients)) {
+                    String workingRecipients = mWorkingMessage.getWorkingRecipients();
+                    if (!mDebugRecipients.equals(workingRecipients)) {
+                    }
+                }
+                sanityCheckConversation();
+            }
+
+            // send can change the recipients. Make sure we remove the listeners first and then add
+            // them back once the recipient list has settled.
+            removeRecipientsListeners();
+
+            /// M: If msg can be sent, AttachmentEditor can not be reponsed.
+            mClickCanResponse = false;
+            /// M:the method is extend to support gemini @{
+            mWorkingMessage.send(mDebugRecipients, mSelectedSubId);
+            MmsLog.d(TAG, "Compose.sendMessage(): after sendMessage. mConversation.ThreadId="
+                    + mConversation.getThreadId()
+                    + ", MessageCount=" + mConversation.getMessageCount());
+            /// @}
+            /** M:
+             *   If message count is 0, it should be a new message.
+             *   After tap send button, the sent message will have draft flag for a short time.
+             *   That means, the message count will be 0 for a short time.
+             *   If user tap home key in this short time, it will change the
+             *   conversation id to 0 in the method savedraft().
+             *   When the screen is back to Message Composer, it will
+             *   query database with thread(conversation) id 0.
+             *   So, it will query for nothing. The screen is always blank.
+             *   Fix this issue by force to set message count with 1.
+             */
+            if (mConversation.getMessageCount() == 0) {
+                mConversation.setMessageCount(1);
+            }
+            /// M: @{
+            mWaitingForSendMessage = true;
+            /// M: when tap fail icon, don't add recipients
+            isInitRecipientsEditor = false;
+            mMsgListView.setVisibility(View.VISIBLE);
+            /// @}
+
+            mSentMessage = true;
+            mSendingMessage = true;
+            addRecipientsListeners();
+
+            mScrollOnSend = true;   // in the next onQueryComplete, scroll the list to the end.
+            // M: reset mCutRecipients
+            mCutRecipients = null;
+        }
+        // But bail out if we are supposed to exit after the message is sent.
+        if (mExitOnSent) {
+            /// M: fix bug ALPS00722349, update thread after forward message, avoid conversation
+            /// draft state become abnormal.
+            boolean isChecked = mConversation.isChecked();
+            mConversation = Conversation.upDateThread(getApplicationContext(),
+                    mConversation.getThreadId(), false);
+            mConversation.setIsChecked(isChecked);
+            ///M: add for guarantee the message sent. @{
+            mUiHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    finish();
+                }
+            }, 150);
+            /// @}
+        }
+    }
+
+    private void resetMessage() {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            log("resetMessage");
+        }
+
+        /// M: should hide RecipientsEditor before TextEditor requestFocus. To avoid do
+        /// afterTextChange after message sent.
+        hideRecipientEditor();
+        updateTitle(mConversation.getRecipients());
+
+        // Make the attachment editor hide its view.
+        mAttachmentEditor.hideView();
+//            mAttachmentEditorScrollView.setVisibility(View.GONE);
+        ///M: change the order between Editor.requestFocus & showSubjectEditor
+        /// for fix issue ALPS00569570 @{
+        // Focus to the text editor.
+        mTextEditor.requestFocus();
+
+        // Hide the subject editor.
+        showSubjectEditor(false);
+        /// @}
+
+        mOpComposeExt.resetMessage();
+
+        // We have to remove the text change listener while the text editor gets cleared and
+        // we subsequently turn the message back into SMS. When the listener is listening while
+        // doing the clearing, it's fighting to update its counts and itself try and turn
+        // the message one way or the other.
+        mTextEditor.removeTextChangedListener(mTextEditorWatcher);
+
+        // Clear the text box.
+        TextKeyListener.clear(mTextEditor.getText());
+
+        mWorkingMessage.clearConversation(mConversation, false);
+        mWorkingMessage = WorkingMessage.createEmpty(this);
+        mWorkingMessage.setConversation(mConversation);
+
+
+
+        if ((mMessageSubId == Settings.System.DEFAULT_SIM_SETTING_ALWAYS_ASK
+                || mMessageSubId == Settings.System.DEFAULT_SIM_NOT_SET)) {
+            mSelectedSubId = 0;
+        }
+
+        drawBottomPanel();
+
+        // "Or not", in this case.
+        updateSendButtonState();
+        // add for ipmessage
+        mIpCompose.onIpResetMessage();
+        // Our changes are done. Let the listener respond to text changes once again.
+        mTextEditor.removeTextChangedListener(mTextEditorWatcher);
+        mTextEditor.addTextChangedListener(mTextEditorWatcher);
+
+        // Close the soft on-screen keyboard if we're in landscape mode so the user can see the
+        // conversation.
+        ///M: but when the device was tablet, we can't hide the IME
+        boolean isTablet = getResources().getBoolean(R.bool.isTablet);
+        if (mIsLandscape && !isTablet) {
+            hideKeyboard();
+        }
+
+        mLastRecipientCount = 0;
+        mSendingMessage = false;
+        invalidateOptionsMenu();
+        /// M: update list, this must put after hideRecipientEditor(); to avoid a bug.
+        startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 0);
+        /// M: reset flags
+        mClickCanResponse = true;
+   }
+
+    private void hideKeyboard() {
+        MmsLog.d(TAG, "hideKeyboard()");
+        InputMethodManager inputMethodManager =
+            (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+        inputMethodManager.hideSoftInputFromWindow(mTextEditor.getWindowToken(), 0);
+    }
+
+    public void updateSendButtonState() {
+        boolean enable = false;
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            MmsLog.v(TAG, "lzd updateSendButtonState(): isPreparedForSending = "
+                    + isPreparedForSending());
+        }
+        if (isPreparedForSending()) {
+            /// M: Code analyze 049, Update send button or attachment editor state.@{
+            MmsLog.i(TAG, "updateSendButtonState(): mSubCount = " + mSubCount
+                    + " hasSlideshow = " + mWorkingMessage.hasSlideshow());
+            if (mSubCount > 0) {
+                // When the type of attachment is slideshow, we should
+                // also hide the 'Send' button since the slideshow view
+                // already has a 'Send' button embedded.
+                if (!mWorkingMessage.hasSlideshow()) {
+                    enable = true;
+                } else {
+                    mAttachmentEditor.setCanSend(true);
+                }
+            }
+        } else {
+            // / @}
+            mAttachmentEditor.setCanSend(false);
+        }
+
+        boolean requiresMms = mWorkingMessage.requiresMms();
+
+        if (mOpComposeExt.updateSendButton(enable, mSubCount, requiresMms,
+                                           mWorkingMessage.hasSlideshow())) {
+            return;
+        }
+
+        View sendButton = showSmsOrMmsSendButton(requiresMms);
+        if (!requiresMms && (recipientCount() > MmsConfig.getSmsRecipientLimit())) {
+            enable = false;
+        }
+        if (!MmsConfig.isSmsEnabled(this)) {
+            enable = false;
+        }
+        if (MessageUtils.isUseSubSimulator()) {
+            enable = true;
+        }
+        if (sendButton != null) {
+            sendButton.setEnabled(enable);
+            sendButton.setFocusable(enable);
+        }
+    }
+
+    private long getMessageDate(Uri uri) {
+        if (uri != null) {
+            Cursor cursor = SqliteWrapper.query(this, mContentResolver,
+                    uri, new String[] { Mms.DATE }, null, null, null);
+            if (cursor != null) {
+                try {
+                    if ((cursor.getCount() == 1) && cursor.moveToFirst()) {
+                        return cursor.getLong(0) * 1000L;
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+        }
+        return NO_DATE_FOR_DIALOG;
+    }
+
+/// M: @{
+//    private void initActivityState(Intent intent) {
+//        // If we have been passed a thread_id, use that to find our conversation.
+//        long threadId = intent.getLongExtra("thread_id", 0);
+//        if (threadId > 0) {
+//            if (LogTag.VERBOSE) log("get mConversation by threadId " + threadId);
+//            mConversation = Conversation.get(this, threadId, false);
+//        } else {
+//            Uri intentData = intent.getData();
+//            if (intentData != null) {
+//                // try to get a conversation based on the data URI passed to our intent.
+//                if (LogTag.VERBOSE) log("get mConversation by intentData " + intentData);
+//                mConversation = Conversation.get(this, intentData, false);
+//                mWorkingMessage.setText(getBody(intentData));
+//            } else {
+//                // special intent extra parameter to specify the address
+//                String address = intent.getStringExtra("address");
+//                if (!TextUtils.isEmpty(address)) {
+//                    if (LogTag.VERBOSE) log("get mConversation by address " + address);
+//                    mConversation = Conversation.get(this, ContactList.getByNumbers(address,
+//                            false /* don't block */, true /* replace number */), false);
+//                } else {
+//                    if (LogTag.VERBOSE) log("create new conversation");
+//                    mConversation = Conversation.createNew(this);
+//                }
+//            }
+//        }
+//        addRecipientsListeners();
+//
+//        mExitOnSent = intent.getBooleanExtra("exit_on_sent", false);
+//        if (intent.hasExtra("sms_body")) {
+//            mWorkingMessage.setText(intent.getStringExtra("sms_body"));
+//        }
+//        mWorkingMessage.setSubject(intent.getStringExtra("subject"), false);
+//    }
+    private void initActivityState(Bundle bundle) {
+        Intent intent = getIntent();
+        /// M: Code analyze 033, Save some useful information in order to restore the draft when
+        /// activity restarting.@{
+        mIsTooManyRecipients = false;
+        if (bundle != null) {
+            mCompressingImage = bundle.getBoolean("compressing_image", false);
+            String recipientsStr = bundle.getString("recipients");
+            int recipientCount = 0;
+            if (recipientsStr != null) {
+                recipientCount = recipientsStr.split(";").length;
+                mConversation = Conversation.get(getApplicationContext(),
+                    ContactList.getByNumbers(recipientsStr,
+                            false /* don't block */, true /* replace number */), false);
+            } else {
+                Long threadId = bundle.getLong("thread", 0);
+                mConversation = Conversation.get(getApplicationContext(), threadId, false);
+            }
+            // M: fix bug ALPS00352078
+            mWorkingMessage.setConversation(mConversation);
+
+            mExitOnSent = bundle.getBoolean(KEY_EXIT_ON_SENT, false);
+            mForwardMessageMode = bundle.getBoolean(KEY_FORWARDED_MESSAGE, false);
+
+            mWorkingMessage.readStateFromBundle(bundle);
+            /// M: Code analyze 010, Support dirtory mode. @{
+            if (FolderModeUtils.getMmsDirMode()) {
+                mExitOnSent = true;
+            }
+            /// @}
+            if (!mCompressingImage && mConversation.hasDraft()
+                    && mConversation.getMessageCount() == 0) {
+                if (!mWorkingMessage.requiresMms()) {
+                    Log.w(TAG, "delete sms draft");
+                    mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
+                } else {
+                    if (mWorkingMessage.getSlideshow() != null
+                            && mWorkingMessage.getSlideshow().size() == 1
+                            && !mWorkingMessage.getSlideshow().get(0).hasAudio()
+                            && !mWorkingMessage.getSlideshow().get(0).hasImage()
+                            && !mWorkingMessage.getSlideshow().get(0).hasVideo()
+                            && mWorkingMessage.getSlideshow().sizeOfFilesAttach() == 0) {
+                        mWorkingMessage.asyncDeleteDraftMmsMessage(mConversation);
+                        mWorkingMessage.removeAllFileAttaches();
+                        mWorkingMessage.removeAttachment(false);
+                    }
+                }
+                mWorkingMessage.clearConversation(mConversation, true);
+            }
+            if (recipientCount > RECIPIENTS_LIMIT_FOR_SMS) {
+                mIsTooManyRecipients = true;
+            }
+            mCompressingImage = false;
+
+            mAppendAttachmentSign = bundle.getBoolean(KEY_APPEND_MESSAGE, true);
+            MmsLog.d(TAG, "initActivityState mAppendAttachmentSign : " + mAppendAttachmentSign);
+            /// @}
+            return;
+        }
+        /// M: Code analyze 019, Add vcard attachment.  @{
+        long[] contactsIds = VCardUtils.getContactsIds(
+                intent.getStringExtra("multi_export_contacts"));
+        /// @}
+        // If we have been passed a thread_id, use that to find our conversation.
+        long threadId = intent.getLongExtra("thread_id", 0);
+        if (threadId > 0) {
+            if (LogTag.VERBOSE) log("get mConversation by threadId " + threadId);
+            mConversation = Conversation.get(getApplicationContext(), threadId, false);
+        /// M: Code analyze 019, Add vcard attachment.  @{
+        } else if (contactsIds != null && contactsIds.length > 0) {
+            //addTextVCard(contactsIds);
+            addTextVCardAsync(contactsIds);
+            mConversation = Conversation.createNew(getApplicationContext());
+            return;
+        /// @}
+        } else {
+            Uri intentData = intent.getData();
+            /// M: Code analyze 034, If intent is SEND,just create a new empty thread,
+            /// otherwise Conversation.get() will throw exception.
+            String action = intent.getAction();
+            if (intentData != null && (TextUtils.isEmpty(action) ||
+                            !action.equals(Intent.ACTION_SEND))) {
+                /// M: group-contact send message
+                // try to get a conversation based on the data URI passed to our intent.
+                if (intentData.getPathSegments().size() < 2) {
+                    mConversation = mConversation.get(getApplicationContext(),
+                            ContactList.getByNumbers(
+                           getStringForMultipleRecipients(Conversation.getRecipients(intentData)),
+                                 false /* don't block */, true /* replace number */), false);
+                } else {
+                    mConversation = Conversation.get(getApplicationContext(), intentData, false);
+                }
+                /// @}
+                mWorkingMessage.setText(getBody(intentData));
+            } else {
+                // special intent extra parameter to specify the address
+                String address = intent.getStringExtra("address");
+                if (!TextUtils.isEmpty(address)) {
+                    if (LogTag.VERBOSE) log("get mConversation by address ");
+                    mConversation = Conversation.get(getApplicationContext(),
+                            ContactList.getByNumbers(address,
+                            false /* don't block */, true /* replace number */), false);
+                } else {
+                    if (LogTag.VERBOSE) log("create new conversation");
+                    mConversation = Conversation.createNew(getApplicationContext());
+                }
+            }
+        }
+        //addRecipientsListeners();
+        updateThreadIdIfRunning();
+
+        mExitOnSent = intent.getBooleanExtra(KEY_EXIT_ON_SENT, false);
+        mForwardMessageMode = intent.getBooleanExtra(KEY_FORWARDED_MESSAGE, false);
+        if (intent.hasExtra("sms_body")) {
+            /// M: Code analyze 017, Handle forwarded message.(see:forwardMessage()).
+            /// Forward sms message and set sms body.@{
+            String sms_body = intent.getStringExtra("sms_body");
+            /// M: Modify for ALPS00759207
+            mWorkingMessage.setText(sms_body);
+            /// @}
+        }
+        mWorkingMessage.setSubject(intent.getStringExtra("subject"), false);
+
+        /// M: Code analyze 010, Support dirtory mode. @{
+        if (FolderModeUtils.getMmsDirMode()) {
+            mExitOnSent = true;
+        }
+        /// @}
+        mOpComposeExt.initActivityState(intent);
+    }
+
+    private void initFocus() {
+        if (!mIsKeyboardOpen) {
+            return;
+        }
+
+        mOpComposeExt.initFocus();
+
+        // If the recipients editor is visible, there is nothing in it,
+        // and the text editor is not already focused, focus the
+        // recipients editor.
+        if (isRecipientsEditorVisible()
+                && TextUtils.isEmpty(mRecipientsEditor.getText())
+                && !mTextEditor.isFocused()) {
+            mRecipientsEditor.requestFocus();
+            return;
+        }
+
+        // If we decided not to focus the recipients editor, focus the text editor.
+        if (mSubjectTextEditor == null
+                || (mSubjectTextEditor != null && !mSubjectTextEditor.isFocused())) {
+            if ((mBottomPanel != null) && (mBottomPanel.getVisibility() == View.VISIBLE)) {
+                mTextEditor.requestFocus();
+            }
+        }
+    }
+
+    private final MessageListAdapter.OnDataSetChangedListener
+                    mDataSetChangedListener = new MessageListAdapter.OnDataSetChangedListener() {
+        @Override
+        public void onDataSetChanged(MessageListAdapter adapter) {
+            mPossiblePendingNotification = true;
+        }
+
+        @Override
+        public void onContentChanged(MessageListAdapter adapter) {
+        /// M: @{
+            if (mMsgListAdapter != null &&
+                mMsgListAdapter.getOnDataSetChangedListener() != null) {
+                MmsLog.d(TAG, "OnDataSetChangedListener is not cleared");
+                startMsgListQuery();
+            } else {
+                MmsLog.d(TAG, "OnDataSetChangedListener is cleared");
+            }
+        /// @}
+        }
+    };
+
+    private void checkPendingNotification() {
+        if (mPossiblePendingNotification && hasWindowFocus()) {
+            /// M: add for ip message, remove mark as read
+//            mConversation.markAsRead();
+            mPossiblePendingNotification = false;
+        }
+    }
+
+    /**
+     * smoothScrollToEnd will scroll the message list to the bottom if the list is already near
+     * the bottom. Typically this is called to smooth scroll a newly received message into view.
+     * It's also called when sending to scroll the list to the bottom, regardless of where it is,
+     * so the user can see the just sent message. This function is also called when the message
+     * list view changes size because the keyboard state changed or the compose message field grew.
+     *
+     * @param force always scroll to the bottom regardless of current list position
+     * @param listSizeChange the amount the message list view size has vertically changed
+     */
+    private void smoothScrollToEnd(boolean force, int listSizeChange) {
+        int lastItemVisible = mMsgListView.getLastVisiblePosition();
+        int lastItemInList = mMsgListAdapter.getCount() - 1;
+        if (lastItemVisible < 0 || lastItemInList < 0) {
+            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                Log.v(TAG, "smoothScrollToEnd: lastItemVisible=" + lastItemVisible +
+                        ", lastItemInList=" + lastItemInList +
+                        ", mMsgListView not ready");
+            }
+            return;
+        }
+
+        View lastChildVisible =
+                mMsgListView.getChildAt(lastItemVisible - mMsgListView.getFirstVisiblePosition());
+        int lastVisibleItemBottom = 0;
+        int lastVisibleItemHeight = 0;
+        if (lastChildVisible != null) {
+            lastVisibleItemBottom = lastChildVisible.getBottom();
+            lastVisibleItemHeight = lastChildVisible.getHeight();
+        }
+
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            Log.v(TAG, "smoothScrollToEnd newPosition: " + lastItemInList +
+                    " mLastSmoothScrollPosition: " + mLastSmoothScrollPosition +
+                    " first: " + mMsgListView.getFirstVisiblePosition() +
+                    " lastItemVisible: " + lastItemVisible +
+                    " lastVisibleItemBottom: " + lastVisibleItemBottom +
+                    " lastVisibleItemBottom + listSizeChange: " +
+                    (lastVisibleItemBottom + listSizeChange) +
+                    " mMsgListView.getHeight() - mMsgListView.getPaddingBottom(): " +
+                    (mMsgListView.getHeight() - mMsgListView.getPaddingBottom()) +
+                    " listSizeChange: " + listSizeChange);
+        }
+        // Only scroll if the list if we're responding to a newly sent message (force == true) or
+        // the list is already scrolled to the end. This code also has to handle the case where
+        // the listview has changed size (from the keyboard coming up or down or the message entry
+        // field growing/shrinking) and it uses that grow/shrink factor in listSizeChange to
+        // compute whether the list was at the end before the resize took place.
+        // For example, when the keyboard comes up, listSizeChange will be negative, something
+        // like -524. The lastChild listitem's bottom value will be the old value before the
+        // keyboard became visible but the size of the list will have changed. The test below
+        // add listSizeChange to bottom to figure out if the old position was already scrolled
+        // to the bottom. We also scroll the list if the last item is taller than the size of the
+        // list. This happens when the keyboard is up and the last item is an mms with an
+        // attachment thumbnail, such as picture. In this situation, we want to scroll the list so
+        // the bottom of the thumbnail is visible and the top of the item is scroll off the screen.
+        int listHeight = mMsgListView.getHeight();
+        boolean lastItemTooTall = lastVisibleItemHeight > listHeight;
+        boolean willScroll = force ||
+                ((listSizeChange != 0 || lastItemInList != mLastSmoothScrollPosition) &&
+                lastVisibleItemBottom + listSizeChange <=
+                    listHeight - mMsgListView.getPaddingBottom());
+        if (willScroll || (lastItemTooTall && lastItemInList == lastItemVisible)) {
+            if (Math.abs(listSizeChange) > SMOOTH_SCROLL_THRESHOLD) {
+                // When the keyboard comes up, the window manager initiates a cross fade
+                // animation that conflicts with smooth scroll. Handle that case by jumping the
+                // list directly to the end.
+                if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    Log.v(TAG, "keyboard state changed. setSelection=" + lastItemInList);
+                }
+                if (lastItemTooTall) {
+                    // If the height of the last item is taller than the whole height of the list,
+                    // we need to scroll that item so that its top is negative or above the top of
+                    // the list. That way, the bottom of the last item will be exposed above the
+                    // keyboard.
+                    mMsgListView.setSelectionFromTop(lastItemInList,
+                            listHeight - lastVisibleItemHeight);
+                } else {
+                    mMsgListView.setSelection(lastItemInList);
+                }
+            } else if (lastItemInList - lastItemVisible > MAX_ITEMS_TO_INVOKE_SCROLL_SHORTCUT) {
+                if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    Log.v(TAG, "too many to scroll, setSelection=" + lastItemInList);
+                }
+                mMsgListView.setSelection(lastItemInList);
+            } else {
+                if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    Log.v(TAG, "smooth scroll to " + lastItemInList);
+                }
+                if (lastItemTooTall) {
+                    // If the height of the last item is taller than the whole height of the list,
+                    // we need to scroll that item so that its top is negative or above the top of
+                    // the list. That way, the bottom of the last item will be exposed above the
+                    // keyboard. We should use smoothScrollToPositionFromTop here, but it doesn't
+                    // seem to work -- the list ends up scrolling to a random position.
+                    mMsgListView.setSelectionFromTop(lastItemInList,
+                            listHeight - lastVisibleItemHeight);
+                } else {
+                    mMsgListView.smoothScrollToPosition(lastItemInList);
+                }
+                mLastSmoothScrollPosition = lastItemInList;
+            }
+        }
+    }
+
+    private final class BackgroundQueryHandler extends ConversationQueryHandler {
+        public BackgroundQueryHandler(ContentResolver contentResolver) {
+            super(contentResolver);
+        }
+
+        @Override
+        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+            /// M: @{
+            MmsLog.d(TAG, "onQueryComplete, token=" + token + "activity="
+                    + ComposeMessageActivity.this);
+            /// @}
+            switch(token) {
+                case MESSAGE_LIST_QUERY_TOKEN:
+                    /// @}
+                    if (cursor == null) {
+                        MmsLog.w(TAG, "onQueryComplete, cursor is null.");
+                        return;
+                    }
+                    /// M: If adapter or listener has been cleared, just close this cursor@{
+                    if (mMsgListAdapter == null) {
+                        MmsLog.w(TAG, "onQueryComplete, mMsgListAdapter is null.");
+                        cursor.close();
+                        return;
+                    }
+                    if (mMsgListAdapter.getOnDataSetChangedListener() == null) {
+                        MmsLog.d(TAG, "OnDataSetChangedListener is cleared");
+                        cursor.close();
+                        return;
+                    }
+                    /// @}
+                    if (isRecipientsEditorVisible()) {
+                        MmsLog.d(TAG, "RecipientEditor visible, it means no messagelistItem!");
+                        return;
+                    }
+                    // check consistency between the query result and 'mConversation'
+                    long tid = (Long) cookie;
+
+                    if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                        log("##### onQueryComplete: msg history result for threadId " + tid);
+                    }
+                    if (tid != mConversation.getThreadId()) {
+                        log("onQueryComplete: msg history query result is for threadId " +
+                                tid + ", but mConversation has threadId " +
+                                mConversation.getThreadId() + " starting a new query");
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                        startMsgListQuery();
+                        return;
+                    }
+
+                    // check consistency b/t mConversation & mWorkingMessage.mConversation
+                    ComposeMessageActivity.this.sanityCheckConversation();
+
+                    int newSelectionPos = -1;
+                    long targetMsgId = getIntent().getLongExtra("select_id", -1);
+                    String targetMsgType = getIntent().getStringExtra("msg_type");
+                    if (targetMsgId != -1) {
+                      if (cursor != null) {
+                        cursor.moveToPosition(-1);
+                        while (cursor.moveToNext()) {
+                            long msgId = cursor.getLong(COLUMN_ID);
+                            String messageType = cursor.getString(COLUMN_MSG_TYPE);
+                            if (msgId == targetMsgId && messageType.equals(targetMsgType)) {
+                                newSelectionPos = cursor.getPosition();
+                                getIntent().putExtra("select_id", -1);
+                                break;
+                            }
+                          }
+                        }
+                    } else if (mSavedScrollPosition != -1) {
+                        // mSavedScrollPosition is set when this activity pauses. If equals maxint,
+                        // it means the message list was scrolled to the end. Meanwhile, messages
+                        // could have been received. When the activity resumes and we were
+                        // previously scrolled to the end, jump the list so any new messages are
+                        // visible.
+                        if (mSavedScrollPosition == Integer.MAX_VALUE) {
+                            int cnt = mMsgListAdapter.getCount();
+                            if (cnt > 0) {
+                                // Have to wait until the adapter is loaded before jumping to
+                                // the end.
+                                newSelectionPos = cnt - 1;
+                                mSavedScrollPosition = -1;
+                            }
+                        } else {
+                            // remember the saved scroll position before the activity is paused.
+                            // reset it after the message list query is done
+                            newSelectionPos = mSavedScrollPosition;
+                            mSavedScrollPosition = -1;
+                        }
+                    }
+                    /// M: Code analyze 047, Extra uri from message body and get number from uri.
+                    /// Then use this number to update contact cache. @{
+                    if (mNeedUpdateContactForMessageContent) {
+                        updateContactCache(cursor);
+                        mNeedUpdateContactForMessageContent = false;
+                    }
+                    /// @}
+
+                    mMsgListAdapter.changeCursor(cursor);
+
+                    if (newSelectionPos != -1) {
+                        /// M: remove bug ALPS00404266 patch, keep item top @{
+                        mMsgListView.setSelection(newSelectionPos);     // jump the list to the pos
+                        //View child = mMsgListView.getChildAt(newSelectionPos);
+                        //int top = 0;
+                        //if (child != null) {
+                        //    top = child.getTop();
+                        //}
+                       // mMsgListView.setSelectionFromTop(newSelectionPos, top);
+                        /// @}
+                    } else {
+                        /// M: google jb.mr1 patch, Conversation should scroll to the bottom
+                        /// when incoming received @{
+                        int count = mMsgListAdapter.getCount();
+                        long lastMsgId = 0;
+                        if (cursor != null && count > 0) {
+                            cursor.moveToLast();
+                            lastMsgId = cursor.getLong(COLUMN_ID);
+                        }
+                        // mScrollOnSend is set when we send a message. We always want to scroll
+                        // the message list to the end when we send a message, but have to wait
+                        // until the DB has changed. We also want to scroll the list when a
+                        // new message has arrived.
+                        smoothScrollToEnd(mScrollOnSend || lastMsgId != mLastMessageId, 0);
+                        mLastMessageId = lastMsgId;
+                        /// @}
+                        mScrollOnSend = false;
+                    }
+                    // Adjust the conversation's message count to match reality. The
+                    // conversation's message count is eventually used in
+                    // WorkingMessage.clearConversation to determine whether to delete
+                    // the conversation or not.
+                    if (mMsgListAdapter.getCount() == 0 && mWaitingForSendMessage) {
+                        mConversation.setMessageCount(1);
+                    } else {
+                        mConversation.setMessageCount(mMsgListAdapter.getCount());
+                    }
+                    updateThreadIdIfRunning();
+                    cursor.moveToPosition(-1);
+                    while (cursor.moveToNext()) {
+                        int read = cursor.getInt(MessageListAdapter.COLUMN_MMS_READ);
+                        read += cursor.getInt(MessageListAdapter.COLUMN_SMS_READ);
+                        if (read == 0) {
+                            mConversation.setHasUnreadMessages(true);
+                            break;
+                        }
+                    }
+                    MmsLog.d(TAG, "onQueryComplete(): Conversation.ThreadId="
+                            + mConversation.getThreadId()
+                            + ", MessageCount=" + mConversation.getMessageCount());
+
+                    // Once we have completed the query for the message history, if
+                    // there is nothing in the cursor and we are not composing a new
+                    // message, we must be editing a draft in a new conversation (unless
+                    // mSentMessage is true).
+                    // Show the recipients editor to give the user a chance to add
+                    // more people before the conversation begins.
+                    if (cursor != null && cursor.getCount() == 0
+                            && !isRecipientsEditorVisible() && !mSentMessage) {
+                        /// M: fix bug ALPS01098902, avoding checkObsoleteThreadId in this case
+                        if (mSubSelectDialog != null && mSubSelectDialog.isShowing()
+                                && mOldThreadID > 0 && mCutRecipients != null) {
+                            mIsSameConv = false;
+                        }
+                        initRecipientsEditor(null);
+                    }
+
+                    // FIXME: freshing layout changes the focused view to an unexpected
+                    // one, set it back to TextEditor forcely.
+                    if (mSubjectTextEditor == null || (mSubjectTextEditor != null
+                            && !mSubjectTextEditor.isFocused())) {
+                        mTextEditor.requestFocus();
+                    }
+
+                    invalidateOptionsMenu();    // some menu items depend on the adapter's count
+                    if (!mIsActivityStoped) {
+                        mConversation.blockMarkAsRead(false);
+                        mConversation.markAsRead();
+                    }
+                    return;
+
+                case MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN:
+                    // check consistency between the query result and 'mConversation'
+                    tid = (Long) cookie;
+
+                    if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                        log("## onQueryComplete (after delete): msg history result for threadId "
+                                + tid);
+                    }
+                    if (cursor == null) {
+                        return;
+                    }
+                    if (tid > 0 && cursor.getCount() == 0) {
+                        // We just deleted the last message and the thread will get deleted
+                        // by a trigger in the database. Clear the threadId so next time we
+                        // need the threadId a new thread will get created.
+                        log("##### MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN clearing thread id: "
+                                + tid);
+                        Conversation conv = Conversation.get(getApplicationContext(), tid,
+                                false);
+                        if (conv != null) {
+                            conv.clearThreadId();
+                            conv.setDraftState(false);
+                        }
+                    }
+                    cursor.close();
+                    break;
+                default:
+                    MmsLog.w(TAG, "unknown token.");
+                    break;
+            }
+        }
+
+        @Override
+        protected void onDeleteComplete(int token, Object cookie, int result) {
+            super.onDeleteComplete(token, cookie, result);
+            /// M: fix bug ALPS00351620; for requery searchactivity.
+            SearchActivity.setNeedRequery();
+            switch(token) {
+                case ConversationList.DELETE_CONVERSATION_TOKEN:
+                    /// M: @{
+                    /*
+                    mConversation.setMessageCount(0);
+                    // fall through
+                    */
+                    try {
+                        if (TelephonyManagerEx.getDefault().isTestIccCard(0)) {
+                            MmsLog.d(TAG, "All threads has been deleted, send notification..");
+                            SmsManager
+                                .getSmsManagerForSubscriptionId(
+                                   SmsReceiverService.sLastIncomingSmsSubId)
+                                       .getDefault().setSmsMemoryStatus(true);
+                        }
+                    } catch (Exception ex) {
+                        MmsLog.e(TAG, " " + ex.getMessage());
+                    }
+                    // Update the notification for new messages since they
+                    // may be deleted.
+                    MessagingNotification.nonBlockingUpdateNewMessageIndicator(
+                            ComposeMessageActivity.this, MessagingNotification.THREAD_NONE, false);
+                    // Update the notification for failed messages since they
+                    // may be deleted.
+                    updateSendFailedNotification();
+                    MessagingNotification.updateDownloadFailedNotification(
+                            ComposeMessageActivity.this);
+                    break;
+                    /// @}
+                case DELETE_MESSAGE_TOKEN:
+                    /// M: google jb.mr1 patch, Conversation should scroll to the bottom
+                    /// when incoming received @{
+                    if (cookie instanceof Boolean && ((Boolean) cookie).booleanValue()) {
+                        // If we just deleted the last message, reset the saved id.
+                        mLastMessageId = 0;
+                    }
+                    /// @}
+                    /// M: Code analyze 027,Add for deleting one message.@{
+                    MmsLog.d(TAG, "onDeleteComplete(): before update mConversation, ThreadId = "
+                            + mConversation.getThreadId());
+                    ContactList recipients = getRecipients();
+                    mConversation = Conversation.upDateThread(getApplicationContext(),
+                            mConversation.getThreadId(), false);
+                    mThreadCountManager.isFull(mThreadId, ComposeMessageActivity.this,
+                            ThreadCountManager.OP_FLAG_DECREASE);
+                    /// @}
+                    // Update the notification for new messages since they
+                    // may be deleted.
+                    MessagingNotification.nonBlockingUpdateNewMessageIndicator(
+                            ComposeMessageActivity.this, MessagingNotification.THREAD_NONE, false);
+                    // Update the notification for failed messages since they
+                    // may be deleted.
+                    updateSendFailedNotification();
+                    /// M: Code analyze 027,Add for deleting one message.@{
+                    MessagingNotification
+                        .updateDownloadFailedNotification(ComposeMessageActivity.this);
+                    MmsLog.d(TAG, "onDeleteComplete(): MessageCount = "
+                            + mConversation.getMessageCount() +
+                            ", ThreadId = " + mConversation.getThreadId());
+                    if (mIpCompose.onDeleteComplete(token)) {
+                        break;
+                    }
+                    if (mConversation.getMessageCount() <= 0
+                            || mConversation.getThreadId() <= 0L) {
+                        mMsgListAdapter.changeCursor(null);
+                        if (needSaveDraft() && (recipients != null)) {
+                            if (!isRecipientsEditorVisible()) {
+                                makeDraftEditable(recipients);
+                            }
+                        } else {
+                            /// M: fix bug for ConversationList select all performance,
+                            /// update selected threads array.@{
+                            ConversationListAdapter.removeSelectedState(mSelectedThreadId);
+                            /// @
+                            finish();
+                        }
+                    }
+                    /// @}
+                    break;
+            }
+            // If we're deleting the whole conversation, throw away
+            // our current working message and bail.
+            if (token == ConversationList.DELETE_CONVERSATION_TOKEN) {
+                ContactList recipients = mConversation.getRecipients();
+                mWorkingMessage.discard();
+
+                // Remove any recipients referenced by this single thread from the
+                // contacts cache. It's possible for two or more threads to reference
+                // the same contact. That's ok if we remove it. We'll recreate that contact
+                // when we init all Conversations below.
+                if (recipients != null) {
+                    for (Contact contact : recipients) {
+                        contact.removeFromCache();
+                    }
+                }
+
+                // Make sure the conversation cache reflects the threads in the DB.
+                Conversation.init(getApplicationContext());
+                finish();
+            } else if (token == DELETE_MESSAGE_TOKEN) {
+                /// M: Code analyze 027,Add for deleting one message.@{
+                // Check to see if we just deleted the last message
+                startMsgListQuery(MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN, 0);
+                /// @}
+            }
+        }
+    }
+
+    @Override
+    public void onUpdate(final Contact updated) {
+        /** M:
+         * In a bad case ANR will happen. When many contact is update, onUpdate will be
+         * invoked very frequently,and the code here will run many times. In mRecipientsEditor,
+         * if there are 100[can be more?] recipients,
+         * mRecipientsEditor.constructContactsFromInput is time cost.
+         * ANR may happen if process many this message consequently.
+         * so reduce the frequence, and touch event message have more changces to process.
+         */
+        if (isRecipientsEditorVisible()) {
+            return;
+        }
+        log("[CMA] onUpdate contact updated: " + updated);
+        if (mPrevRunnable != null) {
+            mMessageListItemHandler.removeCallbacks(mPrevRunnable);
+        }
+        mPrevRunnable = new Runnable() {
+            public void run() {
+                ContactList recipients = getRecipients();
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.vpi(TAG, "[CMA] onUpdate contact updated: " + updated);
+                    MmsLog.vpi(TAG, "[CMA] onUpdate recipients: " + recipients);
+                }
+                updateTitle(recipients);
+                /// M: Contact is modified, update the menu icon of contact.
+                invalidateOptionsMenu();
+
+                // The contact information for one (or more) of the recipients has changed.
+                // Rebuild the message list so each MessageItem will get the last contact info.
+                ComposeMessageActivity.this.mMsgListAdapter.notifyDataSetChanged();
+            }
+        };
+        /// M: Using an existing handler for the post, rather than conjuring up a new one.
+        mMessageListItemHandler.postDelayed(mPrevRunnable, UPDATE_DELAY);
+    }
+
+    private void addRecipientsListeners() {
+        Contact.addListener(this);
+    }
+
+    private void removeRecipientsListeners() {
+        Contact.removeListener(this);
+    }
+
+    public static Intent createIntent(Context context, long threadId) {
+        Intent intent = new Intent(context, ComposeMessageActivity.class);
+
+        if (threadId > 0) {
+            intent.setData(Conversation.getUri(threadId));
+        }
+
+        return intent;
+    }
+
+    private String getBody(Uri uri) {
+        if (uri == null) {
+            return null;
+        }
+        String urlStr = uri.getSchemeSpecificPart();
+        if (!urlStr.contains("?")) {
+            return null;
+        }
+        urlStr = urlStr.substring(urlStr.indexOf('?') + 1);
+        String[] params = urlStr.split("&");
+        for (String p : params) {
+            if (p.startsWith("body=")) {
+                try {
+                    return URLDecoder.decode(p.substring(5), "UTF-8");
+                } catch (UnsupportedEncodingException e) { }
+            }
+        }
+        return null;
+    }
+
+    private void updateThreadIdIfRunning() {
+        if (mIsRunning && mConversation != null) {
+            if (mConversation.getMessageCount() > 0) {
+                MessagingNotification.setCurrentlyDisplayedThreadId(mConversation.getThreadId());
+            } else {
+                MessagingNotification
+                    .setCurrentlyDisplayedThreadId(MessagingNotification.THREAD_NONE);
+            }
+        }
+        // If we're not running, but resume later, the current thread ID will be set in onResume()
+    }
+
+     //////////////////////////////////////////////////////////////////////////////////////
+     // MTK add
+
+     /// M: Code analyze 012, add for multi-delete @{
+     public static final int REQUEST_CODE_FOR_MULTIDELETE  = 110;
+     /// @}
+
+     /// M: Code analyze 025, Add video or audio attachment and check the attachment size.@{
+     public static final int MIN_SIZE_FOR_CAPTURE_VIDEO    = 1024 * 10;  // 10K
+     public static final int MIN_SIZE_FOR_RECORD_AUDIO = 1024 * 5; // 5K
+     // M: fix bug ALPS00354728
+     private boolean mAppendAttachmentSign = true;
+     /// @}
+
+     /// M: Code analyze 014, Add quick text. @{
+     private static final int MENU_ADD_QUICK_TEXT         = 8;
+     private AlertDialog mQuickTextDialog;
+     /// @}
+
+     /// M: Code analyze 015, Add text vcard. @{
+     private static final int MENU_ADD_TEXT_VCARD         = 9;
+     public static final int REQUEST_CODE_TEXT_VCARD       = 22;
+     /// @}
+
+     private static final int MENU_CALL_RECIPIENT_BY_VT  = 10;
+     /// M: Code analyze 016, Add for select text copy. @{
+     private static final int MENU_SELECT_TEXT             = 36;
+     /// @}
+
+     private static final String SIGN_CREATE_AFTER_KILL_BY_SYSTEM = "ForCreateAfterKilledBySystem";
+
+     /// M: Code analyze 017, Handle forwarded message.(see:forwardMessage())@{
+     public static final String SMS_ADDRESS = "sms_address";
+     public static final String SMS_BODY = "sms_body";
+     public static final String FORWARD_MESSAGE = "forwarded_message";
+     /// @}
+
+     // State variable indicating an image is being compressed, which may take a while.
+     private boolean mCompressingImage = false;
+     private int mToastCountForResizeImage = 0; // For indicate whether show toast message for
+                        //resize image or not. If mToastCountForResizeImage equals 0, show toast.
+     /// M: Code analyze 010, Support dirtory mode. @{
+     private int mHomeBox = 0;
+     /// @}
+     private Toast mExceedMessageSizeToast = null;
+
+     /// M: Code analyze 009,Show attachment dialog . @{
+     private SoloAlertDialog mSoloAlertDialog;
+     /// @}
+
+     /// M: Code analyze 047, Extra uri from message body and get number from uri.
+     /// Then use this number to update contact cache. @{
+     private boolean mNeedUpdateContactForMessageContent = true;
+     /// @}
+
+     private boolean  mDrawBottomPanel = false;
+
+     /// M: the member is only used by onUpdate
+     private static final long UPDATE_DELAY = 100L;
+
+     /// M: Code analyze 011, use another method for performance
+     ///(use this to limit the contact query count) @{
+     private static final int UPDATE_LIMIT_LANDSCAPE = 20;
+     private static final int UPDATE_LIMIT_PORTRAIT = 20;
+     /// @}
+
+     ///@ M:fix bug ALPS00871320 tablet has wide space to show more contact
+     private static final int UPDATE_LIMIT_LANDSCAPE_TABLET = 30;
+     private static final int UPDATE_LIMIT_PORTRAIT_TABLET = 30;
+
+     private int getLimitedContact() {
+        boolean isPortrait =
+            getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
+        int updateLimit = 0;
+
+        boolean isTablet = getResources().getBoolean(R.bool.isTablet);
+        if (isPortrait) {
+            updateLimit = isTablet ? UPDATE_LIMIT_PORTRAIT_TABLET
+                    : UPDATE_LIMIT_PORTRAIT;
+        } else {
+            updateLimit = isTablet ? UPDATE_LIMIT_LANDSCAPE_TABLET
+                    : UPDATE_LIMIT_LANDSCAPE;
+        }
+        return updateLimit;
+     }
+
+     ///@
+     private Runnable mPrevRunnable;
+     private boolean mNeedSaveAsMms = false;
+
+     /// M: Code analyze 038, If the user is editing slideshow now.
+     /// Do not allow the activity finish but return directly when back key is entered. @{
+     private boolean mIsEditingSlideshow = false;
+     /// @}
+
+     /// M: Code analyze 026, If the two clicks are too close. @{
+     private long mAttachClickTime = -1;
+     private long mEditClickTime = -1;
+     /// @}
+
+     // mAudioUri will look like this: content://media/external/images/media
+     private static final String mAudioUri = Audio.Media.getContentUri("external").toString();
+
+     /// M: Code analyze 050, Add scroll listener and touch listener for MessageListView.@{
+     private static int CHANGE_SCROLL_LISTENER_MIN_CURSOR_COUNT = 100;
+     private MyScrollListener mScrollListener = new MyScrollListener(
+             CHANGE_SCROLL_LISTENER_MIN_CURSOR_COUNT, "MessageList_Scroll_Tread");
+     /// @}
+
+     /// M: Code analyze 018, Add ringtone for sound attachment.  @{
+     public static final int REQUEST_CODE_ATTACH_RINGTONE  = 20;
+     /// @}
+
+     /// M: Code analyze 019, Add vcard attachment.  @{
+     public static final int REQUEST_CODE_ATTACH_VCARD       = 21;
+     /// @}
+
+     /// M: Code analyze 020, Add vcalendar attachment.  @{
+     public static final int REQUEST_CODE_ATTACH_VCALENDAR = 25;
+     /// @}
+
+     /// M: Code analyze 021, Copy all valid parts of the attachment(pdu) to SD card.
+     /// This opeartor will be removed to a separate activity.    @{
+     public static final int REQUEST_CODE_MULTI_SAVE       = 23;
+     /// @}
+
+     /// M: Code analyze 022, Add bookmark. @{
+     private static final int MENU_ADD_TO_BOOKMARK         = 35;
+     private ArrayList<String> mURLs = new ArrayList<String>();
+     /// @}
+
+     /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+     private static final int MENU_SAVE_MESSAGE_TO_SUB     = 32;
+     private static final int SUB_SELECT_FOR_SEND_MSG                     = 1;
+     private static final int SUB_SELECT_FOR_SAVE_MSG_TO_SUB             = 2;
+     private static final int MSG_QUIT_SAVE_MESSAGE_THREAD                 = 100;
+     private static final int MSG_SAVE_MESSAGE_TO_SUB                     = 102;
+     private static final int MSG_SAVE_MESSAGE_TO_SUB_AFTER_SELECT_SUB     = 104;
+     private static final int MSG_SAVE_MESSAGE_TO_SUB_SUCCEED             = 106;
+     private static final int MSG_SAVE_MESSAGE_TO_SUB_FAILED_GENERIC     = 108;
+     private static final int MSG_SAVE_MESSAGE_TO_SUB_FAILED_SUB_FULL     = 110;
+
+     private static final String SELECT_TYPE    = "Select_type";
+     private int mSubCount; //The count of current sub cards.  0/1/2
+    private List<SubscriptionInfo> mSubInfoList;
+     private Handler mSaveMsgHandler = null;
+     private Thread mSaveMsgThread = null;
+     private AlertDialog mSubSelectDialog;
+     private int mMessageSubId;
+    private int mAssociatedSubId;
+    private int mSelectedSubId;
+     /// @}
+
+     /// M: Code analyze 006, Control Sub indicator on status bar. @{
+     private StatusBarManager mStatusBarManager;
+     private ComponentName mComponentName;
+     /// @}
+
+     /// M: Code analyze 056,Now,the sms recipient limit is different from mms.
+     /// We can set limit for sms or mms individually. @{
+     private static final int RECIPIENTS_LIMIT_FOR_SMS     = MmsConfig.getSmsRecipientLimit();
+     /// @}
+     private boolean mIsTooManyRecipients;     // Whether the recipients are too many
+
+     /// M: Code analyze 046, Whether the recipientedit control has been initialized. @{
+     private boolean isInitRecipientsEditor = true; // true, init Recip Editor and add recipient;
+                                                   // false, init Recip Editor, but recipient
+     /// @}
+
+     private boolean mWaitingForSendMessage;
+
+     /// M: Code analyze 023, Delete the char value of '\r' . @{
+     private static final String STR_RN = "\\r\\n"; // for "\r\n"
+     private static final String STR_CN = "\n"; // the char value of '\n'
+     /// @}
+     public static boolean mDestroy = false;
+
+     /// M: Code analyze 027,Add for deleting one message.@{
+     private ThreadCountManager mThreadCountManager = ThreadCountManager.getInstance();
+     private Long mThreadId = -1L;
+     /// @}
+
+     /// M: Code analyze 002,  If a new ComposeMessageActivity is created, kill old one
+     private static WeakReference<ComposeMessageActivity> sCompose = null;
+     /// @}
+
+     private static String sTextEditorText;
+     private long mLastThreadIdFromNotification;
+
+     private boolean mSendButtonCanResponse = true;    // can click send button
+     private static final long RESUME_BUTTON_INTERVAL = 1000;
+     private static final int MSG_RESUME_SEND_BUTTON  = 112;
+
+     /// M: Code analyze 024, If the click operator can be responsed. @{
+     boolean mClickCanResponse = true;           // can click button or some view items
+     /// @}
+
+     /// M: Code analyze 013, Get contacts from Contact app . @{
+     // handle NullPointerException in onActivityResult() for pick up recipients
+     private boolean mIsRecipientHasIntentNotHandle = false;
+     private Intent mIntent = null;
+     private boolean misPickContatct = false;
+     /// @}
+
+     /// M: Code analyze 004, Set max height for text editor. @{
+     private HeightChangedLinearLayout mHeightChangedLinearLayout;
+     private static final int mReferencedTextEditorTwoLinesHeight = 65;
+     private static final int mReferencedTextEditorThreeLinesHeight = 110;
+     private static final int mReferencedTextEditorFourLinesHeight    = 140;
+     private static final int mReferencedTextEditorSevenLinesHeight = 224;
+     private static final int mReferencedAttachmentEditorHeight     = 266;
+     private static final int mReferencedMaxHeight                    = 800;
+     private int mCurrentMaxHeight                                    = 800;
+     /// @}
+
+     /// M: Code analyze 042, If you discard the draft message manually.@{
+     private boolean mHasDiscardWorkingMessage = false;
+     /// @}
+
+    /// M: fix bug ALPS00572383, delay show "suggested" on the SelectSubDialog @{
+    private final HashMap<Integer, Integer> mHashSub = new HashMap<Integer, Integer>();
+    private static final int MSG_SELECT_SUB_DIALOG_SHOW = 500;
+    private int mAssociatedSubQueryDone;
+    private int mSelectSubType;
+    /// @}
+
+    private static final int MSG_DISMISS_CONTACT_PICK_DIALOG = 9009;
+    /// M:
+    private Handler mUiHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+
+            if (mOpComposeExt.handleUiMessage(msg, mSubCount, mSelectedSubId)) {
+                return;
+            }
+
+            switch (msg.what) {
+            case MSG_SAVE_MESSAGE_TO_SUB_SUCCEED:
+                Toast.makeText(ComposeMessageActivity.this,
+                        R.string.save_message_to_sim_successful, Toast.LENGTH_SHORT).show();
+                // M: fix for bug ALPS01468873
+                //sendBroadcast(new Intent(ManageSimMessages.ACTION_NOTIFY_SIMMESSAGE_UPDATE));
+                break;
+
+            case MSG_SAVE_MESSAGE_TO_SUB_FAILED_GENERIC:
+                Toast.makeText(ComposeMessageActivity.this,
+                        R.string.save_message_to_sim_unsuccessful, Toast.LENGTH_SHORT).show();
+                break;
+
+            case MSG_SAVE_MESSAGE_TO_SUB_FAILED_SUB_FULL:
+                int slotId = -1;
+                if (mSubCount == 1) {
+                    slotId = mSubInfoList.get(0).getSimSlotIndex();
+                } else {
+                    if (mSelectedSubId > 0) {
+                        SubscriptionInfo subInfo = SubscriptionManager.from(
+                                MmsApp.getApplication()).getActiveSubscriptionInfo(mSelectedSubId);
+                        if (subInfo != null) {
+                            slotId = subInfo.getSimSlotIndex();
+                        }
+                    }
+                }
+                Toast.makeText(ComposeMessageActivity.this,
+                        getString(R.string.save_message_to_sim_unsuccessful) + ". "
+                        + (getString(R.string.sim_full_title)), Toast.LENGTH_SHORT).show();
+                /// @}
+                break;
+            /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+            case MSG_SAVE_MESSAGE_TO_SUB: //multi sub cards
+                String type = (String) msg.obj;
+                long msgId = msg.arg1;
+                saveMessageToSub(type, msgId);
+                break;
+            /// @}
+            case MSG_RESUME_SEND_BUTTON:
+                mSendButtonCanResponse = true;
+                break;
+            case MSG_SELECT_SUB_DIALOG_SHOW:
+                /// M: fix bug ALPS00572383, delay show "suggested" on the SelectSimDialog @{
+                mUiHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        int position = -1;
+                        if (mHashSub != null && mSelectSubType == SUB_SELECT_FOR_SEND_MSG) {
+                            for (int i = 0; i < mHashSub.size(); i++) {
+                                if (mHashSub != null
+                                        && mHashSub.get(i) == mAssociatedSubQueryDone) {
+                                    position = i;
+                                    break;
+                                }
+                            }
+
+                            if (position != -1 && mSubSelectDialog != null
+                                                        && mSubSelectDialog.isShowing()) {
+                                ListView listView = mSubSelectDialog.getListView();
+                                if (listView != null) {
+                                    View view = listView.getChildAt(position);
+                                    if (view != null) {
+                                       TextView textView =
+                                           (TextView) view.findViewById(R.id.sim_suggested);
+                                       if (textView != null) {
+                                           textView.setText(getString(R.string.suggested));
+                                       }
+                                    }
+                                }
+                                mHashSub.clear();
+                            }
+                        }
+                    }
+                });
+                break;
+                /// @}
+            case MSG_DISMISS_CONTACT_PICK_DIALOG:
+                mUiHandler.removeCallbacks(mContactPickRunnable);
+                if (mContactPickDialog != null && mContactPickDialog.isShowing()) {
+                    mContactPickDialog.dismiss();
+                }
+                mContactPickDialog = null;
+                break;
+            default:
+                MmsLog.w(TAG, "inUIHandler msg unhandled.");
+                break;
+            }
+        }
+    };
+
+    /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+    private final class SaveMsgThread extends Thread {
+        private String msgType = null;
+        private long msgId = 0;
+        public SaveMsgThread(String type, long id) {
+            msgType = type;
+            msgId = id;
+        }
+        public void run() {
+            Looper.prepare();
+            if (null != Looper.myLooper()) {
+                mSaveMsgHandler = new SaveMsgHandler(Looper.myLooper());
+            }
+            Message msg = mSaveMsgHandler.obtainMessage(MSG_SAVE_MESSAGE_TO_SUB);
+            msg.arg1 = (int) msgId;
+            msg.obj = msgType;
+            if (mSubCount > 1) { // multi sub cards
+                mUiHandler.sendMessage(msg);
+            } else {
+                mSaveMsgHandler.sendMessage(msg); //single sub card
+            }
+            Looper.loop();
+        }
+    }
+
+    private final class SaveMsgHandler extends Handler {
+        public SaveMsgHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_QUIT_SAVE_MESSAGE_THREAD: {
+                    MmsLog.i(MmsApp.TXN_TAG, "exit save message thread");
+                    getLooper().quit();
+                    break;
+                }
+
+                case MSG_SAVE_MESSAGE_TO_SUB: { //single sub card
+                    String type = (String) msg.obj;
+                    long msgId = msg.arg1;
+                    //saveMessageTo(type, msgId);
+                    getMessageAndSaveToSub(type, msgId);
+                    break;
+                }
+
+                case MSG_SAVE_MESSAGE_TO_SUB_AFTER_SELECT_SUB: {
+                    Intent it = (Intent) msg.obj;
+                    getMessageAndSaveToSub(it);
+                    break;
+                }
+
+                default:
+                    break;
+            }
+        }
+    }
+
+    private void saveMessageToSub(String msgType, long msgId) { //multi sub cards exist
+        MmsLog.d(MmsApp.TXN_TAG, "save message to sub, message type:" + msgType
+                + "; message id:" + msgId + "; sub count:" + mSubCount);
+
+        Intent intent = new Intent();
+        intent.putExtra("message_type", msgType);
+        intent.putExtra("message_id", msgId);
+        intent.putExtra(SELECT_TYPE, SUB_SELECT_FOR_SAVE_MSG_TO_SUB);
+        mSelectSubType = SUB_SELECT_FOR_SAVE_MSG_TO_SUB;
+        showSubSelectedDialog(intent);
+    }
+
+    private void getMessageAndSaveToSub(Intent intent) {
+        MmsLog.i(MmsApp.TXN_TAG,
+                "get message and save to sub, selected sub id = " + mSelectedSubId);
+        String msgType = intent.getStringExtra("message_type");
+        long msgId = intent.getLongExtra("message_id", 0);
+        if (msgType == null) {
+            //mSaveMsgHandler.sendEmptyMessage(MSG_SAVE_MESSAGE_TO_SIM_FAILED_GENERIC);
+            mUiHandler.sendEmptyMessage(MSG_SAVE_MESSAGE_TO_SUB_FAILED_GENERIC);
+            return;
+        }
+        getMessageAndSaveToSub(msgType, msgId);
+    }
+
+    private void getMessageAndSaveToSub(String msgType, long msgId) {
+        int result = 0;
+        ///M: ALPS00726802, get the orignal position when long click this item
+        Cursor cursor = mMsgListAdapter.getCursor();
+        if (mClickedItemPosition >= 0 && mClickedItemPosition < cursor.getCount()) {
+            cursor.moveToPosition(mClickedItemPosition);
+        }
+        MessageItem msgItem = getMessageItem(msgType, msgId, true);
+        if (msgItem == null || msgItem.mBody == null) {
+            MmsLog.e(MmsApp.TXN_TAG, "getMessageAndSaveToSub, can not get Message Item.");
+            return;
+        }
+
+        String scAddress = null;
+
+        ArrayList<String> messages = null;
+        messages = SmsManager.getDefault().divideMessage(msgItem.mBody);
+
+        int smsStatus = 0;
+        long timeStamp = 0;
+        if (msgItem.isReceivedMessage()) {
+            smsStatus = SmsManager.STATUS_ON_ICC_READ;
+            timeStamp = msgItem.mSmsDate;
+            scAddress = msgItem.getServiceCenter();
+        } else if (msgItem.isSentMessage()) {
+            smsStatus = SmsManager.STATUS_ON_ICC_SENT;
+        } else if (msgItem.isFailedMessage()) {
+            smsStatus = SmsManager.STATUS_ON_ICC_UNSENT;
+        } else {
+            MmsLog.w(MmsApp.TXN_TAG, "Unknown sms status");
+        }
+        int subId = -1;
+        if (mSubCount == 1) {
+            mSelectedSubId = (int) mSubInfoList.get(0).getSubscriptionId();
+        }
+        subId = mSelectedSubId;
+        if (scAddress == null) {
+                scAddress = TelephonyManagerEx.getDefault().getScAddress(subId);
+        }
+
+        MmsLog.dpi(MmsApp.TXN_TAG, "\t subId\t= " + subId
+                + "\t scAddress\t= " + scAddress
+                + "\t Address\t= " + msgItem.mAddress
+                + "\t msgBody\t= " + msgItem.mBody
+                + "\t smsStatus\t= " + smsStatus
+                + "\t timeStamp\t= " + timeStamp
+                + "\t messages size\t= " + messages.size());
+
+        /// M: add for ALPS01844319, check SIM whether locked first, return fail if locked. @{
+        TelephonyManager telephony =
+            (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+        int simState = telephony.getSimState(SubscriptionManager.getSlotId(subId));
+        MmsLog.d(MmsApp.TXN_TAG, "\t simState \t= " + simState);
+        // set result as fail if SIM locked.
+        if (simState == TelephonyManager.SIM_STATE_PIN_REQUIRED) {
+            result = SmsManager.RESULT_ERROR_GENERIC_FAILURE;
+        } else {
+            result = SmsManager.getSmsManagerForSubscriptionId(subId).copyTextMessageToIccCard(
+                    scAddress, msgItem.mAddress, messages, smsStatus, timeStamp);
+        }
+        /// @}
+        MmsLog.d(MmsApp.TXN_TAG, "\t result\t= " + result);
+
+        result = mOpComposeExt.getMessageAndSaveToSub(
+                mConversation.getRecipients().getNumbers(),
+                scAddress, messages, smsStatus, timeStamp, subId, result);
+
+        if (result == SmsManager.RESULT_ERROR_SUCCESS) {
+            MmsLog.d(MmsApp.TXN_TAG, "save message to sub succeed.");
+            mUiHandler.sendEmptyMessage(MSG_SAVE_MESSAGE_TO_SUB_SUCCEED);
+        } else if (result == SmsManager.RESULT_ERROR_SIM_MEM_FULL) {
+            MmsLog.w(MmsApp.TXN_TAG, "save message to sub failed: sub memory full.");
+            mUiHandler.sendEmptyMessage(MSG_SAVE_MESSAGE_TO_SUB_FAILED_SUB_FULL);
+        } else {
+            MmsLog.w(MmsApp.TXN_TAG, "save message to sub failed: generic error.");
+            mUiHandler.sendEmptyMessage(MSG_SAVE_MESSAGE_TO_SUB_FAILED_GENERIC);
+        }
+        mSaveMsgHandler.sendEmptyMessageDelayed(MSG_QUIT_SAVE_MESSAGE_THREAD, 5000);
+    }
+
+    Runnable mGetSubInfoRunnable = new Runnable() {
+        public void run() {
+            getSubInfoList();
+            mOpComposeExt.getSubInfoRunnable(mWorkingMessage.hasSlideshow());
+
+        }
+    };
+
+     private void getSubInfoList() {
+        mSubInfoList = SubscriptionManager.from(this).getActiveSubscriptionInfoList();
+        mSubCount = (mSubInfoList != null && !mSubInfoList.isEmpty()) ? mSubInfoList.size() : 0;
+        MmsLog.i(TAG, "ComposeMessageActivity.getSubInfoList(): mSubCount = " + mSubCount);
+    }
+
+     private void subSelection() {
+        if (mIpCompose.subSelection()) {
+            return;
+        }
+        int selectedSubId = mOpComposeExt.subSelection();
+        if (selectedSubId != 0) {
+            mSelectedSubId = selectedSubId;
+            return;
+        }
+        if (mSubCount == 1) {
+            mSelectedSubId = (int) mSubInfoList.get(0).getSubscriptionId();
+            confirmSendMessageIfNeeded();
+        } else if (mSubCount > 1) { // multi sub cards exist.
+            Intent intent = new Intent();
+            mSelectSubType = SUB_SELECT_FOR_SEND_MSG;
+            intent.putExtra(SELECT_TYPE, SUB_SELECT_FOR_SEND_MSG);
+            // getContactSIM
+            if (isRecipientsEditorVisible()) {
+                if (mRecipientsEditor.getRecipientCount() == 1/*isOnlyOneRecipient()*/) {
+                    mAssociatedSubId = getContactSub(mRecipientsEditor.getNumbers().get(0));
+                } else {
+                    mAssociatedSubId = -1;
+                }
+            } else {
+                if (getRecipients().size() == 1/*isOnlyOneRecipient()*/) {
+                    mAssociatedSubId = getContactSub(getRecipients().get(0).getNumber());
+                } else {
+                    mAssociatedSubId = -1;
+                }
+            }
+/*
+  * Op18 : Dual Send button is shown in compose screen .
+  * This setting is not saved along with subscriptionManager.getDefaultSmsSubId()
+  * So ,  check its value in plugin , if false handle default else plugin will handle send message
+
+*/
+    MmsLog.d(TAG, "mAssociatedSubId = " + mAssociatedSubId);
+
+           if (mAssociatedSubId == -1 && mOpComposeExt.sendMessageForDualSendButton() == false) {
+
+                // getDefaultSIM()
+                mMessageSubId = SubscriptionManager.getDefaultSmsSubscriptionId();
+                MmsLog.d(TAG, "mMessageSubId = " + mMessageSubId);
+                if (mMessageSubId == DefaultSmsSimSettings.ASK_USER_SUB_ID
+                        || mOpComposeExt.subSelectionDialog(mMessageSubId)) {
+                    // always ask, show SIM selection dialog
+                    showSubSelectedDialog(intent);
+                    updateSendButtonState();
+                } else if (mMessageSubId == Settings.System.DEFAULT_SIM_NOT_SET) {
+                    /*
+                     * not set default Sub:
+                     * if recipients are morn than 2,or there is no associated Sub,
+                     * show SIM selection dialog
+                     * else send message via associated SIM
+                     */
+                    if (mAssociatedSubId == -1) {
+                        showSubSelectedDialog(intent);
+                        updateSendButtonState();
+                    } else {
+                        mSelectedSubId = mAssociatedSubId;
+                        confirmSendMessageIfNeeded();
+                    }
+                } else {
+                    /*
+                     * default SIM:
+                     * if recipients are morn than 2,or there is no associated SIM,
+                     * send message via default SIM
+                     * else show SIM selection dialog
+                     */
+                    boolean isAssociatedSubExsit = false;
+                    List<SubscriptionInfo> subinfoList
+                        = SubscriptionManager.from(this).getActiveSubscriptionInfoList();
+                    int subCount = 0;
+                    if (subinfoList != null) {
+                        subCount = subinfoList.size();
+                    }
+                    for (int slotId = 0; slotId < subCount; slotId++) {
+                        SubscriptionInfo subInfo = subinfoList.get(slotId);
+                        if (subInfo != null) {
+                            int subId = subInfo.getSubscriptionId();
+                            isAssociatedSubExsit = (subId == mAssociatedSubId ? true : false);
+                            if (isAssociatedSubExsit) {
+                                break;
+                            }
+                        }
+                    }
+                    if ((mAssociatedSubId == -1 || (mMessageSubId == mAssociatedSubId)
+                            || !isAssociatedSubExsit)
+                            && MessageUtils.isSmsSubIdActive(this, mMessageSubId)) {
+                        mSelectedSubId = (int) mMessageSubId;
+                        confirmSendMessageIfNeeded();
+                    } else {
+                        showSubSelectedDialog(intent);
+                        updateSendButtonState();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onDialogClick(int subId, Intent intent) {
+        mSelectedSubId = (int) subId;
+        if (intent.getIntExtra(SELECT_TYPE, -1) == SUB_SELECT_FOR_SEND_MSG) {
+            confirmSendMessageIfNeeded();
+            mIsOneSubSelected = true;
+        } else if (intent.getIntExtra(SELECT_TYPE, -1) == SUB_SELECT_FOR_SAVE_MSG_TO_SUB) {
+            // getMessageAndSaveToSim(it);
+            Message msg = mSaveMsgHandler.obtainMessage(MSG_SAVE_MESSAGE_TO_SUB_AFTER_SELECT_SUB);
+            msg.obj = intent;
+            // mSaveMsgHandler.sendMessageDelayed(msg, 60);
+            mSaveMsgHandler.sendMessage(msg);
+        }
+    }
+
+    @Override
+    public void onCancelClick() {
+
+    }
+
+    @Override
+    public void onDialogDismiss() {
+        if (isRecipientsEditorVisible() && mCutRecipients != null) {
+            mRecipientsEditor.removeChipChangedListener(mChipWatcher);
+            mRecipientsEditor.populate(new ContactList());
+            mRecipientsEditor.addChipChangedListener(mChipWatcher);
+            mRecipientsEditor.populate(mCutRecipients);
+            mCutRecipients = null;
+            // / M : Fix CR ALPS01009525
+            // / which will a empty thread in the widget that send group message
+            // from contact @{
+            if (mOldThreadID > 0) {
+                Conversation.asyncDeleteObsoleteThreadID(mBackgroundQueryHandler, mOldThreadID);
+            }
+            // / @}
+        } else if (mCutRecipients != null) {
+            if (mConversation != null) {
+                Log.d(TAG,
+                        "onDismiss, mark old thread draft status to false: "
+                                + mConversation.getThreadId());
+                mConversation.setDraftState(false);
+            }
+            mWorkingMessage.syncWorkingRecipients();
+            Conversation conv = mWorkingMessage.getConversation();
+            long threadId = 0L;
+            if (conv != null) {
+                conv.ensureThreadId();
+                threadId = conv.getThreadId();
+            }
+            // / M: fix bug ALPS00595715 @{
+            mWorkingMessage.saveDraft(false);
+            if (mIsOneSubSelected) {
+                startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 0);
+                mIsOneSubSelected = false;
+            } else {
+                startActivity(createIntent(ComposeMessageActivity.this, threadId));
+            }
+            // /@}
+            // / M: fix bug ALPS00595715 @{
+            if (mOldThreadID > 0 && mOldThreadID != threadId) {
+                mIsSameConv = false;
+                MmsLog.d(TAG, "onDismiss not same thread");
+            }
+            mCutRecipients = null;
+        }
+    }
+
+    private boolean mIsOneSubSelected = false;
+
+    private void showSubSelectedDialog(Intent intent) {
+        mIsOneSubSelected = false;
+        SubSelectDialog subSelectDialog = new SubSelectDialog(this, this);
+
+        String str = null;
+
+        str = mOpComposeExt.showSubSelectedDialog(str);
+
+        mSubSelectDialog = subSelectDialog.showSubSelectedDialog(true, str, intent);
+
+        /// M: fix bug ALPS00572383, delay show "suggested" on the SelectSubDialog @{
+        if (mAssociatedSubQueryDone != -1) {
+            mUiHandler.sendEmptyMessage(MSG_SELECT_SUB_DIALOG_SHOW);
+        }
+        /// @}
+    }
+    /// @}
+    /// M: Code analyze 003,  Set or get max mms size.
+    private void initMessageSettings() {
+        MessageUtils.setMmsLimitSize(this);
+    }
+    /// @}
+
+    private void showConfirmDialog(Uri uri, boolean append, int type, int messageId) {
+        if (isFinishing()) {
+            return;
+        }
+
+        final Uri mRestrictedMidea = uri;
+        final boolean mRestrictedAppend = append;
+        final int mRestrictedType = type;
+
+        new AlertDialog.Builder(ComposeMessageActivity.this)
+        .setTitle(R.string.unsupport_media_type)
+        .setIconAttribute(android.R.attr.alertDialogIcon)
+        .setMessage(messageId)
+        .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+            public final void onClick(DialogInterface dialog, int which) {
+                    /// M: disable when non-default sms
+                    if (!mIsSmsEnabled) {
+                        Toast.makeText(ComposeMessageActivity.this,
+                                R.string.compose_disabled_toast, Toast.LENGTH_SHORT).show();
+                        return;
+                    }
+                    if (mRestrictedMidea == null || mRestrictedType == WorkingMessage.TEXT
+                        || mWorkingMessage.isDiscarded()) {
+                        return;
+                    }
+                    getAsyncDialog().runAsync(new Runnable() {
+                        public void run() {
+                            /// M: fix bug ALPS01258201, show progessDialog
+                            runOnUiThread(new Runnable() {
+                                public void run() {
+                                    Log.d(TAG, "reCreate and show ProgressDialog");
+                                    getAsyncDialog().reCreateProgressDialog(
+                                            R.string.adding_attachments_title);
+                                    getAsyncDialog().resetShowProgressDialog();
+                                }
+                            });
+                            int createMode = WorkingMessage.sCreationMode;
+                            WorkingMessage.sCreationMode = 0;
+                            int result = mWorkingMessage.setAttachment(mRestrictedType,
+                                    mRestrictedMidea, mRestrictedAppend);
+                            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                                MmsLog.vpi(TAG, "Restricted Midea: dataUri=" + mRestrictedMidea);
+                            }
+                            if (mRestrictedType == WorkingMessage.IMAGE
+                                && (result == WorkingMessage.IMAGE_TOO_LARGE
+                                        || result == WorkingMessage.MESSAGE_SIZE_EXCEEDED)) {
+                                MmsLog.dpi(TAG, "showConfirmDialog: resize image "
+                                        + mRestrictedMidea);
+                                MessageUtils.resizeImage(ComposeMessageActivity.this,
+                                        mRestrictedMidea, mAttachmentEditorHandler,
+                                        mResizeImageCallback, mRestrictedAppend,
+                                    true);
+                                WorkingMessage.sCreationMode = createMode;
+                                dismissProgressDialog();
+                                return;
+                            }
+                            WorkingMessage.sCreationMode = createMode;
+                            int typeId = R.string.type_picture;
+                            if (mRestrictedType == WorkingMessage.AUDIO) {
+                                typeId = R.string.type_audio;
+                            } else if (mRestrictedType == WorkingMessage.VIDEO) {
+                                typeId = R.string.type_video;
+                            }
+                            handleAddAttachmentError(result, typeId);
+                            /// M: fix bug ALPS00726611, must save draft when click on WARNING_TYPE
+                            if (result == WorkingMessage.OK) {
+                                if (mWorkingMessage.saveAsMms(false) != null) {
+                                    mHasDiscardWorkingMessage = true;
+                                }
+                            }
+                            dismissProgressDialog();
+                        }
+                    }, new ShowRunnable(), R.string.adding_attachments_title);
+                    Log.d(TAG, "Composer add mAsyncTaskNum = " + (++mAsyncTaskNum));
+            }
+        })
+        .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
+            public final void onClick(DialogInterface dialog, int which) {
+                mWorkingMessage.removeFakeMmsForDraft();
+                updateSendButtonState();
+            }
+        })
+        .setOnCancelListener(new DialogInterface.OnCancelListener() {
+            public void onCancel(DialogInterface arg0) {
+                mWorkingMessage.removeFakeMmsForDraft();
+                updateSendButtonState();
+            }
+        })
+        .show();
+    }
+
+     /// M: Code analyze 067, Add audio attachment. @{
+    private void addAudio(final Uri uri, final boolean append) {
+        mNeedSaveAsMms = false;
+        if (uri != null) {
+            mNeedSaveAsMms = true;
+            int result = WorkingMessage.OK;
+            try {
+                if (append) {
+                    mWorkingMessage.checkSizeBeforeAppend();
+                }
+            } catch (ExceedMessageSizeException e) {
+                result = WorkingMessage.MESSAGE_SIZE_EXCEEDED;
+                handleAddAttachmentError(result, R.string.type_audio);
+                mNeedSaveAsMms = false;
+                return;
+            }
+            result = mWorkingMessage.setAttachment(WorkingMessage.AUDIO, uri, append);
+            if (result == WorkingMessage.WARNING_TYPE) {
+                mNeedSaveAsMms = false;
+                runOnUiThread(new Runnable() {
+                    public void run() {
+                        showConfirmDialog(uri, append,
+                                WorkingMessage.AUDIO, R.string.confirm_restricted_audio);
+                    }
+                });
+            } else {
+                handleAddAttachmentError(result, R.string.type_audio);
+                if (result != WorkingMessage.OK) {
+                    mNeedSaveAsMms = false;
+                }
+            }
+        }
+    }
+    /// @}
+
+    /// M: Code analyze 015, Add text vcard. @{
+    private void addTextVCardAsync(final long[] contactsIds) {
+        MmsLog.i(TAG, "compose.addTextVCardAsync(): contactsIds.length() = " + contactsIds.length);
+        getAsyncDialog().runAsync(new Runnable() {
+            public void run() {
+                //addTextVCard(contactsIds);
+               String textVCard = TextUtils.isEmpty(mTextEditor.getText()) ? "" : "\n";
+               VCardAttachment tvc = new VCardAttachment(ComposeMessageActivity.this);
+               final String textString = tvc.getTextVCardString(contactsIds, textVCard);
+               runOnUiThread(new Runnable() {
+               public void run() {
+                   insertText(mTextEditor, textString);
+               }
+
+             });
+           }
+        }, null, R.string.menu_insert_text_vcard); // the str is ok for reuse[or use a new string].
+    }
+    /// @}
+
+    private void addFileAttachment(String type, Uri uri, boolean append) {
+        if (!addFileAttachment(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, uri, append)) {
+            if (!addFileAttachment(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, uri, append)) {
+                if (!addFileAttachment(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+                        uri, append)) {
+                    MmsLog.i(TAG, "This file is not in media store(audio, video or image)," +
+                            "attemp to add it like file uri");
+                    addAttachment(type, (Uri) uri, append);
+                }
+            }
+        }
+    }
+
+    private boolean addFileAttachment(Uri mediaStoreUri, Uri uri, boolean append) {
+        String path = uri.getPath();
+        if (path != null) {
+            Cursor c = getContentResolver().query(mediaStoreUri,
+                    new String[] {MediaStore.MediaColumns._ID, Audio.Media.MIME_TYPE},
+                    MediaStore.MediaColumns.DATA + "=?",
+                    new String[] {path}, null);
+            if (c != null) {
+                try {
+                    if (c.moveToFirst()) {
+                        Uri contentUri = Uri.withAppendedPath(mediaStoreUri, c.getString(0));
+                        MmsLog.ipi(TAG, "Get id in MediaStore:" + c.getString(0)
+                                + " Get content type in MediaStore:" + c.getString(1)
+                                + " Get uri in MediaStore:" + contentUri);
+                        String contentType = c.getString(1);
+                        addAttachment(contentType, contentUri, append);
+                        return true;
+                    } else {
+                        MmsLog.ipi(TAG, "MediaStore:" + mediaStoreUri.toString()
+                                + " has not this file");
+                    }
+                } finally {
+                    c.close();
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean isHasRecipientCount() {
+        int recipientCount = recipientCount();
+        return (recipientCount > 0 && recipientCount < RECIPIENTS_LIMIT_FOR_SMS);
+    }
+
+    private String getResourcesString(int id) {
+        Resources r = getResources();
+        return r.getString(id);
+    }
+
+    /// M: Code analyze 030, Check condition before sending message.@{
+    public void checkConditionsAndSendMessage(final boolean bCheckEcmMode) {
+        // check pin
+        if (mSelectedSubId <= 0) {
+            mSelectedSubId = SubscriptionManager.getDefaultSubscriptionId();
+        }
+        // add CellConnMgr feature
+        if (showWfcSendButtonPopUp()) {
+            updateSendButtonState(true);
+            return;
+        }
+        final CellConnMgr cellConnMgr = new CellConnMgr(getApplicationContext());
+        final int state = cellConnMgr.getCurrentState(mSelectedSubId, CellConnMgr.STATE_FLIGHT_MODE
+                | CellConnMgr.STATE_SIM_LOCKED | CellConnMgr.STATE_RADIO_OFF);
+        MmsLog.d(TAG, "CellConnMgr, state is " + state);
+        ///M: WFC: Do not show pop-up, if wfc is OFF @ {
+        if (!TelephonyManagerEx.getDefault().isWifiCallingEnabled(mSelectedSubId) &&
+            (((state & CellConnMgr.STATE_FLIGHT_MODE) == CellConnMgr.STATE_FLIGHT_MODE ) ||
+            ((state & CellConnMgr.STATE_RADIO_OFF) == CellConnMgr.STATE_RADIO_OFF ) ||
+            ((state & (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))
+                == (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))))  {
+            final ArrayList<String> stringArray =
+                cellConnMgr.getStringUsingState(mSelectedSubId, state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(android.R.string.ok,
+                        new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        dialog.dismiss();
+                        mTextEditor.requestFocus();
+                        updateSendButtonState(true);
+                    }
+                });
+                mPlaneModeDialog = builder.show();
+                mPlaneModeDialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
+                    @Override
+                    public void onDismiss(DialogInterface dialog) {
+                        dialog.dismiss();
+                        mPlaneModeDialog = null;
+                        updateSendButtonState(true);
+                    }
+                });
+            }
+        } else if ((state & CellConnMgr.STATE_SIM_LOCKED) == CellConnMgr.STATE_SIM_LOCKED) {
+            final ArrayList<String> stringArray =
+                cellConnMgr.getStringUsingState(mSelectedSubId, state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setCancelable(true);
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(stringArray.get(2),
+                        new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                            cellConnMgr.handleRequest(mSelectedSubId, state);
+                            mTextEditor.requestFocus();
+                            updateSendButtonState(true);
+                    }
+                });
+                builder.setNegativeButton(stringArray.get(3),
+                        new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                            dialog.dismiss();
+                            mTextEditor.requestFocus();
+                            updateSendButtonState(true);
+                    }
+                });
+                builder.show();
+            }
+        } else {
+            if (!mOpComposeExt.checkConditionsAndSendMessage(mWorkingMessage.requiresMms(),
+                    bCheckEcmMode)) {
+                checkBeforeSendMessage(bCheckEcmMode);
+            }
+        }
+   }
+   /// @}
+
+    /// M: Code analyze 049, Update send button or attachment editor state.@{
+    private void updateSendButtonState(final boolean enabled) {
+        if (!mWorkingMessage.hasSlideshow()) {
+            View sendButton = showSmsOrMmsSendButton(mWorkingMessage.requiresMms());
+            if (mOpComposeExt.updateSendButtonState(mWorkingMessage.requiresMms(),
+                    recipientCount(), MmsConfig.getSmsRecipientLimit(), mSubCount)) {
+                return;
+            }
+            sendButton.setEnabled(enabled);
+            sendButton.setFocusable(enabled);
+        } else {
+            mAttachmentEditor.setCanSend(enabled && (mSubCount > 0));
+        }
+    }
+    /// @}
+
+    private void insertText(EditText edit, String insertText) {
+        int where = edit.getSelectionStart();
+
+        if (where == -1) {
+            edit.append(insertText);
+        } else {
+            edit.getText().insert(where, insertText);
+        }
+    }
+
+    /**
+     * This filter will constrain edits not to make the length of the text
+     * greater than the specified length.
+     */
+    class TextLengthFilter extends InputFilter.LengthFilter {
+        public TextLengthFilter(int max) {
+            super(max);
+            mMaxLength = max;
+            mExceedMessageSizeToast = Toast.makeText(ComposeMessageActivity.this,
+                    R.string.exceed_editor_size_limitation,
+                    Toast.LENGTH_SHORT);
+        }
+
+        public CharSequence filter(CharSequence source, int start, int end,
+                                   Spanned dest, int dstart, int dend) {
+            MmsLog.dpi(TAG, "TextLengthFilter source = " + source +
+                    " start = " + start + " end = " + end + " dstart = "
+                    + dstart + " dend = " + dend + " dest length = " + dest.length());
+            int keep = mMaxLength - (dest.length() - (dend - dstart));
+            if (keep < (end - start)) {
+                mExceedMessageSizeToast.show();
+                mInputMethodManager.restartInput(
+                        ComposeMessageActivity.this.getWindow().getCurrentFocus());
+            }
+            return super.filter(source, start, end, dest, dstart, dend);
+            /*
+            if (keep <= 0) {
+                return "";
+            } else if (keep >= end - start) {
+                return null; // keep original
+            } else {
+                return source.subSequence(start, start + keep);
+            }
+            */
+        }
+
+        private int mMaxLength;
+    }
+
+    /// M: Code analyze 051, Hide input keyboard.@{
+    private void hideInputMethod() {
+        MmsLog.d(TAG, "hideInputMethod()");
+        if (this.getWindow() != null && this.getWindow().getCurrentFocus() != null) {
+            mInputMethodManager
+                .hideSoftInputFromWindow(this.getWindow().getCurrentFocus().getWindowToken(), 0);
+        }
+    }
+    /// @}
+
+    // toast there are too many recipients.
+    private void toastTooManyRecipients(int recipientCount) {
+        final String tooManyRecipients = getString(R.string.too_many_recipients,
+                recipientCount, RECIPIENTS_LIMIT_FOR_SMS);
+        mUiHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(ComposeMessageActivity.this,
+                        tooManyRecipients, Toast.LENGTH_LONG).show();
+            }
+        }, 1000);
+    }
+
+    /// M: Code analyze 013, Get contacts from Contact app . @{
+    private void addContacts(int pickCount, int requestCode) {
+        /// M: @{
+        /*Intent intent = new Intent("android.intent.action.CONTACTSMULTICHOICE");
+          intent.setType(Phone.CONTENT_ITEM_TYPE);
+          intent.putExtra("request_email", true);
+          intent.putExtra("pick_count", pickCount);
+          misPickContatct = true;
+          startActivityForResult(intent, REQUEST_CODE_PICK_CONTACT);*/
+
+        /// M: fix bug ALPS00444752, set true to disable to Show ContactPicker
+        mShowingContactPicker = true;
+        misPickContatct = true;
+        Intent intent = new Intent(MessageUtils.ACTION_CONTACT_SELECTION);
+        intent.setType(Phone.CONTENT_TYPE);
+
+        if (mOpComposeExt.addContacts(intent, pickCount, requestCode)) {
+            return;
+        }
+        try {
+            startActivityForResult(intent, requestCode);
+        } catch (ActivityNotFoundException e) {
+            mShowingContactPicker = false;
+            misPickContatct = false;
+            Toast.makeText(this, this.getString(R.string.no_application_response),
+                    Toast.LENGTH_SHORT).show();
+            MmsLog.e(TAG, e.getMessage());
+        }
+        /// @}
+    }
+
+    private int getContactSub(final String num) {
+        class Int {
+            private int value = -1;
+            public void  set(int n) {
+                value = n;
+            }
+            public int get() {
+                return value;
+            }
+        }
+        final Int subID = new Int();
+        final Object dbQueryLock = new Object();
+        final Context mContextTemp = this.getApplicationContext();
+        // query the db in another thread.
+        new Thread(new Runnable() {
+            public void run() {
+                int subId = -1;
+                String number = num;
+                String formatNumber = MessageUtils.formatNumber(number, mContextTemp);
+                String TrimFormatNumber = formatNumber;
+                if (formatNumber != null) {
+                    TrimFormatNumber = formatNumber.replace(" ", "");
+                }
+                Cursor associateSubCursor = ComposeMessageActivity.this.getContentResolver().query(
+                    Data.CONTENT_URI,
+                    new String[]{ContactsContract.Data.SIM_ASSOCIATION_ID},
+                    Data.MIMETYPE + "='" + CommonDataKinds.Phone.CONTENT_ITEM_TYPE
+                    + "' AND (" + Data.DATA1 + "=?" +
+                    " OR " + Data.DATA1 + "=?" +
+                    " OR " + Data.DATA4 + "=?" +
+                    ") AND (" + ContactsContract.Data.SIM_ASSOCIATION_ID + "!= -1)",
+                    new String[]{number, formatNumber, TrimFormatNumber},
+                    null
+                );
+
+                if ((null != associateSubCursor) && (associateSubCursor.getCount() > 0)) {
+                    associateSubCursor.moveToFirst();
+                    // Get only one record is OK
+                    subId = (Integer) associateSubCursor.getInt(0);
+                } else {
+                    subId = -1;
+                }
+                if (associateSubCursor != null) {
+                    associateSubCursor.close();
+                }
+                synchronized (dbQueryLock) {
+                    MmsLog.d(MmsApp.TXN_TAG, "before notify");
+                    subID.set(subId);
+                    dbQueryLock.notify();
+                    /// M: fix bug ALPS00572383, delay show "suggested" on the SelectSimDialog @{
+                    mAssociatedSubQueryDone = subId;
+                }
+                /// @}
+            }
+        }).start();
+        // change UI thread wait from 500ms to 1000ms at most, for CR ALPS00721717
+        synchronized (dbQueryLock) {
+            try {
+                MmsLog.d(MmsApp.TXN_TAG, "before wait");
+                dbQueryLock.wait(1000);
+            } catch (InterruptedException e) {
+                //time out
+            }
+            MmsLog.d(MmsApp.TXN_TAG, "subID = " + subID.get());
+            return subID.get();
+        }
+    }
+
+    private void checkRecipientsCount() {
+        //if (isRecipientsEditorVisible()) {
+        //mRecipientsEditor.structLastRecipient();
+        //}
+//        hideInputMethod();
+        if (mIpCompose.onIpCheckRecipientsCount()) {
+            return;
+        }
+        if (!MessageUtils.allowSafeDraft(this, MmsConfig.getDeviceStorageFullStatus(), true,
+                TOAST_TYPE_FOR_SEND_MSG)) {
+            updateSendButtonState();
+            return;
+        }
+        final int mmsLimitCount = MmsConfig.getMmsRecipientLimit();
+        String message = "";
+        if (recipientCount() > mmsLimitCount) {
+            message = getString(R.string.max_recipients_message, mmsLimitCount);
+        }
+        boolean isRecipientsEditorEmpty = isRecipientsEditorVisible()
+                && "".equals(mRecipientsEditor.getText().toString().replaceAll(";", "")
+                        .replaceAll(",", "").trim());
+        boolean isConversationRecipientEmpty = !isRecipientsEditorVisible()
+                && "".equals(mConversation.getRecipients().serialize().replaceAll(";", "")
+                        .replaceAll(",", ""));
+
+        message = mOpComposeExt.checkRecipientsCount(message,
+                mWorkingMessage.requiresMms(), recipientCount(),
+                mmsLimitCount, isRecipientsEditorEmpty, isConversationRecipientEmpty, getIntent(),
+                mMsgListAdapter, mSubInfoList, isRecipientsEditorVisible());
+
+        if (mWorkingMessage.requiresMms() && (recipientCount() > mmsLimitCount)) {
+            message = "";
+            if (recipientCount() > mmsLimitCount) {
+                message = getString(R.string.max_recipients_message, mmsLimitCount);
+            }
+
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setTitle(R.string.max_recipients_title);
+            builder.setIconAttribute(android.R.attr.alertDialogIcon);
+            builder.setCancelable(true);
+            builder.setMessage(message);
+            builder.setPositiveButton(R.string.yes, new DialogInterface.OnClickListener() {
+                public void onClick(DialogInterface dialog, int which) {
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            /*
+                             * If entering an existing thread, #mRecipientsEditor
+                             * never gets initialized.
+                             * So, when mRecipientsEditor is not visible, it might be null.
+                             */
+                            List<String> recipientsList;
+                            if (isRecipientsEditorVisible()) {
+                                recipientsList = mRecipientsEditor.getNumbers();
+                            } else {
+                                recipientsList = new ArrayList<String>(
+                                        Arrays.asList(getRecipients().getNumbers()));
+                            }
+                            List<String> newRecipientsList = new ArrayList<String>();
+
+                            if (recipientCount() > mmsLimitCount * 2) {
+                                for (int i = 0; i < mmsLimitCount; i++) {
+                                    newRecipientsList.add(recipientsList.get(i));
+                                }
+                                mWorkingMessage.setWorkingRecipients(newRecipientsList);
+                            } else {
+                                for (int i = recipientCount() - 1; i >= mmsLimitCount; i--) {
+                                    recipientsList.remove(i);
+                                }
+                                mWorkingMessage.setWorkingRecipients(recipientsList);
+                                /// M: fix bug ALPS00432629
+                                newRecipientsList = recipientsList;
+                            }
+                            subSelection();
+
+                            /// M: fix bug ALPS00432629, update title
+                            /// when recipientsList cut to 20 @{
+                            ContactList list = ContactList.getByNumbers(newRecipientsList, false);
+                            mCutRecipients = list;
+                        }
+                    });
+                }
+            });
+            builder.setNegativeButton(R.string.no, null);
+            builder.show();
+            updateSendButtonState();
+        } else {
+            /** M:
+             * fix CR ALPS00069541
+             * if the message copy from sub card with unknown recipient
+             * the recipient will be ""
+             */
+            if ((isRecipientsEditorVisible() && isRecipientsEditorEmpty)
+                    || (!isRecipientsEditorVisible() && isConversationRecipientEmpty)) {
+                new AlertDialog.Builder(this)
+                        .setIconAttribute(android.R.attr.alertDialogIcon)
+                        .setTitle(R.string.cannot_send_message)
+                        .setMessage(R.string.cannot_send_message_reason)
+                        .setPositiveButton(R.string.yes, new CancelSendingListener())
+                        .show();
+            } else {
+                /// M: reply message with the card directly if
+                /// only one card related in conversation
+                subSelection();
+            }
+        }
+    }
+
+    /// M: Code analyze 002,  If a new ComposeMessageActivity is created, kill old one
+    public static Activity getComposeContext() {
+        return sCompose == null ? null : sCompose.get();
+    }
+    /// @}
+
+   @Override
+    public void onShutDown() {
+       /// M: fix bug ALPS01539513
+       if (mWorkingMessage != null && mWorkingMessage.requiresMms()
+               && mWorkingMessage.getSlideshow() != null
+               && !mWorkingMessage.getSlideshow().needUpdate()) {
+           Log.d(TAG, "onShutDown return");
+           return;
+       }
+       /// M: don't save draft again if Compose is finished.
+       if (!this.isFinishing()) {
+           saveDraft(false);
+       }
+       /// @}
+    }
+
+    /*
+    this function is add for read report
+    */
+    private final int READ_REPORT_DISABLED                      = 0;
+    private final int READ_REPORT_SINGLE_MODE_ENABLED           = 1;
+    private final int READ_REPORT_GEMINI_MODE_ENABLED           = 2;
+
+    private void checkAndSendReadReport() {
+        final Context ct = ComposeMessageActivity.this;
+        final long threadId = mConversation.getThreadId();
+        MmsLog.d(MmsApp.TXN_TAG, "checkAndSendReadReport,threadId:" + threadId);
+        new Thread(new Runnable() {
+            public void run() {
+                SharedPreferences prefs =
+                    PreferenceManager.getDefaultSharedPreferences(ComposeMessageActivity.this);
+                int rrAllowed = READ_REPORT_DISABLED;
+                /// @}
+                // / M: [ALPS00465911] [3G Gemini+]JE when Message -> settings
+                // -> cell center -> back to idle @{
+                int[] totalSubIds = SubscriptionManager.from(
+                        ComposeMessageActivity.this).getActiveSubscriptionIdList();
+                MmsLog.d(MmsApp.TXN_TAG, "checkAndSendReadReport,totalSubIds = "
+                        + totalSubIds.length);
+                // / @}
+                rrAllowed = READ_REPORT_GEMINI_MODE_ENABLED;
+
+                MmsLog.d(MmsApp.TXN_TAG, "rrAllowed=" + rrAllowed);
+                // if read report is off, mark the mms read report status readed.
+                if (rrAllowed == READ_REPORT_DISABLED) {
+                    ContentValues values = new ContentValues(1);
+                    String where =
+                        Mms.THREAD_ID + " = " + threadId + " and " + Mms.READ_REPORT + " = 128";
+                    // update uri inbox is not used, must indicate here.
+                    where += " and " + Mms.MESSAGE_BOX + " = " + Mms.MESSAGE_BOX_INBOX;
+                    values.put(Mms.READ_REPORT,
+                            PduHeaders.READ_STATUS__DELETED_WITHOUT_BEING_READ);
+                    SqliteWrapper.update(ct, ct.getContentResolver(), Mms.Inbox.CONTENT_URI,
+                                        values,
+                                        where,
+                                        null);
+                    return;
+                }
+                if (rrAllowed > READ_REPORT_DISABLED) {
+                    StringBuilder suffix = new StringBuilder();
+                    switch (rrAllowed) {
+                        case READ_REPORT_SINGLE_MODE_ENABLED:
+                            // nothing to do in single card mode
+                            break;
+                        case READ_REPORT_GEMINI_MODE_ENABLED:
+                            boolean isAppendAnd = true;
+                            for (int subId : totalSubIds) {
+                                if (prefs.getBoolean(Long.toString(subId) + "_"
+                                        + MmsPreferenceActivity.READ_REPORT_AUTO_REPLY, false)) {
+                                    MmsLog.e(MmsApp.TXN_TAG, "readReport supported on subId: "
+                                            + subId);
+                                    // slot i has card and read report on
+                                    if (isAppendAnd) {
+                                        suffix.append(
+                                                Telephony.Mms.SUBSCRIPTION_ID + " = " + subId);
+                                        isAppendAnd = false;
+                                    } else {
+                                        suffix.append(" or " + Telephony.Mms.SUBSCRIPTION_ID
+                                                + " = " + subId);
+                                    }
+                                } else {
+                                    MmsLog.e(MmsApp.TXN_TAG,
+                                            "mark subId" + subId + " card readed");
+                                    markReadReportProcessed(ct, threadId, subId);
+                                }
+                            }
+                            if (!TextUtils.isEmpty(suffix.toString())) {
+                                suffix.insert(0, " and (");
+                                suffix.append(") ");
+                            }
+                            break;
+                        default:
+                            MmsLog.e(MmsApp.TXN_TAG, "impossible value for rrAllowed.");
+                            break;
+                        }
+                    boolean networkOk = true;
+                    int airplaneMode = Settings.System.getInt(ct.getContentResolver(),
+                            Settings.System.AIRPLANE_MODE_ON, 0);
+                    //network not ok.next time will try.
+                    if ((networkOk != true) || (airplaneMode == 1)) {
+                        MmsLog.d(MmsApp.TXN_TAG, "networkok:"
+                                + networkOk + ",airplaneMode:" + airplaneMode);
+                        return;
+                    }
+                    Cursor cs = null;
+                    try {
+                        String where = Mms.THREAD_ID + " = " + threadId
+                        + " and " + Mms.READ_REPORT + " = 128" + suffix.toString();
+                        cs = SqliteWrapper.query(ct, ct.getContentResolver(),
+                                Mms.Inbox.CONTENT_URI,
+                                new String[]{Mms._ID, Telephony.Mms.SUBSCRIPTION_ID},
+                                where, null, null);
+                        if (cs != null) {
+                            final int count = cs.getCount();
+                            if (count > 0) {
+                                //mark the ones need send read report status to pending as 130.
+                                ContentValues values = new ContentValues(1);
+                                values.put(Mms.READ_REPORT,
+                                        PduHeaders.READ_STATUS__DELETED_WITHOUT_BEING_READ);
+                                // update uri inbox is not used, must indicate here.
+                                where += " and " + Mms.MESSAGE_BOX + " = " + Mms.MESSAGE_BOX_INBOX;
+                                SqliteWrapper.update(ct, ct.getContentResolver(),
+                                        Mms.Inbox.CONTENT_URI, values, where, null);
+                                //show a toast.
+                                runOnUiThread(new Runnable() {
+                                    public void run() {
+                                        Toast.makeText(ComposeMessageActivity.this,
+                                                    ct.getResources().getQuantityString(
+                                                            R.plurals.read_report_toast_msg,
+                                                            count, count),
+                                                    Toast.LENGTH_SHORT).show();
+                                    }
+                                });
+                            }
+                            startSendReadReport(cs);
+                        }
+                    } catch (Exception e) {
+                        MmsLog.e(MmsApp.TXN_TAG,
+                                "exception happend when scan read report!:" + e.getMessage());
+                    } finally {
+                        if (cs != null) {
+                            cs.close();
+                        }
+                    }
+                }
+            }
+
+            private void markReadReportProcessed(Context ct, long threadId, int subId) {
+                ContentValues values = new ContentValues(1);
+                values.put(Mms.READ_REPORT, PduHeaders.READ_STATUS__DELETED_WITHOUT_BEING_READ);
+                String where = Mms.THREAD_ID + " = " + threadId
+                        + " and " + Mms.READ_REPORT + " = 128"
+                        + " and " + Telephony.Mms.SUBSCRIPTION_ID + " = " + subId;
+                // update uri inbox is not used, must indicate here.
+                where += " and " + Mms.MESSAGE_BOX + " = " + Mms.MESSAGE_BOX_INBOX;
+                SqliteWrapper.update(ct, ct.getContentResolver(), Mms.Inbox.CONTENT_URI,
+                                    values,
+                                    where,
+                                    null);
+            }
+
+            private void startSendReadReport(final Cursor cursor) {
+                cursor.moveToPosition(-1);
+                while (cursor.moveToNext()) {
+                    MmsLog.d(MmsApp.TXN_TAG, "send an intent for read report.");
+                    long msgId = cursor.getLong(0);
+                    Intent rrIntent = new Intent(ct, TransactionService.class);
+                    rrIntent.putExtra(TransactionBundle.URI, Mms.Inbox.CONTENT_URI + "/" + msgId);
+                    rrIntent.putExtra(TransactionBundle.TRANSACTION_TYPE,
+                            Transaction.READREC_TRANSACTION);
+
+                    int subId = cursor.getInt(1);
+                    MmsLog.d(MmsApp.TXN_TAG, "subId:" + subId);
+                    rrIntent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
+
+                    ct.startService(rrIntent);
+                }
+            }
+        }).start();
+    }
+
+    /**
+     * Remove the number which is the same as any one before;
+     * When the count of recipients over the limit, make a
+     * toast and remove the recipients over the limit.
+     * @param recipientsString the numbers slipt by ','.
+     * @return recipientsString the numbers slipt by ',' after modified.
+     */
+    private String getStringForMultipleRecipients(String recipientsString) {
+        recipientsString = recipientsString.replaceAll(",", ";");
+        String[] recipients_all = recipientsString.split(";");
+        List<String> recipientsList = new ArrayList<String>();
+        for (String recipient : recipients_all) {
+            recipientsList.add(recipient);
+        }
+
+        Set<String> recipientsSet = new HashSet<String>();
+        recipientsSet.addAll(recipientsList);
+
+        if (recipientsSet.size() > RECIPIENTS_LIMIT_FOR_SMS) {
+            toastTooManyRecipients(recipients_all.length);
+        }
+
+        recipientsList.clear();
+        recipientsList.addAll(recipientsSet);
+
+        recipientsString = "";
+        int count = recipientsList.size() > RECIPIENTS_LIMIT_FOR_SMS
+                ? RECIPIENTS_LIMIT_FOR_SMS : recipientsList.size();
+        StringBuffer buf = new StringBuffer();
+        buf.append(recipientsString);
+        for (int i = 0; i < count; i++) {
+            if (i == (count - 1)) {
+                buf.append(recipientsList.get(i));
+            } else {
+                buf.append(recipientsList.get(i) + ";");
+            }
+        }
+        recipientsString = buf.toString();
+        return recipientsString;
+    }
+
+    /**
+     * Get Conversation.
+     * * Notice: This function is also called by operator plugin(OP01). When modify this function,
+     * please notify operator team.
+     *
+     * @return Conversation
+     */
+    public Conversation getConversation() {
+        return mConversation;
+    }
+
+    /// M: Code analyze 014, Add quick text. @{
+    private void showQuickTextDialog() {
+        mQuickTextDialog = null;
+        //if (mQuickTextDialog == null) {
+            List<String> quickTextsList = new ArrayList<String>();
+
+            /// M: new feature, add default quick text when frist "insert quick text" @{
+            if (MmsConfig.getInitQuickText()) {
+                String[] defaultQuickTexts =
+                    getResources().getStringArray(R.array.default_quick_texts);
+                for (int i = 0; i < defaultQuickTexts.length; i++) {
+                    quickTextsList.add(defaultQuickTexts[i]);
+                }
+            } else {
+                // add user's quick text
+                if (MmsConfig.getQuicktexts().size() == 0) {
+                    MmsConfig.updateAllQuicktexts();
+                }
+                quickTextsList = MmsConfig.getQuicktexts();
+            }
+            /// @}
+
+            List<Map<String, ?>> entries = new ArrayList<Map<String, ?>>();
+            for (String text : quickTextsList) {
+                HashMap<String, Object> entry = new HashMap<String, Object>();
+                entry.put("text", text);
+                entries.add(entry);
+            }
+
+            final SimpleAdapter qtAdapter = new SimpleAdapter(this, entries,
+                    R.layout.quick_text_list_item,
+                    new String[] {"text"}, new int[] {R.id.quick_text});
+
+            AlertDialog.Builder qtBuilder = new AlertDialog.Builder(this);
+
+            qtBuilder.setTitle(getString(R.string.select_quick_text));
+            qtBuilder.setCancelable(true);
+            qtBuilder.setAdapter(qtAdapter, new DialogInterface.OnClickListener() {
+                @SuppressWarnings("unchecked")
+                public final void onClick(DialogInterface dialog, int which) {
+                    HashMap<String, Object> item =
+                        (HashMap<String, Object>) qtAdapter.getItem(which);
+                    if (mSubjectTextEditor != null && mSubjectTextEditor.isFocused()) {
+                        insertText(mSubjectTextEditor, (String) item.get("text"));
+                    } else {
+                        insertText(mTextEditor, (String) item.get("text"));
+                    }
+                    dialog.dismiss();
+                }
+            });
+            mQuickTextDialog = qtBuilder.create();
+        //}
+        mQuickTextDialog.show();
+    }
+    /// @}
+
+    /// M: Code analyze 006, Control Sub indicator on status bar. @{
+    @Override
+    public void onSubInforChanged() {
+        MmsLog.i(MmsApp.LOG_TAG, "onSubInforChanged(): Composer");
+        mMessageSubId = (int) Settings.System.getLong(getContentResolver(),
+                Settings.System.SMS_SIM_SETTING,
+                Settings.System.DEFAULT_SIM_NOT_SET);
+        mSelectedSubId = (int) mMessageSubId;
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mOpComposeExt.onSubInforChanged();
+                updateSendButtonState();
+            }
+        });
+    }
+    /// @}
+
+    /// M: Code analyze 004, Set max height for text editor. @{
+    private final HeightChangedLinearLayout.LayoutSizeChangedListener mLayoutSizeChangedListener =
+            new HeightChangedLinearLayout.LayoutSizeChangedListener() {
+        private int mMaxHeight = 0;
+        @Override
+        public void onLayoutSizeChanged(int w, int h, int oldw, int oldh) {
+            /// M: fix bug ALPS00419856, set TextEditor Height = four when unlock screen @{
+            if (h - oldh > SOFT_KEY_BOARD_MIN_HEIGHT) {
+                mIsSoftKeyBoardShow = false;
+            } else {
+                mIsSoftKeyBoardShow = true;
+            }
+            /// @}
+            mMaxHeight = (h > mMaxHeight) ? h : mMaxHeight;
+            if (h == oldh || mTextEditor == null || mTextEditor.getVisibility() == View.GONE) {
+                return;
+            }
+            MmsLog.d(TAG, "onLayoutSizeChanged(): mIsLandscape = " + mIsLandscape);
+
+            boolean resultIp = mIpCompose.onIpLayoutSizeChanged(mIsSoftKeyBoardShow);
+            boolean resultOp = mOpComposeExt.onLayoutSizeChanged(mIsSoftKeyBoardShow);
+            if (!mIsLandscape) {
+                if (h > oldh && !resultIp && !resultOp) {
+                    updateTextEditorHeightInFullScreen();
+                } else {
+                    mUiHandler.postDelayed(new Runnable() {
+                        public void run() {
+                            MmsLog.d(TAG, "onLayoutSizeChanged(): mTextEditor.setMaxHeight: "
+                                    + mReferencedTextEditorThreeLinesHeight);
+                            mTextEditor.setMaxHeight(mReferencedTextEditorThreeLinesHeight
+                                    * mCurrentMaxHeight / mReferencedMaxHeight);
+                        }
+                    }, 100);
+                }
+            }
+        }
+    };
+
+    private void updateTextEditorHeightInFullScreen() {
+        if (mIsLandscape || mTextEditor == null || mTextEditor.getVisibility() == View.GONE) {
+            return;
+        }
+        mUiHandler.postDelayed(new Runnable() {
+            public void run() {
+                updateFullScreenTextEditorHeight();
+            }
+        }, 100);
+    }
+
+    private void updateFullScreenTextEditorHeight() {
+        boolean resultIp = mIpCompose.updateIpFullScreenTextEditorHeight();
+        boolean resultOp = mOpComposeExt.updateFullScreenTextEditorHeight();
+        if (mAttachmentEditor.getVisibility() == View.VISIBLE
+                && mAttachmentEditor.getHeight() > 0
+                && !mWorkingMessage.hasSlideshow()) {
+            MmsLog.d(TAG, "updateTextEditorHeight(): mTextEditor.setMaxHeight: "
+                    + (mReferencedTextEditorSevenLinesHeight
+                            * mCurrentMaxHeight / mReferencedMaxHeight));
+            if (mIsLandscape) {
+                mTextEditor.setMaxHeight(
+                        mReferencedTextEditorTwoLinesHeight
+                        * mCurrentMaxHeight / mReferencedMaxHeight);
+            } else {
+                if (mIsSoftKeyBoardShow) {
+                    mTextEditor.setMaxHeight(mReferencedTextEditorFourLinesHeight
+                            * mCurrentMaxHeight / mReferencedMaxHeight);
+                } else {
+                    mTextEditor.setMaxHeight(mReferencedTextEditorSevenLinesHeight
+                            * mCurrentMaxHeight / mReferencedMaxHeight);
+                }
+            }
+        } else {
+            /// M: fix bug ALPS00419856, set TextEditor Height = four when unlock screen @{
+            if (mIsSoftKeyBoardShow && !mIsLandscape) {
+                if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                    MmsLog.v(TAG, "updateFullScreenTextEditorHeight() updateTextEditorHeight()" +
+                            ": mTextEditor.setMaxHeight: " + (mReferencedTextEditorFourLinesHeight
+                                * mCurrentMaxHeight / mReferencedMaxHeight));
+                }
+                mTextEditor.setMaxHeight(mReferencedTextEditorFourLinesHeight
+                        * mCurrentMaxHeight / mReferencedMaxHeight);
+            /// @}
+            } else if (!mIsSoftKeyBoardShow && !mIsLandscape) {
+                if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                    MmsLog.v(TAG, "updateTextEditorHeight(): mTextEditor.setMaxHeight: "
+                    + ((mReferencedTextEditorSevenLinesHeight + mReferencedAttachmentEditorHeight)
+                                * mCurrentMaxHeight / mReferencedMaxHeight));
+                }
+                if (!resultIp && !resultOp) {
+                    mTextEditor.setMaxHeight(
+                            (mReferencedTextEditorSevenLinesHeight
+                                    + mReferencedAttachmentEditorHeight)
+                                    * mCurrentMaxHeight / mReferencedMaxHeight);
+                }
+            } else {
+                if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                    MmsLog.v(TAG, "updateTextEditorHeight(): mTextEditor.setMaxHeight: "
+                        + (mReferencedTextEditorTwoLinesHeight * mCurrentMaxHeight
+                                / mReferencedMaxHeight));
+                }
+                mTextEditor.setMaxHeight(mReferencedTextEditorTwoLinesHeight * mCurrentMaxHeight
+                            / mReferencedMaxHeight);
+            }
+        }
+    }
+    /// @}
+
+   @Override
+    public void startActivity(Intent intent) {
+        try {
+            super.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            Intent mChooserIntent = Intent.createChooser(intent, null);
+            super.startActivity(mChooserIntent);
+        }
+    }
+
+    /**
+     * Simple cache to prevent having to load the same PduBody again and again for the same uri.
+     */
+
+    private boolean needSaveDraft() {
+        return ((!isRecipientsEditorVisible())
+                    || (mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms())))
+                && !mWorkingMessage.isDiscarded() && (mWorkingMessage.isWorthSaving());
+    }
+
+    public void onPreMmsSent() {
+        startMsgListQuery(MESSAGE_LIST_QUERY_TOKEN, 0);
+    }
+
+    private boolean checkSlideCount(boolean append) {
+        String mMsg = this.getString(R.string.cannot_add_slide_anymore);
+        Toast mToast = Toast.makeText(this, mMsg, Toast.LENGTH_SHORT);
+        int mSlideCount = 0;
+        SlideshowModel slideShow = mWorkingMessage.getSlideshow();
+        if (slideShow != null) {
+            mSlideCount = slideShow.size();
+        }
+        if (mSlideCount >= SlideshowEditor.MAX_SLIDE_NUM && append) {
+            mToast.show();
+            return false;
+        }
+        return true;
+    }
+
+    /// M: Code analyze 009,Show attachment dialog . @{
+    private class SoloAlertDialog extends AlertDialog {
+        private AlertDialog mAlertDialog;
+
+        private SoloAlertDialog(Context context) {
+            super(context);
+        }
+
+        public boolean needShow() {
+            return mAlertDialog == null || !mAlertDialog.isShowing();
+        }
+
+        public void show(final boolean append) {
+            if (!needShow()) {
+                return;
+            }
+
+            AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
+            builder.setIcon(R.drawable.ic_dialog_attach);
+            builder.setTitle(R.string.add_attachment);
+
+            // if (mAttachmentTypeSelectorAdapter == null) {
+            // add for vcard, if there is a real slideshow, hide vCard
+            int mode = AttachmentTypeSelectorAdapter.MODE_WITH_SLIDESHOW;
+            if (mWorkingMessage.hasSlideshow()) {
+                mode |= AttachmentTypeSelectorAdapter.MODE_WITHOUT_FILE_ATTACHMENT;
+            } else {
+                mode |= AttachmentTypeSelectorAdapter.MODE_WITH_FILE_ATTACHMENT;
+            }
+            if (MessageUtils.isVCalendarAvailable(ComposeMessageActivity.this)) {
+                mode |= AttachmentTypeSelectorAdapter.MODE_WITH_VCALENDAR;
+            }
+            mAttachmentTypeSelectorAdapter = new AttachmentTypeSelectorAdapter(getContext(), mode);
+            // }
+            builder.setAdapter(mAttachmentTypeSelectorAdapter,
+                    new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            addAttachment(
+                                    mAttachmentTypeSelectorAdapter.buttonToCommand(which), append);
+                            dialog.dismiss();
+                        }
+                    });
+            mAlertDialog = builder.show();
+        }
+
+        public void dismiss() {
+            if (mAlertDialog != null && mAlertDialog.isShowing()) {
+                mAlertDialog.dismiss();
+            }
+            super.dismiss();
+        }
+    }
+    /// @}
+
+    private void waitForCompressing() {
+        synchronized (ComposeMessageActivity.this) {
+            while (mCompressingImage) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    MmsLog.e(TAG, "intterrupted exception e ", e);
+                }
+            }
+        }
+    }
+
+    private void notifyCompressingDone() {
+        synchronized (ComposeMessageActivity.this) {
+            mCompressingImage = false;
+            notify();
+        }
+    }
+
+    private boolean mCompressingVCardFinished = false;
+
+    /// M: change return value to int. if attachFile.length is 0,will
+    /// return WorkingMessage.UNKNOWN_ERROR
+    /// The return value will be used in asyncAttachVCardByContactsId
+    /// to judge wether need to saveAsMms or not
+    private int setFileAttachment(final String fileName, final int type, final boolean append) {
+        final File attachFile = getFileStreamPath(fileName);
+        MmsLog.d(TAG, "setFileAttachment(): attachFile.exists()?=" + attachFile.exists() +
+                        ", attachFile.length()=" + attachFile.length());
+        final Resources res = getResources();
+        if (attachFile.exists() && attachFile.length() > 0) {
+            Uri attachUri = Uri.fromFile(attachFile);
+            int result = WorkingMessage.OK;
+            try {
+                if (append) {
+                    mWorkingMessage.checkSizeBeforeAppend();
+                }
+            } catch (ExceedMessageSizeException e) {
+                result = WorkingMessage.MESSAGE_SIZE_EXCEEDED;
+                handleAddAttachmentError(result, R.string.type_common_file);
+                return result;
+            }
+            result = mWorkingMessage.setAttachment(type, attachUri, append);
+            handleAddAttachmentError(result, R.string.type_common_file);
+            mCompressingVCardFinished = true;
+            return result;
+        } else {
+            mUiHandler.post(new Runnable() {
+                public void run() {
+                    Toast.makeText(ComposeMessageActivity.this,
+                            res.getString(R.string.failed_to_add_media, fileName),
+                            Toast.LENGTH_SHORT).show();
+                }
+            });
+            return WorkingMessage.UNKNOWN_ERROR;
+        }
+    }
+
+    public void setCompressingVCardFinished(boolean compressingVCardFinished) {
+        mCompressingVCardFinished = compressingVCardFinished;
+    }
+
+    private void asyncAttachVCalendar(final Uri eventUri) {
+        if (eventUri == null) {
+            return;
+        }
+        getAsyncDialog().runAsync(new Runnable() {
+            public void run() {
+                attachVCalendar(eventUri);
+                /// call saveAsMms to save the draft @{
+                mWorkingMessage.saveAsMms(false);
+                /// @}
+            }
+        }, null, R.string.adding_attachments_title);
+    }
+
+    private void attachVCalendar(Uri eventUri) {
+        if (eventUri == null) {
+            Log.w(TAG, "attachVCalendar, oops uri is null");
+            return;
+        }
+        int result = WorkingMessage.OK;
+
+        /// M: OP01
+        if (!mOpComposeExt.attachVCalendar(mAppendAttachmentSign,
+                WorkingMessage.VCALENDAR, eventUri, R.string.type_common_file)) {
+            result = mWorkingMessage.setAttachment(WorkingMessage.VCALENDAR, eventUri, false);
+            handleAddAttachmentError(result, R.string.type_common_file);
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 019, Add vcard attachment.  @{
+    private void asyncAttachVCardByContactsId(final Intent data) {
+        if (data == null) {
+            return;
+        }
+        getAsyncDialog().runAsyncInThreadPool(new Runnable() {
+            public void run() {
+                long[] contactsId =
+                    data.getLongArrayExtra("com.mediatek.contacts.list.pickcontactsresult");
+                VCardAttachment va = new VCardAttachment(ComposeMessageActivity.this);
+                int result = WorkingMessage.OK;
+                String fileName = va.getVCardFileNameByContactsId(contactsId);
+                /// M: add for attachmentEnhance Modify ALPS00474719 @{
+                if (mOpComposeExt.asyncAttachVCardByContactsId(mAppendAttachmentSign)) {
+                    // add vcard and OP01
+                    result = setFileAttachment(fileName, WorkingMessage.VCARD, true);
+                } else {
+                    // replace or Not OP01
+                    result = setFileAttachment(fileName, WorkingMessage.VCARD, false);
+                }
+
+                /// Fix CR : ALPS00970618
+                /// Fix CR : ALPS01035223 Add VCard with 1000 contacts cause exceed message
+                /// limitation the result should be OK, that saveAsMms or there will be errors @{
+                if (result == WorkingMessage.OK) {
+                    Log.d("[Mms][Composer]", "asyncAttachVCardByContactsId result is ok");
+                    /// Fix CR ALPS01011718 @{
+                    if (mCompressingVCardFinished && mWorkingMessage.isDiscarded()) {
+                        mWorkingMessage.unDiscard();
+                    }
+                    /// @}
+                    mWorkingMessage.saveAsMms(false);
+                }
+                /// @}
+                VCardUtils.deleteVCardTempFile(getApplicationContext(), fileName);
+            }
+        }, null, R.string.adding_attachments_title);
+    }
+    /// @}
+
+    /// M: Code analyze 047, Extra uri from message body and get number from uri.
+    /// Then use this number to update contact cache. @{
+    private void updateContactCache(Cursor cursor) {
+        if (cursor != null) {
+            Set<SpannableString> msgs = new HashSet<SpannableString>();
+            while (cursor.moveToNext()) {
+                String smsBody = cursor.getString(MessageListAdapter.COLUMN_SMS_BODY);
+
+                if (smsBody == null) {
+                    continue;
+                }
+
+                SpannableString msg = new SpannableString(smsBody);
+                msgs.add(msg);
+            }
+            // update the contact cache in an async thread to avoid ANR
+            updateContactCacheAsync(msgs);
+        }
+    }
+
+    private void updateContactCacheAsync(final Set<SpannableString> msgs) {
+        for (SpannableString msg : msgs) {
+            Linkify.addLinks(msg, Linkify.ALL);
+        }
+        new Thread(new Runnable() {
+            public void run() {
+                Set<String> uriSet = new HashSet<String>();
+                for (SpannableString msg : msgs) {
+                    List<String> uris = MessageUtils.extractUris(msg.getSpans(0, msg.length(),
+                        URLSpan.class));
+                    for (String uri : uris) {
+                        uriSet.add(uri);
+                    }
+                }
+                for (String uri : uriSet) {
+                    String[] body = uri.toLowerCase().split("tel:");
+                    if (body.length > 1) {
+                        Contact.get(body[1].trim(), false);
+                    }
+                }
+            }
+        }).start();
+    }
+    /// @}
+
+    /// M: Code analyze 036, Change text size if adjust font size.@{
+    public void setTextSize(float size) {
+        if (mTextEditor != null) {
+            mTextEditor.setTextSize(size);
+        }
+        if (mMsgListAdapter != null) {
+            mMsgListAdapter.setTextSize(size);
+        }
+
+        if (mMsgListView != null && mMsgListView.getVisibility() == View.VISIBLE) {
+            int count = mMsgListView.getChildCount();
+            for (int i = 0; i < count; i++) {
+                MessageListItem item =  (MessageListItem) mMsgListView.getChildAt(i);
+                if (item != null) {
+                    item.setBodyTextSize(size);
+                }
+            }
+        }
+    }
+    /// @}
+
+    public boolean  dispatchTouchEvent(MotionEvent ev) {
+        boolean ret = false;
+        /// M: Code analyze 001, Plugin opeartor. @{
+        if (mOpComposeExt != null) {
+            ret = mOpComposeExt.dispatchTouchEvent(ev);
+        }
+        /// @}
+
+        if (!ret) {
+            ret = super.dispatchTouchEvent(ev);
+        }
+        return ret;
+    }
+
+    private void showKeyBoard(boolean isShow) {
+        if (isShow && mIsSmsEnabled) {
+            mTextEditor.requestFocus();
+            mInputMethodManager.showSoftInput(mTextEditor, 0);
+            mIsKeyboardOpen = true;
+        } else {
+            hideInputMethod();
+        }
+    }
+
+    private long genThreadIdFromContacts(Intent data) {
+        final long[] contactsId = data
+                .getLongArrayExtra("com.mediatek.contacts.list.pickdataresult");
+        if (contactsId == null || contactsId.length <= 0) {
+            Log.d(TAG, "[genThreadIdFromContacts] get recipients from contacts is null");
+            return 0;
+        }
+        final ContactList aList = new ContactList();
+        final ContactList list = new ContactList();
+        ContactList selected = ContactList.blockingGetByIds(contactsId);
+        List<String> selectedNumbers = Arrays.asList(selected.getProtosomaitcNumbers());
+        final List<String> numbers = Arrays.asList(mConversation.getRecipients()
+                .getProtosomaitcNumbers());
+        String selectedNumberAfterFormat = "";
+        if (numbers.size() > 0) {
+            for (String number : numbers) {
+                if (!number.trim().equals("")) {
+                    Contact c = Contact.get(number, false);
+                    aList.add(c);
+                }
+            }
+            // / M: format existing numbers(remove "-" and " ")
+            List<String> formatedNumbers = Arrays.asList(aList.getNumbers(true));
+            for (String selectedNumber : selectedNumbers) {
+                selectedNumberAfterFormat = MessageUtils.parseMmsAddress(selectedNumber);
+                if (selectedNumberAfterFormat != null
+                        && !selectedNumberAfterFormat.trim().equals("")
+                        && !formatedNumbers.contains(selectedNumberAfterFormat)) {
+                    Contact c = Contact.get(selectedNumber, false);
+                    list.add(c);
+                }
+            }
+            aList.addAll(list);
+        }
+        if (aList == null || aList.size() <= 0) {
+            return 0;
+        }
+        long id = Conversation.getOrCreateThreadId(getApplicationContext(), aList);
+        return id;
+    }
+
+    private boolean mIsStartMultiDeleteActivity = false;
+
+    private void updateTextEditorHint() {
+        // add for ipmessage
+        if (mIpCompose.onIpUpdateTextEditorHint()) {
+            return;
+        }
+        if (mIsSmsEnabled) {
+            mTextEditor.setHint(R.string.ipmsg_sms_hint);
+        } else {
+            mTextEditor.setHint(R.string.sending_disabled_not_default_app);
+        }
+        mTextEditor.setFilters(new InputFilter[] {
+            new TextLengthFilter(MmsConfig.getMaxTextLimit())
+        });
+        updateCounter(mWorkingMessage.getText(), 0, 0, 0);
+    }
+
+    private String formatLastOnlineTime(int time) {
+        return MessageUtils.formatTimeStampString(this, (long) (time * 1000L), true);
+    }
+
+    private void checkBeforeSendMessage(boolean bCheckEcmMode) {
+        boolean needSendIpMessage =
+            mIpCompose.checkIpMessageBeforeSendMessage(mSelectedSubId, bCheckEcmMode);
+        if (!needSendIpMessage) {
+            sendMessage(bCheckEcmMode);
+        }
+    }
+
+    /// M:added for bug ALPS00317889
+    private boolean mShowDialogForMultiImage = false;
+
+    /// M: show contact detail or create new contact. @{
+    private static final int MENU_SHOW_CONTACT          = 121;
+    private static final int MENU_CREATE_CONTACT        = 122;
+    private QuickContactBadge mQuickContact;
+    /// @}
+
+    /// M: fix bug ALPS00414023, update sub state dynamically. @{
+    private BroadcastReceiver mSubReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            mOpComposeExt.onReceive(action, mGetSubInfoRunnable);
+
+            if (action != null && action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED)) {
+                    /// M: fix bug ALPS00429274, dismiss Dialog when SUB_CHANGED @{
+                    if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+                        mSubSelectDialog.dismiss();
+                    }
+                    /// @}
+                    /// M: Fix Bug: ALPS00503002 ;
+                    getSubInfoList();
+                    updateSendButtonState();
+                    mMsgListAdapter.notifyDataSetChanged();
+            } else if (action != null
+                    && (action.equals(TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED)
+                        || action.equals(TelephonyIntents.ACTION_SUBINFO_CONTENT_CHANGE))) {
+                mGetSubInfoRunnable.run();
+            }
+        }
+    };
+
+    private void saveAsMms(boolean notify) {
+        if (!MessageUtils.allowSafeDraft(this, MmsConfig.getDeviceStorageFullStatus(), false,
+                TOAST_TYPE_FOR_SAVE_DRAFT)) {
+            return;
+        }
+        if (mNeedSaveAsMms) {
+            mNeedSaveAsMms = false;
+            if (mWorkingMessage.saveAsMms(notify) != null) {
+                mHasDiscardWorkingMessage = true;
+            }
+        }
+    }
+
+    /// M: after delete the last message of one thread,
+    /// don't finish this activity if have draft. @{
+    private void makeDraftEditable(ContactList recipients) {
+        if (!mConversation.getRecipients().equals(recipients)) {
+            mConversation.setRecipients(recipients);
+            MmsLog.d(TAG, "makeDraftEditable, do not equal");
+        } else {
+            MmsLog.d(TAG, "makeDraftEditable, equal");
+            mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
+            mConversation.clearThreadId();
+        }
+        mWorkingMessage.setConversation(mConversation);
+        updateThreadIdIfRunning();
+        invalidateOptionsMenu();
+        hideRecipientEditor();
+        initRecipientsEditor(null);
+        isInitRecipientsEditor = true;
+    }
+    /// @}
+
+    private static final int CELL_PROGRESS_DIALOG = 1;
+
+    @Override
+    protected Dialog onCreateDialog(int id) {
+        //add for ipmessage
+        Dialog dlg = mIpCompose.onIpCreateDialog(id);
+        if (dlg != null) {
+            return dlg;
+        }
+
+        ProgressDialog dialog = null;
+        if (id == CELL_PROGRESS_DIALOG) {
+            dialog = new ProgressDialog(ComposeMessageActivity.this);
+            // mProgressDialog.setTitle(getText(titleResId));
+            dialog.setMessage(getString(R.string.sum_search_networks));
+            dialog.setIndeterminate(true);
+            dialog.setCancelable(false);
+            dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
+            // / M: fix bug ALPS00451836, remove FLAG_DISMISS_KEYGUARD flags
+            if (getWindow() != null) {
+                getWindow().clearFlags(
+                        WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
+                                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
+            }
+        }
+        return dialog;
+    }
+
+    /// M: fix bug ALPS00941735, set Obsolete ThreadId and except it when ConversationList query
+    long mOldThreadID = -1;
+
+    boolean mIsCheckObsolete = false;
+
+    boolean mIsSameConv = true;
+
+    private void checkObsoleteThreadId() {
+        if (isRecipientsEditorVisible()) {
+            List<String> numbers =  mRecipientsEditor.getNumbers();
+            if (numbers != null && numbers.size() > 0) {
+                if (mOldThreadID > 0 && mIsCheckObsolete
+                    && mIsSameConv && !mWorkingMessage.isDiscarded()
+                    && !FolderModeUtils.getMmsDirMode()) {
+                    mIsCheckObsolete = false;
+                    mWorkingMessage.syncWorkingRecipients();
+                    long newThreadId = mWorkingMessage.getConversation().ensureThreadId();
+                    if (mOldThreadID != newThreadId) {
+                        DraftManager.sEditingThread.add(mOldThreadID);
+                        MmsLog.d(TAG, "new recipent list != old, old Obsolete thread id = "
+                            + mOldThreadID);
+                    }
+                }
+            }
+        }
+    }
+
+    /*
+     * M: reload working message when working message is not correct.
+     */
+    private void reloadWorkingMessage() {
+        if (mTempMmsUri == null) {
+            return;
+        }
+        WorkingMessage newMessage = WorkingMessage.load(this, mTempMmsUri);
+
+        if (newMessage != null) {
+            if (newMessage.hasMediaAttachments()) {
+                newMessage.removeAllFileAttaches();
+            }
+            boolean isMmsBefore = mWorkingMessage.requiresMms();
+            newMessage.setSubject(mWorkingMessage.getSubject(), false);
+
+            mWorkingMessage = newMessage;
+            updateThreadIdIfRunning();
+
+            boolean isMmsAfter = mWorkingMessage.requiresMms();
+            if (!isMmsAfter && !isMmsBefore) {
+                mWorkingMessage.setForceUpdateThreadId(true);
+            }
+        }
+    }
+
+    /**
+     * M: For Just not send length required mms with Slot one.<br>
+     * This function:check the mms is whether legnth required mms.
+     *
+     * @return
+     */
+    public boolean isLengthRequiredMms() {
+        MmsLog.d(TAG, "isLengthRequiredMms Checked");
+        if (mWorkingMessage == null) {
+            return false;
+        }
+        if (!mWorkingMessage.requiresMms()) {
+            return false;
+        }
+        if (mWorkingMessage.hasSubject()) {
+            return false;
+        }
+        if (mWorkingMessage.hasAttachedFiles()) {
+            return false;
+        }
+        if (mWorkingMessage.hasAttachment()) {
+            return false;
+        }
+        if ((mWorkingMessage.getState() & 1) > 0) {
+            return false;
+        }
+        SlideshowModel ssm = mWorkingMessage.getSlideshow();
+        if (ssm != null && ssm.size() != 1) {
+            return false;
+        } else if (ssm != null && ssm.get(0) != null && !ssm.get(0).hasText()) {
+            return false;
+        }
+        int slotId = SubscriptionManager.from(MmsApp.getApplication())
+                .getActiveSubscriptionInfo(mSelectedSubId).getSimSlotIndex();
+        if (slotId != 0) {
+            return false;
+        }
+        if (!TelephonyManager.getDefault().isNetworkRoaming(mSelectedSubId)) {
+            return false;
+        }
+        if (ssm == null && mWorkingMessage.hasText()) {
+            return true;
+        }
+        return true;
+    }
+
+    /**
+     * M: For Just not send length required mms with Slot one.<br>
+     */
+    public void confirmForChangeMmsToSms() {
+        if (!isLengthRequiredMms()) {
+            MmsLog.d(TAG, "isLengthRequiredMms Checked false");
+            mOpComposeExt.setConfirmMmsToSms(false);
+            confirmSendMessageIfNeeded();
+            return;
+        }
+        MmsLog.d(TAG, "isLengthRequiredMms Checked true");
+        new AlertDialog.Builder(this)
+            .setTitle("")
+            .setIconAttribute(android.R.attr.alertDialogIcon)
+            .setPositiveButton(R.string.yes, new OnClickListener() {
+                @Override
+                public void onClick(DialogInterface arg0, int arg1) {
+                    mOpComposeExt.setConfirmMmsToSms(false);
+                    mWorkingMessage.setLengthRequiresMms(false, false);
+                    confirmSendMessageIfNeeded();
+                }
+            }).setNegativeButton(R.string.no, new OnClickListener() {
+                @Override
+                public void onClick(DialogInterface arg0, int arg1) {
+                    mOpComposeExt.setConfirmMmsToSms(true);
+                    mWorkingMessage.setLengthRequiresMms(true, false);
+                    updateSendButtonState();
+                }
+            }).setCancelable(true).show();
+    }
+
+    /// M: Whether attachment is being added or not. @{
+    private boolean mWaitingAttachment = false;
+    public boolean isWaitingAttachment() {
+        return mWaitingAttachment;
+    }
+
+    public void setWaitingAttachment(boolean waitingAttachment) {
+        mWaitingAttachment = waitingAttachment;
+    }
+    /// @}
+
+    /// M: add for CMCC feature fix ALPS01317511 @{
+    public boolean isWorthSaving() {
+        boolean ret = false;
+        if (mWorkingMessage != null) {
+            ret = mWorkingMessage.isWorthSaving();
+        }
+        MmsLog.d(TAG, "isWorthSaving: ret = " + ret);
+        return ret;
+    }
+
+    public boolean hasValidRecipient() {
+        boolean ret = true;
+        if (isRecipientsEditorVisible()
+                && !mRecipientsEditor.hasValidRecipient(mWorkingMessage.requiresMms())) {
+            ret = false;
+        }
+        MmsLog.d(TAG, "hasValidRecipient: ret = " + ret);
+        return ret;
+    }
+    /// @}
+
+
+    private void stopDraftService() {
+        if (FeatureOption.MTK_GMO_ROM_OPTIMIZE) {
+            MmsLog.d(TAG, "stop Draft Service");
+            stopService(new Intent(this, DraftService.class));
+        }
+    }
+
+    /**
+     * Get Ip conversation for ip plugin.
+     * Notice: This function is also called by operator plugin(OP01). When modify this function,
+     * please notify operator team.
+     *
+     * @return IIpConversationExt
+     */
+    public IIpConversationExt getIpConversation() {
+        return mConversation.mIpConv;
+    }
+
+    /*
+     * M: ALPS01956117. If image is compressing after onStop,
+     * async save draft operation should be delayed.
+     */
+    private boolean mNeedSaveDraftAfterStop = false;
+
+    public class ComposeActivityCallback implements IComposeActivityCallback {
+
+        public void convertIpMessageToMmsOrSms(int type, boolean isAppend, String path,
+                String text, int subId) {
+            switch (type) {
+                case IpMessageUtils.IpMessageType.TEXT:
+                    mWorkingMessage.setText(text);
+                    break;
+                case IpMessageUtils.IpMessageType.PICTURE:
+                    if (!TextUtils.isEmpty(text)) {
+                        mWorkingMessage.setText(text);
+                        if (mTextEditor != null && mTextEditor.getVisibility() == View.VISIBLE) {
+                            mTextEditor.setText(text);
+                        }
+                    }
+                    File imageFile = new File(path);
+                    Uri imageUri = Uri.fromFile(imageFile);
+                    addImage(imageUri, isAppend);
+                    saveAsMms(true);
+                    break;
+                case IpMessageUtils.IpMessageType.VOICE:
+                    if (!TextUtils.isEmpty(text)) {
+                        mWorkingMessage.setText(text);
+                        if (mTextEditor != null && mTextEditor.getVisibility() == View.VISIBLE) {
+                            mTextEditor.setText(text);
+                        }
+                    }
+                    File voiceFile = new File(path);
+                    Uri voiceUri = Uri.fromFile(voiceFile);
+                    addAudio(voiceUri, isAppend);
+                    saveAsMms(true);
+                    break;
+                case IpMessageUtils.IpMessageType.VCARD:
+                    File vCardFile = new File(path);
+                    Uri vCardUri = Uri.fromFile(vCardFile);
+                    VCardAttachment va = new VCardAttachment(ComposeMessageActivity.this);
+                    String fileName = va.getVCardFileNameByUri(vCardUri);
+                    setFileAttachment(fileName, WorkingMessage.VCARD, false);
+                    saveAsMms(true);
+                    VCardUtils.deleteVCardTempFile(getApplicationContext(), fileName);
+                    break;
+                case IpMessageUtils.IpMessageType.VIDEO:
+                    if (!TextUtils.isEmpty(text)) {
+                        mWorkingMessage.setText(text);
+                        if (mTextEditor != null && mTextEditor.getVisibility() == View.VISIBLE) {
+                            mTextEditor.setText(text);
+                        }
+                    }
+                    File videoFile = new File(path);
+                    Uri videoUri = Uri.fromFile(videoFile);
+                    addVideo(videoUri, isAppend);
+                    saveAsMms(true);
+                    break;
+                case IpMessageUtils.IpMessageType.CALENDAR:
+                    File vCalendarFile = new File(path);
+                    Uri vCalendarUri = Uri.fromFile(vCalendarFile);
+                    attachVCalendar(vCalendarUri);
+                    saveAsMms(true);
+                    break;
+                default:
+                    break;
+            }
+            if (subId > 0) {
+                mSelectedSubId = subId;
+            }
+        }
+
+        public long getCurrentThreadId() {
+            return mConversation.getThreadId();
+        }
+
+        public void deleteDraftSmsMessage() {
+            mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
+        }
+
+        @Override
+        public String getRecipientsEditorInfo() {
+            if (mRecipientsEditor != null && isRecipientsEditorVisible()) {
+                if (mRecipientsEditor.getNumbers().size() == 1) {
+                    return mRecipientsEditor.getNumbers().get(0);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        public List<String> getRecipientsEditorInfoList() {
+            if (mRecipientsEditor != null && isRecipientsEditorVisible()) {
+                return mRecipientsEditor.getNumbers();
+            }
+            return null;
+        }
+
+        @Override
+        public String[] getConversationInfo() {
+            if (mConversation != null && mConversation.getRecipients() != null) {
+                return mConversation.getRecipients().getNumbers();
+            }
+            return null;
+        }
+
+        public IIpConversationExt getIpConversation() {
+            return mConversation.mIpConv;
+        }
+
+        public void callbackCheckConditionsAndSendMessage(boolean bCheckEcmMode) {
+            checkConditionsAndSendMessage(true);
+        }
+
+        public void callbackUpdateSendButtonState() {
+            updateSendButtonState();
+        }
+
+        public void callbackUpdateButtonState(boolean canResponse) {
+            mSendButtonCanResponse = canResponse;
+        }
+
+        public void callbackSendMessage(boolean bCheckEcmMode) {
+            sendMessage(bCheckEcmMode);
+        }
+
+        public void asyncDeleteDraftSmsMessage() {
+            mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
+        }
+
+        public void addIpContacts(int pickCount, int requestCode) {
+            addContacts(pickCount, requestCode);
+        }
+
+        public long genIpThreadIdFromContacts(Intent data) {
+            return genThreadIdFromContacts(data);
+        }
+
+        public void asyncUpdateIpThreadMuteIcon() {
+            asyncUpdateThreadMuteIcon();
+        }
+
+        public void setIpOnlineDividerString(String onLine) {
+            mMsgListAdapter.setOnlineDividerString(onLine);
+        }
+
+        public void updateIpOnlineDividerTime() {
+            mMsgListAdapter.updateOnlineDividerTime();
+        }
+
+        public void notifyIpDataSetChanged() {
+            mMsgListAdapter.notifyDataSetChanged();
+        }
+
+        public void invalidateIpOptionsMenu() {
+            invalidateOptionsMenu();
+        }
+
+        public View showIpOrMmsSendButton(boolean isMms) {
+            return showSmsOrMmsSendButton(isMms);
+        }
+
+        public void setClearIpCacheFlag(boolean clearCacheFlag) {
+            mMsgListAdapter.setClearCacheFlag(clearCacheFlag);
+        }
+
+        public void setIpDraftState(boolean hasDraft) {
+            mConversation.setDraftState(hasDraft);
+        }
+
+        public void runIpAsyncInThreadPool(final Runnable backgroundTask,
+                final Runnable postExecuteTask, final int dialogStringId) {
+            mAsyncDialog.runAsyncInThreadPool(backgroundTask, postExecuteTask, dialogStringId);
+        }
+
+        public void syncIpWorkingRecipients() {
+            mWorkingMessage.syncWorkingRecipients();
+        }
+
+        public void guaranteeIpThreadId() {
+            mConversation.guaranteeThreadId();
+        }
+
+        public void onPreIpMessageSent() {
+            onPreMessageSent();
+        }
+
+        public void resetIpMessage() {
+            resetMessage();
+        }
+
+        public void onIpMessageSent() {
+            onMessageSent();
+        }
+
+        public void onIpClick(View view) {
+            onClick(view);
+        }
+
+        public boolean isIpSubjectEditorVisible() {
+            return isSubjectEditorVisible();
+        }
+
+        public void showIpSubjectEditor(boolean isShow) {
+            showSubjectEditor(isShow);
+        }
+
+        public void drawIpBottomPanel() {
+            drawBottomPanel();
+        }
+
+        public void hideIpSharePanel() {
+        }
+
+        public void addIpAttachment(int commonAttachmentType, boolean append) {
+            if (append) {
+                addAttachment(commonAttachmentType, append);
+            } else {
+                addAttachment(commonAttachmentType, !mWorkingMessage.hasAttachedFiles());
+            }
+        }
+
+        public void enableShareButton(boolean enable) {
+        }
+
+        public void resetSharePanel() {
+        }
+
+        public IWorkingMessageCallback getWorkingMessage() {
+            return mWorkingMessage;
+        }
+
+        public void hideIpRecipientEditor() {
+            hideRecipientEditor();
+        }
+
+        public void onIpSubSelection() {
+            subSelection();
+        }
+
+        public boolean isIpRecipientEditorVisible() {
+            return isRecipientsEditorVisible();
+        }
+
+        public void updateIpTitle() {
+            updateTitle(mConversation.getRecipients());
+        }
+
+        public void hideIpInputMethod() {
+            hideInputMethod();
+        }
+
+        public void showAddAttachmentDialog(final boolean append) {
+            ComposeMessageActivity.this.showAddAttachmentDialog(append);
+        }
+
+        public boolean checkSizeBeforeAppend() {
+            try {
+                mWorkingMessage.checkSizeBeforeAppend();
+            } catch (ExceedMessageSizeException e) {
+                int result = WorkingMessage.MESSAGE_SIZE_EXCEEDED;
+                handleAddAttachmentError(result, R.string.type_common_file);
+                return false;
+            }
+            return true;
+        }
+
+        public int setAttachment(int type, Uri uri, boolean append) {
+            return mWorkingMessage.setAttachment(type, uri, append);
+        }
+
+        public void handleAddAttachmentError(int result, int mediaTypeStringId) {
+            ComposeMessageActivity.this.handleAddAttachmentError(result, mediaTypeStringId);
+        }
+
+        public void checkRecipientsCountCallback() {
+            checkRecipientsCount();
+        }
+
+        public void confirmForChangeMmsToSmsCallback() {
+            confirmForChangeMmsToSms();
+        }
+
+        public void goToConversationListCallback() {
+            goToConversationList();
+        }
+
+        public void setHomeBox(int box) {
+            mHomeBox = box;
+        }
+
+        public void setHadToSlideShowEditor(boolean hadToSlideShowEditor) {
+            mHadToSlideShowEditor = hadToSlideShowEditor;
+        }
+
+        public void setWorkingMessage(IWorkingMessageCallback workingMessage) {
+            mWorkingMessage = (WorkingMessage) workingMessage;
+        }
+
+        public void updateThreadIdIfRunningCallback() {
+            updateThreadIdIfRunning();
+        }
+
+        public void drawTopPanelCallback(boolean showSubjectEditor) {
+            drawTopPanel(showSubjectEditor);
+        }
+
+        public void processNewIntentCallback(Intent intent) {
+            processNewIntent(intent);
+        }
+
+        public void updateCounterCallback(CharSequence text, int start, int before, int count) {
+            updateCounter(text, start, before, count);
+        }
+
+        public boolean isPreparedForSendingCallback() {
+            return isPreparedForSending();
+        }
+
+        public void setIsPickContatct(boolean isPickContatct) {
+            misPickContatct = isPickContatct;
+        }
+
+        public void updateSendButtonStateCallback(boolean enabled) {
+            updateSendButtonState(enabled);
+        }
+
+        public void updateTextEditorHintCallback() {
+            updateTextEditorHint();
+        }
+
+        public void setSendButtonCanResponse(boolean sendButtonCanResponse) {
+            mSendButtonCanResponse = sendButtonCanResponse;
+        }
+
+        public boolean getSendButtonCanResponse() {
+            return mSendButtonCanResponse;
+        }
+
+        public void callbackCheckBeforeSendMessage(boolean bCheckEcmMode) {
+            checkBeforeSendMessage(bCheckEcmMode);
+        }
+
+        public boolean isHasRecipientCountCallback() {
+            return isHasRecipientCount();
+        }
+
+        public void requestRecipientsEditorFocus() {
+            if (isRecipientsEditorVisible()) {
+                mRecipientsEditor.requestFocus();
+            }
+        }
+
+        public CharSequence getTextEditorText() {
+            return mTextEditor.getText();
+        }
+
+        public void hideOrShowTopPanelCallback() {
+            hideOrShowTopPanel();
+        }
+
+        public boolean getIsSmsEnabled() {
+            return mIsSmsEnabled;
+        }
+
+        public OnCreateContextMenuListener getOnCreateContextMenuListener() {
+            return mRecipientsMenuCreateListener;
+        }
+
+        public String getNumbersFromIntentCallback(Intent intent) {
+            return getNumbersFromIntent(intent);
+        }
+
+        public void confirmSendMessageIfNeededCallback() {
+            confirmSendMessageIfNeeded();
+        }
+
+        public void setSubIdCallback(int subId) {
+            setSubId(subId);
+        }
+
+        public void updateFullScreenTextEditorHeightCallback() {
+            updateFullScreenTextEditorHeight();
+        }
+
+        public void showKeyBoardCallback(boolean isShow) {
+            showKeyBoard(isShow);
+        }
+
+        public void setTextEditorMaxHeight(int linesHeight) {
+            mTextEditor.setMaxHeight(linesHeight * mCurrentMaxHeight / mReferencedMaxHeight);
+        }
+
+        public void unpreparedForSendingAlertCallback() {
+            unpreparedForSendingAlert();
+        }
+
+        public boolean showWfcSendButtonPopUpCallback() {
+            return showWfcSendButtonPopUp();
+        }
+    }
+
+    public void setCanResponse(boolean canResponse) {
+        mClickCanResponse = canResponse;
+    }
+
+    ///M: WFC: Show pop-up @ {
+    private boolean showWfcSendButtonPopUp() {
+        MmsLog.d(TAG, "showWfcSendButtonPopUp mSelectedSubId: " + mSelectedSubId);
+        if (MessagingNotification.doShowWfcPopup(mSelectedSubId, getApplicationContext())) {
+            new AlertDialog.Builder(this)
+                .setCancelable(false)
+                .setTitle(R.string.wfc_no_cellular_network)
+                .setMessage(R.string.wfc_connect_to_available_wifi)
+                .setPositiveButton(R.string.OK, new OnClickListener() {
+                    public void onClick(DialogInterface dialog, int whichButton) {
+                        dialog.dismiss();
+                    }
+            }).show();
+            return true;
+        }
+        return false;
+    }
+   /// @}
+
+    @Override
+    public void onRequestPermissionsResult(
+            final int requestCode, final String permissions[], final int[] grantResults) {
+        Log.d(TAG, " onRequestPermissionsResult Activity Count: "
+                + PermissionCheckUtil.sPermissionsActivityStarted);
+        PermissionCheckUtil.setPermissionActivityCount(false);
+        if (isAllPermissionGranted()) {
+            mNeedRequestPermissins = false;
+            if (DraftCache.getInstance() == null) {
+                MmsApp.getApplication().onRequestPermissionsResult();
+            }
+
+            //onCreate begin
+            mForwardingMessage = false;
+
+            /// M: If cell dialog is showed before, do not show it. @{
+            if (mSavedInstanceState != null
+                    && mSavedInstanceState.getBoolean("cell_dialog_showing", false)) {
+                MmsLog.d(TAG, "cell progress dialog is showed before, do not show it now");
+                mSavedInstanceState.putBundle("android:savedDialogs", null);
+            }
+            /// @}
+
+            // add for ipmessage
+            mIpCompose = IpMessageUtils.getIpMessagePlugin(this).getIpComposeActivity();
+            // add for op plugin
+            mOpComposeExt = OpMessageUtils.getOpMessagePlugin().getOpComposeExt();
+
+            mMessageSubId = (int) Settings.System.getLong(getContentResolver(),
+                    Settings.System.SMS_SIM_SETTING, Settings.System.DEFAULT_SIM_NOT_SET);
+
+            mInputMethodManager =
+                (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+
+            /// M: Code analyze 002,  If a new ComposeMessageActivity is created, kill old one
+            Activity compose = sCompose == null ? null : sCompose.get();
+            /// M Fix CR : ALPS01275735, which has mms draft for conversation A, enter it.
+            /// change recipients froam A to B, then come a B notification , click the notification,
+            /// enter the thread A, it will show wrong composer UI.
+            /// because conversation from cache is the same. @{
+            if (compose != null && compose instanceof ComposeMessageActivity) {
+                Intent in = this.getIntent();
+                /// M : Fix issue ALPS01767850 @{
+                if (in.getBooleanExtra("from_notification", false)) {
+                    boolean b = ((ComposeMessageActivity) compose).hasValidRecipient();
+                    if (b) {
+                        mLastThreadIdFromNotification
+                                = ((ComposeMessageActivity) compose)
+                                    .mConversation.ensureThreadId();
+                        if (!((ComposeMessageActivity) compose).mWorkingMessage.hasAttachment()) {
+                            sTextEditorText
+                                    = ((ComposeMessageActivity) compose)
+                                            .mWorkingMessage.getText().toString();
+                        } else {
+                            sTextEditorText = null;
+                        }
+                    }
+                }
+                /// @}
+                long thid = in.getLongExtra("thread_id_from_notification", -1);
+                if (((ComposeMessageActivity) compose).mConversation != null) {
+                    if (thid == ((ComposeMessageActivity) compose).mConversation.getThreadId()) {
+                        ((ComposeMessageActivity) compose).mConversation.clearThreadId();
+                    }
+                }
+            }
+            /// @}
+
+            if (compose != null && !compose.isFinishing() && mSavedInstanceState == null) {
+                MmsLog.d(TAG, "onCreate finish old compose");
+                compose.finish();
+            }
+            sCompose = null;
+            sCompose = new WeakReference(this);
+            /// @}
+            /// M: Code analyze 003,  Set or get max mms size.
+            initMessageSettings();
+            /// @}
+            resetConfiguration(getResources().getConfiguration());
+            /// M: Code analyze 004, Set max height for text editor. @{
+            WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+            if (mIsLandscape) {
+                mCurrentMaxHeight = windowManager.getDefaultDisplay().getWidth();
+            } else {
+                mCurrentMaxHeight = windowManager.getDefaultDisplay().getHeight();
+            }
+            MmsLog.d(TAG, "onCreate(): mCurrentMaxHeight = " + mCurrentMaxHeight);
+            /// @}
+            setContentView(R.layout.compose_message_activity);
+            setProgressBarVisibility(false);
+
+            mIpCompose.onIpComposeActivityCreate(this, mIpComposeCallback, mHandler, mUiHandler,
+                    (ImageButton) findViewById(R.id.send_button_sms),
+                    (TextView) findViewById(R.id.ip_message_typing_status),
+                    (TextView) findViewById(R.id.ipmsg_joyn_stranger_remind),
+                    findViewById(R.id.bottom_panel), mSavedInstanceState,
+                    (ImageButton) findViewById(R.id.share_button),
+                    (LinearLayout) findViewById(R.id.panel_container),
+                    (EditText) findViewById(R.id.embedded_text_editor));
+
+            /// M: add for update sub state dynamically. @{
+            IntentFilter intentFilter =
+                new IntentFilter(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+            mOpComposeExt.onCreate(mIpComposeCallback, getIntent(), intentFilter, compose, this,
+                    mSavedInstanceState, mUiHandler, (ImageButton) findViewById(R.id.share_button),
+                    (LinearLayout) findViewById(R.id.panel_container),
+                    (EditText) findViewById(R.id.embedded_text_editor));
+            /// @}
+
+            /// M: Code analyze 005, Set input mode. @{
+            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
+            /// @}
+
+            // Initialize members for UI elements.
+            initResourceRefs();
+            /// M: Code analyze 006, Control Sub indicator on status bar. @{
+            mStatusBarManager = (StatusBarManager) getSystemService(Context.STATUS_BAR_SERVICE);
+            mComponentName = getComponentName();
+            /// @}
+
+            /// M: Code analyze 007, Get information from Sub or save message to Sub. @{
+            mSubCount = 0;
+            /// @}
+
+            mContentResolver = getContentResolver();
+            mBackgroundQueryHandler = new BackgroundQueryHandler(mContentResolver);
+
+            initialize(mSavedInstanceState, 0, true);
+
+            if (TRACE) {
+                android.os.Debug.startMethodTracing("compose");
+            }
+            /// M: Code analyze 008,unkown . @{
+            mDestroy = false;
+
+            /// @}
+            /// M: Code analyze 009,Show attachment dialog . @{
+            mSoloAlertDialog = new SoloAlertDialog(this);
+            /// @}
+            /// M: Code analyze 007, Get information from Sub or
+            /// save message to Sub.(Get all Sub info) @{
+            mGetSubInfoRunnable.run();
+            /// @} for ALPS00475359 end
+
+            this.registerReceiver(mSubReceiver, intentFilter);
+            /// @}
+
+            //onStart begin
+            mIsActivityStoped = false;
+            boolean isSmsEnabled = MmsConfig.isSmsEnabled(this);
+            if (isSmsEnabled != mIsSmsEnabled) {
+                mIsSmsEnabled = isSmsEnabled;
+                invalidateOptionsMenu();
+            }
+            /// M Fix CR : ALPS01257113, when sub select dialog
+            /// showed in default sms. after change to
+            /// non-default sms, dismiss the sub select dialog @{
+            if (!mIsSmsEnabled) {
+                if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+                    mSubSelectDialog.dismiss();
+                }
+            }
+            /// @}
+
+            /// M: Code analyze 036, Change text size if adjust font size.@{
+            float textSize =
+                MessageUtils.getPreferenceValueFloat(this, SettingListActivity.TEXT_SIZE, 18);
+            setTextSize(textSize);
+            /// @}
+
+            /// M: Code analyze 013, Get contacts from Contact app . @{
+            misPickContatct = false;
+            /// @}
+            // M:for ALPS01065027,just for compose messagelist in scrolling
+            mMsgListView.setOnScrollListener(mScrollListener);
+            mScrollListener.setIsNeedRefresh(true);
+            mScrollListener.setThreadId(mConversation.getThreadId(), ComposeMessageActivity.this);
+            initFocus();
+
+            // Register a BroadcastReceiver to listen on HTTP I/O process.
+            registerReceiver(mHttpProgressReceiver, mHttpProgressFilter);
+            mOpComposeExt.onStart(this, this);
+            loadMessageContent();
+
+            // Update the fasttrack info in case any of the recipients' contact info changed
+            // while we were paused. This can happen, for example, if a user changes or adds
+            // an avatar associated with a contact.
+            /// M: @{
+            if (mConversation.getThreadId() == 0) {
+                mWorkingMessage.syncWorkingRecipients();
+            }
+            /// @}
+
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                MmsLog.vpi(TAG, "onStart: update title, mConversation=" + mConversation.toString());
+            }
+
+            ActionBar actionBar = getActionBar();
+            /// M: Add log. @{
+            if (actionBar == null) {
+                MmsLog.e(TAG, "ACTION BAR is null, window feature FEATURE_ACTION_BAR: "
+                        + getWindow().hasFeature(Window.FEATURE_ACTION_BAR)
+                        + ", feature FEATURE_NO_TITLE: "
+                        + getWindow().hasFeature(Window.FEATURE_NO_TITLE));
+            } else {
+                actionBar.setDisplayHomeAsUpEnabled(true);
+            }
+            /// @}
+
+            /// M: Code analyze 047, Extra uri from message body and get number from uri.
+            /// Then use this number to update contact cache. @{
+            mNeedUpdateContactForMessageContent = true;
+            /// @}
+
+            /// M: Code analyze 001, Plugin opeartor. @{
+            new MmsDialogNotifyUtils(this).closeMsgDialog();
+            /// @}
+
+            if (isRecipientsEditorVisible() && mIsSmsEnabled &&
+                    getResources().getConfiguration().orientation
+                        != Configuration.ORIENTATION_LANDSCAPE) {
+                getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                        WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+            }
+            ///M: WFC: Show notification ticker @ {
+            if (ImsManager.isWfcEnabledByPlatform(getApplicationContext())) {
+//                MessagingNotification.showWfcNotification(getApplicationContext());
+            }
+            /// @}
+            if (mMsgListAdapter != null) {
+                mMsgListAdapter.setOnDataSetChangedListener(mDataSetChangedListener);
+            }
+            addRecipientsListeners();
+        } else {
+            finish();
+        }
+    }
+
+    private boolean requestAllPermissions() {
+        ArrayList<String> missingList;
+        if (CtaUtils.isCtaSupported()) {
+            if (CtaUtils.isEmailMmsSupported()) {
+                missingList = PermissionCheckUtil.getMissingPermissions(this,
+                        PermissionCheckUtil.ALL_CTA_PERMISSIONS);
+            } else {
+                missingList = PermissionCheckUtil.getMissingPermissions(this,
+                        PermissionCheckUtil.ALL_CTA_PERMISSIONS_NO_SEND_MMS);
+            }
+        } else {
+            missingList = PermissionCheckUtil.getMissingPermissions(this,
+                    PermissionCheckUtil.ALL_PERMISSIONS);
+        }
+
+        if (missingList.size() == 0) {
+            Log.d(TAG, " requestAllPermissions all permissions granted");
+            return false;
+        }
+
+        final String[] missingArray = new String[missingList.size()];
+        missingList.toArray(missingArray);
+        Log.d(TAG, " requestAllPermissions all permissions start!");
+        PermissionCheckUtil.setPermissionActivityCount(true);
+        requestPermissions(missingArray,
+                PermissionCheckUtil.REQUIRED_PERMISSIONS_REQUEST_CODE);
+        return true;
+    }
+
+    private boolean isAllPermissionGranted() {
+        String[] permissions;
+        if (CtaUtils.isCtaSupported()) {
+            if (CtaUtils.isEmailMmsSupported()) {
+                permissions = PermissionCheckUtil.ALL_CTA_PERMISSIONS;
+            } else {
+                permissions = PermissionCheckUtil.ALL_CTA_PERMISSIONS_NO_SEND_MMS;
+            }
+        } else {
+            permissions = PermissionCheckUtil.ALL_PERMISSIONS;
+        }
+
+        for (int i = 0; i < permissions.length; i++) {
+            if (!PermissionCheckUtil.hasPermission(this, permissions[i])) {
+                // Show toast
+                if (PermissionCheckUtil.isRequiredPermission(permissions[i])
+                        || PermissionCheckUtil.isNeverGrantedPermission(this, permissions[i])) {
+                    if (!PermissionCheckUtil.isPermissionChecking()) {
+                        PermissionCheckUtil.showNoPermissionsToast(this);
+                    }
+                }
+                Log.d(TAG, "isAllPermissionGranted return false");
+                return false;
+            }
+        }
+
+        Log.d(TAG, "isAllPermissionGranted return true");
+        return true;
+    }
+
+    @Override
+    public void onMultiWindowModeChanged(boolean isInMultiWindowMode) {
+        if (mOpComposeExt != null) {
+            mOpComposeExt.onMultiWindowModeChanged(isInMultiWindowMode);
+        }
+    }
+
+}

Property changes on: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/ComposeMessageActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java
===================================================================
--- vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java	(revision 0)
+++ vendor/branch/5058Y_EMEA/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java	(revision 2619)
@@ -0,0 +1,2420 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.mediatek.mms.ui;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Service;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Configuration;
+import android.database.Cursor;
+import android.database.sqlite.SqliteWrapper;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.ServiceManager;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds;
+import android.provider.ContactsContract.Data;
+import android.provider.Settings;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.text.method.TextKeyListener;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.R;
+import com.android.mms.data.Contact;
+import com.android.mms.data.ContactList;
+import com.android.mms.data.Conversation;
+import com.android.mms.data.WorkingMessage;
+import com.android.mms.data.WorkingMessage.MessageStatusListener;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.ui.AsyncDialog;
+import com.android.mms.ui.ComposeMessageActivity;
+import com.android.mms.ui.MessageUtils;
+import com.android.mms.ui.MsgContentSlideView;
+import com.android.mms.ui.MsgContentSlideView.MsgContentSlideListener;
+import com.android.mms.ui.Presenter;
+import com.android.mms.ui.PresenterFactory;
+import com.android.mms.ui.SlideViewInterface;
+import com.android.mms.ui.SubSelectDialog;
+import com.android.mms.ui.VideoAttachmentView;
+import com.android.mms.ui.MsgNumSlideview.MsgNumBarSlideListener;
+import com.android.mms.ui.SubSelectDialog.SubClickAndDismissListener;
+import com.android.mms.util.AddressUtils;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.MessageResource;
+import com.android.mms.util.MmsContentType;
+import com.android.mms.util.MmsLog;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.MultimediaMessagePdu;
+import com.google.android.mms.pdu.NotificationInd;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPersister;
+
+import com.mediatek.internal.telephony.CellConnMgr;
+import com.mediatek.internal.telephony.DefaultSmsSimSettings;
+import com.mediatek.ipmsg.util.IpMessageUtils;
+import com.mediatek.mms.callback.IDialogModeActivityCallback;
+import com.mediatek.mms.ext.IOpDialogModeActivityExt;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.ipmessage.IIpDialogModeActivityExt;
+import com.mediatek.mms.model.FileAttachmentModel;
+import com.mediatek.mms.util.PermissionCheckUtil;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.MmsPreferenceActivity;
+
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Map;
+/** M:
+ * Dialog mode
+ */
+public class DialogModeActivity extends Activity implements
+    MsgNumBarSlideListener,
+    MsgContentSlideListener,
+    OnClickListener,
+    SlideViewInterface,
+    MessageStatusListener,
+    SubClickAndDismissListener,
+    IDialogModeActivityCallback {
+
+    private int mCurUriIdx;
+    private Uri mCurUri;
+    //private MsgNumSlideview mMsgNumBar;
+    private ImageButton mLeftArrow;
+    private ImageButton mRightArrow;
+    private TextView mMsgNumText;
+    private TextView mSender;
+    //private MsgContentSlideView mContentLayout;
+    private TextView mSmsContentText;
+    private TextView mRecvTime;
+    private TextView mSubName;
+    private ImageView mContactImage;
+    private View mMmsView;
+    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+    private View mMmsAttachView;
+    private ImageView mMmsAttachImageView;
+    private TextView mAttachName;
+    private TextView mAttachSize;
+    /// @}
+    private ImageView mMmsImageView;
+    private ImageButton mMmsPlayButton;
+    private EditText mReplyEditor;
+    private ImageButton mSendButton;
+    private TextView mTextCounter;
+    private Button mCloseBtn;
+    private Button mDeleteBtn;
+    //private ImageButton mCloseBtn;
+    private AsyncDialog mAsyncDialog;   // Used for background tasks.
+    private Cursor mCursor;
+    //private boolean mWaitingForSubActivity;
+    private DialogModeReceiver mReceiver;
+    private boolean mContentViewSet;
+    private AlertDialog mSubSelectDialog;
+    private int mAssociatedSubId;
+    private int mSelectedSubId;
+    private WorkingMessage mWorkingMessage;
+    private boolean mSendingMessage;
+    private boolean mWaitingForSendMessage;
+    private int mSubCount;
+    private int[] mSubIdList;
+    private static Drawable sDefaultContactImage;
+
+    private int mPage = MmsConfig.getSmsToMmsTextThreshold();
+
+    private static final String TAG = "Mms/DialogMode";
+    private static final int SMS_ID = 0;
+    private static final int SMS_TID = 1;
+    private static final int SMS_ADDR = 2;
+    private static final int SMS_DATE = 3;
+    private static final int SMS_READ = 4;
+    private static final int SMS_BODY = 5;
+    private static final int SMS_SUB = 6;
+    private static final int SMS_TYPE = 7;
+    private static final String TYPE_MMS = "mms";
+    private static final String TYPE_SMS = "sms";
+    private static final int REQUEST_CODE_ECM_EXIT_DIALOG = 107;
+    private static final String EXIT_ECM_RESULT = "exit_ecm_result";
+    private static final String SELECT_TYPE = "Select_type";
+    private static final int SIM_SELECT_FOR_SEND_MSG = 1;
+    /// M: see this time out use place comment about it's usage.
+    private static final int DRAW_OVER_TIME_OUT = 100;
+
+    private static final String UNREAD_SELECTION = "(read=0 OR seen=0)";
+
+    private static final int FLAG_HOMEKEY_DISPATCHED = 0X80000000;
+    /// M: fix bug ALPS00446919, merge back from ALPS.JB2.MP to ALPS.JB2
+    //private final ArrayList<Uri> mUris;
+    private ArrayList<Uri> mUris;
+    private ArrayList<String> mReplyContent;
+
+    /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+    private TextView mGroupMmsSender;
+    private boolean mIsGroupMms;
+
+    private boolean mHasRegisterReceiver = false;
+    // M: add for OP
+    private IOpDialogModeActivityExt mOpDialogModeActivityExt;
+
+    private View mIpView;
+
+    Runnable mResetMessageRunnable = new Runnable() {
+        public void run() {
+            MmsLog.d(TAG, "mResetMessageRunnable.run");
+            resetMessage();
+        }
+    };
+
+    Runnable mMessageSentRunnable = new Runnable() {
+        public void run() {
+            MmsLog.d(TAG, "mMessageSentRunnable.run");
+            String body = getString(R.string.strOk);
+            MmsLog.dpi(TAG, "string=" + body);
+            Toast.makeText(getApplicationContext(), body, Toast.LENGTH_SHORT).show();
+        }
+    };
+
+    private final TextWatcher mTextEditorWatcher = new TextWatcher() {
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            return;
+        }
+
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            MmsLog.d(TAG, "mTextEditorWatcher.onTextChanged");
+            // mWorkingMessage.setText(s);
+            updateSendButtonState();
+            updateCounter(s, start, before, count);
+            if (mReplyContent.size() != 0) {
+                mReplyContent.set(mCurUriIdx, s.toString());
+            }
+        }
+
+        public void afterTextChanged(Editable s) {
+            return;
+        }
+    };
+
+    /// M:
+    private ArrayList<Uri> mReadedUris;
+    /** M: this variable is used for a special issue. when use click mms's play button,
+     *  MmsPlayerActivity will be started, and close this activity.
+     *  but the invocation is async, so this activity's finish will be call first.
+     *  when framework started MmsPlayerActivity it will check the invoking activity,
+     *  because this activity is finishing, the new created activity will not put in front.
+     *  so add this flag to control finish activity in onStop.
+     */
+    private boolean mNeedFinish = false;
+
+    private int[] mParams = new int[4];
+    private boolean mReachMax = true;
+
+    private IIpDialogModeActivityExt mIpDialogModeActivity;
+
+    public DialogModeActivity() {
+        mUris = new ArrayList<Uri>();
+        mReplyContent = new ArrayList<String>();
+        mReadedUris = new ArrayList<Uri>();
+
+        mCurUriIdx = 0;
+        mCurUri = null;
+        mCursor = null;
+        mMmsView = null;
+        mMmsImageView = null;
+        mMmsPlayButton = null;
+        //mCellMgr = null;
+        mReceiver = null;
+        mContentViewSet = false;
+        mWorkingMessage = null;
+        //mWaitingForSubActivity = false;
+        /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+        mMmsAttachView = null;
+        mMmsAttachImageView = null;
+        mAttachName = null;
+        mAttachSize = null;
+        /// @}
+
+        // add for ipmessage
+        mIpDialogModeActivity = IpMessageUtils.getIpMessagePlugin(this).getIpDialogModeActivity();
+    }
+
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (PermissionCheckUtil.requestRequiredPermissions(this)) {
+            return;
+        }
+        if (DraftCache.getInstance() == null) {
+            MmsApp.getApplication().onRequestPermissionsResult();
+        }
+
+        // add for op
+        mOpDialogModeActivityExt =
+            OpMessageUtils.getOpMessagePlugin().getOpDialogModeActivityExt();
+        mOpDialogModeActivityExt.setHost(this);
+
+        /// M: do not finish activity when touch outside
+        setFinishOnTouchOutside(false);
+        //getWindow().setFlags(FLAG_HOMEKEY_DISPATCHED,FLAG_HOMEKEY_DISPATCHED);
+
+        MmsLog.d(TAG, "DialogModeActivity.onCreate");
+        addNewUri(getIntent());
+        if (loadCurMsg() != null) {
+            initDialogView();
+            setDialogView();
+            resetMessage();
+        }
+
+        registerReceiver();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        MmsLog.d(TAG, "DialogModeActivity.onResume()");
+        /** M: mReplyEditor.getLineCount() is not right when it is invoked during onCreate.
+         *  in tablet, rotate screen will restore text in EditText, and trigger onTextChanged,
+         *  in the triggered onTextChanged the getLineCount() is still not right.
+         *  even in onResume, getLineCount() is not ensured right.
+         *  the function is right after the layout is drawn. But drawn over no callback.
+         *  so the work around is to check the line count after a millseconds later.
+         *  If the feature hide count when only one line is removed, this code can remove.
+         */
+        if (mOpDialogModeActivityExt.onResume()) {
+            return;
+        }
+
+        Handler tempHandler = new Handler();
+        tempHandler.postDelayed(new Runnable() {
+            public void run() {
+                if (mTextCounter != null && mReplyEditor != null
+                        && mReplyEditor.getLineCount() > 1) {
+                    /// M: the content is set right in onTextChanged. It is just not visible.
+                    mTextCounter.setVisibility(View.VISIBLE);
+                }
+            }
+        }, DRAW_OVER_TIME_OUT);
+    }
+
+    private void registerReceiver() {
+        MmsLog.d(TAG, "DialogModeActivity.registerReceiver");
+        /// M: fix bug ALPS00517135, update sim state dynamically;
+        IntentFilter intentFilter
+                = new IntentFilter(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        registerReceiver(mSimReceiver, intentFilter);
+        mHasRegisterReceiver = true;
+        if (mReceiver != null) {
+            return;
+        }
+        mReceiver = new DialogModeReceiver();
+        IntentFilter filter = new IntentFilter("com.android.mms.dialogmode.VIEWED");
+        registerReceiver(mReceiver, filter);
+    }
+
+    private void unRegisterReceiver() {
+        MmsLog.d(TAG, "DialogModeActivity.unRegisterReceiver");
+        /// M: fix bug ALPS00517135, update sim state dynamically
+        if (mHasRegisterReceiver) {
+            mHasRegisterReceiver = false;
+            unregisterReceiver(mSimReceiver);
+            mSimReceiver = null;
+        }
+        if (mReceiver != null) {
+            unregisterReceiver(mReceiver);
+            mReceiver = null;
+        }
+    }
+    @Override
+    protected void onDestroy() {
+        MmsLog.d(TAG, "DialogModeActivity.onDestroy");
+
+        if (!PermissionCheckUtil.checkRequiredPermissions(this)) {
+            super.onDestroy();
+            return;
+        }
+
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        unRegisterReceiver();
+
+        mIpDialogModeActivity.onIpDestroy();
+        /// M: update widget
+        MmsWidgetProvider.notifyDatasetChanged(getApplicationContext());
+        super.onDestroy();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        MmsLog.d(TAG, "DialogModeActivity.onSaveInstanceState");
+        PowerManager powerManager = (PowerManager) getSystemService(Service.POWER_SERVICE);
+        if (!powerManager.isScreenOn()) {
+            MmsLog.d(TAG, "onSaveInstanceState not ScreenOn");
+            return;
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        MmsLog.d(TAG, "DialogModeActivity.onNewIntent");
+        super.onNewIntent(intent);
+        setIntent(intent);
+        String newString = intent.getStringExtra("com.android.mms.transaction.new_msg_uri");
+        if (mCurUri != null && newString != null) {
+            if (!newString.equals(mCurUri.toString())) {
+                addNewUri(intent);
+            } else {
+                MmsLog.d(TAG, "DialogModeActivity.new Uri = current Uri , don't add NewUri ");
+            }
+        }
+        loadCurMsg();
+        initDialogView();
+        setDialogView();
+//        if (mCellMgr == null) {
+//            mCellMgr = new CellConnMgr();
+//            mCellMgr.register(getApplication());
+//        }
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        MmsLog.dpi(TAG, "DialogModeActivity.onActivityResult, requestCode=" + requestCode
+            + ", resultCode=" + resultCode + ", data=" + data);
+        if (resultCode != RESULT_OK) {
+            MmsLog.w(TAG, "fail due to resultCode=" + resultCode);
+            return;
+        }
+
+        if (requestCode == REQUEST_CODE_ECM_EXIT_DIALOG) {
+                boolean outOfEmergencyMode = data.getBooleanExtra(EXIT_ECM_RESULT, false);
+                MmsLog.d(TAG, "REQUEST_CODE_ECM_EXIT_DIALOG, mode=" + outOfEmergencyMode);
+                if (outOfEmergencyMode) {
+                    sendMessage(false);
+                }
+        } else {
+                MmsLog.d(TAG, "bail due to unknown requestCode=" + requestCode);
+        }
+    }
+
+    @Override
+    public void startActivityForResult(Intent intent, int requestCode) {
+        MmsLog.d(TAG, "DialogModeActivity.startActivityForResult");
+        super.startActivityForResult(intent, requestCode);
+    }
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        MmsLog.d(TAG, "onConfigurationChanged is called");
+        super.onConfigurationChanged(newConfig);
+
+    }
+    private AsyncDialog getAsyncDialog() {
+        if (mAsyncDialog == null) {
+            mAsyncDialog = new AsyncDialog(this);
+        }
+        return mAsyncDialog;
+    }
+    private void resetMessage() {
+        MmsLog.d(TAG, "DialogModeActivity.resetMessage");
+
+        // We have to remove the text change listener while the text editor gets cleared and
+        // we subsequently turn the message back into SMS. When the listener is listening while
+        // doing the clearing, it's fighting to update its counts and itself try and turn
+        // the message one way or the other.
+        mReplyEditor.removeTextChangedListener(mTextEditorWatcher);
+        // Clear the text box.
+        TextKeyListener.clear(mReplyEditor.getText());
+
+        if (mWorkingMessage != null) {
+            MmsLog.d(TAG, "clear working message");
+            mWorkingMessage = null;
+        }
+        updateSendButtonState();
+        mReplyEditor.addTextChangedListener(mTextEditorWatcher);
+        //mReplyEditor.setText("");
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+        } else {
+            mReplyEditor.setText("");
+        }
+        mSendingMessage = false;
+    }
+
+    public void onProtocolChanged(boolean mms, boolean needToast) {
+        MmsLog.d(TAG, "DialogModeActivity.onProtocolChanged");
+    }
+
+    public void onAttachmentChanged() {
+        MmsLog.d(TAG, "DialogModeActivity.onAttachmentChanged");
+    }
+
+    public void onPreMmsSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onPreMmsSent");
+    }
+
+    public void onMaxPendingMessagesReached() {
+        MmsLog.d(TAG, "DialogModeActivity.onMaxPendingMessagesReached");
+    }
+
+    public void onAttachmentError(int error) {
+        MmsLog.d(TAG, "DialogModeActivity.onAttachmentError");
+    }
+
+    private void addNewUri(Intent intent) {
+        if (intent == null) {
+            return;
+        }
+        String newString = intent.getStringExtra("com.android.mms.transaction.new_msg_uri");
+        MmsLog.dpi(TAG, "DialogModeActivity.addNewUri, new uri=" + newString);
+        Uri newUri = Uri.parse(newString);
+        mUris.add(mUris.size(), newUri);
+        mReplyContent.add(mReplyContent.size(), null);
+        mCurUriIdx = mUris.size() - 1;
+        MmsLog.d(TAG, "new index=" + mCurUriIdx);
+        // add for ipmessage
+        mIpDialogModeActivity.onIpAddNewUri(intent, newUri);
+    }
+
+    private void initDialogView() {
+        MmsLog.d(TAG, "DialogModeActivity.initDialogView");
+        if (mContentViewSet) {
+            MmsLog.d(TAG, "have init");
+            return;
+        }
+        setContentView(R.layout.msg_dlg_activity);
+        mContentViewSet = true;
+        updateSubInfoList();
+        mLeftArrow = (ImageButton) findViewById(R.id.previous);
+        mLeftArrow.setOnClickListener(this);
+        mRightArrow = (ImageButton) findViewById(R.id.next);
+        mRightArrow.setOnClickListener(this);
+        mMsgNumText = (TextView) findViewById(R.id.msg_counter);
+        mSender = (TextView) findViewById(R.id.recepient_name);
+        TextView groupSender = (TextView) findViewById(R.id.group_sender);
+        Typeface tf = Typeface.create(Typeface.SANS_SERIF, Typeface.NORMAL);
+        if (tf != null) {
+            mSender.setTypeface(tf);
+        }
+        MsgContentSlideView contentLayout;
+        contentLayout = (MsgContentSlideView) findViewById(R.id.content_scroll_view);
+        contentLayout.registerFlingListener(this);
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+        mGroupMmsSender = (TextView) findViewById(R.id.group_mms_sender);
+        mSmsContentText = (TextView) findViewById(R.id.msg_content);
+        if (tf != null) {
+            mSmsContentText.setTypeface(tf);
+        }
+        mRecvTime = (TextView) findViewById(R.id.msg_recv_timer);
+        if (tf != null) {
+            mRecvTime.setTypeface(tf);
+        }
+
+        LinearLayout simInfo = (LinearLayout) findViewById(R.id.sim_info_linear);
+        simInfo.setVisibility(View.VISIBLE);
+
+        mSubName = (TextView) findViewById(R.id.sub_name);
+        mSubName.setVisibility(View.VISIBLE);
+        if (tf != null) {
+            mSubName.setTypeface(tf);
+        }
+        mContactImage = (ImageView) findViewById(R.id.contact_img);
+        sDefaultContactImage = getApplicationContext().getResources().getDrawable(
+            R.drawable.ic_default_contact);
+        mReplyEditor = (EditText) findViewById(R.id.embedded_reply_text_editor);
+        mReplyEditor.addTextChangedListener(mTextEditorWatcher);
+        mReplyEditor
+                .setFilters(new InputFilter[] {new TextLengthFilter(MmsConfig.getMaxTextLimit())});
+
+        mSendButton = (ImageButton) findViewById(R.id.reply_send_button);
+        mSendButton.setOnClickListener(this);
+        mTextCounter = (TextView) findViewById(R.id.text_counter);
+        mCloseBtn = (Button) findViewById(R.id.mark_as_read_btn);
+        mCloseBtn.setOnClickListener(this);
+        mDeleteBtn = (Button) findViewById(R.id.delete_btn);
+        mDeleteBtn.setOnClickListener(this);
+        //mReplyEditor.setText("");
+        MmsLog.d(TAG, "mCurUriIdx" + mCurUriIdx);
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+            MmsLog.dpi(TAG, "content" + content);
+        }
+        mIpView = (View) findViewById(R.id.ip_view);
+
+        // add for ipmessage
+        mIpDialogModeActivity.onIpInitDialogView(this, mUris, mMmsView, mCursor, this,
+                mReplyEditor, mSmsContentText, mIpView, mGroupMmsSender, mContactImage);
+
+        /// M: add for op
+        mOpDialogModeActivityExt.initDialogView(mSubName,
+                (Button) findViewById(R.id.msg_dlg_mms_download_button), mRecvTime,
+                (TextView) findViewById(R.id.send_time_txt),
+                (LinearLayout) findViewById(R.id.double_time_layout),
+                (LinearLayout) this.findViewById(R.id.button_and_counter),
+                (TextView) findViewById(R.id.ct_text_dlg_counter), mCursor);
+    }
+    private void setDialogView() {
+        // Msg count bar
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.setDialogView msgNum" + msgNum);
+        if (msgNum <= 1) {
+            mLeftArrow.setVisibility(View.INVISIBLE);
+            mRightArrow.setVisibility(View.INVISIBLE);
+            mMsgNumText.setVisibility(View.INVISIBLE);
+        } else {
+            mLeftArrow.setVisibility(View.VISIBLE);
+            mRightArrow.setVisibility(View.VISIBLE);
+            mMsgNumText.setVisibility(View.VISIBLE);
+            StringBuilder msgNumStrBuilder = new StringBuilder("");
+            msgNumStrBuilder.append(mCurUriIdx + 1);
+            msgNumStrBuilder.append('/');
+            msgNumStrBuilder.append(msgNum);
+            String msgNumStr = msgNumStrBuilder.toString();
+            MmsLog.dpi(TAG, "msgNumStr" + msgNumStr);
+            mMsgNumText.setText(msgNumStr);
+        }
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+        }
+        mSender.setText(getSenderString());
+        mSmsContentText.setText(getSmsContent());
+        mRecvTime.setText(getReceivedTime());
+
+        /// M: add for OP
+        mOpDialogModeActivityExt.setDialogView(getApplicationContext(),
+                getCurrentSubId(), isCurSMS(), mCursor != null ? mCursor.getInt(SMS_TYPE) : -1,
+                        getSentTime(), getReceivedTime(), (ImageView) findViewById(R.id.sub_icon));
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+        if (mIsGroupMms) {
+            mContactImage.setImageDrawable(sDefaultContactImage);
+        } else {
+            Drawable image = getContactImage();
+            if (image != null) {
+                mContactImage.setImageDrawable(image);
+            }
+        }
+
+        if (isCurSMS()) {
+            if (mMmsView != null) {
+                MmsLog.d(TAG, "Hide MMS views");
+                mMmsView.setVisibility(View.GONE);
+            }
+            if (mMmsAttachView != null) {
+                MmsLog.d(TAG, "Hide MMS vcard or vcalendar views");
+                mMmsAttachView.setVisibility(View.GONE);
+            }
+            if (mSmsContentText != null) {
+                mSmsContentText.setVisibility(View.VISIBLE);
+            }
+        } else if (isCurMMS()) {
+           MmsLog.d(TAG, "a MMS");
+           loadMmsView();
+        }
+
+        // add for ipmessage
+        String simCharSequence = mIpDialogModeActivity.onIpSetDialogView();
+        MessageUtils.setSubIconAndLabel(getCurrentSubId(), simCharSequence, mSubName);
+        updateSendButtonState();
+    }
+
+    public void onSlideToPrev() {
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToPrev, msgNum=" + msgNum);
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToPrev, mCurUriIdx=" + mCurUriIdx);
+        if (msgNum <= 1) {
+            return;
+        }
+        if (mCurUriIdx == 0) {
+            return;
+        }
+        if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+            MmsLog.dpi(TAG, "DialogModeActivity.onSlideToPrev, mCurUri=" + mCurUri.toString());
+            mReadedUris.add(mCurUri);
+        }
+        mCurUriIdx--;
+        loadCurMsg();
+        setDialogView();
+    }
+
+    public void onSlideToNext() {
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToNext, msgNum=" + msgNum);
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToNext, mCurUriIdx=" + mCurUriIdx);
+        if (msgNum <= 1) {
+            return;
+        }
+        if (mCurUriIdx == (msgNum - 1)) {
+            return;
+        }
+        if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+            MmsLog.dpi(TAG, "DialogModeActivity.onSlideToNext, mCurUri=" + mCurUri.toString());
+            mReadedUris.add(mCurUri);
+        }
+        mCurUriIdx++;
+        loadCurMsg();
+        setDialogView();
+    }
+
+    private boolean isCurSMS() {
+        MmsLog.d(TAG, "DialogModeActivity.isCurSMS");
+        if (judgeParameterIsOk() == false) {
+            return false;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        String type = mCurUri.getAuthority();
+        MmsLog.d(TAG, "type=" + type);
+        if (type.equals(TYPE_SMS)) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isCurMMS() {
+        MmsLog.d(TAG, "DialogModeActivity.isCurMMS");
+        if (judgeParameterIsOk() == false) {
+            return false;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        String type = mCurUri.getAuthority();
+        MmsLog.d(TAG, "type=" + type);
+        if (type.equals(TYPE_MMS)) {
+            return true;
+        }
+        return false;
+    }
+
+    private Cursor loadCurMsg() {
+        MmsLog.d(TAG, "DialogModeActivity.loadCurMsg, idx=" + mCurUriIdx);
+        if (judgeParameterIsOk() == false) {
+            return null;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        MmsLog.dpi(TAG, "uri=" + mCurUri.toString());
+        String projection[];
+        if (isCurSMS()) {
+            projection = new String[] {"_id", "thread_id", "address", "date", "read", "body",
+                "sub_id", "date_sent"};
+        } else {
+            projection = new String[] {"_id", "thread_id", "null as address", "date", "read",
+                "sub", "sub_id", "m_type", "date_sent"};
+        }
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        Cursor cursor = mIpDialogModeActivity.loadCurMsg(mCurUri, projection, UNREAD_SELECTION);
+        if (cursor == null) {
+            cursor = getContentResolver().query(mCurUri, projection, UNREAD_SELECTION, null,
+                    null);
+        }
+        if (cursor == null) {
+            MmsLog.d(TAG, "no msg found");
+            mCursor = null;
+            finish();
+            return null;
+        }
+        /// M: this is a invalid uri, load the next.
+        if (cursor.getCount() == 0) {
+            cursor.close();
+            mUris.remove(mCurUriIdx);
+            mReplyContent.remove(mCurUriIdx);
+            if (mUris.size() > 0) {
+                if (mCurUriIdx == mUris.size()) {
+                    mCurUriIdx = mUris.size() - 1;
+                    MmsLog.d(TAG, "load next new index=" + mCurUriIdx);
+                }
+                return loadCurMsg();
+            }
+            finish();
+            return null;
+        }
+
+        mCursor = cursor;
+        return cursor;
+    }
+    private boolean judgeParameterIsOk() {
+        if (mUris.size() <= 0 || mCurUriIdx >= mUris.size()
+                || (Uri) mUris.get(mCurUriIdx) == null) {
+            if (mCursor != null) {
+                mCursor.close();
+            }
+            mCursor = null;
+            mCurUri = null;
+            mCurUriIdx = 0;
+            finish();
+            return false;
+        } else {
+            return true;
+        }
+    }
+    private void removeCurMsg() {
+        MmsLog.d(TAG, "DialogModeActivity.removeCurMsg");
+        if (judgeParameterIsOk() == false) {
+            return;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        MmsLog.dpi(TAG, "uri=" + mCurUri.toString());
+        MmsLog.d(TAG, "mCurUriIdx=" + mCurUriIdx);
+        mUris.remove(mCurUriIdx);
+        mReplyContent.remove(mCurUriIdx);
+        if (mCurUriIdx != 0) {
+            mCurUriIdx--;
+        }
+        if (mUris.isEmpty()) {
+            MmsLog.d(TAG, "no msg");
+            finish();
+            return;
+        }
+        loadCurMsg();
+        setDialogView();
+    }
+    private String getSenderString() {
+        MmsLog.d(TAG, "DialogModeActivity.getSenderString");
+        if (mCursor == null || mCursor.isClosed()) {
+            MmsLog.d(TAG, "mCursor null");
+            mCursor = null;
+            return "";
+        }
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpGetSenderString() != null) {
+            return mIpDialogModeActivity.onIpGetSenderString();
+        }
+        if (mCursor.moveToFirst()) {
+            if (isCurSMS()) {
+                String recipientIds = mCursor.getString(SMS_ADDR);
+                ContactList recipients;
+                recipients = ContactList.getByNumbers(recipientIds, false, true);
+                // MmsLog.d(TAG, "recipients=" + recipientIds);
+                MmsLog.dpi(TAG, "recipients=" + recipients.formatNames(", "));
+                return recipients.formatNames(", ");
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return "";
+                }
+                ContactList recipients = conv.getRecipients();
+                /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+                mIsGroupMms = MmsPreferenceActivity.getIsGroupMmsEnabled(DialogModeActivity.this)
+                                            && recipients.size() > 1;
+                MmsLog.dpi(TAG, "recipients=" + recipients.formatNames(", "));
+                return recipients.formatNames(", ");
+            }
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getSenderNumber() {
+        MmsLog.d(TAG, "DialogModeActivity.getSenderNumber");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return "";
+        }
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpGetSenderNumber() != null) {
+            return mIpDialogModeActivity.onIpGetSenderNumber();
+        }
+        if (mCursor.moveToFirst()) {
+            if (isCurSMS()) {
+                String addr = mCursor.getString(SMS_ADDR);
+                MmsLog.dpi(TAG, "addr=" + addr);
+                return addr;
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return "";
+                }
+                ContactList recipients = conv.getRecipients();
+                String[] numbers = recipients.getNumbers();
+
+                if (numbers != null && numbers.length != 0) {
+                    MmsLog.dpi(TAG, "number0=" + numbers[0]);
+                    return numbers[0];
+                } else {
+                    MmsLog.d(TAG, "empty number");
+                    return "";
+                }
+            }
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getSmsContent() {
+        MmsLog.d(TAG, "DialogModeActivity.getSmsContent");
+        if (!isCurSMS() || mCursor == null) {
+            return "";
+        }
+        if (mCursor.moveToFirst()) {
+            String content = mCursor.getString(SMS_BODY);
+            MmsLog.dpi(TAG, "content=" + content);
+            return content;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getReceivedTime() {
+        MmsLog.d(TAG, "DialogModeActivity.getReceivedTime");
+        ///M: add for ipmessage
+        String time = mIpDialogModeActivity.getReceivedTime(getApplicationContext(), mCursor);
+        if (!TextUtils.isEmpty(time)) {
+            return time;
+        }
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            long date = mCursor.getLong(SMS_DATE);
+            String strDate;
+            if (isCurSMS()) {
+                strDate = MessageUtils.formatTimeStampString(getApplicationContext(), date);
+            } else {
+                strDate =
+                    MessageUtils.formatTimeStampString(getApplicationContext(), date * 1000L);
+            }
+            MmsLog.d(TAG, "date=" + strDate);
+            builder.append(strDate);
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private String getSentTime() {
+        MmsLog.d(TAG, "DialogModeActivity.getReceivedTime");
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            long date = mCursor.getLong(mCursor.getColumnCount() - 1);
+            String strDate;
+            if (isCurSMS()) {
+                strDate = MessageUtils.formatTimeStampString(getApplicationContext(), date);
+            } else {
+                strDate =
+                    MessageUtils.formatTimeStampString(getApplicationContext(), date * 1000L);
+            }
+            MmsLog.d(TAG, "sentDate=" + strDate);
+            builder.append(strDate);
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private int getCurrentSubId() {
+        int subId = -1;
+        if (mCursor == null) {
+            return subId;
+        }
+        if (mCursor.moveToFirst()) {
+            subId = mCursor.getInt(SMS_SUB);
+        }
+        MmsLog.d(TAG, "getCurrentSubId:" + subId);
+        return subId;
+    }
+
+    private String getSIMName() {
+        MmsLog.d(TAG, "DialogModeActivity.getSIMName");
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            int subId = mCursor.getInt(SMS_SUB);
+            MmsLog.d(TAG, "subId=" + subId);
+            SubscriptionInfo subInfo = SubscriptionManager.from(MmsApp.getApplication())
+                    .getActiveSubscriptionInfo(subId);
+            builder.append(subInfo.getDisplayName().toString());
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private int getSIMColor() {
+        MmsLog.d(TAG, "DialogModeActivity.getSIMColor");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return MessageResource.drawable.sim_background_locked;
+        }
+        if (mCursor.moveToFirst()) {
+            int subId = mCursor.getInt(SMS_SUB);
+            MmsLog.d(TAG, "subId =" + subId);
+            SubscriptionInfo subInfo = SubscriptionManager.from(MmsApp.getApplication())
+                    .getActiveSubscriptionInfo(subId);
+            //MmsLog.d(TAG, "color=" + subInfo.getSimBackgroundLightRes());
+            //MmsLog.d(TAG, "color=" + subInfo.getColor());
+            //return subInfo.getSimBackgroundLightRes();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            //return EncapsulatedR.drawable.sim_background_locked;
+        }
+        return 1;
+    }
+
+    private Drawable getContactImage() {
+        MmsLog.d(TAG, "DialogModeActivity.getContactImage");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return sDefaultContactImage;
+        }
+        if (mCursor.moveToFirst()) {
+            ContactList recipients;
+            boolean isGroup = false;
+            if (isCurSMS()) {
+                String recipientIds = mCursor.getString(SMS_ADDR);
+                recipients = ContactList.getByNumbers(recipientIds, false, true);
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return sDefaultContactImage;
+                }
+                recipients = conv.getRecipients();
+                if (recipients == null) {
+                    return sDefaultContactImage;
+                }
+            }
+            if (recipients == null || recipients.size() == 0) {
+                return sDefaultContactImage;
+            }
+            Contact contact = recipients.get(0);
+            if (contact == null) {
+                MmsLog.d(TAG, "no contact");
+                return sDefaultContactImage;
+            }
+            return contact.getAvatar(getApplicationContext(), sDefaultContactImage, getThreadId());
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return sDefaultContactImage;
+        }
+    }
+
+    private long getThreadId() {
+        MmsLog.d(TAG, "DialogModeActivity.getThreadId");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return -1;
+        }
+        if (mCursor.moveToFirst()) {
+            long tid = mCursor.getLong(SMS_TID);
+            MmsLog.d(TAG, "tid=" + tid);
+            return tid;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return -1;
+        }
+    }
+
+    private Conversation getConversation() {
+        MmsLog.d(TAG, "DialogModeActivity.getConversation");
+        long tid = getThreadId();
+        if (tid < 0) {
+            MmsLog.d(TAG, "invalid tid");
+            return null;
+        }
+        MmsLog.d(TAG, "tid=" + tid);
+        Conversation conv = Conversation.get(this, tid, true); //new Conversation(this, tid, true);
+        if (conv == null) {
+            MmsLog.d(TAG, "conv null");
+            return null;
+        }
+        return conv;
+    }
+
+    // Implements OnClickListener
+    public void onClick(View v) {
+        MmsLog.d(TAG, "DialogModeActivity.onClick");
+        if (v == null) {
+            return;
+        }
+        if (v.equals(mSmsContentText)) {
+            MmsLog.d(TAG, "Clicent content view");
+            openThread(getThreadId());
+        } else if (v.equals(mMmsPlayButton)) { // PLay MMS
+            MmsLog.dpi(TAG, "View this MMS mCurUri: " + mCurUri);
+            if (!isCurMMS()) {
+                return;
+            }
+            MessageUtils.viewMmsMessageAttachment(this, mCurUri, null, getAsyncDialog());
+            if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+                mReadedUris.add(mCurUri);
+            }
+            markAsRead(mReadedUris);
+            /// M: see this variable's note
+            mNeedFinish = true;
+        } else if (v.equals(mSendButton)) {
+            MmsLog.d(TAG, "Send SMS");
+            sendReplySms();
+        } else if (v.equals(mCloseBtn)) {
+            // change the mark as read button to close button.
+            MmsLog.d(TAG, "mark readbtn");
+            if (mCursor != null) {
+                mCursor.close();
+                mCursor = null;
+            }
+            if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+                MmsLog.dpi(TAG, "mCurUri" + mCurUri.toString());
+                mReadedUris.add(mCurUri);
+            }
+            finish();
+        } else if (v == mDeleteBtn) {
+            // change the delete button to view button.
+            MmsLog.d(TAG, "view the message thread");
+            markAsSeen(mReadedUris);
+
+            // add for ipmessage
+            if (!mIpDialogModeActivity.onIpClick(getThreadId())) {
+                openThread(getThreadId());
+            }
+        } else if (v == mLeftArrow) {
+            onSlideToPrev();
+        } else if (v == mRightArrow) {
+            onSlideToNext();
+        }
+    }
+
+    private void openThread(long threadId) {
+        MmsLog.d(TAG, "DialogModeActivity.openThread " + threadId);
+        int flags = Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP
+                | Intent.FLAG_ACTIVITY_CLEAR_TOP;
+        if (!FolderModeUtils.startFolderViewList(
+                mOpDialogModeActivityExt.openThread(), this, null, flags)) {
+            if (threadId < 0) {
+                return;
+            }
+            /// M: Fix CR : ALPS01011718 @{
+            Intent intent = ComposeMessageActivity.createIntent(this, threadId);
+            intent.putExtra("finish", true);
+            intent.setFlags(flags);
+            /// @}
+            startActivity(intent);
+        }
+        finish();
+    }
+
+    private void loadMmsView() {
+        MmsLog.d(TAG, "DialogModeActivity.loadMmsView ");
+        if (mMmsView == null) {
+            MmsLog.d(TAG, "set Mms views visible");
+            mMmsView = findViewById(R.id.msg_dlg_mms_view);
+            mMmsImageView = (ImageView) findViewById(R.id.msg_dlg_image_view);
+            mMmsPlayButton = (ImageButton) findViewById(R.id.msg_dlg_play_slideshow_button);
+            mMmsPlayButton.setVisibility(View.VISIBLE);
+        }
+        mMmsImageView.setVisibility(View.GONE);
+        if (mMmsAttachView == null) {
+            mMmsAttachView = findViewById(R.id.vca_dlg_image_view);
+            mMmsAttachImageView = (ImageView) findViewById(R.id.vca_image_view);
+            mAttachName = (TextView) findViewById(R.id.file_attachment_name_info);
+            mAttachSize = (TextView) findViewById(R.id.file_attachment_size_info);
+        }
+        loadMmsContents();
+    }
+
+    private void sendReplySms() {
+        MmsLog.d(TAG, "DialogModeActivity.sendReplySms");
+        // add for ipmessage
+        if (mIpDialogModeActivity
+                .onIpSendReplySms(mReplyEditor.getText().toString(), getSenderNumber())) {
+            return;
+        }
+        simSelection();
+    }
+
+    private void simSelection() {
+        MmsLog.d(TAG, "DialogModeActivity.simSelection");
+        MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+
+        String number = getSenderNumber();
+        int messageSubId = SubscriptionManager.getDefaultSmsSubscriptionId();
+        MmsLog.d(TAG, "messageSimId=" + messageSubId);
+        Intent intent = new Intent();
+        intent.putExtra(SELECT_TYPE, SIM_SELECT_FOR_SEND_MSG);
+        long currentSubId = getCurrentSubId();
+
+        if (mOpDialogModeActivityExt.simSelection(mSelectedSubId, mSubCount,
+                number, messageSubId, intent, currentSubId, mSubIdList, this)) {
+            return;
+        }
+
+
+        if (mSubCount == 1) {
+            MmsLog.d(TAG, "mSubCount == 1");
+            mSelectedSubId = mSubIdList[0];
+            confirmSendMessageIfNeeded();
+        } else {
+            if (number == null || number.length() == 0) {
+                mAssociatedSubId = -1;
+            } else {
+                mAssociatedSubId = getContactSIM(number);
+            }
+            MmsLog.d(TAG, "mAssociatedSubId=" + mAssociatedSubId);
+
+            if (messageSubId == DefaultSmsSimSettings.ASK_USER_SUB_ID) {
+                // always ask, show SIM selection dialog
+                showSubSelectedDialog(false, intent);
+                updateSendButtonState();
+            } else if (messageSubId == Settings.System.DEFAULT_SIM_NOT_SET) {
+                if (mAssociatedSubId == -1) {
+                    showSubSelectedDialog(false, intent);
+                    updateSendButtonState();
+                } else {
+                    mSelectedSubId = mAssociatedSubId;
+                    confirmSendMessageIfNeeded();
+                }
+            } else {
+                if (!MessageUtils.isSmsSubIdActive(this, messageSubId)) {
+                    showSubSelectedDialog(false, intent);
+                    updateSendButtonState();
+                } else {
+                    mSelectedSubId = messageSubId;
+                    confirmSendMessageIfNeeded();
+                }
+            }
+        }
+
+        MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+    }
+
+    private int getContactSIM(String number) {
+        MmsLog.dpi(TAG, "DialogModeActivity.getContactSIM, " + number);
+
+        int subId = -1;
+        String formatNumber = MessageUtils.formatNumber(number, this);
+        String TrimFormatNumber = formatNumber;
+        if (formatNumber != null) {
+            TrimFormatNumber = formatNumber.replace(" ", "");
+        }
+        Cursor associateSIMCursor = getApplicationContext().getContentResolver().query(
+                Data.CONTENT_URI,
+                new String[] {
+                    ContactsContract.Data.SIM_ASSOCIATION_ID
+                },
+                Data.MIMETYPE + "='" + CommonDataKinds.Phone.CONTENT_ITEM_TYPE + "' AND ("
+                        + Data.DATA1 + "=?" + " OR " + Data.DATA1 + "=?" + " OR " + Data.DATA4
+                        + "=?" + ") AND (" + ContactsContract.Data.SIM_ASSOCIATION_ID
+                        + "!= -1)", new String[] {
+                        number, formatNumber, TrimFormatNumber
+                }, null);
+        try {
+            if (null == associateSIMCursor) {
+                MmsLog.w(TAG, " queryContactInfo : associateSIMCursor is null");
+            } else {
+                MmsLog.d(TAG, " queryContactInfo : associateSIMCursor is not null. Count["
+                    + associateSIMCursor.getCount() + "]");
+            }
+            if ((null != associateSIMCursor) && (associateSIMCursor.getCount() > 0)) {
+                associateSIMCursor.moveToFirst();
+                // Get only one record is OK
+                subId = (Integer) associateSIMCursor.getInt(0);
+            } else {
+                subId = -1;
+            }
+            MmsLog.d(TAG, "subId=" + subId);
+        } finally {
+            if (associateSIMCursor != null) {
+                associateSIMCursor.close();
+            }
+        }
+        return subId;
+    }
+    private void showSubSelectedDialog(boolean overridePref , Intent intent) {
+        SubSelectDialog subSelectDialog = new SubSelectDialog(this, this);
+        mSubSelectDialog = subSelectDialog.showSubSelectedDialog(true, null, intent);
+    }
+
+    @Override
+    public void onDialogClick(int subId, Intent intent) {
+        mSelectedSubId = subId;
+        updateSendButtonState();
+        if (intent.getIntExtra(SELECT_TYPE, -1) == SIM_SELECT_FOR_SEND_MSG) {
+            confirmSendMessageIfNeeded();
+        }
+    }
+
+    @Override
+    public void onDialogDismiss() {
+        // TODO Auto-generated method stub
+    }
+
+    @Override
+    public void onCancelClick() {
+        // TODO Auto-generated method stub
+    }
+
+    private void confirmSendMessageIfNeeded() {
+        MmsLog.d(TAG, "DialogModeActivity.confirmSendMessageIfNeeded");
+        checkConditionsAndSendMessage(true);
+    }
+
+    private void checkConditionsAndSendMessage(final boolean bCheckEcmMode) {
+        MmsLog.d(TAG, "DialogModeActivity.checkConditionsAndSendMessage");
+        if (mSelectedSubId <= 0) {
+            mSelectedSubId = SubscriptionManager.getDefaultSubscriptionId();
+        }
+        // add CellConnMgr feature
+        final CellConnMgr cellConnMgr = new CellConnMgr(getApplicationContext());
+        final int state = cellConnMgr.getCurrentState(mSelectedSubId, CellConnMgr.STATE_FLIGHT_MODE
+                | CellConnMgr.STATE_SIM_LOCKED | CellConnMgr.STATE_RADIO_OFF);
+        MmsLog.d(TAG, "CellConnMgr, state is " + state);
+        if (!ImsManager.isWfcEnabledByUser(this) &&
+            (((state & CellConnMgr.STATE_FLIGHT_MODE) == CellConnMgr.STATE_FLIGHT_MODE) ||
+            ((state & CellConnMgr.STATE_RADIO_OFF) == CellConnMgr.STATE_RADIO_OFF) ||
+            ((state & (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))
+                  == (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))))  {
+            final ArrayList<String> stringArray = cellConnMgr.getStringUsingState(mSelectedSubId,
+                    state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(android.R.string.ok,
+                        new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                                updateSendButtonState();
+                            }
+                        });
+                builder.show();
+            }
+        }  else if ((state & CellConnMgr.STATE_SIM_LOCKED) == CellConnMgr.STATE_SIM_LOCKED) {
+            final ArrayList<String> stringArray
+                    = cellConnMgr.getStringUsingState(mSelectedSubId, state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setCancelable(true);
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(stringArray.get(2),
+                        new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                            cellConnMgr.handleRequest(mSelectedSubId, state);
+                            updateSendButtonState();
+                    }
+                });
+                builder.setNegativeButton(stringArray.get(3),
+                        new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                                updateSendButtonState();
+                            }
+                        });
+                builder.show();
+            }
+        } else {
+            sendMessage(bCheckEcmMode);
+        }
+    }
+
+    private void sendMessage(boolean bCheckEcmMode) {
+        MmsLog.d(TAG, "DialogModeActivity.sendMessage," + bCheckEcmMode);
+
+        if (bCheckEcmMode) {
+            MmsLog.d(TAG, "bCheckEcmMode=" + bCheckEcmMode);
+
+            // TODO: expose this in telephony layer for SDK build
+            int phoneId = SubscriptionManager.getPhoneId(mSelectedSubId);
+            String inEcm = TelephonyManager.getTelephonyProperty(phoneId,
+                    TelephonyProperties.PROPERTY_INECM_MODE, null);
+            //String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE);
+            if (Boolean.parseBoolean(inEcm)) {
+                try {
+                    MmsLog.d(TAG, "show notice to block others");
+                    startActivityForResult(new Intent(
+                            TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),
+                        REQUEST_CODE_ECM_EXIT_DIALOG);
+                    return;
+                } catch (ActivityNotFoundException e) {
+                    // continue to send message
+                    MmsLog.e(TAG, "Cannot find EmergencyCallbackModeExitDialog", e);
+                }
+            }
+        }
+        /*
+         * ContactList contactList = isRecipientsEditorVisible()
+         * ? mRecipientsEditor.constructContactsFromInput(false) :
+         * getRecipients(); mDebugRecipients = contactList.serialize();
+         */
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpSendMessage(mReplyEditor.getText().toString(),
+                getSenderNumber())) {
+            return;
+        }
+
+        if (!mSendingMessage) {
+            /*
+             * if (LogTag.SEVERE_WARNING) {
+             * String sendingRecipients = mConversation.getRecipients().serialize(); if
+             * (!sendingRecipients.equals(mDebugRecipients)) { String workingRecipients =
+             * mWorkingMessage.getWorkingRecipients();
+             * if (!mDebugRecipients.equals(workingRecipients)) {
+             * LogTag.warnPossibleRecipientMismatch(
+             * "ComposeMessageActivity.sendMessage" + " recipients in window: \"" +
+             * mDebugRecipients + "\" differ from recipients from conv: \"" + sendingRecipients +
+             * "\" and working recipients: " + workingRecipients, this); } }
+             * sanityCheckConversation(); }
+             */
+
+            // send can change the recipients. Make sure we remove the listeners first and then add
+            // them back once the recipient list has settled.
+            // removeRecipientsListeners();
+            MmsLog.d(TAG, "new working message");
+            mWorkingMessage = WorkingMessage.createEmpty(this, this);
+            // mWorkingMessage.setMessageStatusListener(this);
+            mWorkingMessage.setConversation(getConversation());
+            mWorkingMessage.setText(mReplyEditor.getText());
+            MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+            mWorkingMessage.send("", mSelectedSubId);
+            mSendingMessage = true;
+            mWaitingForSendMessage = true;
+            mCurUri = (Uri) mUris.get(mCurUriIdx);
+            markAsRead(mCurUri);
+        }
+    }
+
+    private void loadMmsContents() {
+        MmsLog.d(TAG, "DialogModeActivity.loadMmsContents");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return;
+        }
+
+        if (!mCursor.moveToFirst()) {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return;
+        }
+        MmsLog.d(TAG, "cursor ok");
+            // check msg type
+            int type = mCursor.getInt(SMS_TYPE);
+            MmsLog.d(TAG, "type=" + type);
+
+            if (PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND == type) {
+                MmsLog.d(TAG, "mms nofity");
+                String content;
+                content = getNotificationContentString(mCurUri);
+                mSmsContentText.setText(content);
+                if (mMmsAttachView != null) {
+                    mMmsAttachView.setVisibility(View.GONE);
+                }
+                if (mMmsView != null) {
+                    mMmsView.setVisibility(View.GONE);
+                }
+                return;
+            }
+
+            // get MMS pdu
+            PduPersister p = PduPersister.getPduPersister(this);
+            MultimediaMessagePdu msg;
+            SlideshowModel slideshow = null;
+
+            try {
+                msg = (MultimediaMessagePdu) p.load(mCurUri);
+            } catch (MmsException e) {
+                MmsLog.d(TAG, e.toString());
+                msg = null;
+            }
+
+            if (msg == null) {
+                MmsLog.d(TAG, "msg null");
+                return;
+            }
+
+            // get slideshow
+        try {
+            slideshow = SlideshowModel.createFromPduBody(this, msg.getBody());
+        } catch (MmsException e) {
+            slideshow = null;
+            e.printStackTrace();
+        }
+            if (slideshow == null) {
+                MmsLog.d(TAG, "loadMmsContents(); slideshow null");
+            } else {
+                MmsLog.d(TAG, "loadMmsContents(); slideshow ok");
+            }
+
+            // set Mms content text
+            EncodedStringValue subObj = msg.getSubject();
+            String subject = null;
+
+            if (subObj != null) {
+                subject = subObj.getString();
+                MmsLog.dpi(TAG, "sub=" + subject);
+            }
+
+            SpannableStringBuilder buf = new SpannableStringBuilder();
+            boolean hasSubject = false;
+
+            // init set a empty string
+            buf.append("");
+
+            // add subject
+            if ((subject != null) && (subject.length() > 0)) {
+                hasSubject = true;
+                buf.append(TextUtils.replace(getResources().getString(R.string.inline_subject),
+                    new String[] {"%s"}, new CharSequence[] {subject}));
+                buf.replace(0, buf.length(), buf);
+            }
+
+            MmsLog.dpi(TAG, "with sub=" + buf.toString());
+
+        if (slideshow == null) {
+            MmsLog.d(TAG, "slideshow null");
+            mMmsView.setVisibility(View.GONE);
+            mMmsAttachView.setVisibility(View.GONE);
+            if (buf.length() == 0) {
+                mSmsContentText.setText("        ");
+            }
+        } else {
+                // append first text to content
+                SlideModel slide = slideshow.get(0);
+                String body;
+
+                if ((slide != null) && slide.hasText()) {
+                    TextModel tm = slide.getText();
+                    body = tm.getText();
+                    MmsLog.dpi(TAG, "body=" + body);
+
+                    if (hasSubject) {
+                        buf.append(" - ");
+                    }
+                    buf.append(body);
+                } else { // First slide no text
+                    if (!hasSubject) {
+                        buf.append("        ");
+                    }
+                }
+                MmsLog.dpi(TAG, "with cont=" + buf.toString());
+                mSmsContentText.setText(buf);
+                mSmsContentText.setVisibility(View.VISIBLE);
+
+                // Set Mms play button
+                boolean needPresent = false;
+                for (int i = 0; i < slideshow.size(); i++) {
+                    MmsLog.d(TAG, "check slide" + i);
+                    slide = slideshow.get(i);
+                    if (slide.hasImage() || slide.hasVideo() || slide.hasAudio()) {
+                        MmsLog.d(TAG, "found");
+                        needPresent = true;
+                        break;
+                    }
+                }
+
+                if (!needPresent) {
+                if (slideshow.size() > 1) {
+                        needPresent = true;
+                }
+            }
+                if (needPresent) {
+                        MmsLog.d(TAG, "present slidehsow");
+                        Presenter presenter = PresenterFactory.getPresenter(
+                            "MmsThumbnailPresenter", this, this, slideshow);
+                        presenter.present(null);
+                        mMmsPlayButton.setOnClickListener(this);
+                        mMmsAttachView.setVisibility(View.GONE);
+                        setSmsContentTextView();
+                } else {
+                    MmsLog.d(TAG, "no media");
+                    mMmsView.setVisibility(View.GONE);
+                    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+                    setVcardOrVcalendar(slideshow);
+                }
+        }
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms @{
+        if (mIsGroupMms) {
+            mGroupMmsSender.setVisibility(View.VISIBLE);
+            String name = interpretFrom(msg.getFrom(), mCurUri) + ":";
+            mGroupMmsSender.setText(name);
+        } else {
+            mGroupMmsSender.setVisibility(View.GONE);
+        }
+        /// @}
+    }
+
+    private String getNotificationContentString(Uri uri) {
+        MmsLog.d(TAG, "DialogModeActivity.getNotificationContentString");
+
+        PduPersister p = PduPersister.getPduPersister(this);
+        NotificationInd msg;
+
+        try {
+            msg = (NotificationInd) p.load(mCurUri);
+            /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms @{
+            if (mIsGroupMms) {
+                mGroupMmsSender.setVisibility(View.VISIBLE);
+                String name = interpretFrom(msg.getFrom(), mCurUri) + ":";
+                mGroupMmsSender.setText(name);
+            } else {
+                mGroupMmsSender.setVisibility(View.GONE);
+            }
+            /// @}
+        } catch (MmsException e) {
+            MmsLog.d(TAG, e.toString());
+            return "";
+        }
+        if (msg == null) {
+            MmsLog.d(TAG, "msg null");
+            return "";
+        }
+
+        String msgSizeText = this.getString(R.string.message_size_label)
+            + String.valueOf((msg.getMessageSize() + 1023) / 1024)
+            + this.getString(R.string.kilobyte);
+
+        String timestamp = this.getString(R.string.expire_on, MessageUtils.formatTimeStampString(
+            this, msg.getExpiry() * 1000L));
+
+        String ret = msgSizeText + "\r\n" + timestamp;
+        ret = mOpDialogModeActivityExt.getNotificationContentString(
+                this.getString(R.string.from_label)
+                + (getSenderNumber()), this.getString(R.string.subject_label)
+                + (msg.getSubject() != null ? msg.getSubject().getString() : ""), msgSizeText,
+                timestamp);
+        MmsLog.d(TAG, "ret=" + ret);
+
+        return ret;
+    }
+
+    // SlideshowModel mSlideshow;
+    private SlideshowModel getSlideShow() {
+        MmsLog.d(TAG, "DialogModeActivity.getSlideShow ");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return null;
+        }
+
+        if (mCursor.moveToFirst()) {
+            MmsLog.d(TAG, "cursor ok");
+
+                PduPersister p = PduPersister.getPduPersister(this);
+                int type = mCursor.getInt(SMS_TYPE);
+                MmsLog.d(TAG, "type=" + type);
+
+                if (PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND == type) {
+                    MmsLog.d(TAG, "mms nofity");
+                    return null;
+                }
+
+                MultimediaMessagePdu msg;
+                try {
+                    msg = (MultimediaMessagePdu) p.load(mCurUri);
+                } catch (MmsException e) {
+                    MmsLog.d(TAG, e.toString());
+                e.printStackTrace();
+                    msg = null;
+                }
+
+                if (msg != null) {
+                SlideshowModel slideshow;
+                try {
+                    slideshow = SlideshowModel
+                            .createFromPduBody(this, msg.getBody());
+                } catch (MmsException e) {
+                    MmsLog.d(TAG, e.toString());
+                    e.printStackTrace();
+                    slideshow = null;
+                }
+                    if (slideshow == null) {
+                        MmsLog.d(TAG, "getSlideShow(); slideshow null");
+                    } else {
+                        MmsLog.d(TAG, "getSlideShow(); slideshow ok");
+                    }
+                    return slideshow;
+                }
+                MmsLog.d(TAG, "msg null");
+
+            return null;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return null;
+        }
+    }
+
+    @Override
+    public void startAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.startAudio");
+    }
+
+    @Override
+    public void startVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.startVideo");
+    }
+
+    @Override
+    public void setAudio(Uri audio, String name, Map<String, ?> extras) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setAudio");
+    }
+
+    @Override
+    public void setTextVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setTextVisibility");
+    }
+
+    @Override
+    public void setText(String name, String text) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setText");
+    }
+
+    @Override
+    public void setImage(String name, Bitmap bitmap) {
+        MmsLog.d(TAG, "DialogModeActivity.setImage " + name);
+        // inflateMmsView();
+
+        try {
+            Bitmap image = bitmap;
+            if (null == image) {
+                MmsLog.d(TAG, "bitmap null");
+                image = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_picture);
+            }
+            MmsLog.d(TAG, "set bitmap to mMmsImageView");
+            mMmsImageView.setImageBitmap(image);
+            mMmsImageView.setVisibility(View.VISIBLE);
+            mMmsView.setVisibility(View.VISIBLE);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage: out of memory:" + e.toString());
+        }
+    }
+
+    @Override
+    public void setImage(Uri mUri) {
+        MmsLog.d(TAG, "DialogModeActivity.setImage(uri) ");
+        try {
+            Bitmap bitmap = null;
+            if (null == mUri) {
+                bitmap = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_picture);
+            } else {
+                //String mScheme = mUri.getScheme();
+                InputStream mInputStream = null;
+                try {
+                    mInputStream = getApplicationContext().getContentResolver().openInputStream(
+                        mUri);
+                    if (mInputStream != null) {
+                        bitmap = BitmapFactory.decodeStream(mInputStream);
+                    }
+                } catch (FileNotFoundException e) {
+                    bitmap = null;
+                } finally {
+                    if (mInputStream != null) {
+                        mInputStream.close();
+                    }
+                }
+            }
+                setImage("", bitmap);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage(Uri): out of memory: ", e);
+        } catch (Exception e) {
+            MmsLog.d(TAG, "setImage(uri) error." + e);
+        }
+    }
+
+    @Override
+    public void reset() {
+        MmsLog.d(TAG, "DialogModeActivity.reset");
+
+        if (mMmsView != null) {
+            mMmsView.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public void setVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setVisibility");
+        mMmsView.setVisibility(View.VISIBLE);
+    }
+
+    @Override
+    public void pauseAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.pauseAudio");
+
+    }
+
+    @Override
+    public void pauseVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.pauseVideo");
+
+    }
+
+    @Override
+    public void seekAudio(int seekTo) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.seekAudio");
+
+    }
+
+    @Override
+    public void seekVideo(int seekTo) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.seekVideo");
+
+    }
+
+    @Override
+    public void setVideoVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setVideoVisibility");
+    }
+
+    @Override
+    public void stopAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.stopAudio");
+    }
+
+    @Override
+    public void stopVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.stopVideo");
+    }
+
+    @Override
+    public void setVideo(String name, Uri video) {
+        MmsLog.d(TAG, "DialogModeActivity.setVideo");
+        // inflateMmsView();
+
+        try {
+            Bitmap bitmap = VideoAttachmentView.createVideoThumbnail(this, video);
+            if (null == bitmap) {
+                MmsLog.d(TAG, "bitmap null");
+                bitmap = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_video);
+            }
+            MmsLog.d(TAG, "set bitmap to mMmsImageView");
+            mMmsImageView.setImageBitmap(bitmap);
+            mMmsImageView.setVisibility(View.VISIBLE);
+            mMmsView.setVisibility(View.VISIBLE);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage: out of memory:" + e.toString());
+        }
+    }
+
+    @Override
+    public void setVideoThumbnail(String name, Bitmap bitmap) {
+        MmsLog.d(TAG, "setVideoThumbnail");
+    }
+
+    @Override
+    public void setImageRegionFit(String fit) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setImageRegionFit");
+    }
+
+    @Override
+    public void setImageVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setImageVisibility");
+        mMmsView.setVisibility(View.VISIBLE);
+    }
+
+    @Override
+    public int getWidth() {
+        MmsLog.d(TAG, "DialogModeActivity.getWidth" + mMmsImageView.getWidth());
+        return mMmsImageView.getWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        MmsLog.d(TAG, "DialogModeActivity.getHeight" + mMmsImageView.getHeight());
+        return mMmsImageView.getHeight();
+    }
+
+    private void updateSendButtonState() {
+        boolean enable = false;
+        int len = 0;
+        if (mReplyEditor != null) {
+            len = mReplyEditor.getText().toString().length();
+        }
+        MmsLog.d(TAG, "DialogModeActivity.updateSendButtonState(): len = " + len);
+
+        if (mSendButton != null) {
+            if (len > 0) {
+                MmsLog.d(TAG, "updateSendButtonState(): mSubCount = " + mSubCount);
+
+                /** M: MTK Encapsulation ITelephony */
+                // ITelephony phone = ITelephony.Stub
+                //        .asInterface(ServiceManager.checkService("phone"));
+                ITelephony sTelephony
+                        = ITelephony.Stub.asInterface(ServiceManager.getService("phone"));
+                //TelephonyService phone = EncapsulatedTelephonyService.getInstance();
+                if (sTelephony != null) {
+                    if (isAnySimInsert()) { // check SIM state
+                        enable = true;
+                    }
+                }
+            }
+
+            // View sendButton = showSmsOrMmsSendButton(mWorkingMessage.requiresMms());
+            mSendButton.setEnabled(enable);
+            mSendButton.setFocusable(enable);
+            if (enable) {
+                mSendButton.setImageResource(R.drawable.ic_send_ipmsg);
+            } else {
+                mSendButton.setImageResource(R.drawable.ic_send_sms_unsend);
+            }
+        }
+        // add for ipmessage
+        mIpDialogModeActivity.onIpUpdateSendButtonState(mSendButton);
+        mOpDialogModeActivityExt.updateSendButtonState(enable);
+    }
+
+    private boolean isAnySimInsert() {
+        MmsLog.d(TAG, "DialogModeActivity.isAnySimInsert,mSubCount=" + mSubCount);
+        if (mSubCount > 0) {
+            return true;
+        }
+        return false;
+    }
+
+       private void updateSubInfoList() {
+           MmsLog.d(TAG, "updateSubInfoList mSubCount = " + mSubCount);
+           mSubIdList = SubscriptionManager.from(this).getActiveSubscriptionIdList();
+           if (mSubIdList != null) {
+               MmsLog.d(TAG, "updateSubInfoList is not null");
+               mSubCount = mSubIdList.length;
+           } else {
+                   MmsLog.d(TAG, "updateSubInfoList is null");
+                   mSubCount = 0;
+           }
+    }
+
+    private void updateCounter(CharSequence text, int start, int before, int count) {
+        MmsLog.d(TAG, "DialogModeActivity.updateCounter");
+
+        //int[] params = null;
+        //params = SmsMessage.calculateLength(text, false);
+        MmsLog.dpi(TAG, "mParams[0]" + mParams[0]);
+        MmsLog.dpi(TAG, "mParams[1]" + mParams[1]);
+        MmsLog.dpi(TAG, "mParams[2]" + mParams[2]);
+        MmsLog.dpi(TAG, "mParams[3]" + mParams[3]);
+        /*
+         * SmsMessage.calculateLength returns an int[4] with:
+         * int[0] being the number of SMS's required, int[1] the
+         * number of code units used, int[2] is the number of code
+         * units remaining until the next message. int[3] is the
+         * encoding type that should be used for the message.
+         */
+        if (mReachMax == true) {
+            mParams = SmsMessage.calculateLength(text, false);
+            mReachMax = false;
+
+        }
+        int msgCount = mParams[0];
+
+        int remainingInCurrentMessage = mParams[2];
+        //int unitesUsed = params[1];
+
+        // mWorkingMessage.setLengthRequiresMms(
+        // msgCount >= MmsConfig.getSmsToMmsTextThreshold(), true);
+        // Show the counter
+        // Update the remaining characters and number of messages required.
+        // if (mWorkingMessage.requiresMms()) {
+        // mTextCounter.setVisibility(View.GONE);
+        // } else {
+        // mTextCounter.setVisibility(View.VISIBLE);
+        // }
+
+
+        String counterText = remainingInCurrentMessage + "/" + msgCount;
+        MmsLog.dpi(TAG, "counterText=" + counterText);
+        mTextCounter.setText(counterText);
+        mOpDialogModeActivityExt.updateCounter(mTextCounter, mReplyEditor.getLineCount(),
+                remainingInCurrentMessage, msgCount, counterText);
+        // m1
+    }
+    /**
+    * This filter will constrain edits not to make the length of the text
+    * greater than the specified length.
+    */
+    class TextLengthFilter extends InputFilter.LengthFilter {
+        private final Toast mExceedMessageSizeToast;
+        private final int mMaxLength;
+        public TextLengthFilter(int max) {
+            super(max);
+            mMaxLength = max;
+            mExceedMessageSizeToast = Toast.makeText(DialogModeActivity.this,
+                R.string.exceed_message_size_limitation, Toast.LENGTH_SHORT);
+        }
+        public CharSequence filter(CharSequence source, int start, int end, Spanned dest,
+        int dstart, int dend) {
+            /// M: re-compute max sms number count
+            String text = "";
+            String destString = dest.toString();
+            String headString = destString.substring(0, dstart);
+            if (headString != null) {
+                text += headString;
+            }
+            String middleString = source.toString().substring(start, end);
+            if (middleString != null) {
+                text += middleString;
+            }
+            String tailString = destString.substring(dend);
+            if (tailString != null) {
+                text += tailString;
+            }
+            int page = mPage - 1;
+            int maxLength = mMaxLength;
+            // this function is for MO SMS
+
+            MmsLog.d(TAG, "filter is called");
+//            TextEncodingDetails ted = SmsManager.isImsSmsSupported() ?
+//                com.android.internal.telephony.cdma.SmsMessage.calculateLength(text, false) :
+//                com.android.internal.telephony.gsm.SmsMessage.calculateLength(text, false);
+//                TextEncodingDetails ted = com.android.internal.telephony.gsm.SmsMessage
+//            .calculateLength(text, false);
+            mParams  = SmsMessage.calculateLength(text, false);
+            MmsLog.dpi(TAG, "mParams[0]" + mParams[0]);
+            MmsLog.dpi(TAG, "mParams[1]" + mParams[1]);
+            MmsLog.dpi(TAG, "mParams[2]" + mParams[2]);
+            MmsLog.dpi(TAG, "mParams[3]" + mParams[3]);
+            ArrayList<String> list = SmsMessage.fragmentText(text);
+            if (list != null && list.size() > page) {
+                maxLength = 0;
+                for (int i = 0; i < page; i++) {
+                    maxLength += list.get(i).length();
+                }
+                MmsLog.d(TAG, "get maxLength:" + maxLength);
+            }
+            MmsLog.d(TAG, "maxLength:" + maxLength);
+            int keep = maxLength - (dest.length() - (dend - dstart));
+            if (keep < (end - start)) {
+                InputMethodManager mInputMethodManager
+                        = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                mExceedMessageSizeToast.show();
+                if (mInputMethodManager != null) {
+                    mInputMethodManager.restartInput(
+                            DialogModeActivity.this.getWindow().getCurrentFocus());
+                }
+                mReachMax = true;
+            }
+            if (keep <= 0) {
+                return "";
+            } else if (keep >= end - start) {
+                return null; // keep original
+            } else {
+                keep += start;
+                if (Character.isHighSurrogate(source.charAt(keep - 1))) {
+                    --keep;
+                    if (keep == start) {
+                        return "";
+                    }
+                }
+                return source.subSequence(start, keep);
+            }
+        }
+    }
+    private void markAsRead(final Uri uri) {
+        MmsLog.dpi(TAG, "DialogModeActivity.markAsRead, " + uri.toString());
+
+        new Thread(new Runnable() {
+            public void run() {
+                if (!mIpDialogModeActivity.markAsRead(getApplicationContext(), uri)) {
+                    final ContentValues values = new ContentValues(2);
+                    values.put("read", 1);
+                    values.put("seen", 1);
+                    SqliteWrapper.update(getApplicationContext(),
+                            getContentResolver(), uri, values,
+                            null, null);
+                    MessagingNotification.blockingUpdateNewMessageIndicator(
+                            DialogModeActivity.this,
+                            MessagingNotification.THREAD_NONE, false, uri);
+                }
+            }
+        }).start();
+        removeCurMsg();
+    }
+
+    private void markAsRead(final ArrayList<Uri> uris) {
+        final Object[] uriArray = uris.toArray();
+        new Thread(new Runnable() {
+            public void run() {
+                final ContentValues values = new ContentValues(2);
+                values.put("read", 1);
+                values.put("seen", 1);
+                for (Object uriObject : uriArray) {
+                    Uri uri = (Uri) uriObject;
+                    MmsLog.dpi(TAG, "markasread a:" + uri.toString());
+                    if (!mIpDialogModeActivity.markAsRead(getApplicationContext(), uri)) {
+                        SqliteWrapper.update(getApplicationContext(), getContentResolver(), uri,
+                                values, null, null);
+                        MessagingNotification.blockingUpdateNewMessageIndicator(
+                                DialogModeActivity.this,
+                                MessagingNotification.THREAD_NONE, false, uri);
+                    }
+                }
+        } }).start();
+    }
+
+    private void markAsSeen(final ArrayList<Uri> uris) {
+        final Object[] uriArray = uris.toArray();
+        new Thread(new Runnable() {
+            public void run() {
+                final ContentValues values = new ContentValues(2);
+                values.put("seen", 1);
+                for (Object uriObject : uriArray) {
+                    Uri uri = (Uri) uriObject;
+                    MmsLog.dpi(TAG, "markasseen a:" + uri.toString());
+                    SqliteWrapper.update(getApplicationContext(),
+                            getContentResolver(), uri, values, null, null);
+                }
+                ///M: [ALPS01486266] [KK][MT6592][SGLTE][SMS][Must Resolve]after view new message,
+                ///still show unread message notification
+                ///because composeMessageActivity also update notification
+                //MessagingNotification.blockingUpdateNewMessageIndicator(DialogModeActivity.this,
+                        //MessagingNotification.THREAD_NONE, false);
+            }
+        }).start();
+    }
+
+    public class DialogModeReceiver extends BroadcastReceiver {
+
+        private static final String MSG_VIEWED_ACTION = "com.android.mms.dialogmode.VIEWED";
+
+        public void onReceive(Context context, Intent intent) {
+            MmsLog.d(TAG, "DialogModeActivity.DialogModeReceiver.onReceive");
+
+            // TODO Auto-generated method stub
+            if (intent != null) {
+                String action = intent.getAction();
+                if (action == null) {
+                    return;
+                }
+                MmsLog.d(TAG, "action=" + action);
+                DialogModeActivity.this.finish();
+            }
+        }
+    }
+
+
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        MmsLog.d(TAG, "onStop()");
+        if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+            mSubSelectDialog.dismiss();
+        }
+        if (mNeedFinish) {
+            mNeedFinish = false;
+            finish();
+        }
+
+    }
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+    switch (keyCode) {
+        case KeyEvent.KEYCODE_HOME:
+            onClick(mCloseBtn);
+            break;
+        default:
+            break;
+    }
+    return super.onKeyDown(keyCode, event);
+
+}
+    @Override
+    public void onBackPressed() {
+        /// M: take press back just as press close button
+        onClick(mCloseBtn);
+    }
+
+    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+    private void setVcardOrVcalendar(SlideshowModel slideshow) {
+        if (slideshow == null || slideshow.getAttachFiles() == null
+                || slideshow.getAttachFiles().size() == 0) {
+               if (mMmsAttachView != null) {
+                    mMmsAttachView.setVisibility(View.GONE);
+                }
+                if (mMmsView != null) {
+                    mMmsView.setVisibility(View.GONE);
+                }
+            return;
+        }
+        FileAttachmentModel attach = slideshow.getAttachFiles().get(0);
+        String contentType = attach.getContentType();
+        String src = attach.getSrc();
+        long size = attach.getAttachSize();
+        if (contentType.equalsIgnoreCase(MmsContentType.TEXT_VCARD)
+                || contentType.equalsIgnoreCase(MmsContentType.TEXT_VCALENDAR)) {
+            mMmsAttachView.setVisibility(View.VISIBLE);
+            MmsLog.d(TAG, "set vcard or vcarlendar to mMmsImageView");
+            String nameText = "";
+            if (contentType.equalsIgnoreCase(MmsContentType.TEXT_VCARD)) {
+                mMmsAttachImageView.setImageResource(R.drawable.ic_vcard_attach);
+                nameText = getResources().getString(R.string.file_attachment_vcard_name, src);
+            } else {
+                mMmsAttachImageView.setImageResource(R.drawable.ic_vcalendar_attach);
+                nameText = getResources().getString(R.string.file_attachment_vcalendar_name, src);
+            }
+            mAttachName.setText(nameText);
+            mAttachSize.setText(MessageUtils.getHumanReadableSize(size));
+            setSmsContentTextView();
+        }
+    }
+
+    private void setSmsContentTextView() {
+        if (mSmsContentText != null) {
+            CharSequence contentString = mSmsContentText.getText();
+            if (contentString == null || contentString.toString().trim().length() == 0) {
+                mSmsContentText.setVisibility(View.GONE);
+            }
+        }
+    }
+    /// @}
+
+    /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+    private String interpretFrom(EncodedStringValue from, Uri messageUri) {
+        String address;
+        if (from != null) {
+            address = from.getString();
+        } else {
+            address = AddressUtils.getFrom(DialogModeActivity.this, messageUri);
+        }
+        String contact = TextUtils.isEmpty(address) ?
+                            DialogModeActivity.this.getString(android.R.string.unknownName)
+                            : Contact.get(address, false).getName();
+        return contact;
+    }
+
+    /// M: fix bug ALPS00517135, update sim state dynamically. @{
+    private Handler mSimHanlder = new Handler();
+    private BroadcastReceiver mSimReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            mOpDialogModeActivityExt.onReceive(context, intent);
+            String action = intent.getAction();
+            MmsLog.d(TAG, "onReceive action = " + action);
+            if (action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED)) {
+                if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+                    mSubSelectDialog.dismiss();
+                }
+                updateSubInfoList();
+                updateSendButtonState();
+            }
+        }
+    };
+    /// @}
+
+    // Add for IpMessage callback
+
+    public int getCurUriIdx() {
+        return mCurUriIdx;
+    }
+
+    public void setCurUriIdx(int curUriIdx, Uri curUri) {
+        mCurUri = curUri;
+        mCurUriIdx = curUriIdx;
+    }
+
+    public void onPreMessageSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onPreMessageSent");
+        runOnUiThread(mResetMessageRunnable);
+    }
+
+    public void onMessageSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onMessageSent");
+        mWaitingForSendMessage = false;
+        runOnUiThread(mMessageSentRunnable);
+    }
+
+    public String getNumber() {
+        Conversation conv = getConversation();
+        if (conv != null) {
+            String num = conv.getRecipients().get(0).getNumber();
+            return num;
+        }
+        return null;
+    }
+
+    public String getName() {
+        Conversation conv = getConversation();
+        if (conv != null) {
+            String nam = conv.getRecipients().get(0).getName();
+            return nam;
+        }
+        return null;
+    }
+
+    public long getIpThreadId() {
+        return getThreadId();
+    }
+
+    public void markIpAsRead(final Uri uri) {
+        markAsRead(uri);
+    }
+
+    public void onIpSubSelection() {
+        simSelection();
+    }
+
+    public int getIpSelectedId() {
+        return (int) mSelectedSubId;
+    }
+
+    public void setIpSelectedSubId(int selectedSubId) {
+        mSelectedSubId = selectedSubId;
+    }
+
+    public void onIpConfirmSendMessageIfNeeded() {
+        confirmSendMessageIfNeeded();
+    }
+
+    public void onIpShowSubSelectedDialog(boolean overridePref , Intent intent) {
+        showSubSelectedDialog(overridePref, intent);
+    }
+
+    public void onIpUpdateSendButtonState() {
+        updateSendButtonState();
+    }
+
+    // add for op callback
+    @Override
+    public void opSetSelectedSubId(int subId) {
+        mSelectedSubId = subId;
+    }
+
+    @Override
+    public void opConfirmSendMessageIfNeeded() {
+        confirmSendMessageIfNeeded();
+    }
+
+    public Uri opGetCurUri() {
+        return mCurUri;
+    }
+
+    public long opGetThreadId() {
+        return getThreadId();
+    }
+
+    public int opGetCurrentSubId() {
+        return getCurrentSubId();
+    }
+}
Index: vendor/branch/5058Y_EMEA/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java
===================================================================
--- vendor/branch/5058Y_EMEA/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java	(revision 0)
+++ vendor/branch/5058Y_EMEA/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java	(revision 2619)
@@ -0,0 +1,3179 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+import android.app.ActivityThread;
+import android.app.PendingIntent;
+import android.content.ActivityNotFoundException;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.BaseBundle;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+// MTK-START
+import android.os.SystemProperties;
+// MTK-END
+import android.text.TextUtils;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import com.android.internal.telephony.IMms;
+import com.android.internal.telephony.ISms;
+import com.android.internal.telephony.SmsRawData;
+import com.android.internal.telephony.uicc.IccConstants;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+// MTK-START
+import android.app.PendingIntent.CanceledException;
+import com.android.internal.telephony.PhoneConstants;
+import com.mediatek.common.MPlugin;
+// For 4G data only, this class will check 4G data only and prompt to user
+import com.mediatek.common.sms.IDataOnlySmsFwkExt;
+// MTK_ONLY_OWNER_SIM_SUPPORT
+import com.mediatek.common.telephony.IOnlyOwnerSimSupport;
+
+import com.mediatek.internal.telephony.IccSmsStorageStatus;
+// Cell broadcast new interface
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.mediatek.internal.telephony.SmsCbConfigInfo;
+import com.android.internal.telephony.SmsConstants;
+// MTK-END
+
+/*
+ * TODO(code review): Curious question... Why are a lot of these
+ * methods not declared as static, since they do not seem to require
+ * any local object state?  Presumably this cannot be changed without
+ * interfering with the API...
+ */
+
+/**
+ * Manages SMS operations such as sending data, text, and pdu SMS messages.
+ * Get this object by calling the static method {@link #getDefault()}.
+ *
+ * <p>For information about how to behave as the default SMS app on Android 4.4 (API level 19)
+ * and higher, see {@link android.provider.Telephony}.
+ */
+public final class SmsManager {
+    private static final String TAG = "SmsManager";
+    /**
+     * A psuedo-subId that represents the default subId at any given time. The actual subId it
+     * represents changes as the default subId is changed.
+     */
+    private static final int DEFAULT_SUBSCRIPTION_ID = -1002;
+
+    /** Singleton object constructed during class initialization. */
+    private static final SmsManager sInstance = new SmsManager(DEFAULT_SUBSCRIPTION_ID);
+    private static final Object sLockObject = new Object();
+
+    /** @hide */
+    public static final int CELL_BROADCAST_RAN_TYPE_GSM = 0;
+    /** @hide */
+    public static final int CELL_BROADCAST_RAN_TYPE_CDMA = 1;
+
+    private static final Map<Integer, SmsManager> sSubInstances =
+            new ArrayMap<Integer, SmsManager>();
+
+    /** A concrete subscription id, or the pseudo DEFAULT_SUBSCRIPTION_ID */
+    private int mSubId;
+
+    /*
+     * Key for the various carrier-dependent configuration values.
+     * Some of the values are used by the system in processing SMS or MMS messages. Others
+     * are provided for the convenience of SMS applications.
+     */
+
+    /**
+     * Whether to append transaction id to MMS WAP Push M-Notification.ind's content location URI
+     * when constructing the download URL of a new MMS (boolean type)
+     */
+    public static final String MMS_CONFIG_APPEND_TRANSACTION_ID =
+            CarrierConfigManager.KEY_MMS_APPEND_TRANSACTION_ID_BOOL;
+    /**
+     * Whether MMS is enabled for the current carrier (boolean type)
+     */
+    public static final String
+        MMS_CONFIG_MMS_ENABLED = CarrierConfigManager.KEY_MMS_MMS_ENABLED_BOOL;
+    /**
+     * Whether group MMS is enabled for the current carrier (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_GROUP_MMS_ENABLED = CarrierConfigManager.KEY_MMS_GROUP_MMS_ENABLED_BOOL;
+    /**
+     * If this is enabled, M-NotifyResp.ind should be sent to the WAP Push content location instead
+     * of the default MMSC (boolean type)
+     */
+    public static final String MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED =
+            CarrierConfigManager.KEY_MMS_NOTIFY_WAP_MMSC_ENABLED_BOOL;
+    /**
+     * Whether alias is enabled (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_ENABLED = CarrierConfigManager.KEY_MMS_ALIAS_ENABLED_BOOL;
+    /**
+     * Whether audio is allowed to be attached for MMS messages (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_ALLOW_ATTACH_AUDIO = CarrierConfigManager.KEY_MMS_ALLOW_ATTACH_AUDIO_BOOL;
+    /**
+     * Whether multipart SMS is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MULTIPART_SMS_ENABLED =
+            CarrierConfigManager.KEY_MMS_MULTIPART_SMS_ENABLED_BOOL;
+    /**
+     * Whether SMS delivery report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_SMS_DELIVERY_REPORT_ENABLED_BOOL;
+    /**
+     * Whether content-disposition field should be expected in an MMS PDU (boolean type)
+     */
+    public static final String MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION =
+            CarrierConfigManager.KEY_MMS_SUPPORT_MMS_CONTENT_DISPOSITION_BOOL;
+    /**
+     * Whether multipart SMS should be sent as separate messages
+     */
+    public static final String MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES =
+            CarrierConfigManager.KEY_MMS_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES_BOOL;
+    /**
+     * Whether MMS read report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MMS_READ_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_MMS_READ_REPORT_ENABLED_BOOL;
+    /**
+     * Whether MMS delivery report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_MMS_DELIVERY_REPORT_ENABLED_BOOL;
+    /**
+     * Max MMS message size in bytes (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_MESSAGE_SIZE = CarrierConfigManager.KEY_MMS_MAX_MESSAGE_SIZE_INT;
+    /**
+     * Max MMS image width (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_IMAGE_WIDTH = CarrierConfigManager.KEY_MMS_MAX_IMAGE_WIDTH_INT;
+    /**
+     * Max MMS image height (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_IMAGE_HEIGHT = CarrierConfigManager.KEY_MMS_MAX_IMAGE_HEIGHT_INT;
+    /**
+     * Limit of recipients of MMS messages (int type)
+     */
+    public static final String
+            MMS_CONFIG_RECIPIENT_LIMIT = CarrierConfigManager.KEY_MMS_RECIPIENT_LIMIT_INT;
+    /**
+     * Min alias character count (int type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_MIN_CHARS = CarrierConfigManager.KEY_MMS_ALIAS_MIN_CHARS_INT;
+    /**
+     * Max alias character count (int type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_MAX_CHARS = CarrierConfigManager.KEY_MMS_ALIAS_MAX_CHARS_INT;
+    /**
+     * When the number of parts of a multipart SMS reaches this threshold, it should be converted
+     * into an MMS (int type)
+     */
+    public static final String MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD =
+            CarrierConfigManager.KEY_MMS_SMS_TO_MMS_TEXT_THRESHOLD_INT;
+    /**
+     * Some carriers require SMS to be converted into MMS when text length reaches this threshold
+     * (int type)
+     */
+    public static final String MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD =
+            CarrierConfigManager.KEY_MMS_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD_INT;
+    /**
+     * Max message text size (int type)
+     */
+    public static final String MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE =
+            CarrierConfigManager.KEY_MMS_MESSAGE_TEXT_MAX_SIZE_INT;
+    /**
+     * Max message subject length (int type)
+     */
+    public static final String
+            MMS_CONFIG_SUBJECT_MAX_LENGTH = CarrierConfigManager.KEY_MMS_SUBJECT_MAX_LENGTH_INT;
+    /**
+     * MMS HTTP socket timeout in milliseconds (int type)
+     */
+    public static final String
+            MMS_CONFIG_HTTP_SOCKET_TIMEOUT = CarrierConfigManager.KEY_MMS_HTTP_SOCKET_TIMEOUT_INT;
+    /**
+     * The name of the UA Prof URL HTTP header for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_UA_PROF_TAG_NAME = CarrierConfigManager.KEY_MMS_UA_PROF_TAG_NAME_STRING;
+    /**
+     * The User-Agent header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_USER_AGENT = CarrierConfigManager.KEY_MMS_USER_AGENT_STRING;
+    /**
+     * The UA Profile URL header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_UA_PROF_URL = CarrierConfigManager.KEY_MMS_UA_PROF_URL_STRING;
+    /**
+     * A list of HTTP headers to add to MMS HTTP request, separated by "|" (String type)
+     */
+    public static final String
+            MMS_CONFIG_HTTP_PARAMS = CarrierConfigManager.KEY_MMS_HTTP_PARAMS_STRING;
+    /**
+     * Email gateway number (String type)
+     */
+    public static final String MMS_CONFIG_EMAIL_GATEWAY_NUMBER =
+            CarrierConfigManager.KEY_MMS_EMAIL_GATEWAY_NUMBER_STRING;
+    /**
+     * The suffix to append to the NAI header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_NAI_SUFFIX = CarrierConfigManager.KEY_MMS_NAI_SUFFIX_STRING;
+    /**
+     * If true, show the cell broadcast (amber alert) in the SMS settings. Some carriers don't want
+     * this shown. (Boolean type)
+     */
+    public static final String MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS =
+            CarrierConfigManager.KEY_MMS_SHOW_CELL_BROADCAST_APP_LINKS_BOOL;
+    /**
+     * Whether the carrier MMSC supports charset field in Content-Type header. If this is false,
+     * then we don't add "charset" to "Content-Type"
+     */
+    public static final String MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER =
+            CarrierConfigManager.KEY_MMS_SUPPORT_HTTP_CHARSET_HEADER_BOOL;
+    /**
+     * If true, add "Connection: close" header to MMS HTTP requests so the connection
+     * is immediately closed (disabling keep-alive). (Boolean type)
+     * @hide
+     */
+    public static final String MMS_CONFIG_CLOSE_CONNECTION =
+            CarrierConfigManager.KEY_MMS_CLOSE_CONNECTION_BOOL;
+
+    /*
+     * Forwarded constants from SimDialogActivity.
+     */
+    private static String DIALOG_TYPE_KEY = "dialog_type";
+    private static final int SMS_PICK = 2;
+
+    // MTK-START
+    /** Tablet Multi-user feature */
+    private IOnlyOwnerSimSupport mOnlyOwnerSimSupport = null;
+
+    /** 4G data only feature */
+    private IDataOnlySmsFwkExt mDataOnlySmsFwkExt = null;
+
+    private static boolean DBG = SystemProperties.get("ro.build.type").equals("eng");
+    // MTK-END
+
+    /**
+     * Send a text based SMS.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
+     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
+     * writes messages sent using this method to the SMS Provider (the default SMS app is always
+     * responsible for writing its sent messages to the SMS Provider). For information about
+     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
+     *
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param text the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or text are empty
+     */
+    public void sendTextMessage(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        sendTextMessageInternal(destinationAddress, scAddress, text,
+            sentIntent, deliveryIntent, true /* persistMessageForCarrierApp*/);
+    }
+
+    private void sendTextMessageInternal(String destinationAddress, String scAddress,
+            String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
+            boolean persistMessageForCarrierApp) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        // MTK-START
+        // Support empty content
+        //if (TextUtils.isEmpty(text)) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+        Rlog.d(TAG, "sendTextMessage, text=" + ((DBG == true)? text : "") +
+                ", destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, text, sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(),
+                    destinationAddress,
+                    scAddress, text, sentIntent, deliveryIntent,
+                    persistMessageForCarrierApp);
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "sendTextMessage, RemoteException!");
+            // MTK-END
+        }
+    }
+
+    /**
+     * Send a text based SMS without writing it into the SMS Provider.
+     *
+     * <p>Only the carrier app can call this method.</p>
+     *
+     * @see #sendTextMessage(String, String, String, PendingIntent, PendingIntent)
+     * @hide
+     */
+    public void sendTextMessageWithoutPersisting(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        sendTextMessageInternal(destinationAddress, scAddress, text,
+            sentIntent, deliveryIntent, false /* persistMessageForCarrierApp*/);
+    }
+
+    /**
+     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
+     * for internal use only.
+     *
+     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
+     * the Phone process if set to false.
+     *
+     * @hide
+     */
+    public void sendTextMessageWithSelfPermissions(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        // MTK-START
+        // Support empty content
+        //if (TextUtils.isEmpty(text)) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+        Rlog.d(TAG, "sendTextMessage, text=" + ((DBG == true)? text : "") +
+                ", destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, text, sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
+                    ActivityThread.currentPackageName(),
+                    destinationAddress,
+                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Inject an SMS PDU into the android application framework.
+     *
+     * The caller should have carrier privileges.
+     * @see android.telephony.TelephonyManager#hasCarrierPrivileges
+     *
+     * @param pdu is the byte array of pdu to be injected into android application framework
+     * @param format is the format of SMS pdu (3gpp or 3gpp2)
+     * @param receivedIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully received by the
+     *  android application framework, or failed. This intent is broadcasted at
+     *  the same time an SMS received from radio is acknowledged back.
+     *  The result code will be <code>RESULT_SMS_HANDLED</code> for success, or
+     *  <code>RESULT_SMS_GENERIC_ERROR</code> for error.
+     *
+     * @throws IllegalArgumentException if format is not one of 3gpp and 3gpp2.
+     */
+    public void injectSmsPdu(byte[] pdu, String format, PendingIntent receivedIntent) {
+        if (!format.equals(SmsMessage.FORMAT_3GPP) && !format.equals(SmsMessage.FORMAT_3GPP2)) {
+            // Format must be either 3gpp or 3gpp2.
+            throw new IllegalArgumentException(
+                    "Invalid pdu format. format must be either 3gpp or 3gpp2");
+        }
+        try {
+            ISms iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            if (iccISms != null) {
+                iccISms.injectSmsPduForSubscriber(
+                        getSubscriptionId(), pdu, format, receivedIntent);
+            }
+        } catch (RemoteException ex) {
+          // ignore it
+        }
+    }
+
+    /**
+     * Divide a message text into several fragments, none bigger than
+     * the maximum SMS message size.
+     *
+     * @param text the original message.  Must not be null.
+     * @return an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     *
+     * @throws IllegalArgumentException if text is null
+     */
+    public ArrayList<String> divideMessage(String text) {
+        if (null == text) {
+            throw new IllegalArgumentException("text is null");
+        }
+        return SmsMessage.fragmentText(text);
+    }
+
+    /**
+     * Send a multi-part text based SMS.  The callee should have already
+     * divided the message into correctly sized parts by calling
+     * <code>divideMessage</code>.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
+     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
+     * writes messages sent using this method to the SMS Provider (the default SMS app is always
+     * responsible for writing its sent messages to the SMS Provider). For information about
+     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK</code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applications,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     */
+    public void sendMultipartTextMessage(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        sendMultipartTextMessageInternal(destinationAddress, scAddress, parts,
+              sentIntents, deliveryIntents, true /* persistMessageForCarrierApp*/);
+    }
+
+    private void sendMultipartTextMessageInternal(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents,
+            boolean persistMessageForCarrierApp) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+        // MTK-START
+        // Support empty content
+        //if (parts == null || parts.size() < 1) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+
+        Rlog.d(TAG, "sendMultipartTextMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, parts, sentIntents)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                iccISms.sendMultipartTextForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        destinationAddress, scAddress, parts,
+                        sentIntents, deliveryIntents, persistMessageForCarrierApp);
+            } catch (RemoteException ex) {
+                // ignore it
+                // MTK-START
+                Rlog.d(TAG, "sendMultipartTextMessage, RemoteException!");
+                // MTK-END
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+            // MTK-START
+            // If content is null, pass the empty string
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            sendTextMessage(destinationAddress, scAddress, text,
+                    sentIntent, deliveryIntent);
+            // MTK-END
+        }
+    }
+
+    /**
+     * Send a multi-part text based SMS without writing it into the SMS Provider.
+     *
+     * <p>Only the carrier app can call this method.</p>
+     *
+     * @see #sendMultipartTextMessage(String, String, ArrayList, ArrayList, ArrayList)
+     * @hide
+     **/
+    public void sendMultipartTextMessageWithoutPersisting(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        sendMultipartTextMessageInternal(destinationAddress, scAddress, parts,
+            sentIntents, deliveryIntents, false /* persistMessageForCarrierApp*/);
+    }
+
+    /**
+     * Send a data based SMS to a specific application port.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param destinationPort the port to deliver the message to
+     * @param data the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     */
+    public void sendDataMessage(
+            String destinationAddress, String scAddress, short destinationPort,
+            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendDataForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(),
+                    destinationAddress, scAddress, destinationPort & 0xFFFF,
+                    data, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "sendDataMessage, RemoteException!");
+            // MTK-END
+        }
+    }
+
+    /**
+     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
+     * for internal use only.
+     *
+     * @hide
+     */
+    public void sendDataMessageWithSelfPermissions(
+            String destinationAddress, String scAddress, short destinationPort,
+            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(1);
+        sentIntents.add(sentIntent);
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
+                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
+                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+
+
+    /**
+     * Get the SmsManager associated with the default subscription id. The instance will always be
+     * associated with the default subscription id, even if the default subscription id is changed.
+     *
+     * @return the SmsManager associated with the default subscription id
+     */
+    public static SmsManager getDefault() {
+        return sInstance;
+    }
+
+    /**
+     * Get the the instance of the SmsManager associated with a particular subscription id
+     *
+     * @param subId an SMS subscription id, typically accessed using
+     *   {@link android.telephony.SubscriptionManager}
+     * @return the instance of the SmsManager associated with subId
+     */
+    public static SmsManager getSmsManagerForSubscriptionId(int subId) {
+        // TODO(shri): Add javadoc link once SubscriptionManager is made public api
+        synchronized(sLockObject) {
+            SmsManager smsManager = sSubInstances.get(subId);
+            if (smsManager == null) {
+                smsManager = new SmsManager(subId);
+                sSubInstances.put(subId, smsManager);
+            }
+            return smsManager;
+        }
+    }
+
+    private SmsManager(int subId) {
+        mSubId = subId;
+
+        // MTK-START
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            /** Tablet Multi-user feature */
+            try {
+                mOnlyOwnerSimSupport = MPlugin.createInstance(IOnlyOwnerSimSupport.class.getName());
+                if (mOnlyOwnerSimSupport != null) {
+                    String actualClassName = mOnlyOwnerSimSupport.getClass().getName();
+                    Rlog.d(TAG, "initial mOnlyOwnerSimSupport done, actual class name is " +
+                            actualClassName);
+                } else {
+                    Rlog.e(TAG, "FAIL! intial mOnlyOwnerSimSupport");
+                }
+            } catch (RuntimeException e) {
+                Rlog.e(TAG, "FAIL! No IOnlyOwnerSimSupport");
+            }
+
+            /** 4G data only feature */
+            try {
+                mDataOnlySmsFwkExt = MPlugin.createInstance(IDataOnlySmsFwkExt.class.getName());
+                if (mDataOnlySmsFwkExt != null) {
+                    String className = mDataOnlySmsFwkExt.getClass().getName();
+                    Rlog.d(TAG, "initial mDataOnlySmsFwkExt done, class name is " + className);
+                } else {
+                    Rlog.e(TAG, "FAIL! intial mDataOnlySmsFwkExt");
+                }
+            } catch (RuntimeException e) {
+                Rlog.e(TAG, "FAIL! No mDataOnlySmsFwkExt");
+            }
+        }
+        // MTK-END
+    }
+
+    /**
+     * Get the associated subscription id. If the instance was returned by {@link #getDefault()},
+     * then this method may return different values at different points in time (if the user
+     * changes the default subscription id). It will return < 0 if the default subscription id
+     * cannot be determined.
+     *
+     * Additionally, to support legacy applications that are not multi-SIM aware,
+     * if the following are true:
+     *     - We are using a multi-SIM device
+     *     - A default SMS SIM has not been selected
+     *     - At least one SIM subscription is available
+     * then ask the user to set the default SMS SIM.
+     *
+     * @return associated subscription id
+     */
+    public int getSubscriptionId() {
+        final int subId = (mSubId == DEFAULT_SUBSCRIPTION_ID)
+                ? getDefaultSmsSubscriptionId() : mSubId;
+        boolean isSmsSimPickActivityNeeded = false;
+        final Context context = ActivityThread.currentApplication().getApplicationContext();
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                isSmsSimPickActivityNeeded = iccISms.isSmsSimPickActivityNeeded(subId);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "Exception in getSubscriptionId");
+        }
+
+        // MTK-START
+        // Mark since MTK have another SIM Card selection logic
+        isSmsSimPickActivityNeeded = false;
+        // MTK-END
+        if (isSmsSimPickActivityNeeded) {
+            Log.d(TAG, "getSubscriptionId isSmsSimPickActivityNeeded is true");
+            // ask the user for a default SMS SIM.
+            Intent intent = new Intent();
+            intent.setClassName("com.android.settings",
+                    "com.android.settings.sim.SimDialogActivity");
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
+            try {
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException anfe) {
+                // If Settings is not installed, only log the error as we do not want to break
+                // legacy applications.
+                Log.e(TAG, "Unable to launch Settings application.");
+            }
+        }
+
+        return subId;
+    }
+
+    /**
+     * Returns the ISms service, or throws an UnsupportedOperationException if
+     * the service does not exist.
+     */
+    private static ISms getISmsServiceOrThrow() {
+        ISms iccISms = getISmsService();
+        if (iccISms == null) {
+            throw new UnsupportedOperationException("Sms is not supported");
+        }
+        return iccISms;
+    }
+
+    private static ISms getISmsService() {
+        return ISms.Stub.asInterface(ServiceManager.getService("isms"));
+    }
+
+    /**
+     * Copy a raw SMS PDU to the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param smsc the SMSC for this message, or NULL for the default SMSC
+     * @param pdu the raw PDU to store
+     * @param status message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *               STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @return true for success
+     *
+     * @throws IllegalArgumentException if pdu is NULL
+     * {@hide}
+     */
+    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
+        // MTK-START
+        Rlog.d(TAG, "copyMessageToIcc");
+        // MTK-END
+        boolean success = false;
+        // MTK-START
+        SimSmsInsertStatus smsStatus = null;
+        // MTK-END
+
+        if (null == pdu) {
+            throw new IllegalArgumentException("pdu is NULL");
+        }
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.copyMessageToIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        status, pdu, smsc);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Delete the specified message from the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param messageIndex is the record index of the message on ICC
+     * @return true for success
+     *
+     * {@hide}
+     */
+    public boolean
+    deleteMessageFromIcc(int messageIndex) {
+        // MTK-START
+        Rlog.d(TAG, "deleteMessageFromIcc, messageIndex=" + messageIndex);
+        // MTK-END
+        boolean success = false;
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+        // MTK-END
+
+        byte[] pdu = new byte[IccConstants.SMS_RECORD_LENGTH-1];
+        Arrays.fill(pdu, (byte)0xff);
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.updateMessageOnIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        messageIndex, STATUS_ON_ICC_FREE, pdu);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "deleteMessageFromIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return success;
+    }
+
+    /**
+     * Update the specified message on the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param messageIndex record index of message to update
+     * @param newStatus new message status (STATUS_ON_ICC_READ,
+     *                  STATUS_ON_ICC_UNREAD, STATUS_ON_ICC_SENT,
+     *                  STATUS_ON_ICC_UNSENT, STATUS_ON_ICC_FREE)
+     * @param pdu the raw PDU to store
+     * @return true for success
+     *
+     * {@hide}
+     */
+    public boolean updateMessageOnIcc(int messageIndex, int newStatus, byte[] pdu) {
+        // MTK-START
+        Rlog.d(TAG, "updateMessageOnIcc, messageIndex=" + messageIndex);
+        // MTK-END
+        boolean success = false;
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false ;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.updateMessageOnIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        messageIndex, newStatus, pdu);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "updateMessageOnIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return success;
+    }
+
+    /**
+     * Retrieves all messages currently stored on ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects
+     *
+     * {@hide}
+     */
+    public ArrayList<SmsMessage> getAllMessagesFromIcc() {
+        // MTK-START
+        Rlog.d(TAG, "getAllMessagesFromIcc");
+        // MTK-END
+        List<SmsRawData> records = null;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                records = iccISms.getAllMessagesFromIccEfForSubscriber(
+                        getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "getAllMessagesFromIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return createMessageListFromRawRecords(records);
+    }
+
+    /**
+     * Enable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA).Note that if two different clients
+     * enable the same message identifier, they must both disable it for the device to stop
+     * receiving those messages. All received messages will be broadcast in an
+     * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     * @see #disableCellBroadcast(int, int)
+     *
+     * {@hide}
+     */
+    public boolean enableCellBroadcast(int messageIdentifier, int ranType) {
+        boolean success = false;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.enableCellBroadcastForSubscriber(
+                        getSubscriptionId(), messageIdentifier, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Disable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different clients
+     * enable the same message identifier, they must both disable it for the
+     * device to stop receiving those messages.
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     *
+     * @see #enableCellBroadcast(int, int)
+     *
+     * {@hide}
+     */
+    public boolean disableCellBroadcast(int messageIdentifier, int ranType) {
+        boolean success = false;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.disableCellBroadcastForSubscriber(
+                        getSubscriptionId(), messageIdentifier, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Enable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier range and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different clients enable
+     * the same message identifier, they must both disable it for the device to stop
+     * receiving those messages. All received messages will be broadcast in an
+     * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     * @see #disableCellBroadcastRange(int, int, int)
+     *
+     * @throws IllegalArgumentException if endMessageId < startMessageId
+     * {@hide}
+     */
+    public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
+        boolean success = false;
+
+        if (endMessageId < startMessageId) {
+            throw new IllegalArgumentException("endMessageId < startMessageId");
+        }
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.enableCellBroadcastRangeForSubscriber(getSubscriptionId(),
+                        startMessageId, endMessageId, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Disable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier range and RAN type. The RAN type specify this message
+     * ID range belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different
+     * clients enable the same message identifier, they must both disable it for
+     * the device to stop receiving those messages.
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     *
+     * @see #enableCellBroadcastRange(int, int, int)
+     *
+     * @throws IllegalArgumentException if endMessageId < startMessageId
+     * {@hide}
+     */
+    public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
+        boolean success = false;
+
+        if (endMessageId < startMessageId) {
+            throw new IllegalArgumentException("endMessageId < startMessageId");
+        }
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.disableCellBroadcastRangeForSubscriber(getSubscriptionId(),
+                        startMessageId, endMessageId, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Create a list of <code>SmsMessage</code>s from a list of RawSmsData
+     * records returned by <code>getAllMessagesFromIcc()</code>
+     *
+     * @param records SMS EF records, returned by
+     *   <code>getAllMessagesFromIcc</code>
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.
+     */
+    // MTK-START
+    private ArrayList<SmsMessage> createMessageListFromRawRecords(List<SmsRawData> records) {
+    // MTK-END
+        ArrayList<SmsMessage> messages = new ArrayList<SmsMessage>();
+        // MTK-START
+        Rlog.d(TAG, "createMessageListFromRawRecords");
+        // MTK-END
+        if (records != null) {
+            int count = records.size();
+            for (int i = 0; i < count; i++) {
+                SmsRawData data = records.get(i);
+                // List contains all records, including "free" records (null)
+                if (data != null) {
+                    // MTK-START
+                    int activePhone = TelephonyManager.getDefault().getCurrentPhoneType(mSubId);
+                    String phoneType = (PhoneConstants.PHONE_TYPE_CDMA == activePhone)
+                            ? SmsConstants.FORMAT_3GPP2 : SmsConstants.FORMAT_3GPP;
+                    Rlog.d(TAG, "phoneType: " + phoneType);
+                    SmsMessage sms = SmsMessage.createFromEfRecord(i + 1, data.getBytes(),
+                            phoneType);
+                    //SmsMessage sms = SmsMessage.createFromEfRecord(i+1, data.getBytes());
+                    // MTK-END
+                    if (sms != null) {
+                        messages.add(sms);
+                    }
+                }
+            }
+            // MTK-START
+            Rlog.d(TAG, "actual sms count is " + count);
+            // MTK-END
+        // MTK-START
+        } else {
+            Rlog.d(TAG, "fail to parse SIM sms, records is null");
+        }
+        // MTK-END
+
+        return messages;
+    }
+
+    /**
+     * SMS over IMS is supported if IMS is registered and SMS is supported
+     * on IMS.
+     *
+     * @return true if SMS over IMS is supported, false otherwise
+     *
+     * @see #getImsSmsFormat()
+     *
+     * @hide
+     */
+    public boolean isImsSmsSupported() {
+        boolean boSupported = false;
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                boSupported = iccISms.isImsSmsSupportedForSubscriber(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return boSupported;
+    }
+
+    /**
+     * Gets SMS format supported on IMS.  SMS over IMS format is
+     * either 3GPP or 3GPP2.
+     *
+     * @return SmsMessage.FORMAT_3GPP,
+     *         SmsMessage.FORMAT_3GPP2
+     *      or SmsMessage.FORMAT_UNKNOWN
+     *
+     * @see #isImsSmsSupported()
+     *
+     * @hide
+     */
+    public String getImsSmsFormat() {
+        String format = com.android.internal.telephony.SmsConstants.FORMAT_UNKNOWN;
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                format = iccISms.getImsSmsFormatForSubscriber(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return format;
+    }
+
+    /**
+     * Get default sms subscription id
+     *
+     * @return the default SMS subscription id
+     */
+    public static int getDefaultSmsSubscriptionId() {
+        ISms iccISms = null;
+        try {
+            iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            return iccISms.getPreferredSmsSubscription();
+        } catch (RemoteException ex) {
+            return -1;
+        } catch (NullPointerException ex) {
+            return -1;
+        }
+    }
+
+    /**
+     * Get SMS prompt property,  enabled or not
+     *
+     * @return true if enabled, false otherwise
+     * @hide
+     */
+    public boolean isSMSPromptEnabled() {
+        ISms iccISms = null;
+        try {
+            iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            return iccISms.isSMSPromptEnabled();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    // see SmsMessage.getStatusOnIcc
+
+    /** Free space (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_FREE      = 0;
+
+    /** Received and read (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_READ      = 1;
+
+    /** Received and unread (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_UNREAD    = 3;
+
+    /** Stored and sent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_SENT      = 5;
+
+    /** Stored and unsent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_UNSENT    = 7;
+
+    // SMS send failure result codes
+
+    /** Generic failure cause */
+    static public final int RESULT_ERROR_GENERIC_FAILURE    = 1;
+    /** Failed because radio was explicitly turned off */
+    static public final int RESULT_ERROR_RADIO_OFF          = 2;
+    /** Failed because no pdu provided */
+    static public final int RESULT_ERROR_NULL_PDU           = 3;
+    /** Failed because service is currently unavailable */
+    static public final int RESULT_ERROR_NO_SERVICE         = 4;
+    /** Failed because we reached the sending queue limit.  {@hide} */
+    static public final int RESULT_ERROR_LIMIT_EXCEEDED     = 5;
+    /** Failed because FDN is enabled. {@hide} */
+    static public final int RESULT_ERROR_FDN_CHECK_FAILURE  = 6;
+
+    static private final String PHONE_PACKAGE_NAME = "com.android.phone";
+
+    // MTK-START
+    /**
+     * Sucessful error code.
+     *
+     * @internal
+     * @hide
+     */
+    static public final int RESULT_ERROR_SUCCESS = 0;
+    /**
+     * Failed because sim memory is full.
+     *
+     * @internal
+     * @hide
+     */
+    static public final int RESULT_ERROR_SIM_MEM_FULL = 7;
+    /** @hide */
+    static public final int RESULT_ERROR_INVALID_ADDRESS = 8;
+
+    // for SMS validity period feature
+    /**
+     * Support to change the validity period.
+     * Extra parameter on bundle for validity period.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String EXTRA_PARAMS_VALIDITY_PERIOD = "validity_period";
+
+    /** @hide */
+    public static final String EXTRA_PARAMS_ENCODING_TYPE = "encoding_type";
+
+    /**
+     * Support to change the validity period.
+     * The value of no duration.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_NO_DURATION = -1;
+
+    /**
+     * Support to change the validity period.
+     * The value of one hour.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_ONE_HOUR = 11; // (VP + 1) * 5 = 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of six hours.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_SIX_HOURS = 71; // (VP + 1) * 5 = 6 * 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of twelve hours.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_TWELVE_HOURS = 143; // (VP + 1) * 5 = 12 * 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of one day.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_ONE_DAY = 167; // 12 + (VP - 143) * 30 Mins = 24 Hours
+
+    /**
+     * Support to change the validity period.
+     * The value of maximum duration and use the network setting.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_MAX_DURATION = 255; // (VP - 192) Weeks
+    // MTK-END
+
+    /**
+     * Send an MMS message
+     *
+     * @param context application context
+     * @param contentUri the content Uri from which the message pdu will be read
+     * @param locationUrl the optional location url where message should be sent to
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  sending the message.
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed
+     * @throws IllegalArgumentException if contentUri is empty
+     */
+    public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl,
+            Bundle configOverrides, PendingIntent sentIntent) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms == null) {
+                return;
+            }
+
+            iMms.sendMessage(getSubscriptionId(), ActivityThread.currentPackageName(), contentUri,
+                    locationUrl, configOverrides, sentIntent);
+        } catch (RemoteException e) {
+            // Ignore it
+        }
+    }
+
+    /**
+     * Download an MMS message from carrier by a given location URL
+     *
+     * @param context application context
+     * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained
+     *  from the MMS WAP push notification
+     * @param contentUri the content uri to which the downloaded pdu will be written
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  downloading the message.
+     * @param downloadedIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is downloaded, or the download is failed
+     * @throws IllegalArgumentException if locationUrl or contentUri is empty
+     */
+    public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri,
+            Bundle configOverrides, PendingIntent downloadedIntent) {
+        if (TextUtils.isEmpty(locationUrl)) {
+            throw new IllegalArgumentException("Empty MMS location URL");
+        }
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms == null) {
+                return;
+            }
+            iMms.downloadMessage(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), locationUrl,
+                    contentUri, configOverrides, downloadedIntent);
+        } catch (RemoteException e) {
+            // Ignore it
+        }
+    }
+
+    // MMS send/download failure result codes
+    public static final int MMS_ERROR_UNSPECIFIED = 1;
+    public static final int MMS_ERROR_INVALID_APN = 2;
+    public static final int MMS_ERROR_UNABLE_CONNECT_MMS = 3;
+    public static final int MMS_ERROR_HTTP_FAILURE = 4;
+    public static final int MMS_ERROR_IO_ERROR = 5;
+    public static final int MMS_ERROR_RETRY = 6;
+    public static final int MMS_ERROR_CONFIGURATION_ERROR = 7;
+    public static final int MMS_ERROR_NO_DATA_NETWORK = 8;
+
+    /** Intent extra name for MMS sending result data in byte array type */
+    public static final String EXTRA_MMS_DATA = "android.telephony.extra.MMS_DATA";
+    /** Intent extra name for HTTP status code for MMS HTTP failure in integer type */
+    public static final String EXTRA_MMS_HTTP_STATUS = "android.telephony.extra.MMS_HTTP_STATUS";
+
+    /**
+     * Import a text message into system's SMS store
+     *
+     * Only default SMS apps can import SMS
+     *
+     * @param address the destination(source) address of the sent(received) message
+     * @param type the type of the message
+     * @param text the message text
+     * @param timestampMillis the message timestamp in milliseconds
+     * @param seen if the message is seen
+     * @param read if the message is read
+     * @return the message URI, null if failed
+     * @hide
+     */
+    public Uri importTextMessage(String address, int type, String text, long timestampMillis,
+            boolean seen, boolean read) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.importTextMessage(ActivityThread.currentPackageName(),
+                        address, type, text, timestampMillis, seen, read);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /** Represents the received SMS message for importing {@hide} */
+    public static final int SMS_TYPE_INCOMING = 0;
+    /** Represents the sent SMS message for importing {@hide} */
+    public static final int SMS_TYPE_OUTGOING = 1;
+
+    /**
+     * Import a multimedia message into system's MMS store. Only the following PDU type is
+     * supported: Retrieve.conf, Send.req, Notification.ind, Delivery.ind, Read-Orig.ind
+     *
+     * Only default SMS apps can import MMS
+     *
+     * @param contentUri the content uri from which to read the PDU of the message to import
+     * @param messageId the optional message id. Use null if not specifying
+     * @param timestampSecs the optional message timestamp. Use -1 if not specifying
+     * @param seen if the message is seen
+     * @param read if the message is read
+     * @return the message URI, null if failed
+     * @throws IllegalArgumentException if pdu is empty
+     * {@hide}
+     */
+    public Uri importMultimediaMessage(Uri contentUri, String messageId, long timestampSecs,
+            boolean seen, boolean read) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.importMultimediaMessage(ActivityThread.currentPackageName(),
+                        contentUri, messageId, timestampSecs, seen, read);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Delete a system stored SMS or MMS message
+     *
+     * Only default SMS apps can delete system stored SMS and MMS messages
+     *
+     * @param messageUri the URI of the stored message
+     * @return true if deletion is successful, false otherwise
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public boolean deleteStoredMessage(Uri messageUri) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.deleteStoredMessage(ActivityThread.currentPackageName(), messageUri);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Delete a system stored SMS or MMS thread
+     *
+     * Only default SMS apps can delete system stored SMS and MMS conversations
+     *
+     * @param conversationId the ID of the message conversation
+     * @return true if deletion is successful, false otherwise
+     * {@hide}
+     */
+    public boolean deleteStoredConversation(long conversationId) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.deleteStoredConversation(
+                        ActivityThread.currentPackageName(), conversationId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Update the status properties of a system stored SMS or MMS message, e.g.
+     * the read status of a message, etc.
+     *
+     * @param messageUri the URI of the stored message
+     * @param statusValues a list of status properties in key-value pairs to update
+     * @return true if update is successful, false otherwise
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public boolean updateStoredMessageStatus(Uri messageUri, ContentValues statusValues) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.updateStoredMessageStatus(ActivityThread.currentPackageName(),
+                        messageUri, statusValues);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /** Message status property: whether the message has been seen. 1 means seen, 0 not {@hide} */
+    public static final String MESSAGE_STATUS_SEEN = "seen";
+    /** Message status property: whether the message has been read. 1 means read, 0 not {@hide} */
+    public static final String MESSAGE_STATUS_READ = "read";
+
+    /**
+     * Archive or unarchive a stored conversation
+     *
+     * @param conversationId the ID of the message conversation
+     * @param archived true to archive the conversation, false to unarchive
+     * @return true if update is successful, false otherwise
+     * {@hide}
+     */
+    public boolean archiveStoredConversation(long conversationId, boolean archived) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.archiveStoredConversation(ActivityThread.currentPackageName(),
+                        conversationId, archived);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Add a text message draft to system SMS store
+     *
+     * Only default SMS apps can add SMS draft
+     *
+     * @param address the destination address of message
+     * @param text the body of the message to send
+     * @return the URI of the stored draft message
+     * {@hide}
+     */
+    public Uri addTextMessageDraft(String address, String text) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.addTextMessageDraft(ActivityThread.currentPackageName(), address, text);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Add a multimedia message draft to system MMS store
+     *
+     * Only default SMS apps can add MMS draft
+     *
+     * @param contentUri the content uri from which to read the PDU data of the draft MMS
+     * @return the URI of the stored draft message
+     * @throws IllegalArgumentException if pdu is empty
+     * {@hide}
+     */
+    public Uri addMultimediaMessageDraft(Uri contentUri) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.addMultimediaMessageDraft(ActivityThread.currentPackageName(),
+                        contentUri);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Send a system stored text message.
+     *
+     * You can only send a failed text message or a draft text message.
+     *
+     * @param messageUri the URI of the stored message
+     * @param scAddress is the service center address or null to use the current default SMSC
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredTextMessage(Uri messageUri, String scAddress, PendingIntent sentIntent,
+            PendingIntent deliveryIntent) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        // MTK-START
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendStoredText(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                    scAddress, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Send a system stored multi-part text message.
+     *
+     * You can only send a failed text message or a draft text message.
+     * The provided <code>PendingIntent</code> lists should match the part number of the
+     * divided text of the stored message by using <code>divideMessage</code>
+     *
+     * @param messageUri the URI of the stored message
+     * @param scAddress is the service center address or null to use
+     *   the current default SMSC
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK</code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applications,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredMultipartTextMessage(Uri messageUri, String scAddress,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendStoredMultipartText(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                    scAddress, sentIntents, deliveryIntents);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Send a system stored MMS message
+     *
+     * This is used for sending a previously sent, but failed-to-send, message or
+     * for sending a text message that has been stored as a draft.
+     *
+     * @param messageUri the URI of the stored message
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  sending the message.
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredMultimediaMessage(Uri messageUri, Bundle configOverrides,
+            PendingIntent sentIntent) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                iMms.sendStoredMessage(
+                        getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                        configOverrides, sentIntent);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Turns on/off the flag to automatically write sent/received SMS/MMS messages into system
+     *
+     * When this flag is on, all SMS/MMS sent/received are stored by system automatically
+     * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
+     * automatically
+     *
+     * This flag can only be changed by default SMS apps
+     *
+     * @param enabled Whether to enable message auto persisting
+     * {@hide}
+     */
+    public void setAutoPersisting(boolean enabled) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                iMms.setAutoPersisting(ActivityThread.currentPackageName(), enabled);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Get the value of the flag to automatically write sent/received SMS/MMS messages into system
+     *
+     * When this flag is on, all SMS/MMS sent/received are stored by system automatically
+     * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
+     * automatically
+     *
+     * @return the current value of the auto persist flag
+     * {@hide}
+     */
+    public boolean getAutoPersisting() {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.getAutoPersisting();
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Get carrier-dependent configuration values.
+     *
+     * @return bundle key/values pairs of configuration values
+     */
+    public Bundle getCarrierConfigValues() {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.getCarrierConfigValues(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Filters a bundle to only contain MMS config variables.
+     *
+     * This is for use with bundles returned by {@link CarrierConfigManager} which contain MMS
+     * config and unrelated config. It is assumed that all MMS_CONFIG_* keys are present in the
+     * supplied bundle.
+     *
+     * @param config a Bundle that contains MMS config variables and possibly more.
+     * @return a new Bundle that only contains the MMS_CONFIG_* keys defined above.
+     * @hide
+     */
+    public static Bundle getMmsConfig(BaseBundle config) {
+        Bundle filtered = new Bundle();
+        filtered.putBoolean(MMS_CONFIG_APPEND_TRANSACTION_ID,
+                config.getBoolean(MMS_CONFIG_APPEND_TRANSACTION_ID));
+        filtered.putBoolean(MMS_CONFIG_MMS_ENABLED, config.getBoolean(MMS_CONFIG_MMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_GROUP_MMS_ENABLED,
+                config.getBoolean(MMS_CONFIG_GROUP_MMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED,
+                config.getBoolean(MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_ALIAS_ENABLED, config.getBoolean(MMS_CONFIG_ALIAS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_ALLOW_ATTACH_AUDIO,
+                config.getBoolean(MMS_CONFIG_ALLOW_ATTACH_AUDIO));
+        filtered.putBoolean(MMS_CONFIG_MULTIPART_SMS_ENABLED,
+                config.getBoolean(MMS_CONFIG_MULTIPART_SMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION,
+                config.getBoolean(MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION));
+        filtered.putBoolean(MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES,
+                config.getBoolean(MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES));
+        filtered.putBoolean(MMS_CONFIG_MMS_READ_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_MMS_READ_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_CLOSE_CONNECTION,
+                config.getBoolean(MMS_CONFIG_CLOSE_CONNECTION));
+        filtered.putInt(MMS_CONFIG_MAX_MESSAGE_SIZE, config.getInt(MMS_CONFIG_MAX_MESSAGE_SIZE));
+        filtered.putInt(MMS_CONFIG_MAX_IMAGE_WIDTH, config.getInt(MMS_CONFIG_MAX_IMAGE_WIDTH));
+        filtered.putInt(MMS_CONFIG_MAX_IMAGE_HEIGHT, config.getInt(MMS_CONFIG_MAX_IMAGE_HEIGHT));
+        filtered.putInt(MMS_CONFIG_RECIPIENT_LIMIT, config.getInt(MMS_CONFIG_RECIPIENT_LIMIT));
+        filtered.putInt(MMS_CONFIG_ALIAS_MIN_CHARS, config.getInt(MMS_CONFIG_ALIAS_MIN_CHARS));
+        filtered.putInt(MMS_CONFIG_ALIAS_MAX_CHARS, config.getInt(MMS_CONFIG_ALIAS_MAX_CHARS));
+        filtered.putInt(MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD,
+                config.getInt(MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD));
+        filtered.putInt(MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD,
+                config.getInt(MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD));
+        filtered.putInt(MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE,
+                config.getInt(MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE));
+        filtered.putInt(MMS_CONFIG_SUBJECT_MAX_LENGTH,
+                config.getInt(MMS_CONFIG_SUBJECT_MAX_LENGTH));
+        filtered.putInt(MMS_CONFIG_HTTP_SOCKET_TIMEOUT,
+                config.getInt(MMS_CONFIG_HTTP_SOCKET_TIMEOUT));
+        filtered.putString(MMS_CONFIG_UA_PROF_TAG_NAME,
+                config.getString(MMS_CONFIG_UA_PROF_TAG_NAME));
+        filtered.putString(MMS_CONFIG_USER_AGENT, config.getString(MMS_CONFIG_USER_AGENT));
+        filtered.putString(MMS_CONFIG_UA_PROF_URL, config.getString(MMS_CONFIG_UA_PROF_URL));
+        filtered.putString(MMS_CONFIG_HTTP_PARAMS, config.getString(MMS_CONFIG_HTTP_PARAMS));
+        filtered.putString(MMS_CONFIG_EMAIL_GATEWAY_NUMBER,
+                config.getString(MMS_CONFIG_EMAIL_GATEWAY_NUMBER));
+        filtered.putString(MMS_CONFIG_NAI_SUFFIX, config.getString(MMS_CONFIG_NAI_SUFFIX));
+        filtered.putBoolean(MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS,
+                config.getBoolean(MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS));
+        filtered.putBoolean(MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER,
+                config.getBoolean(MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER));
+        return filtered;
+    }
+
+    // MTK-START
+    /**
+     * Judge if the destination address is a valid SMS address or not, and if
+     * the text is null or not
+     *
+     * @destinationAddress the destination address to which the message be sent
+     * @text the content of shorm message
+     * @sentIntent will be broadcast if the address or the text is invalid
+     * @return true for valid parameters
+     */
+    private static boolean isValidParameters(String destinationAddress, String text,
+            PendingIntent sentIntent) {
+        ArrayList<PendingIntent> sentIntents =
+                new ArrayList<PendingIntent>();
+        ArrayList<String> parts =
+                new ArrayList<String>();
+
+        sentIntents.add(sentIntent);
+        parts.add(text);
+
+        // if (TextUtils.isEmpty(text)) {
+        // throw new IllegalArgumentException("Invalid message body");
+        // }
+
+        return isValidParameters(destinationAddress, parts, sentIntents);
+    }
+
+    /**
+     * Judges if the destination address is a valid SMS address or not, and if
+     * the text is null or not.
+     *
+     * @param destinationAddress The destination address to which the message be sent
+     * @param parts The content of shorm message
+     * @param sentIntent will be broadcast if the address or the text is invalid
+     * @return True for valid parameters
+     */
+    private static boolean isValidParameters(String destinationAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents) {
+        if (parts == null || parts.size() == 0) {
+            return true;
+        }
+
+        if (!isValidSmsDestinationAddress(destinationAddress)) {
+            for (int i = 0; i < sentIntents.size(); i++) {
+                PendingIntent sentIntent = sentIntents.get(i);
+                if (sentIntent != null) {
+                    try {
+                        sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
+                    } catch (CanceledException ex) { }
+                }
+            }
+
+            Rlog.d(TAG, "Invalid destinationAddress: " + destinationAddress);
+            return false;
+        }
+
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+        if (parts == null || parts.size() < 1) {
+            throw new IllegalArgumentException("Invalid message body");
+        }
+
+        return true;
+    }
+
+    /**
+     * judge if the input destination address is a valid SMS address or not
+     *
+     * @param da the input destination address
+     * @return true for success
+     *
+     */
+    private static boolean isValidSmsDestinationAddress(String da) {
+        String encodeAddress = PhoneNumberUtils.extractNetworkPortion(da);
+        if (encodeAddress == null)
+            return true;
+
+        return !(encodeAddress.isEmpty());
+    }
+
+    /**
+     * Retrieves all messages currently stored on ICC based on different mode.
+     * Ex. CDMA mode or GSM mode for international cards.
+     *
+     * @param subId subscription identity
+     * @param mode the GSM mode or CDMA mode
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects
+     * @hide
+     */
+    public ArrayList<SmsMessage> getAllMessagesFromIccEfByMode(int mode) {
+        Rlog.d(TAG, "getAllMessagesFromIcc, mode=" + mode);
+
+        List<SmsRawData> records = null;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                records = iccISms.getAllMessagesFromIccEfByModeForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), mode);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        int sz = 0;
+        if (records != null) {
+            sz = records.size();
+        }
+        for (int i = 0; i < sz; ++i) {
+            byte[] data = null;
+            SmsRawData record = records.get(i);
+            if (record == null) {
+                continue;
+            } else {
+                data = record.getBytes();
+            }
+            int index = i + 1;
+            if ((data[0] & 0xff) == SmsManager.STATUS_ON_ICC_UNREAD) {
+                Rlog.d(TAG, "index[" + index + "] is STATUS_ON_ICC_READ");
+                boolean ret;
+                ret = updateMessageOnIcc(index, SmsManager.STATUS_ON_ICC_READ, data);
+                if (ret) {
+                    Rlog.d(TAG, "update index[" + index + "] to STATUS_ON_ICC_READ");
+                } else {
+                    Rlog.d(TAG, "fail to update message status");
+                }
+            }
+        }
+
+        return createMessageListFromRawRecordsByMode(getSubscriptionId(), records, mode);
+    }
+
+    /**
+     * Create a list of <code>SmsMessage</code>s from a list of RawSmsData
+     * records returned by <code>getAllMessagesFromIcc()</code>.
+     *
+     * @param subId subscription identity
+     * @param records SMS EF records, returned by
+     *            <code>getAllMessagesFromIcc</code>
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.
+     */
+    private static ArrayList<SmsMessage> createMessageListFromRawRecordsByMode(int subId,
+            List<SmsRawData> records, int mode) {
+        Rlog.d(TAG, "createMessageListFromRawRecordsByMode");
+
+        ArrayList<SmsMessage> msg = null;
+        if (records != null) {
+            int count = records.size();
+            msg = new ArrayList<SmsMessage>();
+
+            for (int i = 0; i < count; i++) {
+                SmsRawData data = records.get(i);
+
+                if (data != null) {
+                    SmsMessage singleSms =
+                            createFromEfRecordByMode(subId, i + 1, data.getBytes(), mode);
+                    if (singleSms != null) {
+                        msg.add(singleSms);
+                    }
+                }
+            }
+            Rlog.d(TAG, "actual sms count is " + msg.size());
+        } else {
+            Rlog.d(TAG, "fail to parse SIM sms, records is null");
+        }
+
+        return msg;
+    }
+
+    /**
+     * Create an SmsMessage from an SMS EF record.
+     *
+     * @param index Index of SMS record. This should be index in ArrayList
+     *              returned by SmsManager.getAllMessagesFromSim + 1.
+     * @param data Record data.
+     * @param slotId SIM card the user would like to access
+     * @return An SmsMessage representing the record.
+     *
+     */
+    private static SmsMessage createFromEfRecordByMode(int subId, int index, byte[] data,
+            int mode) {
+        SmsMessage sms = null;
+
+        if (mode == PhoneConstants.PHONE_TYPE_CDMA) {
+            sms = SmsMessage.createFromEfRecord(index, data, SmsConstants.FORMAT_3GPP2);
+        } else {
+            sms = SmsMessage.createFromEfRecord(index, data, SmsConstants.FORMAT_3GPP);
+        }
+
+        if (sms != null) {
+            sms.setSubId(subId);
+        }
+
+        return sms;
+    }
+
+    /**
+     * Copy a text SMS to the ICC.
+     *
+     * @param subId subscription identity
+     * @param scAddress Service center address
+     * @param address   Destination address or original address
+     * @param text      List of message text
+     * @param status    message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *                  STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param timestamp Timestamp when service center receive the message
+     * @return success or not
+     *
+     * @internal
+     * @hide
+     */
+    public int copyTextMessageToIccCard(String scAddress, String address, List<String> text,
+            int status, long timestamp) {
+        Rlog.d(TAG, "copyTextMessageToIccCard");
+        int result = SmsManager.RESULT_ERROR_GENERIC_FAILURE;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return result;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.copyTextMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), scAddress, address, text, status,
+                        timestamp);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Send a data based SMS to a specific application port.
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param destinationPort the port to deliver the message to
+     * @param originalPort the port to deliver the message from
+     * @param data the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK<code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applicaitons,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     *
+     * @hide
+     */
+    public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort,
+            short originalPort, byte[] data, PendingIntent sentIntent,
+            PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendDataWithOriginalPortForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destinationAddress, scAddress,
+                        destinationPort & 0xFFFF, originalPort & 0xFFFF, data, sentIntent,
+                        deliveryIntent);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+    }
+
+    /**
+     * Send a text based SMS.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *  the current default SMSC
+     * @param text the body of the message to send
+     * @param encodingType the encoding type of message(gsm 7-bit, unicode or automatic)
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK<code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or text are empty
+     * @hide
+     */
+    public void sendTextMessageWithEncodingType(String destAddr, String scAddr, String text,
+            int encodingType, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendTextMessageWithEncodingType, text=" + ((DBG == true)? text : "") +
+                ", encoding=" + encodingType);
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, text, sentIntent)) {
+            Rlog.d(TAG, "the parameters are invalid");
+            return;
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendTextWithEncodingTypeForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destAddr, scAddr, text, encodingType,
+                        sentIntent, deliveryIntent, true /*persistMessageForCarrierApp*/);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+    }
+
+    /**
+     * Send a multi-part text based SMS.  The callee should have already
+     * divided the message into correctly sized parts by calling
+     * <code>divideMessage</code>.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param encodingType the encoding type of message(gsm 7-bit, unicode or automatic)
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK<code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applicaitons,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     *
+     * @internal
+     * @hide
+     */
+    public void sendMultipartTextMessageWithEncodingType(String destAddr, String scAddr,
+            ArrayList<String> parts, int encodingType, ArrayList<PendingIntent> sentIntents,
+            ArrayList<PendingIntent> deliveryIntents) {
+        Rlog.d(TAG, "sendMultipartTextMessageWithEncodingType, encoding=" + encodingType);
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, parts, sentIntents)) {
+            Rlog.d(TAG, "invalid parameters for multipart message");
+            return;
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                if (iccISms != null) {
+                    iccISms.sendMultipartTextWithEncodingTypeForSubscriber(getSubscriptionId(),
+                            ActivityThread.currentPackageName(), destAddr, scAddr, parts,
+                            encodingType, sentIntents, deliveryIntents,
+                            true /*persistMessageForCarrierApp*/);
+                }
+            } catch (RemoteException ex) {
+                Rlog.d(TAG, "RemoteException");
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            Rlog.d(TAG, "get sentIntent: " + sentIntent);
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+            Rlog.d(TAG, "send single message");
+            if (parts != null) {
+                Rlog.d(TAG, "parts.size = " + parts.size());
+            }
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            Rlog.d(TAG, "pass encoding type " + encodingType);
+            sendTextMessageWithEncodingType(destAddr, scAddr, text, encodingType, sentIntent,
+                    deliveryIntent);
+        }
+    }
+
+    /**
+     * Divide a message text into several fragments, none bigger than
+     * the maximum SMS message size.
+     *
+     * @param text the original message.  Must not be null.
+     * @param encodingType text encoding type(7-bit, 16-bit or automatic)
+     * @return an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     *
+     * @internal
+     * @hide
+     */
+    public ArrayList<String> divideMessage(String text, int encodingType) {
+        Rlog.d(TAG, "divideMessage, encoding = " + encodingType);
+        ArrayList<String> ret = SmsMessage.fragmentText(text, encodingType);
+        Rlog.d(TAG, "divideMessage: size = " + ret.size());
+        return ret;
+    }
+
+    /**
+     * insert a text SMS to the ICC.
+     *
+     * @param subId subscription identity
+     * @param scAddress Service center address
+     * @param address   Destination address or original address
+     * @param text      List of message text
+     * @param status    message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *                  STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param timestamp Timestamp when service center receive the message
+     * @return SimSmsInsertStatus
+     * @hide
+     */
+    public SimSmsInsertStatus insertTextMessageToIccCard(String scAddress, String address,
+            List<String> text, int status, long timestamp) {
+        Rlog.d(TAG, "insertTextMessageToIccCard");
+        SimSmsInsertStatus ret = null;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.insertTextMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), scAddress, address, text, status,
+                        timestamp);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, (ret != null) ? "insert Text " + ret.indexInIcc : "insert Text null");
+        return ret;
+
+    }
+
+    /**
+     * Copy a raw SMS PDU to the ICC.
+     *
+     * @param subId subscription identity
+     * @param status message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *               STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param pdu the raw PDU to store
+     * @param smsc encoded smsc service center
+     * @return SimSmsInsertStatus
+     * @hide
+     */
+    public SimSmsInsertStatus insertRawMessageToIccCard(int status, byte[] pdu, byte[] smsc) {
+        Rlog.d(TAG, "insertRawMessageToIccCard");
+        SimSmsInsertStatus ret = null;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.insertRawMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), status, pdu, smsc);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, (ret != null) ? "insert Raw " + ret.indexInIcc : "insert Raw null");
+        return ret;
+    }
+
+    /**
+     * Send an SMS with specified encoding type.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr the SMSC to send the message through, or NULL for the
+     *  default SMSC
+     * @param text the body of the message to send
+     * @param extraParams extra parameters, such as validity period, encoding type
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     * @hide
+     */
+    public void sendTextMessageWithExtraParams(String destAddr, String scAddr, String text,
+            Bundle extraParams, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendTextMessageWithExtraParams, text=" + ((DBG == true)? text : ""));
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, text, sentIntent)) {
+            return;
+        }
+
+        if (extraParams == null) {
+            Rlog.d(TAG, "bundle is null");
+            return;
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendTextWithExtraParamsForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destAddr, scAddr, text, extraParams,
+                        sentIntent, deliveryIntent, true /*persistMessageForCarrierApp*/);
+            }
+        } catch (RemoteException e) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+    }
+
+    /**
+     * Send a multi-part text based SMS with specified encoding type.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param extraParams extra parameters, such as validity period, encoding type
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @internal
+     * @hide
+     */
+    public void sendMultipartTextMessageWithExtraParams(String destAddr, String scAddr,
+            ArrayList<String> parts, Bundle extraParams, ArrayList<PendingIntent> sentIntents,
+            ArrayList<PendingIntent> deliveryIntents) {
+        Rlog.d(TAG, "sendMultipartTextMessageWithExtraParams");
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, parts, sentIntents)) {
+            return;
+        }
+
+        if (extraParams == null) {
+            Rlog.d(TAG, "bundle is null");
+            return;
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                if (iccISms != null) {
+                    iccISms.sendMultipartTextWithExtraParamsForSubscriber(getSubscriptionId(),
+                            ActivityThread.currentPackageName(), destAddr, scAddr, parts,
+                            extraParams, sentIntents, deliveryIntents,
+                            true /*persistMessageForCarrierApp*/);
+                }
+            } catch (RemoteException e) {
+                Rlog.d(TAG, "RemoteException");
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            sendTextMessageWithExtraParams(destAddr, scAddr, text, extraParams, sentIntent,
+                    deliveryIntent);
+        }
+    }
+
+    /**
+     * Get SMS paramter from icc cards
+     *
+     * @return <code>SmsParameters</code> object for sms sim card settings.
+     *
+     * @hide
+     */
+    public SmsParameters getSmsParameters() {
+        Rlog.d(TAG, "getSmsParameters");
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.getSmsParametersForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            } else {
+                return null;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, "fail to get SmsParameters");
+        return null;
+
+    }
+
+    /**
+     * Set sms paramter icc cards.
+     *
+     * @param params <code>SmsParameters</code>.
+     *
+     * @return true set complete; false set failed.
+     *
+     * @hide
+     */
+    public boolean setSmsParameters(SmsParameters params) {
+        Rlog.d(TAG, "setSmsParameters");
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.setSmsParametersForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), params);
+            } else {
+                return false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return false;
+
+    }
+
+    /**
+     * Copy SMS to Icc cards.
+     *
+     * @param smsc service message centers address
+     * @param pdu sms pdu
+     * @param status sms status
+     *
+     * @return copied index on Icc cards
+     *
+     * @hide
+     */
+    public int copySmsToIcc(byte[] smsc, byte[] pdu, int status) {
+        Rlog.d(TAG, "copySmsToIcc");
+
+        SimSmsInsertStatus smsStatus = insertRawMessageToIccCard(status, pdu, smsc);
+        if (smsStatus == null) {
+            return -1;
+        }
+        int[] index = smsStatus.getIndex();
+
+        if (index != null && index.length > 0) {
+            return index[0];
+        }
+
+        return -1;
+    }
+
+    /**
+     * Update sms status on icc card.
+     *
+     * @param index updated index of sms on icc card
+     * @param read read status
+     *
+     * @return true updated successful; false updated failed.
+     *
+     * @hide
+     */
+    public boolean updateSmsOnSimReadStatus(int index, boolean read) {
+        Rlog.d(TAG, "updateSmsOnSimReadStatus");
+        SmsRawData record = null;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                record = iccISms.getMessageFromIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), index);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        if (record != null) {
+            byte[] rawData = record.getBytes();
+            int status = rawData[0] & 0xff;
+            Rlog.d(TAG, "sms status is " + status);
+            if (status != SmsManager.STATUS_ON_ICC_UNREAD &&
+                    status != SmsManager.STATUS_ON_ICC_READ) {
+                Rlog.d(TAG, "non-delivery sms " + status);
+                return false;
+            } else {
+                if ((status == SmsManager.STATUS_ON_ICC_UNREAD && read == false)
+                        || (status == SmsManager.STATUS_ON_ICC_READ && read == true)) {
+                    Rlog.d(TAG, "no need to update status");
+                    return true;
+                } else {
+                    Rlog.d(TAG, "update sms status as " + read);
+                    int newStatus = ((read == true) ? SmsManager.STATUS_ON_ICC_READ
+                            : SmsManager.STATUS_ON_ICC_UNREAD);
+                    return updateMessageOnIcc(index, newStatus, rawData);
+                }
+            }
+        } // end if(record != null)
+
+        Rlog.d(TAG, "record is null");
+
+        return false;
+    }
+
+    /**
+     * Set ETWS config to modem.
+     *
+     * @param mode ETWS config mode.
+     *
+     * @return true set ETWS config successful; false set ETWS config failed.
+     *
+     * @hide
+     */
+    public boolean setEtwsConfig(int mode) {
+        Rlog.d(TAG, "setEtwsConfig, mode=" + mode);
+        boolean ret = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.setEtwsConfigForSubscriber(getSubscriptionId(), mode);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return ret;
+    }
+
+    /**
+     * Set the memory storage status of the SMS.
+     * This function is used for FTA test only.
+     *
+     * @param subId subscription identity
+     * @param status false for storage full, true for storage available
+     *
+     * @internal
+     * @hide
+     */
+    public void setSmsMemoryStatus(boolean status) {
+        Rlog.d(TAG, "setSmsMemoryStatus");
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.setSmsMemoryStatusForSubscriber(getSubscriptionId(), status);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+    }
+
+    /**
+     * Get SMS SIM Card memory's total and used number.
+     *
+     * @param subId subscription identity
+     *
+     * @return <code>IccSmsStorageStatus</code> object
+     *
+     * @internal
+     * @hide
+     */
+    public IccSmsStorageStatus getSmsSimMemoryStatus() {
+        Rlog.d(TAG, "getSmsSimMemoryStatus");
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.getSmsSimMemoryStatusForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return null;
+    }
+
+    /**
+     * @hide
+     */
+    private SmsBroadcastConfigInfo Convert2SmsBroadcastConfigInfo(SmsCbConfigInfo info) {
+        return new SmsBroadcastConfigInfo(
+                info.mFromServiceId,
+                info.mToServiceId,
+                info.mFromCodeScheme,
+                info.mToCodeScheme,
+                info.mSelected);
+    }
+
+    /**
+     * @hide
+     */
+    private SmsCbConfigInfo Convert2SmsCbConfigInfo(SmsBroadcastConfigInfo info) {
+        return new SmsCbConfigInfo(
+                info.getFromServiceId(),
+                info.getToServiceId(),
+                info.getFromCodeScheme(),
+                info.getToCodeScheme(),
+                info.isSelected());
+    }
+
+    /**
+     * Set cell broadcast config to icc cards.
+     *
+     * @return <code>SmsBroadcastConfigInfo</code>
+     *
+     * @internal
+     * @hide
+     */
+    public SmsBroadcastConfigInfo[] getCellBroadcastSmsConfig() {
+        Rlog.d(TAG, "getCellBroadcastSmsConfig");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        SmsCbConfigInfo[] configs = null;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                configs = iccISms.getCellBroadcastSmsConfigForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        if (configs != null) {
+            Rlog.d(TAG, "config length = " + configs.length);
+            int i = 0;
+            if (configs.length != 0) {
+                SmsBroadcastConfigInfo[] result = new SmsBroadcastConfigInfo[configs.length];
+                for (i = 0; i < configs.length; i++)
+                    result[i] = Convert2SmsBroadcastConfigInfo(configs[i]);
+                return result;
+            }
+        }
+
+        /*
+         * Exception to return null case, Even if there is no channesl,
+         * it still have one config with -1
+         */
+        return null;
+    }
+
+    /**
+     * Get cell broadcast config from icc cards.
+     *
+     * @param channels <code>SmsBroadcastConfigInfo</code>
+     * @param languages <code>SmsBroadcastConfigInfo</code>
+     *
+     * @return <code>SmsBroadcastConfigInfo</code>
+     *
+     * @internal
+     * @hide
+     */
+    public boolean setCellBroadcastSmsConfig(SmsBroadcastConfigInfo[] channels,
+            SmsBroadcastConfigInfo[] languages) {
+        Rlog.d(TAG, "setCellBroadcastSmsConfig");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        if (channels != null) {
+            Rlog.d(TAG, "channel size=" + channels.length);
+        } else {
+            Rlog.d(TAG, "channel size=0");
+        }
+        if (languages != null) {
+            Rlog.d(TAG, "language size=" + languages.length);
+        } else {
+            Rlog.d(TAG, "language size=0");
+        }
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                int i = 0;
+                SmsCbConfigInfo[] channelInfos = null, languageInfos = null;
+                if (channels != null && channels.length != 0) {
+                    channelInfos = new SmsCbConfigInfo[channels.length];
+                    for (i = 0 ; i < channels.length ; i++)
+                        channelInfos[i] = Convert2SmsCbConfigInfo(channels[i]);
+                }
+                if (languages != null && languages.length != 0) {
+                    languageInfos = new SmsCbConfigInfo[languages.length];
+                    for (i = 0 ; i < languages.length ; i++)
+                        languageInfos[i] = Convert2SmsCbConfigInfo(languages[i]);
+                }
+
+                result = iccISms.setCellBroadcastSmsConfigForSubscriber(getSubscriptionId(),
+                        channelInfos, languageInfos);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "setCellBroadcastSmsConfig, RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Query if cell broadcast activation.
+     *
+     * @return true activatd; false deactivated.
+     *
+     * @internal
+     * @hide
+     */
+    public boolean queryCellBroadcastSmsActivation() {
+        Rlog.d(TAG, "queryCellBroadcastSmsActivation");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.queryCellBroadcastSmsActivationForSubscriber(
+                        getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * To activate the cell broadcast.
+     *
+     * @param activate true activation; false de-activation.
+     *
+     * @return true process successfully; false process failed.
+     *
+     * @internal
+     * @hide
+     */
+    public boolean activateCellBroadcastSms(boolean activate) {
+        Rlog.d(TAG, "activateCellBroadcastSms activate : " + activate + ", sub = " +
+                getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.activateCellBroadcastSmsForSubscriber(getSubscriptionId(),
+                        activate);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException e) {
+            Rlog.d(TAG, "fail to activate CB");
+            result = false;
+        }
+
+        return result;
+    }
+
+    /**
+     * Remove specified channel and serial of cb message.
+     *
+     * @param channelId removed channel id
+     * @param serialId removed serial id
+     *
+     * @return true process successfully; false process failed.
+     *
+     * @hide
+     */
+    public boolean removeCellBroadcastMsg(int channelId, int serialId) {
+        Rlog.d(TAG, "RemoveCellBroadcastMsg, subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.removeCellBroadcastMsgForSubscriber(getSubscriptionId(),
+                        channelId, serialId);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoveCellBroadcastMsg, RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Query cell broadcast channel configuration
+     *
+     * @return channel configuration. e.g. "1,3,100-123"
+     *
+     * @hide
+     */
+    public String getCellBroadcastRanges() {
+        Rlog.d(TAG, "getCellBroadcastRanges, subId=" + getSubscriptionId());
+        String configs = "";
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                configs = iccISms.getCellBroadcastRangesForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return configs;
+    }
+
+    /**
+     * Set cell broadcast language configuration
+     *
+     * @param lang denotes language configuration. e.g. "1,7,5-29"
+     *
+     * @hide
+     */
+    public boolean setCellBroadcastLang(String lang) {
+        Rlog.d(TAG, "setCellBroadcastLang, subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.setCellBroadcastLangsForSubscriber(getSubscriptionId(), lang);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return result;
+    }
+
+    /**
+     * Get cell broadcast language configuration
+     *
+     * @return language configuration. e.g. "1,2,3,32"
+     *
+     * @hide
+     */
+    public String getCellBroadcastLang() {
+        Rlog.d(TAG, "getCellBroadcastLang, subId=" + getSubscriptionId());
+        String langs = "";
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                langs = iccISms.getCellBroadcastLangsForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return langs;
+    }
+    // MTK-END
+}
