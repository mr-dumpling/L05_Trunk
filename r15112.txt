Index: vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/AndroidManifest.xml
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/AndroidManifest.xml	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/AndroidManifest.xml	(revision 15112)
@@ -0,0 +1,146 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+        package="com.android.stk"
+        android:sharedUserId="android.uid.phone">
+
+    <original-package android:name="com.android.stk" />
+
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
+    <uses-permission android:name="android.permission.GET_TASKS" />
+    <uses-permission android:name="android.permission.RECEIVE_STK_COMMANDS" />
+    <uses-permission android:name="android.permission.INTERACT_ACROSS_USER_FULL" />
+    <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE" />
+    <protected-broadcast android:name="android.intent.action.RESET_MAIN_ACCESS" />
+    <protected-broadcast android:name="android.stkDialog.TIMEOUT" />
+
+    <application android:icon="@drawable/ic_launcher_sim_toolkit"
+        android:label="@string/app_name"
+        android:clearTaskOnLaunch="true"
+        android:process="com.android.phone"
+        android:taskAffinity="android.task.stk">
+
+        <activity android:name=".StkMain"
+            android:theme="@android:style/Theme.Translucent.NoTitleBar"
+            android:configChanges="orientation"
+            android:label="@string/app_name"
+            android:enabled="false"
+            android:exported="true"
+            android:taskAffinity="android.task.stk.task">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".StkLauncherActivity"
+            android:theme="@android:style/Theme.NoTitleBar"
+            android:configChanges="orientation"
+            android:label="@string/app_name"
+            android:exported="true"
+            android:taskAffinity="android.task.stk.task">
+            <intent-filter>
+                 <action android:name="android.intent.action.VIEW" />
+                 <action android:name="android.intent.action.PICK" />
+                 <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".StkMenuActivity"
+            android:theme="@android:style/Theme.NoTitleBar"
+            android:icon="@drawable/ic_launcher_sim_toolkit"
+            android:label="@string/app_name"
+            android:configChanges="orientation|locale|screenSize|layoutDirection|keyboardHidden|mnc|mcc"
+            android:exported="false"
+            android:taskAffinity="android.task.stk.task">
+             <intent-filter>
+                 <action android:name="android.intent.action.VIEW" />
+                 <action android:name="android.intent.action.PICK" />
+                 <category android:name="android.intent.category.DEFAULT" />
+             </intent-filter>
+         </activity>
+
+         <activity android:name=".StkInputActivity"
+            android:label="@string/app_name"
+            android:icon="@drawable/ic_launcher_sim_toolkit"
+            android:theme="@android:style/Theme.Holo"
+            android:configChanges="orientation|locale|screenSize|keyboardHidden|layoutDirection"
+            android:exported="false"
+            android:taskAffinity="android.task.stk.task">
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <action android:name="android.intent.action.EDIT" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".StkDialogActivity"
+            android:directBootAware="true"
+            android:configChanges="orientation|locale|screenSize|mcc|mnc|touchscreen|keyboard|keyboardHidden|navigation|screenLayout|fontScale|uiMode|smallestScreenSize|layoutDirection"
+            android:theme="@android:style/Theme.Holo.Dialog"
+            android:exported="false"
+            android:taskAffinity="android.task.stk.task">
+        </activity>
+
+        <activity android:name=".ToneDialog"
+            android:exported="false"
+            android:theme="@android:style/Theme.Holo.Dialog"
+            android:configChanges="orientation|locale|screenSize|layoutDirection" >
+        </activity>
+
+        <receiver android:name="com.android.stk.StkCmdReceiver"
+            android:directBootAware="true">
+            <intent-filter>
+                <action android:name= "android.intent.action.stk.command" />
+                <action android:name= "android.intent.action.stk.session_end" />
+                <action android:name= "android.intent.action.stk.icc_status_change" />
+                <action android:name= "android.intent.action.stk.alpha_notify" />
+            </intent-filter>
+        </receiver>
+
+        <receiver android:name="com.android.stk.EventReceiver"
+            android:directBootAware="true">
+            <intent-filter>
+                <action android:name="android.intent.action.stk.USER_ACTIVITY" />
+                <action android:name="android.intent.action.LOCALE_CHANGED" />
+                <action android:name="android.intent.action.stk.BROWSER_TERMINATION" />
+            </intent-filter>
+        </receiver>
+        <receiver android:name="com.android.stk.BootCompletedReceiver"
+            android:directBootAware="true">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+                <action android:name="android.intent.action.SIM_STATE_CHANGED" />
+                <action android:name="android.intent.action.RADIO_TECHNOLOGY" />
+                <action android:name="android.intent.action.USER_INITIALIZE" />
+            </intent-filter>
+        </receiver>
+        <!--BEGIN-chenhu-->
+        <receiver android:name=".ProactiveSetTitleReceiver">
+            <intent-filter>
+                <action android:name="proactive_set_stkselection_app_title" />
+                <action android:name="android.intent.action.SIM_STATE_CHANGED" />
+            </intent-filter>
+        </receiver>
+        <!--END-chenhu-->
+        <service android:name="StkAppService"
+                android:directBootAware="true"/>
+
+    </application>
+</manifest>
Index: vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/src/com/android/stk/ProactiveSetTitleReceiver.java
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/src/com/android/stk/ProactiveSetTitleReceiver.java	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/vendor/mediatek/proprietary/packages/apps/Stk/src/com/android/stk/ProactiveSetTitleReceiver.java	(revision 15112)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.stk;
+
+import android.content.BroadcastReceiver;  
+import android.content.ComponentName;  
+import android.content.Context;  
+import android.content.Intent;  
+import android.content.pm.PackageManager;  
+import android.util.Log;  
+import android.os.SystemProperties;  
+import com.android.internal.telephony.TelephonyIntents;
+import android.telephony.TelephonyManager;
+
+public class ProactiveSetTitleReceiver extends BroadcastReceiver {
+    PackageManager pm;  
+    @Override  
+    public void onReceive(Context context, Intent intent) {
+		String action = intent.getAction();
+		String persoStkAppName = null;
+		TelephonyManager telMgr = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
+		pm = context.getPackageManager(); 
+		int simState = telMgr.getSimState();
+		if (action.equals("proactive_set_stkselection_app_title")) { 
+			int simId = intent.getIntExtra("simId", 0);  
+			persoStkAppName = SystemProperties.get("gsm.stk.perso.app_title");
+			Log.i("Stk", "insert persoStkAppName = " + persoStkAppName);
+			String defaultStkAppName = "";
+			try {
+				defaultStkAppName = pm.getApplicationLabel(pm.getApplicationInfo("com.android.stk",0)).toString();
+			} catch (PackageManager.NameNotFoundException e) {
+				e.printStackTrace();
+			}
+		}
+		if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+			if (TelephonyManager.SIM_STATE_ABSENT == simState) {
+				SystemProperties.set("gsm.stk.perso.app_title", "");
+				Log.i("Stk", "persoStkAppName = " + persoStkAppName);
+			}
+		}
+        setAppState(false);
+        setAppState(true);
+    }
+
+    private void setAppState(boolean install) {
+        Log.i("Stk", "setAppState install = " + install);
+        ComponentName cName = new ComponentName("com.android.stk", "com.android.stk.StkMain");
+        int state = install ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED: PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
+        try {
+            pm.setComponentEnabledSetting(cName, state, PackageManager.DONT_KILL_APP);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
\ No newline at end of file
Index: vendor/branch/5058A_VIVA_BOLIVIA/device/ausshine/aus6739_66_n1/system.prop
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/device/ausshine/aus6739_66_n1/system.prop	(revision 15111)
+++ vendor/branch/5058A_VIVA_BOLIVIA/device/ausshine/aus6739_66_n1/system.prop	(revision 15112)
@@ -99,4 +99,6 @@
 ro.product.first_api_level=25
 
 persist.sys.timezone =America/La_Paz
-persist.radio.fd.on.only.r8=1
\ No newline at end of file
+persist.radio.fd.on.only.r8=1
+
+ro.telcel.enabled = true
\ No newline at end of file
Index: vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMFileHandler.java
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMFileHandler.java	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMFileHandler.java	(revision 15112)
@@ -0,0 +1,106 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.uicc;
+
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+
+/**
+ * {@hide}
+ */
+public final class SIMFileHandler extends IccFileHandler implements IccConstants {
+    static final String LOG_TAG = "SIMFileHandler";
+
+    //***** Instance Variables
+
+    //***** Constructor
+
+    public SIMFileHandler(UiccCardApplication app, String aid, CommandsInterface ci) {
+        super(app, aid, ci);
+    }
+
+    //***** Overridden from IccFileHandler
+
+    @Override
+    protected String getEFPath(int efid) {
+        // TODO(): DF_GSM can be 7F20 or 7F21 to handle backward compatibility.
+        // Implement this after discussion with OEMs.
+        switch(efid) {
+        case EF_SMS:
+        // MTK-START
+        case EF_SMSP:   // [ALPS01206315] Support EF_SMSP
+        // MTK-END
+            return MF_SIM + DF_TELECOM;
+
+        case EF_EXT6:
+        case EF_MWIS:
+        case EF_MBI:
+        case EF_SPN:
+        case EF_AD:
+        case EF_MBDN:
+        case EF_PNN:
+        case EF_SPDI:
+        case EF_SST:
+        case EF_CFIS:
+        case EF_GID1:
+        case EF_GID2:
+            return MF_SIM + DF_GSM;
+
+        case EF_MAILBOX_CPHS:
+        case EF_VOICE_MAIL_INDICATOR_CPHS:
+        case EF_CFF_CPHS:
+        case EF_SPN_CPHS:
+        case EF_SPN_SHORT_CPHS:
+        case EF_INFO_CPHS:
+        case EF_CSP_CPHS:
+        case EF_SUME: //add by chenhu
+            return MF_SIM + DF_GSM;
+        // MTK-START
+        case EF_ECC:
+        case EF_OPL:
+        // MTK-END
+            return MF_SIM + DF_GSM;
+        // MTK-START
+        case EF_RAT: // ALPS00302702 RAT balancing (ADF(USIM)/7F66/5F30/EF_RAT)
+            return DF_ADF + "7F66" + "5F30";
+        case EF_CSIM_IMSIM:
+            return MF_SIM + DF_CDMA;
+        // MTK-END
+        }
+        String path = getCommonIccEFPath(efid);
+        if (path == null) {
+            Rlog.e(LOG_TAG, "Error: EF Path being returned in null");
+        }
+        return path;
+    }
+
+    @Override
+    protected void logd(String msg) {
+        Rlog.d(LOG_TAG, msg);
+    }
+
+    @Override
+    protected void loge(String msg) {
+        Rlog.e(LOG_TAG, msg);
+    }
+}
Index: vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java	(revision 15112)
@@ -0,0 +1,4255 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.uicc;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Message;
+// MTK-START
+import android.os.SystemProperties;
+import android.telephony.TelephonyManager;
+// MTK-END
+import android.telephony.CarrierConfigManager;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.text.TextUtils;
+import android.telephony.Rlog;
+import android.content.res.Resources;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.MccTable;
+// MTK-START
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.ServiceStateTracker;
+// MTK-END
+import com.android.internal.telephony.SmsConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.gsm.SimTlv;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
+
+// MTK-START
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_DEFAULT_NAME;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneFactory;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.telephony.SubscriptionManager;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
+import android.app.ActivityManagerNative;
+import android.os.UserHandle;
+import static android.Manifest.permission.READ_PHONE_STATE;
+// MTK-END
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+// MTK-START
+import android.content.BroadcastReceiver;
+import com.mediatek.common.telephony.ITelephonyExt;
+import com.mediatek.common.MPlugin;
+import android.app.AlertDialog;
+import android.os.PowerManager;
+import android.view.WindowManager;
+import android.content.DialogInterface;
+
+// MTK-END
+
+/**
+ * {@hide}
+ */
+public class SIMRecords extends IccRecords {
+    protected static final String LOG_TAG = "SIMRecords";
+
+    private static final boolean CRASH_RIL = false;
+
+    // ***** Instance Variables
+
+    VoiceMailConstants mVmConfig;
+
+
+    SpnOverride mSpnOverride;
+
+    // ***** Cached SIM State; cleared on channel close
+
+    private int mCallForwardingStatus;
+
+
+    /**
+     * States only used by getSpnFsm FSM
+     */
+    private GetSpnFsmState mSpnState;
+
+    /** CPHS service information (See CPHS 4.2 B.3.1.1)
+     *  It will be set in onSimReady if reading GET_CPHS_INFO successfully
+     *  mCphsInfo[0] is CPHS Phase
+     *  mCphsInfo[1] and mCphsInfo[2] is CPHS Service Table
+     */
+    private byte[] mCphsInfo = null;
+    boolean mCspPlmnEnabled = true;
+
+    byte[] mEfMWIS = null;
+    byte[] mEfCPHS_MWI =null;
+    byte[] mEfCff = null;
+    byte[] mEfCfis = null;
+
+    byte[] mEfLi = null;
+    byte[] mEfPl = null;
+
+    int mSpnDisplayCondition;
+    // Numeric network codes listed in TS 51.011 EF[SPDI]
+    ArrayList<String> mSpdiNetworks = null;
+
+    String mPnnHomeName = null;
+
+    UsimServiceTable mUsimServiceTable;
+
+    @Override
+    public String toString() {
+        return "SimRecords: " + super.toString()
+                + " mVmConfig" + mVmConfig
+                + " mSpnOverride=" + "mSpnOverride"
+                + " callForwardingEnabled=" + mCallForwardingStatus
+                + " spnState=" + mSpnState
+                + " mCphsInfo=" + mCphsInfo
+                + " mCspPlmnEnabled=" + mCspPlmnEnabled
+                + " efMWIS=" + mEfMWIS
+                + " efCPHS_MWI=" + mEfCPHS_MWI
+                + " mEfCff=" + mEfCff
+                + " mEfCfis=" + mEfCfis
+                + " getOperatorNumeric=" + getOperatorNumeric();
+    }
+
+    // ***** Constants
+
+    // From TS 51.011 EF[SPDI] section
+    static final int TAG_SPDI = 0xA3;
+    static final int TAG_SPDI_PLMN_LIST = 0x80;
+
+    // Full Name IEI from TS 24.008
+    static final int TAG_FULL_NETWORK_NAME = 0x43;
+
+    // Short Name IEI from TS 24.008
+    static final int TAG_SHORT_NETWORK_NAME = 0x45;
+
+    // active CFF from CPHS 4.2 B.4.5
+    static final int CFF_UNCONDITIONAL_ACTIVE = 0x0a;
+    static final int CFF_UNCONDITIONAL_DEACTIVE = 0x05;
+    static final int CFF_LINE1_MASK = 0x0f;
+    static final int CFF_LINE1_RESET = 0xf0;
+
+    // CPHS Service Table (See CPHS 4.2 B.3.1)
+    private static final int CPHS_SST_MBN_MASK = 0x30;
+    private static final int CPHS_SST_MBN_ENABLED = 0x30;
+
+    // EF_CFIS related constants
+    // Spec reference TS 51.011 section 10.3.46.
+    private static final int CFIS_BCD_NUMBER_LENGTH_OFFSET = 2;
+    private static final int CFIS_TON_NPI_OFFSET = 3;
+    private static final int CFIS_ADN_CAPABILITY_ID_OFFSET = 14;
+    private static final int CFIS_ADN_EXTENSION_ID_OFFSET = 15;
+
+    // ***** Event Constants
+    private static final int EVENT_GET_IMSI_DONE = 3;
+    private static final int EVENT_GET_ICCID_DONE = 4;
+    private static final int EVENT_GET_MBI_DONE = 5;
+    private static final int EVENT_GET_MBDN_DONE = 6;
+    private static final int EVENT_GET_MWIS_DONE = 7;
+    private static final int EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE = 8;
+    protected static final int EVENT_GET_AD_DONE = 9; // Admin data on SIM
+    protected static final int EVENT_GET_MSISDN_DONE = 10;
+    private static final int EVENT_GET_CPHS_MAILBOX_DONE = 11;
+    private static final int EVENT_GET_SPN_DONE = 12;
+    private static final int EVENT_GET_SPDI_DONE = 13;
+    private static final int EVENT_UPDATE_DONE = 14;
+    private static final int EVENT_GET_PNN_DONE = 15;
+    protected static final int EVENT_GET_SST_DONE = 17;
+    private static final int EVENT_GET_ALL_SMS_DONE = 18;
+    private static final int EVENT_MARK_SMS_READ_DONE = 19;
+    private static final int EVENT_SET_MBDN_DONE = 20;
+    private static final int EVENT_SMS_ON_SIM = 21;
+    private static final int EVENT_GET_SMS_DONE = 22;
+    private static final int EVENT_GET_CFF_DONE = 24;
+    private static final int EVENT_SET_CPHS_MAILBOX_DONE = 25;
+    private static final int EVENT_GET_INFO_CPHS_DONE = 26;
+    // private static final int EVENT_SET_MSISDN_DONE = 30; Defined in IccRecords as 30
+    private static final int EVENT_SIM_REFRESH = 31;
+    private static final int EVENT_GET_CFIS_DONE = 32;
+    private static final int EVENT_GET_CSP_CPHS_DONE = 33;
+    private static final int EVENT_GET_GID1_DONE = 34;
+    private static final int EVENT_APP_LOCKED = 35;
+    private static final int EVENT_GET_GID2_DONE = 36;
+    private static final int EVENT_CARRIER_CONFIG_CHANGED = 37;
+
+    // MTK-START
+    private static final int EVENT_RADIO_AVAILABLE = 41;
+    private static final int EVENT_GET_LI_DONE = 42;
+    private static final int EVENT_GET_ELP_DONE = 43;
+    private static final int EVENT_DUAL_IMSI_READY = 44;
+
+    private static final int EVENT_QUERY_MENU_TITLE_DONE = 53;
+
+    private static final int EVENT_GET_SIM_ECC_DONE = 102;
+    private static final int EVENT_GET_USIM_ECC_DONE = 103;
+    private static final int EVENT_GET_ALL_OPL_DONE = 104;
+    private static final int EVENT_GET_CPHSONS_DONE = 105;
+    private static final int EVENT_GET_SHORT_CPHSONS_DONE = 106;
+    private static final int EVENT_QUERY_ICCID_DONE = 107;
+    private static final int EVENT_DELAYED_SEND_PHB_CHANGE = 200;
+    private static final int EVENT_RADIO_STATE_CHANGED = 201;
+    private static final int EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED = 203; // ALPS00302698 ENS
+    private static final int EVENT_GET_RAT_DONE = 204; // ALPS00302702 RAT balancing
+    private static final int EVENT_QUERY_ICCID_DONE_FOR_HOT_SWAP = 205;
+    private static final int EVENT_GET_NEW_MSISDN_DONE = 206;
+    private static final int EVENT_GET_PSISMSC_DONE = 207; // USim authentication
+    private static final int EVENT_GET_SMSP_DONE = 208; // USim authentication
+    private static final int EVENT_GET_GBABP_DONE = 209;
+    private static final int EVENT_GET_GBANL_DONE = 210;
+    private static final int EVENT_CFU_IND = 211;
+    private static final int EVENT_IMSI_REFRESH_QUERY = 212;
+    private static final int EVENT_IMSI_REFRESH_QUERY_DONE = 213;
+    private static final int EVENT_GET_EF_ICCID_DONE = 300;
+
+    /* Remote SIM ME lock */
+    private static final int EVENT_MELOCK_CHANGED = 400;
+    // MTK-END
+
+    // Lookup table for carriers known to produce SIMs which incorrectly indicate MNC length.
+
+    private static final String[] MCCMNC_CODES_HAVING_3DIGITS_MNC = {
+        "302370", "302720", "310260",
+        "405025", "405026", "405027", "405028", "405029", "405030", "405031", "405032",
+        "405033", "405034", "405035", "405036", "405037", "405038", "405039", "405040",
+        "405041", "405042", "405043", "405044", "405045", "405046", "405047", "405750",
+        "405751", "405752", "405753", "405754", "405755", "405756", "405799", "405800",
+        "405801", "405802", "405803", "405804", "405805", "405806", "405807", "405808",
+        "405809", "405810", "405811", "405812", "405813", "405814", "405815", "405816",
+        "405817", "405818", "405819", "405820", "405821", "405822", "405823", "405824",
+        "405825", "405826", "405827", "405828", "405829", "405830", "405831", "405832",
+        "405833", "405834", "405835", "405836", "405837", "405838", "405839", "405840",
+        "405841", "405842", "405843", "405844", "405845", "405846", "405847", "405848",
+        "405849", "405850", "405851", "405852", "405853", "405875", "405876", "405877",
+        "405878", "405879", "405880", "405881", "405882", "405883", "405884", "405885",
+        "405886", "405908", "405909", "405910", "405911", "405912", "405913", "405914",
+        "405915", "405916", "405917", "405918", "405919", "405920", "405921", "405922",
+        "405923", "405924", "405925", "405926", "405927", "405928", "405929", "405930",
+        "405931", "405932", "502142", "502143", "502145", "502146", "502147", "502148"
+    };
+    // MTK-START
+    private static final String KEY_SIM_ID = "SIM_ID";
+
+    private boolean isValidMBI = false;
+
+    // ALPS00302702 RAT balancing
+    private boolean mEfRatLoaded = false;
+    private byte[] mEfRat = null;
+
+    private static final String[] LANGUAGE_CODE_FOR_LP = {
+        "de", "en", "it", "fr", "es", "nl", "sv", "da", "pt", "fi",
+        "no", "el", "tr", "hu", "pl", "",
+        "cs", "he", "ar", "ru", "is", "", "", "", "", "",
+        "", "", "", "", "", ""
+    };
+
+    int mSlotId;
+
+    private ITelephonyExt mTelephonyExt;
+    private BroadcastReceiver mSimReceiver;
+    private BroadcastReceiver mSubReceiver;
+    private RadioTechnologyChangedReceiver mRTC;
+    String cphsOnsl;
+    String cphsOnss;
+    private int iccIdQueryState = -1; // -1: init, 0: query error, 1: query successful
+    private boolean hasQueryIccId;
+
+    private int efLanguageToLoad = 0;
+    private boolean mIsPhbEfResetDone = false;
+
+    private String mSimImsi = null;
+    private byte[] mEfSST = null;
+    private byte[] mEfELP = null;
+    private byte[] mEfPsismsc = null;
+    private byte[] mEfSmsp = null;
+
+    static final String[] SIMRECORD_PROPERTY_RIL_PHB_READY  = {
+        "gsm.sim.ril.phbready",
+        "gsm.sim.ril.phbready.2",
+        "gsm.sim.ril.phbready.3",
+        "gsm.sim.ril.phbready.4"
+    };
+
+    static final String[] SIMRECORD_PROPERTY_RIL_PUK1  = {
+        "gsm.sim.retry.puk1",
+        "gsm.sim.retry.puk1.2",
+        "gsm.sim.retry.puk1.3",
+        "gsm.sim.retry.puk1.4",
+    };
+
+    private String[] SIM_RECORDS_PROPERTY_ECC_LIST = {
+        "ril.ecclist",
+        "ril.ecclist1",
+        "ril.ecclist2",
+        "ril.ecclist3",
+    };
+
+    private boolean mPhbReady = false;
+    private boolean mPhbWaitSub = false;
+    private boolean mSIMInfoReady = false;
+
+    public static class OperatorName {
+        public String sFullName;
+        public String sShortName;
+    }
+
+    /*Operator list recode
+    * include numeric mcc mnc code
+    * and a range of LAC, the operator name index in PNN
+    */
+    public static class OplRecord {
+        public String sPlmn;
+        public int nMinLAC;
+        public int nMaxLAC;
+        public int nPnnIndex;
+    }
+
+    //Operator name listed in TS 51.011 EF[PNN] for plmn in operator list(EF[OPL])
+    private ArrayList<OperatorName> mPnnNetworkNames = null;
+    //Operator list in TS 51.011 EF[OPL]
+    private ArrayList<OplRecord> mOperatorList = null;
+
+    private String mSpNameInEfSpn = null; // MVNO-API
+
+    private String mMenuTitleFromEf = null;
+
+    //3g dongle
+    private boolean isDispose = false;
+    private static final int[] simServiceNumber = {
+        1, 17, 51, 52, 54, 55, 56, 0, 12, 3, 7, 0, 0
+    };
+
+    private static final int[] usimServiceNumber = {
+        0, 19, 45, 46, 48, 49, 51, 71, 12, 2, 0, 42, 0
+    };
+
+    private UiccCard mUiccCard;
+    private UiccController mUiccController;
+    private String mGbabp;
+    private ArrayList<byte[]> mEfGbanlList;
+    private String[] mGbanl;
+
+    private Phone mPhone;
+
+    String mEfEcc = "";
+    // MTK-END
+
+    // ***** Constructor
+
+    public SIMRecords(UiccCardApplication app, Context c, CommandsInterface ci) {
+        super(app, c, ci);
+
+        // MTK-START
+        mSlotId = app.getSlotId();
+        mUiccController = UiccController.getInstance();
+        mUiccCard = mUiccController.getUiccCard(mSlotId);
+        log("mUiccCard Instance = " + mUiccCard);
+
+        mPhone = PhoneFactory.getPhone(app.getPhoneId());
+
+        //mAdnCache = new AdnRecordCache(mFh);
+        mAdnCache = new AdnRecordCache(mFh, ci, app);
+        ///M: Move UPBM code to here for phone restart event to contacts app.begin
+        Intent intent = new Intent();
+        intent.setAction("android.intent.action.ACTION_PHONE_RESTART");
+        intent.putExtra("SimId", mSlotId);
+        mContext.sendBroadcast(intent);
+        // MTK-END
+
+        mVmConfig = new VoiceMailConstants();
+        // MTK-START
+        //mSpnOverride = new SpnOverride();
+        mSpnOverride = SpnOverride.getInstance();
+        // MTK-END
+
+        mRecordsRequested = false;  // No load request is made till SIM ready
+
+        // recordsToLoad is set to 0 because no requests are made yet
+        mRecordsToLoad = 0;
+
+        // MTK-START
+        cphsOnsl = null;
+        cphsOnss = null;
+        hasQueryIccId = false;
+        // MTK-END
+        mCi.setOnSmsOnSim(this, EVENT_SMS_ON_SIM, null);
+        mCi.registerForIccRefresh(this, EVENT_SIM_REFRESH, null);
+        // MTK-START
+        mCi.registerForPhbReady(this, EVENT_PHB_READY, null);
+        /* register for CFU info flag notification */
+        mCi.registerForCallForwardingInfo(this, EVENT_CFU_IND, null);
+        mCi.registerForRadioStateChanged(this, EVENT_RADIO_STATE_CHANGED, null);
+        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
+        mCi.registerForEfCspPlmnModeBitChanged(this, EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED, null);
+        mCi.registerForMelockChanged(this, EVENT_MELOCK_CHANGED, null);
+
+        mCi.registerForImsiRefreshDone(this, EVENT_IMSI_REFRESH_QUERY, null);
+        // MTK-END
+
+        // Start off by setting empty state
+        resetRecords();
+        mParentApp.registerForReady(this, EVENT_APP_READY, null);
+        mParentApp.registerForLocked(this, EVENT_APP_LOCKED, null);
+
+        // MTK-START
+        mSimReceiver = new SIMBroadCastReceiver();
+        IntentFilter filter = new IntentFilter();
+        filter.addAction("com.mediatek.dm.LAWMO_WIPE");
+        filter.addAction("action_pin_dismiss");
+        filter.addAction("action_melock_dismiss");
+        filter.addAction("android.intent.action.ACTION_SHUTDOWN_IPO");
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        mContext.registerReceiver(mSimReceiver, filter);
+
+        mSubReceiver = new SubBroadCastReceiver();
+        IntentFilter subFilter = new IntentFilter();
+        subFilter.addAction(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        mContext.registerReceiver(mSubReceiver, subFilter);
+        /** M: Bug Fix for ALPS02189616 */
+        // register new receiver for RADIO_TECHNOLOGY_CHANGED
+        mRTC = new RadioTechnologyChangedReceiver();
+        IntentFilter rtcFilter = new IntentFilter();
+        // M: PHB Revise
+        rtcFilter.addAction(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
+        mContext.registerReceiver(mRTC, rtcFilter);
+
+        // ALPS01099419, mAdnCache is needed before onUpdateIccAvailability.
+        if (DBG) log("SIMRecords updateIccRecords");
+        if (mPhone.getIccPhoneBookInterfaceManager() != null) {
+            mPhone.getIccPhoneBookInterfaceManager().updateIccRecords(this);
+        }
+
+        //ALPS00566446: Check if phb is ready or not, if phb was already ready,
+        //we won't wait for phb ready.
+        if (isPhbReady()) {
+            if (DBG) log("Phonebook is ready.");
+            mPhbReady = true;
+            broadcastPhbStateChangedIntent(mPhbReady);
+        }
+        try {
+            mTelephonyExt = MPlugin.createInstance(ITelephonyExt.class.getName(), mContext);
+        } catch (Exception e) {
+            loge("Fail to create plug-in");
+            e.printStackTrace();
+        }
+        // MTK-END
+
+        if (DBG) log("SIMRecords X ctor this=" + this);
+
+        IntentFilter intentfilter = new IntentFilter();
+        intentfilter.addAction(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
+        c.registerReceiver(mReceiver, intentfilter);
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
+                sendMessage(obtainMessage(EVENT_CARRIER_CONFIG_CHANGED));
+            }
+        }
+    };
+
+    @Override
+    public void dispose() {
+        if (DBG) log("Disposing SIMRecords this=" + this);
+        //Unregister for all events
+        // MTK-START
+        //3g dongle
+        isDispose = true;
+        // MTK-END
+        mCi.unregisterForIccRefresh(this);
+        mCi.unSetOnSmsOnSim(this);
+        // MTK-START
+
+        mCi.unregisterForCallForwardingInfo(this);
+        mCi.unregisterForPhbReady(this);
+        mCi.unregisterForRadioStateChanged(this);
+        mCi.unregisterForEfCspPlmnModeBitChanged(this);
+        mCi.unregisterForMelockChanged(this);
+        // MTK-END
+        mParentApp.unregisterForReady(this);
+        mParentApp.unregisterForLocked(this);
+        // MTK-START
+        mContext.unregisterReceiver(mSimReceiver);
+        mContext.unregisterReceiver(mSubReceiver);
+        mContext.unregisterReceiver(mReceiver);
+        // M: PHB Revise
+        mContext.unregisterReceiver(mRTC);
+        mPhbWaitSub = false;
+        // MTK-END
+        resetRecords();
+        // MTK-START
+        mAdnCache.reset();
+        setPhbReady(false);
+        mIccId = null;
+        mImsi = null;
+        // MTK-END
+
+        // MTK-START
+        log("dispose(), clean CFU icon");
+        mCallForwardingStatus = CALL_FORWARDING_STATUS_DISABLED;
+        mPhone.clearCallForwardingIndicatorFromSharedPref();
+        mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
+        // MTK-END
+        super.dispose();
+    }
+
+    @Override
+    protected void finalize() {
+        if(DBG) log("finalized");
+    }
+
+    protected void resetRecords() {
+        mImsi = null;
+        mMsisdn = null;
+        mVoiceMailNum = null;
+        mMncLength = UNINITIALIZED;
+        log("setting0 mMncLength" + mMncLength);
+        mIccId = null;
+        mFullIccId = null;
+        // -1 means no EF_SPN found; treat accordingly.
+        mSpnDisplayCondition = -1;
+        mEfMWIS = null;
+        mEfCPHS_MWI = null;
+        mSpdiNetworks = null;
+        mPnnHomeName = null;
+        mGid1 = null;
+        mGid2 = null;
+
+        mAdnCache.reset();
+
+        log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
+        log("update icc_operator_numeric=" + null);
+        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), "");
+        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), "");
+        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), "");
+        // MTK-START
+        setSystemProperty(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, null);
+        // MTK-END
+
+        // recordsRequested is set to false indicating that the SIM
+        // read requests made so far are not valid. This is set to
+        // true only when fresh set of read requests are made.
+        mRecordsRequested = false;
+    }
+
+
+    //***** Public Methods
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String getIMSI() {
+        return mImsi;
+    }
+
+    @Override
+    public String getMsisdnNumber() {
+        return mMsisdn;
+    }
+
+    @Override
+    public String getGid1() {
+        return mGid1;
+    }
+
+    @Override
+    public String getGid2() {
+        return mGid2;
+    }
+
+    @Override
+    public UsimServiceTable getUsimServiceTable() {
+        return mUsimServiceTable;
+    }
+
+    private int getExtFromEf(int ef) {
+        int ext;
+        switch (ef) {
+            case EF_MSISDN:
+                /* For USIM apps use EXT5. (TS 31.102 Section 4.2.37) */
+                if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                    ext = EF_EXT5;
+                } else {
+                    ext = EF_EXT1;
+                }
+                break;
+            default:
+                ext = EF_EXT1;
+        }
+        return ext;
+    }
+
+    /**
+     * Set subscriber number to SIM record
+     *
+     * The subscriber number is stored in EF_MSISDN (TS 51.011)
+     *
+     * When the operation is complete, onComplete will be sent to its handler
+     *
+     * @param alphaTag alpha-tagging of the dailing nubmer (up to 10 characters)
+     * @param number dailing nubmer (up to 20 digits)
+     *        if the number starts with '+', then set to international TOA
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    @Override
+    public void setMsisdnNumber(String alphaTag, String number,
+            Message onComplete) {
+
+        // If the SIM card is locked by PIN, we will set EF_MSISDN fail.
+        // In that case, msisdn and msisdnTag should not be update.
+        mNewMsisdn = number;
+        mNewMsisdnTag = alphaTag;
+
+        if(DBG) log("Set MSISDN: " + mNewMsisdnTag + " " + /*mNewMsisdn*/
+                Rlog.pii(LOG_TAG, mNewMsisdn));
+
+        AdnRecord adn = new AdnRecord(mNewMsisdnTag, mNewMsisdn);
+
+        new AdnRecordLoader(mFh).updateEF(adn, EF_MSISDN, getExtFromEf(EF_MSISDN), 1, null,
+                obtainMessage(EVENT_SET_MSISDN_DONE, onComplete));
+    }
+
+    @Override
+    public String getMsisdnAlphaTag() {
+        return mMsisdnTag;
+    }
+
+    @Override
+    public String getVoiceMailNumber() {
+        // MTK-START
+        log("getVoiceMailNumber " + mVoiceMailNum);
+        // MTK-END
+        return mVoiceMailNum;
+    }
+
+    /**
+     * Set voice mail number to SIM record
+     *
+     * The voice mail number can be stored either in EF_MBDN (TS 51.011) or
+     * EF_MAILBOX_CPHS (CPHS 4.2)
+     *
+     * If EF_MBDN is available, store the voice mail number to EF_MBDN
+     *
+     * If EF_MAILBOX_CPHS is enabled, store the voice mail number to EF_CHPS
+     *
+     * So the voice mail number will be stored in both EFs if both are available
+     *
+     * Return error only if both EF_MBDN and EF_MAILBOX_CPHS fail.
+     *
+     * When the operation is complete, onComplete will be sent to its handler
+     *
+     * @param alphaTag alpha-tagging of the dailing nubmer (upto 10 characters)
+     * @param voiceNumber dailing nubmer (upto 20 digits)
+     *        if the number is start with '+', then set to international TOA
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    @Override
+    public void setVoiceMailNumber(String alphaTag, String voiceNumber,
+            Message onComplete) {
+        // MTK-START
+        log("setVoiceMailNumber, mIsVoiceMailFixed " + mIsVoiceMailFixed +
+            ", mMailboxIndex " + mMailboxIndex + ", mMailboxIndex " + mMailboxIndex);
+        // MTK-END
+        if (mIsVoiceMailFixed) {
+            AsyncResult.forMessage((onComplete)).exception =
+                    new IccVmFixedException("Voicemail number is fixed by operator");
+            onComplete.sendToTarget();
+            return;
+        }
+
+        mNewVoiceMailNum = voiceNumber;
+        mNewVoiceMailTag = alphaTag;
+
+        AdnRecord adn = new AdnRecord(mNewVoiceMailTag, mNewVoiceMailNum);
+
+        if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
+
+            new AdnRecordLoader(mFh).updateEF(adn, EF_MBDN, EF_EXT6,
+                    mMailboxIndex, null,
+                    obtainMessage(EVENT_SET_MBDN_DONE, onComplete));
+
+        } else if (isCphsMailboxEnabled()) {
+            // MTK-START
+            log("setVoiceMailNumber,load EF_MAILBOX_CPHS");
+            // MTK-END
+            new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS,
+                    EF_EXT1, 1, null,
+                    obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onComplete));
+
+        } else {
+            // MTK-START
+            log("setVoiceMailNumber,Update SIM voice mailbox error");
+            // MTK-END
+            AsyncResult.forMessage((onComplete)).exception =
+                    new IccVmNotSupportedException("Update SIM voice mailbox error");
+            onComplete.sendToTarget();
+        }
+    }
+
+    @Override
+    public String getVoiceMailAlphaTag()
+    {
+        return mVoiceMailTag;
+    }
+
+    /**
+     * Sets the SIM voice message waiting indicator records
+     * @param line GSM Subscriber Profile Number, one-based. Only '1' is supported
+     * @param countWaiting The number of messages waiting, if known. Use
+     *                     -1 to indicate that an unknown number of
+     *                      messages are waiting
+     */
+    @Override
+    public void
+    setVoiceMessageWaiting(int line, int countWaiting) {
+        if (line != 1) {
+            // only profile 1 is supported
+            return;
+        }
+
+        try {
+            if (mEfMWIS != null) {
+                // TS 51.011 10.3.45
+
+                // lsb of byte 0 is 'voicemail' status
+                mEfMWIS[0] = (byte)((mEfMWIS[0] & 0xfe)
+                                    | (countWaiting == 0 ? 0 : 1));
+
+                // byte 1 is the number of voice messages waiting
+                if (countWaiting < 0) {
+                    // The spec does not define what this should be
+                    // if we don't know the count
+                    mEfMWIS[1] = 0;
+                } else {
+                    mEfMWIS[1] = (byte) countWaiting;
+                }
+
+                mFh.updateEFLinearFixed(
+                    EF_MWIS, 1, mEfMWIS, null,
+                    obtainMessage (EVENT_UPDATE_DONE, EF_MWIS, 0));
+            }
+
+            // MTK-START
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                log("[setVoiceMessageWaiting] It is USIM card, skip write CPHS file");
+            } else {
+            // MTK-END
+                if (mEfCPHS_MWI != null) {
+                        // Refer CPHS4_2.WW6 B4.2.3
+                    mEfCPHS_MWI[0] = (byte)((mEfCPHS_MWI[0] & 0xf0)
+                                | (countWaiting == 0 ? 0x5 : 0xa));
+                    mFh.updateEFTransparent(
+                        EF_VOICE_MAIL_INDICATOR_CPHS, mEfCPHS_MWI,
+                        obtainMessage (EVENT_UPDATE_DONE, EF_VOICE_MAIL_INDICATOR_CPHS));
+            // MTK-START
+                }
+            // MTK-END
+            }
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            logw("Error saving voice mail state to SIM. Probably malformed SIM record", ex);
+        }
+    }
+
+    // MTK-START
+    /* Provide a API to GsmCdmaPhone to check EfCfis. However, we don't use AOSP method to
+     * distinguish EF_CFIS. Because MD does't check the MSP, we need to align MD's way.
+     */
+    public boolean checkEfCfis() {
+        boolean isValid = (mEfCfis != null) && (mEfCfis.length == 16);
+        log("mEfCfis is null? = " + (mEfCfis == null));
+        return isValid;
+    }
+    // MTK-END
+
+    // Validate data is !null and the MSP (Multiple Subscriber Profile)
+    // byte is between 1 and 4. See ETSI TS 131 102 v11.3.0 section 4.2.64.
+    private boolean validEfCfis(byte[] data) {
+        return ((data != null) && (data[0] >= 1) && (data[0] <= 4));
+    }
+
+    public int getVoiceMessageCount() {
+        boolean voiceMailWaiting = false;
+        int countVoiceMessages = 0;
+        if (mEfMWIS != null) {
+            // Use this data if the EF[MWIS] exists and
+            // has been loaded
+            // Refer TS 51.011 Section 10.3.45 for the content description
+            voiceMailWaiting = ((mEfMWIS[0] & 0x01) != 0);
+            countVoiceMessages = mEfMWIS[1] & 0xff;
+
+            if (voiceMailWaiting && countVoiceMessages == 0) {
+                // Unknown count = -1
+                countVoiceMessages = -1;
+            }
+            if(DBG) log(" VoiceMessageCount from SIM MWIS = " + countVoiceMessages);
+        } else if (mEfCPHS_MWI != null) {
+            // use voice mail count from CPHS
+            int indicator = (int) (mEfCPHS_MWI[0] & 0xf);
+
+            // Refer CPHS4_2.WW6 B4.2.3
+            if (indicator == 0xA) {
+                // Unknown count = -1
+                countVoiceMessages = -1;
+            } else if (indicator == 0x5) {
+                countVoiceMessages = 0;
+            }
+            if(DBG) log(" VoiceMessageCount from SIM CPHS = " + countVoiceMessages);
+        }
+        return countVoiceMessages;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getVoiceCallForwardingFlag() {
+        return mCallForwardingStatus;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
+        Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag: " + enable);
+
+        if (line != 1) return; // only line 1 is supported
+
+        mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED :
+                CALL_FORWARDING_STATUS_DISABLED;
+
+        Rlog.d(LOG_TAG, " mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
+        mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
+
+        try {
+            // if (validEfCfis(mEfCfis)) {
+            // MTK-START
+            if (checkEfCfis()) {
+            // MTK-END
+                // lsb is of byte f1 is voice status
+                if (enable) {
+                    mEfCfis[1] |= 1;
+                } else {
+                    mEfCfis[1] &= 0xfe;
+                }
+
+                log("setVoiceCallForwardingFlag: enable=" + enable
+                        + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
+
+                // Update dialNumber if not empty and CFU is enabled.
+                // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
+                if (enable && !TextUtils.isEmpty(dialNumber)) {
+                    logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
+
+                    // MTK-START
+                    // Fix ALPS03414399
+                    // If the dial number contains prefix like "tel:", "sip:" or "sips:",
+                    // it have to be truncated before passed to numberToCalledPartyBCD().
+                    String tmpDialNumber = convertNumberIfContainsPrefix(dialNumber);
+                    byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(tmpDialNumber);
+                    // MTK-END
+
+                    System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
+
+                    mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
+                    mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
+                    mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
+                }
+
+                // MTK-START
+                if (mFh != null) {
+                    mFh.updateEFLinearFixed(
+                            EF_CFIS, 1, mEfCfis, null,
+                            obtainMessage (EVENT_UPDATE_DONE, EF_CFIS));
+                } else {
+                    log("setVoiceCallForwardingFlag: mFh is null, skip update EF_CFIS");
+                }
+                // MTK-END
+            } else {
+                log("setVoiceCallForwardingFlag: ignoring enable=" + enable
+                        + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
+            }
+
+            if (mEfCff != null) {
+                if (enable) {
+                    mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET)
+                            | CFF_UNCONDITIONAL_ACTIVE);
+                } else {
+                    mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET)
+                            | CFF_UNCONDITIONAL_DEACTIVE);
+                }
+
+                // MTK-START
+                if (mFh != null) {
+                    mFh.updateEFTransparent(
+                            EF_CFF_CPHS, mEfCff,
+                            obtainMessage (EVENT_UPDATE_DONE, EF_CFF_CPHS));
+                } else {
+                    log("setVoiceCallForwardingFlag: mFh is null, skip update EF_CFF_CPHS");
+                }
+                // MTK-END
+            }
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            logw("Error saving call forwarding flag to SIM. "
+                            + "Probably malformed SIM record", ex);
+
+        }
+    }
+
+    /**
+     * Called by STK Service when REFRESH is received.
+     * @param fileChanged indicates whether any files changed
+     * @param fileList if non-null, a list of EF files that changed
+     */
+    @Override
+    public void onRefresh(boolean fileChanged, int[] fileList) {
+        if (fileChanged) {
+            // A future optimization would be to inspect fileList and
+            // only reload those files that we care about.  For now,
+            // just re-fetch all SIM records that we cache.
+            fetchSimRecords();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String getOperatorNumeric() {
+        if (mImsi == null) {
+            // MTK-START
+            if (getRecordsLoaded()) {
+                log("getOperatorNumeric: IMSI == null when record loaded.");
+            }
+            // MTK-END
+            //log("getOperatorNumeric: IMSI == null");
+            return null;
+        }
+        if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
+            log("getSIMOperatorNumeric: bad mncLength");
+            return null;
+        }
+
+        // Length = length of MCC + length of MNC
+        // length of mcc = 3 (TS 23.003 Section 2.2)
+        return mImsi.substring(0, 3 + mMncLength);
+    }
+
+    // MTK-START
+    @Override
+    public String getSIMCPHSOns() {
+        if (cphsOnsl != null) {
+            return cphsOnsl;
+        } else {
+            return cphsOnss;
+        }
+    }
+    // MTK-END
+
+    // ***** Overridden from Handler
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        AdnRecord adn;
+
+        byte data[];
+
+        boolean isRecordLoadResponse = false;
+
+        if (mDestroyed.get()) {
+            loge("Received message " + msg + "[" + msg.what + "] " +
+                    " while being destroyed. Ignoring.");
+            return;
+        }
+
+        try { switch (msg.what) {
+            case EVENT_APP_READY:
+                onReady();
+                // MTK-START
+                fetchEccList();
+                // MTK-END
+                break;
+
+            case EVENT_APP_LOCKED:
+                onLocked();
+                // MTK-START
+                fetchEccList();
+                // MTK-END
+                break;
+
+            /* IO events */
+            case EVENT_GET_IMSI_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Exception querying IMSI, Exception:" + ar.exception);
+                    break;
+                }
+
+                mImsi = (String) ar.result;
+
+                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
+                // than 15 (and usually 15).
+                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
+                    loge("invalid IMSI " + mImsi);
+                    mImsi = null;
+                }
+
+                log("IMSI: mMncLength=" + mMncLength);
+                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
+
+                // MTK-START
+                //if (((mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                if (((mMncLength == UNINITIALIZED) ||
+                        (mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                // MTK-END
+                        ((mImsi != null) && (mImsi.length() >= 6))) {
+                    String mccmncCode = mImsi.substring(0, 6);
+                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                        if (mccmnc.equals(mccmncCode)) {
+                            mMncLength = 3;
+                            log("IMSI: setting1 mMncLength=" + mMncLength);
+                            break;
+                        }
+                    }
+                }
+
+                // MTK-START
+                //if (mMncLength == UNKNOWN) {
+                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                // MTK-END
+                    // the SIM has told us all it knows, but it didn't know the mnc length.
+                    // guess using the mcc
+                    try {
+                        int mcc = Integer.parseInt(mImsi.substring(0,3));
+                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
+                        log("setting2 mMncLength=" + mMncLength);
+                    } catch (NumberFormatException e) {
+                        mMncLength = UNKNOWN;
+                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
+                    }
+                }
+
+                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
+                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                    // finally have both the imsi and the mncLength and can parse the imsi properly
+                    // MTK-START
+                    //MccTable.updateMccMncConfiguration(mContext,
+                            //mImsi.substring(0, 3 + mMncLength), false);
+                    updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                    // MTK-END
+                }
+                mImsiReadyRegistrants.notifyRegistrants();
+            break;
+
+            case EVENT_GET_MBI_DONE:
+                boolean isValidMbdn;
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[]) ar.result;
+
+                isValidMbdn = false;
+                if (ar.exception == null) {
+                    // Refer TS 51.011 Section 10.3.44 for content details
+                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
+
+                    // Voice mail record number stored first
+                    mMailboxIndex = data[0] & 0xff;
+
+                    // check if dailing numbe id valid
+                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
+                        log("Got valid mailbox number for MBDN");
+                        isValidMbdn = true;
+                        // MTK-START
+                        this.isValidMBI = true; // ALPS00301018
+                        // MTK-END
+                    }
+                }
+
+                // one more record to load
+                mRecordsToLoad += 1;
+
+                if (isValidMbdn) {
+                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
+                    // MTK-START
+                    log("EVENT_GET_MBI_DONE, to load EF_MBDN");
+                    // MTK-END
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6,
+                            mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
+                // MTK-START
+                } else if (isCphsMailboxEnabled()) {
+                // MTK-END
+                    // If this EF not present, try mailbox as in CPHS standard
+                    // CPHS (CPHS4_2.WW6) is a european standard.
+                    // MTK-START
+                    log("EVENT_GET_MBI_DONE, to load EF_MAILBOX_CPHS");
+                    // MTK-END
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS,
+                            EF_EXT1, 1,
+                            obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                // MTK-START
+                } else {
+                    log("EVENT_GET_MBI_DONE, do nothing");
+                    mRecordsToLoad -= 1;
+                // MTK-END
+                }
+
+                break;
+            case EVENT_GET_CPHS_MAILBOX_DONE:
+            case EVENT_GET_MBDN_DONE:
+                //Resetting the voice mail number and voice mail tag to null
+                //as these should be updated from the data read from EF_MBDN.
+                //If they are not reset, incase of invalid data/exception these
+                //variables are retaining their previous values and are
+                //causing invalid voice mailbox info display to user.
+                mVoiceMailNum = null;
+                mVoiceMailTag = null;
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+
+                    loge("Invalid or missing EF"
+                        + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
+
+                    // Bug #645770 fall back to CPHS
+                    // FIXME should use SST to decide
+
+                    if (msg.what == EVENT_GET_MBDN_DONE) {
+                        //load CPHS on fail...
+                        // FIXME right now, only load line1's CPHS voice mail entry
+
+                        mRecordsToLoad += 1;
+                        new AdnRecordLoader(mFh).loadFromEF(
+                                EF_MAILBOX_CPHS, EF_EXT1, 1,
+                                obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                    }
+                    break;
+                }
+
+                adn = (AdnRecord)ar.result;
+
+                log("VM: " + adn +
+                        ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
+
+                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
+                    // Bug #645770 fall back to CPHS
+                    // FIXME should use SST to decide
+                    // FIXME right now, only load line1's CPHS voice mail entry
+                    mRecordsToLoad += 1;
+                    new AdnRecordLoader(mFh).loadFromEF(
+                            EF_MAILBOX_CPHS, EF_EXT1, 1,
+                            obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+
+                    break;
+                }
+
+                mVoiceMailNum = adn.getNumber();
+                mVoiceMailTag = adn.getAlphaTag();
+            break;
+
+            case EVENT_GET_MSISDN_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Invalid or missing EF[MSISDN]");
+                    break;
+                }
+
+                adn = (AdnRecord)ar.result;
+
+                mMsisdn = adn.getNumber();
+                mMsisdnTag = adn.getAlphaTag();
+
+                // MTK-START
+                mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                // MTK-END
+                log("MSISDN: " + /*mMsisdn*/ Rlog.pii(LOG_TAG, mMsisdn));
+            break;
+
+            case EVENT_SET_MSISDN_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception == null) {
+                    mMsisdn = mNewMsisdn;
+                    mMsisdnTag = mNewMsisdnTag;
+                    // MTK-START
+                    mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                    // MTK-END
+                    log("Success to update EF[MSISDN]");
+                }
+
+                if (ar.userObj != null) {
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                            = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                }
+                break;
+
+            case EVENT_GET_MWIS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if(DBG) log("EF_MWIS : " + IccUtils.bytesToHexString(data));
+
+                if (ar.exception != null) {
+                    if(DBG) loge("EVENT_GET_MWIS_DONE exception = "
+                            + ar.exception);
+                    break;
+                }
+
+                if ((data[0] & 0xff) == 0xff) {
+                    if(DBG) log("SIMRecords: Uninitialized record MWIS");
+                    break;
+                }
+
+                mEfMWIS = data;
+                break;
+
+            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if(DBG) log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
+
+                if (ar.exception != null) {
+                    if(DBG) loge("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = "
+                            + ar.exception);
+                    break;
+                }
+
+                mEfCPHS_MWI = data;
+                break;
+
+            case EVENT_GET_ICCID_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mIccId = IccUtils.bcdToString(data, 0, data.length);
+                mFullIccId = IccUtils.bchToString(data, 0, data.length);
+
+                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
+
+            break;
+
+
+            case EVENT_GET_AD_DONE:
+                try {
+                    isRecordLoadResponse = true;
+
+                    ar = (AsyncResult)msg.obj;
+                    data = (byte[])ar.result;
+
+                    if (ar.exception != null) {
+                        break;
+                    }
+
+                    log("EF_AD: " + IccUtils.bytesToHexString(data));
+
+                    if (data.length < 3) {
+                        log("Corrupt AD data on SIM");
+                        break;
+                    }
+
+                    // MTK-START
+                    if ((data[0] & 1) == 1 && (data[2] & 1) == 1) {
+                        //TS31.102: EF_AD. If the bit1 of byte 1 is 1
+                        //,then bit 1 of byte 3 is for ciphering.
+                        log("SIMRecords: Cipher is enable");
+                    }
+                    // MTK-END
+
+                    if (data.length == 3) {
+                        log("MNC length not present in EF_AD");
+                        break;
+                    }
+
+                    mMncLength = data[3] & 0xf;
+                    log("setting4 mMncLength=" + mMncLength);
+
+                    if (mMncLength == 0xf) {
+                        mMncLength = UNKNOWN;
+                        log("setting5 mMncLength=" + mMncLength);
+                    } else if (mMncLength != 2 && mMncLength != 3) {
+                        mMncLength = UNINITIALIZED;
+                        log("setting5 mMncLength=" + mMncLength);
+                    }
+                } finally {
+                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) ||
+                            (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
+                        String mccmncCode = mImsi.substring(0, 6);
+                        log("mccmncCode=" + mccmncCode);
+                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                            if (mccmnc.equals(mccmncCode)) {
+                                mMncLength = 3;
+                                log("setting6 mMncLength=" + mMncLength);
+                                break;
+                            }
+                        }
+                    }
+
+                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                        if (mImsi != null) {
+                            try {
+                                int mcc = Integer.parseInt(mImsi.substring(0,3));
+
+                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
+                                log("setting7 mMncLength=" + mMncLength);
+                            } catch (NumberFormatException e) {
+                                mMncLength = UNKNOWN;
+                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
+                            }
+                        } else {
+                            // Indicate we got this info, but it didn't contain the length.
+                            mMncLength = UNKNOWN;
+                            log("MNC length not present in EF_AD setting9 mMncLength=" + mMncLength);
+                        }
+                    }
+                    if (mImsi != null && mMncLength != UNKNOWN) {
+                        // finally have both imsi and the length of the mnc and can parse
+                        // the imsi properly
+                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                        // MTK-START
+                        //MccTable.updateMccMncConfiguration(mContext,
+                                //mImsi.substring(0, 3 + mMncLength), false);
+                        updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                        // MTK-END
+                    }
+                }
+            break;
+
+            case EVENT_GET_SPN_DONE:
+                // MTK-START
+                if (DBG) log("EF_SPN loaded and try to extract: ");
+                // MTK-END
+                isRecordLoadResponse = true;
+                ar = (AsyncResult) msg.obj;
+                // MTK-START
+                //getSpnFsm(false, ar);
+                if (ar != null && ar.exception == null) {
+                    if (DBG) log("getSpnFsm, Got data from EF_SPN");
+                    data = (byte[]) ar.result;
+                    mSpnDisplayCondition = 0xff & data[0];
+
+                    // [ALPS00121176], 255 means invalid SPN file
+                    if (mSpnDisplayCondition == 255) {
+                        mSpnDisplayCondition = -1;
+                    }
+
+                    setServiceProviderName(
+                            IccUtils.adnStringFieldToString(data, 1, data.length - 1));
+                    mSpNameInEfSpn = getServiceProviderName(); // MVNO-API
+                    if (mSpNameInEfSpn != null && mSpNameInEfSpn.equals("")) {
+                        if (DBG) log("set spNameInEfSpn to null because parsing result is empty");
+                        mSpNameInEfSpn = null;
+                    }
+
+                    if (DBG) log("Load EF_SPN: " + getServiceProviderName()
+                            + " spnDisplayCondition: " + mSpnDisplayCondition);
+                    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(),
+                            getServiceProviderName());
+                } else {
+                    if (DBG) loge(": read spn fail!");
+                    // See TS 51.011 10.3.11.  Basically, default to
+                    // show PLMN always, and SPN also if roaming.
+                    mSpnDisplayCondition = -1;
+                }
+                // MTK-END
+            break;
+
+            case EVENT_GET_CFF_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    mEfCff = null;
+                } else {
+                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
+                    mEfCff = data;
+                }
+
+                break;
+
+            case EVENT_GET_SPDI_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                parseEfSpdi(data);
+            break;
+
+            case EVENT_UPDATE_DONE:
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception != null) {
+                    logw("update failed. ", ar.exception);
+                }
+            break;
+
+            case EVENT_GET_PNN_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                // MTK-START
+                //data = (byte[])ar.result;
+                // MTK-END
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                // MTK-START
+                parseEFpnn((ArrayList) ar.result);
+               /*
+                SimTlv tlv = new SimTlv(data, 0, data.length);
+
+                for ( ; tlv.isValidObject() ; tlv.nextObject()) {
+                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
+                        mPnnHomeName
+                            = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                        break;
+                    }
+                }
+                */
+                // MTK-END
+            break;
+
+            case EVENT_GET_ALL_SMS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception != null)
+                    break;
+
+                handleSmses((ArrayList<byte []>) ar.result);
+                break;
+
+            case EVENT_MARK_SMS_READ_DONE:
+                Rlog.i("ENF", "marked read: sms " + msg.arg1);
+                break;
+
+
+            case EVENT_SMS_ON_SIM:
+                isRecordLoadResponse = false;
+
+                ar = (AsyncResult)msg.obj;
+
+                int[] index = (int[])ar.result;
+
+                if (ar.exception != null || index.length != 1) {
+                    loge("Error on SMS_ON_SIM with exp "
+                            + ar.exception + " length " + index.length);
+                } else {
+                    log("READ EF_SMS RECORD index=" + index[0]);
+                    mFh.loadEFLinearFixed(EF_SMS,index[0],
+                            obtainMessage(EVENT_GET_SMS_DONE));
+                }
+                break;
+
+            case EVENT_GET_SMS_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception == null) {
+                    handleSms((byte[])ar.result);
+                } else {
+                    loge("Error on GET_SMS with exp " + ar.exception);
+                }
+                break;
+            case EVENT_GET_SST_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mUsimServiceTable = new UsimServiceTable(data);
+                if (DBG) log("SST: " + mUsimServiceTable);
+                // MTK-START
+                mEfSST = data;
+
+                if ((mParentApp != null) &&
+                        (mParentApp.getState() == AppState.APPSTATE_READY)) {
+                    mParentApp.queryFdn();
+                }
+
+                fetchMbiRecords();
+                fetchMwisRecords();
+                fetchPnnAndOpl();
+                fetchSpn();
+                fetchSmsp();
+                fetchGbaRecords();
+                // MTK-END
+                break;
+
+            case EVENT_GET_INFO_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                mCphsInfo = (byte[])ar.result;
+
+                if (DBG) log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
+                // MTK-START
+                // ALPS00301018
+                if (this.isValidMBI == false && isCphsMailboxEnabled()) {
+                    mRecordsToLoad += 1;
+                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS,
+                                EF_EXT1, 1,
+                                obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                }
+                // MTK-END
+            break;
+
+            case EVENT_SET_MBDN_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+
+                if (DBG) log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
+                if (ar.exception == null) {
+                    mVoiceMailNum = mNewVoiceMailNum;
+                    mVoiceMailTag = mNewVoiceMailTag;
+                }
+
+                if (isCphsMailboxEnabled()) {
+                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
+                    Message onCphsCompleted = (Message) ar.userObj;
+
+                    /* write to cphs mailbox whenever it is available but
+                    * we only need notify caller once if both updating are
+                    * successful.
+                    *
+                    * so if set_mbdn successful, notify caller here and set
+                    * onCphsCompleted to null
+                    */
+                    if (ar.exception == null && ar.userObj != null) {
+                        AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = null;
+                        ((Message) ar.userObj).sendToTarget();
+
+                        if (DBG) log("Callback with MBDN successful.");
+
+                        onCphsCompleted = null;
+                    }
+
+                    new AdnRecordLoader(mFh).
+                            updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null,
+                            obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE,
+                                    onCphsCompleted));
+                } else {
+                    if (ar.userObj != null) {
+                        Resources resource = Resources.getSystem();
+                        if (ar.exception != null && resource.getBoolean(com.android.internal.
+                                    R.bool.editable_voicemailnumber)) {
+                            // GsmCdmaPhone will store vm number on device
+                            // when IccVmNotSupportedException occurred
+                            AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = new IccVmNotSupportedException(
+                                        "Update SIM voice mailbox error");
+                        } else {
+                            AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                = ar.exception;
+                        }
+                        ((Message) ar.userObj).sendToTarget();
+                    }
+                }
+                break;
+            case EVENT_SET_CPHS_MAILBOX_DONE:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if(ar.exception == null) {
+                    mVoiceMailNum = mNewVoiceMailNum;
+                    mVoiceMailTag = mNewVoiceMailTag;
+                } else {
+                    if (DBG) loge("Set CPHS MailBox with exception: "
+                            + ar.exception);
+                }
+                if (ar.userObj != null) {
+                    if (DBG) log("Callback with CPHS MB successful.");
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                            = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                }
+                break;
+            case EVENT_SIM_REFRESH:
+                isRecordLoadResponse = false;
+                ar = (AsyncResult)msg.obj;
+                if (DBG) log("Sim REFRESH with exception: " + ar.exception);
+                if (ar.exception == null) {
+                    handleSimRefresh((IccRefreshResponse)ar.result);
+                }
+                break;
+            case EVENT_GET_CFIS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data = (byte[])ar.result;
+
+                if (ar.exception != null) {
+                    mEfCfis = null;
+                } else {
+                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
+                    mEfCfis = data;
+                }
+
+                break;
+
+            // MTK-START
+            case EVENT_GET_SIM_ECC_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_SIM_ECC_DONE)");
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    if (DBG) loge("Get SIM ecc with exception: " + ar.exception);
+                    break;
+                }
+
+                mEfEcc = "";
+
+                data = (byte[]) ar.result;
+                for (int i = 0 ; i + 2 < data.length ; i += 3) {
+                    String eccNum;
+                    eccNum = IccUtils.bcdToString(data, i, 3);
+                    if (eccNum != null && !eccNum.equals("") && !mEfEcc.equals("")) {
+                        mEfEcc = mEfEcc + ";";
+                    }
+                    // Add service category
+                    mEfEcc += eccNum + ",0" ;
+                }
+                mEfEcc += ";112,0;911,0";
+
+                if (DBG) log("SIM mEfEcc is " + mEfEcc);
+                SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], mEfEcc);
+            break;
+
+            case EVENT_GET_USIM_ECC_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_USIM_ECC_DONE)");
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    if (DBG) loge("Get USIM ecc with exception: " + ar.exception);
+                    break;
+                }
+
+                ArrayList eccRecords = (ArrayList) ar.result;
+                int count = eccRecords.size();
+
+                mEfEcc = "";
+
+                for (int i = 0; i < count; i++) {
+                    data = (byte[]) eccRecords.get(i);
+                    if (DBG) {
+                        log("USIM EF_ECC record " + i + ": "+ IccUtils.bytesToHexString(data));
+                    }
+                    String eccNum;
+                    eccNum = IccUtils.bcdToString(data, 0, 3);
+                    if (eccNum != null && !eccNum.equals("")) {
+                        if (!mEfEcc.equals("")) {
+                            mEfEcc = mEfEcc + ";";
+                        }
+                        mEfEcc = mEfEcc + eccNum ;
+
+                        //Add service category
+                        int category = (data[data.length - 1] & 0x000000FF);
+                        mEfEcc += "," + String.valueOf(category);
+                    }
+                }
+                mEfEcc += ";112,0;911,0";
+
+                if (DBG) log("USIM mEfEcc is " + mEfEcc);
+                SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], mEfEcc);
+            break;
+
+            case EVENT_GET_CSP_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Exception in fetching EF_CSP data " + ar.exception);
+                    break;
+                }
+
+                data = (byte[])ar.result;
+
+                log("EF_CSP: " + IccUtils.bytesToHexString(data));
+                handleEfCspData(data);
+                break;
+
+            case EVENT_GET_GID1_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data =(byte[])ar.result;
+
+                if (ar.exception != null) {
+                    loge("Exception in get GID1 " + ar.exception);
+                    mGid1 = null;
+                    break;
+                }
+                mGid1 = IccUtils.bytesToHexString(data);
+                log("GID1: " + mGid1);
+
+                break;
+
+            case EVENT_GET_GID2_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                data =(byte[])ar.result;
+
+                if (ar.exception != null) {
+                    loge("Exception in get GID2 " + ar.exception);
+                    mGid2 = null;
+                    break;
+                }
+                mGid2 = IccUtils.bytesToHexString(data);
+                log("GID2: " + mGid2);
+
+                break;
+
+            case EVENT_CARRIER_CONFIG_CHANGED:
+                handleCarrierNameOverride();
+                break;
+
+            // MTK-START
+            case EVENT_GET_ALL_OPL_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    break;
+                }
+                parseEFopl((ArrayList) ar.result);
+                break;
+
+            case EVENT_GET_CPHSONS_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_CPHSONS_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    cphsOnsl = IccUtils.adnStringFieldToString(
+                            data, 0, data.length);
+                    if (DBG) log("Load EF_SPN_CPHS: " + cphsOnsl);
+                }
+                break;
+
+            case EVENT_GET_SHORT_CPHSONS_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_SHORT_CPHSONS_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    cphsOnss = IccUtils.adnStringFieldToString(
+                            data, 0, data.length);
+
+                    if (DBG) log("Load EF_SPN_SHORT_CPHS: " + cphsOnss);
+                }
+                break;
+            case EVENT_MELOCK_CHANGED:
+                if (DBG) log("handleMessage (EVENT_MELOCK_CHANGED)");
+                ar = (AsyncResult) msg.obj;
+
+                if (ar != null && ar.exception == null && ar.result != null) {
+                    int[] simMelockEvent = (int []) ar.result;
+
+                    if (DBG) log("sim melock event = " + simMelockEvent[0]);
+
+                    RebootClickListener listener = new RebootClickListener();
+
+                    if (simMelockEvent[0] == 0) {
+                        AlertDialog alertDialog = new AlertDialog.Builder(mContext)
+                            .setTitle("Unlock Phone")
+                            .setMessage(
+                                "Please restart the phone now since unlock setting has changed.")
+                            .setPositiveButton("OK", listener)
+                            .create();
+
+                        alertDialog.setCancelable(false);
+                        alertDialog.setCanceledOnTouchOutside(false);
+
+                        alertDialog.getWindow().setType(
+                                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+                        alertDialog.show();
+                    }
+                }
+                break;
+
+            case EVENT_EF_CSP_PLMN_MODE_BIT_CHANGED:
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null)  {
+                    processEfCspPlmnModeBitUrc(((int[]) ar.result)[0]);
+                }
+                break;
+
+            // ALPS00302702 RAT balancing
+            case EVENT_GET_RAT_DONE:
+                if (DBG) log("handleMessage (EVENT_GET_RAT_DONE)");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                mEfRatLoaded = true;
+                if (ar != null && ar.exception == null) {
+                    mEfRat = ((byte[]) ar.result);
+                    log("load EF_RAT complete: " + mEfRat[0]);
+                    boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+                } else {
+                    log("load EF_RAT fail");
+                    mEfRat = null;
+                    if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                        boradcastEfRatContentNotify(EF_RAT_NOT_EXIST_IN_USIM);
+                    } else {
+                        boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+                    }
+                }
+                break;
+
+            /*
+              Detail description:
+              This feature provides a interface to get menu title string from EF_SUME
+            */
+            case EVENT_QUERY_MENU_TITLE_DONE:
+                log("[sume receive response message");
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    if (data != null && data.length >= 2) {
+                        int tag = data[0] & 0xff;
+                        int len = data[1] & 0xff;
+                        log("[sume tag = " + tag + ", len = " + len);
+                        mMenuTitleFromEf = IccUtils.adnStringFieldToString(data, 2, len);
+                        log("[sume menu title is " + mMenuTitleFromEf);
+                        /*-begin-chenhu*/
+                        int def = mContext.getResources().getInteger(com.android.internal.R.integer.def_customized_stk_app_name);
+                        if (def == 2) {
+                            SystemProperties.set("gsm.stk.perso.app_title", mMenuTitleFromEf);
+                        }
+                        /*-end-chenhu*/
+                    }
+                } else {
+                    if (ar.exception != null) {
+                        loge("[sume exception in AsyncResult: " +
+                                ar.exception.getClass().getName());
+                    } else {
+                        log("[sume null AsyncResult");
+                    }
+                    mMenuTitleFromEf = null;
+                }
+
+                break;
+            case EVENT_RADIO_AVAILABLE:
+                // TODO: Wait for isSetLanguageBySIM ready
+                if (mTelephonyExt.isSetLanguageBySIM()) {
+                    fetchLanguageIndicator();
+                }
+                mMsisdn = "";
+                //setNumberToSimInfo();
+                mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                break;
+            case EVENT_GET_LI_DONE:
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception == null) {
+                   log("EF_LI: " +
+                   IccUtils.bytesToHexString(data));
+                   mEfLi = data;
+                }
+                onLanguageFileLoaded();
+                break;
+            case EVENT_GET_ELP_DONE:
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception == null) {
+                    log("EF_ELP: " +
+                       IccUtils.bytesToHexString(data));
+                    mEfELP = data;
+                }
+                onLanguageFileLoaded();
+                break;
+
+            case EVENT_GET_PSISMSC_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                log("EF_PSISMSC: " + IccUtils.bytesToHexString(data));
+
+                if (data != null) {
+                    mEfPsismsc = data;
+                }
+                break;
+
+            case EVENT_GET_SMSP_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+                data = (byte[]) ar.result;
+
+                if (ar.exception != null) {
+                    break;
+                }
+
+                log("EF_SMSP: " + IccUtils.bytesToHexString(data));
+
+                if (data != null) {
+                    mEfSmsp = data;
+                }
+                break;
+
+            case EVENT_GET_GBABP_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                   data = ((byte[]) ar.result);
+                   mGbabp = IccUtils.bytesToHexString(data);
+
+                   if (DBG) log("EF_GBABP=" + mGbabp);
+                } else {
+                    loge("Error on GET_GBABP with exp " + ar.exception);
+                }
+                break;
+
+            case EVENT_GET_GBANL_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception == null) {
+                    mEfGbanlList = ((ArrayList<byte[]>) ar.result);
+                    if (DBG) log("GET_GBANL record count: " + mEfGbanlList.size());
+                } else {
+                    loge("Error on GET_GBANL with exp " + ar.exception);
+                }
+                break;
+            // MTK-START
+            case EVENT_CFU_IND:
+                ar = (AsyncResult) msg.obj;
+                /* Line1 is enabled or disabled while reveiving this EVENT */
+                if (ar != null && ar.exception == null && ar.result != null) {
+                   int[] cfuResult = (int[]) ar.result;
+                   log("handle EVENT_CFU_IND, setVoiceCallForwardingFlag:" + cfuResult[0]);
+                }
+                break;
+            // MTK-END
+            case EVENT_IMSI_REFRESH_QUERY:
+                log("handleMessage (EVENT_IMSI_REFRESH_QUERY) mImsi= " + mImsi);
+                mCi.getIMSIForApp(mParentApp.getAid(),
+                    obtainMessage(EVENT_IMSI_REFRESH_QUERY_DONE));
+                break;
+            case EVENT_IMSI_REFRESH_QUERY_DONE:
+                log("handleMessage (EVENT_IMSI_REFRESH_QUERY_DONE)");
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    loge("Exception querying IMSI, Exception:" + ar.exception);
+                    break;
+                }
+
+                mImsi = (String) ar.result;
+                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
+                // than 15 (and usually 15).
+                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
+                    loge("invalid IMSI " + mImsi);
+                    mImsi = null;
+                }
+                log("IMSI: mMncLength=" + mMncLength);
+                log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxx");
+
+                if (((mMncLength == UNINITIALIZED) ||
+                        (mMncLength == UNKNOWN) || (mMncLength == 2)) &&
+                        ((mImsi != null) && (mImsi.length() >= 6))) {
+                    String mccmncRefresh = mImsi.substring(0, 6);
+                    for (String mccmncR: MCCMNC_CODES_HAVING_3DIGITS_MNC) {
+                        if (mccmncR.equals(mccmncRefresh)) {
+                            mMncLength = 3;
+                            log("IMSI: setting1 mMncLength=" + mMncLength);
+                            break;
+                        }
+                    }
+                }
+                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
+                    // the SIM has told us all it knows, but it didn't know the mnc length.
+                    // guess using the mcc
+                    try {
+                        int mccR = Integer.parseInt(mImsi.substring(0, 3));
+                        mMncLength = MccTable.smallestDigitsMccForMnc(mccR);
+                        log("setting2 mMncLength=" + mMncLength);
+                    } catch (NumberFormatException e) {
+                        mMncLength = UNKNOWN;
+                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
+                    }
+                }
+
+                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
+                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
+                    // finally have both the imsi and the mncLength and can parse the imsi properly
+                    //MccTable.updateMccMncConfiguration(mContext,
+                            //mImsi.substring(0, 3 + mMncLength), false);
+                    updateConfiguration(mImsi.substring(0, 3 + mMncLength));
+                }
+                if (!mImsi.equals(mSimImsi)) {
+                    mSimImsi = mImsi;
+                    mImsiReadyRegistrants.notifyRegistrants();
+                    log("SimRecords: mImsiReadyRegistrants.notifyRegistrants");
+                }
+
+                if (mRecordsToLoad == 0 && mRecordsRequested == true) {
+                    onAllRecordsLoaded();
+                }
+                break;
+            // MTK-START
+            /** M: Bug Fix for ALPS02189616 */
+            // handle new event
+            case EVENT_DELAYED_SEND_PHB_CHANGE:
+                mPhbReady = isPhbReady();
+                log("[EVENT_DELAYED_SEND_PHB_CHANGE] isReady : " + mPhbReady);
+                broadcastPhbStateChangedIntent(mPhbReady);
+                break;
+            // MTK-END
+
+            default:
+                super.handleMessage(msg);   // IccRecords handles generic record load responses
+
+        }}catch (RuntimeException exc) {
+            // I don't want these exceptions to be fatal
+            logw("Exception parsing SIM record", exc);
+        } finally {
+            // Count up record load responses even if they are fails
+            if (isRecordLoadResponse) {
+                onRecordLoaded();
+            }
+        }
+    }
+
+    private class EfPlLoaded implements IccRecordLoaded {
+        public String getEfName() {
+            return "EF_PL";
+        }
+
+        public void onRecordLoaded(AsyncResult ar) {
+            mEfPl = (byte[]) ar.result;
+            if (DBG) log("EF_PL=" + IccUtils.bytesToHexString(mEfPl));
+        }
+    }
+
+    private class EfUsimLiLoaded implements IccRecordLoaded {
+        public String getEfName() {
+            return "EF_LI";
+        }
+
+        public void onRecordLoaded(AsyncResult ar) {
+            mEfLi = (byte[]) ar.result;
+            if (DBG) log("EF_LI=" + IccUtils.bytesToHexString(mEfLi));
+        }
+    }
+
+    private void handleFileUpdate(int efid) {
+        switch(efid) {
+            case EF_MBDN:
+                mRecordsToLoad++;
+                new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6,
+                        mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
+                break;
+            case EF_MAILBOX_CPHS:
+                mRecordsToLoad++;
+                new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1,
+                        1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
+                break;
+            case EF_CSP_CPHS:
+                mRecordsToLoad++;
+                log("[CSP] SIM Refresh for EF_CSP_CPHS");
+                mFh.loadEFTransparent(EF_CSP_CPHS,
+                        obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+                break;
+            case EF_FDN:
+                if (DBG) log("SIM Refresh called for EF_FDN");
+                mParentApp.queryFdn();
+            // MTK-START
+                //break;
+            case EF_ADN:
+            case EF_SDN:
+            case EF_PBR:
+                // ALPS00523253: If the file update is related to PHB efid, set phb ready to false
+                if (false == mIsPhbEfResetDone) {
+                    mIsPhbEfResetDone = true;
+                    mAdnCache.reset();
+                    log("handleFileUpdate ADN like");
+                    setPhbReady(false);
+                }
+                break;
+            // MTK-END
+            case EF_MSISDN:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_MSISDN");
+                new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1,
+                        obtainMessage(EVENT_GET_MSISDN_DONE));
+                break;
+            case EF_CFIS:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_CFIS");
+                mFh.loadEFLinearFixed(EF_CFIS,
+                        1, obtainMessage(EVENT_GET_CFIS_DONE));
+                break;
+            case EF_CFF_CPHS:
+                mRecordsToLoad++;
+                log("SIM Refresh called for EF_CFF_CPHS");
+                mFh.loadEFTransparent(EF_CFF_CPHS,
+                        obtainMessage(EVENT_GET_CFF_DONE));
+                break;
+            default:
+                // MTK-START
+                log("handleFileUpdate default");
+                // For now, fetch all records if this is not a
+                // voicemail number.
+                // TODO: Handle other cases, instead of fetching all.
+                //mAdnCache.reset();
+                if (mAdnCache.isUsimPhbEfAndNeedReset(efid) == true) {
+                    if (false == mIsPhbEfResetDone) {
+                        mIsPhbEfResetDone = true;
+                        mAdnCache.reset();
+                        setPhbReady(false);
+                    }
+                }
+                // MTK-END
+                fetchSimRecords();
+                break;
+        }
+    }
+
+    private void handleSimRefresh(IccRefreshResponse refreshResponse){
+        if (refreshResponse == null) {
+            if (DBG) log("handleSimRefresh received without input");
+            return;
+        }
+
+        // MTK-START
+        //if (refreshResponse.aid != null &&
+        if (refreshResponse.aid != null && !TextUtils.isEmpty(refreshResponse.aid) &&
+        // MTK-START
+                !refreshResponse.aid.equals(mParentApp.getAid())) {
+            // This is for different app. Ignore.
+            // MTK-START
+            if (DBG) {
+                log("handleSimRefresh, refreshResponse.aid = " + refreshResponse.aid
+                        + ", mParentApp.getAid() = " + mParentApp.getAid());
+            }
+            // MTK-END
+            return;
+        }
+
+        switch (refreshResponse.refreshResult) {
+            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
+                // MTK-START
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_FILE_UPDATED");
+
+                handleFileUpdate(refreshResponse.efId);
+
+                mIsPhbEfResetDone = false;
+                // MTK-END
+                break;
+            case IccRefreshResponse.REFRESH_RESULT_INIT:
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_INIT");
+                // need to reload all files (that we care about)
+                // MTK-START
+                setPhbReady(false);
+                // MTK-END
+                onIccRefreshInit();
+                break;
+            case IccRefreshResponse.REFRESH_RESULT_RESET:
+                // Refresh reset is handled by the UiccCard object.
+                if (DBG) log("handleSimRefresh with SIM_REFRESH_RESET");
+                // MTK-START
+                //if (requirePowerOffOnSimRefreshReset()) {
+                    //mCi.setRadioPower(false, null);
+                    /* Note: no need to call setRadioPower(true).  Assuming the desired
+                    * radio power state is still ON (as tracked by ServiceStateTracker),
+                    * ServiceStateTracker will call setRadioPower when it receives the
+                    * RADIO_STATE_CHANGED notification for the power off.  And if the
+                    * desired power state has changed in the interim, we don't want to
+                    * override it with an unconditional power on.
+                    */
+                    TelephonyManager.MultiSimVariants mSimVar =
+                            TelephonyManager.getDefault().getMultiSimConfiguration();
+                    log("mSimVar : " + mSimVar);
+                    if (SystemProperties.get("ro.sim_refresh_reset_by_modem").equals("1") != true) {
+                        log("sim_refresh_reset_by_modem false");
+                        mCi.resetRadio(null);
+                    } else {
+                        log("Sim reset by modem!");
+                    }
+                //}
+                //mAdnCache.reset();
+                setPhbReady(false);
+                onIccRefreshInit();
+                // MTK-END
+                break;
+            case IccRefreshResponse.REFRESH_INIT_FULL_FILE_UPDATED:
+                //ALPS00848917: Add refresh type
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_INIT_FULL_FILE_UPDATED");
+                }
+                setPhbReady(false);
+                onIccRefreshInit();
+                break;
+            case IccRefreshResponse.REFRESH_INIT_FILE_UPDATED:
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_INIT_FILE_UPDATED, EFID = "
+                            +  refreshResponse.efId);
+                }
+                handleFileUpdate(refreshResponse.efId);
+
+                mIsPhbEfResetDone = false;
+                if (mParentApp.getState() == AppState.APPSTATE_READY) {
+                    // This will cause files to be reread
+                    sendMessage(obtainMessage(EVENT_APP_READY));
+                }
+                break;
+            case IccRefreshResponse.REFRESH_SESSION_RESET:
+                if (DBG) {
+                    log("handleSimRefresh with REFRESH_SESSION_RESET");
+                }
+                // need to reload all files (that we care about)
+                onIccRefreshInit();
+                break;
+            default:
+                // unknown refresh operation
+                if (DBG) log("handleSimRefresh with unknown operation");
+                break;
+        }
+        // MTK-START
+        // notify stk app to clear the idle text
+        if (refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_INIT ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET ||
+                refreshResponse.refreshResult ==
+                IccRefreshResponse.REFRESH_INIT_FULL_FILE_UPDATED ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_INIT_FILE_UPDATED ||
+                refreshResponse.refreshResult == IccRefreshResponse.REFRESH_RESULT_APP_INIT) {
+            // impl
+            log("notify stk app to remove the idle text");
+            Intent intent;
+            intent = new Intent(TelephonyIntents.ACTION_REMOVE_IDLE_TEXT);
+            intent.putExtra(KEY_SIM_ID, mSlotId);
+            mContext.sendBroadcast(intent);
+        }
+        // MTK-END
+    }
+
+    /**
+     * Dispatch 3GPP format message to registrant ({@code GsmCdmaPhone}) to pass to the 3GPP SMS
+     * dispatcher for delivery.
+     */
+    private int dispatchGsmMessage(SmsMessage message) {
+        mNewSmsRegistrants.notifyResult(message);
+        return 0;
+    }
+
+    private void handleSms(byte[] ba) {
+        if (ba[0] != 0)
+            Rlog.d("ENF", "status : " + ba[0]);
+
+        // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+        // 3 == "received by MS from network; message to be read"
+        if (ba[0] == 3) {
+            int n = ba.length;
+
+            // Note: Data may include trailing FF's.  That's OK; message
+            // should still parse correctly.
+            byte[] pdu = new byte[n - 1];
+            System.arraycopy(ba, 1, pdu, 0, n - 1);
+            SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+
+            dispatchGsmMessage(message);
+        }
+    }
+
+
+    private void handleSmses(ArrayList<byte[]> messages) {
+        int count = messages.size();
+
+        for (int i = 0; i < count; i++) {
+            byte[] ba = messages.get(i);
+
+            if (ba[0] != 0)
+                Rlog.i("ENF", "status " + i + ": " + ba[0]);
+
+            // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+            // 3 == "received by MS from network; message to be read"
+
+            if (ba[0] == 3) {
+                int n = ba.length;
+
+                // Note: Data may include trailing FF's.  That's OK; message
+                // should still parse correctly.
+                byte[] pdu = new byte[n - 1];
+                System.arraycopy(ba, 1, pdu, 0, n - 1);
+                SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+
+                dispatchGsmMessage(message);
+
+                // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
+                // 1 == "received by MS from network; message read"
+
+                ba[0] = 1;
+
+                if (false) { // FIXME: writing seems to crash RdoServD
+                    mFh.updateEFLinearFixed(EF_SMS,
+                            i, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, i));
+                }
+            }
+        }
+    }
+
+    // MTK-START
+    private String findBestLanguage(byte[] languages) {
+        String bestMatch = null;
+        String[] locales = mContext.getAssets().getLocales();
+
+        if ((languages == null) || (locales == null)) return null;
+
+        // Each 2-bytes consists of one language
+        for (int i = 0; (i + 1) < languages.length; i += 2) {
+            try {
+                String lang = new String(languages, i, 2, "ISO-8859-1");
+                if (DBG) log ("languages from sim = " + lang);
+                for (int j = 0; j < locales.length; j++) {
+                    if (locales[j] != null && locales[j].length() >= 2 &&
+                            locales[j].substring(0, 2).equalsIgnoreCase(lang)) {
+                        return lang;
+                    }
+                }
+                if (bestMatch != null) break;
+            } catch(java.io.UnsupportedEncodingException e) {
+                log ("Failed to parse USIM language records" + e);
+            }
+        }
+        // no match found. return null
+        return null;
+    }
+
+    // MTK-END
+
+    @Override
+    protected void onRecordLoaded() {
+        // One record loaded successfully or failed, In either case
+        // we need to update the recordsToLoad count
+        mRecordsToLoad -= 1;
+        if (DBG) log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
+
+        if (mRecordsToLoad == 0 && mRecordsRequested == true) {
+            onAllRecordsLoaded();
+        } else if (mRecordsToLoad < 0) {
+            loge("recordsToLoad <0, programmer error suspected");
+            mRecordsToLoad = 0;
+        }
+    }
+
+    private void setVoiceCallForwardingFlagFromSimRecords() {
+        // if (validEfCfis(mEfCfis)) {
+        // MTK-START
+        if (checkEfCfis()) {
+        // MTK-END
+            // Refer TS 51.011 Section 10.3.46 for the content description
+            mCallForwardingStatus = (mEfCfis[1] & 0x01);
+            // MTK-START
+            mPhone.setVoiceCallForwardingFlag(1,
+                    mCallForwardingStatus == CALL_FORWARDING_STATUS_ENABLED, null);
+            // MTK-END
+            log("EF_CFIS: callForwardingEnabled=" + mCallForwardingStatus);
+        } else if (mEfCff != null) {
+            mCallForwardingStatus =
+                    ((mEfCff[0] & CFF_LINE1_MASK) == CFF_UNCONDITIONAL_ACTIVE) ?
+                            CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
+            log("EF_CFF: callForwardingEnabled=" + mCallForwardingStatus);
+        } else {
+            mCallForwardingStatus = CALL_FORWARDING_STATUS_UNKNOWN;
+            log("EF_CFIS and EF_CFF not valid. callForwardingEnabled=" + mCallForwardingStatus);
+        }
+    }
+
+    @Override
+    protected void onAllRecordsLoaded() {
+        if (DBG) log("record load complete");
+
+        Resources resource = Resources.getSystem();
+        if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
+            setSimLanguage(mEfLi, mEfPl);
+        } else {
+            if (DBG) log ("Not using EF LI/EF PL");
+        }
+
+        setVoiceCallForwardingFlagFromSimRecords();
+
+        if (mParentApp.getState() == AppState.APPSTATE_PIN ||
+               mParentApp.getState() == AppState.APPSTATE_PUK ||
+               // MTK-START
+               mParentApp.getState() == AppState.APPSTATE_SUBSCRIPTION_PERSO) {
+               // MTK-END
+            // reset recordsRequested, since sim is not loaded really
+            mRecordsRequested = false;
+            // lock state, only update language
+            return ;
+        }
+
+        // Some fields require more than one SIM record to set
+
+        String operator = getOperatorNumeric();
+        if (!TextUtils.isEmpty(operator)) {
+            log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" +
+                    operator + "'");
+            log("update icc_operator_numeric=" + operator);
+            mTelephonyManager.setSimOperatorNumericForPhone(
+                    mParentApp.getPhoneId(), operator);
+            final SubscriptionController subController = SubscriptionController.getInstance();
+            subController.setMccMnc(operator, subController.getDefaultSubId());
+        } else {
+            log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
+        }
+        /*-begin-chenhu*/
+        if(operator != null ){
+            log("SIMRecords: update stk name. operator = " + operator);
+            final int def = mContext.getResources().getInteger(com.android.internal.R.integer.def_customized_stk_app_name);
+            if(def == 3 || def ==2){
+                Intent intent = new Intent("proactive_set_stkselection_app_title");
+                intent.putExtra("simId", mParentApp.getSlotId());
+                mContext.sendBroadcast(intent);
+            }
+        }
+        /*-end-chenhu*/
+        if (!TextUtils.isEmpty(mImsi)) {
+            log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + mImsi) : ""));
+            // MTK-START
+            //mTelephonyManager.setSimCountryIsoForPhone(
+            //        mParentApp.getPhoneId(), MccTable.countryCodeForMcc(
+            //        Integer.parseInt(mImsi.substring(0,3))));
+            String countryCode;
+            try {
+                countryCode =
+                    MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3)));
+            } catch (NumberFormatException e) {
+                countryCode = null;
+                loge("SIMRecords: Corrupt IMSI!");
+            }
+            mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), countryCode);
+            // MTK-END
+        } else {
+            log("onAllRecordsLoaded empty imsi skipping setting mcc");
+        }
+
+        setVoiceMailByCountry(operator);
+
+        // MTK-START
+        setSpnFromConfig(getOperatorNumeric());
+        // MTK-END
+
+        mRecordsLoadedRegistrants.notifyRegistrants(
+            new AsyncResult(null, null, null));
+
+        // MTK-START
+        log("imsi = " + mImsi + " operator = " + operator);
+
+        if (operator != null) {
+            String newName = null;
+            if (operator.equals("46002") || operator.equals("46007")) {
+                operator = "46000";
+            }
+            newName = SpnOverride.getInstance().lookupOperatorName(
+                    SubscriptionManager.getSubIdUsingPhoneId(mParentApp.getPhoneId()),
+                    operator, true, mContext);
+
+            setSystemProperty(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, newName);
+
+        }
+        // MTK-END
+    }
+
+    //***** Private methods
+
+    private void handleCarrierNameOverride() {
+        CarrierConfigManager configLoader = (CarrierConfigManager)
+                mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        if (configLoader != null && configLoader.getConfig().getBoolean(
+                CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
+            String carrierName = configLoader.getConfig().getString(
+                    CarrierConfigManager.KEY_CARRIER_NAME_STRING);
+            setServiceProviderName(carrierName);
+            mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(),
+                    carrierName);
+        } else {
+            // MTK-START
+            if (getRecordsLoaded()) {
+            // MTK-END
+                setSpnFromConfig(getOperatorNumeric());
+            // MTK-START
+            }
+            // MTK-END
+        }
+    }
+
+    private void setSpnFromConfig(String carrier) {
+        // MTK-START
+        // If EF_SPN has value, use it directly to avoid wrong spn-conf.xml to
+        // override the EF_SPN value.
+        //if (mSpnOverride.containsCarrier(carrier)) {
+        //    setServiceProviderName(mSpnOverride.getSpn(carrier));
+        //    mTelephonyManager.setSimOperatorNameForPhone(
+        //            mParentApp.getPhoneId(), getServiceProviderName());
+        //}
+        if (TextUtils.isEmpty(getServiceProviderName()) && mSpnOverride.containsCarrier(carrier)) {
+            mTelephonyManager.setSimOperatorNameForPhone(
+                    mParentApp.getPhoneId(), mSpnOverride.getSpn(carrier));
+        }
+    }
+
+
+    private void setVoiceMailByCountry (String spn) {
+        if (mVmConfig.containsCarrier(spn)) {
+            // MTK-START
+            log("setVoiceMailByCountry");
+            // MTK-END
+            mIsVoiceMailFixed = true;
+            mVoiceMailNum = mVmConfig.getVoiceMailNumber(spn);
+            mVoiceMailTag = mVmConfig.getVoiceMailTag(spn);
+        }
+    }
+
+    @Override
+    public void onReady() {
+        fetchSimRecords();
+    }
+
+    private void onLocked() {
+        if (DBG) log("only fetch EF_LI and EF_PL in lock state");
+        loadEfLiAndEfPl();
+    }
+
+    private void loadEfLiAndEfPl() {
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            mRecordsRequested = true;
+            mFh.loadEFTransparent(EF_LI,
+                    obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfUsimLiLoaded()));
+            mRecordsToLoad++;
+
+            mFh.loadEFTransparent(EF_PL,
+                    obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
+            mRecordsToLoad++;
+        }
+    }
+
+    private void loadCallForwardingRecords() {
+        mRecordsRequested = true;
+        mFh.loadEFLinearFixed(EF_CFIS, 1, obtainMessage(EVENT_GET_CFIS_DONE));
+        mRecordsToLoad++;
+        mFh.loadEFTransparent(EF_CFF_CPHS, obtainMessage(EVENT_GET_CFF_DONE));
+        mRecordsToLoad++;
+    }
+
+    protected void fetchSimRecords() {
+        mRecordsRequested = true;
+
+        if (DBG) log("fetchSimRecords " + mRecordsToLoad);
+
+        mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
+        mRecordsToLoad++;
+
+        // FIXME should examine EF[MSISDN]'s capability configuration
+        // to determine which is the voice/data/fax line
+        new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1,
+                    obtainMessage(EVENT_GET_MSISDN_DONE));
+        mRecordsToLoad++;
+
+        // Record number is subscriber profile
+        // MTK-START
+        // We should check the SST table before read EF_MBI.
+        //mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
+        //mRecordsToLoad++;
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
+        mRecordsToLoad++;
+
+        // Record number is subscriber profile
+        // MTK-START
+        // [ALPS01888298] should check service before access MWIS EF
+        //mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
+        //mRecordsToLoad++;
+        // MTK-END
+
+        // Also load CPHS-style voice mail indicator, which stores
+        // the same info as EF[MWIS]. If both exist, both are updated
+        // but the EF[MWIS] data is preferred
+        // Please note this must be loaded after EF[MWIS]
+        mFh.loadEFTransparent(
+                EF_VOICE_MAIL_INDICATOR_CPHS,
+                obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
+        mRecordsToLoad++;
+
+        // Same goes for Call Forward Status indicator: fetch both
+        // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
+        loadCallForwardingRecords();
+
+        // MTK-START
+        //getSpnFsm(true, null);
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
+        mRecordsToLoad++;
+
+        // MTK-START
+        //mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
+        //recordsToLoad++;
+        // MTK-END
+
+        mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_CSP_CPHS,obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
+        mRecordsToLoad++;
+
+        mFh.loadEFTransparent(EF_GID2, obtainMessage(EVENT_GET_GID2_DONE));
+        mRecordsToLoad++;
+
+        loadEfLiAndEfPl();
+
+        // MTK-START
+        // TODO: Wait for isSetLanguageBySIM ready
+        /*
+                Detail description:
+                This feature provides a interface to get menu title string from EF_SUME
+                */
+        if (mTelephonyExt != null) {
+            if (mTelephonyExt.isSetLanguageBySIM()) {
+                mFh.loadEFTransparent(EF_SUME, obtainMessage(EVENT_QUERY_MENU_TITLE_DONE));
+                mRecordsToLoad++;
+            }
+        } else {
+           loge("fetchSimRecords(): mTelephonyExt is null!!!");
+        }
+
+        fetchCPHSOns();
+        // MTK-END
+
+
+        // XXX should seek instead of examining them all
+        if (false) { // XXX
+            mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
+            mRecordsToLoad++;
+        }
+
+        if (CRASH_RIL) {
+            String sms = "0107912160130310f20404d0110041007030208054832b0120"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+                         + "ffffffffffffffffffffffffffffff";
+            byte[] ba = IccUtils.hexStringToBytes(sms);
+
+            mFh.updateEFLinearFixed(EF_SMS, 1, ba, null,
+                            obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
+        }
+        if (DBG) log("fetchSimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
+        // MTK-START
+        fetchRatBalancing();
+        // MTK-END
+    }
+
+    /**
+     * Returns the SpnDisplayRule based on settings on the SIM and the
+     * specified plmn (currently-registered PLMN).  See TS 22.101 Annex A
+     * and TS 51.011 10.3.11 for details.
+     *
+     * If the SPN is not found on the SIM or is empty, the rule is
+     * always PLMN_ONLY.
+     */
+    @Override
+    public int getDisplayRule(String plmn) {
+        int rule;
+        // MTK-START
+        boolean bSpnActive = false;
+        String spn = getServiceProviderName();
+
+        if (mEfSST != null && mParentApp != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                if (mEfSST.length >= 3 && (mEfSST[2] & 0x04) == 4) {
+                    bSpnActive = true;
+                    log("getDisplayRule USIM mEfSST is " +
+                     IccUtils.bytesToHexString(mEfSST) + " set bSpnActive to true");
+                }
+            } else if ((mEfSST.length >= 5) && (mEfSST[4] & 0x02) == 2) {
+                bSpnActive = true;
+                log("getDisplayRule SIM mEfSST is " +
+                    IccUtils.bytesToHexString(mEfSST) + " set bSpnActive to true");
+            }
+        }
+
+        log("getDisplayRule mParentApp is " +
+            ((mParentApp != null) ? mParentApp : "null"));
+        // MTK-END
+        if (mParentApp != null && mParentApp.getUiccCard() != null &&
+            mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
+        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
+            // MTK-START
+            log("getDisplayRule, getOperatorBrandOverride is not null");
+            // MTK-END
+            rule = SPN_RULE_SHOW_PLMN;
+            // MTK-START
+        //} else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
+        } else if (!bSpnActive || TextUtils.isEmpty(spn) ||
+                spn.equals("") || mSpnDisplayCondition == -1) {
+            // MTK-END
+            // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
+            // MTK-START
+            log("getDisplayRule, no EF_SPN");
+            // MTK-END
+            rule = SPN_RULE_SHOW_PLMN;
+        } else if (isOnMatchingPlmn(plmn)) {
+            rule = SPN_RULE_SHOW_SPN;
+            if ((mSpnDisplayCondition & 0x01) == 0x01) {
+                // ONS required when registered to HPLMN or PLMN in EF_SPDI
+                rule |= SPN_RULE_SHOW_PLMN;
+            }
+        } else {
+            rule = SPN_RULE_SHOW_PLMN;
+            if ((mSpnDisplayCondition & 0x02) == 0x00) {
+                // SPN required if not registered to HPLMN or PLMN in EF_SPDI
+                rule |= SPN_RULE_SHOW_SPN;
+            }
+        }
+        return rule;
+    }
+
+    /**
+     * Checks if plmn is HPLMN or on the spdiNetworks list.
+     */
+    private boolean isOnMatchingPlmn(String plmn) {
+        if (plmn == null) return false;
+
+        // MTK-START
+        //if (plmn.equals(getOperatorNumeric())) {
+        if (isHPlmn(plmn)) {
+        // MTK-END
+            return true;
+        }
+
+        if (mSpdiNetworks != null) {
+            for (String spdiNet : mSpdiNetworks) {
+                if (plmn.equals(spdiNet)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * States of Get SPN Finite State Machine which only used by getSpnFsm()
+     */
+    private enum GetSpnFsmState {
+        IDLE,               // No initialized
+        INIT,               // Start FSM
+        READ_SPN_3GPP,      // Load EF_SPN firstly
+        READ_SPN_CPHS,      // Load EF_SPN_CPHS secondly
+        READ_SPN_SHORT_CPHS // Load EF_SPN_SHORT_CPHS last
+    }
+
+    /**
+     * Finite State Machine to load Service Provider Name , which can be stored
+     * in either EF_SPN (3GPP), EF_SPN_CPHS, or EF_SPN_SHORT_CPHS (CPHS4.2)
+     *
+     * After starting, FSM will search SPN EFs in order and stop after finding
+     * the first valid SPN
+     *
+     * If the FSM gets restart while waiting for one of
+     * SPN EFs results (i.e. a SIM refresh occurs after issuing
+     * read EF_CPHS_SPN), it will re-initialize only after
+     * receiving and discarding the unfinished SPN EF result.
+     *
+     * @param start set true only for initialize loading
+     * @param ar the AsyncResult from loadEFTransparent
+     *        ar.exception holds exception in error
+     *        ar.result is byte[] for data in success
+     */
+    private void getSpnFsm(boolean start, AsyncResult ar) {
+        byte[] data;
+
+        if (start) {
+            // Check previous state to see if there is outstanding
+            // SPN read
+            if(mSpnState == GetSpnFsmState.READ_SPN_3GPP ||
+               mSpnState == GetSpnFsmState.READ_SPN_CPHS ||
+               mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS ||
+               mSpnState == GetSpnFsmState.INIT) {
+                // Set INIT then return so the INIT code
+                // will run when the outstanding read done.
+                mSpnState = GetSpnFsmState.INIT;
+                return;
+            } else {
+                mSpnState = GetSpnFsmState.INIT;
+            }
+        }
+
+        switch(mSpnState){
+            case INIT:
+                // MTK-START
+                //setServiceProviderName(null);
+                // MTK-END
+
+                mFh.loadEFTransparent(EF_SPN,
+                        obtainMessage(EVENT_GET_SPN_DONE));
+                mRecordsToLoad++;
+
+                mSpnState = GetSpnFsmState.READ_SPN_3GPP;
+                break;
+            case READ_SPN_3GPP:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+                    mSpnDisplayCondition = 0xff & data[0];
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 1, data.length - 1));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        mSpnState = GetSpnFsmState.READ_SPN_CPHS;
+                    } else {
+                        if (DBG) log("Load EF_SPN: " + spn
+                                + " spnDisplayCondition: " + mSpnDisplayCondition);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+
+                        mSpnState = GetSpnFsmState.IDLE;
+                    }
+                } else {
+                    mSpnState = GetSpnFsmState.READ_SPN_CPHS;
+                }
+
+                if (mSpnState == GetSpnFsmState.READ_SPN_CPHS) {
+                    mFh.loadEFTransparent( EF_SPN_CPHS,
+                            obtainMessage(EVENT_GET_SPN_DONE));
+                    mRecordsToLoad++;
+
+                    // See TS 51.011 10.3.11.  Basically, default to
+                    // show PLMN always, and SPN also if roaming.
+                    mSpnDisplayCondition = -1;
+                }
+                break;
+            case READ_SPN_CPHS:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 0, data.length));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
+                    } else {
+                        // Display CPHS Operator Name only when not roaming
+                        mSpnDisplayCondition = 2;
+
+                        if (DBG) log("Load EF_SPN_CPHS: " + spn);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+
+                        mSpnState = GetSpnFsmState.IDLE;
+                    }
+                } else {
+                    mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
+                }
+
+                if (mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS) {
+                    mFh.loadEFTransparent(
+                            EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
+                    mRecordsToLoad++;
+                }
+                break;
+            case READ_SPN_SHORT_CPHS:
+                if (ar != null && ar.exception == null) {
+                    data = (byte[]) ar.result;
+
+                    setServiceProviderName(IccUtils.adnStringFieldToString(
+                            data, 0, data.length));
+                    // for card double-check and brand override
+                    // we have to do this:
+                    final String spn = getServiceProviderName();
+
+                    if (spn == null || spn.length() == 0) {
+                        if (DBG) log("No SPN loaded in either CHPS or 3GPP");
+                    } else {
+                        // Display CPHS Operator Name only when not roaming
+                        mSpnDisplayCondition = 2;
+
+                        if (DBG) log("Load EF_SPN_SHORT_CPHS: " + spn);
+                        mTelephonyManager.setSimOperatorNameForPhone(
+                                mParentApp.getPhoneId(), spn);
+                    }
+                } else {
+                    setServiceProviderName(null);
+                    if (DBG) log("No SPN loaded in either CHPS or 3GPP");
+                }
+
+                mSpnState = GetSpnFsmState.IDLE;
+                break;
+            default:
+                mSpnState = GetSpnFsmState.IDLE;
+        }
+    }
+
+    /**
+     * Parse TS 51.011 EF[SPDI] record
+     * This record contains the list of numeric network IDs that
+     * are treated specially when determining SPN display
+     */
+    private void
+    parseEfSpdi(byte[] data) {
+        SimTlv tlv = new SimTlv(data, 0, data.length);
+
+        byte[] plmnEntries = null;
+
+        for ( ; tlv.isValidObject() ; tlv.nextObject()) {
+            // Skip SPDI tag, if existant
+            if (tlv.getTag() == TAG_SPDI) {
+              tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
+            }
+            // There should only be one TAG_SPDI_PLMN_LIST
+            if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
+                plmnEntries = tlv.getData();
+                break;
+            }
+        }
+
+        if (plmnEntries == null) {
+            return;
+        }
+
+        mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
+
+        for (int i = 0 ; i + 2 < plmnEntries.length ; i += 3) {
+            String plmnCode;
+            // MTK-START
+            //plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
+            plmnCode = IccUtils.parsePlmnToString(plmnEntries, i, 3);
+            // MTK-END
+
+            // Valid operator codes are 5 or 6 digits
+            if (plmnCode.length() >= 5) {
+                log("EF_SPDI network: " + plmnCode);
+                mSpdiNetworks.add(plmnCode);
+            }
+        }
+    }
+
+    /**
+     * check to see if Mailbox Number is allocated and activated in CPHS SST
+     */
+    private boolean isCphsMailboxEnabled() {
+        if (mCphsInfo == null)  return false;
+        return ((mCphsInfo[1] & CPHS_SST_MBN_MASK) == CPHS_SST_MBN_ENABLED );
+    }
+
+    @Override
+    protected void log(String s) {
+        // MTK-START
+        //Rlog.d(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.d(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    @Override
+    protected void loge(String s) {
+        // MTK-START
+        //Rlog.e(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.e(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    protected void logw(String s, Throwable tr) {
+        // MTK-START
+        //Rlog.w(LOG_TAG, "[SIMRecords] " + s, tr);
+        Rlog.w(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")", tr);
+        // MTK-END
+    }
+
+    protected void logv(String s) {
+        // MTK-START
+        //Rlog.v(LOG_TAG, "[SIMRecords] " + s);
+        Rlog.v(LOG_TAG, "[SIMRecords] " + s + " (slot " + mSlotId + ")");
+        // MTK-END
+    }
+
+    /**
+     * Return true if "Restriction of menu options for manual PLMN selection"
+     * bit is set or EF_CSP data is unavailable, return false otherwise.
+     */
+    @Override
+    public boolean isCspPlmnEnabled() {
+        return mCspPlmnEnabled;
+    }
+
+    /**
+     * Parse EF_CSP data and check if
+     * "Restriction of menu options for manual PLMN selection" is
+     * Enabled/Disabled
+     *
+     * @param data EF_CSP hex data.
+     */
+    private void handleEfCspData(byte[] data) {
+        // As per spec CPHS4_2.WW6, CPHS B.4.7.1, EF_CSP contains CPHS defined
+        // 18 bytes (i.e 9 service groups info) and additional data specific to
+        // operator. The valueAddedServicesGroup is not part of standard
+        // services. This is operator specific and can be programmed any where.
+        // Normally this is programmed as 10th service after the standard
+        // services.
+        int usedCspGroups = data.length / 2;
+        // This is the "Service Group Number" of "Value Added Services Group".
+        byte valueAddedServicesGroup = (byte)0xC0;
+
+        mCspPlmnEnabled = true;
+        for (int i = 0; i < usedCspGroups; i++) {
+             if (data[2 * i] == valueAddedServicesGroup) {
+                 log("[CSP] found ValueAddedServicesGroup, value " + data[(2 * i) + 1]);
+                 if ((data[(2 * i) + 1] & 0x80) == 0x80) {
+                     // Bit 8 is for
+                     // "Restriction of menu options for manual PLMN selection".
+                     // Operator Selection menu should be enabled.
+                     mCspPlmnEnabled = true;
+                 } else {
+                     mCspPlmnEnabled = false;
+                     // Operator Selection menu should be disabled.
+                     // Operator Selection Mode should be set to Automatic.
+                     log("[CSP] Set Automatic Network Selection");
+                     mNetworkSelectionModeAutomaticRegistrants.notifyRegistrants();
+                 }
+                 return;
+             }
+        }
+
+        log("[CSP] Value Added Service Group (0xC0), not found!");
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("SIMRecords: " + this);
+        pw.println(" extends:");
+        super.dump(fd, pw, args);
+        pw.println(" mVmConfig=" + mVmConfig);
+        pw.println(" mSpnOverride=" + mSpnOverride);
+        pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
+        pw.println(" mSpnState=" + mSpnState);
+        pw.println(" mCphsInfo=" + mCphsInfo);
+        pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
+        pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
+        pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
+        pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
+        pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
+        pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
+        pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
+        pw.println(" mPnnHomeName=" + mPnnHomeName);
+        pw.println(" mUsimServiceTable=" + mUsimServiceTable);
+        pw.println(" mGid1=" + mGid1);
+        pw.println(" mGid2=" + mGid2);
+        pw.flush();
+    }
+
+    // MTK-START
+    // MVNO-API START
+    public String getSpNameInEfSpn() {
+        if (DBG) log("getSpNameInEfSpn(): " + mSpNameInEfSpn);
+        return mSpNameInEfSpn;
+    }
+
+    public String isOperatorMvnoForImsi() {
+        SpnOverride spnOverride = SpnOverride.getInstance();
+        String imsiPattern = spnOverride.isOperatorMvnoForImsi(getOperatorNumeric(),
+                getIMSI());
+        String mccmnc = getOperatorNumeric();
+        if (DBG) {
+            log("isOperatorMvnoForImsi(), imsiPattern: " + imsiPattern
+                + ", mccmnc: " + mccmnc);
+        }
+        if (imsiPattern == null || mccmnc == null) {
+            return null;
+        }
+        String result = imsiPattern.substring(mccmnc.length(), imsiPattern.length());
+        if (DBG) {
+            log("isOperatorMvnoForImsi(): " + result);
+        }
+        return result;
+    }
+
+
+    public String getFirstFullNameInEfPnn() {
+        if (mPnnNetworkNames == null || mPnnNetworkNames.size() == 0) {
+            if (DBG) log("getFirstFullNameInEfPnn(): empty");
+            return null;
+        }
+
+        OperatorName opName = mPnnNetworkNames.get(0);
+        if (DBG) log("getFirstFullNameInEfPnn(): first fullname: " + opName.sFullName);
+        if (opName.sFullName != null)
+            return new String(opName.sFullName);
+        return null;
+    }
+
+    public String isOperatorMvnoForEfPnn() {
+        String MCCMNC = getOperatorNumeric();
+        String PNN = getFirstFullNameInEfPnn();
+        if (DBG) log("isOperatorMvnoForEfPnn(): mccmnc = " + MCCMNC + ", pnn = " + PNN);
+        if (SpnOverride.getInstance().getSpnByEfPnn(MCCMNC, PNN) != null)
+            return PNN;
+        return null;
+    }
+
+    public String getMvnoMatchType() {
+        String IMSI = getIMSI();
+        String SPN = getSpNameInEfSpn();
+        String PNN = getFirstFullNameInEfPnn();
+        String GID1 = getGid1();
+        String MCCMNC = getOperatorNumeric();
+        if (DBG) {
+            log("getMvnoMatchType(): imsi = " + IMSI + ", mccmnc = " + MCCMNC + ", spn = " + SPN);
+        }
+
+        if (SpnOverride.getInstance().getSpnByEfSpn(MCCMNC, SPN) != null)
+            return PhoneConstants.MVNO_TYPE_SPN;
+
+        if (SpnOverride.getInstance().getSpnByImsi(MCCMNC, IMSI) != null)
+            return PhoneConstants.MVNO_TYPE_IMSI;
+
+        if (SpnOverride.getInstance().getSpnByEfPnn(MCCMNC, PNN) != null)
+            return PhoneConstants.MVNO_TYPE_PNN;
+
+        if (SpnOverride.getInstance().getSpnByEfGid1(MCCMNC, GID1) != null)
+            return PhoneConstants.MVNO_TYPE_GID;
+
+        return PhoneConstants.MVNO_TYPE_NONE;
+    }
+    // MVNO-API END
+
+    private class SIMBroadCastReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals("com.mediatek.dm.LAWMO_WIPE")) {
+               wipeAllSIMContacts();
+            } else {
+                if (action.equals("android.intent.action.ACTION_SHUTDOWN_IPO")) {
+                   processShutdownIPO();
+                   // ALPS00293301
+                   //SystemProperties.set(PROPERTY_ICC_OPERATOR_DEFAULT_NAME, null);
+                   //if(FeatureOption.MTK_GEMINI_SUPPORT)
+                   //    SystemProperties.set(PROPERTY_ICC_OPERATOR_DEFAULT_NAME_2, null);
+
+                   //ALPS01213113
+                   SystemProperties.set(SIM_RECORDS_PROPERTY_ECC_LIST[mSlotId], null);
+
+                   // ALPS00302698 ENS
+                   log("wipeAllSIMContacts ACTION_SHUTDOWN_IPO: reset mCspPlmnEnabled");
+                   mCspPlmnEnabled = true;
+
+                   // TODO: Wait for isSetLanguageBySIM ready
+                   // ALPS00302702 RAT balancing
+                   if (mTelephonyExt.isSetLanguageBySIM()) {
+                       mEfRatLoaded = false;
+                       mEfRat = null;
+                   }
+
+                   mAdnCache.reset();
+                   log("wipeAllSIMContacts ACTION_SHUTDOWN_IPO");
+                } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                    String reasonExtra = intent.getStringExtra(
+                            IccCardConstants.INTENT_KEY_LOCKED_REASON);
+                    int slot = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                    String simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                    log("SIM_STATE_CHANGED: slot = " + slot + ",reason = " + reasonExtra +
+                            ",simState = " + simState);
+                    if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(reasonExtra)) {
+                        if (slot == mSlotId) {
+                            String strPuk1Count = null;
+                            strPuk1Count = SystemProperties.get(
+                                    SIMRECORD_PROPERTY_RIL_PUK1[mSlotId], "0");
+                            log("SIM_STATE_CHANGED: strPuk1Count = " + strPuk1Count);
+                            //if (strPuk1Count.equals("0")){
+                            //    setPhbReady(false);
+                            //}
+
+                            mMsisdn = "";
+                            //setNumberToSimInfo();
+                            mRecordsEventsRegistrants.notifyResult(EVENT_MSISDN);
+                        }
+                    }
+                    if (slot == mSlotId) {
+                        String strPhbReady = null;
+                        strPhbReady = SystemProperties.get(
+                                SIMRECORD_PROPERTY_RIL_PHB_READY[mSlotId], "false");
+                        //Update phb ready by sim state.
+                        log("sim state: " + simState + ", mPhbReady: " + mPhbReady +
+                                ",strPhbReady: " + strPhbReady.equals("true"));
+                        if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simState)) {
+                            if (false == mPhbReady && strPhbReady.equals("true")) {
+                                mPhbReady = true;
+                                broadcastPhbStateChangedIntent(mPhbReady);
+
+                            } else if (true == mPhbWaitSub && strPhbReady.equals("true")) {
+                                log("mPhbWaitSub is " + mPhbWaitSub + ", broadcast if need");
+                                mPhbWaitSub = false;
+                                broadcastPhbStateChangedIntent(mPhbReady);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private class SubBroadCastReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+            if ((mPhbWaitSub == true) &&
+                    (action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED))) {
+                log("SubBroadCastReceiver receive ACTION_SUBINFO_RECORD_UPDATED");
+                mPhbWaitSub = false;
+                broadcastPhbStateChangedIntent(mPhbReady);
+            }
+        }
+    }
+
+    private void wipeAllSIMContacts() {
+        if (DBG) log("wipeAllSIMContacts");
+        mAdnCache.reset();
+        if (DBG) log("wipeAllSIMContacts after reset");
+    }
+
+    private void processShutdownIPO() {
+        // reset icc id variable when ipo shutdown
+        // ipo shutdown will make radio turn off,
+        // only needs to reset the variable which will not be reset in onRadioOffOrNotAvailable()
+        hasQueryIccId = false;
+        iccIdQueryState = -1;
+        mIccId = null;
+        mImsi = null;
+        mSpNameInEfSpn = null;
+
+    }
+
+    private void fetchEccList() {
+        // [Backward compatible]
+        // If "ril.ef.ecc.support" is "1", means modem will send URC to notify
+        // EF_ECC's value and phone number utility module will take over the
+        // system properties.
+
+        int eccFromModemUrc = SystemProperties.getInt("ril.ef.ecc.support", 0);
+
+        if (DBG) log("fetchEccList(), eccFromModemUrc:" + eccFromModemUrc);
+
+        if (eccFromModemUrc == 0) {
+            mEfEcc = "";
+
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                mFh.loadEFLinearFixedAll(EF_ECC, obtainMessage(EVENT_GET_USIM_ECC_DONE));
+            } else {
+                mFh.loadEFTransparent(EF_ECC, obtainMessage(EVENT_GET_SIM_ECC_DONE));
+            }
+        }
+    }
+
+    //ALPS00784072: We don't need to update configure if mnc & mnc not changed.
+    private void updateConfiguration(String numeric) {
+        if (!TextUtils.isEmpty(numeric) && !mOldMccMnc.equals(numeric)) {
+            mOldMccMnc = numeric;
+            MccTable.updateMccMncConfiguration(mContext, mOldMccMnc, false);
+        } else {
+            log("Do not update configuration if mcc mnc no change.");
+        }
+    }
+
+    /**
+    *parse pnn list
+    */
+    private void parseEFpnn(ArrayList messages) {
+        int count = messages.size();
+        if (DBG) log("parseEFpnn(): pnn has " + count + " records");
+
+        mPnnNetworkNames = new ArrayList<OperatorName>(count);
+        for (int i = 0; i < count; i++) {
+            byte[] data = (byte[]) messages.get(i);
+            if (DBG) {
+                log("parseEFpnn(): pnn record " + i + " content is " +
+                        IccUtils.bytesToHexString(data));
+            }
+
+            SimTlv tlv = new SimTlv(data, 0, data.length);
+            OperatorName opName = new OperatorName();
+            for (; tlv.isValidObject(); tlv.nextObject()) {
+                if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
+                    opName.sFullName = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                    if (DBG) log("parseEFpnn(): pnn sFullName is "  + opName.sFullName);
+                } else if (tlv.getTag() == TAG_SHORT_NETWORK_NAME) {
+                    opName.sShortName = IccUtils.networkNameToString(
+                                tlv.getData(), 0, tlv.getData().length);
+                    if (DBG) log("parseEFpnn(): pnn sShortName is "  + opName.sShortName);
+                }
+            }
+
+            mPnnNetworkNames.add(opName);
+        }
+    }
+
+    // ALPS00267605 : PNN/OPL revision
+    private void fetchPnnAndOpl() {
+        if (DBG) log("fetchPnnAndOpl()");
+        //boolean bPnnOplActive = false;
+        boolean bPnnActive = false;
+        boolean bOplActive = false;
+
+        if (mEfSST != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                if (mEfSST.length >= 6) {
+                    bPnnActive = ((mEfSST[5] & 0x10) == 0x10);
+                    if (bPnnActive) {
+                        bOplActive = ((mEfSST[5] & 0x20) == 0x20);
+                    }
+                }
+            } else if (mEfSST.length >= 13) {
+                bPnnActive = ((mEfSST[12] & 0x30) == 0x30);
+                if (bPnnActive) {
+                    bOplActive = ((mEfSST[12] & 0xC0) == 0xC0);
+                }
+            }
+        }
+        if (DBG) log("bPnnActive = " + bPnnActive + ", bOplActive = " + bOplActive);
+
+        if (bPnnActive) {
+            mFh.loadEFLinearFixedAll(EF_PNN, obtainMessage(EVENT_GET_PNN_DONE));
+            mRecordsToLoad++;
+            if (bOplActive) {
+                mFh.loadEFLinearFixedAll(EF_OPL, obtainMessage(EVENT_GET_ALL_OPL_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    private void fetchSpn() {
+        if (DBG) log("fetchSpn()");
+        boolean bSpnActive = false;
+
+        IccConstants.IccServiceStatus iccSerStatus = getSIMServiceStatus(
+                IccConstants.IccService.SPN);
+        if (iccSerStatus == IccConstants.IccServiceStatus.ACTIVATED) {
+            setServiceProviderName(null);
+            mFh.loadEFTransparent(EF_SPN,
+                    obtainMessage(EVENT_GET_SPN_DONE));
+            mRecordsToLoad++;
+        } else {
+            if (DBG) log("[SIMRecords] SPN service is not activated  ");
+        }
+    }
+
+    public IccConstants.IccServiceStatus getSIMServiceStatus(
+            IccConstants.IccService enService) {
+        int nServiceNum = enService.getIndex();
+        IccConstants.IccServiceStatus simServiceStatus = IccConstants.IccServiceStatus.UNKNOWN;
+        if (DBG) {
+            log("getSIMServiceStatus enService is " + enService +
+                    " Service Index is " + nServiceNum);
+        }
+
+        if (nServiceNum >= 0 &&
+                nServiceNum < IccConstants.IccService.UNSUPPORTED_SERVICE.getIndex() &&
+                mEfSST != null) {
+            if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+                int nUSTIndex = usimServiceNumber[nServiceNum];
+                if (nUSTIndex <= 0) {
+                    simServiceStatus = IccConstants.IccServiceStatus.NOT_EXIST_IN_USIM;
+                } else {
+                    int nbyte = nUSTIndex / 8;
+                    int nbit = nUSTIndex % 8 ;
+                    if (nbit == 0) {
+                        nbit = 7;
+                        nbyte--;
+                    } else {
+                        nbit--;
+                    }
+                    if (DBG) log("getSIMServiceStatus USIM nbyte: " + nbyte + " nbit: " + nbit);
+
+                    if (mEfSST.length > nbyte && ((mEfSST[nbyte] & (0x1 << nbit)) > 0)) {
+                        simServiceStatus = IccConstants.IccServiceStatus.ACTIVATED;
+                    } else {
+                        simServiceStatus = IccConstants.IccServiceStatus.INACTIVATED;
+                    }
+                }
+            } else {
+                int nSSTIndex = simServiceNumber[nServiceNum];
+                if (nSSTIndex <= 0) {
+                    simServiceStatus = IccConstants.IccServiceStatus.NOT_EXIST_IN_SIM;
+                } else {
+                    int nbyte = nSSTIndex / 4;
+                    int nbit = nSSTIndex % 4;
+                    if (nbit == 0) {
+                        nbit = 3;
+                        nbyte--;
+                    } else {
+                        nbit--;
+                    }
+
+                    int nMask = (0x2 << (nbit * 2));
+                    log("getSIMServiceStatus SIM nbyte: " + nbyte +
+                            " nbit: " + nbit + " nMask: " + nMask);
+                    if (mEfSST.length > nbyte && ((mEfSST[nbyte] & nMask) == nMask)) {
+                        simServiceStatus = IccConstants.IccServiceStatus.ACTIVATED;
+                    } else {
+                        simServiceStatus = IccConstants.IccServiceStatus.INACTIVATED;
+                    }
+                }
+            }
+        }
+
+        log("getSIMServiceStatus simServiceStatus: " + simServiceStatus);
+        return simServiceStatus;
+    }
+
+    private void fetchSmsp() {
+        if (DBG) log("fetchSmsp()");
+
+        //For USim authentication.
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.SM_SERVICE_PARAMS)) {
+                if (DBG) log("SMSP support.");
+                mFh.loadEFLinearFixed(EF_SMSP, 1, obtainMessage(EVENT_GET_SMSP_DONE));
+                mRecordsToLoad++;
+
+                if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.SM_OVER_IP)) {
+                    if (DBG) log("PSISMSP support.");
+                    mFh.loadEFLinearFixed(EF_PSISMSC, 1, obtainMessage(EVENT_GET_PSISMSC_DONE));
+                    mRecordsToLoad++;
+                }
+
+            }
+        }
+    }
+
+    private void fetchGbaRecords() {
+        if (DBG) log("fetchGbaRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.GBA)) {
+                if (DBG) log("GBA support.");
+                mFh.loadEFTransparent(EF_ISIM_GBABP, obtainMessage(EVENT_GET_GBABP_DONE));
+                mRecordsToLoad++;
+
+                mFh.loadEFLinearFixedAll(EF_ISIM_GBANL, obtainMessage(EVENT_GET_GBANL_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    private void fetchMbiRecords() {
+        if (DBG) log("fetchMbiRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.MBDN)) {
+                if (DBG) log("MBI/MBDN support.");
+                mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    private void fetchMwisRecords() {
+        if (DBG) log("fetchMwisRecords");
+
+        if (mUsimServiceTable != null && mParentApp.getType() != AppType.APPTYPE_SIM) {
+            if (mUsimServiceTable.isAvailable(UsimServiceTable.UsimService.MWI_STATUS)) {
+                if (DBG) log("MWIS support.");
+                mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
+                mRecordsToLoad++;
+            }
+        }
+    }
+
+    /**
+    *parse opl list
+    */
+    private void parseEFopl(ArrayList messages) {
+        int count = messages.size();
+        if (DBG) log("parseEFopl(): opl has " + count + " records");
+
+        mOperatorList = new ArrayList<OplRecord>(count);
+        for (int i = 0; i < count; i++) {
+            byte[] data = (byte[]) messages.get(i);
+
+            OplRecord oplRec = new OplRecord();
+
+            oplRec.sPlmn = IccUtils.parsePlmnToStringForEfOpl(data, 0, 3); // ALPS00316057
+
+            byte[] minLac = new byte[2];
+            minLac[0] = data[3];
+            minLac[1] = data[4];
+            oplRec.nMinLAC = Integer.parseInt(IccUtils.bytesToHexString(minLac), 16);
+
+            byte[] maxLAC = new byte[2];
+            maxLAC[0] = data[5];
+            maxLAC[1] = data[6];
+            oplRec.nMaxLAC = Integer.parseInt(IccUtils.bytesToHexString(maxLAC), 16);
+
+            byte[] pnnRecordIndex = new byte[1];
+            pnnRecordIndex[0] = data[7];
+            oplRec.nPnnIndex = Integer.parseInt(IccUtils.bytesToHexString(pnnRecordIndex), 16);
+            if (DBG) {
+                log("parseEFopl(): record=" + i + " content=" + IccUtils.bytesToHexString(data) +
+                        " sPlmn=" + oplRec.sPlmn + " nMinLAC=" + oplRec.nMinLAC +
+                        " nMaxLAC=" + oplRec.nMaxLAC + " nPnnIndex=" + oplRec.nPnnIndex);
+            }
+
+            mOperatorList.add(oplRec);
+        }
+    }
+
+    private void boradcastEfRatContentNotify(int item) {
+        Intent intent = new Intent(TelephonyIntents.ACTION_EF_RAT_CONTENT_NOTIFY);
+        intent.putExtra(TelephonyIntents.EXTRA_EF_RAT_STATUS, item);
+        intent.putExtra(PhoneConstants.SLOT_KEY, mSlotId);
+        log("broadCast intent ACTION_EF_RAT_CONTENT_NOTIFY: item: " + item + ", simId: " + mSlotId);
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+    }
+
+    // ALPS00302698 ENS
+    private void processEfCspPlmnModeBitUrc(int bit) {
+        log("processEfCspPlmnModeBitUrc: bit = " + bit);
+        if (bit == 0) {
+            mCspPlmnEnabled = false;
+        } else {
+            mCspPlmnEnabled = true;
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_EF_CSP_CONTENT_NOTIFY);
+        intent.putExtra(TelephonyIntents.EXTRA_PLMN_MODE_BIT, bit);
+        intent.putExtra(PhoneConstants.SLOT_KEY, mSlotId);
+        log("broadCast intent ACTION_EF_CSP_CONTENT_NOTIFY, EXTRA_PLMN_MODE_BIT: " +  bit);
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+
+    }
+
+    private void fetchLanguageIndicator() {
+        log("fetchLanguageIndicator ");
+        String l = SystemProperties.get("persist.sys.language");
+        String c = SystemProperties.get("persist.sys.country");
+        String oldSimLang = SystemProperties.get("persist.sys.simlanguage");
+        if ((null == l || 0 == l.length()) && (null == c || 0 == c.length())
+                         && (null == oldSimLang || 0 == oldSimLang.length())) {
+            if (mEfLi == null) {
+                mFh.loadEFTransparent(EF_LI,
+                       obtainMessage(EVENT_GET_LI_DONE));
+                efLanguageToLoad++;
+            }
+            mFh.loadEFTransparent(EF_ELP,
+                   obtainMessage(EVENT_GET_ELP_DONE));
+            efLanguageToLoad++;
+        }
+    }
+
+    private void onLanguageFileLoaded() {
+        efLanguageToLoad--;
+        log("onLanguageFileLoaded efLanguageToLoad is " + efLanguageToLoad);
+        if (efLanguageToLoad == 0) {
+            log("onLanguageFileLoaded all language file loaded");
+            if (mEfLi != null || mEfELP != null) {
+                setLanguageFromSIM();
+            } else {
+                log("onLanguageFileLoaded all language file are not exist!");
+            }
+        }
+    }
+
+    private void setLanguageFromSIM() {
+        log("setLanguageFromSIM ");
+        boolean bMatched = false;
+
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            bMatched = getMatchedLocaleByLI(mEfLi);
+        } else {
+            bMatched = getMatchedLocaleByLP(mEfLi);
+        }
+        if (!bMatched && mEfELP != null) {
+            bMatched = getMatchedLocaleByLI(mEfELP);
+        }
+        log("setLanguageFromSIM End");
+    }
+
+    private boolean getMatchedLocaleByLI(byte[] data) {
+        boolean ret = false;
+        if (data == null) {
+            return ret;
+        }
+        int lenOfLI = data.length;
+        String lang = null;
+        for (int i = 0; i + 2 <= lenOfLI; i += 2) {
+            lang = IccUtils.parseLanguageIndicator(data, i, 2);
+            log("USIM language in language indicator: i is " + i + " language is " + lang);
+            if (lang == null || lang.equals("")) {
+                log("USIM language in language indicator: i is " + i + " language is empty");
+                break;
+            }
+            lang = lang.toLowerCase();
+            ret = matchLangToLocale(lang);
+
+            if (ret) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    private boolean getMatchedLocaleByLP(byte[] data) {
+        boolean ret = false;
+        if (data == null) {
+            return ret;
+        }
+        int lenOfLP = data.length;
+        String lang = null;
+        for (int i = 0; i < lenOfLP; i++) {
+            int index = (int) mEfLi[0] & 0xff;
+            if (0x00 <= index && index <= 0x0f) {
+                lang = LANGUAGE_CODE_FOR_LP[index];
+            } else if (0x20 <= index && index <= 0x2f) {
+                lang = LANGUAGE_CODE_FOR_LP[index - 0x10];
+            }
+
+            log("SIM language in language preference: i is " + i + " language is " + lang);
+            if (lang == null || lang.equals("")) {
+                log("SIM language in language preference: i is " + i + " language is empty");
+                break;
+            }
+
+            ret = matchLangToLocale(lang);
+
+            if (ret) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    private boolean matchLangToLocale(String lang) {
+        boolean ret = false;
+        String[] locals = mContext.getAssets().getLocales();
+        int localsSize = locals.length;
+        for (int i = 0 ; i < localsSize; i++) {
+            String s = locals[i];
+            int len = s.length();
+            if (len == 5) {
+                String language = s.substring(0, 2);
+                log("Supported languages: the i" + i + " th is " + language);
+                if (lang.equals(language)) {
+                    ret = true;
+                    //MccTable.setSystemLocale(mContext, lang, s.substring(3, 5));
+                    log("Matched! lang: " + lang + ", country is " + s.substring(3, 5));
+                    break;
+                }
+            }
+        }
+        return ret;
+    }
+
+    /*
+      Detail description:
+      This feature provides a interface to get menu title string from EF_SUME
+    */
+    public String getMenuTitleFromEf() {
+        return mMenuTitleFromEf;
+    }
+
+    private void fetchCPHSOns() {
+        if (DBG) log("fetchCPHSOns()");
+        cphsOnsl = null;
+        cphsOnss = null;
+        mFh.loadEFTransparent(EF_SPN_CPHS,
+               obtainMessage(EVENT_GET_CPHSONS_DONE));
+        mRecordsToLoad++;
+        mFh.loadEFTransparent(
+               EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SHORT_CPHSONS_DONE));
+        mRecordsToLoad++;
+    }
+
+    // ALPS00302702 RAT balancing START
+    private void fetchRatBalancing() {
+        // TODO: wait for isSetLanguageBySIM ready
+        if (mTelephonyExt.isSetLanguageBySIM())
+            return;
+        log("support MTK_RAT_BALANCING");
+
+        if (mParentApp.getType() == AppType.APPTYPE_USIM) {
+            log("start loading EF_RAT");
+            mFh.loadEFTransparent(EF_RAT, obtainMessage(EVENT_GET_RAT_DONE));
+            mRecordsToLoad++;
+        }
+        else if (mParentApp.getType() == AppType.APPTYPE_SIM) {
+            // broadcast & set no file
+            log("loading EF_RAT fail, because of SIM");
+            mEfRatLoaded = false;
+            mEfRat = null;
+            boradcastEfRatContentNotify(EF_RAT_FOR_OTHER_CASE);
+        }
+        else {
+            log("loading EF_RAT fail, because of +EUSIM");
+        }
+    }
+
+    public int getEfRatBalancing() {
+        log("getEfRatBalancing: iccCardType = " + mParentApp.getType()
+                + ", mEfRatLoaded = " + mEfRatLoaded + ", mEfRat is null = " + (mEfRat == null));
+
+        if ((mParentApp.getType() == AppType.APPTYPE_USIM) && mEfRatLoaded && mEfRat == null) {
+            return EF_RAT_NOT_EXIST_IN_USIM;
+        }
+        return EF_RAT_FOR_OTHER_CASE;
+    }
+    // ALPS00302702 RAT balancing END
+
+    public boolean isHPlmn(String plmn) {
+        ServiceStateTracker sst = null;
+
+        sst = mPhone.getServiceStateTracker();
+
+        if (sst != null) {
+            return sst.isHPlmn(plmn);
+        } else {
+            if (DBG) log("can't get sst");
+            return false;
+        }
+    }
+
+    // ALPS00359372 for at&t testcase, mnc 2 should match 3 digits
+    private boolean isMatchingPlmnForEfOpl(String simPlmn, String bcchPlmn) {
+        if (simPlmn == null || simPlmn.equals("") || bcchPlmn == null || bcchPlmn.equals(""))
+            return false;
+
+        if (DBG) log("isMatchingPlmnForEfOpl(): simPlmn = " + simPlmn + ", bcchPlmn = " + bcchPlmn);
+
+        /*  3GPP TS 23.122 Annex A (normative): HPLMN Matching Criteria
+            For PCS1900 for North America, regulations mandate that a 3-digit MNC shall be used;
+            however during a transition period, a 2 digit MNC may be broadcast by the Network and,
+            in this case, the 3rd digit of the SIM is stored as 0 (this is the 0 suffix rule). */
+        int simPlmnLen = simPlmn.length();
+        int bcchPlmnLen = bcchPlmn.length();
+        if (simPlmnLen < 5 || bcchPlmnLen < 5)
+            return false;
+
+        int i = 0;
+        for (i = 0; i < 5; i++) {
+            if (simPlmn.charAt(i) == 'd')
+                continue;
+            if (simPlmn.charAt(i) != bcchPlmn.charAt(i))
+                return false;
+        }
+
+        if (simPlmnLen == 6 && bcchPlmnLen == 6) {
+            if (simPlmn.charAt(5) == 'd' || simPlmn.charAt(5) == bcchPlmn.charAt(5)) {
+                return true;
+            } else {
+                return false;
+            }
+        } else if (bcchPlmnLen == 6 && bcchPlmn.charAt(5) != '0' && bcchPlmn.charAt(5) != 'd') {
+            return false;
+        } else if (simPlmnLen == 6 && simPlmn.charAt(5) != '0' && simPlmn.charAt(5) != 'd') {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean isPlmnEqualsSimNumeric(String plmn) {
+        String mccmnc = getOperatorNumeric();
+        if (plmn == null) return false;
+
+        if (mccmnc == null || mccmnc.equals("")) {
+            log("isPlmnEqualsSimNumeric: getOperatorNumeric error: " + mccmnc);
+            return false;
+        }
+
+        if (plmn.equals(mccmnc)) {
+            return true;
+        } else {
+            if (plmn.length() == 5 && mccmnc.length() == 6
+                && plmn.equals(mccmnc.substring(0, 5))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+
+    // ALPS00267605 : PNN/OPL revision
+    public String getEonsIfExist(String plmn, int nLac, boolean bLongNameRequired) {
+        if (DBG) {
+            log("EONS getEonsIfExist: plmn is " + plmn + " nLac is " +
+                    nLac + " bLongNameRequired: " + bLongNameRequired);
+        }
+        if (plmn == null || mPnnNetworkNames == null || mPnnNetworkNames.size() == 0) {
+            return null;
+        }
+
+        int nPnnIndex = -1;
+        boolean isHPLMN = isPlmnEqualsSimNumeric(plmn);
+
+        if (mOperatorList == null) {
+            // case for EF_PNN only
+            if (isHPLMN) {
+                if (DBG) log("getEonsIfExist: Plmn is HPLMN, return PNN's first record");
+                nPnnIndex = 1;
+            } else {
+                if (DBG) log("getEonsIfExist: Plmn is not HPLMN and no mOperatorList, return null");
+                return null;
+            }
+        } else {
+            //search EF_OPL using plmn & nLac
+            for (int i = 0; i < mOperatorList.size(); i++) {
+                OplRecord oplRec = mOperatorList.get(i);
+
+                // ALPS00316057
+                //if((plmn.equals(oplRec.sPlmn) ||(!oplRec.sPlmn.equals("") &&
+                //      plmn.startsWith(oplRec.sPlmn))) &&
+                if (isMatchingPlmnForEfOpl(oplRec.sPlmn, plmn) &&
+                        ((oplRec.nMinLAC == 0 && oplRec.nMaxLAC == 0xfffe) ||
+                        (oplRec.nMinLAC <= nLac && oplRec.nMaxLAC >= nLac))) {
+                    if (DBG) log("getEonsIfExist: find it in EF_OPL");
+                    if (oplRec.nPnnIndex == 0) {
+                        if (DBG) log("getEonsIfExist: oplRec.nPnnIndex is 0, from other sources");
+                        return null;
+                    }
+                    nPnnIndex = oplRec.nPnnIndex;
+                    break;
+                }
+            }
+        }
+
+        //ALPS00312727, 11603, add check (mOperatorList.size() == 1
+        if (nPnnIndex == -1 && isHPLMN && (mOperatorList.size() == 1)) {
+            if (DBG) {
+                log("getEonsIfExist: not find it in EF_OPL, but Plmn is HPLMN," +
+                        " return PNN's first record");
+            }
+            nPnnIndex = 1;
+        }
+        else if (nPnnIndex > 1 && nPnnIndex > mPnnNetworkNames.size() && isHPLMN) {
+            if (DBG) {
+                log("getEonsIfExist: find it in EF_OPL, but index in EF_OPL > EF_PNN list" +
+                        " length & Plmn is HPLMN, return PNN's first record");
+            }
+            nPnnIndex = 1;
+        }
+        else if (nPnnIndex > 1 && nPnnIndex > mPnnNetworkNames.size() && !isHPLMN) {
+            if (DBG) {
+                log("getEonsIfExist: find it in EF_OPL, but index in EF_OPL > EF_PNN list" +
+                        " length & Plmn is not HPLMN, return PNN's first record");
+            }
+            nPnnIndex = -1;
+        }
+
+        String sEons = null;
+        if (nPnnIndex >= 1) {
+            OperatorName opName = mPnnNetworkNames.get(nPnnIndex - 1);
+            if (bLongNameRequired) {
+                if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                } else if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                }
+            } else if (!bLongNameRequired) {
+                if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                } else if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                }
+            }
+        }
+        if (DBG) log("getEonsIfExist: sEons is " + sEons);
+
+        return sEons;
+
+        /*int nPnnIndex = -1;
+        //check if the plmn is Hplmn, return the first record of pnn
+        if (isHPlmn(plmn)) {
+            nPnnIndex = 1;
+            if (DBG) log("EONS getEonsIfExist Plmn is hplmn");
+        } else {
+            //search the plmn from opl and if the LAC in the range of opl
+            for (int i = 0; i < mOperatorList.size(); i++) {
+                OplRecord oplRec = mOperatorList.get(i);
+                //check if the plmn equals with the plmn in the operator list
+                //or starts with the plmn in the operator list(which include wild char 'D')
+                if((plmn.equals(oplRec.sPlmn) ||(!oplRec.sPlmn.equals("") &&
+                        plmn.startsWith(oplRec.sPlmn))) &&
+                        ((oplRec.nMinLAC == 0 && oplRec.nMaxLAC == 0xfffe) ||
+                        (oplRec.nMinLAC <= nLac && oplRec.nMaxLAC >= nLac))) {
+                    nPnnIndex = oplRec.nPnnIndex;
+                    break;
+                }
+                if (DBG) log("EONS getEonsIfExist record number is " + i + " sPlmn: " +
+                        oplRec.sPlmn + " nMinLAC: " + oplRec.nMinLAC + " nMaxLAC: " +
+                        oplRec.nMaxLAC + " PnnIndex " + oplRec.nPnnIndex);
+            }
+            if (nPnnIndex == 0) {
+                // not HPLMN and the index is 0 indicates that the
+                // name is to be taken from other sources
+                return null;
+            }
+        }
+        if (DBG) log("EONS getEonsIfExist Index of pnn is  " + nPnnIndex);
+
+        String sEons = null;
+        if (nPnnIndex >= 1) {
+            OperatorName opName = mPnnNetworkNames.get(nPnnIndex - 1);
+            if (bLongNameRequired) {
+                if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                } else if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                }
+            } else if (!bLongNameRequired ) {
+                if (opName.sShortName != null) {
+                    sEons = new String(opName.sShortName);
+                } else if (opName.sFullName != null) {
+                    sEons = new String(opName.sFullName);
+                }
+            }
+        }
+        if (DBG) log("EONS getEonsIfExist sEons is " + sEons);
+        return sEons;*/
+    }
+
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     */
+    public String getEfGbabp() {
+        log("GBABP = " + mGbabp);
+        return mGbabp;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     */
+    public void setEfGbabp(String gbabp, Message onComplete) {
+        byte[] data = IccUtils.hexStringToBytes(gbabp);
+
+        log("setEfGbabp data = " + data);
+        mFh.updateEFTransparent(EF_GBABP, data, onComplete);
+    }
+
+    /**
+     * Returns the Public Service Identity of the SM-SC (PSISMSC) that was loaded from the USIM.
+     * @return PSISMSC or null if not present or not loaded
+     */
+    public byte[] getEfPsismsc() {
+        log("PSISMSC = " + mEfPsismsc);
+        return mEfPsismsc;
+    }
+
+    /**
+     * Returns the Short message parameter (SMSP) that was loaded from the USIM.
+     * @return PSISMSC or null if not present or not loaded
+     */
+    public byte[] getEfSmsp() {
+        log("mEfSmsp = " + mEfPsismsc);
+        return mEfSmsp;
+    }
+
+    /**
+     * Returns the MCC+MNC length that was loaded from the USIM.
+     * @return MCC+MNC length or 0 if not present or not loaded
+     */
+    public int getMncLength() {
+        log("mncLength = " + mMncLength);
+        return mMncLength;
+    }
+
+    private class RebootClickListener
+            implements DialogInterface.OnClickListener {
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            log("Unlock Phone onClick");
+            PowerManager pm = (PowerManager) mContext
+                    .getSystemService(Context.POWER_SERVICE);
+            pm.reboot("Unlock state changed");
+        }
+    }
+    public void broadcastPhbStateChangedIntent(boolean isReady) {
+        // M: for avoid repeate intent from GSMPhone and CDMAPhone
+        if (mPhone.getPhoneType() != PhoneConstants.PHONE_TYPE_GSM) {
+            log("broadcastPhbStateChangedIntent, Not active Phone.");
+            return;
+        }
+
+        log("broadcastPhbStateChangedIntent, mPhbReady " + mPhbReady);
+        if (isReady == true) {
+            int phoneId = mParentApp.getPhoneId();
+            mSubId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+
+            String strAllSimState = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+            String strCurSimState = "";
+
+            if ((strAllSimState != null) && (strAllSimState.length() > 0)) {
+                String values[] = strAllSimState.split(",");
+                if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
+                    strCurSimState = values[phoneId];
+                }
+            }
+
+            if (mSubId <= 0 || strCurSimState.equals("NOT_READY")) {
+                log("broadcastPhbStateChangedIntent, mSubId " + mSubId
+                    + ", sim state " + strAllSimState);
+                mPhbWaitSub = true;
+                return;
+            }
+        } else {
+            if (mSubId <= 0) {
+                log("broadcastPhbStateChangedIntent, isReady == false and mSubId <= 0");
+                return;
+            }
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_PHB_STATE_CHANGED);
+        intent.putExtra("ready", isReady);
+        intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mSubId);
+        if (DBG) log("Broadcasting intent ACTION_PHB_STATE_CHANGED " + isReady
+                    + " sub id " + mSubId + " phoneId " + mParentApp.getPhoneId());
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+
+        if (isReady == false) {
+            mSubId = -1;
+        }
+    }
+
+    public boolean isPhbReady() {
+        if (DBG) log("isPhbReady(): cached mPhbReady = " + (mPhbReady ? "true" : "false"));
+        String strPhbReady = "false";
+        String strAllSimState = "";
+        String strCurSimState = "";
+        boolean isSimLocked = false;
+        int phoneId = mParentApp.getPhoneId();
+
+        strPhbReady = SystemProperties.get(
+                SIMRECORD_PROPERTY_RIL_PHB_READY[mParentApp.getSlotId()], "false");
+        strAllSimState = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+
+        if ((strAllSimState != null) && (strAllSimState.length() > 0)) {
+            String values[] = strAllSimState.split(",");
+            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
+                strCurSimState = values[phoneId];
+            }
+        }
+
+        isSimLocked = (strCurSimState.equals("NETWORK_LOCKED") ||
+                       strCurSimState.equals("PIN_REQUIRED"));
+                        //In PUK_REQUIRED state, phb can be accessed.
+
+        if (DBG) log("isPhbReady(): mPhbReady = " + (mPhbReady ? "true" : "false") +
+                     ", strCurSimState = " + strCurSimState);
+        return (strPhbReady.equals("true") && !isSimLocked);
+    }
+
+    public void setPhbReady(boolean isReady) {
+        if (DBG) log("setPhbReady(): isReady = " + (isReady ? "true" : "false"));
+        if (mPhbReady != isReady) {
+            String strPhbReady = isReady ? "true" : "false";
+            mPhbReady = isReady;
+            SystemProperties.set(
+                    SIMRECORD_PROPERTY_RIL_PHB_READY[mParentApp.getSlotId()], strPhbReady);
+            broadcastPhbStateChangedIntent(mPhbReady);
+        }
+    }
+    // add for alps01947090
+    public boolean isRadioAvailable() {
+        if (mCi != null) {
+          return mCi.getRadioState().isAvailable();
+        }
+        return false;
+    }
+
+    /** M: Bug Fix for ALPS02189616. */
+    // add new code for svlte romaing case.
+
+    /**
+     * Inner private class for revice broad cast ACTION_RADIO_TECHNOLOGY_CHANGED.
+     */
+    private class RadioTechnologyChangedReceiver extends BroadcastReceiver {
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+             if (action.equals(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED)) {
+                 // listener radio technology changed. If it not own object phone
+                 // broadcast false.
+                 // if it own object, send delay message to broadcast PHB_CHANGE
+                 // event. APP will receive PHB_CHANGE broadcast and init phonebook.
+                 int phoneid = intent.getIntExtra(PhoneConstants.PHONE_KEY, -1);
+                 log("[ACTION_RADIO_TECHNOLOGY_CHANGED] phoneid : " + phoneid);
+                 if (null != mParentApp && mParentApp.getPhoneId() == phoneid) {
+                     String cdmaPhoneName = "CDMA";
+                     int delayedTime = 500;
+                     String activePhoneName = intent.getStringExtra(PhoneConstants.PHONE_NAME_KEY);
+                     int subid = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1);
+                     log("[ACTION_RADIO_TECHNOLOGY_CHANGED] activePhoneName : " + activePhoneName
+                             + " | subid : " + subid);
+                     if (!cdmaPhoneName.equals(activePhoneName)) {
+                         sendMessageDelayed(obtainMessage(EVENT_DELAYED_SEND_PHB_CHANGE),
+                                 delayedTime);
+                         mAdnCache.reset();
+                     }
+                 }
+             }
+        }
+    }
+    // PHB Refactoring ++++
+    @Override
+    protected int getChildPhoneId() {
+        int phoneId = mParentApp.getPhoneId();
+        log("[getChildPhoneId] phoneId = " + phoneId);
+        return phoneId;
+    }
+
+    @Override
+    protected void updatePHBStatus(int status, boolean isSimLocked) {
+        log("[updatePHBStatus] status : " + status + " | isSimLocked : " + isSimLocked
+                + " | mPhbReady : " + mPhbReady);
+
+        // M: PHB Revise
+        if (status == GSM_PHB_READY) {
+            if (false == isSimLocked) {
+                if (mPhbReady == false) {
+                    mPhbReady = true;
+                    broadcastPhbStateChangedIntent(mPhbReady);
+                }
+            } else {
+                log("phb ready but sim is not ready.");
+            }
+        } else if (status == GSM_PHB_NOT_READY) {
+            if (mPhbReady == true) {
+                mAdnCache.reset();
+                mPhbReady = false;
+                broadcastPhbStateChangedIntent(mPhbReady);
+            }
+        }
+    }
+    // PHB Refactoring ----
+    // MTK-END
+
+    // MTK-START
+    private String convertNumberIfContainsPrefix(String dialNumber) {
+        String r = dialNumber;
+        if (dialNumber != null &&
+            (dialNumber.startsWith("tel:") ||
+             dialNumber.startsWith("sip:") ||
+             dialNumber.startsWith("sips:"))) {
+            r = dialNumber.substring(dialNumber.indexOf(":") + 1);
+            Rlog.d(LOG_TAG, "convertNumberIfContainsPrefix: dialNumber = " + dialNumber);
+        }
+        return r;
+    }
+    // MTK-END
+}
Index: vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/frameworks/opt/telephony/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java	(revision 15112)
@@ -0,0 +1,1598 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.cat;
+
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+
+import com.android.internal.telephony.GsmAlphabet;
+import com.android.internal.telephony.uicc.IccFileHandler;
+
+import java.util.Iterator;
+import java.util.List;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.USER_ACTIVITY_EVENT;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.IDLE_SCREEN_AVAILABLE_EVENT;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.LANGUAGE_SELECTION_EVENT;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.BROWSER_TERMINATION_EVENT;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.BROWSING_STATUS_EVENT;
+/// M: BIP {
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.DATA_AVAILABLE_EVENT;
+import static com.android.internal.telephony.cat.CatCmdMessage.
+                   SetupEventListConstants.CHANNEL_STATUS_EVENT;
+/// M: BIP }
+/**
+ * Factory class, used for decoding raw byte arrays, received from baseband,
+ * into a CommandParams object.
+ *
+ */
+class CommandParamsFactory extends Handler {
+    private static CommandParamsFactory sInstance = null;
+    private IconLoader mIconLoader;
+    private CommandParams mCmdParams = null;
+    private int mIconLoadState = LOAD_NO_ICON;
+    private RilMessageDecoder mCaller = null;
+    private boolean mloadIcon = false;
+
+    private Context mContext;
+    // used to mark the index of tlv object in a tlv list
+    int tlvIndex = -1;
+
+    // constants
+    static final int MSG_ID_LOAD_ICON_DONE = 1;
+
+    // loading icons state parameters.
+    static final int LOAD_NO_ICON           = 0;
+    static final int LOAD_SINGLE_ICON       = 1;
+    static final int LOAD_MULTI_ICONS       = 2;
+
+    // Command Qualifier values for refresh command
+    static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
+    static final int REFRESH_NAA_INIT_AND_FILE_CHANGE       = 0x02;
+    static final int REFRESH_NAA_INIT                       = 0x03;
+    static final int REFRESH_UICC_RESET                     = 0x04;
+
+    // Command Qualifier values for PLI command
+    static final int DTTZ_SETTING                           = 0x03;
+    static final int LANGUAGE_SETTING                       = 0x04;
+    static final int BATTERY_STATE                          = 0x0A;
+
+    // As per TS 102.223 Annex C, Structure of CAT communications,
+    // the APDU length can be max 255 bytes. This leaves only 239 bytes for user
+    // input string. CMD details TLV + Device IDs TLV + Result TLV + Other
+    // details of TextString TLV not including user input take 16 bytes.
+    //
+    // If UCS2 encoding is used, maximum 118 UCS2 chars can be encoded in 238 bytes.
+    // Each UCS2 char takes 2 bytes. Byte Order Mask(BOM), 0xFEFF takes 2 bytes.
+    //
+    // If GSM 7 bit default(use 8 bits to represent a 7 bit char) format is used,
+    // maximum 239 chars can be encoded in 239 bytes since each char takes 1 byte.
+    //
+    // No issues for GSM 7 bit packed format encoding.
+
+    private static final int MAX_GSM7_DEFAULT_CHARS = 239;
+    private static final int MAX_UCS2_CHARS = 118;
+
+    static synchronized CommandParamsFactory getInstance(RilMessageDecoder caller,
+            IccFileHandler fh) {
+        if (sInstance != null) {
+            return sInstance;
+        }
+        if (fh != null) {
+            return new CommandParamsFactory(caller, fh);
+        }
+        return null;
+    }
+
+    static synchronized CommandParamsFactory getInstance(RilMessageDecoder caller,
+            IccFileHandler fh, Context context) {
+        if (sInstance != null) {
+            return sInstance;
+        }
+
+        if (fh != null && context != null) {
+            return new CommandParamsFactory(caller, fh, context);
+        }
+
+        return null;
+    }
+
+    private CommandParamsFactory(RilMessageDecoder caller, IccFileHandler fh, Context context) {
+        mCaller = caller;
+        mIconLoader = IconLoader.getInstance(this, fh, mCaller.getSlotId());
+        mContext = context;
+    }
+
+    private CommandParamsFactory(RilMessageDecoder caller, IccFileHandler fh) {
+        mCaller = caller;
+        mIconLoader = IconLoader.getInstance(this, fh, mCaller.getSlotId());
+    }
+
+    private CommandDetails processCommandDetails(List<ComprehensionTlv> ctlvs)
+        throws ResultException {
+
+        CommandDetails cmdDet = null;
+
+        if (ctlvs != null) {
+            // Search for the Command Details object.
+            ComprehensionTlv ctlvCmdDet = searchForTag(
+                    ComprehensionTlvTag.COMMAND_DETAILS, ctlvs);
+            if (ctlvCmdDet != null) {
+                try {
+                    cmdDet = ValueParser.retrieveCommandDetails(ctlvCmdDet);
+                } catch (ResultException e) {
+                    CatLog.d(this, "Failed to procees command details");
+                    throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+                }
+            }
+        }
+        return cmdDet;
+    }
+
+    void make(BerTlv berTlv) {
+        if (berTlv == null) {
+            return;
+        }
+        // reset global state parameters.
+        mCmdParams = null;
+        mIconLoadState = LOAD_NO_ICON;
+        // only proactive command messages are processed.
+        if (berTlv.getTag() != BerTlv.BER_PROACTIVE_COMMAND_TAG) {
+            CatLog.e(this, "CPF-make: Ununderstood proactive command tag");
+            sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
+            return;
+        }
+        boolean cmdPending = false;
+        List<ComprehensionTlv> ctlvs = berTlv.getComprehensionTlvs();
+        // process command dtails from the tlv list.
+        CommandDetails cmdDet = null;
+        try {
+            cmdDet = processCommandDetails(ctlvs);
+        } catch (ResultException e) {
+            CatLog.e(this, "CPF-make: Except to procees command details : " + e.result());
+            sendCmdParams(e.result());
+            return;
+        }
+        if (cmdDet == null) {
+            CatLog.e(this, "CPF-make: No CommandDetails object");
+            sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
+            return;
+        }
+
+        // extract command type enumeration from the raw value stored inside
+        // the Command Details object.
+        AppInterface.CommandType cmdType = AppInterface.CommandType
+                .fromInt(cmdDet.typeOfCommand);
+        if (cmdType == null) {
+            CatLog.d(this, "CPF-make: Command type can't be found");
+             // This PROACTIVE COMMAND is presently not handled. Hence set
+            // result code as BEYOND_TERMINAL_CAPABILITY in TR.
+            mCmdParams = new CommandParams(cmdDet);
+            sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
+            return;
+        }
+
+        // proactive command length is incorrect.
+        if (!berTlv.isLengthValid()) {
+            mCmdParams = new CommandParams(cmdDet);
+            sendCmdParams(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            return;
+        }
+
+        try {
+            switch (cmdType) {
+            case SET_UP_MENU:
+                cmdPending = processSelectItem(cmdDet, ctlvs);
+                break;
+            case SELECT_ITEM:
+                cmdPending = processSelectItem(cmdDet, ctlvs);
+                break;
+            case DISPLAY_TEXT:
+                cmdPending = processDisplayText(cmdDet, ctlvs);
+                break;
+             case SET_UP_IDLE_MODE_TEXT:
+                 cmdPending = processSetUpIdleModeText(cmdDet, ctlvs);
+                 break;
+             case GET_INKEY:
+                cmdPending = processGetInkey(cmdDet, ctlvs);
+                break;
+             case GET_INPUT:
+                 cmdPending = processGetInput(cmdDet, ctlvs);
+                 break;
+             case SEND_DTMF:
+             case SEND_SMS:
+             case SEND_SS:
+             case SEND_USSD:
+                 cmdPending = processEventNotify(cmdDet, ctlvs);
+                 break;
+             case GET_CHANNEL_STATUS:
+             case SET_UP_CALL:
+                 cmdPending = processSetupCall(cmdDet, ctlvs);
+                 break;
+             case REFRESH:
+                processRefresh(cmdDet, ctlvs);
+                cmdPending = false;
+                break;
+             case LAUNCH_BROWSER:
+                 cmdPending = processLaunchBrowser(cmdDet, ctlvs);
+                 break;
+             case PLAY_TONE:
+                cmdPending = processPlayTone(cmdDet, ctlvs);
+                break;
+             case SET_UP_EVENT_LIST:
+                 cmdPending = processSetUpEventList(cmdDet, ctlvs);
+                 break;
+             case PROVIDE_LOCAL_INFORMATION:
+                cmdPending = processProvideLocalInfo(cmdDet, ctlvs);
+                break;
+             case OPEN_CHANNEL:
+             case CLOSE_CHANNEL:
+             case RECEIVE_DATA:
+             case SEND_DATA:
+                 cmdPending = processBIPClient(cmdDet, ctlvs);
+                 break;
+            case ACTIVATE:
+                cmdPending = processActivate(cmdDet, ctlvs);
+                break;
+            default:
+                // unsupported proactive commands
+                mCmdParams = new CommandParams(cmdDet);
+                CatLog.d(this, "CPF-make: default case");
+                sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
+                return;
+            }
+        } catch (ResultException e) {
+            CatLog.d(this, "make: caught ResultException e=" + e);
+            mCmdParams = new CommandParams(cmdDet);
+            sendCmdParams(e.result());
+            return;
+        }
+        if (!cmdPending) {
+            sendCmdParams(ResultCode.OK);
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        switch (msg.what) {
+        case MSG_ID_LOAD_ICON_DONE:
+            sendCmdParams(setIcons(msg.obj));
+            break;
+        }
+    }
+
+    private ResultCode setIcons(Object data) {
+        Bitmap[] icons = null;
+        int iconIndex = 0;
+
+        if (data == null) {
+            CatLog.d(this, "Optional Icon data is NULL");
+            mCmdParams.mLoadIconFailed = true;
+            mloadIcon = false;
+            /** In case of icon load fail consider the
+            ** received proactive command as valid (sending RESULT OK) as
+            ** The result code, 'PRFRMD_ICON_NOT_DISPLAYED' will be added in the
+            ** terminal response by CatService/StkAppService if needed based on
+            ** the value of mLoadIconFailed.
+            */
+            return ResultCode.OK;
+        }
+        switch(mIconLoadState) {
+        case LOAD_SINGLE_ICON:
+            mCmdParams.setIcon((Bitmap) data);
+            break;
+        case LOAD_MULTI_ICONS:
+            icons = (Bitmap[]) data;
+            // set each item icon.
+            for (Bitmap icon : icons) {
+                mCmdParams.setIcon(icon);
+                if (icon == null && mloadIcon) {
+                    CatLog.d(this, "Optional Icon data is NULL while loading multi icons");
+                    mCmdParams.mLoadIconFailed = true;
+                }
+            }
+            break;
+        }
+        return ResultCode.OK;
+    }
+
+    private void sendCmdParams(ResultCode resCode) {
+        if (mCaller != null) {
+            mCaller.sendMsgParamsDecoded(resCode, mCmdParams);
+        }
+    }
+
+    /**
+     * Search for a COMPREHENSION-TLV object with the given tag from a list
+     *
+     * @param tag A tag to search for
+     * @param ctlvs List of ComprehensionTlv objects used to search in
+     *
+     * @return A ComprehensionTlv object that has the tag value of {@code tag}.
+     *         If no object is found with the tag, null is returned.
+     */
+    private ComprehensionTlv searchForTag(ComprehensionTlvTag tag,
+            List<ComprehensionTlv> ctlvs) {
+        Iterator<ComprehensionTlv> iter = ctlvs.iterator();
+        return searchForNextTag(tag, iter);
+    }
+
+    /**
+     * Search for the next COMPREHENSION-TLV object with the given tag from a
+     * list iterated by {@code iter}. {@code iter} points to the object next to
+     * the found object when this method returns. Used for searching the same
+     * list for similar tags, usually item id.
+     *
+     * @param tag A tag to search for
+     * @param iter Iterator for ComprehensionTlv objects used for search
+     *
+     * @return A ComprehensionTlv object that has the tag value of {@code tag}.
+     *         If no object is found with the tag, null is returned.
+     */
+    private ComprehensionTlv searchForNextTag(ComprehensionTlvTag tag,
+            Iterator<ComprehensionTlv> iter) {
+        int tagValue = tag.value();
+        while (iter.hasNext()) {
+            ComprehensionTlv ctlv = iter.next();
+            if (ctlv.getTag() == tagValue) {
+                return ctlv;
+            }
+        }
+        return null;
+    }
+
+    private void resetTlvIndex() {
+        tlvIndex = -1;
+    }
+
+    /**
+     * Search for the next COMPREHENSION-TLV object with the given tag from a
+     * list iterated by {@code iter}. {@code iter} points to the object next to
+     * the found object when this method returns. Used for searching the same
+     * list for similar tags, usually item id. At the same time, this method
+     * will update a index to mark the position of the tlv object in the
+     * comprehension- tlv.
+     *
+     * @param tag A tag to search for
+     * @param iter Iterator for ComprehensionTlv objects used for search
+     * @return A ComprehensionTlv object that has the tag value of {@code tag}.
+     *         If no object is found with the tag, null is returned.
+     */
+    private ComprehensionTlv searchForNextTagAndIndex(ComprehensionTlvTag tag,
+            Iterator<ComprehensionTlv> iter) {
+        if (tag == null || iter == null) {
+            CatLog.d(this, "CPF-searchForNextTagAndIndex: Invalid params");
+            return null;
+        }
+
+        int tagValue = tag.value();
+
+        while (iter.hasNext()) {
+            ++tlvIndex;
+            ComprehensionTlv ctlv = iter.next();
+            if (ctlv.getTag() == tagValue) {
+                return ctlv;
+            }
+        }
+
+        // tlvIndex = -1;
+        return null;
+    }
+
+    /**
+     * Search for a COMPREHENSION-TLV object with the given tag from a list and
+     * provide the index of searched tlv object.
+     *
+     * @param tag A tag to search for
+     * @param ctlvs List of ComprehensionTlv objects used to search in
+     * @return A ComprehensionTlv object that has the tag value of {@code tag}.
+     *         If no object is found with the tag, null is returned.
+     */
+    private ComprehensionTlv searchForTagAndIndex(ComprehensionTlvTag tag,
+            List<ComprehensionTlv> ctlvs) {
+        // tlvIndex = -1;
+        resetTlvIndex();
+        Iterator<ComprehensionTlv> iter = ctlvs.iterator();
+        return searchForNextTagAndIndex(tag, iter);
+    }
+
+    /**
+     * Processes DISPLAY_TEXT proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processDisplayText(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs)
+            throws ResultException {
+
+        CatLog.d(this, "process DisplayText");
+
+        TextMessage textMsg = new TextMessage();
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING,
+                ctlvs);
+        if (ctlv != null) {
+            textMsg.text = ValueParser.retrieveTextString(ctlv);
+        }
+        // If the tlv object doesn't exist or the it is a null object reply
+        // with command not understood.
+        if (textMsg.text == null) {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.IMMEDIATE_RESPONSE, ctlvs);
+        if (ctlv != null) {
+            textMsg.responseNeeded = false;
+        }
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            try {
+                iconId = ValueParser.retrieveIconId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveIconId ResultException: " + e.result());
+            }
+            try {
+                textMsg.iconSelfExplanatory = iconId.selfExplanatory;
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "iconId is null.");
+            }
+        }
+        // parse tone duration
+        ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
+        if (ctlv != null) {
+            try {
+                textMsg.duration = ValueParser.retrieveDuration(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveDuration ResultException: " + e.result());
+            }
+        }
+
+        // Parse command qualifier parameters.
+        textMsg.isHighPriority = (cmdDet.commandQualifier & 0x01) != 0;
+        textMsg.userClear = (cmdDet.commandQualifier & 0x80) != 0;
+
+        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+
+        if (iconId != null) {
+            mloadIcon = true;
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes SET_UP_IDLE_MODE_TEXT proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processSetUpIdleModeText(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process SetUpIdleModeText");
+
+        TextMessage textMsg = new TextMessage();
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING,
+                ctlvs);
+        if (ctlv != null) {
+            textMsg.text = ValueParser.retrieveTextString(ctlv);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            iconId = ValueParser.retrieveIconId(ctlv);
+            textMsg.iconSelfExplanatory = iconId.selfExplanatory;
+        }
+
+        /*
+         * If the tlv object doesn't contain text and the icon is not self
+         * explanatory then reply with command not understood.
+         */
+
+        if (textMsg.text == null && iconId != null && !textMsg.iconSelfExplanatory) {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+
+        if (iconId != null) {
+            mloadIcon = true;
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes GET_INKEY proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processGetInkey(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process GetInkey");
+
+        Input input = new Input();
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING,
+                ctlvs);
+        if (ctlv != null) {
+            input.text = ValueParser.retrieveTextString(ctlv);
+        } else {
+            throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+        }
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            try {
+                iconId = ValueParser.retrieveIconId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveIconId ResultException: " + e.result());
+            }
+
+            try {
+                input.iconSelfExplanatory = iconId.selfExplanatory;
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "iconId is null.");
+            }
+        }
+
+        // parse duration
+        ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
+        if (ctlv != null) {
+            try {
+                input.duration = ValueParser.retrieveDuration(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveDuration ResultException: " + e.result());
+            }
+        }
+
+        input.minLen = 1;
+        input.maxLen = 1;
+
+        input.digitOnly = (cmdDet.commandQualifier & 0x01) == 0;
+        input.ucs2 = (cmdDet.commandQualifier & 0x02) != 0;
+        input.yesNo = (cmdDet.commandQualifier & 0x04) != 0;
+        input.helpAvailable = (cmdDet.commandQualifier & 0x80) != 0;
+        input.echo = true;
+
+        mCmdParams = new GetInputParams(cmdDet, input);
+
+        if (iconId != null) {
+            mloadIcon = true;
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes GET_INPUT proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processGetInput(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process GetInput");
+
+        Input input = new Input();
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING,
+                ctlvs);
+        if (ctlv != null) {
+            input.text = ValueParser.retrieveTextString(ctlv);
+        } else {
+            throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.RESPONSE_LENGTH, ctlvs);
+        if (ctlv != null) {
+            try {
+                byte[] rawValue = ctlv.getRawValue();
+                int valueIndex = ctlv.getValueIndex();
+                // The maximum input lenght is 239, because the
+                // maximum length of proactive command is 255
+                input.minLen = rawValue[valueIndex] & 0xff;
+                if (input.minLen > 239) {
+                    input.minLen = 239;
+                }
+
+                input.maxLen = rawValue[valueIndex + 1] & 0xff;
+                if (input.maxLen > 239) {
+                    input.maxLen = 239;
+                }
+            } catch (IndexOutOfBoundsException e) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        } else {
+            throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.DEFAULT_TEXT, ctlvs);
+        if (ctlv != null) {
+            try {
+                input.defaultText = ValueParser.retrieveTextString(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveTextString ResultException: " + e.result());
+            }
+        }
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            try {
+                iconId = ValueParser.retrieveIconId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveIconId ResultException: " + e.result());
+            }
+
+            try {
+                input.iconSelfExplanatory = iconId.selfExplanatory;
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "iconId is null.");
+            }
+        }
+
+        input.digitOnly = (cmdDet.commandQualifier & 0x01) == 0;
+        input.ucs2 = (cmdDet.commandQualifier & 0x02) != 0;
+        input.echo = (cmdDet.commandQualifier & 0x04) == 0;
+        input.packed = (cmdDet.commandQualifier & 0x08) != 0;
+        input.helpAvailable = (cmdDet.commandQualifier & 0x80) != 0;
+
+        // Truncate the maxLen if it exceeds the max number of chars that can
+        // be encoded. Limit depends on DCS in Command Qualifier.
+        if (input.ucs2 && input.maxLen > MAX_UCS2_CHARS) {
+            CatLog.d(this, "UCS2: received maxLen = " + input.maxLen +
+                  ", truncating to " + MAX_UCS2_CHARS);
+            input.maxLen = MAX_UCS2_CHARS;
+        } else if (!input.packed && input.maxLen > MAX_GSM7_DEFAULT_CHARS) {
+            CatLog.d(this, "GSM 7Bit Default: received maxLen = " + input.maxLen +
+                  ", truncating to " + MAX_GSM7_DEFAULT_CHARS);
+            input.maxLen = MAX_GSM7_DEFAULT_CHARS;
+        }
+
+        mCmdParams = new GetInputParams(cmdDet, input);
+
+        if (iconId != null) {
+            mloadIcon = true;
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes REFRESH proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     */
+    private boolean processRefresh(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) {
+
+        CatLog.d(this, "process Refresh");
+        TextMessage textMsg = new TextMessage();
+
+        // REFRESH proactive command is rerouted by the baseband and handled by
+        // the telephony layer. IDLE TEXT should be removed for a REFRESH command
+        // with "initialization" or "reset"
+        switch (cmdDet.commandQualifier) {
+        case REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE:
+        case REFRESH_NAA_INIT_AND_FILE_CHANGE:
+        case REFRESH_NAA_INIT:
+        case REFRESH_UICC_RESET:
+            textMsg.text = null;
+            mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+            break;
+        }
+        return false;
+    }
+
+    /**
+     * Processes SELECT_ITEM proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processSelectItem(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process SelectItem");
+
+        Menu menu = new Menu();
+        IconId titleIconId = null;
+        ItemsIconId itemsIconId = null;
+        Iterator<ComprehensionTlv> iter = ctlvs.iterator();
+
+        AppInterface.CommandType cmdType = AppInterface.CommandType
+                .fromInt(cmdDet.typeOfCommand);
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID,
+                ctlvs);
+        if (ctlv != null) {
+            try {
+                menu.title = ValueParser.retrieveAlphaId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveAlphaId ResultException: " + e.result());
+            }
+            CatLog.d(this, "add AlphaId: " + menu.title);
+            /*begin-chenhu*/
+            int def = mContext.getResources().getInteger(com.android.internal.R.integer.def_customized_stk_app_name);
+            if(def == 2) {
+                if (cmdDet.typeOfCommand == AppInterface.CommandType.SET_UP_MENU.value()) {
+                    if (menu.title != null && menu.title.length() <= SystemProperties.PROP_VALUE_MAX) {
+                        SystemProperties.set("gsm.stk.perso.app_title", menu.title);
+                    }
+                }
+            }
+            /*end-chenhu*/
+        } else if (cmdType == AppInterface.CommandType.SET_UP_MENU) {
+            // According to spec ETSI TS 102 223 section 6.10.3, the
+            // Alpha ID is mandatory (and also part of minimum set of
+            // elements required) for SET_UP_MENU. If it is not received
+            // by ME, then ME should respond with "error: missing minimum
+            // information" and not "command performed successfully".
+            throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+        }
+
+        while (true) {
+            ctlv = searchForNextTag(ComprehensionTlvTag.ITEM, iter);
+            if (ctlv != null) {
+                Item item = ValueParser.retrieveItem(ctlv);
+                //CatLog.d(this, "add menu item: " + ((item == null) ? "" : item.toString()));
+                menu.items.add(item);
+            } else {
+                break;
+            }
+        }
+
+        // We must have at least one menu item.
+        if (menu.items.size() == 0) {
+            CatLog.d(this, "no menu item");
+            throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.NEXT_ACTION_INDICATOR, ctlvs);
+        if (ctlv != null) {
+            try {
+            menu.nextActionIndicator = ValueParser.retrieveNextActionIndicator(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveNextActionIndicator ResultException: " + e.result());
+            }
+            try {
+            if (menu.nextActionIndicator.length != menu.items.size()) {
+                CatLog.d(this, "nextActionIndicator.length != number of menu items");
+                menu.nextActionIndicator = null;
+            }
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "nextActionIndicator is null.");
+            }
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.ITEM_ID, ctlvs);
+        if (ctlv != null) {
+            // CAT items are listed 1...n while list start at 0, need to
+            // subtract one.
+            try {
+                menu.defaultItem = ValueParser.retrieveItemId(ctlv) - 1;
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveItemId ResultException: " + e.result());
+            }
+            CatLog.d(this, "default item: " + menu.defaultItem);
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            mIconLoadState = LOAD_SINGLE_ICON;
+            try {
+                titleIconId = ValueParser.retrieveIconId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveIconId ResultException: " + e.result());
+            }
+            try {
+                menu.titleIconSelfExplanatory = titleIconId.selfExplanatory;
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "titleIconId is null.");
+            }
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.ITEM_ICON_ID_LIST, ctlvs);
+        if (ctlv != null) {
+            mIconLoadState = LOAD_MULTI_ICONS;
+            try {
+                itemsIconId = ValueParser.retrieveItemsIconId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveItemsIconId ResultException: " + e.result());
+            }
+            try {
+                menu.itemsIconSelfExplanatory = itemsIconId.selfExplanatory;
+            } catch (NullPointerException ne) {
+                CatLog.e(this, "itemsIconId is null.");
+            }
+        }
+
+        boolean presentTypeSpecified = (cmdDet.commandQualifier & 0x01) != 0;
+        if (presentTypeSpecified) {
+            if ((cmdDet.commandQualifier & 0x02) == 0) {
+                menu.presentationType = PresentationType.DATA_VALUES;
+            } else {
+                menu.presentationType = PresentationType.NAVIGATION_OPTIONS;
+            }
+        }
+        menu.softKeyPreferred = (cmdDet.commandQualifier & 0x04) != 0;
+        menu.helpAvailable = (cmdDet.commandQualifier & 0x80) != 0;
+
+        mCmdParams = new SelectItemParams(cmdDet, menu, titleIconId != null);
+
+        // Load icons data if needed.
+        switch(mIconLoadState) {
+        case LOAD_NO_ICON:
+            return false;
+        case LOAD_SINGLE_ICON:
+            if (titleIconId != null && titleIconId.recordNumber > 0) {
+                mloadIcon = true;
+                mIconLoader.loadIcon(titleIconId.recordNumber, this
+                        .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+                break;
+            } else {
+                return false;
+            }
+        case LOAD_MULTI_ICONS:
+            if (itemsIconId != null) {
+                int[] recordNumbers = itemsIconId.recordNumbers;
+                if (titleIconId != null) {
+                    // Create a new array for all the icons (title and items).
+                    recordNumbers = new int[itemsIconId.recordNumbers.length + 1];
+                    recordNumbers[0] = titleIconId.recordNumber;
+                    System.arraycopy(itemsIconId.recordNumbers, 0, recordNumbers,
+                            1, itemsIconId.recordNumbers.length);
+                }
+                mloadIcon = true;
+                mIconLoader.loadIcons(recordNumbers, this
+                        .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+                break;
+            } else {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Processes EVENT_NOTIFY message from baseband.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     */
+    private boolean processEventNotify(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process EventNotify");
+
+        TextMessage textMsg = new TextMessage();
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID,
+                ctlvs);
+        if (ctlv != null) {
+            textMsg.text = ValueParser.retrieveAlphaId(ctlv);
+        } else {
+            // throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
+            textMsg.text = null;
+        }
+
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            iconId = ValueParser.retrieveIconId(ctlv);
+            textMsg.iconSelfExplanatory = iconId.selfExplanatory;
+        }
+
+        textMsg.responseNeeded = false;
+        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+
+        if (iconId != null) {
+            mloadIcon = true;
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes SET_UP_EVENT_LIST proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details object retrieved.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return false. This function always returns false meaning that the command
+     *         processing is  not pending and additional asynchronous processing
+     *         is not required.
+     */
+/* L-MR1
+    private boolean processSetUpEventList(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) {
+
+        CatLog.d(this, "process SetUpEventList");
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.EVENT_LIST, ctlvs);
+        if (ctlv != null) {
+            try {
+                byte[] rawValue = ctlv.getRawValue();
+                int valueIndex = ctlv.getValueIndex();
+                int valueLen = ctlv.getLength();
+                int[] eventList = new int[valueLen];
+                int eventValue = -1;
+                int i = 0;
+                while (valueLen > 0) {
+                    eventValue = rawValue[valueIndex] & 0xff;
+                    valueIndex++;
+                    valueLen--;
+
+                    switch (eventValue) {
+                        case USER_ACTIVITY_EVENT:
+                        case IDLE_SCREEN_AVAILABLE_EVENT:
+                        case LANGUAGE_SELECTION_EVENT:
+                        case BROWSER_TERMINATION_EVENT:
+                        case BROWSING_STATUS_EVENT:
+                        /// M: BIP {
+                        case DATA_AVAILABLE_EVENT:
+                        case CHANNEL_STATUS_EVENT:
+                        /// M: BIP }
+                            eventList[i] = eventValue;
+                            i++;
+                            break;
+                        default:
+                            break;
+                    }
+
+                }
+                mCmdParams = new SetEventListParams(cmdDet, eventList);
+            } catch (IndexOutOfBoundsException e) {
+                CatLog.e(this, " IndexOutofBoundException in processSetUpEventList");
+            }
+        }
+        return false;
+    }
+*/
+    /**
+     *            object and Device Identities object within the proactive
+     *            command.
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     */
+    private boolean processSetUpEventList(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+        //
+        // ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.EVENT_LIST,
+        // ctlvs);
+        // if (ctlv != null) {
+        // try {
+        // byte[] rawValue = ctlv.getRawValue();
+        // int valueIndex = ctlv.getValueIndex();
+        // int valueLen = ctlv.getLength();
+        //
+        // } catch (IndexOutOfBoundsException e) {}
+        // }
+        // return true;
+
+        CatLog.d(this, "process SetUpEventList");
+
+        byte[] eventList;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.EVENT_LIST, ctlvs);
+        if (ctlv != null) {
+            try {
+                byte[] rawValue = ctlv.getRawValue();
+                int valueIndex = ctlv.getValueIndex();
+                int valueLen = ctlv.getLength();
+
+                eventList = new byte[valueLen];
+                for (int index = 0; index < valueLen; ) {
+                    eventList[index] = rawValue[valueIndex];
+                    CatLog.v(this, "CPF-processSetUpEventList: eventList[" + index + "] = "
+                            + eventList[index]);
+                    if (rawValue[valueIndex]
+                            == CatService.EVENT_LIST_ELEMENT_IDLE_SCREEN_AVAILABLE) {
+                        CatLog.v(this, "CPF-processSetUpEventList: sent intent with idle = true");
+                        Intent intent = new Intent(CatService.IDLE_SCREEN_INTENT_NAME);
+                        intent.putExtra(CatService.IDLE_SCREEN_ENABLE_KEY, true);
+                        mContext.sendBroadcast(intent);
+                        // IWindowManager wm =
+                        // IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
+                        /*
+                         * try { wm.setEventDownloadNeeded(true); } catch
+                         * (RemoteException e) { CatLog.d(this,
+                         * "Exception when set EventDownloadNeeded flag in WindowManager"
+                         * ); } catch (NullPointerException e2) { StkLog.d(this,
+                         * "wm is null"); }
+                         */
+                    } else if (rawValue[valueIndex]
+                            == CatService.EVENT_LIST_ELEMENT_USER_ACTIVITY) {
+                        CatLog.v(this, "CPF-processSetUpEventList: sent intent for user activity");
+                        Intent intent = new Intent(CatService.USER_ACTIVITY_INTENT_NAME);
+                        intent.putExtra(CatService.USER_ACTIVITY_ENABLE_KEY, true);
+                        mContext.sendBroadcast(intent);
+                    }
+                    index++;
+                    valueIndex++;
+                }
+                mCmdParams = new SetupEventListParams(cmdDet, eventList);
+            } catch (IndexOutOfBoundsException e) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Processes LAUNCH_BROWSER proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processLaunchBrowser(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process LaunchBrowser");
+
+        TextMessage confirmMsg = new TextMessage();
+        IconId iconId = null;
+        String url = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.URL, ctlvs);
+        if (ctlv != null) {
+            try {
+                byte[] rawValue = ctlv.getRawValue();
+                int valueIndex = ctlv.getValueIndex();
+                int valueLen = ctlv.getLength();
+                if (valueLen > 0) {
+                    url = GsmAlphabet.gsm8BitUnpackedToString(rawValue,
+                            valueIndex, valueLen);
+                } else {
+                    url = null;
+                }
+            } catch (IndexOutOfBoundsException e) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+
+        // parse alpha identifier.
+        ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
+        if (ctlv != null) {
+            confirmMsg.text = ValueParser.retrieveAlphaId(ctlv);
+        }
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            iconId = ValueParser.retrieveIconId(ctlv);
+            confirmMsg.iconSelfExplanatory = iconId.selfExplanatory;
+        }
+
+        // parse command qualifier value.
+        LaunchBrowserMode mode;
+        switch (cmdDet.commandQualifier) {
+        case 0x00:
+        default:
+            mode = LaunchBrowserMode.LAUNCH_IF_NOT_ALREADY_LAUNCHED;
+            break;
+        case 0x02:
+            mode = LaunchBrowserMode.USE_EXISTING_BROWSER;
+            break;
+        case 0x03:
+            mode = LaunchBrowserMode.LAUNCH_NEW_BROWSER;
+            break;
+        }
+
+        mCmdParams = new LaunchBrowserParams(cmdDet, confirmMsg, url, mode);
+
+        if (iconId != null) {
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+     /**
+     * Processes PLAY_TONE proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.t
+     * @throws ResultException
+     */
+    private boolean processPlayTone(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process PlayTone");
+
+        Tone tone = null;
+        TextMessage textMsg = new TextMessage();
+        Duration duration = null;
+        IconId iconId = null;
+
+        ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TONE, ctlvs);
+        if (ctlv != null) {
+            // Nothing to do for null objects.
+            if (ctlv.getLength() > 0) {
+                try {
+                    byte[] rawValue = ctlv.getRawValue();
+                    int valueIndex = ctlv.getValueIndex();
+                    int toneVal = rawValue[valueIndex];
+                    tone = Tone.fromInt(toneVal);
+                } catch (IndexOutOfBoundsException e) {
+                    throw new ResultException(
+                            ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+                }
+            }
+        }
+        // parse alpha identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
+        if (ctlv != null) {
+            try {
+            textMsg.text = ValueParser.retrieveAlphaId(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveAlphaId ResultException: " + e.result());
+            }
+        }
+        // parse tone duration
+        ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
+        if (ctlv != null) {
+            try {
+            duration = ValueParser.retrieveDuration(ctlv);
+            } catch (ResultException e) {
+                CatLog.e(this, "retrieveDuration ResultException: " + e.result());
+            }
+        }
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            iconId = ValueParser.retrieveIconId(ctlv);
+            textMsg.iconSelfExplanatory = iconId.selfExplanatory;
+        }
+
+        boolean vibrate = (cmdDet.commandQualifier & 0x01) != 0x00;
+
+        textMsg.responseNeeded = false;
+        mCmdParams = new PlayToneParams(cmdDet, textMsg, tone, duration, vibrate);
+
+        if (iconId != null) {
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Processes SETUP_CALL proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details object retrieved from the proactive command
+     *        object
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object and Device Identities object within the proactive command
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     */
+    private boolean processSetupCall(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+        CatLog.d(this, "process SetupCall");
+
+        Iterator<ComprehensionTlv> iter = ctlvs.iterator();
+        ComprehensionTlv ctlv = null;
+        // User confirmation phase message.
+        TextMessage confirmMsg = new TextMessage();
+        // Call set up phase message.
+        TextMessage callMsg = new TextMessage();
+        IconId confirmIconId = null;
+        IconId callIconId = null;
+
+        // The structure of SET UP CALL
+        // alpha id -> address -> icon id -> alpha id -> icon id
+        // We use the index of alpha id to judge the type of alpha id:
+        // confirm or call
+        final int addrIndex = getAddrIndex(ctlvs);
+        if (-1 == addrIndex) {
+            CatLog.d(this, "fail to get ADDRESS data object");
+            return false;
+        }
+
+        final int alpha1Index = getConfirmationAlphaIdIndex(ctlvs, addrIndex);
+        final int alpha2Index = getCallingAlphaIdIndex(ctlvs, addrIndex);
+
+        ctlv = getConfirmationAlphaId(ctlvs, addrIndex);
+        if (ctlv != null) {
+            confirmMsg.text = ValueParser.retrieveAlphaId(ctlv);
+        }
+
+        ctlv = getConfirmationIconId(ctlvs, alpha1Index, alpha2Index);
+        if (ctlv != null) {
+            confirmIconId = ValueParser.retrieveIconId(ctlv);
+            confirmMsg.iconSelfExplanatory = confirmIconId.selfExplanatory;
+        }
+
+        ctlv = getCallingAlphaId(ctlvs, addrIndex);
+        if (ctlv != null) {
+            callMsg.text = ValueParser.retrieveAlphaId(ctlv);
+        }
+
+        ctlv = getCallingIconId(ctlvs, alpha2Index);
+        if (ctlv != null) {
+            callIconId = ValueParser.retrieveIconId(ctlv);
+            callMsg.iconSelfExplanatory = callIconId.selfExplanatory;
+        }
+
+        mCmdParams = new CallSetupParams(cmdDet, confirmMsg, callMsg);
+
+        if (confirmIconId != null || callIconId != null) {
+            mIconLoadState = LOAD_MULTI_ICONS;
+            int[] recordNumbers = new int[2];
+            recordNumbers[0] = confirmIconId != null
+                    ? confirmIconId.recordNumber : -1;
+            recordNumbers[1] = callIconId != null ? callIconId.recordNumber
+                    : -1;
+
+            mIconLoader.loadIcons(recordNumbers, this
+                    .obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    private boolean processProvideLocalInfo(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs)
+            throws ResultException {
+        CatLog.d(this, "process ProvideLocalInfo");
+        switch (cmdDet.commandQualifier) {
+            case DTTZ_SETTING:
+                CatLog.d(this, "PLI [DTTZ_SETTING]");
+                mCmdParams = new CommandParams(cmdDet);
+                break;
+            case LANGUAGE_SETTING:
+                CatLog.d(this, "PLI [LANGUAGE_SETTING]");
+                mCmdParams = new CommandParams(cmdDet);
+                break;
+            default:
+                CatLog.d(this, "PLI[" + cmdDet.commandQualifier + "] Command Not Supported");
+                mCmdParams = new CommandParams(cmdDet);
+                throw new ResultException(ResultCode.BEYOND_TERMINAL_CAPABILITY);
+        }
+        return false;
+    }
+
+    /**
+     * Processes Activate proactive command from the SIM card.
+     *
+     * @param cmdDet Command Details container object.
+     * @param ctlvs List of ComprehensionTlv objects following Command Details
+     *        object
+     * @return true if the command is processing is pending and additional
+     *         asynchronous processing is required.
+     * @throws ResultException
+     */
+    private boolean processActivate(CommandDetails cmdDet,
+            List<ComprehensionTlv> ctlvs) throws ResultException {
+
+        CatLog.d(this, "process Activate");
+
+        ComprehensionTlv ctlv = null;
+        int target = 0;
+
+        ctlv = searchForTag(ComprehensionTlvTag.ACTIVATE_DESCRIPTOR, ctlvs);
+        if (ctlv != null) {
+            try {
+                target = ValueParser.retrieveTarget(ctlv);
+            } catch (ResultException e) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+            CatLog.d(this, "target: " + target);
+        }
+
+        mCmdParams = new ActivateParams(cmdDet, target);
+        return false;
+    }
+
+    /**
+     * Get the index of ADDRESS data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @return the index of ADDRESS data object.
+     */
+    private int getAddrIndex(final List<ComprehensionTlv> list) {
+        int addrIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ADDRESS.value()) {
+                return addrIndex;
+            }
+            ++addrIndex;
+        } // end while
+
+        return -1;
+    }
+
+    /**
+     * Get the index of ALPHA_ID data object in confirmation phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param addrIndex The index of ADDRESS data object
+     * @return the index of ALPHA_ID data object.
+     */
+    private int getConfirmationAlphaIdIndex(final List<ComprehensionTlv> list,
+            final int addrIndex) {
+        int alphaIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ALPHA_ID.value()
+                    && alphaIndex < addrIndex) {
+                return alphaIndex;
+            }
+            ++alphaIndex;
+        } // end while
+
+        return -1;
+    }
+
+    /**
+     * Get the index of ALPHA_ID data object in call phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param addrIndex The index of ADDRESS data object
+     * @return the index of ALPHA_ID data object.
+     */
+    private int getCallingAlphaIdIndex(final List<ComprehensionTlv> list,
+            final int addrIndex) {
+        int alphaIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ALPHA_ID.value()
+                    && alphaIndex > addrIndex) {
+                return alphaIndex;
+            }
+            ++alphaIndex;
+        } // end while
+
+        return -1;
+    }
+
+    /**
+     * Get the ALPHA_ID data object in confirmation phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param addrIndex The index of ADDRESS data object
+     * @return ALPHA_ID data object.
+     */
+    private ComprehensionTlv getConfirmationAlphaId(final List<ComprehensionTlv> list,
+            final int addrIndex) {
+        int alphaIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ALPHA_ID.value()
+                    && alphaIndex < addrIndex) {
+                return temp;
+            }
+            ++alphaIndex;
+        } // end while
+
+        return null;
+    }
+
+    /**
+     * Get the ALPHA_ID data object in call phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param addrIndex The index of ADDRESS data object
+     * @return ALPHA_ID data object.
+     */
+    private ComprehensionTlv getCallingAlphaId(final List<ComprehensionTlv> list,
+            final int addrIndex) {
+        int alphaIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ALPHA_ID.value()
+                    && alphaIndex > addrIndex) {
+                return temp;
+            }
+            ++alphaIndex;
+        } // end while
+
+        return null;
+    }
+
+    /**
+     * Get the ICON_ID data object in confirmation phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param alpha1Index The index of ALPHA_ID data object of confirmation
+     *            phase
+     * @param alpha2Index The index of ALPHA_ID data object of call phase
+     * @return ICON_ID data object.
+     */
+    private ComprehensionTlv getConfirmationIconId(final List<ComprehensionTlv> list,
+            final int alpha1Index,
+            final int alpha2Index) {
+        if (-1 == alpha1Index) {
+            return null;
+        }
+
+        int iconIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ICON_ID.value()
+                    && (-1 == alpha2Index || iconIndex < alpha2Index)) {
+                return temp;
+            }
+            ++iconIndex;
+        } // end while
+
+        return null;
+    }
+
+    /**
+     * Get the ICON_ID data object in call phase data object.
+     *
+     * @param list List of ComprehensionTlv
+     * @param alpha2Index The index of ALPHA_ID data object of call phase
+     * @return ICON_ID data object.
+     */
+    private ComprehensionTlv getCallingIconId(final List<ComprehensionTlv> list,
+            final int alpha2Index) {
+        if (-1 == alpha2Index) {
+            return null;
+        }
+
+        int iconIndex = 0;
+
+        ComprehensionTlv temp = null;
+        Iterator<ComprehensionTlv> iter = list.iterator();
+        while (iter.hasNext()) {
+            temp = iter.next();
+            if (temp.getTag() == ComprehensionTlvTag.ICON_ID.value()
+                    && iconIndex > alpha2Index) {
+                return temp;
+            }
+            ++iconIndex;
+        } // end while
+
+        return null;
+    }
+
+    private boolean processBIPClient(CommandDetails cmdDet,
+                                     List<ComprehensionTlv> ctlvs) throws ResultException {
+        AppInterface.CommandType commandType =
+                                    AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
+        if (commandType != null) {
+            CatLog.d(this, "process "+ commandType.name());
+        }
+
+        TextMessage textMsg = new TextMessage();
+        IconId iconId = null;
+        ComprehensionTlv ctlv = null;
+        boolean has_alpha_id = false;
+
+        // parse alpha identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
+        if (ctlv != null) {
+            textMsg.text = ValueParser.retrieveAlphaId(ctlv);
+            CatLog.d(this, "alpha TLV text=" + textMsg.text);
+            has_alpha_id = true;
+        }
+
+        // parse icon identifier
+        ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
+        if (ctlv != null) {
+            iconId = ValueParser.retrieveIconId(ctlv);
+            textMsg.iconSelfExplanatory = iconId.selfExplanatory;
+        }
+
+        textMsg.responseNeeded = false;
+        mCmdParams = new BIPClientParams(cmdDet, textMsg, has_alpha_id);
+
+        if (iconId != null) {
+            mIconLoadState = LOAD_SINGLE_ICON;
+            mIconLoader.loadIcon(iconId.recordNumber, obtainMessage(MSG_ID_LOAD_ICON_DONE));
+            return true;
+        }
+        return false;
+    }
+
+    public void dispose() {
+        mIconLoader.dispose();
+        mIconLoader = null;
+        mCmdParams = null;
+        mCaller = null;
+        sInstance = null;
+    }
+}
Index: vendor/branch/5058A_VIVA_BOLIVIA/frameworks/base/core/java/android/app/ApplicationPackageManager.java
===================================================================
--- vendor/branch/5058A_VIVA_BOLIVIA/frameworks/base/core/java/android/app/ApplicationPackageManager.java	(revision 0)
+++ vendor/branch/5058A_VIVA_BOLIVIA/frameworks/base/core/java/android/app/ApplicationPackageManager.java	(revision 15112)
@@ -0,0 +1,2585 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.annotation.DrawableRes;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.StringRes;
+import android.annotation.XmlRes;
+import android.app.admin.DevicePolicyManager;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.IntentSender;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.ComponentInfo;
+import android.content.pm.EphemeralApplicationInfo;
+import android.content.pm.FeatureInfo;
+import android.content.pm.IOnPermissionsChangeListener;
+import android.content.pm.IPackageDataObserver;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.IPackageInstallObserver;
+import android.content.pm.IPackageManager;
+import android.content.pm.IPackageMoveObserver;
+import android.content.pm.IPackageStatsObserver;
+import android.content.pm.InstrumentationInfo;
+import android.content.pm.IntentFilterVerificationInfo;
+import android.content.pm.KeySet;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ParceledListSlice;
+import android.content.pm.PermissionGroupInfo;
+import android.content.pm.PermissionInfo;
+import android.content.pm.ProviderInfo;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
+import android.content.pm.UserInfo;
+import android.content.pm.VerifierDeviceIdentity;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.os.storage.StorageManager;
+import android.os.storage.VolumeInfo;
+import android.provider.Settings;
+import android.util.ArrayMap;
+import android.util.Log;
+import android.view.Display;
+
+import dalvik.system.VMRuntime;
+
+import com.android.internal.annotations.GuardedBy;
+import com.android.internal.os.SomeArgs;
+import com.android.internal.util.Preconditions;
+import com.android.internal.util.UserIcons;
+import libcore.util.EmptyArray;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import com.android.internal.telephony.TelephonyProperties;
+import android.telephony.SubscriptionManager;
+
+/** @hide */
+public class ApplicationPackageManager extends PackageManager {
+    private static final String TAG = "ApplicationPackageManager";
+    private final static boolean DEBUG_ICONS = false;
+
+    private static final int DEFAULT_EPHEMERAL_COOKIE_MAX_SIZE_BYTES = 16384; // 16KB
+
+    // Default flags to use with PackageManager when no flags are given.
+    private final static int sDefaultFlags = PackageManager.GET_SHARED_LIBRARY_FILES;
+
+    private final Object mLock = new Object();
+
+    @GuardedBy("mLock")
+    private UserManager mUserManager;
+    @GuardedBy("mLock")
+    private PackageInstaller mInstaller;
+
+    @GuardedBy("mDelegates")
+    private final ArrayList<MoveCallbackDelegate> mDelegates = new ArrayList<>();
+
+    @GuardedBy("mLock")
+    private String mPermissionsControllerPackageName;
+
+    UserManager getUserManager() {
+        synchronized (mLock) {
+            if (mUserManager == null) {
+                mUserManager = UserManager.get(mContext);
+            }
+            return mUserManager;
+        }
+    }
+
+    @Override
+    public PackageInfo getPackageInfo(String packageName, int flags)
+            throws NameNotFoundException {
+        return getPackageInfoAsUser(packageName, flags, mContext.getUserId());
+    }
+
+    @Override
+    public PackageInfo getPackageInfoAsUser(String packageName, int flags, int userId)
+            throws NameNotFoundException {
+        try {
+            PackageInfo pi = mPM.getPackageInfo(packageName, flags, userId);
+            if (pi != null) {
+                return pi;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(packageName);
+    }
+
+    @Override
+    public String[] currentToCanonicalPackageNames(String[] names) {
+        try {
+            return mPM.currentToCanonicalPackageNames(names);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String[] canonicalToCurrentPackageNames(String[] names) {
+        try {
+            return mPM.canonicalToCurrentPackageNames(names);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public Intent getLaunchIntentForPackage(String packageName) {
+        // First see if the package has an INFO activity; the existence of
+        // such an activity is implied to be the desired front-door for the
+        // overall package (such as if it has multiple launcher entries).
+        Intent intentToResolve = new Intent(Intent.ACTION_MAIN);
+        intentToResolve.addCategory(Intent.CATEGORY_INFO);
+        intentToResolve.setPackage(packageName);
+        List<ResolveInfo> ris = queryIntentActivities(intentToResolve, 0);
+
+        // Otherwise, try to find a main launcher activity.
+        if (ris == null || ris.size() <= 0) {
+            // reuse the intent instance
+            intentToResolve.removeCategory(Intent.CATEGORY_INFO);
+            intentToResolve.addCategory(Intent.CATEGORY_LAUNCHER);
+            intentToResolve.setPackage(packageName);
+            ris = queryIntentActivities(intentToResolve, 0);
+        }
+        if (ris == null || ris.size() <= 0) {
+            return null;
+        }
+        Intent intent = new Intent(intentToResolve);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.setClassName(ris.get(0).activityInfo.packageName,
+                ris.get(0).activityInfo.name);
+        return intent;
+    }
+
+    @Override
+    public Intent getLeanbackLaunchIntentForPackage(String packageName) {
+        // Try to find a main leanback_launcher activity.
+        Intent intentToResolve = new Intent(Intent.ACTION_MAIN);
+        intentToResolve.addCategory(Intent.CATEGORY_LEANBACK_LAUNCHER);
+        intentToResolve.setPackage(packageName);
+        List<ResolveInfo> ris = queryIntentActivities(intentToResolve, 0);
+
+        if (ris == null || ris.size() <= 0) {
+            return null;
+        }
+        Intent intent = new Intent(intentToResolve);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.setClassName(ris.get(0).activityInfo.packageName,
+                ris.get(0).activityInfo.name);
+        return intent;
+    }
+
+    @Override
+    public int[] getPackageGids(String packageName) throws NameNotFoundException {
+        return getPackageGids(packageName, 0);
+    }
+
+    @Override
+    public int[] getPackageGids(String packageName, int flags)
+            throws NameNotFoundException {
+        try {
+            int[] gids = mPM.getPackageGids(packageName, flags, mContext.getUserId());
+            if (gids != null) {
+                return gids;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(packageName);
+    }
+
+    @Override
+    public int getPackageUid(String packageName, int flags) throws NameNotFoundException {
+        return getPackageUidAsUser(packageName, flags, mContext.getUserId());
+    }
+
+    @Override
+    public int getPackageUidAsUser(String packageName, int userId) throws NameNotFoundException {
+        return getPackageUidAsUser(packageName, 0, userId);
+    }
+
+    @Override
+    public int getPackageUidAsUser(String packageName, int flags, int userId)
+            throws NameNotFoundException {
+        try {
+            int uid = mPM.getPackageUid(packageName, flags, userId);
+            if (uid >= 0) {
+                return uid;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(packageName);
+    }
+
+    @Override
+    public PermissionInfo getPermissionInfo(String name, int flags)
+            throws NameNotFoundException {
+        try {
+            PermissionInfo pi = mPM.getPermissionInfo(name, flags);
+            if (pi != null) {
+                return pi;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(name);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<PermissionInfo> queryPermissionsByGroup(String group, int flags)
+            throws NameNotFoundException {
+        try {
+            ParceledListSlice<PermissionInfo> parceledList =
+                    mPM.queryPermissionsByGroup(group, flags);
+            if (parceledList != null) {
+                List<PermissionInfo> pi = parceledList.getList();
+                if (pi != null) {
+                    return pi;
+                }
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(group);
+    }
+
+    @Override
+    public PermissionGroupInfo getPermissionGroupInfo(String name,
+            int flags) throws NameNotFoundException {
+        try {
+            PermissionGroupInfo pgi = mPM.getPermissionGroupInfo(name, flags);
+            if (pgi != null) {
+                return pgi;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(name);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<PermissionGroupInfo> getAllPermissionGroups(int flags) {
+        try {
+            ParceledListSlice<PermissionGroupInfo> parceledList =
+                    mPM.getAllPermissionGroups(flags);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public ApplicationInfo getApplicationInfo(String packageName, int flags)
+            throws NameNotFoundException {
+        return getApplicationInfoAsUser(packageName, flags, mContext.getUserId());
+    }
+
+    @Override
+    public ApplicationInfo getApplicationInfoAsUser(String packageName, int flags, int userId)
+            throws NameNotFoundException {
+        try {
+            ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, userId);
+            if (ai != null) {
+                // This is a temporary hack. Callers must use
+                // createPackageContext(packageName).getApplicationInfo() to
+                // get the right paths.
+                return maybeAdjustApplicationInfo(ai);
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(packageName);
+    }
+
+    private static ApplicationInfo maybeAdjustApplicationInfo(ApplicationInfo info) {
+        // If we're dealing with a multi-arch application that has both
+        // 32 and 64 bit shared libraries, we might need to choose the secondary
+        // depending on what the current runtime's instruction set is.
+        if (info.primaryCpuAbi != null && info.secondaryCpuAbi != null) {
+            final String runtimeIsa = VMRuntime.getRuntime().vmInstructionSet();
+
+            // Get the instruction set that the libraries of secondary Abi is supported.
+            // In presence of a native bridge this might be different than the one secondary Abi used.
+            String secondaryIsa = VMRuntime.getInstructionSet(info.secondaryCpuAbi);
+            final String secondaryDexCodeIsa = SystemProperties.get("ro.dalvik.vm.isa." + secondaryIsa);
+            secondaryIsa = secondaryDexCodeIsa.isEmpty() ? secondaryIsa : secondaryDexCodeIsa;
+
+            // If the runtimeIsa is the same as the primary isa, then we do nothing.
+            // Everything will be set up correctly because info.nativeLibraryDir will
+            // correspond to the right ISA.
+            if (runtimeIsa.equals(secondaryIsa)) {
+                ApplicationInfo modified = new ApplicationInfo(info);
+                modified.nativeLibraryDir = info.secondaryNativeLibraryDir;
+                return modified;
+            }
+        }
+        return info;
+    }
+
+    @Override
+    public ActivityInfo getActivityInfo(ComponentName className, int flags)
+            throws NameNotFoundException {
+        try {
+            ActivityInfo ai = mPM.getActivityInfo(className, flags, mContext.getUserId());
+            if (ai != null) {
+                return ai;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(className.toString());
+    }
+
+    @Override
+    public ActivityInfo getReceiverInfo(ComponentName className, int flags)
+            throws NameNotFoundException {
+        try {
+            ActivityInfo ai = mPM.getReceiverInfo(className, flags, mContext.getUserId());
+            if (ai != null) {
+                return ai;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(className.toString());
+    }
+
+    @Override
+    public ServiceInfo getServiceInfo(ComponentName className, int flags)
+            throws NameNotFoundException {
+        try {
+            ServiceInfo si = mPM.getServiceInfo(className, flags, mContext.getUserId());
+            if (si != null) {
+                return si;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(className.toString());
+    }
+
+    @Override
+    public ProviderInfo getProviderInfo(ComponentName className, int flags)
+            throws NameNotFoundException {
+        try {
+            ProviderInfo pi = mPM.getProviderInfo(className, flags, mContext.getUserId());
+            if (pi != null) {
+                return pi;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(className.toString());
+    }
+
+    @Override
+    public String[] getSystemSharedLibraryNames() {
+        try {
+            return mPM.getSystemSharedLibraryNames();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public @NonNull String getServicesSystemSharedLibraryPackageName() {
+        try {
+            return mPM.getServicesSystemSharedLibraryPackageName();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public @NonNull String getSharedSystemSharedLibraryPackageName() {
+        try {
+            return mPM.getSharedSystemSharedLibraryPackageName();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public FeatureInfo[] getSystemAvailableFeatures() {
+        try {
+            ParceledListSlice<FeatureInfo> parceledList =
+                    mPM.getSystemAvailableFeatures();
+            if (parceledList == null) {
+                return new FeatureInfo[0];
+            }
+            final List<FeatureInfo> list = parceledList.getList();
+            final FeatureInfo[] res = new FeatureInfo[list.size()];
+            for (int i = 0; i < res.length; i++) {
+                res[i] = list.get(i);
+            }
+            return res;
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean hasSystemFeature(String name) {
+        return hasSystemFeature(name, 0);
+    }
+
+    @Override
+    public boolean hasSystemFeature(String name, int version) {
+        try {
+            return mPM.hasSystemFeature(name, version);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int checkPermission(String permName, String pkgName) {
+        try {
+            return mPM.checkPermission(permName, pkgName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean isPermissionRevokedByPolicy(String permName, String pkgName) {
+        try {
+            return mPM.isPermissionRevokedByPolicy(permName, pkgName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public String getPermissionControllerPackageName() {
+        synchronized (mLock) {
+            if (mPermissionsControllerPackageName == null) {
+                try {
+                    mPermissionsControllerPackageName = mPM.getPermissionControllerPackageName();
+                } catch (RemoteException e) {
+                    throw e.rethrowFromSystemServer();
+                }
+            }
+            return mPermissionsControllerPackageName;
+        }
+    }
+
+    @Override
+    public boolean addPermission(PermissionInfo info) {
+        try {
+            return mPM.addPermission(info);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean addPermissionAsync(PermissionInfo info) {
+        try {
+            return mPM.addPermissionAsync(info);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void removePermission(String name) {
+        try {
+            mPM.removePermission(name);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void grantRuntimePermission(String packageName, String permissionName,
+            UserHandle user) {
+        try {
+            mPM.grantRuntimePermission(packageName, permissionName, user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void revokeRuntimePermission(String packageName, String permissionName,
+            UserHandle user) {
+        try {
+            mPM.revokeRuntimePermission(packageName, permissionName, user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getPermissionFlags(String permissionName, String packageName, UserHandle user) {
+        try {
+            return mPM.getPermissionFlags(permissionName, packageName, user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void updatePermissionFlags(String permissionName, String packageName,
+            int flagMask, int flagValues, UserHandle user) {
+        try {
+            mPM.updatePermissionFlags(permissionName, packageName, flagMask,
+                    flagValues, user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean shouldShowRequestPermissionRationale(String permission) {
+        try {
+            return mPM.shouldShowRequestPermissionRationale(permission,
+                    mContext.getPackageName(), mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int checkSignatures(String pkg1, String pkg2) {
+        try {
+            return mPM.checkSignatures(pkg1, pkg2);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int checkSignatures(int uid1, int uid2) {
+        try {
+            return mPM.checkUidSignatures(uid1, uid2);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String[] getPackagesForUid(int uid) {
+        try {
+            return mPM.getPackagesForUid(uid);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String getNameForUid(int uid) {
+        try {
+            return mPM.getNameForUid(uid);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getUidForSharedUser(String sharedUserName)
+            throws NameNotFoundException {
+        try {
+            int uid = mPM.getUidForSharedUser(sharedUserName);
+            if(uid != -1) {
+                return uid;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        throw new NameNotFoundException("No shared userid for user:"+sharedUserName);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public List<PackageInfo> getInstalledPackages(int flags) {
+        return getInstalledPackagesAsUser(flags, mContext.getUserId());
+    }
+
+    /** @hide */
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<PackageInfo> getInstalledPackagesAsUser(int flags, int userId) {
+        try {
+            ParceledListSlice<PackageInfo> parceledList =
+                    mPM.getInstalledPackages(flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public List<PackageInfo> getPackagesHoldingPermissions(
+            String[] permissions, int flags) {
+        final int userId = mContext.getUserId();
+        try {
+            ParceledListSlice<PackageInfo> parceledList =
+                    mPM.getPackagesHoldingPermissions(permissions, flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public List<ApplicationInfo> getInstalledApplications(int flags) {
+        final int userId = mContext.getUserId();
+        try {
+            ParceledListSlice<ApplicationInfo> parceledList =
+                    mPM.getInstalledApplications(flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @SuppressWarnings("unchecked")
+    @Override
+    public List<EphemeralApplicationInfo> getEphemeralApplications() {
+        try {
+            ParceledListSlice<EphemeralApplicationInfo> slice =
+                    mPM.getEphemeralApplications(mContext.getUserId());
+            if (slice != null) {
+                return slice.getList();
+            }
+            return Collections.emptyList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public Drawable getEphemeralApplicationIcon(String packageName) {
+        try {
+            Bitmap bitmap = mPM.getEphemeralApplicationIcon(
+                    packageName, mContext.getUserId());
+            if (bitmap != null) {
+                return new BitmapDrawable(null, bitmap);
+            }
+            return null;
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean isEphemeralApplication() {
+        try {
+            return mPM.isEphemeralApplication(
+                    mContext.getPackageName(), mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getEphemeralCookieMaxSizeBytes() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.EPHEMERAL_COOKIE_MAX_SIZE_BYTES,
+                DEFAULT_EPHEMERAL_COOKIE_MAX_SIZE_BYTES);
+    }
+
+    @Override
+    public @NonNull byte[] getEphemeralCookie() {
+        try {
+            final byte[] cookie = mPM.getEphemeralApplicationCookie(
+                    mContext.getPackageName(), mContext.getUserId());
+            if (cookie != null) {
+                return cookie;
+            } else {
+                return EmptyArray.BYTE;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean setEphemeralCookie(@NonNull  byte[] cookie) {
+        try {
+            return mPM.setEphemeralApplicationCookie(
+                    mContext.getPackageName(), cookie, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public ResolveInfo resolveActivity(Intent intent, int flags) {
+        return resolveActivityAsUser(intent, flags, mContext.getUserId());
+    }
+
+    @Override
+    public ResolveInfo resolveActivityAsUser(Intent intent, int flags, int userId) {
+        try {
+            return mPM.resolveIntent(
+                intent,
+                intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                flags,
+                userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public List<ResolveInfo> queryIntentActivities(Intent intent,
+                                                   int flags) {
+        return queryIntentActivitiesAsUser(intent, flags, mContext.getUserId());
+    }
+
+    /** @hide Same as above but for a specific user */
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ResolveInfo> queryIntentActivitiesAsUser(Intent intent,
+            int flags, int userId) {
+        try {
+            ParceledListSlice<ResolveInfo> parceledList =
+                    mPM.queryIntentActivities(intent,
+                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                            flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ResolveInfo> queryIntentActivityOptions(
+        ComponentName caller, Intent[] specifics, Intent intent,
+        int flags) {
+        final ContentResolver resolver = mContext.getContentResolver();
+
+        String[] specificTypes = null;
+        if (specifics != null) {
+            final int N = specifics.length;
+            for (int i=0; i<N; i++) {
+                Intent sp = specifics[i];
+                if (sp != null) {
+                    String t = sp.resolveTypeIfNeeded(resolver);
+                    if (t != null) {
+                        if (specificTypes == null) {
+                            specificTypes = new String[N];
+                        }
+                        specificTypes[i] = t;
+                    }
+                }
+            }
+        }
+
+        try {
+            ParceledListSlice<ResolveInfo> parceledList =
+                    mPM.queryIntentActivityOptions(caller, specifics, specificTypes, intent,
+                    intent.resolveTypeIfNeeded(resolver), flags, mContext.getUserId());
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ResolveInfo> queryBroadcastReceiversAsUser(Intent intent, int flags, int userId) {
+        try {
+            ParceledListSlice<ResolveInfo> parceledList =
+                    mPM.queryIntentReceivers(intent,
+                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                            flags,  userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public List<ResolveInfo> queryBroadcastReceivers(Intent intent, int flags) {
+        return queryBroadcastReceiversAsUser(intent, flags, mContext.getUserId());
+    }
+
+    @Override
+    public ResolveInfo resolveService(Intent intent, int flags) {
+        try {
+            return mPM.resolveService(
+                intent,
+                intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                flags,
+                mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ResolveInfo> queryIntentServicesAsUser(Intent intent, int flags, int userId) {
+        try {
+            ParceledListSlice<ResolveInfo> parceledList =
+                    mPM.queryIntentServices(intent,
+                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                    flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public List<ResolveInfo> queryIntentServices(Intent intent, int flags) {
+        return queryIntentServicesAsUser(intent, flags, mContext.getUserId());
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ResolveInfo> queryIntentContentProvidersAsUser(
+            Intent intent, int flags, int userId) {
+        try {
+            ParceledListSlice<ResolveInfo> parceledList =
+                    mPM.queryIntentContentProviders(intent,
+                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                            flags, userId);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public List<ResolveInfo> queryIntentContentProviders(Intent intent, int flags) {
+        return queryIntentContentProvidersAsUser(intent, flags, mContext.getUserId());
+    }
+
+    @Override
+    public ProviderInfo resolveContentProvider(String name, int flags) {
+        return resolveContentProviderAsUser(name, flags, mContext.getUserId());
+    }
+
+    /** @hide **/
+    @Override
+    public ProviderInfo resolveContentProviderAsUser(String name, int flags, int userId) {
+        try {
+            return mPM.resolveContentProvider(name, flags, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<ProviderInfo> queryContentProviders(String processName,
+            int uid, int flags) {
+        try {
+            ParceledListSlice<ProviderInfo> slice =
+                    mPM.queryContentProviders(processName, uid, flags);
+            return slice != null ? slice.getList() : Collections.<ProviderInfo>emptyList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public InstrumentationInfo getInstrumentationInfo(
+        ComponentName className, int flags)
+            throws NameNotFoundException {
+        try {
+            InstrumentationInfo ii = mPM.getInstrumentationInfo(
+                className, flags);
+            if (ii != null) {
+                return ii;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        throw new NameNotFoundException(className.toString());
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<InstrumentationInfo> queryInstrumentation(
+        String targetPackage, int flags) {
+        try {
+            ParceledListSlice<InstrumentationInfo> parceledList =
+                    mPM.queryInstrumentation(targetPackage, flags);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Nullable
+    @Override
+    public Drawable getDrawable(String packageName, @DrawableRes int resId,
+            @Nullable ApplicationInfo appInfo) {
+        final ResourceName name = new ResourceName(packageName, resId);
+        final Drawable cachedIcon = getCachedIcon(name);
+        if (cachedIcon != null) {
+            return cachedIcon;
+        }
+
+        if (appInfo == null) {
+            try {
+                appInfo = getApplicationInfo(packageName, sDefaultFlags);
+            } catch (NameNotFoundException e) {
+                return null;
+            }
+        }
+
+        if (resId != 0) {
+            try {
+                final Resources r = getResourcesForApplication(appInfo);
+                final Drawable dr = r.getDrawable(resId, null);
+                if (dr != null) {
+                    putCachedIcon(name, dr);
+                }
+
+                if (false) {
+                    RuntimeException e = new RuntimeException("here");
+                    e.fillInStackTrace();
+                    Log.w(TAG, "Getting drawable 0x" + Integer.toHexString(resId)
+                                    + " from package " + packageName
+                                    + ": app scale=" + r.getCompatibilityInfo().applicationScale
+                                    + ", caller scale=" + mContext.getResources()
+                                    .getCompatibilityInfo().applicationScale,
+                            e);
+                }
+                if (DEBUG_ICONS) {
+                    Log.v(TAG, "Getting drawable 0x"
+                            + Integer.toHexString(resId) + " from " + r
+                            + ": " + dr);
+                }
+                return dr;
+            } catch (NameNotFoundException e) {
+                Log.w("PackageManager", "Failure retrieving resources for "
+                        + appInfo.packageName);
+            } catch (Resources.NotFoundException e) {
+                Log.w("PackageManager", "Failure retrieving resources for "
+                        + appInfo.packageName + ": " + e.getMessage());
+            } catch (Exception e) {
+                // If an exception was thrown, fall through to return
+                // default icon.
+                Log.w("PackageManager", "Failure retrieving icon 0x"
+                        + Integer.toHexString(resId) + " in package "
+                        + packageName, e);
+            }
+        }
+
+        return null;
+    }
+
+    @Override public Drawable getActivityIcon(ComponentName activityName)
+            throws NameNotFoundException {
+        return getActivityInfo(activityName, sDefaultFlags).loadIcon(this);
+    }
+
+    @Override public Drawable getActivityIcon(Intent intent)
+            throws NameNotFoundException {
+        if (intent.getComponent() != null) {
+            return getActivityIcon(intent.getComponent());
+        }
+
+        ResolveInfo info = resolveActivity(
+            intent, PackageManager.MATCH_DEFAULT_ONLY);
+        if (info != null) {
+            return info.activityInfo.loadIcon(this);
+        }
+
+        throw new NameNotFoundException(intent.toUri(0));
+    }
+
+    @Override public Drawable getDefaultActivityIcon() {
+        return Resources.getSystem().getDrawable(
+            com.android.internal.R.drawable.sym_def_app_icon);
+    }
+
+    @Override public Drawable getApplicationIcon(ApplicationInfo info) {
+        return info.loadIcon(this);
+    }
+
+    @Override public Drawable getApplicationIcon(String packageName)
+            throws NameNotFoundException {
+        return getApplicationIcon(getApplicationInfo(packageName, sDefaultFlags));
+    }
+
+    @Override
+    public Drawable getActivityBanner(ComponentName activityName)
+            throws NameNotFoundException {
+        return getActivityInfo(activityName, sDefaultFlags).loadBanner(this);
+    }
+
+    @Override
+    public Drawable getActivityBanner(Intent intent)
+            throws NameNotFoundException {
+        if (intent.getComponent() != null) {
+            return getActivityBanner(intent.getComponent());
+        }
+
+        ResolveInfo info = resolveActivity(
+                intent, PackageManager.MATCH_DEFAULT_ONLY);
+        if (info != null) {
+            return info.activityInfo.loadBanner(this);
+        }
+
+        throw new NameNotFoundException(intent.toUri(0));
+    }
+
+    @Override
+    public Drawable getApplicationBanner(ApplicationInfo info) {
+        return info.loadBanner(this);
+    }
+
+    @Override
+    public Drawable getApplicationBanner(String packageName)
+            throws NameNotFoundException {
+        return getApplicationBanner(getApplicationInfo(packageName, sDefaultFlags));
+    }
+
+    @Override
+    public Drawable getActivityLogo(ComponentName activityName)
+            throws NameNotFoundException {
+        return getActivityInfo(activityName, sDefaultFlags).loadLogo(this);
+    }
+
+    @Override
+    public Drawable getActivityLogo(Intent intent)
+            throws NameNotFoundException {
+        if (intent.getComponent() != null) {
+            return getActivityLogo(intent.getComponent());
+        }
+
+        ResolveInfo info = resolveActivity(
+            intent, PackageManager.MATCH_DEFAULT_ONLY);
+        if (info != null) {
+            return info.activityInfo.loadLogo(this);
+        }
+
+        throw new NameNotFoundException(intent.toUri(0));
+    }
+
+    @Override
+    public Drawable getApplicationLogo(ApplicationInfo info) {
+        return info.loadLogo(this);
+    }
+
+    @Override
+    public Drawable getApplicationLogo(String packageName)
+            throws NameNotFoundException {
+        return getApplicationLogo(getApplicationInfo(packageName, sDefaultFlags));
+    }
+
+    @Override
+    public Drawable getManagedUserBadgedDrawable(Drawable drawable, Rect badgeLocation,
+            int badgeDensity) {
+        Drawable badgeDrawable = getDrawableForDensity(
+            com.android.internal.R.drawable.ic_corp_badge, badgeDensity);
+        return getBadgedDrawable(drawable, badgeDrawable, badgeLocation, true);
+    }
+
+    @Override
+    public Drawable getUserBadgedIcon(Drawable icon, UserHandle user) {
+        final int badgeResId = getBadgeResIdForUser(user.getIdentifier());
+        if (badgeResId == 0) {
+            return icon;
+        }
+        Drawable badgeIcon = getDrawable("system", badgeResId, null);
+        return getBadgedDrawable(icon, badgeIcon, null, true);
+    }
+
+    @Override
+    public Drawable getUserBadgedDrawableForDensity(Drawable drawable, UserHandle user,
+            Rect badgeLocation, int badgeDensity) {
+        Drawable badgeDrawable = getUserBadgeForDensity(user, badgeDensity);
+        if (badgeDrawable == null) {
+            return drawable;
+        }
+        return getBadgedDrawable(drawable, badgeDrawable, badgeLocation, true);
+    }
+
+    @Override
+    public Drawable getUserBadgeForDensity(UserHandle user, int density) {
+        return getManagedProfileIconForDensity(user, com.android.internal.R.drawable.ic_corp_badge,
+                density);
+    }
+
+    @Override
+    public Drawable getUserBadgeForDensityNoBackground(UserHandle user, int density) {
+        return getManagedProfileIconForDensity(user,
+                com.android.internal.R.drawable.ic_corp_badge_no_background, density);
+    }
+
+    private Drawable getDrawableForDensity(int drawableId, int density) {
+        if (density <= 0) {
+            density = mContext.getResources().getDisplayMetrics().densityDpi;
+        }
+        return Resources.getSystem().getDrawableForDensity(drawableId, density);
+    }
+
+    private Drawable getManagedProfileIconForDensity(UserHandle user, int drawableId, int density) {
+        if (isManagedProfile(user.getIdentifier())) {
+            return getDrawableForDensity(drawableId, density);
+        }
+        return null;
+    }
+
+    @Override
+    public CharSequence getUserBadgedLabel(CharSequence label, UserHandle user) {
+        if (isManagedProfile(user.getIdentifier())) {
+            return Resources.getSystem().getString(
+                    com.android.internal.R.string.managed_profile_label_badge, label);
+        }
+        return label;
+    }
+
+    @Override
+    public Resources getResourcesForActivity(ComponentName activityName)
+            throws NameNotFoundException {
+        return getResourcesForApplication(
+            getActivityInfo(activityName, sDefaultFlags).applicationInfo);
+    }
+
+    @Override
+    public Resources getResourcesForApplication(@NonNull ApplicationInfo app)
+            throws NameNotFoundException {
+        if (app.packageName.equals("system")) {
+            return mContext.mMainThread.getSystemContext().getResources();
+        }
+        final boolean sameUid = (app.uid == Process.myUid());
+        final Resources r = mContext.mMainThread.getTopLevelResources(
+                    sameUid ? app.sourceDir : app.publicSourceDir,
+                    sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs,
+                    app.resourceDirs, app.sharedLibraryFiles, Display.DEFAULT_DISPLAY,
+                    mContext.mPackageInfo);
+        if (r != null) {
+            return r;
+        }
+        throw new NameNotFoundException("Unable to open " + app.publicSourceDir);
+
+    }
+
+    @Override
+    public Resources getResourcesForApplication(String appPackageName)
+            throws NameNotFoundException {
+        return getResourcesForApplication(
+            getApplicationInfo(appPackageName, sDefaultFlags));
+    }
+
+    /** @hide */
+    @Override
+    public Resources getResourcesForApplicationAsUser(String appPackageName, int userId)
+            throws NameNotFoundException {
+        if (userId < 0) {
+            throw new IllegalArgumentException(
+                    "Call does not support special user #" + userId);
+        }
+        if ("system".equals(appPackageName)) {
+            return mContext.mMainThread.getSystemContext().getResources();
+        }
+        try {
+            ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, sDefaultFlags, userId);
+            if (ai != null) {
+                return getResourcesForApplication(ai);
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        throw new NameNotFoundException("Package " + appPackageName + " doesn't exist");
+    }
+
+    volatile int mCachedSafeMode = -1;
+
+    @Override
+    public boolean isSafeMode() {
+        try {
+            if (mCachedSafeMode < 0) {
+                mCachedSafeMode = mPM.isSafeMode() ? 1 : 0;
+            }
+            return mCachedSafeMode != 0;
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void addOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        synchronized (mPermissionListeners) {
+            if (mPermissionListeners.get(listener) != null) {
+                return;
+            }
+            OnPermissionsChangeListenerDelegate delegate =
+                    new OnPermissionsChangeListenerDelegate(listener, Looper.getMainLooper());
+            try {
+                mPM.addOnPermissionsChangeListener(delegate);
+                mPermissionListeners.put(listener, delegate);
+            } catch (RemoteException e) {
+                throw e.rethrowFromSystemServer();
+            }
+        }
+    }
+
+    @Override
+    public void removeOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        synchronized (mPermissionListeners) {
+            IOnPermissionsChangeListener delegate = mPermissionListeners.get(listener);
+            if (delegate != null) {
+                try {
+                    mPM.removeOnPermissionsChangeListener(delegate);
+                    mPermissionListeners.remove(listener);
+                } catch (RemoteException e) {
+                    throw e.rethrowFromSystemServer();
+                }
+            }
+        }
+    }
+
+    static void configurationChanged() {
+        synchronized (sSync) {
+            sIconCache.clear();
+            sStringCache.clear();
+        }
+    }
+
+    ApplicationPackageManager(ContextImpl context,
+                              IPackageManager pm) {
+        mContext = context;
+        mPM = pm;
+    }
+
+    @Nullable
+    private Drawable getCachedIcon(@NonNull ResourceName name) {
+        synchronized (sSync) {
+            final WeakReference<Drawable.ConstantState> wr = sIconCache.get(name);
+            if (DEBUG_ICONS) Log.v(TAG, "Get cached weak drawable ref for "
+                                   + name + ": " + wr);
+            if (wr != null) {   // we have the activity
+                final Drawable.ConstantState state = wr.get();
+                if (state != null) {
+                    if (DEBUG_ICONS) {
+                        Log.v(TAG, "Get cached drawable state for " + name + ": " + state);
+                    }
+                    // Note: It's okay here to not use the newDrawable(Resources) variant
+                    //       of the API. The ConstantState comes from a drawable that was
+                    //       originally created by passing the proper app Resources instance
+                    //       which means the state should already contain the proper
+                    //       resources specific information (like density.) See
+                    //       BitmapDrawable.BitmapState for instance.
+                    return state.newDrawable();
+                }
+                // our entry has been purged
+                sIconCache.remove(name);
+            }
+        }
+        return null;
+    }
+
+    private void putCachedIcon(@NonNull ResourceName name, @NonNull Drawable dr) {
+        synchronized (sSync) {
+            sIconCache.put(name, new WeakReference<>(dr.getConstantState()));
+            if (DEBUG_ICONS) Log.v(TAG, "Added cached drawable state for " + name + ": " + dr);
+        }
+    }
+
+    static void handlePackageBroadcast(int cmd, String[] pkgList, boolean hasPkgInfo) {
+        boolean immediateGc = false;
+        if (cmd == IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE) {
+            immediateGc = true;
+        }
+        if (pkgList != null && (pkgList.length > 0)) {
+            boolean needCleanup = false;
+            for (String ssp : pkgList) {
+                synchronized (sSync) {
+                    for (int i=sIconCache.size()-1; i>=0; i--) {
+                        ResourceName nm = sIconCache.keyAt(i);
+                        if (nm.packageName.equals(ssp)) {
+                            //Log.i(TAG, "Removing cached drawable for " + nm);
+                            sIconCache.removeAt(i);
+                            needCleanup = true;
+                        }
+                    }
+                    for (int i=sStringCache.size()-1; i>=0; i--) {
+                        ResourceName nm = sStringCache.keyAt(i);
+                        if (nm.packageName.equals(ssp)) {
+                            //Log.i(TAG, "Removing cached string for " + nm);
+                            sStringCache.removeAt(i);
+                            needCleanup = true;
+                        }
+                    }
+                }
+            }
+            if (needCleanup || hasPkgInfo) {
+                if (immediateGc) {
+                    // Schedule an immediate gc.
+                    Runtime.getRuntime().gc();
+                } else {
+                    ActivityThread.currentActivityThread().scheduleGcIdler();
+                }
+            }
+        }
+    }
+
+    private static final class ResourceName {
+        final String packageName;
+        final int iconId;
+
+        ResourceName(String _packageName, int _iconId) {
+            packageName = _packageName;
+            iconId = _iconId;
+        }
+
+        ResourceName(ApplicationInfo aInfo, int _iconId) {
+            this(aInfo.packageName, _iconId);
+        }
+
+        ResourceName(ComponentInfo cInfo, int _iconId) {
+            this(cInfo.applicationInfo.packageName, _iconId);
+        }
+
+        ResourceName(ResolveInfo rInfo, int _iconId) {
+            this(rInfo.activityInfo.applicationInfo.packageName, _iconId);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            ResourceName that = (ResourceName) o;
+
+            if (iconId != that.iconId) return false;
+            return !(packageName != null ?
+                     !packageName.equals(that.packageName) : that.packageName != null);
+
+        }
+
+        @Override
+        public int hashCode() {
+            int result;
+            result = packageName.hashCode();
+            result = 31 * result + iconId;
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            return "{ResourceName " + packageName + " / " + iconId + "}";
+        }
+    }
+
+    private CharSequence getCachedString(ResourceName name) {
+        synchronized (sSync) {
+            WeakReference<CharSequence> wr = sStringCache.get(name);
+            if (wr != null) {   // we have the activity
+                CharSequence cs = wr.get();
+                if (cs != null) {
+                    return cs;
+                }
+                // our entry has been purged
+                sStringCache.remove(name);
+            }
+        }
+        return null;
+    }
+
+    private void putCachedString(ResourceName name, CharSequence cs) {
+        synchronized (sSync) {
+            sStringCache.put(name, new WeakReference<CharSequence>(cs));
+        }
+    }
+
+    @Override
+    public CharSequence getText(String packageName, @StringRes int resid,
+                                ApplicationInfo appInfo) {
+        /*begin-20151020-yangning.hong-add-for-T730276,T730254,T730263,T730245,T742200*/
+        if ("com.android.stk".equals(packageName)) {
+            int def = mContext.getResources().getInteger(com.android.internal.R.integer.def_customized_stk_app_name);
+            Log.d("PackageManager", "def_customized_stk_app_name is " + def);
+
+            /*-begin-20151020-yangning.hong-add-for-T742207-ssv-to-custom-stk-name*/
+            boolean mSsvEnabled = SystemProperties.getBoolean("ro.telcel.enabled", false);
+            if(mSsvEnabled){
+                if (def == 1 || def == 2) {
+                    //If def = 2, so read SATK name from EF_SUME and Set up menu alpha ID firstly.
+                    String title = SystemProperties.get("gsm.stk.perso.app_title");
+                    if (title == null || title.length() <= 0) {
+                        title = null;
+                    }
+                    Log.d(TAG, "ssv version run in customize STK shortcut name = " + title);
+                    if ((title != null) && (title.length() > 0)) {
+                        return title;
+                    }
+                }
+            /*-end-20151020-yangning.hong-add-for-T742207-ssv-to-custom-stk-name*/
+            }else{
+                if (def == 1 || def == 2) {//T730276,T730254,T730263
+                    String title = SystemProperties.get("gsm.stk.perso.app_title");
+                    Log.d(TAG, "run in customize STK shortcut name by reading sim card SUME." + title);
+                    if ((title != null) && (title.length() > 0)) {
+                        return title;
+                    }
+                } else if (def == 3) {//T730245
+                    String[] ideaOperatorNumerics = {"334020", "46001"};
+                    String[] plmns = SystemProperties.get("gsm.sim.operator.numeric", "").split(",");
+                    if(plmns != null && plmns.length > 0){
+                        String operatorNumeric = "";
+                        String operatorNumeric2 = "";
+                        if(plmns.length > 1){
+                            operatorNumeric = plmns[0];
+                            operatorNumeric2 = plmns[1];
+                        }else{
+                            operatorNumeric = plmns[0];
+                        }
+                        Log.d(TAG,"ideaOperatorNumberic:" + operatorNumeric);
+                        Log.d(TAG,"ideaOperatorNumberic2:" + operatorNumeric2);
+                        for (String ideaOperatorNumeric : ideaOperatorNumerics) {
+                            if (operatorNumeric.equals(ideaOperatorNumeric)
+                                    || operatorNumeric2.equals(ideaOperatorNumeric)){
+                                Log.d(TAG, "IDEA_PLMN");
+                                return "SIM Telcel";
+                            }
+                        }
+                    }
+                }else if (def == 4){//T742200
+                    String stkUnicodeTitle = mContext.getResources().getString(com.android.internal.R.string.gsm_stk_title_unicode);
+                    Log.d(TAG,"############Test for TIM card");
+                    if (stkUnicodeTitle != null && stkUnicodeTitle.length() > 0)
+                        return stkUnicodeTitle;
+                }
+            }
+        }
+        /*end-20151020-yangning.hong-add-for-T730276,T730254,T730263,T730245,T742200*/
+
+        ResourceName name = new ResourceName(packageName, resid);
+        if (false) Log.d("PackageManager", "Query text for package: " + packageName
+                        + "resid: " + resid);
+        CharSequence text = getCachedString(name);
+        if (text != null) {
+			if(isSupportedRenameStk()){
+                if(SubscriptionManager.getDefaultSubId() == 0 && PACKAGE_NAME_STK.equals(packageName)){
+                    if(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA) !=""
+                        && SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA).length() > 1){
+                        String mStkAppName = SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
+                        text = (CharSequence)mStkAppName;
+                    }
+                }
+                if(SubscriptionManager.getDefaultSubId() == 1 && PACKAGE_NAME_STK1.equals(packageName)){
+                    if(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2) !=""
+                        && SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2).length() > 1){
+                        String mStk1AppName = SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
+                        text = (CharSequence)mStk1AppName;
+                    }
+                }
+            }
+            return text;
+        }
+        if (appInfo == null) {
+            try {
+                appInfo = getApplicationInfo(packageName, sDefaultFlags);
+            } catch (NameNotFoundException e) {
+                if (false) Log.w("PackageManager", "Cannot find application info for package " + packageName
+                    + "return null text");
+                return null;
+            }
+        }
+        try {
+            Resources r = getResourcesForApplication(appInfo);
+            text = r.getText(resid);
+			if(isSupportedRenameStk()){
+                if(SubscriptionManager.getDefaultSubId() == 0 && PACKAGE_NAME_STK.equals(packageName)){
+                    if(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA) !=""
+                        && SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA).length() >1){
+                        String mStkAppName = SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
+                        text = mStkAppName;
+                    }
+                }
+                if(SubscriptionManager.getDefaultSubId() == 1 && PACKAGE_NAME_STK1.equals(packageName)){
+                    if(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2) !=""
+                        && SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2).length() >1){
+                        String mStk1AppName = SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
+                        text = mStk1AppName;
+                    }
+                }
+            }
+            putCachedString(name, text);
+            if (false) Log.d("PackageManager", "return text:  " + text + "for package: " + packageName);
+            return text;
+        } catch (NameNotFoundException e) {
+            Log.w("PackageManager", "Failure retrieving resources for "
+                  + appInfo.packageName);
+        } catch (RuntimeException e) {
+            // If an exception was thrown, fall through to return
+            // default icon.
+            Log.w("PackageManager", "Failure retrieving text 0x"
+                  + Integer.toHexString(resid) + " in package "
+                  + packageName, e);
+        }
+        if (false) Log.w("PackageManager", "return null text for package: " + packageName);
+        return null;
+    }
+	
+    private static final String PACKAGE_NAME_STK = "com.android.stk";
+    private static final String PACKAGE_NAME_STK1 = "com.android.stk";
+	
+	private boolean isSupportedRenameStk(){
+        return true;
+    }
+
+    @Override
+    public XmlResourceParser getXml(String packageName, @XmlRes int resid,
+                                    ApplicationInfo appInfo) {
+        if (appInfo == null) {
+            try {
+                appInfo = getApplicationInfo(packageName, sDefaultFlags);
+            } catch (NameNotFoundException e) {
+                return null;
+            }
+        }
+        try {
+            Resources r = getResourcesForApplication(appInfo);
+            return r.getXml(resid);
+        } catch (RuntimeException e) {
+            // If an exception was thrown, fall through to return
+            // default icon.
+            Log.w("PackageManager", "Failure retrieving xml 0x"
+                  + Integer.toHexString(resid) + " in package "
+                  + packageName, e);
+        } catch (NameNotFoundException e) {
+            Log.w("PackageManager", "Failure retrieving resources for "
+                  + appInfo.packageName);
+        }
+        return null;
+    }
+
+    @Override
+    public CharSequence getApplicationLabel(ApplicationInfo info) {
+        return info.loadLabel(this);
+    }
+
+    @Override
+    public void installPackage(Uri packageURI, IPackageInstallObserver observer, int flags,
+                               String installerPackageName) {
+        installCommon(packageURI, new LegacyPackageInstallObserver(observer), flags,
+                installerPackageName, mContext.getUserId());
+    }
+
+    @Override
+    public void installPackage(Uri packageURI, PackageInstallObserver observer,
+            int flags, String installerPackageName) {
+        installCommon(packageURI, observer, flags, installerPackageName, mContext.getUserId());
+    }
+
+    private void installCommon(Uri packageURI,
+            PackageInstallObserver observer, int flags, String installerPackageName,
+            int userId) {
+        if (!"file".equals(packageURI.getScheme())) {
+            throw new UnsupportedOperationException("Only file:// URIs are supported");
+        }
+
+        final String originPath = packageURI.getPath();
+        try {
+            mPM.installPackageAsUser(originPath, observer.getBinder(), flags, installerPackageName,
+                    userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int installExistingPackage(String packageName) throws NameNotFoundException {
+        return installExistingPackageAsUser(packageName, mContext.getUserId());
+    }
+
+    @Override
+    public int installExistingPackageAsUser(String packageName, int userId)
+            throws NameNotFoundException {
+        try {
+            int res = mPM.installExistingPackageAsUser(packageName, userId);
+            if (res == INSTALL_FAILED_INVALID_URI) {
+                throw new NameNotFoundException("Package " + packageName + " doesn't exist");
+            }
+            return res;
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void verifyPendingInstall(int id, int response) {
+        try {
+            mPM.verifyPendingInstall(id, response);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout,
+            long millisecondsToDelay) {
+        try {
+            mPM.extendVerificationTimeout(id, verificationCodeAtTimeout, millisecondsToDelay);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) {
+        try {
+            mPM.verifyIntentFilter(id, verificationCode, failedDomains);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getIntentVerificationStatusAsUser(String packageName, int userId) {
+        try {
+            return mPM.getIntentVerificationStatus(packageName, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean updateIntentVerificationStatusAsUser(String packageName, int status, int userId) {
+        try {
+            return mPM.updateIntentVerificationStatus(packageName, status, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
+        try {
+            ParceledListSlice<IntentFilterVerificationInfo> parceledList =
+                    mPM.getIntentFilterVerifications(packageName);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public List<IntentFilter> getAllIntentFilters(String packageName) {
+        try {
+            ParceledListSlice<IntentFilter> parceledList =
+                    mPM.getAllIntentFilters(packageName);
+            if (parceledList == null) {
+                return Collections.emptyList();
+            }
+            return parceledList.getList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String getDefaultBrowserPackageNameAsUser(int userId) {
+        try {
+            return mPM.getDefaultBrowserPackageName(userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean setDefaultBrowserPackageNameAsUser(String packageName, int userId) {
+        try {
+            return mPM.setDefaultBrowserPackageName(packageName, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void setInstallerPackageName(String targetPackage,
+            String installerPackageName) {
+        try {
+            mPM.setInstallerPackageName(targetPackage, installerPackageName);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String getInstallerPackageName(String packageName) {
+        try {
+            return mPM.getInstallerPackageName(packageName);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getMoveStatus(int moveId) {
+        try {
+            return mPM.getMoveStatus(moveId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void registerMoveCallback(MoveCallback callback, Handler handler) {
+        synchronized (mDelegates) {
+            final MoveCallbackDelegate delegate = new MoveCallbackDelegate(callback,
+                    handler.getLooper());
+            try {
+                mPM.registerMoveCallback(delegate);
+            } catch (RemoteException e) {
+                throw e.rethrowFromSystemServer();
+            }
+            mDelegates.add(delegate);
+        }
+    }
+
+    @Override
+    public void unregisterMoveCallback(MoveCallback callback) {
+        synchronized (mDelegates) {
+            for (Iterator<MoveCallbackDelegate> i = mDelegates.iterator(); i.hasNext();) {
+                final MoveCallbackDelegate delegate = i.next();
+                if (delegate.mCallback == callback) {
+                    try {
+                        mPM.unregisterMoveCallback(delegate);
+                    } catch (RemoteException e) {
+                        throw e.rethrowFromSystemServer();
+                    }
+                    i.remove();
+                }
+            }
+        }
+    }
+
+    @Override
+    public int movePackage(String packageName, VolumeInfo vol) {
+        try {
+            final String volumeUuid;
+            if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.id)) {
+                volumeUuid = StorageManager.UUID_PRIVATE_INTERNAL;
+            } else if (vol.isPrimaryPhysical()) {
+                volumeUuid = StorageManager.UUID_PRIMARY_PHYSICAL;
+            } else {
+                volumeUuid = Preconditions.checkNotNull(vol.fsUuid);
+            }
+
+            return mPM.movePackage(packageName, volumeUuid);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public @Nullable VolumeInfo getPackageCurrentVolume(ApplicationInfo app) {
+        final StorageManager storage = mContext.getSystemService(StorageManager.class);
+        if (app.isInternal()) {
+            return storage.findVolumeById(VolumeInfo.ID_PRIVATE_INTERNAL);
+        } else if (app.isExternalAsec()) {
+            return storage.getPrimaryPhysicalVolume();
+        } else {
+            return storage.findVolumeByUuid(app.volumeUuid);
+        }
+    }
+
+    @Override
+    public @NonNull List<VolumeInfo> getPackageCandidateVolumes(ApplicationInfo app) {
+        final StorageManager storage = mContext.getSystemService(StorageManager.class);
+        final VolumeInfo currentVol = getPackageCurrentVolume(app);
+        final List<VolumeInfo> vols = storage.getVolumes();
+        final List<VolumeInfo> candidates = new ArrayList<>();
+        for (VolumeInfo vol : vols) {
+            if (Objects.equals(vol, currentVol) || isPackageCandidateVolume(mContext, app, vol)) {
+                candidates.add(vol);
+            }
+        }
+        return candidates;
+    }
+
+    private boolean isPackageCandidateVolume(
+            ContextImpl context, ApplicationInfo app, VolumeInfo vol) {
+        final boolean forceAllowOnExternal = Settings.Global.getInt(
+                context.getContentResolver(), Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0;
+        // Private internal is always an option
+        if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.getId())) {
+            return true;
+        }
+
+        // System apps and apps demanding internal storage can't be moved
+        // anywhere else
+        /// M: add checking isVendorApp for not adding into candidate
+        if (app.isSystemApp() || app.isVendorApp()) {
+            return false;
+        }
+        if (!forceAllowOnExternal
+                && (app.installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY
+                        || app.installLocation == PackageInfo.INSTALL_LOCATION_UNSPECIFIED)) {
+            return false;
+        }
+
+        // Gotta be able to write there
+        if (!vol.isMountedWritable()) {
+            return false;
+        }
+
+        // Moving into an ASEC on public primary is only option internal
+        if (vol.isPrimaryPhysical()) {
+            return app.isInternal();
+        }
+
+        // Some apps can't be moved. (e.g. device admins)
+        try {
+            if (mPM.isPackageDeviceAdminOnAnyUser(app.packageName)) {
+                return false;
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        // Otherwise we can move to any private volume
+        return (vol.getType() == VolumeInfo.TYPE_PRIVATE);
+    }
+
+    @Override
+    public int movePrimaryStorage(VolumeInfo vol) {
+        try {
+            final String volumeUuid;
+            if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.id)) {
+                volumeUuid = StorageManager.UUID_PRIVATE_INTERNAL;
+            } else if (vol.isPrimaryPhysical()) {
+                volumeUuid = StorageManager.UUID_PRIMARY_PHYSICAL;
+            } else {
+                volumeUuid = Preconditions.checkNotNull(vol.fsUuid);
+            }
+
+            return mPM.movePrimaryStorage(volumeUuid);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public @Nullable VolumeInfo getPrimaryStorageCurrentVolume() {
+        final StorageManager storage = mContext.getSystemService(StorageManager.class);
+        final String volumeUuid = storage.getPrimaryStorageUuid();
+        return storage.findVolumeByQualifiedUuid(volumeUuid);
+    }
+
+    @Override
+    public @NonNull List<VolumeInfo> getPrimaryStorageCandidateVolumes() {
+        final StorageManager storage = mContext.getSystemService(StorageManager.class);
+        final VolumeInfo currentVol = getPrimaryStorageCurrentVolume();
+        final List<VolumeInfo> vols = storage.getVolumes();
+        final List<VolumeInfo> candidates = new ArrayList<>();
+        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,
+                storage.getPrimaryStorageUuid()) && currentVol != null) {
+            // TODO: support moving primary physical to emulated volume
+            candidates.add(currentVol);
+        } else {
+            for (VolumeInfo vol : vols) {
+                if (Objects.equals(vol, currentVol) || isPrimaryStorageCandidateVolume(vol)) {
+                    candidates.add(vol);
+                }
+            }
+        }
+        return candidates;
+    }
+
+    private static boolean isPrimaryStorageCandidateVolume(VolumeInfo vol) {
+        // Private internal is always an option
+        if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.getId())) {
+            return true;
+        }
+
+        // Gotta be able to write there
+        if (!vol.isMountedWritable()) {
+            return false;
+        }
+
+        // We can move to any private volume
+        return (vol.getType() == VolumeInfo.TYPE_PRIVATE);
+    }
+
+    @Override
+    public void deletePackage(String packageName, IPackageDeleteObserver observer, int flags) {
+        deletePackageAsUser(packageName, observer, flags, mContext.getUserId());
+    }
+
+    @Override
+    public void deletePackageAsUser(String packageName, IPackageDeleteObserver observer, int flags,
+            int userId) {
+        try {
+            mPM.deletePackageAsUser(packageName, observer, userId, flags);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void clearApplicationUserData(String packageName,
+                                         IPackageDataObserver observer) {
+        try {
+            mPM.clearApplicationUserData(packageName, observer, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+    @Override
+    public void deleteApplicationCacheFiles(String packageName,
+                                            IPackageDataObserver observer) {
+        try {
+            mPM.deleteApplicationCacheFiles(packageName, observer);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void deleteApplicationCacheFilesAsUser(String packageName, int userId,
+            IPackageDataObserver observer) {
+        try {
+            mPM.deleteApplicationCacheFilesAsUser(packageName, userId, observer);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void freeStorageAndNotify(String volumeUuid, long idealStorageSize,
+            IPackageDataObserver observer) {
+        try {
+            mPM.freeStorageAndNotify(volumeUuid, idealStorageSize, observer);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void freeStorage(String volumeUuid, long freeStorageSize, IntentSender pi) {
+        try {
+            mPM.freeStorage(volumeUuid, freeStorageSize, pi);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended,
+            int userId) {
+        try {
+            return mPM.setPackagesSuspendedAsUser(packageNames, suspended, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean isPackageSuspendedForUser(String packageName, int userId) {
+        try {
+            return mPM.isPackageSuspendedForUser(packageName, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void getPackageSizeInfoAsUser(String packageName, int userHandle,
+            IPackageStatsObserver observer) {
+        try {
+            mPM.getPackageSizeInfo(packageName, userHandle, observer);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void addPackageToPreferred(String packageName) {
+        Log.w(TAG, "addPackageToPreferred() is a no-op");
+    }
+
+    @Override
+    public void removePackageFromPreferred(String packageName) {
+        Log.w(TAG, "removePackageFromPreferred() is a no-op");
+    }
+
+    @Override
+    public List<PackageInfo> getPreferredPackages(int flags) {
+        Log.w(TAG, "getPreferredPackages() is a no-op");
+        return Collections.emptyList();
+    }
+
+    @Override
+    public void addPreferredActivity(IntentFilter filter,
+                                     int match, ComponentName[] set, ComponentName activity) {
+        try {
+            mPM.addPreferredActivity(filter, match, set, activity, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void addPreferredActivityAsUser(IntentFilter filter, int match,
+            ComponentName[] set, ComponentName activity, int userId) {
+        try {
+            mPM.addPreferredActivity(filter, match, set, activity, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void replacePreferredActivity(IntentFilter filter,
+                                         int match, ComponentName[] set, ComponentName activity) {
+        try {
+            mPM.replacePreferredActivity(filter, match, set, activity, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void replacePreferredActivityAsUser(IntentFilter filter,
+                                         int match, ComponentName[] set, ComponentName activity,
+                                         int userId) {
+        try {
+            mPM.replacePreferredActivity(filter, match, set, activity, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void clearPackagePreferredActivities(String packageName) {
+        try {
+            mPM.clearPackagePreferredActivities(packageName);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getPreferredActivities(List<IntentFilter> outFilters,
+                                      List<ComponentName> outActivities, String packageName) {
+        try {
+            return mPM.getPreferredActivities(outFilters, outActivities, packageName);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public ComponentName getHomeActivities(List<ResolveInfo> outActivities) {
+        try {
+            return mPM.getHomeActivities(outActivities);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void setComponentEnabledSetting(ComponentName componentName,
+                                           int newState, int flags) {
+        try {
+            mPM.setComponentEnabledSetting(componentName, newState, flags, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getComponentEnabledSetting(ComponentName componentName) {
+        try {
+            return mPM.getComponentEnabledSetting(componentName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void setApplicationEnabledSetting(String packageName,
+                                             int newState, int flags) {
+        try {
+            mPM.setApplicationEnabledSetting(packageName, newState, flags,
+                    mContext.getUserId(), mContext.getOpPackageName());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public int getApplicationEnabledSetting(String packageName) {
+        try {
+            return mPM.getApplicationEnabledSetting(packageName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public void flushPackageRestrictionsAsUser(int userId) {
+        try {
+            mPM.flushPackageRestrictionsAsUser(userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * M: Add api for check apk signature
+     *
+     * @hide
+     */
+    @Override
+    public int checkAPKSignatures(String pkg) {
+        try {
+            return mPM.checkAPKSignatures(pkg);
+        } catch (RemoteException e) {
+            return PackageInfo.KEY_ERROR;
+              // Should never happen!
+        }
+    }
+
+    @Override
+    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden,
+            UserHandle user) {
+        try {
+            return mPM.setApplicationHiddenSettingAsUser(packageName, hidden,
+                    user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public boolean getApplicationHiddenSettingAsUser(String packageName, UserHandle user) {
+        try {
+            return mPM.getApplicationHiddenSettingAsUser(packageName, user.getIdentifier());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public KeySet getKeySetByAlias(String packageName, String alias) {
+        Preconditions.checkNotNull(packageName);
+        Preconditions.checkNotNull(alias);
+        try {
+            return mPM.getKeySetByAlias(packageName, alias);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public KeySet getSigningKeySet(String packageName) {
+        Preconditions.checkNotNull(packageName);
+        try {
+            return mPM.getSigningKeySet(packageName);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public boolean isSignedBy(String packageName, KeySet ks) {
+        Preconditions.checkNotNull(packageName);
+        Preconditions.checkNotNull(ks);
+        try {
+            return mPM.isPackageSignedByKeySet(packageName, ks);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /** @hide */
+    @Override
+    public boolean isSignedByExactly(String packageName, KeySet ks) {
+        Preconditions.checkNotNull(packageName);
+        Preconditions.checkNotNull(ks);
+        try {
+            return mPM.isPackageSignedByKeySetExactly(packageName, ks);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public VerifierDeviceIdentity getVerifierDeviceIdentity() {
+        try {
+            return mPM.getVerifierDeviceIdentity();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean isUpgrade() {
+        try {
+            return mPM.isUpgrade();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    @Override
+    public PackageInstaller getPackageInstaller() {
+        synchronized (mLock) {
+            if (mInstaller == null) {
+                try {
+                    mInstaller = new PackageInstaller(mContext, this, mPM.getPackageInstaller(),
+                            mContext.getPackageName(), mContext.getUserId());
+                } catch (RemoteException e) {
+                    throw e.rethrowFromSystemServer();
+                }
+            }
+            return mInstaller;
+        }
+    }
+
+    @Override
+    public boolean isPackageAvailable(String packageName) {
+        try {
+            return mPM.isPackageAvailable(packageName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public void addCrossProfileIntentFilter(IntentFilter filter, int sourceUserId, int targetUserId,
+            int flags) {
+        try {
+            mPM.addCrossProfileIntentFilter(filter, mContext.getOpPackageName(),
+                    sourceUserId, targetUserId, flags);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public void clearCrossProfileIntentFilters(int sourceUserId) {
+        try {
+            mPM.clearCrossProfileIntentFilters(sourceUserId, mContext.getOpPackageName());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public Drawable loadItemIcon(PackageItemInfo itemInfo, ApplicationInfo appInfo) {
+        Drawable dr = loadUnbadgedItemIcon(itemInfo, appInfo);
+        if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
+            return dr;
+        }
+        return getUserBadgedIcon(dr, new UserHandle(mContext.getUserId()));
+    }
+
+    /**
+     * @hide
+     */
+    public Drawable loadUnbadgedItemIcon(PackageItemInfo itemInfo, ApplicationInfo appInfo) {
+        if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
+            Bitmap bitmap = getUserManager().getUserIcon(itemInfo.showUserIcon);
+            if (bitmap == null) {
+                return UserIcons.getDefaultUserIcon(itemInfo.showUserIcon, /* light= */ false);
+            }
+            return new BitmapDrawable(bitmap);
+        }
+        Drawable dr = null;
+        if (itemInfo.packageName != null) {
+            dr = getDrawable(itemInfo.packageName, itemInfo.icon, appInfo);
+        }
+        if (dr == null) {
+            dr = itemInfo.loadDefaultIcon(this);
+        }
+        return dr;
+    }
+
+    private Drawable getBadgedDrawable(Drawable drawable, Drawable badgeDrawable,
+            Rect badgeLocation, boolean tryBadgeInPlace) {
+        final int badgedWidth = drawable.getIntrinsicWidth();
+        final int badgedHeight = drawable.getIntrinsicHeight();
+        final boolean canBadgeInPlace = tryBadgeInPlace
+                && (drawable instanceof BitmapDrawable)
+                && ((BitmapDrawable) drawable).getBitmap().isMutable();
+
+        final Bitmap bitmap;
+        if (canBadgeInPlace) {
+            bitmap = ((BitmapDrawable) drawable).getBitmap();
+        } else {
+            bitmap = Bitmap.createBitmap(badgedWidth, badgedHeight, Bitmap.Config.ARGB_8888);
+        }
+        Canvas canvas = new Canvas(bitmap);
+
+        if (!canBadgeInPlace) {
+            drawable.setBounds(0, 0, badgedWidth, badgedHeight);
+            drawable.draw(canvas);
+        }
+
+        if (badgeLocation != null) {
+            if (badgeLocation.left < 0 || badgeLocation.top < 0
+                    || badgeLocation.width() > badgedWidth || badgeLocation.height() > badgedHeight) {
+                throw new IllegalArgumentException("Badge location " + badgeLocation
+                        + " not in badged drawable bounds "
+                        + new Rect(0, 0, badgedWidth, badgedHeight));
+            }
+            badgeDrawable.setBounds(0, 0, badgeLocation.width(), badgeLocation.height());
+
+            canvas.save();
+            canvas.translate(badgeLocation.left, badgeLocation.top);
+            badgeDrawable.draw(canvas);
+            canvas.restore();
+        } else {
+            badgeDrawable.setBounds(0, 0, badgedWidth, badgedHeight);
+            badgeDrawable.draw(canvas);
+        }
+
+        if (!canBadgeInPlace) {
+            BitmapDrawable mergedDrawable = new BitmapDrawable(mContext.getResources(), bitmap);
+
+            if (drawable instanceof BitmapDrawable) {
+                BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
+                mergedDrawable.setTargetDensity(bitmapDrawable.getBitmap().getDensity());
+            }
+
+            return mergedDrawable;
+        }
+
+        return drawable;
+    }
+
+    private int getBadgeResIdForUser(int userId) {
+        // Return the framework-provided badge.
+        if (isManagedProfile(userId)) {
+            return com.android.internal.R.drawable.ic_corp_icon_badge;
+        }
+        return 0;
+    }
+
+    private boolean isManagedProfile(int userId) {
+        return getUserManager().isManagedProfile(userId);
+    }
+
+    /** {@hide} */
+    private static class MoveCallbackDelegate extends IPackageMoveObserver.Stub implements
+            Handler.Callback {
+        private static final int MSG_CREATED = 1;
+        private static final int MSG_STATUS_CHANGED = 2;
+
+        final MoveCallback mCallback;
+        final Handler mHandler;
+
+        public MoveCallbackDelegate(MoveCallback callback, Looper looper) {
+            mCallback = callback;
+            mHandler = new Handler(looper, this);
+        }
+
+        @Override
+        public boolean handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_CREATED: {
+                    final SomeArgs args = (SomeArgs) msg.obj;
+                    mCallback.onCreated(args.argi1, (Bundle) args.arg2);
+                    args.recycle();
+                    return true;
+                }
+                case MSG_STATUS_CHANGED: {
+                    final SomeArgs args = (SomeArgs) msg.obj;
+                    mCallback.onStatusChanged(args.argi1, args.argi2, (long) args.arg3);
+                    args.recycle();
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public void onCreated(int moveId, Bundle extras) {
+            final SomeArgs args = SomeArgs.obtain();
+            args.argi1 = moveId;
+            args.arg2 = extras;
+            mHandler.obtainMessage(MSG_CREATED, args).sendToTarget();
+        }
+
+        @Override
+        public void onStatusChanged(int moveId, int status, long estMillis) {
+            final SomeArgs args = SomeArgs.obtain();
+            args.argi1 = moveId;
+            args.argi2 = status;
+            args.arg3 = estMillis;
+            mHandler.obtainMessage(MSG_STATUS_CHANGED, args).sendToTarget();
+        }
+    }
+
+    private final ContextImpl mContext;
+    private final IPackageManager mPM;
+
+    private static final Object sSync = new Object();
+    private static ArrayMap<ResourceName, WeakReference<Drawable.ConstantState>> sIconCache
+            = new ArrayMap<ResourceName, WeakReference<Drawable.ConstantState>>();
+    private static ArrayMap<ResourceName, WeakReference<CharSequence>> sStringCache
+            = new ArrayMap<ResourceName, WeakReference<CharSequence>>();
+
+    private final Map<OnPermissionsChangedListener, IOnPermissionsChangeListener>
+            mPermissionListeners = new ArrayMap<>();
+
+    public class OnPermissionsChangeListenerDelegate extends IOnPermissionsChangeListener.Stub
+            implements Handler.Callback{
+        private static final int MSG_PERMISSIONS_CHANGED = 1;
+
+        private final OnPermissionsChangedListener mListener;
+        private final Handler mHandler;
+
+
+        public OnPermissionsChangeListenerDelegate(OnPermissionsChangedListener listener,
+                Looper looper) {
+            mListener = listener;
+            mHandler = new Handler(looper, this);
+        }
+
+        @Override
+        public void onPermissionsChanged(int uid) {
+            mHandler.obtainMessage(MSG_PERMISSIONS_CHANGED, uid, 0).sendToTarget();
+        }
+
+        @Override
+        public boolean handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_PERMISSIONS_CHANGED: {
+                    final int uid = msg.arg1;
+                    mListener.onPermissionsChanged(uid);
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
