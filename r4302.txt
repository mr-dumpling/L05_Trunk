Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/android/telephony/SmsManager.java	(revision 4302)
@@ -0,0 +1,3179 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+import android.app.ActivityThread;
+import android.app.PendingIntent;
+import android.content.ActivityNotFoundException;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.BaseBundle;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+// MTK-START
+import android.os.SystemProperties;
+// MTK-END
+import android.text.TextUtils;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import com.android.internal.telephony.IMms;
+import com.android.internal.telephony.ISms;
+import com.android.internal.telephony.SmsRawData;
+import com.android.internal.telephony.uicc.IccConstants;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+// MTK-START
+import android.app.PendingIntent.CanceledException;
+import com.android.internal.telephony.PhoneConstants;
+import com.mediatek.common.MPlugin;
+// For 4G data only, this class will check 4G data only and prompt to user
+import com.mediatek.common.sms.IDataOnlySmsFwkExt;
+// MTK_ONLY_OWNER_SIM_SUPPORT
+import com.mediatek.common.telephony.IOnlyOwnerSimSupport;
+
+import com.mediatek.internal.telephony.IccSmsStorageStatus;
+// Cell broadcast new interface
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.mediatek.internal.telephony.SmsCbConfigInfo;
+import com.android.internal.telephony.SmsConstants;
+// MTK-END
+
+/*
+ * TODO(code review): Curious question... Why are a lot of these
+ * methods not declared as static, since they do not seem to require
+ * any local object state?  Presumably this cannot be changed without
+ * interfering with the API...
+ */
+
+/**
+ * Manages SMS operations such as sending data, text, and pdu SMS messages.
+ * Get this object by calling the static method {@link #getDefault()}.
+ *
+ * <p>For information about how to behave as the default SMS app on Android 4.4 (API level 19)
+ * and higher, see {@link android.provider.Telephony}.
+ */
+public final class SmsManager {
+    private static final String TAG = "SmsManager";
+    /**
+     * A psuedo-subId that represents the default subId at any given time. The actual subId it
+     * represents changes as the default subId is changed.
+     */
+    private static final int DEFAULT_SUBSCRIPTION_ID = -1002;
+
+    /** Singleton object constructed during class initialization. */
+    private static final SmsManager sInstance = new SmsManager(DEFAULT_SUBSCRIPTION_ID);
+    private static final Object sLockObject = new Object();
+
+    /** @hide */
+    public static final int CELL_BROADCAST_RAN_TYPE_GSM = 0;
+    /** @hide */
+    public static final int CELL_BROADCAST_RAN_TYPE_CDMA = 1;
+
+    private static final Map<Integer, SmsManager> sSubInstances =
+            new ArrayMap<Integer, SmsManager>();
+
+    /** A concrete subscription id, or the pseudo DEFAULT_SUBSCRIPTION_ID */
+    private int mSubId;
+
+    /*
+     * Key for the various carrier-dependent configuration values.
+     * Some of the values are used by the system in processing SMS or MMS messages. Others
+     * are provided for the convenience of SMS applications.
+     */
+
+    /**
+     * Whether to append transaction id to MMS WAP Push M-Notification.ind's content location URI
+     * when constructing the download URL of a new MMS (boolean type)
+     */
+    public static final String MMS_CONFIG_APPEND_TRANSACTION_ID =
+            CarrierConfigManager.KEY_MMS_APPEND_TRANSACTION_ID_BOOL;
+    /**
+     * Whether MMS is enabled for the current carrier (boolean type)
+     */
+    public static final String
+        MMS_CONFIG_MMS_ENABLED = CarrierConfigManager.KEY_MMS_MMS_ENABLED_BOOL;
+    /**
+     * Whether group MMS is enabled for the current carrier (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_GROUP_MMS_ENABLED = CarrierConfigManager.KEY_MMS_GROUP_MMS_ENABLED_BOOL;
+    /**
+     * If this is enabled, M-NotifyResp.ind should be sent to the WAP Push content location instead
+     * of the default MMSC (boolean type)
+     */
+    public static final String MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED =
+            CarrierConfigManager.KEY_MMS_NOTIFY_WAP_MMSC_ENABLED_BOOL;
+    /**
+     * Whether alias is enabled (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_ENABLED = CarrierConfigManager.KEY_MMS_ALIAS_ENABLED_BOOL;
+    /**
+     * Whether audio is allowed to be attached for MMS messages (boolean type)
+     */
+    public static final String
+            MMS_CONFIG_ALLOW_ATTACH_AUDIO = CarrierConfigManager.KEY_MMS_ALLOW_ATTACH_AUDIO_BOOL;
+    /**
+     * Whether multipart SMS is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MULTIPART_SMS_ENABLED =
+            CarrierConfigManager.KEY_MMS_MULTIPART_SMS_ENABLED_BOOL;
+    /**
+     * Whether SMS delivery report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_SMS_DELIVERY_REPORT_ENABLED_BOOL;
+    /**
+     * Whether content-disposition field should be expected in an MMS PDU (boolean type)
+     */
+    public static final String MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION =
+            CarrierConfigManager.KEY_MMS_SUPPORT_MMS_CONTENT_DISPOSITION_BOOL;
+    /**
+     * Whether multipart SMS should be sent as separate messages
+     */
+    public static final String MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES =
+            CarrierConfigManager.KEY_MMS_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES_BOOL;
+    /**
+     * Whether MMS read report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MMS_READ_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_MMS_READ_REPORT_ENABLED_BOOL;
+    /**
+     * Whether MMS delivery report is enabled (boolean type)
+     */
+    public static final String MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED =
+            CarrierConfigManager.KEY_MMS_MMS_DELIVERY_REPORT_ENABLED_BOOL;
+    /**
+     * Max MMS message size in bytes (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_MESSAGE_SIZE = CarrierConfigManager.KEY_MMS_MAX_MESSAGE_SIZE_INT;
+    /**
+     * Max MMS image width (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_IMAGE_WIDTH = CarrierConfigManager.KEY_MMS_MAX_IMAGE_WIDTH_INT;
+    /**
+     * Max MMS image height (int type)
+     */
+    public static final String
+            MMS_CONFIG_MAX_IMAGE_HEIGHT = CarrierConfigManager.KEY_MMS_MAX_IMAGE_HEIGHT_INT;
+    /**
+     * Limit of recipients of MMS messages (int type)
+     */
+    public static final String
+            MMS_CONFIG_RECIPIENT_LIMIT = CarrierConfigManager.KEY_MMS_RECIPIENT_LIMIT_INT;
+    /**
+     * Min alias character count (int type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_MIN_CHARS = CarrierConfigManager.KEY_MMS_ALIAS_MIN_CHARS_INT;
+    /**
+     * Max alias character count (int type)
+     */
+    public static final String
+            MMS_CONFIG_ALIAS_MAX_CHARS = CarrierConfigManager.KEY_MMS_ALIAS_MAX_CHARS_INT;
+    /**
+     * When the number of parts of a multipart SMS reaches this threshold, it should be converted
+     * into an MMS (int type)
+     */
+    public static final String MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD =
+            CarrierConfigManager.KEY_MMS_SMS_TO_MMS_TEXT_THRESHOLD_INT;
+    /**
+     * Some carriers require SMS to be converted into MMS when text length reaches this threshold
+     * (int type)
+     */
+    public static final String MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD =
+            CarrierConfigManager.KEY_MMS_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD_INT;
+    /**
+     * Max message text size (int type)
+     */
+    public static final String MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE =
+            CarrierConfigManager.KEY_MMS_MESSAGE_TEXT_MAX_SIZE_INT;
+    /**
+     * Max message subject length (int type)
+     */
+    public static final String
+            MMS_CONFIG_SUBJECT_MAX_LENGTH = CarrierConfigManager.KEY_MMS_SUBJECT_MAX_LENGTH_INT;
+    /**
+     * MMS HTTP socket timeout in milliseconds (int type)
+     */
+    public static final String
+            MMS_CONFIG_HTTP_SOCKET_TIMEOUT = CarrierConfigManager.KEY_MMS_HTTP_SOCKET_TIMEOUT_INT;
+    /**
+     * The name of the UA Prof URL HTTP header for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_UA_PROF_TAG_NAME = CarrierConfigManager.KEY_MMS_UA_PROF_TAG_NAME_STRING;
+    /**
+     * The User-Agent header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_USER_AGENT = CarrierConfigManager.KEY_MMS_USER_AGENT_STRING;
+    /**
+     * The UA Profile URL header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_UA_PROF_URL = CarrierConfigManager.KEY_MMS_UA_PROF_URL_STRING;
+    /**
+     * A list of HTTP headers to add to MMS HTTP request, separated by "|" (String type)
+     */
+    public static final String
+            MMS_CONFIG_HTTP_PARAMS = CarrierConfigManager.KEY_MMS_HTTP_PARAMS_STRING;
+    /**
+     * Email gateway number (String type)
+     */
+    public static final String MMS_CONFIG_EMAIL_GATEWAY_NUMBER =
+            CarrierConfigManager.KEY_MMS_EMAIL_GATEWAY_NUMBER_STRING;
+    /**
+     * The suffix to append to the NAI header value for MMS HTTP request (String type)
+     */
+    public static final String
+            MMS_CONFIG_NAI_SUFFIX = CarrierConfigManager.KEY_MMS_NAI_SUFFIX_STRING;
+    /**
+     * If true, show the cell broadcast (amber alert) in the SMS settings. Some carriers don't want
+     * this shown. (Boolean type)
+     */
+    public static final String MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS =
+            CarrierConfigManager.KEY_MMS_SHOW_CELL_BROADCAST_APP_LINKS_BOOL;
+    /**
+     * Whether the carrier MMSC supports charset field in Content-Type header. If this is false,
+     * then we don't add "charset" to "Content-Type"
+     */
+    public static final String MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER =
+            CarrierConfigManager.KEY_MMS_SUPPORT_HTTP_CHARSET_HEADER_BOOL;
+    /**
+     * If true, add "Connection: close" header to MMS HTTP requests so the connection
+     * is immediately closed (disabling keep-alive). (Boolean type)
+     * @hide
+     */
+    public static final String MMS_CONFIG_CLOSE_CONNECTION =
+            CarrierConfigManager.KEY_MMS_CLOSE_CONNECTION_BOOL;
+
+    /*
+     * Forwarded constants from SimDialogActivity.
+     */
+    private static String DIALOG_TYPE_KEY = "dialog_type";
+    private static final int SMS_PICK = 2;
+
+    // MTK-START
+    /** Tablet Multi-user feature */
+    private IOnlyOwnerSimSupport mOnlyOwnerSimSupport = null;
+
+    /** 4G data only feature */
+    private IDataOnlySmsFwkExt mDataOnlySmsFwkExt = null;
+
+    private static boolean DBG = SystemProperties.get("ro.build.type").equals("eng");
+    // MTK-END
+
+    /**
+     * Send a text based SMS.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
+     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
+     * writes messages sent using this method to the SMS Provider (the default SMS app is always
+     * responsible for writing its sent messages to the SMS Provider). For information about
+     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
+     *
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param text the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or text are empty
+     */
+    public void sendTextMessage(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        sendTextMessageInternal(destinationAddress, scAddress, text,
+            sentIntent, deliveryIntent, true /* persistMessageForCarrierApp*/);
+    }
+
+    private void sendTextMessageInternal(String destinationAddress, String scAddress,
+            String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
+            boolean persistMessageForCarrierApp) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        // MTK-START
+        // Support empty content
+        //if (TextUtils.isEmpty(text)) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+        Rlog.d(TAG, "sendTextMessage, text=" + ((DBG == true)? text : "") +
+                ", destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, text, sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(),
+                    destinationAddress,
+                    scAddress, text, sentIntent, deliveryIntent,
+                    persistMessageForCarrierApp);
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "sendTextMessage, RemoteException!");
+            // MTK-END
+        }
+    }
+
+    /**
+     * Send a text based SMS without writing it into the SMS Provider.
+     *
+     * <p>Only the carrier app can call this method.</p>
+     *
+     * @see #sendTextMessage(String, String, String, PendingIntent, PendingIntent)
+     * @hide
+     */
+    public void sendTextMessageWithoutPersisting(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        sendTextMessageInternal(destinationAddress, scAddress, text,
+            sentIntent, deliveryIntent, false /* persistMessageForCarrierApp*/);
+    }
+
+    /**
+     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
+     * for internal use only.
+     *
+     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
+     * the Phone process if set to false.
+     *
+     * @hide
+     */
+    public void sendTextMessageWithSelfPermissions(
+            String destinationAddress, String scAddress, String text,
+            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        // MTK-START
+        // Support empty content
+        //if (TextUtils.isEmpty(text)) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+        Rlog.d(TAG, "sendTextMessage, text=" + ((DBG == true)? text : "") +
+                ", destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, text, sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
+                    ActivityThread.currentPackageName(),
+                    destinationAddress,
+                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Inject an SMS PDU into the android application framework.
+     *
+     * The caller should have carrier privileges.
+     * @see android.telephony.TelephonyManager#hasCarrierPrivileges
+     *
+     * @param pdu is the byte array of pdu to be injected into android application framework
+     * @param format is the format of SMS pdu (3gpp or 3gpp2)
+     * @param receivedIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully received by the
+     *  android application framework, or failed. This intent is broadcasted at
+     *  the same time an SMS received from radio is acknowledged back.
+     *  The result code will be <code>RESULT_SMS_HANDLED</code> for success, or
+     *  <code>RESULT_SMS_GENERIC_ERROR</code> for error.
+     *
+     * @throws IllegalArgumentException if format is not one of 3gpp and 3gpp2.
+     */
+    public void injectSmsPdu(byte[] pdu, String format, PendingIntent receivedIntent) {
+        if (!format.equals(SmsMessage.FORMAT_3GPP) && !format.equals(SmsMessage.FORMAT_3GPP2)) {
+            // Format must be either 3gpp or 3gpp2.
+            throw new IllegalArgumentException(
+                    "Invalid pdu format. format must be either 3gpp or 3gpp2");
+        }
+        try {
+            ISms iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            if (iccISms != null) {
+                iccISms.injectSmsPduForSubscriber(
+                        getSubscriptionId(), pdu, format, receivedIntent);
+            }
+        } catch (RemoteException ex) {
+          // ignore it
+        }
+    }
+
+    /**
+     * Divide a message text into several fragments, none bigger than
+     * the maximum SMS message size.
+     *
+     * @param text the original message.  Must not be null.
+     * @return an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     *
+     * @throws IllegalArgumentException if text is null
+     */
+    public ArrayList<String> divideMessage(String text) {
+        if (null == text) {
+            throw new IllegalArgumentException("text is null");
+        }
+        return SmsMessage.fragmentText(text);
+    }
+
+    /**
+     * Send a multi-part text based SMS.  The callee should have already
+     * divided the message into correctly sized parts by calling
+     * <code>divideMessage</code>.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
+     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
+     * writes messages sent using this method to the SMS Provider (the default SMS app is always
+     * responsible for writing its sent messages to the SMS Provider). For information about
+     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK</code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applications,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     */
+    public void sendMultipartTextMessage(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        sendMultipartTextMessageInternal(destinationAddress, scAddress, parts,
+              sentIntents, deliveryIntents, true /* persistMessageForCarrierApp*/);
+    }
+
+    private void sendMultipartTextMessageInternal(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents,
+            boolean persistMessageForCarrierApp) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+        // MTK-START
+        // Support empty content
+        //if (parts == null || parts.size() < 1) {
+        //    throw new IllegalArgumentException("Invalid message body");
+        //}
+
+        Rlog.d(TAG, "sendMultipartTextMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, parts, sentIntents)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                iccISms.sendMultipartTextForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        destinationAddress, scAddress, parts,
+                        sentIntents, deliveryIntents, persistMessageForCarrierApp);
+            } catch (RemoteException ex) {
+                // ignore it
+                // MTK-START
+                Rlog.d(TAG, "sendMultipartTextMessage, RemoteException!");
+                // MTK-END
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+            // MTK-START
+            // If content is null, pass the empty string
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            sendTextMessage(destinationAddress, scAddress, text,
+                    sentIntent, deliveryIntent);
+            // MTK-END
+        }
+    }
+
+    /**
+     * Send a multi-part text based SMS without writing it into the SMS Provider.
+     *
+     * <p>Only the carrier app can call this method.</p>
+     *
+     * @see #sendMultipartTextMessage(String, String, ArrayList, ArrayList, ArrayList)
+     * @hide
+     **/
+    public void sendMultipartTextMessageWithoutPersisting(
+            String destinationAddress, String scAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        sendMultipartTextMessageInternal(destinationAddress, scAddress, parts,
+            sentIntents, deliveryIntents, false /* persistMessageForCarrierApp*/);
+    }
+
+    /**
+     * Send a data based SMS to a specific application port.
+     *
+     * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
+     * {@link android.Manifest.permission#SEND_SMS} permission.</p>
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param destinationPort the port to deliver the message to
+     * @param data the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     */
+    public void sendDataMessage(
+            String destinationAddress, String scAddress, short destinationPort,
+            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendDataForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(),
+                    destinationAddress, scAddress, destinationPort & 0xFFFF,
+                    data, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "sendDataMessage, RemoteException!");
+            // MTK-END
+        }
+    }
+
+    /**
+     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
+     * for internal use only.
+     *
+     * @hide
+     */
+    public void sendDataMessageWithSelfPermissions(
+            String destinationAddress, String scAddress, short destinationPort,
+            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(1);
+        sentIntents.add(sentIntent);
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
+                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
+                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+
+
+    /**
+     * Get the SmsManager associated with the default subscription id. The instance will always be
+     * associated with the default subscription id, even if the default subscription id is changed.
+     *
+     * @return the SmsManager associated with the default subscription id
+     */
+    public static SmsManager getDefault() {
+        return sInstance;
+    }
+
+    /**
+     * Get the the instance of the SmsManager associated with a particular subscription id
+     *
+     * @param subId an SMS subscription id, typically accessed using
+     *   {@link android.telephony.SubscriptionManager}
+     * @return the instance of the SmsManager associated with subId
+     */
+    public static SmsManager getSmsManagerForSubscriptionId(int subId) {
+        // TODO(shri): Add javadoc link once SubscriptionManager is made public api
+        synchronized(sLockObject) {
+            SmsManager smsManager = sSubInstances.get(subId);
+            if (smsManager == null) {
+                smsManager = new SmsManager(subId);
+                sSubInstances.put(subId, smsManager);
+            }
+            return smsManager;
+        }
+    }
+
+    private SmsManager(int subId) {
+        mSubId = subId;
+
+        // MTK-START
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            /** Tablet Multi-user feature */
+            try {
+                mOnlyOwnerSimSupport = MPlugin.createInstance(IOnlyOwnerSimSupport.class.getName());
+                if (mOnlyOwnerSimSupport != null) {
+                    String actualClassName = mOnlyOwnerSimSupport.getClass().getName();
+                    Rlog.d(TAG, "initial mOnlyOwnerSimSupport done, actual class name is " +
+                            actualClassName);
+                } else {
+                    Rlog.e(TAG, "FAIL! intial mOnlyOwnerSimSupport");
+                }
+            } catch (RuntimeException e) {
+                Rlog.e(TAG, "FAIL! No IOnlyOwnerSimSupport");
+            }
+
+            /** 4G data only feature */
+            try {
+                mDataOnlySmsFwkExt = MPlugin.createInstance(IDataOnlySmsFwkExt.class.getName());
+                if (mDataOnlySmsFwkExt != null) {
+                    String className = mDataOnlySmsFwkExt.getClass().getName();
+                    Rlog.d(TAG, "initial mDataOnlySmsFwkExt done, class name is " + className);
+                } else {
+                    Rlog.e(TAG, "FAIL! intial mDataOnlySmsFwkExt");
+                }
+            } catch (RuntimeException e) {
+                Rlog.e(TAG, "FAIL! No mDataOnlySmsFwkExt");
+            }
+        }
+        // MTK-END
+    }
+
+    /**
+     * Get the associated subscription id. If the instance was returned by {@link #getDefault()},
+     * then this method may return different values at different points in time (if the user
+     * changes the default subscription id). It will return < 0 if the default subscription id
+     * cannot be determined.
+     *
+     * Additionally, to support legacy applications that are not multi-SIM aware,
+     * if the following are true:
+     *     - We are using a multi-SIM device
+     *     - A default SMS SIM has not been selected
+     *     - At least one SIM subscription is available
+     * then ask the user to set the default SMS SIM.
+     *
+     * @return associated subscription id
+     */
+    public int getSubscriptionId() {
+        final int subId = (mSubId == DEFAULT_SUBSCRIPTION_ID)
+                ? getDefaultSmsSubscriptionId() : mSubId;
+        boolean isSmsSimPickActivityNeeded = false;
+        final Context context = ActivityThread.currentApplication().getApplicationContext();
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                isSmsSimPickActivityNeeded = iccISms.isSmsSimPickActivityNeeded(subId);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "Exception in getSubscriptionId");
+        }
+
+        // MTK-START
+        // Mark since MTK have another SIM Card selection logic
+        isSmsSimPickActivityNeeded = false;
+        // MTK-END
+        if (isSmsSimPickActivityNeeded) {
+            Log.d(TAG, "getSubscriptionId isSmsSimPickActivityNeeded is true");
+            // ask the user for a default SMS SIM.
+            Intent intent = new Intent();
+            intent.setClassName("com.android.settings",
+                    "com.android.settings.sim.SimDialogActivity");
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
+            try {
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException anfe) {
+                // If Settings is not installed, only log the error as we do not want to break
+                // legacy applications.
+                Log.e(TAG, "Unable to launch Settings application.");
+            }
+        }
+
+        return subId;
+    }
+
+    /**
+     * Returns the ISms service, or throws an UnsupportedOperationException if
+     * the service does not exist.
+     */
+    private static ISms getISmsServiceOrThrow() {
+        ISms iccISms = getISmsService();
+        if (iccISms == null) {
+            throw new UnsupportedOperationException("Sms is not supported");
+        }
+        return iccISms;
+    }
+
+    private static ISms getISmsService() {
+        return ISms.Stub.asInterface(ServiceManager.getService("isms"));
+    }
+
+    /**
+     * Copy a raw SMS PDU to the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param smsc the SMSC for this message, or NULL for the default SMSC
+     * @param pdu the raw PDU to store
+     * @param status message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *               STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @return true for success
+     *
+     * @throws IllegalArgumentException if pdu is NULL
+     * {@hide}
+     */
+    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
+        // MTK-START
+        Rlog.d(TAG, "copyMessageToIcc");
+        // MTK-END
+        boolean success = false;
+        // MTK-START
+        SimSmsInsertStatus smsStatus = null;
+        // MTK-END
+
+        if (null == pdu) {
+            throw new IllegalArgumentException("pdu is NULL");
+        }
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.copyMessageToIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        status, pdu, smsc);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Delete the specified message from the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param messageIndex is the record index of the message on ICC
+     * @return true for success
+     *
+     * {@hide}
+     */
+    public boolean
+    deleteMessageFromIcc(int messageIndex) {
+        // MTK-START
+        Rlog.d(TAG, "deleteMessageFromIcc, messageIndex=" + messageIndex);
+        // MTK-END
+        boolean success = false;
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+        // MTK-END
+
+        byte[] pdu = new byte[IccConstants.SMS_RECORD_LENGTH-1];
+        Arrays.fill(pdu, (byte)0xff);
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.updateMessageOnIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        messageIndex, STATUS_ON_ICC_FREE, pdu);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "deleteMessageFromIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return success;
+    }
+
+    /**
+     * Update the specified message on the ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @param messageIndex record index of message to update
+     * @param newStatus new message status (STATUS_ON_ICC_READ,
+     *                  STATUS_ON_ICC_UNREAD, STATUS_ON_ICC_SENT,
+     *                  STATUS_ON_ICC_UNSENT, STATUS_ON_ICC_FREE)
+     * @param pdu the raw PDU to store
+     * @return true for success
+     *
+     * {@hide}
+     */
+    public boolean updateMessageOnIcc(int messageIndex, int newStatus, byte[] pdu) {
+        // MTK-START
+        Rlog.d(TAG, "updateMessageOnIcc, messageIndex=" + messageIndex);
+        // MTK-END
+        boolean success = false;
+
+        // MTK-START
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false ;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.updateMessageOnIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(),
+                        messageIndex, newStatus, pdu);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "updateMessageOnIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return success;
+    }
+
+    /**
+     * Retrieves all messages currently stored on ICC.
+     * ICC (Integrated Circuit Card) is the card of the device.
+     * For example, this can be the SIM or USIM for GSM.
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects
+     *
+     * {@hide}
+     */
+    public ArrayList<SmsMessage> getAllMessagesFromIcc() {
+        // MTK-START
+        Rlog.d(TAG, "getAllMessagesFromIcc");
+        // MTK-END
+        List<SmsRawData> records = null;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                records = iccISms.getAllMessagesFromIccEfForSubscriber(
+                        getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+            // MTK-START
+            Rlog.d(TAG, "getAllMessagesFromIcc, RemoteException!");
+            // MTK-END
+        }
+
+        return createMessageListFromRawRecords(records);
+    }
+
+    /**
+     * Enable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA).Note that if two different clients
+     * enable the same message identifier, they must both disable it for the device to stop
+     * receiving those messages. All received messages will be broadcast in an
+     * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     * @see #disableCellBroadcast(int, int)
+     *
+     * {@hide}
+     */
+    public boolean enableCellBroadcast(int messageIdentifier, int ranType) {
+        boolean success = false;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.enableCellBroadcastForSubscriber(
+                        getSubscriptionId(), messageIdentifier, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Disable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different clients
+     * enable the same message identifier, they must both disable it for the
+     * device to stop receiving those messages.
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     *
+     * @see #enableCellBroadcast(int, int)
+     *
+     * {@hide}
+     */
+    public boolean disableCellBroadcast(int messageIdentifier, int ranType) {
+        boolean success = false;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.disableCellBroadcastForSubscriber(
+                        getSubscriptionId(), messageIdentifier, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Enable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier range and RAN type. The RAN type specify this message ID
+     * belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different clients enable
+     * the same message identifier, they must both disable it for the device to stop
+     * receiving those messages. All received messages will be broadcast in an
+     * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     * @see #disableCellBroadcastRange(int, int, int)
+     *
+     * @throws IllegalArgumentException if endMessageId < startMessageId
+     * {@hide}
+     */
+    public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
+        boolean success = false;
+
+        if (endMessageId < startMessageId) {
+            throw new IllegalArgumentException("endMessageId < startMessageId");
+        }
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.enableCellBroadcastRangeForSubscriber(getSubscriptionId(),
+                        startMessageId, endMessageId, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Disable reception of cell broadcast (SMS-CB) messages with the given
+     * message identifier range and RAN type. The RAN type specify this message
+     * ID range belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different
+     * clients enable the same message identifier, they must both disable it for
+     * the device to stop receiving those messages.
+     * Note: This call is blocking, callers may want to avoid calling it from
+     * the main thread of an application.
+     *
+     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
+     * or C.R1001-G (3GPP2)
+     * @param ranType as defined in class SmsManager, the value can be one of these:
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_GSM
+     *    android.telephony.SmsMessage.CELL_BROADCAST_RAN_TYPE_CDMA
+     * @return true if successful, false otherwise
+     *
+     * @see #enableCellBroadcastRange(int, int, int)
+     *
+     * @throws IllegalArgumentException if endMessageId < startMessageId
+     * {@hide}
+     */
+    public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
+        boolean success = false;
+
+        if (endMessageId < startMessageId) {
+            throw new IllegalArgumentException("endMessageId < startMessageId");
+        }
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                success = iccISms.disableCellBroadcastRangeForSubscriber(getSubscriptionId(),
+                        startMessageId, endMessageId, ranType);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return success;
+    }
+
+    /**
+     * Create a list of <code>SmsMessage</code>s from a list of RawSmsData
+     * records returned by <code>getAllMessagesFromIcc()</code>
+     *
+     * @param records SMS EF records, returned by
+     *   <code>getAllMessagesFromIcc</code>
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.
+     */
+    // MTK-START
+    private ArrayList<SmsMessage> createMessageListFromRawRecords(List<SmsRawData> records) {
+    // MTK-END
+        ArrayList<SmsMessage> messages = new ArrayList<SmsMessage>();
+        // MTK-START
+        Rlog.d(TAG, "createMessageListFromRawRecords");
+        // MTK-END
+        if (records != null) {
+            int count = records.size();
+            for (int i = 0; i < count; i++) {
+                SmsRawData data = records.get(i);
+                // List contains all records, including "free" records (null)
+                if (data != null) {
+                    // MTK-START
+                    int activePhone = TelephonyManager.getDefault().getCurrentPhoneType(mSubId);
+                    String phoneType = (PhoneConstants.PHONE_TYPE_CDMA == activePhone)
+                            ? SmsConstants.FORMAT_3GPP2 : SmsConstants.FORMAT_3GPP;
+                    Rlog.d(TAG, "phoneType: " + phoneType);
+                    SmsMessage sms = SmsMessage.createFromEfRecord(i + 1, data.getBytes(),
+                            phoneType);
+                    //SmsMessage sms = SmsMessage.createFromEfRecord(i+1, data.getBytes());
+                    // MTK-END
+                    if (sms != null) {
+                        messages.add(sms);
+                    }
+                }
+            }
+            // MTK-START
+            Rlog.d(TAG, "actual sms count is " + count);
+            // MTK-END
+        // MTK-START
+        } else {
+            Rlog.d(TAG, "fail to parse SIM sms, records is null");
+        }
+        // MTK-END
+
+        return messages;
+    }
+
+    /**
+     * SMS over IMS is supported if IMS is registered and SMS is supported
+     * on IMS.
+     *
+     * @return true if SMS over IMS is supported, false otherwise
+     *
+     * @see #getImsSmsFormat()
+     *
+     * @hide
+     */
+    public boolean isImsSmsSupported() {
+        boolean boSupported = false;
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                boSupported = iccISms.isImsSmsSupportedForSubscriber(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return boSupported;
+    }
+
+    /**
+     * Gets SMS format supported on IMS.  SMS over IMS format is
+     * either 3GPP or 3GPP2.
+     *
+     * @return SmsMessage.FORMAT_3GPP,
+     *         SmsMessage.FORMAT_3GPP2
+     *      or SmsMessage.FORMAT_UNKNOWN
+     *
+     * @see #isImsSmsSupported()
+     *
+     * @hide
+     */
+    public String getImsSmsFormat() {
+        String format = com.android.internal.telephony.SmsConstants.FORMAT_UNKNOWN;
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                format = iccISms.getImsSmsFormatForSubscriber(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return format;
+    }
+
+    /**
+     * Get default sms subscription id
+     *
+     * @return the default SMS subscription id
+     */
+    public static int getDefaultSmsSubscriptionId() {
+        ISms iccISms = null;
+        try {
+            iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            return iccISms.getPreferredSmsSubscription();
+        } catch (RemoteException ex) {
+            return -1;
+        } catch (NullPointerException ex) {
+            return -1;
+        }
+    }
+
+    /**
+     * Get SMS prompt property,  enabled or not
+     *
+     * @return true if enabled, false otherwise
+     * @hide
+     */
+    public boolean isSMSPromptEnabled() {
+        ISms iccISms = null;
+        try {
+            iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
+            return iccISms.isSMSPromptEnabled();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    // see SmsMessage.getStatusOnIcc
+
+    /** Free space (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_FREE      = 0;
+
+    /** Received and read (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_READ      = 1;
+
+    /** Received and unread (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_UNREAD    = 3;
+
+    /** Stored and sent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_SENT      = 5;
+
+    /** Stored and unsent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
+    static public final int STATUS_ON_ICC_UNSENT    = 7;
+
+    // SMS send failure result codes
+
+    /** Generic failure cause */
+    static public final int RESULT_ERROR_GENERIC_FAILURE    = 1;
+    /** Failed because radio was explicitly turned off */
+    static public final int RESULT_ERROR_RADIO_OFF          = 2;
+    /** Failed because no pdu provided */
+    static public final int RESULT_ERROR_NULL_PDU           = 3;
+    /** Failed because service is currently unavailable */
+    static public final int RESULT_ERROR_NO_SERVICE         = 4;
+    /** Failed because we reached the sending queue limit.  {@hide} */
+    static public final int RESULT_ERROR_LIMIT_EXCEEDED     = 5;
+    /** Failed because FDN is enabled. {@hide} */
+    static public final int RESULT_ERROR_FDN_CHECK_FAILURE  = 6;
+
+    static private final String PHONE_PACKAGE_NAME = "com.android.phone";
+
+    // MTK-START
+    /**
+     * Sucessful error code.
+     *
+     * @internal
+     * @hide
+     */
+    static public final int RESULT_ERROR_SUCCESS = 0;
+    /**
+     * Failed because sim memory is full.
+     *
+     * @internal
+     * @hide
+     */
+    static public final int RESULT_ERROR_SIM_MEM_FULL = 7;
+    /** @hide */
+    static public final int RESULT_ERROR_INVALID_ADDRESS = 8;
+
+    // for SMS validity period feature
+    /**
+     * Support to change the validity period.
+     * Extra parameter on bundle for validity period.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String EXTRA_PARAMS_VALIDITY_PERIOD = "validity_period";
+
+    /** @hide */
+    public static final String EXTRA_PARAMS_ENCODING_TYPE = "encoding_type";
+
+    /**
+     * Support to change the validity period.
+     * The value of no duration.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_NO_DURATION = -1;
+
+    /**
+     * Support to change the validity period.
+     * The value of one hour.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_ONE_HOUR = 11; // (VP + 1) * 5 = 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of six hours.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_SIX_HOURS = 71; // (VP + 1) * 5 = 6 * 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of twelve hours.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_TWELVE_HOURS = 143; // (VP + 1) * 5 = 12 * 60 Mins
+
+    /**
+     * Support to change the validity period.
+     * The value of one day.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_ONE_DAY = 167; // 12 + (VP - 143) * 30 Mins = 24 Hours
+
+    /**
+     * Support to change the validity period.
+     * The value of maximum duration and use the network setting.
+     *
+     * @internal
+     * @hide
+     */
+    public static final int VALIDITY_PERIOD_MAX_DURATION = 255; // (VP - 192) Weeks
+    // MTK-END
+
+    /**
+     * Send an MMS message
+     *
+     * @param context application context
+     * @param contentUri the content Uri from which the message pdu will be read
+     * @param locationUrl the optional location url where message should be sent to
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  sending the message.
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed
+     * @throws IllegalArgumentException if contentUri is empty
+     */
+    public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl,
+            Bundle configOverrides, PendingIntent sentIntent) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms == null) {
+                return;
+            }
+
+            iMms.sendMessage(getSubscriptionId(), ActivityThread.currentPackageName(), contentUri,
+                    locationUrl, configOverrides, sentIntent);
+        } catch (RemoteException e) {
+            // Ignore it
+        }
+    }
+
+    /**
+     * Download an MMS message from carrier by a given location URL
+     *
+     * @param context application context
+     * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained
+     *  from the MMS WAP push notification
+     * @param contentUri the content uri to which the downloaded pdu will be written
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  downloading the message.
+     * @param downloadedIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is downloaded, or the download is failed
+     * @throws IllegalArgumentException if locationUrl or contentUri is empty
+     */
+    public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri,
+            Bundle configOverrides, PendingIntent downloadedIntent) {
+        if (TextUtils.isEmpty(locationUrl)) {
+            throw new IllegalArgumentException("Empty MMS location URL");
+        }
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms == null) {
+                return;
+            }
+            iMms.downloadMessage(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), locationUrl,
+                    contentUri, configOverrides, downloadedIntent);
+        } catch (RemoteException e) {
+            // Ignore it
+        }
+    }
+
+    // MMS send/download failure result codes
+    public static final int MMS_ERROR_UNSPECIFIED = 1;
+    public static final int MMS_ERROR_INVALID_APN = 2;
+    public static final int MMS_ERROR_UNABLE_CONNECT_MMS = 3;
+    public static final int MMS_ERROR_HTTP_FAILURE = 4;
+    public static final int MMS_ERROR_IO_ERROR = 5;
+    public static final int MMS_ERROR_RETRY = 6;
+    public static final int MMS_ERROR_CONFIGURATION_ERROR = 7;
+    public static final int MMS_ERROR_NO_DATA_NETWORK = 8;
+
+    /** Intent extra name for MMS sending result data in byte array type */
+    public static final String EXTRA_MMS_DATA = "android.telephony.extra.MMS_DATA";
+    /** Intent extra name for HTTP status code for MMS HTTP failure in integer type */
+    public static final String EXTRA_MMS_HTTP_STATUS = "android.telephony.extra.MMS_HTTP_STATUS";
+
+    /**
+     * Import a text message into system's SMS store
+     *
+     * Only default SMS apps can import SMS
+     *
+     * @param address the destination(source) address of the sent(received) message
+     * @param type the type of the message
+     * @param text the message text
+     * @param timestampMillis the message timestamp in milliseconds
+     * @param seen if the message is seen
+     * @param read if the message is read
+     * @return the message URI, null if failed
+     * @hide
+     */
+    public Uri importTextMessage(String address, int type, String text, long timestampMillis,
+            boolean seen, boolean read) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.importTextMessage(ActivityThread.currentPackageName(),
+                        address, type, text, timestampMillis, seen, read);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /** Represents the received SMS message for importing {@hide} */
+    public static final int SMS_TYPE_INCOMING = 0;
+    /** Represents the sent SMS message for importing {@hide} */
+    public static final int SMS_TYPE_OUTGOING = 1;
+
+    /**
+     * Import a multimedia message into system's MMS store. Only the following PDU type is
+     * supported: Retrieve.conf, Send.req, Notification.ind, Delivery.ind, Read-Orig.ind
+     *
+     * Only default SMS apps can import MMS
+     *
+     * @param contentUri the content uri from which to read the PDU of the message to import
+     * @param messageId the optional message id. Use null if not specifying
+     * @param timestampSecs the optional message timestamp. Use -1 if not specifying
+     * @param seen if the message is seen
+     * @param read if the message is read
+     * @return the message URI, null if failed
+     * @throws IllegalArgumentException if pdu is empty
+     * {@hide}
+     */
+    public Uri importMultimediaMessage(Uri contentUri, String messageId, long timestampSecs,
+            boolean seen, boolean read) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.importMultimediaMessage(ActivityThread.currentPackageName(),
+                        contentUri, messageId, timestampSecs, seen, read);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Delete a system stored SMS or MMS message
+     *
+     * Only default SMS apps can delete system stored SMS and MMS messages
+     *
+     * @param messageUri the URI of the stored message
+     * @return true if deletion is successful, false otherwise
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public boolean deleteStoredMessage(Uri messageUri) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.deleteStoredMessage(ActivityThread.currentPackageName(), messageUri);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Delete a system stored SMS or MMS thread
+     *
+     * Only default SMS apps can delete system stored SMS and MMS conversations
+     *
+     * @param conversationId the ID of the message conversation
+     * @return true if deletion is successful, false otherwise
+     * {@hide}
+     */
+    public boolean deleteStoredConversation(long conversationId) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.deleteStoredConversation(
+                        ActivityThread.currentPackageName(), conversationId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Update the status properties of a system stored SMS or MMS message, e.g.
+     * the read status of a message, etc.
+     *
+     * @param messageUri the URI of the stored message
+     * @param statusValues a list of status properties in key-value pairs to update
+     * @return true if update is successful, false otherwise
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public boolean updateStoredMessageStatus(Uri messageUri, ContentValues statusValues) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.updateStoredMessageStatus(ActivityThread.currentPackageName(),
+                        messageUri, statusValues);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /** Message status property: whether the message has been seen. 1 means seen, 0 not {@hide} */
+    public static final String MESSAGE_STATUS_SEEN = "seen";
+    /** Message status property: whether the message has been read. 1 means read, 0 not {@hide} */
+    public static final String MESSAGE_STATUS_READ = "read";
+
+    /**
+     * Archive or unarchive a stored conversation
+     *
+     * @param conversationId the ID of the message conversation
+     * @param archived true to archive the conversation, false to unarchive
+     * @return true if update is successful, false otherwise
+     * {@hide}
+     */
+    public boolean archiveStoredConversation(long conversationId, boolean archived) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.archiveStoredConversation(ActivityThread.currentPackageName(),
+                        conversationId, archived);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Add a text message draft to system SMS store
+     *
+     * Only default SMS apps can add SMS draft
+     *
+     * @param address the destination address of message
+     * @param text the body of the message to send
+     * @return the URI of the stored draft message
+     * {@hide}
+     */
+    public Uri addTextMessageDraft(String address, String text) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.addTextMessageDraft(ActivityThread.currentPackageName(), address, text);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Add a multimedia message draft to system MMS store
+     *
+     * Only default SMS apps can add MMS draft
+     *
+     * @param contentUri the content uri from which to read the PDU data of the draft MMS
+     * @return the URI of the stored draft message
+     * @throws IllegalArgumentException if pdu is empty
+     * {@hide}
+     */
+    public Uri addMultimediaMessageDraft(Uri contentUri) {
+        if (contentUri == null) {
+            throw new IllegalArgumentException("Uri contentUri null");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.addMultimediaMessageDraft(ActivityThread.currentPackageName(),
+                        contentUri);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Send a system stored text message.
+     *
+     * You can only send a failed text message or a draft text message.
+     *
+     * @param messageUri the URI of the stored message
+     * @param scAddress is the service center address or null to use the current default SMSC
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK</code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredTextMessage(Uri messageUri, String scAddress, PendingIntent sentIntent,
+            PendingIntent deliveryIntent) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        // MTK-START
+
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendStoredText(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                    scAddress, sentIntent, deliveryIntent);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Send a system stored multi-part text message.
+     *
+     * You can only send a failed text message or a draft text message.
+     * The provided <code>PendingIntent</code> lists should match the part number of the
+     * divided text of the stored message by using <code>divideMessage</code>
+     *
+     * @param messageUri the URI of the stored message
+     * @param scAddress is the service center address or null to use
+     *   the current default SMSC
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK</code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applications,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredMultipartTextMessage(Uri messageUri, String scAddress,
+            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            iccISms.sendStoredMultipartText(
+                    getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                    scAddress, sentIntents, deliveryIntents);
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Send a system stored MMS message
+     *
+     * This is used for sending a previously sent, but failed-to-send, message or
+     * for sending a text message that has been stored as a draft.
+     *
+     * @param messageUri the URI of the stored message
+     * @param configOverrides the carrier-specific messaging configuration values to override for
+     *  sending the message.
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is successfully sent, or failed
+     * @throws IllegalArgumentException if messageUri is empty
+     * {@hide}
+     */
+    public void sendStoredMultimediaMessage(Uri messageUri, Bundle configOverrides,
+            PendingIntent sentIntent) {
+        if (messageUri == null) {
+            throw new IllegalArgumentException("Empty message URI");
+        }
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                iMms.sendStoredMessage(
+                        getSubscriptionId(), ActivityThread.currentPackageName(), messageUri,
+                        configOverrides, sentIntent);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Turns on/off the flag to automatically write sent/received SMS/MMS messages into system
+     *
+     * When this flag is on, all SMS/MMS sent/received are stored by system automatically
+     * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
+     * automatically
+     *
+     * This flag can only be changed by default SMS apps
+     *
+     * @param enabled Whether to enable message auto persisting
+     * {@hide}
+     */
+    public void setAutoPersisting(boolean enabled) {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                iMms.setAutoPersisting(ActivityThread.currentPackageName(), enabled);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+
+    /**
+     * Get the value of the flag to automatically write sent/received SMS/MMS messages into system
+     *
+     * When this flag is on, all SMS/MMS sent/received are stored by system automatically
+     * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
+     * automatically
+     *
+     * @return the current value of the auto persist flag
+     * {@hide}
+     */
+    public boolean getAutoPersisting() {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.getAutoPersisting();
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return false;
+    }
+
+    /**
+     * Get carrier-dependent configuration values.
+     *
+     * @return bundle key/values pairs of configuration values
+     */
+    public Bundle getCarrierConfigValues() {
+        try {
+            IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
+            if (iMms != null) {
+                return iMms.getCarrierConfigValues(getSubscriptionId());
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+        return null;
+    }
+
+    /**
+     * Filters a bundle to only contain MMS config variables.
+     *
+     * This is for use with bundles returned by {@link CarrierConfigManager} which contain MMS
+     * config and unrelated config. It is assumed that all MMS_CONFIG_* keys are present in the
+     * supplied bundle.
+     *
+     * @param config a Bundle that contains MMS config variables and possibly more.
+     * @return a new Bundle that only contains the MMS_CONFIG_* keys defined above.
+     * @hide
+     */
+    public static Bundle getMmsConfig(BaseBundle config) {
+        Bundle filtered = new Bundle();
+        filtered.putBoolean(MMS_CONFIG_APPEND_TRANSACTION_ID,
+                config.getBoolean(MMS_CONFIG_APPEND_TRANSACTION_ID));
+        filtered.putBoolean(MMS_CONFIG_MMS_ENABLED, config.getBoolean(MMS_CONFIG_MMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_GROUP_MMS_ENABLED,
+                config.getBoolean(MMS_CONFIG_GROUP_MMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED,
+                config.getBoolean(MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_ALIAS_ENABLED, config.getBoolean(MMS_CONFIG_ALIAS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_ALLOW_ATTACH_AUDIO,
+                config.getBoolean(MMS_CONFIG_ALLOW_ATTACH_AUDIO));
+        filtered.putBoolean(MMS_CONFIG_MULTIPART_SMS_ENABLED,
+                config.getBoolean(MMS_CONFIG_MULTIPART_SMS_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION,
+                config.getBoolean(MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION));
+        filtered.putBoolean(MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES,
+                config.getBoolean(MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES));
+        filtered.putBoolean(MMS_CONFIG_MMS_READ_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_MMS_READ_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED,
+                config.getBoolean(MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED));
+        filtered.putBoolean(MMS_CONFIG_CLOSE_CONNECTION,
+                config.getBoolean(MMS_CONFIG_CLOSE_CONNECTION));
+        filtered.putInt(MMS_CONFIG_MAX_MESSAGE_SIZE, config.getInt(MMS_CONFIG_MAX_MESSAGE_SIZE));
+        filtered.putInt(MMS_CONFIG_MAX_IMAGE_WIDTH, config.getInt(MMS_CONFIG_MAX_IMAGE_WIDTH));
+        filtered.putInt(MMS_CONFIG_MAX_IMAGE_HEIGHT, config.getInt(MMS_CONFIG_MAX_IMAGE_HEIGHT));
+        filtered.putInt(MMS_CONFIG_RECIPIENT_LIMIT, config.getInt(MMS_CONFIG_RECIPIENT_LIMIT));
+        filtered.putInt(MMS_CONFIG_ALIAS_MIN_CHARS, config.getInt(MMS_CONFIG_ALIAS_MIN_CHARS));
+        filtered.putInt(MMS_CONFIG_ALIAS_MAX_CHARS, config.getInt(MMS_CONFIG_ALIAS_MAX_CHARS));
+        filtered.putInt(MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD,
+                config.getInt(MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD));
+        filtered.putInt(MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD,
+                config.getInt(MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD));
+        filtered.putInt(MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE,
+                config.getInt(MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE));
+        filtered.putInt(MMS_CONFIG_SUBJECT_MAX_LENGTH,
+                config.getInt(MMS_CONFIG_SUBJECT_MAX_LENGTH));
+        filtered.putInt(MMS_CONFIG_HTTP_SOCKET_TIMEOUT,
+                config.getInt(MMS_CONFIG_HTTP_SOCKET_TIMEOUT));
+        filtered.putString(MMS_CONFIG_UA_PROF_TAG_NAME,
+                config.getString(MMS_CONFIG_UA_PROF_TAG_NAME));
+        filtered.putString(MMS_CONFIG_USER_AGENT, config.getString(MMS_CONFIG_USER_AGENT));
+        filtered.putString(MMS_CONFIG_UA_PROF_URL, config.getString(MMS_CONFIG_UA_PROF_URL));
+        filtered.putString(MMS_CONFIG_HTTP_PARAMS, config.getString(MMS_CONFIG_HTTP_PARAMS));
+        filtered.putString(MMS_CONFIG_EMAIL_GATEWAY_NUMBER,
+                config.getString(MMS_CONFIG_EMAIL_GATEWAY_NUMBER));
+        filtered.putString(MMS_CONFIG_NAI_SUFFIX, config.getString(MMS_CONFIG_NAI_SUFFIX));
+        filtered.putBoolean(MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS,
+                config.getBoolean(MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS));
+        filtered.putBoolean(MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER,
+                config.getBoolean(MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER));
+        return filtered;
+    }
+
+    // MTK-START
+    /**
+     * Judge if the destination address is a valid SMS address or not, and if
+     * the text is null or not
+     *
+     * @destinationAddress the destination address to which the message be sent
+     * @text the content of shorm message
+     * @sentIntent will be broadcast if the address or the text is invalid
+     * @return true for valid parameters
+     */
+    private static boolean isValidParameters(String destinationAddress, String text,
+            PendingIntent sentIntent) {
+        ArrayList<PendingIntent> sentIntents =
+                new ArrayList<PendingIntent>();
+        ArrayList<String> parts =
+                new ArrayList<String>();
+
+        sentIntents.add(sentIntent);
+        parts.add(text);
+
+        // if (TextUtils.isEmpty(text)) {
+        // throw new IllegalArgumentException("Invalid message body");
+        // }
+
+        return isValidParameters(destinationAddress, parts, sentIntents);
+    }
+
+    /**
+     * Judges if the destination address is a valid SMS address or not, and if
+     * the text is null or not.
+     *
+     * @param destinationAddress The destination address to which the message be sent
+     * @param parts The content of shorm message
+     * @param sentIntent will be broadcast if the address or the text is invalid
+     * @return True for valid parameters
+     */
+    private static boolean isValidParameters(String destinationAddress, ArrayList<String> parts,
+            ArrayList<PendingIntent> sentIntents) {
+        if (parts == null || parts.size() == 0) {
+            return true;
+        }
+
+        if (!isValidSmsDestinationAddress(destinationAddress)) {
+            for (int i = 0; i < sentIntents.size(); i++) {
+                PendingIntent sentIntent = sentIntents.get(i);
+                if (sentIntent != null) {
+                    try {
+                        sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
+                    } catch (CanceledException ex) { }
+                }
+            }
+
+            Rlog.d(TAG, "Invalid destinationAddress: " + destinationAddress);
+            return false;
+        }
+
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+        if (parts == null || parts.size() < 1) {
+            //throw new IllegalArgumentException("Invalid message body");
+        }
+
+        return true;
+    }
+
+    /**
+     * judge if the input destination address is a valid SMS address or not
+     *
+     * @param da the input destination address
+     * @return true for success
+     *
+     */
+    private static boolean isValidSmsDestinationAddress(String da) {
+        String encodeAddress = PhoneNumberUtils.extractNetworkPortion(da);
+        if (encodeAddress == null)
+            return true;
+
+        return !(encodeAddress.isEmpty());
+    }
+
+    /**
+     * Retrieves all messages currently stored on ICC based on different mode.
+     * Ex. CDMA mode or GSM mode for international cards.
+     *
+     * @param subId subscription identity
+     * @param mode the GSM mode or CDMA mode
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects
+     * @hide
+     */
+    public ArrayList<SmsMessage> getAllMessagesFromIccEfByMode(int mode) {
+        Rlog.d(TAG, "getAllMessagesFromIcc, mode=" + mode);
+
+        List<SmsRawData> records = null;
+
+        try {
+            ISms iccISms = getISmsService();
+            if (iccISms != null) {
+                records = iccISms.getAllMessagesFromIccEfByModeForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), mode);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        int sz = 0;
+        if (records != null) {
+            sz = records.size();
+        }
+        for (int i = 0; i < sz; ++i) {
+            byte[] data = null;
+            SmsRawData record = records.get(i);
+            if (record == null) {
+                continue;
+            } else {
+                data = record.getBytes();
+            }
+            int index = i + 1;
+            if ((data[0] & 0xff) == SmsManager.STATUS_ON_ICC_UNREAD) {
+                Rlog.d(TAG, "index[" + index + "] is STATUS_ON_ICC_READ");
+                boolean ret;
+                ret = updateMessageOnIcc(index, SmsManager.STATUS_ON_ICC_READ, data);
+                if (ret) {
+                    Rlog.d(TAG, "update index[" + index + "] to STATUS_ON_ICC_READ");
+                } else {
+                    Rlog.d(TAG, "fail to update message status");
+                }
+            }
+        }
+
+        return createMessageListFromRawRecordsByMode(getSubscriptionId(), records, mode);
+    }
+
+    /**
+     * Create a list of <code>SmsMessage</code>s from a list of RawSmsData
+     * records returned by <code>getAllMessagesFromIcc()</code>.
+     *
+     * @param subId subscription identity
+     * @param records SMS EF records, returned by
+     *            <code>getAllMessagesFromIcc</code>
+     *
+     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.
+     */
+    private static ArrayList<SmsMessage> createMessageListFromRawRecordsByMode(int subId,
+            List<SmsRawData> records, int mode) {
+        Rlog.d(TAG, "createMessageListFromRawRecordsByMode");
+
+        ArrayList<SmsMessage> msg = null;
+        if (records != null) {
+            int count = records.size();
+            msg = new ArrayList<SmsMessage>();
+
+            for (int i = 0; i < count; i++) {
+                SmsRawData data = records.get(i);
+
+                if (data != null) {
+                    SmsMessage singleSms =
+                            createFromEfRecordByMode(subId, i + 1, data.getBytes(), mode);
+                    if (singleSms != null) {
+                        msg.add(singleSms);
+                    }
+                }
+            }
+            Rlog.d(TAG, "actual sms count is " + msg.size());
+        } else {
+            Rlog.d(TAG, "fail to parse SIM sms, records is null");
+        }
+
+        return msg;
+    }
+
+    /**
+     * Create an SmsMessage from an SMS EF record.
+     *
+     * @param index Index of SMS record. This should be index in ArrayList
+     *              returned by SmsManager.getAllMessagesFromSim + 1.
+     * @param data Record data.
+     * @param slotId SIM card the user would like to access
+     * @return An SmsMessage representing the record.
+     *
+     */
+    private static SmsMessage createFromEfRecordByMode(int subId, int index, byte[] data,
+            int mode) {
+        SmsMessage sms = null;
+
+        if (mode == PhoneConstants.PHONE_TYPE_CDMA) {
+            sms = SmsMessage.createFromEfRecord(index, data, SmsConstants.FORMAT_3GPP2);
+        } else {
+            sms = SmsMessage.createFromEfRecord(index, data, SmsConstants.FORMAT_3GPP);
+        }
+
+        if (sms != null) {
+            sms.setSubId(subId);
+        }
+
+        return sms;
+    }
+
+    /**
+     * Copy a text SMS to the ICC.
+     *
+     * @param subId subscription identity
+     * @param scAddress Service center address
+     * @param address   Destination address or original address
+     * @param text      List of message text
+     * @param status    message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *                  STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param timestamp Timestamp when service center receive the message
+     * @return success or not
+     *
+     * @internal
+     * @hide
+     */
+    public int copyTextMessageToIccCard(String scAddress, String address, List<String> text,
+            int status, long timestamp) {
+        Rlog.d(TAG, "copyTextMessageToIccCard");
+        int result = SmsManager.RESULT_ERROR_GENERIC_FAILURE;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return result;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.copyTextMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), scAddress, address, text, status,
+                        timestamp);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Send a data based SMS to a specific application port.
+     *
+     * @param destinationAddress the address to send the message to
+     * @param scAddress is the service center address or null to use
+     *  the current default SMSC
+     * @param destinationPort the port to deliver the message to
+     * @param originalPort the port to deliver the message from
+     * @param data the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK<code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applicaitons,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     *
+     * @hide
+     */
+    public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort,
+            short originalPort, byte[] data, PendingIntent sentIntent,
+            PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendDataMessage, destinationAddress=" + destinationAddress);
+        if (TextUtils.isEmpty(destinationAddress)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destinationAddress, "send_data", sentIntent)) {
+            return;
+        }
+
+        if (data == null || data.length == 0) {
+            throw new IllegalArgumentException("Invalid message data");
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendDataWithOriginalPortForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destinationAddress, scAddress,
+                        destinationPort & 0xFFFF, originalPort & 0xFFFF, data, sentIntent,
+                        deliveryIntent);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+    }
+
+    /**
+     * Send a text based SMS.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *  the current default SMSC
+     * @param text the body of the message to send
+     * @param encodingType the encoding type of message(gsm 7-bit, unicode or automatic)
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK<code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or text are empty
+     * @hide
+     */
+    public void sendTextMessageWithEncodingType(String destAddr, String scAddr, String text,
+            int encodingType, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendTextMessageWithEncodingType, text=" + ((DBG == true)? text : "") +
+                ", encoding=" + encodingType);
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, text, sentIntent)) {
+            Rlog.d(TAG, "the parameters are invalid");
+            return;
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendTextWithEncodingTypeForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destAddr, scAddr, text, encodingType,
+                        sentIntent, deliveryIntent, true /*persistMessageForCarrierApp*/);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+    }
+
+    /**
+     * Send a multi-part text based SMS.  The callee should have already
+     * divided the message into correctly sized parts by calling
+     * <code>divideMessage</code>.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param encodingType the encoding type of message(gsm 7-bit, unicode or automatic)
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     *   The result code will be <code>Activity.RESULT_OK<code> for success,
+     *   or one of these errors:<br>
+     *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *   <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *   <code>RESULT_ERROR_NULL_PDU</code><br>
+     *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
+     *   the extra "errorCode" containing a radio technology specific value,
+     *   generally only useful for troubleshooting.<br>
+     *   The per-application based SMS control checks sentIntent. If sentIntent
+     *   is NULL the caller will be checked against all unknown applicaitons,
+     *   which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @throws IllegalArgumentException if destinationAddress or data are empty
+     *
+     * @internal
+     * @hide
+     */
+    public void sendMultipartTextMessageWithEncodingType(String destAddr, String scAddr,
+            ArrayList<String> parts, int encodingType, ArrayList<PendingIntent> sentIntents,
+            ArrayList<PendingIntent> deliveryIntents) {
+        Rlog.d(TAG, "sendMultipartTextMessageWithEncodingType, encoding=" + encodingType);
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, parts, sentIntents)) {
+            Rlog.d(TAG, "invalid parameters for multipart message");
+            return;
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                if (iccISms != null) {
+                    iccISms.sendMultipartTextWithEncodingTypeForSubscriber(getSubscriptionId(),
+                            ActivityThread.currentPackageName(), destAddr, scAddr, parts,
+                            encodingType, sentIntents, deliveryIntents,
+                            true /*persistMessageForCarrierApp*/);
+                }
+            } catch (RemoteException ex) {
+                Rlog.d(TAG, "RemoteException");
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            Rlog.d(TAG, "get sentIntent: " + sentIntent);
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+            Rlog.d(TAG, "send single message");
+            if (parts != null) {
+                Rlog.d(TAG, "parts.size = " + parts.size());
+            }
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            Rlog.d(TAG, "pass encoding type " + encodingType);
+            sendTextMessageWithEncodingType(destAddr, scAddr, text, encodingType, sentIntent,
+                    deliveryIntent);
+        }
+    }
+
+    /**
+     * Divide a message text into several fragments, none bigger than
+     * the maximum SMS message size.
+     *
+     * @param text the original message.  Must not be null.
+     * @param encodingType text encoding type(7-bit, 16-bit or automatic)
+     * @return an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     *
+     * @internal
+     * @hide
+     */
+    public ArrayList<String> divideMessage(String text, int encodingType) {
+        Rlog.d(TAG, "divideMessage, encoding = " + encodingType);
+        ArrayList<String> ret = SmsMessage.fragmentText(text, encodingType);
+        Rlog.d(TAG, "divideMessage: size = " + ret.size());
+        return ret;
+    }
+
+    /**
+     * insert a text SMS to the ICC.
+     *
+     * @param subId subscription identity
+     * @param scAddress Service center address
+     * @param address   Destination address or original address
+     * @param text      List of message text
+     * @param status    message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *                  STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param timestamp Timestamp when service center receive the message
+     * @return SimSmsInsertStatus
+     * @hide
+     */
+    public SimSmsInsertStatus insertTextMessageToIccCard(String scAddress, String address,
+            List<String> text, int status, long timestamp) {
+        Rlog.d(TAG, "insertTextMessageToIccCard");
+        SimSmsInsertStatus ret = null;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.insertTextMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), scAddress, address, text, status,
+                        timestamp);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, (ret != null) ? "insert Text " + ret.indexInIcc : "insert Text null");
+        return ret;
+
+    }
+
+    /**
+     * Copy a raw SMS PDU to the ICC.
+     *
+     * @param subId subscription identity
+     * @param status message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
+     *               STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
+     * @param pdu the raw PDU to store
+     * @param smsc encoded smsc service center
+     * @return SimSmsInsertStatus
+     * @hide
+     */
+    public SimSmsInsertStatus insertRawMessageToIccCard(int status, byte[] pdu, byte[] smsc) {
+        Rlog.d(TAG, "insertRawMessageToIccCard");
+        SimSmsInsertStatus ret = null;
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.insertRawMessageToIccCardForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), status, pdu, smsc);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, (ret != null) ? "insert Raw " + ret.indexInIcc : "insert Raw null");
+        return ret;
+    }
+
+    /**
+     * Send an SMS with specified encoding type.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr the SMSC to send the message through, or NULL for the
+     *  default SMSC
+     * @param text the body of the message to send
+     * @param extraParams extra parameters, such as validity period, encoding type
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     * @hide
+     */
+    public void sendTextMessageWithExtraParams(String destAddr, String scAddr, String text,
+            Bundle extraParams, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        Rlog.d(TAG, "sendTextMessageWithExtraParams, text=" + ((DBG == true)? text : ""));
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, text, sentIntent)) {
+            return;
+        }
+
+        if (extraParams == null) {
+            Rlog.d(TAG, "bundle is null");
+            return;
+        }
+
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntent, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.sendTextWithExtraParamsForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), destAddr, scAddr, text, extraParams,
+                        sentIntent, deliveryIntent, true /*persistMessageForCarrierApp*/);
+            }
+        } catch (RemoteException e) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+    }
+
+    /**
+     * Send a multi-part text based SMS with specified encoding type.
+     *
+     * @param subId subscription identity
+     * @param destAddr the address to send the message to
+     * @param scAddr is the service center address or null to use
+     *   the current default SMSC
+     * @param parts an <code>ArrayList</code> of strings that, in order,
+     *   comprise the original message
+     * @param extraParams extra parameters, such as validity period, encoding type
+     * @param sentIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been sent.
+     * @param deliveryIntents if not null, an <code>ArrayList</code> of
+     *   <code>PendingIntent</code>s (one for each message part) that is
+     *   broadcast when the corresponding message part has been delivered
+     *   to the recipient.  The raw pdu of the status report is in the
+     *   extended data ("pdu").
+     *
+     * @internal
+     * @hide
+     */
+    public void sendMultipartTextMessageWithExtraParams(String destAddr, String scAddr,
+            ArrayList<String> parts, Bundle extraParams, ArrayList<PendingIntent> sentIntents,
+            ArrayList<PendingIntent> deliveryIntents) {
+        Rlog.d(TAG, "sendMultipartTextMessageWithExtraParams");
+        if (TextUtils.isEmpty(destAddr)) {
+            throw new IllegalArgumentException("Invalid destinationAddress");
+        }
+
+        if (!isValidParameters(destAddr, parts, sentIntents)) {
+            return;
+        }
+
+        if (extraParams == null) {
+            Rlog.d(TAG, "bundle is null");
+            return;
+        }
+        // MTK-START
+        Context context = ActivityThread.currentApplication().getApplicationContext();
+        if (mDataOnlySmsFwkExt != null && mDataOnlySmsFwkExt.is4GDataOnlyMode(
+                sentIntents, getSubscriptionId(), context)) {
+            Rlog.d(TAG, "is4GDataOnlyMode");
+            return;
+        }
+        // MTK-END
+
+        if (parts.size() > 1) {
+            try {
+                ISms iccISms = getISmsServiceOrThrow();
+                if (iccISms != null) {
+                    iccISms.sendMultipartTextWithExtraParamsForSubscriber(getSubscriptionId(),
+                            ActivityThread.currentPackageName(), destAddr, scAddr, parts,
+                            extraParams, sentIntents, deliveryIntents,
+                            true /*persistMessageForCarrierApp*/);
+                }
+            } catch (RemoteException e) {
+                Rlog.d(TAG, "RemoteException");
+            }
+        } else {
+            PendingIntent sentIntent = null;
+            PendingIntent deliveryIntent = null;
+            if (sentIntents != null && sentIntents.size() > 0) {
+                sentIntent = sentIntents.get(0);
+            }
+            if (deliveryIntents != null && deliveryIntents.size() > 0) {
+                deliveryIntent = deliveryIntents.get(0);
+            }
+
+            String text = (parts == null || parts.size() == 0) ? "" : parts.get(0);
+            sendTextMessageWithExtraParams(destAddr, scAddr, text, extraParams, sentIntent,
+                    deliveryIntent);
+        }
+    }
+
+    /**
+     * Get SMS paramter from icc cards
+     *
+     * @return <code>SmsParameters</code> object for sms sim card settings.
+     *
+     * @hide
+     */
+    public SmsParameters getSmsParameters() {
+        Rlog.d(TAG, "getSmsParameters");
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return null;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.getSmsParametersForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            } else {
+                return null;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        Rlog.d(TAG, "fail to get SmsParameters");
+        return null;
+
+    }
+
+    /**
+     * Set sms paramter icc cards.
+     *
+     * @param params <code>SmsParameters</code>.
+     *
+     * @return true set complete; false set failed.
+     *
+     * @hide
+     */
+    public boolean setSmsParameters(SmsParameters params) {
+        Rlog.d(TAG, "setSmsParameters");
+
+        /** Tablet Multi-user feature */
+        if (mOnlyOwnerSimSupport != null && !mOnlyOwnerSimSupport.isCurrentUserOwner()) {
+            Rlog.d(TAG, "Not the current owner and reject this operation");
+            return false;
+        }
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.setSmsParametersForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), params);
+            } else {
+                return false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return false;
+
+    }
+
+    /**
+     * Copy SMS to Icc cards.
+     *
+     * @param smsc service message centers address
+     * @param pdu sms pdu
+     * @param status sms status
+     *
+     * @return copied index on Icc cards
+     *
+     * @hide
+     */
+    public int copySmsToIcc(byte[] smsc, byte[] pdu, int status) {
+        Rlog.d(TAG, "copySmsToIcc");
+
+        SimSmsInsertStatus smsStatus = insertRawMessageToIccCard(status, pdu, smsc);
+        if (smsStatus == null) {
+            return -1;
+        }
+        int[] index = smsStatus.getIndex();
+
+        if (index != null && index.length > 0) {
+            return index[0];
+        }
+
+        return -1;
+    }
+
+    /**
+     * Update sms status on icc card.
+     *
+     * @param index updated index of sms on icc card
+     * @param read read status
+     *
+     * @return true updated successful; false updated failed.
+     *
+     * @hide
+     */
+    public boolean updateSmsOnSimReadStatus(int index, boolean read) {
+        Rlog.d(TAG, "updateSmsOnSimReadStatus");
+        SmsRawData record = null;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                record = iccISms.getMessageFromIccEfForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName(), index);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        if (record != null) {
+            byte[] rawData = record.getBytes();
+            int status = rawData[0] & 0xff;
+            Rlog.d(TAG, "sms status is " + status);
+            if (status != SmsManager.STATUS_ON_ICC_UNREAD &&
+                    status != SmsManager.STATUS_ON_ICC_READ) {
+                Rlog.d(TAG, "non-delivery sms " + status);
+                return false;
+            } else {
+                if ((status == SmsManager.STATUS_ON_ICC_UNREAD && read == false)
+                        || (status == SmsManager.STATUS_ON_ICC_READ && read == true)) {
+                    Rlog.d(TAG, "no need to update status");
+                    return true;
+                } else {
+                    Rlog.d(TAG, "update sms status as " + read);
+                    int newStatus = ((read == true) ? SmsManager.STATUS_ON_ICC_READ
+                            : SmsManager.STATUS_ON_ICC_UNREAD);
+                    return updateMessageOnIcc(index, newStatus, rawData);
+                }
+            }
+        } // end if(record != null)
+
+        Rlog.d(TAG, "record is null");
+
+        return false;
+    }
+
+    /**
+     * Set ETWS config to modem.
+     *
+     * @param mode ETWS config mode.
+     *
+     * @return true set ETWS config successful; false set ETWS config failed.
+     *
+     * @hide
+     */
+    public boolean setEtwsConfig(int mode) {
+        Rlog.d(TAG, "setEtwsConfig, mode=" + mode);
+        boolean ret = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                ret = iccISms.setEtwsConfigForSubscriber(getSubscriptionId(), mode);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return ret;
+    }
+
+    /**
+     * Set the memory storage status of the SMS.
+     * This function is used for FTA test only.
+     *
+     * @param subId subscription identity
+     * @param status false for storage full, true for storage available
+     *
+     * @internal
+     * @hide
+     */
+    public void setSmsMemoryStatus(boolean status) {
+        Rlog.d(TAG, "setSmsMemoryStatus");
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                iccISms.setSmsMemoryStatusForSubscriber(getSubscriptionId(), status);
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+    }
+
+    /**
+     * Get SMS SIM Card memory's total and used number.
+     *
+     * @param subId subscription identity
+     *
+     * @return <code>IccSmsStorageStatus</code> object
+     *
+     * @internal
+     * @hide
+     */
+    public IccSmsStorageStatus getSmsSimMemoryStatus() {
+        Rlog.d(TAG, "getSmsSimMemoryStatus");
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                return iccISms.getSmsSimMemoryStatusForSubscriber(getSubscriptionId(),
+                        ActivityThread.currentPackageName());
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return null;
+    }
+
+    /**
+     * @hide
+     */
+    private SmsBroadcastConfigInfo Convert2SmsBroadcastConfigInfo(SmsCbConfigInfo info) {
+        return new SmsBroadcastConfigInfo(
+                info.mFromServiceId,
+                info.mToServiceId,
+                info.mFromCodeScheme,
+                info.mToCodeScheme,
+                info.mSelected);
+    }
+
+    /**
+     * @hide
+     */
+    private SmsCbConfigInfo Convert2SmsCbConfigInfo(SmsBroadcastConfigInfo info) {
+        return new SmsCbConfigInfo(
+                info.getFromServiceId(),
+                info.getToServiceId(),
+                info.getFromCodeScheme(),
+                info.getToCodeScheme(),
+                info.isSelected());
+    }
+
+    /**
+     * Set cell broadcast config to icc cards.
+     *
+     * @return <code>SmsBroadcastConfigInfo</code>
+     *
+     * @internal
+     * @hide
+     */
+    public SmsBroadcastConfigInfo[] getCellBroadcastSmsConfig() {
+        Rlog.d(TAG, "getCellBroadcastSmsConfig");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        SmsCbConfigInfo[] configs = null;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                configs = iccISms.getCellBroadcastSmsConfigForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        if (configs != null) {
+            Rlog.d(TAG, "config length = " + configs.length);
+            int i = 0;
+            if (configs.length != 0) {
+                SmsBroadcastConfigInfo[] result = new SmsBroadcastConfigInfo[configs.length];
+                for (i = 0; i < configs.length; i++)
+                    result[i] = Convert2SmsBroadcastConfigInfo(configs[i]);
+                return result;
+            }
+        }
+
+        /*
+         * Exception to return null case, Even if there is no channesl,
+         * it still have one config with -1
+         */
+        return null;
+    }
+
+    /**
+     * Get cell broadcast config from icc cards.
+     *
+     * @param channels <code>SmsBroadcastConfigInfo</code>
+     * @param languages <code>SmsBroadcastConfigInfo</code>
+     *
+     * @return <code>SmsBroadcastConfigInfo</code>
+     *
+     * @internal
+     * @hide
+     */
+    public boolean setCellBroadcastSmsConfig(SmsBroadcastConfigInfo[] channels,
+            SmsBroadcastConfigInfo[] languages) {
+        Rlog.d(TAG, "setCellBroadcastSmsConfig");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        if (channels != null) {
+            Rlog.d(TAG, "channel size=" + channels.length);
+        } else {
+            Rlog.d(TAG, "channel size=0");
+        }
+        if (languages != null) {
+            Rlog.d(TAG, "language size=" + languages.length);
+        } else {
+            Rlog.d(TAG, "language size=0");
+        }
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                int i = 0;
+                SmsCbConfigInfo[] channelInfos = null, languageInfos = null;
+                if (channels != null && channels.length != 0) {
+                    channelInfos = new SmsCbConfigInfo[channels.length];
+                    for (i = 0 ; i < channels.length ; i++)
+                        channelInfos[i] = Convert2SmsCbConfigInfo(channels[i]);
+                }
+                if (languages != null && languages.length != 0) {
+                    languageInfos = new SmsCbConfigInfo[languages.length];
+                    for (i = 0 ; i < languages.length ; i++)
+                        languageInfos[i] = Convert2SmsCbConfigInfo(languages[i]);
+                }
+
+                result = iccISms.setCellBroadcastSmsConfigForSubscriber(getSubscriptionId(),
+                        channelInfos, languageInfos);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "setCellBroadcastSmsConfig, RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Query if cell broadcast activation.
+     *
+     * @return true activatd; false deactivated.
+     *
+     * @internal
+     * @hide
+     */
+    public boolean queryCellBroadcastSmsActivation() {
+        Rlog.d(TAG, "queryCellBroadcastSmsActivation");
+        Rlog.d(TAG, "subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.queryCellBroadcastSmsActivationForSubscriber(
+                        getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * To activate the cell broadcast.
+     *
+     * @param activate true activation; false de-activation.
+     *
+     * @return true process successfully; false process failed.
+     *
+     * @internal
+     * @hide
+     */
+    public boolean activateCellBroadcastSms(boolean activate) {
+        Rlog.d(TAG, "activateCellBroadcastSms activate : " + activate + ", sub = " +
+                getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.activateCellBroadcastSmsForSubscriber(getSubscriptionId(),
+                        activate);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException e) {
+            Rlog.d(TAG, "fail to activate CB");
+            result = false;
+        }
+
+        return result;
+    }
+
+    /**
+     * Remove specified channel and serial of cb message.
+     *
+     * @param channelId removed channel id
+     * @param serialId removed serial id
+     *
+     * @return true process successfully; false process failed.
+     *
+     * @hide
+     */
+    public boolean removeCellBroadcastMsg(int channelId, int serialId) {
+        Rlog.d(TAG, "RemoveCellBroadcastMsg, subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.removeCellBroadcastMsgForSubscriber(getSubscriptionId(),
+                        channelId, serialId);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+                result = false;
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoveCellBroadcastMsg, RemoteException!");
+        }
+
+        return result;
+    }
+
+    /**
+     * Query cell broadcast channel configuration
+     *
+     * @return channel configuration. e.g. "1,3,100-123"
+     *
+     * @hide
+     */
+    public String getCellBroadcastRanges() {
+        Rlog.d(TAG, "getCellBroadcastRanges, subId=" + getSubscriptionId());
+        String configs = "";
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                configs = iccISms.getCellBroadcastRangesForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return configs;
+    }
+
+    /**
+     * Set cell broadcast language configuration
+     *
+     * @param lang denotes language configuration. e.g. "1,7,5-29"
+     *
+     * @hide
+     */
+    public boolean setCellBroadcastLang(String lang) {
+        Rlog.d(TAG, "setCellBroadcastLang, subId=" + getSubscriptionId());
+        boolean result = false;
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                result = iccISms.setCellBroadcastLangsForSubscriber(getSubscriptionId(), lang);
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return result;
+    }
+
+    /**
+     * Get cell broadcast language configuration
+     *
+     * @return language configuration. e.g. "1,2,3,32"
+     *
+     * @hide
+     */
+    public String getCellBroadcastLang() {
+        Rlog.d(TAG, "getCellBroadcastLang, subId=" + getSubscriptionId());
+        String langs = "";
+
+        try {
+            ISms iccISms = getISmsServiceOrThrow();
+            if (iccISms != null) {
+                langs = iccISms.getCellBroadcastLangsForSubscriber(getSubscriptionId());
+            } else {
+                Rlog.d(TAG, "fail to get sms service");
+            }
+        } catch (RemoteException ex) {
+            Rlog.d(TAG, "RemoteException");
+        }
+
+        return langs;
+    }
+    // MTK-END
+}
Index: vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/MessageUtils.java
===================================================================
--- vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/MessageUtils.java	(revision 4301)
+++ vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/ui/MessageUtils.java	(revision 4302)
@@ -1131,6 +1131,17 @@
                 .show();
     }
 
+    public static AlertDialog showSendEmptyMessageConfirmDialog(Context context,
+            OnClickListener listener) {
+        return new AlertDialog.Builder(context)
+                .setIconAttribute(android.R.attr.alertDialogIcon)
+                .setTitle(R.string.send_empty_message_title)
+                .setMessage(R.string.send_empty_message_message)
+                .setPositiveButton(R.string.yes, listener)
+                .setNegativeButton(R.string.no, null)
+                .show();
+    }
+    
     /// M: we[mtk] do not support reply read report when deleteing without read.
     public static void handleReadReport(final Context context,
             final Collection<Long> threadIds,
Index: vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java
===================================================================
--- vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 0)
+++ vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/data/WorkingMessage.java	(revision 4302)
@@ -0,0 +1,3335 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+ /*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.data;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDiskIOException;
+import android.database.sqlite.SqliteWrapper;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.preference.PreferenceManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.provider.Telephony.Threads;
+import android.provider.Telephony.MmsSms.PendingMessages;
+import android.provider.Telephony.MmsSms.WordsTable;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.android.common.contacts.DataUsageStatUpdater;
+import com.android.common.userhappiness.UserHappinessSignals;
+import com.android.mms.ContentRestrictionException;
+import com.android.mms.ExceedMessageSizeException;
+import com.android.mms.LogTag;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.R;
+import com.android.mms.ResolutionException;
+import com.android.mms.RestrictedResolutionException;
+import com.android.mms.UnsupportContentTypeException;
+import com.android.mms.draft.DraftManager;
+import com.android.mms.draft.IDraftInterface;
+import com.android.mms.draft.MmsDraftData;
+import com.android.mms.model.AudioModel;
+import com.android.mms.model.ImageModel;
+import com.android.mms.model.MediaModel;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.model.VideoModel;
+import com.android.mms.model.SlideshowModel.MediaType;
+import com.android.mms.transaction.MessageSender;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.transaction.MmsMessageSender;
+import com.android.mms.transaction.SmsMessageSender;
+import com.android.mms.ui.ComposeMessageActivity;
+import com.android.mms.ui.MessageUtils;
+import com.android.mms.ui.SlideshowEditor;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.MmsLog;
+import com.android.mms.util.Recycler;
+import com.android.mms.util.ThumbnailManager;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.google.android.mms.ContentType;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.SendReq;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.mms.callback.IConversationCallback;
+import com.mediatek.mms.callback.ISplitToMmsAndSmsConversationCallback;
+import com.mediatek.mms.callback.IWorkingMessageCallback;
+import com.mediatek.mms.ext.IOpWorkingMessageExt;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.util.FileAttachmentUtils;
+import com.mediatek.mms.util.MmsSizeUtils;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.MmsPreferenceActivity;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Contains all state related to a message being edited by the user.
+ */
+public class WorkingMessage implements IWorkingMessageCallback {
+    private static final String TAG = "WorkingMessage";
+    private static final String TAG_DRAFT = "[Mms][Draft][WorkingMessage]";
+    private static final boolean DEBUG = false;
+
+    // Public intents
+    public static final String ACTION_SENDING_SMS = "android.intent.action.SENDING_SMS";
+
+    // Intent extras
+    public static final String EXTRA_SMS_MESSAGE = "android.mms.extra.MESSAGE";
+    public static final String EXTRA_SMS_RECIPIENTS = "android.mms.extra.RECIPIENTS";
+    public static final String EXTRA_SMS_THREAD_ID = "android.mms.extra.THREAD_ID";
+
+    //for save message uri when MMS is stoping, and when recreate MMS, it can be read
+    public static final String SAVE_MSG_URI_KEY = "pref_msg_uri_key";
+    public static final String SAVE_MSG_THREADID_KEY = "pref_msg_threadid_key";
+
+    // Database access stuff
+    private final Activity mActivity;
+    private final ContentResolver mContentResolver;
+
+    // States that can require us to save or send a message as MMS.
+    private static final int RECIPIENTS_REQUIRE_MMS = (1 << 0);     // 1
+    private static final int HAS_SUBJECT = (1 << 1);                // 2
+    private static final int HAS_ATTACHMENT = (1 << 2);             // 4
+    private static final int LENGTH_REQUIRES_MMS = (1 << 3);        // 8
+    private static final int FORCE_MMS = (1 << 4);                  // 16
+    /// M: google JB.MR1 patch, group mms
+    private static final int MULTIPLE_RECIPIENTS = (1 << 5);        // 32
+
+    // A bitmap of the above indicating different properties of the message;
+    // any bit set will require the message to be sent via MMS.
+    private int mMmsState;
+
+    // Errors from setAttachment()
+    public static final int OK = 0;
+    public static final int UNKNOWN_ERROR = -1;
+    public static final int MESSAGE_SIZE_EXCEEDED = -2;
+    public static final int UNSUPPORTED_TYPE = -3;
+    public static final int IMAGE_TOO_LARGE = -4;
+
+    // Attachment types
+    public static final int TEXT = 0;
+    public static final int IMAGE = 1;
+    public static final int VIDEO = 2;
+    public static final int AUDIO = 3;
+    public static final int SLIDESHOW = 4;
+
+    // Current attachment type of the message; one of the above values.
+    private int mAttachmentType;
+
+    // Conversation this message is targeting.
+    private Conversation mConversation;
+
+    // Text of the message.
+    private CharSequence mText;
+    // Slideshow for this message, if applicable.  If it's a simple attachment,
+    // i.e. not SLIDESHOW, it will contain only one slide.
+    private SlideshowModel mSlideshow;
+    // Data URI of an MMS message if we have had to save it.
+    private Uri mMessageUri;
+    // MMS subject line for this message
+    private CharSequence mSubject;
+
+    // Set to true if this message has been discarded.
+    private boolean mDiscarded = false;
+
+    // Track whether we have drafts
+    private volatile boolean mHasMmsDraft;
+    private volatile boolean mHasSmsDraft;
+
+    // Cached value of mms enabled flag
+    private static boolean sMmsEnabled = MmsConfig.getMmsEnabled();
+
+    // Our callback interface
+    private final MessageStatusListener mStatusListener;
+    private List<String> mWorkingRecipients;
+
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not send
+    /// MMS anymore after send several MMS fail . @{
+    private static final String[] MMS_OUTBOX_PROJECTION = {
+        Mms._ID,            // 0
+        Mms.MESSAGE_SIZE,   // 1
+        Mms.STATUS
+    };
+    /// @}
+
+    /// M: Modify @{
+    private static final String FDN_URI = "content://icc/fdn/subId/";
+    private static final String[] FDN_PROJECTION = new String[] {
+        "index",
+        "name",
+        "number"
+    };
+    private static final int FDN_COLUMN_INDEX = 0;
+    private static final int FDN_COLUMN_NAME = 1;
+    private static final int FDN_COLUMN_NUMBER = 2;
+    /// @}
+
+    private static final int MMS_MESSAGE_SIZE_INDEX  = 1;
+
+    /// M:
+    private static final String M_TAG = "Mms/WorkingMessage";
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public static final int ATTACHMENT = 5;
+    public static final int VCARD = 6;
+    /// @}
+    /// M: Code analyze 035, For new feature ALPS00249336,  add vCalendar support . @{
+    public static final int VCALENDAR = 7;
+    /// @}
+
+    /// M: Code analyze 036, For bug ALPS00270539, mms draft edit lock. at any
+    /// time, only one thread can modify a mms draft. here currently use a static
+    /// lock is ok, because WorkingMessage is only one at any time. if the condition
+    /// is changed this must be changed too . @{
+    public static Object sDraftMmsLock = new Object();
+    /// @}
+
+    private long mOldThreadId;
+
+    /// M: Fix CR : ALPS01012417 @{
+    private long mOldSmsSaveThreadId;
+    /// @}
+
+    /// M: Fix CR : ALPS01078057 @{
+    private long mOldMmsSaveThreadId = 0;
+    /// @}
+
+    /// M : FIX CR : ALPS01795853 @{
+    private boolean mIsTurnToChooseAttach;
+    /// @}
+
+    /// M: Fix CR: ALPS01234459 @{
+    private boolean mIsLoadingDraft;
+    /// @}
+
+    // Draft message stuff
+    private static final String[] MMS_DRAFT_PROJECTION = {
+        Mms._ID,                // 0
+        Mms.SUBJECT,            // 1
+        Mms.SUBJECT_CHARSET     // 2
+    };
+
+    private static final int MMS_ID_INDEX         = 0;
+    private static final int MMS_SUBJECT_INDEX    = 1;
+    private static final int MMS_SUBJECT_CS_INDEX = 2;
+
+    /// M: Code analyze 039, For new feature ALPS00233419, Creation mode . @{
+    private static final String CREATION_MODE_RESTRICTED = "RESTRICTED";
+    private static final String CREATION_MODE_WARNING    = "WARNING";
+    private static final String CREATION_MODE_FREE       = "FREE";
+
+    public static final int WARNING_TYPE    = -10;
+    public static final int RESTRICTED_TYPE = -11;
+    public static final int RESTRICTED_RESOLUTION = -12;
+
+    public static int sCreationMode  = 0;
+    /// @}
+
+    //Set resizedto true if the image is
+    private boolean mResizeImage = false;
+
+    /// M: Code analyze 033, For bug ALPS00066201,  to solve it can not
+    /// send MMS anymore after send several MMS fail . @{
+    private static final int MMS_MESSAGE_STATUS_INDEX  = 2;
+    /// @}
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft
+    /// when save Latest Mms message as draft . @{
+    private boolean mNeedDeleteOldMmsDraft;
+    /// @}
+
+    /// M: Code analyze 043, For bug ALPS00117913, Mms Basic Coding Convention Correction . @{
+    private static final String FILE_NOT_FOUND = "File not found.";
+
+    private static final String READ_WRITE_FAILURE = "Read or write file failure.";
+
+    private boolean mIsDeleteDraftWhenLoad = false;
+    /// @}
+
+    /// M: fix bug ALPS00513231, force update threadId @{
+    private boolean mForceUpdateThreadId = false;
+
+    public void setForceUpdateThreadId(boolean update) {
+        mForceUpdateThreadId = update;
+    }
+    /// @}
+
+    private Bundle mBundle;
+
+    public IOpWorkingMessageExt mOpWorkingMessageExt = null;
+
+    /**
+     * Callback interface for communicating important state changes back to
+     * ComposeMessageActivity.
+     */
+    public interface MessageStatusListener {
+        /**
+         * Called when the protocol for sending the message changes from SMS
+         * to MMS, and vice versa.
+         *
+         * @param mms If true, it changed to MMS.  If false, to SMS.
+         */
+        /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+        void onProtocolChanged(boolean mms, boolean needToast);
+        /// @}
+
+        /**
+         * Called when an attachment on the message has changed.
+         */
+        void onAttachmentChanged();
+
+        /**
+         * Called just before the process of sending a message.
+         */
+        void onPreMessageSent();
+
+        /**
+         * Called once the process of sending a message, triggered by
+         * {@link send} has completed. This doesn't mean the send succeeded,
+         * just that it has been dispatched to the network.
+         */
+        void onMessageSent();
+
+        /**
+         * Called if there are too many unsent messages in the queue and we're not allowing
+         * any more Mms's to be sent.
+         */
+        void onMaxPendingMessagesReached();
+
+        /**
+         * Called if there's an attachment error while resizing the images just before sending.
+         */
+        void onAttachmentError(int error);
+
+        /** M:Code analyze 045, For bug ALPS00241360, to solve White screen
+         * appears about 3 seconds when sending MMS. Called just before the
+         * process of sending a mms.
+         */
+        void onPreMmsSent();
+    }
+
+    private WorkingMessage(ComposeMessageActivity activity) {
+        MmsLog.d(TAG, "new WorkingMessage(Composer)");
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = activity;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        this.mInterface = new DraftInterface();
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    /**
+     * Creates a new working message.
+     */
+    public static WorkingMessage createEmpty(ComposeMessageActivity activity) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity);
+        return msg;
+    }
+
+    /**
+     * Create a new WorkingMessage from the specified data URI, which typically
+     * contains an MMS message.
+     */
+    public static WorkingMessage load(ComposeMessageActivity activity, Uri uri) {
+        // If the message is not already in the draft box, move it there.
+        if (!uri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+            PduPersister persister = PduPersister.getPduPersister(activity);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "load: moving %s to drafts" + uri);
+            }
+            try {
+                uri = persister.move(uri, Mms.Draft.CONTENT_URI);
+            } catch (MmsException e) {
+                MmsLog.epi(TAG, "Can't move %s to drafts" + uri);
+                return null;
+            }
+        }
+
+        WorkingMessage msg = new WorkingMessage(activity);
+        /// M: Code analyze 046, For bug ALPS00114670, to solve JE happen
+        /// when tap discard slidehsow . @{
+        msg.setConversation(activity.getConversation());
+        /// @}
+        long threadId = 0;
+        boolean noRecipientes = activity.getConversation().getRecipients().isEmpty();
+        if (!noRecipientes) {
+            threadId = activity.getConversation().ensureThreadId();
+        }
+
+        MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                threadId, uri, activity, null);
+        if (mdd == null) {
+            Log.d(TAG_DRAFT, "[load] load from DraftManager result is null!!");
+            return null;
+        }
+        Log.d(TAG_DRAFT, "[load] boolean result is : " + mdd.getBooleanResult());
+        if (mdd.getBooleanResult()) {
+            msg.mHasMmsDraft = true;
+            msg.mSlideshow = mdd.getSlideshow();
+            msg.mMessageUri = mdd.getMessageUri();
+            msg.syncTextFromSlideshow();
+            msg.correctAttachmentState();
+            MmsLog.dpi(TAG_DRAFT, "[load] message uri : " + msg.mMessageUri);
+            return msg;
+        }
+
+        return null;
+    }
+
+    public void correctAttachmentState() {
+        int slideCount = mSlideshow.size();
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        final int fileAttachCount = mSlideshow.sizeOfFilesAttach();
+        /// @}
+        // If we get an empty slideshow, tear down all MMS
+        // state and discard the unnecessary message Uri.
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        if (0 == fileAttachCount) {
+        /// @}
+            if (slideCount == 0 || isEmptySlide()) {
+                //add for attachment enhance
+                MmsLog.d(TAG, "WorkingMessage CorrectAttachmentState RemoveAttachment");
+                removeAttachment(true);
+            } else if (slideCount > 1) {
+                mAttachmentType = SLIDESHOW;
+            } else {
+                SlideModel slide = mSlideshow.get(0);
+                if (slide.hasImage()) {
+                    mAttachmentType = IMAGE;
+                } else if (slide.hasVideo()) {
+                    mAttachmentType = VIDEO;
+                } else if (slide.hasAudio()) {
+                    mAttachmentType = AUDIO;
+                }
+            }
+        } else { /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            mAttachmentType = ATTACHMENT;
+        }
+        /// @}
+
+        updateState(HAS_ATTACHMENT, hasAttachment(), false);
+    }
+
+//add for attachment enhance
+     private boolean isEmptySlide() {
+        int slideCount = mSlideshow.size();
+
+        if (slideCount == 1) {
+            if (mSlideshow != null) {
+                MmsLog.d(TAG, "mSlideshow != null");
+               if (mSlideshow.get(0) != null) {
+                    //Xlog.e(TAG, "contentType = " + mSlideshow.get(0).get(0).getContentType());
+                    MmsLog.d(TAG, "mAttachmentType = " + mAttachmentType);
+                    //MmsLog.e(TAG, "mSlideshow.get(0).get(0) "+ mSlideshow.get(0).get(0));
+
+                    if (mSlideshow.get(0).get(0) != null && mSlideshow.get(0).size() == 1) {
+                        MmsLog.d(TAG, "mSlideshow.get(0).get(0).size " + mSlideshow.get(0).size());
+                        if (mSlideshow.get(0).get(0).getContentType()
+                                .compareTo(ContentType.TEXT_PLAIN) == 0
+                        && (mAttachmentType == VCARD || mAttachmentType == VCALENDAR ||
+                        mAttachmentType == ATTACHMENT)) {
+                            MmsLog.d(TAG, "isEmptySlide return true");
+                            return true;
+                        }
+                    } else if (mSlideshow.get(0).size() == 0 || mSlideshow.get(0).get(0) == null) {
+                        ///M: Modify for ALPS01253847
+                        return true;
+                    }
+               }
+           }
+        }
+
+        MmsLog.d(TAG, "isEmptySlide return false");
+        return false;
+    }
+
+    /**
+     * Load the draft message for the specified conversation, or a new empty message if
+     * none exists.
+     */
+    public static WorkingMessage loadDraft(final ComposeMessageActivity activity,
+                                           final Conversation conv,
+                                           final Runnable onDraftLoaded) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "loadDraft " + conv);
+        }
+
+        final WorkingMessage msg = createEmpty(activity);
+        /// M: Code analyze 037, For bug ALPS00291328,  save conversation to avoid JE . @{
+        msg.setConversation(conv);
+        /// @}
+        if (conv.getThreadId() <= 0) {
+            if (onDraftLoaded != null) {
+                onDraftLoaded.run();
+            }
+            return msg;
+        }
+
+        final long threadId = conv.getThreadId();
+        msg.mOldThreadId = threadId;
+
+        /// M: modify for fix alps01194967  && alps01208583 &&
+        /// alps01224306, load sms draft in backGround. @{
+        new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                MmsLog.dpi(TAG_DRAFT, "[loadDraft] draftText : " + draftText);
+                if (TextUtils.isEmpty(draftText)) {
+                    msg.mInterface.loadRunnable = onDraftLoaded;
+                    /// M: Fix CR : ALPS01234459, while loading draft, can't set text @{
+                    msg.mIsLoadingDraft = true;
+                    /// @}
+                    DraftManager.getInstance().loadDraft(DraftManager.ASYNC_LOAD_ACTION,
+                            threadId, null, activity, msg.mInterface);
+                } else {
+                    msg.mHasSmsDraft = true;
+                    if (onDraftLoaded != null && activity != null) {
+                        activity.runOnUiThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                msg.setText(draftText);
+                                onDraftLoaded.run();
+                            }
+                        });
+                    }
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+        /// @}
+        return msg;
+    }
+
+    private DraftInterface mInterface;
+
+    private class DraftInterface implements IDraftInterface {
+        private Handler mHanlder;
+        DraftInterface() {
+            mHanlder = new Handler();
+        }
+
+        public Runnable loadRunnable;
+
+        public void loadFinished(MmsDraftData mdd) {
+            if (mdd != null) {
+                MmsLog.dpi(TAG_DRAFT, "[loadFinished] enter, and uri : "
+                        + mdd.getMessageUri() + ", subject : " + mdd.getSubject());
+
+                String subject = mdd.getSubject();
+                if (subject != null && subject.length() != 0) {
+                    mHasMmsDraft = true;
+                    setSubject(subject, false);
+                }
+
+                mOpWorkingMessageExt.opLoadFinished(mdd.mIOpMmsDraftDataExt);
+
+                Log.d(TAG_DRAFT, "[loadFinished] boolean result : " + mdd.getBooleanResult());
+                if (mdd.getBooleanResult()) {
+                    mHasMmsDraft = true;
+                    SlideshowModel slideshow = mdd.getSlideshow();
+                    mMessageUri = mdd.getMessageUri();
+
+                    mSlideshow = slideshow;
+                    syncTextFromSlideshow();
+                    correctAttachmentState();
+                    if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+                        Log.d(TAG_DRAFT, "[loadFinished] defualt sms, do delete mms draft");
+                        if (getSlideshow() != null && getSlideshow().size() == 1
+                                && !getSlideshow().get(0).hasAudio()
+                                && !getSlideshow().get(0).hasImage()
+                                && !getSlideshow().get(0).hasVideo()
+                                && getSlideshow().sizeOfFilesAttach() == 0
+                                && TextUtils.isEmpty(subject)
+                                && TextUtils.isEmpty(getText())) {
+                            Log.d(TAG_DRAFT, "[loadFinished] delete");
+                            asyncDeleteDraftMmsMessage(mConversation);
+                            removeAllFileAttaches();
+                            removeAttachment(false);
+                            setSubject(subject, false);
+                            if (mConversation.getMessageCount() <= 0) {
+                                mConversation.clearThreadId();
+                            }
+                        }
+                    }
+                }
+            }
+            /// M Fix CR : ALPS01234459 @{
+            mIsLoadingDraft = false;
+            /// M @}
+            if (loadRunnable != null) {
+                mHanlder.post(loadRunnable);
+            }
+            /// M Fix CR : ALPS01071659 @{
+            deleteGruoupMmsDraft();
+            /// @}
+        }
+
+        public void updateAfterSaveDraftFinished(final Uri msgUri,
+                final int create, final boolean result) {
+            MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] msgUri is : " + msgUri
+                   + ", create : " + create);
+            // use a thread to enhance the quit compose performance which can quit to
+            // conversation list quickly
+            try {
+                if (msgUri == null && create == 1 && !result) {
+                    Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + " MmsException happened, and save failed!");
+                    removeAllFileAttaches();
+                    removeAttachment(true);
+                    mActivity.runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            // TODO Auto-generated method stub
+                            MessageUtils.showErrorDialog(mActivity,
+                                    android.R.string.dialog_alert_title,
+                                    R.string.error_add_attachment, 0, R.string.type_common_file);
+                        }
+                    });
+                    return;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] before msg uri : "
+                                                   + mMessageUri);
+                if (msgUri != null) {
+                    mMessageUri = msgUri;
+                }
+                MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished] after msg uri : "
+                                                   + mMessageUri);
+
+                // / which if the save req is create, quit compose and mms maybe
+                // be killed
+                // / so store the uri into bundle, and start MMs again, which
+                // can load from preference.xml @{
+                if (mMessageUri != null && mBundle != null && create == 1) {
+                    // /M: fix bug: ALPS00568220,
+                    // /M: save message Uri in preference, some times MMS
+                    // will be killed by system
+                    SharedPreferences sp = PreferenceManager
+                            .getDefaultSharedPreferences(mActivity);
+                    SharedPreferences.Editor editor = sp.edit();
+                    editor.putString(SAVE_MSG_URI_KEY, mMessageUri.toString());
+                    MmsLog.dpi(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                            + "save message uri to preference : " + mMessageUri.toString());
+                    editor.apply();
+                }
+                // / @}
+                if (mMessageUri != null) {
+                    if (!mConversation.getRecipients().isEmpty()) {
+                        mConversation.ensureThreadId();
+                        if (mBundle != null) {
+                            SharedPreferences sp1 =
+                                PreferenceManager.getDefaultSharedPreferences(mActivity);
+                            SharedPreferences.Editor editor1 = sp1.edit();
+                            Log.d(TAG_DRAFT, "[updateAfterSaveDraftFinished]"
+                                    + "save thread id to preference : "
+                                    + mConversation.getThreadId());
+                            editor1.putLong(SAVE_MSG_THREADID_KEY, mConversation.getThreadId());
+                            editor1.apply();
+                        }
+                    }
+                    mConversation.setDraftState(true);
+                } else {
+                    mConversation.setDraftState(false);
+                }
+                // / @}
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "updateAfterSaveDraftFinished conv: "
+                            + mConversation + " uri: " + mMessageUri);
+                }
+
+                // / @}
+
+                // Be paranoid and delete any SMS drafts that might be lying
+                // around. Must do
+                // this after ensureThreadId so conv has the correct thread
+                // id.
+                asyncDeleteDraftSmsMessage(mConversation);
+
+                /// M : Fix CR : ALPS01031682
+                /// press home key, will saveDraft(Sms), and after change the recipients saveMms
+                /// the draft will update to the old thread @{
+                if (mOldSmsSaveThreadId > 0) {
+                    if (mOldSmsSaveThreadId != mConversation.getThreadId()) {
+                        deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                        ///M: add for fix issue ALPS01078057. when delete the saved sms
+                        /// should update the old thread's draft state to false.
+                        DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+                    }
+                }
+                /// M Fix CR: ALPS01105564 two draft will show in the conversation list
+                /// because the sound recorder will finish itself, when lock the screnn.
+                /// under this situtation, will send 2 save req to draftmanager,
+                /// meanwhile the mMessageUri is null
+                /// which will create 2 pdu id in the DB and bind to the origin thread .
+                /// after change the recipients, the thread will not be deleted,
+                /// so 2 threads showed in the conversationlist @{
+                deleteOldMmsDraft(mMessageUri, mConversation.getThreadId());
+                /// @}
+
+                /// M: Fix CR : ALPS01078057. when the thread changed,
+                /// if the old thread saved Mms draft before,
+                /// should reset the old thread's draft state @{
+                if (mOldMmsSaveThreadId != 0
+                        && mOldMmsSaveThreadId != mConversation.getThreadId()) {
+                    asyncDeleteOldMmsDraft(mOldMmsSaveThreadId);
+                    DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+                }
+                mOldMmsSaveThreadId = mConversation.getThreadId();
+                /// @}
+
+                // / M: Code analyze 042, For bug ALPS00117913, Delete old
+                // Mms draft when save Latest
+                // / Mms message as draft . @{
+                if (mNeedDeleteOldMmsDraft) {
+                    mNeedDeleteOldMmsDraft = false;
+                    asyncDeleteOldMmsDraft(mConversation.getThreadId());
+                }
+            } finally {
+                Log.d(TAG, "updateAfterSaveDraftFinished setSavingDraft(false)");
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+        }
+    }
+
+    /**
+     * Sets the text of the message to the specified CharSequence.
+     */
+    public void setText(CharSequence s) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setText: s = " + s);
+        }
+        /// M Fix CR : ALPS01234459, while loading draft, no need to set text @{
+        if (mIsLoadingDraft) {
+            Log.d(TAG, "[setText] run loading draft, do not need to set text");
+            return;
+        }
+        /// M @}
+        mText = s;
+        /// M: @{
+        if (mText != null && TextUtils.getTrimmedLength(mText) >= 0) {
+            syncTextToSlideshow();
+        }
+        if (mText == null || mText.length() == 0) {
+            /// M: fix bug ALPS00945813, remove MmsDraft when Length_Mms_Text are deleted
+            if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                asyncDeleteDraftMmsMessage(mConversation);
+                clearConversation(mConversation, true);
+            }
+            /// @}
+            /// M Fix CR ALPS01141440, which still has mms draft after forward message @{
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == LENGTH_REQUIRES_MMS && !hasSubject()
+                    && !hasMediaAttachments() && !hasAttachedFiles()) {
+                    asyncDelete(mMessageUri, null, null);
+                    clearConversation(mConversation, true);
+                    mMessageUri = null;
+                }
+            }
+            /// @}
+        }
+
+    }
+
+    /**
+     * Returns the current message text.
+     */
+    public CharSequence getText() {
+        return mText;
+    }
+
+    /**
+     * @return True if the message has any text. A message with just whitespace is not considered
+     * to have text.
+     */
+    public boolean hasText() {
+        /*
+        if (requiresMms()) {
+            return mText != null && TextUtils.getTrimmedLength(mText) > 0;
+        } else {
+            return mText != null && !TextUtils.isEmpty(mText);
+        }
+        */
+        return true;
+    }
+
+    public void removeAttachment(boolean notify) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT,
+                    "[removeAttachment] not default sms, can't remove attachment,just return!!");
+            return;
+        }
+        MmsLog.d(TAG, "WorkingMessage RemoveAttachment");
+        removeThumbnailsFromCache(mSlideshow);
+        /// M: fix bug ALPS00956551, need clear mText when add attachment twice
+        if (hasSlideshow()) {
+            mText = "";
+        }
+        mAttachmentType = TEXT;
+        /// M: fix bug ALPS02141556 @{
+        synchronized (this) {
+            mSlideshow = null;
+        }
+        /// @}
+        if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+        // mark this message as no longer having an attachment
+        updateState(HAS_ATTACHMENT, false, notify);
+        if (notify) {
+            // Tell ComposeMessageActivity (or other listener) that the attachment has changed.
+            // In the case of ComposeMessageActivity, it will remove its attachment panel because
+            // this working message no longer has an attachment.
+            mStatusListener.onAttachmentChanged();
+        }
+
+        clearConversation(mConversation, true);
+    }
+
+    public static void removeThumbnailsFromCache(SlideshowModel slideshow) {
+        if (slideshow != null) {
+            ThumbnailManager thumbnailManager = MmsApp.getApplication().getThumbnailManager();
+            boolean removedSomething = false;
+            Iterator<SlideModel> iterator = slideshow.iterator();
+            while (iterator.hasNext()) {
+                SlideModel slideModel = iterator.next();
+                if (slideModel.hasImage()) {
+                    /// M: change thumbnail's uri @{
+                    ImageModel im = slideModel.getImage();
+                    Uri uri = ThumbnailManager.getThumbnailUri(im);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                } else if (slideModel.hasVideo()) {
+                    /// M: change thumbnail's uri @{
+                    VideoModel vm = slideModel.getVideo();
+                    Uri uri = ThumbnailManager.getThumbnailUri(vm);
+                    thumbnailManager.removeThumbnail(uri);
+                    /// @}
+                    removedSomething = true;
+                }
+            }
+            if (removedSomething) {
+                // HACK: the keys to the thumbnail cache are the part uris, such as mms/part/3
+                // Because the part table doesn't have auto-increment ids, the part ids are reused
+                // when a message or thread is deleted. For now, we're clearing the whole thumbnail
+                // cache so we don't retrieve stale images when part ids are reused. This will be
+                // fixed in the next release in the mms provider.
+                MmsApp.getApplication().getThumbnailManager().clearBackingStore();
+            }
+        }
+    }
+
+    /**
+     * Adds an attachment to the message, replacing an old one if it existed.
+     * @param type Type of this attachment, such as {@link IMAGE}
+     * @param dataUri Uri containing the attachment data (or null for {@link TEXT})
+     * @param append true if we should add the attachment to a new slide
+     * @return An error code such as {@link UNKNOWN_ERROR} or {@link OK} if successful
+     */
+    public int setAttachment(int type, Uri dataUri, boolean append) {
+        MmsLog.dpi(TAG, "setAttachment type = " + type + " uri = " + dataUri);
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "setAttachment type= " + type + "uri " + dataUri);
+        }
+        int result = OK;
+        SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+
+        // Special case for deleting a slideshow. When ComposeMessageActivity gets told to
+        // remove an attachment (search for AttachmentEditor.MSG_REMOVE_ATTACHMENT), it calls
+        // this function setAttachment with a type of TEXT and a null uri. Basically, it's turning
+        // the working message from an MMS back to a simple SMS. The various attachment types
+        // use slide[0] as a special case. The call to ensureSlideshow below makes sure there's
+        // a slide zero. In the case of an already attached slideshow, ensureSlideshow will do
+        // nothing and the slideshow will remain so that if a user adds a slideshow again, they'll
+        // see their old slideshow they previously deleted. Here we really delete the slideshow.
+        if (type == TEXT && mAttachmentType == SLIDESHOW && mSlideshow != null && dataUri == null
+                && !append) {
+            slideShowEditor.removeAllSlides();
+        }
+
+        /// M: This is added for failed to share only one picture with message. @{
+        if (mSlideshow == null) {
+            append = true;
+        }
+        /// @}
+
+        // Make sure mSlideshow is set up and has a slide.
+        ensureSlideshow();      // mSlideshow can be null before this call, won't be afterwards
+        slideShowEditor.setSlideshow(mSlideshow);
+
+        // Change the attachment and translate the various underlying
+        // exceptions into useful error codes.
+        try {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (type >= ATTACHMENT) {
+                if (mSlideshow == null) {
+                    mSlideshow = SlideshowModel.createNew(mActivity);
+                }
+                new FileAttachmentUtils().setOrAppendFileAttachment(
+                        mActivity, mSlideshow, mText, type, dataUri, append);
+            } else { /// @}
+                if (append) {
+                    appendMedia(type, dataUri);
+                } else {
+                    changeMedia(type, dataUri);
+                }
+            }
+            /// @}
+        } catch (MmsException e) {
+            /// M:
+            MmsLog.e(TAG, e.getMessage() != null ? e.getMessage() : "setAttachment MmsException");
+            result = UNKNOWN_ERROR;
+        } catch (UnsupportContentTypeException e) {
+            /// M: fix bug ALPS604911, modify toast msg
+            result = UNSUPPORTED_TYPE;
+        } catch (ExceedMessageSizeException e) {
+            result = MESSAGE_SIZE_EXCEEDED;
+        } catch (ResolutionException e) {
+            result = IMAGE_TOO_LARGE;
+        /// M: @{
+        } catch (ContentRestrictionException e) {
+            result = sCreationMode;
+        } catch (RestrictedResolutionException e) {
+            result = RESTRICTED_RESOLUTION;
+        } catch (IllegalStateException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (IllegalArgumentException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        } catch (SecurityException e) {
+            MmsLog.e(TAG, e.getMessage());
+            result = UNKNOWN_ERROR;
+        }
+        /// @}
+
+        MmsLog.d(TAG, "setAttachment result = " + result);
+
+        // If we were successful, update mAttachmentType and notify
+        // the listener than there was a change.
+        if (result == OK) {
+            mAttachmentType = type;
+            /// M: @{
+            if (mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+            if (mSlideshow.size() > 1) {
+                mAttachmentType = SLIDESHOW;
+            }
+            /// @}
+        } else if (append) {
+            // We added a new slide and what we attempted to insert on the slide failed.
+            // Delete that slide, otherwise we could end up with a bunch of blank slides.
+//            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            /// M: @{
+            if (slideShowEditor == null || mSlideshow == null) {
+                return UNKNOWN_ERROR;
+            }
+             /// @}
+
+            /// M: Modify ALPS00566470 @{
+            if (!mOpWorkingMessageExt.setAttachment(type, ATTACHMENT,
+                    slideShowEditor)) {
+                slideShowEditor.removeSlide(mSlideshow.size() - 1);
+            }
+        }
+
+        // correctAttachmentState();
+        mIsUpdateAttachEditor = true;
+
+        if (mSlideshow != null && type == IMAGE) {
+            // Prime the image's cache; helps A LOT when the image is coming from the network
+            // (e.g. Picasa album). See b/5445690.
+            int numSlides = mSlideshow.size();
+            if (numSlides > 0) {
+                ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+                if (imgModel != null) {
+                    cancelThumbnailLoading();
+                    imgModel.loadThumbnailBitmap(null);
+                }
+            }
+        }
+        mStatusListener.onAttachmentChanged();  // have to call whether succeeded or failed,
+                                                // because a replace that fails, removes the slide
+
+        if (!MmsConfig.getMultipartSmsEnabled()) {
+            if (!append && mAttachmentType == TEXT && type == TEXT) {
+                int[] params = SmsMessage.calculateLength(getText(), false);
+                /* SmsMessage.calculateLength returns an int[4] with:
+                *   int[0] being the number of SMS's required,
+                *   int[1] the number of code units used,
+                *   int[2] is the number of code units remaining until the next message.
+                *   int[3] is the encoding type that should be used for the message.
+                */
+                int msgCount = params[0];
+                /** M; change 4.1 google default
+                // if (msgCount > 1) {
+                //    // The provider doesn't support multi-part sms's so as soon as the user types
+                //    // an sms longer than one segment, we have to turn the message into an mms.
+                 */
+                if (msgCount >= MmsConfig.getSmsToMmsTextThreshold()) {
+                    setLengthRequiresMms(true, false);
+                } else {
+                    updateState(HAS_ATTACHMENT, hasAttachment(), true);
+                }
+            } else {
+                updateState(HAS_ATTACHMENT, hasAttachment(), true);
+            }
+        } else {
+            // Set HAS_ATTACHMENT if we need it.
+            updateState(HAS_ATTACHMENT, hasAttachment(), true);
+        }
+        correctAttachmentState();
+        if (type != IMAGE && mActivity instanceof ComposeMessageActivity) {
+            ((ComposeMessageActivity) mActivity).setWaitingAttachment(false);
+        }
+        return result;
+    }
+
+    /**
+     * Returns true if this message contains anything worth saving.
+     */
+    public boolean isWorthSaving() {
+        /// M:
+        MmsLog.d(M_TAG, "isWorthSaving(): hasText()="
+                + hasText() + ", hasSubject()=" + hasSubject()
+                + ", hasAttachment()=" + hasAttachment() + ", hasSlideshow()=" + hasSlideshow());
+        // If it actually contains anything, it's of course not empty.
+        if (!TextUtils.isEmpty(mText) || hasSubject() || hasAttachment() || hasSlideshow()) {
+            return true;
+        }
+        // When saveAsMms() has been called, we set FORCE_MMS to represent
+        // sort of an "invisible attachment" so that the message isn't thrown
+        // away when we are shipping it off to other activities.
+        if (isFakeMmsForDraft()) {
+            return true;
+        }
+        return false;
+    }
+
+    private void cancelThumbnailLoading() {
+        int numSlides = mSlideshow != null ? mSlideshow.size() : 0;
+        if (numSlides > 0) {
+            ImageModel imgModel = mSlideshow.get(numSlides - 1).getImage();
+            if (imgModel != null) {
+                imgModel.cancelThumbnailLoading();
+            }
+        }
+    }
+
+    /**
+     * Returns true if FORCE_MMS is set.
+     * When saveAsMms() has been called, we set FORCE_MMS to represent
+     * sort of an "invisible attachment" so that the message isn't thrown
+     * away when we are shipping it off to other activities.
+     */
+    public boolean isFakeMmsForDraft() {
+        return (mMmsState & FORCE_MMS) > 0;
+    }
+
+    /**
+     * Makes sure mSlideshow is set up.
+     */
+    private void ensureSlideshow() {
+        if (mSlideshow != null) {
+            /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+            if (mSlideshow.size() > 0) {
+                return;
+            } else {
+                ///M: Modify for ALPS01250908
+                try {
+                    mSlideshow.add(new SlideModel(mSlideshow));
+                } catch (ContentRestrictionException e) {
+                    Log.e(TAG, "throw a ContentRestrictionException in ensureSlideshow");
+                }
+                return;
+            }
+            /// @}
+        }
+
+        SlideshowModel slideshow = SlideshowModel.createNew(mActivity);
+        SlideModel slide = new SlideModel(slideshow);
+        slideshow.add(slide);
+
+        mSlideshow = slideshow;
+    }
+
+    /**
+     * Change the message's attachment to the data in the specified Uri.
+     * Used only for single-slide ("attachment mode") messages.
+     */
+    private void changeMedia(int type, Uri uri) throws MmsException {
+        SlideModel slide = mSlideshow.get(0);
+
+        MediaModel media;
+        Uri uriTemp = null;
+        if (slide == null) {
+            Log.w(LogTag.TAG, "[WorkingMessage] changeMedia: no slides!");
+            return;
+        }
+
+        /// M: add for attachment enhance @{
+        /// M: If we're changing to text, just bail out. @{
+        if (type == TEXT) {
+            if (mSlideshow != null && mSlideshow.size() > 0) {
+                /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support. @{
+                if (mOpWorkingMessageExt.removeAllAttachFiles()) {
+                    mSlideshow.removeAllAttachFiles();
+                }
+                mSlideshow.clear();
+                mSlideshow = null;
+                ensureSlideshow();
+                if (isResizeImage()) {
+                    // Delete our MMS message, if there is one.
+                    if (mMessageUri != null) {
+                        asyncDelete(mMessageUri, null, null);
+                        setResizeImage(false);
+                    }
+                }
+            }
+            return;
+        }
+        /// M: get thumbnail uri @{
+        if (slide.hasImage()) {
+            ImageModel imageModel = slide.getImage();
+            uriTemp = Uri.parse(imageModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + imageModel.getSrc());
+        } else if (slide.hasVideo()) {
+            VideoModel videoModel = slide.getVideo();
+            uriTemp = Uri.parse(videoModel.getUri().toString() + ThumbnailManager.FLAG_FNAME
+                + videoModel.getSrc());
+        }
+        /// @}
+
+        // Make a correct MediaModel for the type of attachment.
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+        /// M: Code analyze 041, For new feature , add drm support . @{
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        int increaseSize = media.getMediaPackagedSize()
+                + MmsSizeUtils.getSlideshowReserveSize()
+                - mSlideshow.getCurrentSlideshowSize();
+        // OP01
+        increaseSize = mOpWorkingMessageExt.changeMedia(increaseSize,
+                mSlideshow.getAttachFilesPackagedSize());
+        if (increaseSize > 0) {
+            mSlideshow.checkMessageSize(increaseSize);
+        }
+
+        // Remove any previous attachments.
+        removeSlideAttachments(slide);
+
+        slide.add(media);
+
+        if (uriTemp != null) {
+            MmsApp.getApplication().getThumbnailManager().removeThumbnail(uriTemp);
+        }
+        /// @}
+        // For video and audio, set the duration of the slide to that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Add the message's attachment to the data in the specified Uri to a new slide.
+     */
+    private void appendMedia(int type, Uri uri) throws MmsException {
+
+        // If we're changing to text, just bail out.
+        if (type == TEXT) {
+            return;
+        }
+
+        // The first time this method is called, mSlideshow.size() is going to be
+        // one (a newly initialized slideshow has one empty slide). The first time we
+        // attach the picture/video to that first empty slide. From then on when this
+        // function is called, we've got to create a new slide and add the picture/video
+        // to that new slide.
+        boolean addNewSlide = true;
+        if (mSlideshow.size() == 1 && !mSlideshow.isSimple()) {
+            addNewSlide = false;
+        }
+        if (mSlideshow.size() == 1 && mSlideshow.get(0) != null
+                && mSlideshow.get(0).hasAudio() && mSlideshow.get(0).hasImage()) {
+            addNewSlide = true;
+        }
+        if (addNewSlide) {
+            SlideshowEditor slideShowEditor = new SlideshowEditor(mActivity, mSlideshow);
+            if (!slideShowEditor.addNewSlide()) {
+                return;
+            }
+        }
+        mIsUpdateAttachEditor = false;
+        // Make a correct MediaModel for the type of attachment.
+        MediaModel media;
+        SlideModel slide = mSlideshow.get(mSlideshow.size() - 1);
+        if (type == IMAGE) {
+            media = new ImageModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.IMAGE);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == VIDEO) {
+            media = new VideoModel(mActivity, uri, mSlideshow.getLayout().getImageRegion());
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.VIDEO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else if (type == AUDIO) {
+            media = new AudioModel(mActivity, uri);
+
+            String[] fileNames = mSlideshow.getAllMediaNames(MediaType.AUDIO);
+            media.setSrc(MessageUtils.getUniqueName(fileNames, media.getSrc()));
+        } else {
+            throw new IllegalArgumentException("changeMedia type=" + type + ", uri=" + uri);
+        }
+
+        if (media.getMediaPackagedSize() < 0) {
+            throw new ExceedMessageSizeException("Exceed message size limitation");
+        }
+
+        slide.add(media);
+
+        /// M: for vcard, since we append a media, remove vCard
+        removeAllFileAttaches();
+
+        // For video and audio, set the duration of the slide to
+        // that of the attachment.
+        if (type == VIDEO || type == AUDIO) {
+            slide.updateDuration(media.getDuration());
+        }
+    }
+
+    /**
+     * Returns true if the message has an attachment (including slideshows).
+     */
+    public boolean hasAttachment() {
+        return (mAttachmentType > TEXT);
+    }
+
+    /**
+     * Returns the slideshow associated with this message.
+     */
+    public SlideshowModel getSlideshow() {
+        return mSlideshow;
+    }
+
+    /**
+     * Returns true if the message has a real slideshow, as opposed to just
+     * one image attachment, for example.
+     */
+    public boolean hasSlideshow() {
+        /// M: Code analyze 034, For new feature ALPS00231349,  add vCard support . @{
+        return (mSlideshow != null && mSlideshow.size() > 1);
+        /// @}
+    }
+
+    /**
+     * Sets the MMS subject of the message.  Passing null indicates that there
+     * is no subject.  Passing "" will result in an empty subject being added
+     * to the message, possibly triggering a conversion to MMS.  This extra
+     * bit of state is needed to support ComposeMessageActivity converting to
+     * MMS when the user adds a subject.  An empty subject will be removed
+     * before saving to disk or sending, however.
+     */
+    public void setSubject(CharSequence s, boolean notify) {
+        /// M: @{
+        boolean flag = ((s != null) && TextUtils.getTrimmedLength(s) > 0);
+        mSubject = s;
+        if (flag) {
+            updateState(HAS_SUBJECT, flag, notify);
+        } else {
+            updateState(HAS_SUBJECT, flag, notify);
+        }
+        /// @}
+        /// M Fix CR ALPS01141440 @{
+        if (mSubject == null || mSubject.length() == 0) {
+            if ((mActivity instanceof ComposeMessageActivity)
+                    && ((ComposeMessageActivity) mActivity).getForwordingState()) {
+                if (mMmsState == 0) {
+                    asyncDelete(mMessageUri, null, null);
+                    if (mConversation != null) {
+                        clearConversation(mConversation, true);
+                    }
+                    mMessageUri = null;
+                }
+            }
+        }
+       /// @}
+    }
+
+    /**
+     * Returns the MMS subject of the message.
+     */
+    public CharSequence getSubject() {
+        return mSubject;
+    }
+
+    /**
+     * Returns true if this message has an MMS subject. A subject has to be more than just
+     * whitespace.
+     * @return
+     */
+    public boolean hasSubject() {
+        return mSubject != null && TextUtils.getTrimmedLength(mSubject) > 0;
+    }
+
+    /**
+     * Moves the message text into the slideshow.  Should be called any time
+     * the message is about to be sent or written to disk.
+     */
+    private synchronized void syncTextToSlideshow() {
+        /// M: Because progress run async, so get the value first.
+        boolean waitingAttachment = false;
+        if (mActivity instanceof ComposeMessageActivity) {
+            waitingAttachment = ((ComposeMessageActivity) mActivity).isWaitingAttachment();
+        }
+
+        /// M: fix bug ALPS01365426, must calculate mIsExceedSize
+        if (mSlideshow != null && !TextUtils.isEmpty(mText)
+                && TextUtils.getTrimmedLength(mText) >= 0) {
+            int currentSize = getCurrentMessageSize();
+            if (currentSize > MmsConfig.getUserSetMmsSizeLimit(true) && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+        }
+        /// @}
+
+        if (mSlideshow == null || mSlideshow.size() != 1)
+            return;
+        try {
+            SlideModel slide = mSlideshow.get(0);
+            TextModel text;
+            /// M: change google default. @{
+            TextModel oldText = null;
+            if (slide != null) {
+                oldText = slide.getText();
+            }
+            /// M: fix bug ALPS01013522, workaround avoiding mSlideshow NPE
+            MmsLog.d(TAG, "syncTextToSlideshow() mSlideshow = "
+                    + String.valueOf(mSlideshow == null));
+            // Add a TextModel to slide 0 if one doesn't already exist
+            text = new TextModel(mActivity, ContentType.TEXT_PLAIN, "text_0.txt",
+                    mSlideshow != null ? mSlideshow.getLayout().getTextRegion()
+                                   : SlideshowModel.createNew(mActivity)
+                                           .getLayout().getTextRegion(),
+                    (!TextUtils.isEmpty(mText) &&
+                            TextUtils.getTrimmedLength(mText) >= 0)
+                                    ? (mText.toString()).getBytes() : null);
+
+            //klocwork issue pid:18444
+            if (slide != null) {
+                int oldLength = (oldText != null && oldText.getText() != null)
+                                ? oldText.getText().getBytes().length : 0;
+                int newLength = mText != null ? mText.toString().getBytes().length : 0;
+                if (newLength - oldLength > 0) {
+                    if (getCurrentMessageSize() + (newLength - oldLength)
+                                > MmsConfig.getUserSetMmsSizeLimit(true)) {
+                        throw new ExceedMessageSizeException();
+                    }
+                }
+                slide.add(text);
+            }
+        } catch (ExceedMessageSizeException e) {
+            if (!TextUtils.isEmpty(mText) && TextUtils.getTrimmedLength(mText) >= 0
+                    && !waitingAttachment) {
+                mIsExceedSize = true;
+            }
+            return;
+        } catch (ArrayIndexOutOfBoundsException e) {
+            /// M: fix bug ALPS01659457
+            Log.e(TAG, "syncTextToSlideshow ArrayIndexOutOfBoundsException");
+            return;
+        }
+        /// @}
+    }
+
+    /**
+     * Sets the message text out of the slideshow.  Should be called any time
+     * a slideshow is loaded from disk.
+     */
+    private void syncTextFromSlideshow() {
+        // Don't sync text for real slideshows.
+        if (mSlideshow.size() != 1) {
+            return;
+        }
+
+        SlideModel slide = mSlideshow.get(0);
+        if (slide == null || !slide.hasText()) {
+            return;
+        }
+
+        mText = slide.getText().getText();
+    }
+
+    /**
+     * Removes the subject if it is empty, possibly converting back to SMS.
+     */
+    private void removeSubjectIfEmpty(boolean notify) {
+        if (!hasSubject()) {
+            setSubject(null, notify);
+        }
+    }
+
+    /**
+     * Gets internal message state ready for storage.  Should be called any
+     * time the message is about to be sent or written to disk.
+     */
+    private void prepareForSave(boolean notify) {
+        // Make sure our working set of recipients is resolved
+        // to first-class Contact objects before we save.
+        syncWorkingRecipients();
+
+        if (requiresMms()) {
+            ensureSlideshow();
+            syncTextToSlideshow();
+            /// M:
+            removeSubjectIfEmpty(notify);
+        }
+    }
+
+    /**
+     * Resolve the temporary working set of recipients to a ContactList.
+     */
+    public void syncWorkingRecipients() {
+        if (mWorkingRecipients != null) {
+            ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+            mConversation.setRecipients(recipients);    // resets the threadId to zero
+            /// M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(recipients.size() > 1, true);
+            mWorkingRecipients = null;
+        }
+    }
+
+    public void updateStateForGroupMmsChanged() {
+        ContactList recipients = mConversation.getRecipients();
+        setHasMultipleRecipients(recipients.size() > 1, false);
+    }
+
+    public String getWorkingRecipients() {
+        // this function is used for DEBUG only
+        if (mWorkingRecipients == null) {
+            return null;
+        }
+        ContactList recipients = ContactList.getByNumbers(mWorkingRecipients, false);
+        return recipients.serialize();
+    }
+
+    // Call when we've returned from adding an attachment. We're no longer forcing the message
+    // into a Mms message. At this point we either have the goods to make the message a Mms
+    // or we don't. No longer fake it.
+    public void removeFakeMmsForDraft() {
+        updateState(FORCE_MMS, false, false);
+    }
+
+    /**
+     * Force the message to be saved as MMS and return the Uri of the message.
+     * Typically used when handing a message off to another activity.
+     */
+    /// M: add synchronized.
+    public synchronized Uri saveAsMms(boolean notify) {
+        if (DEBUG) LogTag.debug("saveAsMms mConversation=%s", mConversation);
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveAsMms] Non-default sms, cann't save,just return!!");
+            return mMessageUri;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG, "saveAsMms mDiscarded: true mConversation: " + mConversation +
+                    " returning NULL uri and bailing");
+            return null;
+        }
+
+        // FORCE_MMS behaves as sort of an "invisible attachment", making
+        // the message seem non-empty (and thus not discarded).  This bit
+        // is sticky until the last other MMS bit is removed, at which
+        // point the message will fall back to SMS.
+        updateState(FORCE_MMS, true, notify);
+
+        // Collect our state to be written to disk.
+        prepareForSave(true /* notify */);
+
+        try {
+            // Make sure we are saving to the correct thread ID.
+            DraftCache.getInstance().setSavingDraft(true);
+            if (!mConversation.getRecipients().isEmpty()) {
+                mConversation.ensureThreadId();
+            }
+            mConversation.setDraftState(true);
+
+            //PduPersister persister = PduPersister.getPduPersister(mActivity);
+            SendReq sendReq = makeSendReq(mConversation, mSubject);
+
+            sendReq = mOpWorkingMessageExt.opSaveAsMms(sendReq);
+
+            long threadId = mConversation.getThreadId();
+
+            Log.d(TAG_DRAFT, "[saveAsMms] threadId : " + threadId);
+
+            MmsDraftData mdd =
+                DraftManager.getInstance().saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mMessageUri, mSlideshow, sendReq, mActivity, null);
+            if (mdd != null) {
+//                if (mMessageUri == null) {
+                    mMessageUri = mdd.getMessageUri();
+                    if (mdd.getCreateOrUpdate() == 1) {
+                        if (mMessageUri == null && !mdd.getBooleanResult()) {
+                            Log.d(TAG_DRAFT, "[saveAsMms] MmsException happened,and save failed!");
+                            removeAllFileAttaches();
+                            removeAttachment(true);
+                            mActivity.runOnUiThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    // TODO Auto-generated method stub
+                                    MessageUtils.showErrorDialog(mActivity,
+                                                    android.R.string.dialog_alert_title,
+                                                    R.string.error_add_attachment, 0,
+                                                    R.string.type_common_file);
+                                }
+                            });
+                        }
+                    }
+                    MmsLog.dpi(TAG_DRAFT,
+                            "[saveAsMms] call draft manager return , and mMessageUri : "
+                            + mMessageUri);
+                    asyncDeleteDraftSmsMessage(mConversation);
+//                }
+            }
+
+            /// M: google jb.mr1 patch
+            // If we don't already have a Uri lying around, make a new one.  If we do
+            // have one already, make sure it is synced to disk.
+
+            mHasMmsDraft = true;
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+        return mMessageUri;
+    }
+
+    /// M : FIX CR : ALPS01795853
+    /// While exist A MMS draft, then create a new composer, input A phone number
+    /// and input some text, then add image from gallery, this will cause delete the
+    /// MMS draft whcih saved before
+    ///
+    /// Root cause : while enter the document UI, composer will enter the onStop,
+    ///              which will save the sms draft that the content is inputted text
+    ///              after save finished, will delete the MMS draft @{
+    public void setTruntoChooseAttach(boolean chooseOrNot) {
+        Log.d(TAG_DRAFT, "[setTruntoChooseAttach] set to be : " + chooseOrNot);
+        mIsTurnToChooseAttach = chooseOrNot;
+    }
+    /// @}
+
+    /**
+     * Save this message as a draft in the conversation previously specified
+     * to {@link setConversation}.
+     */
+    public void saveDraft(final boolean isStopping) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[saveDraft] not default sms, no need to save draft, just return!!");
+            return;
+        }
+        // If we have discarded the message, just bail out.
+        if (mDiscarded) {
+            MmsLog.dpi(TAG_DRAFT, "saveDraft mDiscarded: true mConversation: " + mConversation +
+                " skipping saving draft and bailing");
+            return;
+        }
+
+        // Make sure setConversation was called.
+        if (mConversation == null) {
+            throw new IllegalStateException("saveDraft() called with no conversation");
+        }
+
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "saveDraft for mConversation " + mConversation);
+        }
+
+        // Get ready to write to disk. But don't notify message status when saving draft
+        prepareForSave(false /* notify */);
+
+        if (requiresMms()) {
+            asyncUpdateDraftMmsMessage(mConversation, isStopping, mInterface);
+            mHasMmsDraft = true;
+
+            /// M: Update state of the draft cache.
+            mConversation.setDraftState(true);
+        } else {
+            String content = mText.toString();
+
+            // bug 2169583: don't bother creating a thread id only to delete the thread
+            // because the content is empty. When we delete the thread in updateDraftSmsMessage,
+            // we didn't nullify conv.mThreadId, causing a temperary situation where conv
+            // is holding onto a thread id that isn't in the database. If a new message arrives
+            // and takes that thread id (because it's the next thread id to be assigned), the
+            // new message will be merged with the draft message thread, causing confusion!
+            if (!TextUtils.isEmpty(content)) {
+                asyncUpdateDraftSmsMessage(mConversation, content);
+                mHasSmsDraft = true;
+            } else {
+                // When there's no associated text message, we have to handle the case where there
+                // might have been a previous mms draft for this message. This can happen when a
+                // user turns an mms back into a sms, such as creating an mms draft with a picture,
+                // then removing the picture.
+                /// Which used to fix load draft from widget, the compose will flicker
+                /// while flicking, this will delete mms draft @{
+                //asyncDeleteDraftMmsMessage(mConversation);
+                /// @}
+                mMessageUri = null;
+            }
+        }
+        // Update state of the draft cache.
+        /// M: coomment google default.
+        // mConversation.setDraftState(true);
+
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    synchronized public void discard() {
+        discard(true);
+    }
+    /// @}
+
+    public void unDiscard() {
+        if (DEBUG) LogTag.debug("unDiscard");
+
+        mDiscarded = false;
+    }
+
+    /**
+     * Returns true if discard() has been called on this message.
+     */
+    public boolean isDiscarded() {
+        return mDiscarded;
+    }
+
+    /**
+     * To be called from our Activity's onSaveInstanceState() to give us a chance
+     * to stow our state away for later retrieval.
+     *
+     * @param bundle The Bundle passed in to onSaveInstanceState
+     */
+    public void writeStateToBundle(Bundle bundle) {
+        mBundle = bundle;
+        if (hasSubject()) {
+            bundle.putString("subject", mSubject.toString());
+        }
+
+        if (mMessageUri != null) {
+            bundle.putParcelable("msg_uri", mMessageUri);
+        } else if (hasText()) {
+            bundle.putString("sms_body", mText.toString());
+        }
+        /// M: fix bug ALPS00779871
+        if (mMessageUri == null) {
+            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+            SharedPreferences.Editor editor = sp.edit();
+            editor.putString(SAVE_MSG_URI_KEY, "");
+            editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+            editor.apply();
+        }
+    }
+
+    /**
+     * To be called from our Activity's onCreate() if the activity manager
+     * has given it a Bundle to reinflate
+     * @param bundle The Bundle passed in to onCreate
+     */
+    public void readStateFromBundle(Bundle bundle) {
+        if (bundle == null) {
+            return;
+        }
+
+        String subject = bundle.getString("subject");
+        setSubject(subject, false);
+
+        Uri uri = (Uri) bundle.getParcelable("msg_uri");
+        ///M: fix bug: ALPS00568220,
+        ///M: load message Uri from preference, because some times MMS will be killed by system
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mActivity);
+        long threadId = sp.getLong(SAVE_MSG_THREADID_KEY, -1);
+        if (uri == null && mConversation != null && mConversation.getThreadId() == threadId
+                && threadId != -1) {
+            String uriString = sp.getString(SAVE_MSG_URI_KEY, null);
+            if (uriString != null && !uriString.equals("")) {
+                uri = Uri.parse(uriString);
+            }
+        }
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(SAVE_MSG_URI_KEY, "");
+        editor.putLong(SAVE_MSG_THREADID_KEY, -1);
+        editor.apply();
+
+        if (uri != null) {
+            threadId = 0L;
+            if (mConversation != null) {
+                threadId = mConversation.getThreadId();
+                if (threadId <= 0 && !mConversation.getRecipients().isEmpty()) {
+                    threadId = mConversation.ensureThreadId();
+                }
+            }
+
+            MmsDraftData mdd = DraftManager.getInstance().loadDraft(DraftManager.SYNC_LOAD_ACTION,
+                    threadId, uri, mActivity, null);
+            if (mdd != null && mdd.getBooleanResult()) {
+                mSlideshow = mdd.getSlideshow();
+                mMessageUri = mdd.getMessageUri();
+                syncTextFromSlideshow();
+                correctAttachmentState();
+            }
+//            loadFromUri(uri);
+            /// M: fix bug ALPS00779135
+            if (mSlideshow != null) {
+                mHasMmsDraft = true;
+            }
+            return;
+        } else {
+            String body = bundle.getString("sms_body");
+            /// M: Code analyze 049, For bug ALPS00106234, to solve the
+            /// "JE" pops up after you press Back key . @{
+            if (body == null) {
+                mText = "";
+            } else {
+                mText = body;
+            }
+            /// @}
+        }
+    }
+
+    /**
+     * Update the temporary list of recipients, used when setting up a
+     * new conversation.  Will be converted to a ContactList on any
+     * save event (send, save draft, etc.)
+     */
+    public void setWorkingRecipients(List<String> numbers) {
+        mWorkingRecipients = numbers;
+        String s = null;
+        if (numbers != null) {
+            int size = numbers.size();
+            switch (size) {
+            case 1:
+                s = numbers.get(0);
+                break;
+            case 0:
+                s = "empty";
+                break;
+            default:
+                s = "{...} len=" + size;
+            }
+        }
+        /// M:
+        MmsLog.dpi(TAG, "setWorkingRecipients: numbers=" + s);
+    }
+
+    private void dumpWorkingRecipients() {
+        Log.i(TAG, "-- mWorkingRecipients:");
+
+        if (mWorkingRecipients != null) {
+            int count = mWorkingRecipients.size();
+            for (int i = 0; i < count; i++) {
+                Log.d(TAG, "   [" + i + "] " + mWorkingRecipients.get(i));
+            }
+            Log.i(TAG, "");
+        }
+    }
+
+    public void dump() {
+        Log.i(TAG, "WorkingMessage:");
+        dumpWorkingRecipients();
+        if (mConversation != null) {
+            MmsLog.dpi(TAG, "mConversation: " + mConversation.toString());
+        }
+    }
+
+    /**
+     * Set the conversation associated with this message.
+     */
+    public void setConversation(Conversation conv) {
+        if (DEBUG) {
+            MmsLog.dpi(TAG, "setConversation " + mConversation + " -> " + conv);
+        }
+
+        mConversation = conv;
+
+        // Convert to MMS if there are any email addresses in the recipient list.
+        if (conv != null) {
+            ContactList contactList = conv.getRecipients();
+            setHasEmail(contactList.containsEmail(), false);
+            // / M: google JB.MR1 patch, group mms
+            setHasMultipleRecipients(contactList.size() > 1, false);
+        }
+    }
+
+    public Conversation getConversation() {
+        return mConversation;
+    }
+
+    /**
+     * Hint whether or not this message will be delivered to an
+     * an email address.
+     */
+    public void setHasEmail(boolean hasEmail, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.setHasEmail(" + hasEmail + ", " + notify + ")");
+        if (MmsConfig.getEmailGateway() != null) {
+            updateState(RECIPIENTS_REQUIRE_MMS, false, notify);
+        } else {
+            updateState(RECIPIENTS_REQUIRE_MMS, hasEmail, notify);
+        }
+    }
+    /** google JB.MR1 patch, group mms
+     * Set whether this message will be sent to multiple recipients. This is a hint whether the
+     * message needs to be sent as an mms or not. If MmsConfig.getGroupMmsEnabled is false, then
+     * the fact that the message is sent to multiple recipients is not a factor in determining
+     * whether the message is sent as an mms, but the other factors (such as, "has a picture
+     * attachment") still hold true.
+     */
+    public void setHasMultipleRecipients(boolean hasMultipleRecipients, boolean notify) {
+        updateState(MULTIPLE_RECIPIENTS,
+                hasMultipleRecipients &&
+                MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity),
+                notify);
+    }
+
+    /**
+     * Returns true if this message would require MMS to send.
+     */
+    public boolean requiresMms() {
+        return (mMmsState > 0);
+    }
+
+    /**
+     * Set whether or not we want to send this message via MMS in order to
+     * avoid sending an excessive number of concatenated SMS messages.
+     * @param: mmsRequired is the value for the LENGTH_REQUIRES_MMS bit.
+     * @param: notify Whether or not to notify the user.
+     */
+    public void setLengthRequiresMms(boolean mmsRequired, boolean notify) {
+        updateState(LENGTH_REQUIRES_MMS, mmsRequired, notify);
+    }
+
+    private static String stateString(int state) {
+        if (state == 0)
+            return "<none>";
+
+        StringBuilder sb = new StringBuilder();
+        if ((state & RECIPIENTS_REQUIRE_MMS) > 0)
+            sb.append("RECIPIENTS_REQUIRE_MMS | ");
+        if ((state & HAS_SUBJECT) > 0)
+            sb.append("HAS_SUBJECT | ");
+        if ((state & HAS_ATTACHMENT) > 0)
+            sb.append("HAS_ATTACHMENT | ");
+        if ((state & LENGTH_REQUIRES_MMS) > 0)
+            sb.append("LENGTH_REQUIRES_MMS | ");
+        if ((state & FORCE_MMS) > 0)
+            sb.append("FORCE_MMS | ");
+        /// M: google JB.MR1 patch, group mms
+        if ((state & MULTIPLE_RECIPIENTS) > 0)
+            sb.append("MULTIPLE_RECIPIENTS | ");
+
+        if (sb.length() > 3) {
+            sb.delete(sb.length() - 3, sb.length());
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Sets the current state of our various "MMS required" bits.
+     *
+     * @param state The bit to change, such as {@link HAS_ATTACHMENT}
+     * @param on If true, set it; if false, clear it
+     * @param notify Whether or not to notify the user
+     */
+    private void updateState(int state, boolean on, boolean notify) {
+        /// M:
+        MmsLog.i(TAG, "WorkingMessage.updateState(" + state + ", " + on + ", " + notify + ")");
+        if (!sMmsEnabled) {
+            // If Mms isn't enabled, the rest of the Messaging UI should not be using any
+            // feature that would cause us to to turn on any Mms flag and show the
+            // "Converting to multimedia..." message.
+            return;
+        }
+        int oldState = mMmsState;
+        if (on) {
+            mMmsState |= state;
+            /// M: Code analyze 048, For bug ALPS00338410, The message only with recipients
+            /// should not be saved as draft display in the all
+            /// messages list after you press "Back" . @{
+            if ((mMmsState & ~FORCE_MMS) > 0) {
+                mMmsState = (mMmsState & ~FORCE_MMS);
+            }
+            /// @}
+        } else {
+            mMmsState &= ~state;
+        }
+
+        // If we are clearing the last bit that is not FORCE_MMS,
+        // expire the FORCE_MMS bit.
+        if (mMmsState == FORCE_MMS && ((oldState & ~FORCE_MMS) > 0)) {
+            mMmsState = 0;
+        }
+        /// M:
+        MmsLog.d(M_TAG, "updateState(): notify=" + notify
+                + ", oldState=" + oldState + ", mMmsState=" + mMmsState);
+        // Notify the listener if we are moving from SMS to MMS
+        // or vice versa.
+        if (notify) {
+            if (oldState == 0 && mMmsState != 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(true, true);
+                /// @}
+            } else if (oldState != 0 && mMmsState == 0) {
+                /// M: Code analyze 044, For bug ALPS00050082, add toast . @{
+                mStatusListener.onProtocolChanged(false, true);
+                /// @}
+            }
+        }
+
+        if (oldState != mMmsState) {
+            MmsLog.d(TAG, stateString(mMmsState) + mMmsState);
+            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) LogTag.debug("updateState: %s%s = %s",
+                    on ? "+" : "-",
+                    stateString(state), stateString(mMmsState));
+        }
+    }
+
+    /**
+     * Send this message over the network.  Will call back with onMessageSent() once
+     * it has been dispatched to the telephony stack.  This WorkingMessage object is
+     * no longer useful after this method has been called.
+     *
+     * @throws ContentRestrictionException if sending an MMS and uaProfUrl is not defined
+     * in mms_config.xml.
+     * M: Code analyze 047, For new feature ALPS00316567,
+     * extend this method for msim, add a parameter for subId
+     */
+    public void send(final String recipientsInUI, final int subId) {
+        MmsLog.d(MmsApp.TXN_TAG, "Enter send(). subId = " + subId);
+        final long origThreadId = mConversation.getThreadId();
+
+        if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            LogTag.debug("send origThreadId: " + origThreadId);
+        }
+
+        removeSubjectIfEmpty(true /* notify */);
+
+        // Get ready to write to disk.
+        prepareForSave(true /* notify */);
+
+        // We need the recipient list for both SMS and MMS.
+        final Conversation conv = mConversation;
+        final String msgTxt = mText.toString();
+        final SplitToMmsAndSmsConversation spliter =
+            new SplitToMmsAndSmsConversation(conv, msgTxt);
+
+         if (spliter.getMMSConversation() != null) {
+            // uaProfUrl setting in mms_config.xml must be present to send an MMS.
+            // However, SMS service will still work in the absence of a uaProfUrl address.
+            if (MmsConfig.getUaProfUrl() == null) {
+                String err = "WorkingMessage.send MMS sending failure. mms_config.xml is " +
+                        "missing uaProfUrl setting.  uaProfUrl is required for MMS service, " +
+                        "but can be absent for SMS.";
+                RuntimeException ex = new NullPointerException(err);
+                Log.e(TAG, err, ex);
+                // now, let's just crash.
+                throw ex;
+            }
+
+            // Make local copies of the bits we need for sending a message,
+            // because we will be doing it off of the main thread, which will
+            // immediately continue on to resetting some of this state.
+            final Uri mmsUri = mMessageUri;
+            final PduPersister persister = PduPersister.getPduPersister(mActivity);
+
+            final SlideshowModel slideshow = mSlideshow;
+            final CharSequence subject = mSubject;
+
+            if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+                MmsLog.dpi(TAG, "Send mmsUri: " + mmsUri);
+            }
+
+            // Do the dirty work of sending the message off of the main UI thread.
+            new Thread(new Runnable() {
+                public void run() {
+                    SendReq sendReq = makeSendReq(spliter.getMMSConversation(), subject);
+
+                    sendReq = mOpWorkingMessageExt.opSendThreadRun(sendReq);
+
+                    // Make sure the text in slide 0 is no longer holding onto a reference to
+                    // the text in the message text box.
+                    slideshow.prepareForSend();
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for gemini . @{
+                    if (spliter.getSMSConversation() != null) {
+                        ///M: Message got split into SMS & MMS. Need to
+                        /// set the mmsuri as NULL to again update it.
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                null, persister, slideshow, sendReq, subId);
+                    }
+                    else {
+                        sendMmsWorker(spliter.getMMSConversation(),
+                                mmsUri, persister, slideshow, sendReq, subId);
+                    }
+                    /// @}
+
+                    updateSendStats(spliter.getMMSConversation());
+
+                    if (origThreadId > 0 && origThreadId != conv.getThreadId()) {
+                        boolean isHasDraft = DraftCache.refreshDraft(mActivity, origThreadId);
+                        Log.d(TAG,
+                                "[send] origThreadId : " + origThreadId
+                                + " isHasDraft : " + isHasDraft);
+                        DraftCache.getInstance().setDraftState(origThreadId, isHasDraft);
+                    }
+                }
+            }, "WorkingMessage.send MMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getMMSConversation().getThreadId(),
+                    spliter.getMMSConversation().getRecipients());
+        }
+        if (spliter.getSMSConversation() != null) {
+            new Thread(new Runnable() {
+                public void run() {
+                    /// M: Code analyze 047, For new feature ALPS00316567,
+                    /// add a parameter for msim . @{
+                    preSendSmsWorker(spliter.getSMSConversation(), msgTxt, recipientsInUI, subId,
+                            (spliter.getMMSConversation() != null) ? true : false);
+                    /// @}
+                    updateSendStats(spliter.getSMSConversation());
+                }
+            }, "WorkingMessage.send SMS").start();
+            // update the Recipient cache with the new to address, if it's different
+            RecipientIdCache.updateNumbers(spliter.getSMSConversation().getThreadId(),
+                    spliter.getSMSConversation().getRecipients());
+        }
+
+        // Mark the message as discarded because it is "off the market" after being sent.\
+        /// M: comment google default.
+        // mDiscarded = true;
+    }
+
+    // Check for the Partial Compliant conditions
+    private boolean isPartiallySMSCompliant() {
+         boolean result = false;
+         if (((mMmsState & FORCE_MMS) == 0)
+             // NO slideshow that will convert the whole message for the whole
+             // recipients into MMS
+         && ((mMmsState & LENGTH_REQUIRES_MMS) == 0)
+             // DO NOT exceed a particular threshold of SMS truncation that
+             // will convert the whole message for the whole recipients into
+             // MMS
+         && ((mMmsState & HAS_ATTACHMENT) == 0)
+             // NO attachment that will convert the whole message for the
+             // whole recipients into MMS
+         && ((mMmsState & HAS_SUBJECT) == 0)) {
+             // NO subject that will convert the whole message for the whole
+             // recipients into MMS
+             // DO NOT check RECIPIENTS_REQUIRE_MMS to allow email & alias as
+             // recipients
+            result = true;
+             // Conversation where MMS could not be mandatory for some
+             // recipients : aka phone numbers.
+        }
+        return result;
+    }
+
+    // set conversation and split it into SMS & MMS conversation
+    private class SplitToMmsAndSmsConversation implements ISplitToMmsAndSmsConversationCallback {
+        private Conversation mSmsConv;
+
+        private Conversation mMmsConv;
+
+        private ContactList listSms;
+
+        private ContactList listMms;
+
+        // Split if necessary the initial conversation in one MMS conversation
+        // or/and one SMS conversation
+        // Allow to send SMS with phone numbers recipients when the conversation
+        // is still SMS compliant.
+
+        public SplitToMmsAndSmsConversation(final Conversation conv, final String msgTxt) {
+            mMmsConv = null;
+            mSmsConv = null;
+            Log.d(TAG, "setConversationToSplitAsSmsMms");
+
+            if (!mOpWorkingMessageExt.onCreateSplitToMmsAndSmsConv(this, conv)) {
+                if (requiresMms() || addressContainsEmailToMms(conv, msgTxt)) {
+                    mMmsConv = conv;
+                } else {
+                    mSmsConv = conv;
+                }
+                return;
+            }
+        }
+
+        private void splitConv(final Conversation conv) {
+            ContactList list = null;
+            Contact contact = null;
+            String number = null;
+            listSms = null;
+            listMms = null;
+
+            // Conversation with SMS/MMS Split is supported
+            if (conv != null) {
+                list = conv.getRecipients();
+                if (list != null) {
+                    if (requiresMms()) {
+                        if (isPartiallySMSCompliant()) {
+                            for (int i = 0; i < list.size(); i++) {
+                                contact = list.get(i);
+                                if (contact != null) {
+                                    number = contact.getNumber();
+                                    if (!TextUtils.isEmpty(number)) {
+                                        if (Mms.isPhoneNumber(number)) {
+                                            addContactAsSms(contact);
+                                        } else {
+                                            addContactAsMms(contact);
+                                        }
+                                    } else {
+                                        addContactAsMms(contact);
+                                    }
+                                } // contact
+                            }
+                        } else {
+                            listMms = list;
+                        } // isPartiallySMSCompliant
+                    } else {
+                        listSms = list;
+                    } // requiresMms
+
+                    if (listMms != null) {
+                        mMmsConv = conv;
+                        mMmsConv.setRecipients(listMms);
+                        if (listSms != null) {
+                            mSmsConv = Conversation.createNew(mActivity.getApplicationContext());
+                            mSmsConv.setRecipients(listSms);
+                        }
+                    } else if (listSms != null) {
+                        mSmsConv = conv;
+                        mSmsConv.setRecipients(listSms);
+                    }
+                }
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsMms(Contact contact) {
+            if (listMms == null) {
+                listMms = new ContactList();
+            }
+            if (!listMms.contains(contact)) {
+                listMms.add(contact);
+            }
+        }
+
+        // Add contact in MMS recipient list
+        private void addContactAsSms(Contact contact) {
+            if (listSms == null) {
+                listSms = new ContactList();
+            }
+            if (!listSms.contains(contact)) {
+                listSms.add(contact);
+            }
+        }
+
+        protected Conversation getSMSConversation() {
+            return mSmsConv;
+        }
+
+        protected Conversation getMMSConversation() {
+            return mMmsConv;
+        }
+
+        /// M: @{
+        public void splitConvCallback(final IConversationCallback conv) {
+            splitConv((Conversation) conv);
+        }
+        /// @}
+    }
+
+    // Be sure to only call this on a background thread.
+    private void updateSendStats(final Conversation conv) {
+        String[] dests = conv.getRecipients().getNumbers();
+        final ArrayList<String> phoneNumbers = new ArrayList<String>(Arrays.asList(dests));
+
+        DataUsageStatUpdater updater = new DataUsageStatUpdater(mActivity);
+        updater.updateWithPhoneNumber(phoneNumbers);
+    }
+
+    private boolean addressContainsEmailToMms(Conversation conv, String text) {
+        if (MmsConfig.getEmailGateway() != null) {
+            String[] dests = conv.getRecipients().getNumbers();
+            int length = dests.length;
+            for (int i = 0; i < length; i++) {
+                if (Mms.isEmailAddress(dests[i]) || MessageUtils.isAlias(dests[i])) {
+                    String mtext = dests[i] + " " + text;
+                    int[] params = SmsMessage.calculateLength(mtext, false);
+                    if (params[0] > 1) {
+                        updateState(RECIPIENTS_REQUIRE_MMS, true, true);
+                        ensureSlideshow();
+                        syncTextToSlideshow();
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    // Message sending stuff
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void preSendSmsWorker(Conversation conv, String msgText, String recipientsInUI,
+            int subId, boolean hasBeenSplit) {
+    /// @}
+        // If user tries to send the message, it's a signal the inputted text is what they wanted.
+        UserHappinessSignals.userAcceptedImeText(mActivity);
+
+        mStatusListener.onPreMessageSent();
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        long origThreadId = conv.getThreadId();
+
+        if (mForceUpdateThreadId) {
+            conv.setNeedForceUpdateThreadId(true);
+            mForceUpdateThreadId = false;
+        }
+
+        // Make sure we are still using the correct thread ID for our recipient set.
+        long threadId = conv.ensureThreadId();
+
+        String semiSepRecipients = conv.getRecipients().serialize();
+
+        // recipientsInUI can be empty when the user types in a number and hits send
+        if (LogTag.SEVERE_WARNING && ((origThreadId != 0 && origThreadId != threadId) ||
+               ((!hasBeenSplit) && (!semiSepRecipients.equals(recipientsInUI))
+                       && !TextUtils.isEmpty(recipientsInUI)))) {
+            String msg = origThreadId != 0 && origThreadId != threadId ?
+                    "WorkingMessage.preSendSmsWorker threadId changed or " +
+                    "recipients changed. origThreadId: " +
+                    origThreadId + " new threadId: " + threadId +
+                    " also mConversation.getThreadId(): " +
+                    mConversation.getThreadId()
+                :
+                    "Recipients in window: \"" +
+                    recipientsInUI + "\" differ from recipients from conv: \"" +
+                    semiSepRecipients + "\"";
+
+            //LogTag.warnPossibleRecipientMismatch(msg, mActivity);
+        }
+
+        // just do a regular send. We're already on a non-ui thread so no need to fire
+        // off another thread to do this work.
+        /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+        sendSmsWorker(msgText, semiSepRecipients, threadId, subId);
+        /// @}
+
+        // Be paranoid and clean any draft SMS up.
+        deleteDraftSmsMessage(threadId);
+        /// M Fix CR:ALPS01268191 which is google issue. while save a mms draft, enter the
+        /// draft, change the recipients to be phone number, and send the sms. @{
+        Log.d(TAG_DRAFT, "[preSendSmsWorker] mOldThreadId : " + mOldThreadId);
+        if (mOldThreadId != 0) {
+//            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+                DraftCache.getInstance().setDraftState(mOldThreadId, false);
+//            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendSmsWorker(String msgText,
+            String semiSepRecipients, long threadId, int subId) {
+    /// @}
+        String[] dests = TextUtils.split(semiSepRecipients, ";");
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {
+            MmsLog.dpi(LogTag.TRANSACTION, "sendSmsWorker sending message: recipients=" +
+                    semiSepRecipients + ", threadId=" + threadId);
+        }
+        MessageSender sender = new SmsMessageSender(mActivity, dests, msgText, threadId, subId);
+
+        try {
+            sender.sendMessage(threadId);
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getSmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send SMS message, threadId=" + threadId, e);
+        }
+
+        mStatusListener.onMessageSent();
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim . @{
+    private void sendMmsWorker(Conversation conv, Uri mmsUri, PduPersister persister,
+            SlideshowModel slideshow, SendReq sendReq, int subId) {
+    /// @}
+        long threadId = 0;
+        Cursor cursor = null;
+        boolean newMessage = false;
+        try {
+            // Put a placeholder message in the database first
+            DraftCache.getInstance().setSavingDraft(true);
+            mStatusListener.onPreMessageSent();
+
+            // Make sure we are still using the correct thread ID for our
+            // recipient set.
+            if (mForceUpdateThreadId) {
+                conv.setNeedForceUpdateThreadId(true);
+                mForceUpdateThreadId = false;
+            }
+            threadId = conv.ensureThreadId();
+            conv.setNeedForceUpdateThreadId(false);
+
+            MmsLog.dpi(TAG, "sendMmsWorker: update draft MMS message " + mmsUri +
+                        " threadId: " + threadId);
+
+            // One last check to verify the address of the recipient.
+            String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+            if (dests.length == 1) {
+                // verify the single address matches what's in the database. If we get a different
+                // address back, jam the new value back into the SendReq.
+                String newAddress =
+                    Conversation.verifySingleRecipient(mActivity, conv.getThreadId(), dests[0]);
+
+                if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                    MmsLog.dpi(TAG, "sendMmsWorker: newAddress " + newAddress +
+                            " dests[0]: " + dests[0]);
+                }
+
+                if (!newAddress.equals(dests[0])) {
+                    dests[0] = newAddress;
+                    EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+                    if (encodedNumbers != null) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("sendMmsWorker: REPLACING number!!!");
+                        }
+                        sendReq.setTo(encodedNumbers);
+                    }
+                }
+            }
+            newMessage = mmsUri == null;
+            if (newMessage) {
+                // check if a draft is already present for current thread
+                final String selection = Mms.THREAD_ID + " = " + threadId;
+                cursor = SqliteWrapper.query(mActivity, mContentResolver, Mms.Draft.CONTENT_URI,
+                        MMS_DRAFT_PROJECTION, selection, null, null);
+                if (cursor == null) {
+                    Log.d(TAG, "[readDraftMmsMessage] cursor is null");
+                }
+                try {
+                    if (cursor != null) {
+                        if (cursor.moveToFirst()) {
+                            Uri uri = ContentUris.withAppendedId(Mms.Draft.CONTENT_URI,
+                                    cursor.getLong(MMS_ID_INDEX));
+                            Log.d(TAG, "retrieved uri = " + uri);
+                            mMessageUri = mmsUri = uri;
+                            newMessage = mmsUri == null;
+                        }
+                    }
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+
+            }
+            if (newMessage) {
+                // Write something in the database so the new message will appear as sending
+                ContentValues values = new ContentValues();
+                values.put(Mms.MESSAGE_BOX, Mms.MESSAGE_BOX_OUTBOX);
+                values.put(Mms.THREAD_ID, threadId);
+                values.put(Mms.MESSAGE_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                /// M: Code analyze 047, For new feature ALPS00316567, add a parameter for msim. @{
+                values.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+                /// @}
+                mmsUri = SqliteWrapper.insert(mActivity, mContentResolver, Mms.Outbox.CONTENT_URI,
+                        values);
+            }
+//            mStatusListener.onMessageSent();
+
+            // If user tries to send the message, it's a signal the inputted text is
+            // what they wanted.
+            UserHappinessSignals.userAcceptedImeText(mActivity);
+
+            // First make sure we don't have too many outstanding unsent message.
+            cursor = SqliteWrapper.query(mActivity, mContentResolver,
+                    Mms.Outbox.CONTENT_URI, MMS_OUTBOX_PROJECTION, null, null, null);
+            if (cursor != null) {
+                long maxMessageSize = MmsConfig.getMaxSizeScaleForPendingMmsAllowed() *
+                    /// M: change google default. @{
+                    MmsConfig.getUserSetMmsSizeLimit(true);
+                    /// @}
+                long totalPendingSize = 0;
+                while (cursor.moveToNext()) {
+                      /// M: change google default. @{
+                    if (PduHeaders.STATUS_UNREACHABLE
+                            != cursor.getLong(MMS_MESSAGE_STATUS_INDEX)) {
+                        totalPendingSize += cursor.getLong(MMS_MESSAGE_SIZE_INDEX);
+                    }
+                    /// @}
+                }
+                if (totalPendingSize >= maxMessageSize) {
+                    unDiscard();    // it wasn't successfully sent. Allow it to be saved as a draft.
+                    mStatusListener.onMaxPendingMessagesReached();
+                    markMmsMessageWithError(mmsUri, subId);
+
+                    /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+                    /// the conversation message count will set to be 0, and the threadid will be
+                    /// set to be 0, so while unlock the screen, the message
+                    /// will not show in the message list @{
+                    mStatusListener.onMessageSent();
+                    /// M @}
+
+                    MmsLog.d(MmsApp.TXN_TAG,
+                            "totalPendingSize >= maxMessageSize, totalPendingSize = "
+                            + totalPendingSize);
+                    return;
+                }
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        try {
+            MmsDraftData res = DraftManager.getInstance()
+                    .saveDraft(DraftManager.SYNC_SAVE_ACTION, threadId,
+                    mmsUri, slideshow, sendReq, mActivity, null);
+            if (res != null) {
+                if (res.getMessageUri() != null) {
+                    MmsLog.dpi(TAG_DRAFT, "[sendMmsWorker] mmsUir : " + mmsUri);
+                    mmsUri = res.getMessageUri();
+                }
+            }
+            /*if (newMessage) {
+                // Create a new MMS message if one hasn't been made yet.
+                mmsUri = createDraftMmsMessage(persister, sendReq, slideshow, mmsUri,
+                        mActivity);
+            } else {
+                // Otherwise, sync the MMS message in progress to disk.
+                updateDraftMmsMessage(mmsUri, persister, slideshow, sendReq);
+            }*/
+
+            // Be paranoid and clean any draft SMS up.
+            deleteDraftSmsMessage(threadId);
+        } finally {
+            DraftCache.getInstance().setSavingDraft(false);
+        }
+
+        if (isAbortSendingMmsByFdnList(conv, subId)) {
+            MmsLog.d(TAG, "Abort Sending By FDN");
+            if (!mmsUri.toString().startsWith(Mms.Draft.CONTENT_URI.toString())) {
+                ContentValues values = new ContentValues();
+                values.put(PendingMessages.PROTO_TYPE, MmsSms.MMS_PROTO);
+                values.put(PendingMessages.MSG_ID, ContentUris.parseId(mmsUri));
+                values.put(PendingMessages.MSG_TYPE, PduHeaders.MESSAGE_TYPE_SEND_REQ);
+                values.put(PendingMessages.ERROR_TYPE, 0);
+                values.put(PendingMessages.ERROR_CODE, 0);
+                values.put(PendingMessages.RETRY_INDEX, 0);
+                values.put(PendingMessages.DUE_TIME, 0);
+
+                SqliteWrapper.insert(mActivity, mActivity.getContentResolver(),
+                        PendingMessages.CONTENT_URI, values);
+            }
+            markMmsMessageWithError(mmsUri, subId);
+            MessagingNotification.notifySendFailed(mActivity, true);
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            new Thread() {
+                public void run() {
+                    Looper.prepare();
+                    Toast.makeText(mActivity, mActivity.getString(R.string.fdn_check_failure),
+                            Toast.LENGTH_SHORT).show();
+                    Looper.loop();
+                };
+            } .start();
+            return;
+        }
+
+        /// M: Mark the message as discarded because it is "off the market" after being sent.
+        mDiscarded = true;
+
+        try {
+            MessageSender sender = new MmsMessageSender(mActivity, mmsUri,
+                    slideshow.getCurrentSlideshowSize(), subId);
+            if (!sender.sendMessage(threadId)) {
+                // The message was sent through SMS protocol, we should
+                // delete the copy which was previously saved in MMS drafts.
+                SqliteWrapper.delete(mActivity, mContentResolver, mmsUri, null, null);
+            }
+            /// M: add for fix issue ALPS00804679 @{
+            else {
+                Log.d(TAG, "sendMmsWorker: sendMessage success, mark draft false. threadId = "
+                        + threadId);
+                DraftCache.getInstance().setSavingDraft(true);
+                conv.setDraftState(false);
+                DraftCache.getInstance().setSavingDraft(false);
+            }
+            ///@}
+
+            /// M : Fix CR : ALPS01798784, while after send the MMS, lock the screen
+            /// the conversation message count will set to be 0, and the threadid will be
+            /// set to be 0, so while unlock the screen,
+            /// the message will not show in the message list @{
+            mStatusListener.onMessageSent();
+            /// @}
+
+            // Make sure this thread isn't over the limits in message count
+            Recycler.getMmsRecycler().deleteOldMessagesByThreadId(mActivity, threadId);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to send message: " + mmsUri + ", threadId=" + threadId, e);
+        }
+        MmsWidgetProvider.notifyDatasetChanged(mActivity);
+    }
+
+    private boolean isAbortSendingMmsByFdnList(Conversation conv, int subId) {
+        boolean isFdnEnabled = false;
+        try {
+            ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(ServiceManager
+                    .getService("phoneEx"));
+            if (telephonyEx != null && telephonyEx.isFdnEnabled(subId)) {
+                isFdnEnabled = true;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "[isAbortSendingMmsByFdnList]catch exception:");
+            e.printStackTrace();
+            isFdnEnabled = false;
+        }
+        Log.d(TAG, "isAbortSendingMmsByFdnList, isFdnEnabled = " + isFdnEnabled);
+        if (!isFdnEnabled) {
+            return false;
+        } else {
+            Uri uri = null;
+            ContactList contactlist = conv.getRecipients();
+            String[] numbers = contactlist.getNumbers();
+            uri = Uri.parse(FDN_URI + subId);
+
+            Cursor cursor = SqliteWrapper.query(mActivity, mActivity.getContentResolver(),
+                    uri, FDN_PROJECTION, null, null, null);
+            ArrayList<String> fdnList = new ArrayList<String>();
+            if (cursor != null) {
+                try {
+                    while (cursor.moveToNext()) {
+                        String number = cursor.getString(FDN_COLUMN_NUMBER);
+                        if (number != null) {
+                            fdnList.add(number);
+                        }
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+            for (String contactNumber : numbers) {
+                MmsLog.dpi(TAG, "isAbortSending, contactNumber = " + contactNumber);
+                if (!isInStringArray(contactNumber, fdnList)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    private boolean isInStringArray(String string, ArrayList<String> arrayList) {
+        for (String oneString : arrayList) {
+            if (string.equals(oneString)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void markMmsMessageWithError(Uri mmsUri, int subId) {
+        try {
+            PduPersister p = PduPersister.getPduPersister(mActivity);
+            // Move the message into MMS Outbox. A trigger will create an entry in
+            // the "pending_msgs" table.
+            p.move(mmsUri, Mms.Outbox.CONTENT_URI);
+
+            // Now update the pending_msgs table with an error for that new item.
+            /// M Fix CR ALPS00584603
+            /// update pending_sim_id column which in pending_msgs table @{
+            ContentValues valuePendingTable = new ContentValues(2);
+            valuePendingTable.put(PendingMessages.ERROR_TYPE, MmsSms.ERR_TYPE_GENERIC_PERMANENT);
+            valuePendingTable.put(Telephony.MmsSms.PendingMessages.SUBSCRIPTION_ID, subId);
+            long msgId = ContentUris.parseId(mmsUri);
+            SqliteWrapper.update(mActivity, mContentResolver,
+                    PendingMessages.CONTENT_URI,
+                    valuePendingTable, PendingMessages.MSG_ID + "=" + msgId, null);
+            /// @}
+            /// M update sim_id column in pdu table @{
+            ContentValues valuePduTable = new ContentValues(1);
+            valuePduTable.put(Telephony.BaseMmsColumns.SUBSCRIPTION_ID, subId);
+            valuePduTable.put(Mms.READ, 0);
+            SqliteWrapper.update(mActivity, mContentResolver, mmsUri, valuePduTable, null, null);
+            /// @}
+        } catch (MmsException e) {
+            // Not much we can do here. If the p.move throws an exception, we'll just
+            // leave the message in the draft box.
+            Log.e(TAG, "Failed to move message to outbox and mark as error: " + mmsUri, e);
+        }
+    }
+
+    /**
+     * makeSendReq should always return a non-null SendReq, whether the dest addresses are
+     * valid or not.
+     */
+    private static SendReq makeSendReq(Conversation conv, CharSequence subject) {
+        /// M: change google default, @{
+        // String[] dests = conv.getRecipients().getNumbers(true /* scrub for MMS address */);
+        String[] dests = conv.getRecipients().getNumbers(false /*don't scrub for MMS address */);
+        // @}
+
+        SendReq req = new SendReq();
+        EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(dests);
+        if (encodedNumbers != null) {
+            req.setTo(encodedNumbers);
+        }
+
+        if (!TextUtils.isEmpty(subject)) {
+            req.setSubject(new EncodedStringValue(subject.toString()));
+        }
+
+        req.setDate(System.currentTimeMillis() / 1000L);
+
+        return req;
+    }
+
+    private void asyncUpdateDraftMmsMessage(final Conversation conv,
+            final boolean isStopping, final IDraftInterface callback) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncUpdateDraftMmsMessage conv= " + conv + " mMessageUri= "
+                                + mMessageUri);
+        }
+
+        DraftCache.getInstance().setSavingDraft(true);
+
+        SendReq sendReq = makeSendReq(conv, mSubject);
+
+        sendReq = mOpWorkingMessageExt.opAsyncUpdateDraftMmsMessage(sendReq);
+
+        long threadId = conv.getThreadId();
+
+        Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] before thread id : " + threadId);
+        if (threadId <= 0 && !conv.getRecipients().isEmpty()) {
+            threadId = conv.ensureThreadId();
+            Log.d(TAG_DRAFT, "[asyncUpdateDraftMmsMessage] after thread id : " + threadId);
+        }
+
+        DraftManager.getInstance().saveDraft(DraftManager.ASYNC_SAVE_ACTION, threadId,
+                mMessageUri, mSlideshow, sendReq, mActivity, callback);
+    }
+
+    private static final String SMS_DRAFT_WHERE = Sms.TYPE + "=" + Sms.MESSAGE_TYPE_DRAFT;
+    private static final String[] SMS_BODY_PROJECTION = { Sms.BODY };
+    private static final int SMS_BODY_INDEX = 0;
+
+    /**
+     * Reads a draft message for the given thread ID from the database,
+     * if there is one, deletes it from the database, and returns it.
+     * @return The draft message or an empty string.
+     */
+    private String readDraftSmsMessage(Conversation conv) {
+        long thread_id = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "readDraftSmsMessage conv: " + conv);
+        }
+        // If it's an invalid thread or we know there's no draft, don't bother.
+        if (thread_id <= 0/* || !conv.hasDraft()*/) {
+            return "";
+        }
+
+        Uri thread_uri = ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, thread_id);
+        String body = "";
+
+        Cursor c = SqliteWrapper.query(mActivity, mContentResolver,
+                        thread_uri, SMS_BODY_PROJECTION, SMS_DRAFT_WHERE, null, null);
+        boolean haveDraft = false;
+        if (c != null) {
+            try {
+                if (c.moveToFirst()) {
+                    body = c.getString(SMS_BODY_INDEX);
+                    haveDraft = true;
+                }
+            } finally {
+                c.close();
+            }
+        }
+
+        // We found a draft, and if there are no messages in the conversation,
+        // that means we deleted the thread, too. Must reset the thread id
+        // so we'll eventually create a new thread.
+        if (haveDraft && (conv.getMessageCount() == 0 || FolderModeUtils.getMmsDirMode())) {
+            asyncDeleteDraftSmsMessage(conv);
+
+            // Clean out drafts for this thread -- if the recipient set changes,
+            // we will lose track of the original draft and be unable to delete
+            // it later.  The message will be re-saved if necessary upon exit of
+            // the activity.
+            clearConversation(conv, true);
+        }
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("readDraftSmsMessage haveDraft: ", !TextUtils.isEmpty(body));
+        }
+
+        return body;
+    }
+
+    public void clearConversation(final Conversation conv, boolean resetThreadId) {
+        /// M: Code analyze 052, For bug ALPS00047256, to solve shows a wrong thread . @{
+        int messageCount = 0;
+        final Uri sAllThreadsUri =
+            Threads.CONTENT_URI.buildUpon().appendQueryParameter("simple", "true").build();
+
+        if (conv.getMessageCount() == 0) {
+            Cursor cursor = SqliteWrapper.query(
+                mActivity,
+                mContentResolver,
+                sAllThreadsUri,
+                new String[] {Threads.MESSAGE_COUNT, Threads._ID} ,
+                Threads._ID + "=" + conv.getThreadId(), null, null);
+            if (cursor != null) {
+                try {
+                    if (cursor.moveToFirst()) {
+                        messageCount =
+                            cursor.getInt(cursor.getColumnIndexOrThrow(Threads.MESSAGE_COUNT));
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+        }
+        if (resetThreadId && conv.getMessageCount() == 0 && messageCount == 0) {
+            LogTag.debug("clearConversation calling clearThreadId");
+            conv.clearThreadId();
+        }
+
+        conv.setDraftState(false);
+    }
+
+    private void asyncUpdateDraftSmsMessage(final Conversation conv, final String contents) {
+        new Thread(new Runnable() {
+            public void run() {
+                try {
+                    DraftCache.getInstance().setSavingDraft(true);
+                    if (conv.getRecipients().isEmpty()) {
+                        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+                            LogTag.debug("asyncUpdateDraftSmsMessage no recipients, not saving");
+                        }
+                        return;
+                    }
+                    /// M: Code analyze 054, For bug ALPS00120202, Message]can't save draft
+                    /// if enter message from messageDirect widget Sometimes thread id is
+                    /// deleted as obsolete thread, so need to guarantee it exists . @{
+                    conv.guaranteeThreadId();
+                    /// @}
+                    conv.setDraftState(true);
+                    updateDraftSmsMessage(conv, contents);
+                } finally {
+                    DraftCache.getInstance().setSavingDraft(false);
+                }
+            }
+        }, "WorkingMessage.asyncUpdateDraftSmsMessage").start();
+    }
+
+    private void updateDraftSmsMessage(final Conversation conv, String contents) {
+        final long threadId = conv.getThreadId();
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "updateDraftSmsMessage tid=" + threadId + ", contents= " + contents);
+        }
+        // If we don't have a valid thread, there's nothing to do.
+        if (threadId <= 0) {
+            return;
+        }
+
+        ContentValues values = new ContentValues(3);
+        values.put(Sms.THREAD_ID, threadId);
+        values.put(Sms.BODY, contents);
+        values.put(Sms.TYPE, Sms.MESSAGE_TYPE_DRAFT);
+        SqliteWrapper.insert(mActivity, mContentResolver, Sms.CONTENT_URI, values);
+        Log.d(TAG_DRAFT,
+                "[updateDraftSmsMessage] mIsTurnToChooseAttach : " + mIsTurnToChooseAttach);
+        if (!mIsTurnToChooseAttach) {
+            asyncDeleteDraftMmsMessage(conv);
+        }
+
+        if (mOldThreadId != 0) {
+            if (mOldThreadId != threadId) {
+                asyncDeleteDraftMmsMessage(mOldThreadId);
+            }
+        }
+        /// M : Fix CR : ALPS01012417  Two threads showed in ConversationList
+        /// new message, input phone number, content, press home key, press message icon
+        /// will load the last sms message, change phone number,back to conversationlist. @{
+        if (mOldSmsSaveThreadId > 0) {
+            if (mOldSmsSaveThreadId != threadId) {
+                deleteDraftSmsMessage(mOldSmsSaveThreadId);
+                ///M: add for fix issue ALPS01078057. when delete the saved sms, should update the
+                /// old thread's draft state to false.
+                DraftCache.getInstance().setDraftState(mOldSmsSaveThreadId, false);
+            }
+        }
+        mOldSmsSaveThreadId = threadId;
+        /// @}
+
+        /// M: Fix CR : ALPS01078057. when the thread changed,
+        /// if the old thread saved Mms draft before,
+        /// should reset the old thread's draft state @{
+        if (mOldMmsSaveThreadId != 0 && mOldMmsSaveThreadId != threadId) {
+            asyncDeleteDraftMmsMessage(mOldMmsSaveThreadId);
+            DraftCache.getInstance().setDraftState(mOldMmsSaveThreadId, false);
+            mOldMmsSaveThreadId = 0;
+        }
+        /// @}
+        mMessageUri = null;
+    }
+
+    private void asyncDelete(final Uri uri, final String selection, final String[] selectionArgs) {
+        if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            MmsLog.dpi(TAG, "asyncDelete " + uri + " where " + selection);
+        }
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+            }
+        }, "WorkingMessage.asyncDelete").start();
+    }
+
+    public void checkDraftSmsMessage(final Conversation conv) {
+        final WorkingMessage msg = this;
+          new Thread(new Runnable() {
+            public void run() {
+                final String draftText = msg.readDraftSmsMessage(conv);
+                Log.d(TAG_DRAFT, "checkDraftSmsMessage draftText : " + draftText);
+                if (!TextUtils.isEmpty(draftText)) {
+                    msg.mHasSmsDraft = true;
+                }
+            }
+        }, "WorkingMessage.loadDraft").start();
+    }
+
+    public void asyncDeleteDraftSmsMessage(Conversation conv) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+        }
+    }
+
+    //M: Add for modify issue ALPS01812929
+    public void asyncDeleteDraftSmsMessage(Conversation conv, final Runnable r) {
+        mHasSmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            asyncDelete(ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null, r);
+        }
+    }
+
+    private void deleteDraftSmsMessage(long threadId) {
+        SqliteWrapper.delete(mActivity, mContentResolver,
+                ContentUris.withAppendedId(Sms.Conversations.CONTENT_URI, threadId),
+                SMS_DRAFT_WHERE, null);
+    }
+
+    public void asyncDeleteDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+        /// M: Reset MMS's message URI because the MMS is deleted */
+        mMessageUri = null;
+
+        }
+    }
+
+    public void asyncDeleteDraftMmsMessage(final long threadId) {
+        mHasMmsDraft = false;
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+
+            /// M: Reset MMS's message URI because the MMS is deleted */
+            mMessageUri = null;
+        }
+    }
+
+    /// M:
+    public int getCurrentMessageSize() {
+        if (mSlideshow != null) {
+            int currentMessageSize = mSlideshow.getCurrentSlideshowSize();
+            return currentMessageSize;
+        }
+        return 0;
+    }
+
+    /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't take
+    /// effect immediately after modify in settings Should update static variable
+    /// after peference is changed . @{
+    public static void updateCreationMode(Context context) {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
+        String creationMode =
+            sp.getString(MmsPreferenceActivity.CREATION_MODE, CREATION_MODE_FREE);
+        if (creationMode.equals(CREATION_MODE_WARNING)) {
+            sCreationMode = WARNING_TYPE;
+        } else if (creationMode.equals(CREATION_MODE_RESTRICTED)) {
+            sCreationMode = RESTRICTED_TYPE;
+        } else {
+            sCreationMode = OK;
+        }
+    }
+    /// @}
+
+    public boolean isResizeImage() {
+        return mResizeImage;
+    }
+
+    public void setResizeImage(boolean resizeImage) {
+        this.mResizeImage = resizeImage;
+    }
+
+    public Uri getMessageUri() {
+        return this.mMessageUri;
+    }
+
+    /// M: Code analyze 042, For bug ALPS00117913, Delete old Mms draft when save
+    /// Latest Mms message as draft . @{
+    public void  setNeedDeleteOldMmsDraft(Boolean delete) {
+        mNeedDeleteOldMmsDraft = delete;
+    }
+    /// @}
+
+    /**
+    * Fix CR : ALPS01105564
+    *  which used to delete the thread which has 2 mms drafts. only remain the last draft(pdu)
+    */
+    private void deleteOldMmsDraft(Uri msgUri, long tid) {
+        if (msgUri != null && tid > 0) {
+            String pduId = msgUri.getLastPathSegment();
+            final String where = Mms.THREAD_ID + "=" + tid + " and " + WordsTable.ID
+                 + " < " + pduId;
+            Log.d(TAG, "deleteOldMmsDraft where : " + where);
+            delete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+
+    /// M: Code analyze 055, For bug ALPS00234739, Remove old Mms draft in
+    /// conversation list instead of compose view . @}
+    private void asyncDeleteOldMmsDraft(final long threadId) {
+        MessageUtils.addRemoveOldMmsThread(new Runnable() {
+            public void run() {
+                if (mMessageUri != null && threadId > 0) {
+                    String pduId = mMessageUri.getLastPathSegment();
+                    final String where = Mms.THREAD_ID + "=" + threadId + " and " + WordsTable.ID
+                            + " != " + pduId;
+                    delete(Mms.Draft.CONTENT_URI, where, null);
+                }
+            }
+        });
+    }
+    /// @}
+
+    /**
+     * Delete all drafts of current thread by threadId.
+     *
+     * @param threadId
+     */
+    public void asyncDeleteAllMmsDraft(final long threadId) {
+        if (threadId > 0) {
+            MmsLog.d(TAG, "asyncDeleteAllMmsDraft");
+            final String where = Mms.THREAD_ID + "=" + threadId;
+            asyncDelete(Mms.Draft.CONTENT_URI, where, null);
+        }
+    }
+
+    private WorkingMessage(Activity activity, MessageStatusListener l) {
+        mActivity = activity;
+        mContentResolver = mActivity.getContentResolver();
+        mStatusListener = l;
+        mAttachmentType = TEXT;
+        mText = "";
+        /// M: Code analyze 040, For bug ALPS00116011, the creation mode can't
+        /// take effect immediately after modify in settings Should update static
+        /// variable after peference is changed . @{
+        updateCreationMode(activity);
+        /// @}
+        mOpWorkingMessageExt = OpMessageUtils.getOpMessagePlugin().getOpWorkingMessageExt();
+        mOpWorkingMessageExt.initOpWorkingMessage(this);
+    }
+
+    public static WorkingMessage createEmpty(Activity activity, MessageStatusListener l) {
+        // Make a new empty working message.
+        WorkingMessage msg = new WorkingMessage(activity, l);
+        return msg;
+    }
+
+    public void setHasMmsDraft(boolean hasMmsDraft) {
+        mHasMmsDraft = hasMmsDraft;
+    }
+
+    public boolean checkSizeBeforeAppend() {
+        if (mSlideshow == null) {
+            return true;
+        }
+        mSlideshow.checkMessageSize(0);
+        return true;
+    }
+
+    private void removeSlideAttachments(SlideModel slide) {
+        slide.removeImage();
+        slide.removeVideo();
+        slide.removeAudio();
+
+        /// M: add for attachment enhance, For new feature ALPS00231349, add vCard support. @{
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    /// M: Code analyze 034, For new feature ALPS00231349, add vCard support . @{
+    public void removeAllFileAttaches() {
+        if (mSlideshow != null && mOpWorkingMessageExt.removeAllAttachFiles()) {
+            mSlideshow.removeAllAttachFiles();
+        }
+    }
+
+    public boolean hasMediaAttachments() {
+        if (mSlideshow == null) {
+            return false;
+        }
+        if (hasSlideshow()) {
+            return true;
+        }
+        final SlideModel slide = mSlideshow.get(0);
+        return (slide != null) && (slide.hasAudio() || slide.hasVideo() || slide.hasImage());
+    }
+
+
+
+    public boolean hasAttachedFiles() {
+        return mSlideshow != null && mSlideshow.sizeOfFilesAttach() > 0;
+    }
+
+    /// M: Code analyze 035, For bug ALPS00095817,  delete draft . @{
+    public synchronized void discard(boolean isDiscard) {
+        if (mActivity != null && !MmsConfig.isSmsEnabled(mActivity)) {
+            Log.d(TAG_DRAFT, "[discard] not default sms, cann't discard, just return!!");
+            return;
+        }
+
+        MmsLog.d(M_TAG, "discard(): Start. mConversation.ThreadId=" + mConversation.getThreadId()
+                + ", MessageCount=" + mConversation.getMessageCount());
+        if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
+            LogTag.debug("[WorkingMessage] discard");
+        }
+
+        if (mDiscarded) {
+            return;
+        }
+
+        // Mark this message as discarded in order to make saveDraft() no-op.
+        mDiscarded = isDiscard;
+        cancelThumbnailLoading();
+
+        // Delete any associated drafts if there are any.
+        if (mHasMmsDraft) {
+            asyncDeleteCurrentDraftMmsMessage(mConversation);
+        }
+        if (mHasSmsDraft) {
+            /// M: fix bug ALPS01471051, ensureThreadId before discard sms draft
+            if (mConversation.getThreadId() == 0) {
+                mConversation.ensureThreadId();
+                Log.d(TAG_DRAFT, "[discard] ensureThreadId before discard sms draft");
+            }
+            //M: Add for modify issue ALPS01812929
+            asyncDeleteDraftSmsMessage(mConversation, new Runnable() {
+                            public void run() {
+                                if (mConversation != null) {
+                                    mConversation.setDraftState(false);
+                                }
+                            }
+                        });
+        }
+        if (mConversation.getThreadId() > 0) {
+            clearConversation(mConversation, true);
+        }
+    }
+    /// @}
+
+    private void delete(final Uri uri, final String selection, final String[] selectionArgs) {
+        /// M: Code analyze 056, For bug ALPS00094352, to solve JE
+        /// of MMS occured when I received serveral SM  . @}
+        if (uri != null) {
+            int result = -1; // if delete is unsuccessful, the delete()
+            // method will return -1
+            int retryCount = 0;
+            int maxRetryCount = 10;
+            while (result == -1 && retryCount < maxRetryCount) {
+                try {
+                    result = SqliteWrapper.delete(mActivity,
+                            mContentResolver, uri, selection, selectionArgs);
+
+                } catch (SQLiteDiskIOException e) {
+                    MmsLog.e(TAG, "asyncDelete(): SQLiteDiskIOException:"
+                            + " delete thread unsuccessful! Try time=" + retryCount);
+                } finally {
+                    retryCount++;
+                }
+            }
+        }
+        /// @}
+    }
+
+    /// M: Code analyze 057, For bug ALPS00234653, to solve Can't continue
+    /// to play the vedio after share a video in mms . @}
+    private void asyncDeleteCurrentDraftMmsMessage(Conversation conv) {
+        mHasMmsDraft = false;
+
+        final long threadId = conv.getThreadId();
+        if (threadId > 0) {
+            final String where = Mms.THREAD_ID + " = " + threadId;
+
+            asyncDelete(mMessageUri, where, null, new Runnable() {
+                public void run() {
+                    if (mConversation != null) {
+                        mConversation.setDraftState(false);
+                    }
+                }
+            });
+
+            // / @}
+            mMessageUri = null;
+        } else if (mMessageUri != null) {
+            asyncDelete(mMessageUri, null, null);
+            mMessageUri = null;
+        }
+    }
+    /// @}
+
+    ///M: add for fix ALPS00452425 @{
+    private void asyncDelete(final Uri uri, final String selection,
+            final String[] selectionArgs, final Runnable r) {
+
+        new Thread(new Runnable() {
+            public void run() {
+                delete(uri, selection, selectionArgs);
+                MmsLog.dpi(TAG, "delete finish, uri = " + uri);
+                if (r != null) {
+                    r.run();
+                }
+            }
+        }, "WorkingMessage.asyncDelete2").start();
+    }
+    /// @}
+
+    /// M Fix CR : ALPS01071659
+    /// First group message, save a mms draft,which only contain text,
+    /// back to conversationlist ,change to not normal message,
+    /// the enter the mms draft send the message,
+    /// back to conversationlist, the group mms draft still there
+    /// when loafFinished, call this to delete the mms draft
+    /// which is not group message, and only contains text @{
+    public void deleteGruoupMmsDraft() {
+        if (mActivity != null && MmsConfig.isSmsEnabled(mActivity)) {
+            if (!MmsPreferenceActivity.getIsGroupMmsEnabled(mActivity)
+                    && mConversation.getRecipients().size() > 1
+                    && mMmsState != RECIPIENTS_REQUIRE_MMS) {
+                if (!hasAttachedFiles() && !hasSlideshow() && !hasAttachment()
+                         && !hasMediaAttachments() && !hasSubject()) {
+                    asyncDeleteDraftMmsMessage(mConversation);
+                    clearConversation(mConversation, true);
+                }
+            }
+        }
+    }
+    /// @}
+
+    /// M: fix bug ALPS00712509, show toast when paste many word and > 300k
+    private boolean mIsExceedSize;
+
+    public boolean isExceedSize() {
+        return mIsExceedSize;
+    }
+
+    public void setIsExceedSize(boolean isExceedSize) {
+        mIsExceedSize = isExceedSize;
+    }
+    /// @}
+
+    private boolean mIsUpdateAttachEditor = true;
+
+    public boolean getIsUpdateAttachEditor() {
+        if (!mIsUpdateAttachEditor) {
+            MmsLog.d(TAG, "mIsUpdateAttachEditor == false");
+        }
+        return mIsUpdateAttachEditor;
+    }
+
+    public void setIsUpdateAttachEditor(boolean update) {
+        mIsUpdateAttachEditor = update;
+    }
+
+    /// M: fix bug ALPS01265824, need remove FileAttachment when text + attachmentSize > limit
+    public boolean isRemoveFileAttachment() {
+        if (mSlideshow != null
+                && mSlideshow.getCurrentSlideshowSize() > MmsConfig.getUserSetMmsSizeLimit(true)) {
+            return true;
+        }
+        return false;
+    }
+
+    // Add for IpMessage callback
+    public boolean requiresIpMms() {
+        return requiresMms();
+    }
+
+    public void setIpText(CharSequence s) {
+        setText(s);
+    }
+
+    public CharSequence getIpText() {
+        return getText();
+    }
+
+    public void syncWorkingIpRecipients() {
+        syncWorkingRecipients();
+    }
+
+    public void setIpSubject(CharSequence s, boolean notify) {
+        setSubject(s, notify);
+    }
+
+    public boolean hasDrmMedia() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMedia();
+    }
+
+    public boolean hasDrmMediaRight() {
+        return mSlideshow == null ? false : mSlideshow.hasDrmMediaRight();
+    }
+
+    public IWorkingMessageCallback loadCallback(Object activity, Uri uri) {
+        return load((ComposeMessageActivity) activity, uri);
+    }
+
+    public boolean hasMediaAttachmentsCallback() {
+        return hasMediaAttachments();
+    }
+
+    public void removeAllFileAttachesCallback() {
+        removeAllFileAttaches();
+    }
+
+    public int getState() {
+        return mMmsState;
+    }
+
+    public void correctAttachmentStateCallback() {
+        correctAttachmentState();
+    }
+
+    public boolean isIpWorthSaving() {
+        return isWorthSaving();
+    }
+
+    public CharSequence getIpSubject() {
+        return getSubject();
+    }
+
+    public void onAttachmentChangedCallback() {
+        mStatusListener.onAttachmentChanged();
+    }
+
+    public void discardCallback() {
+        discard();
+    }
+
+    public void updateStateExt(int state, boolean on, boolean notify) {
+        updateState(state, on, notify);
+    }
+
+    public void setLengthRequiresMmsCallback(boolean mmsRequired, boolean notify) {
+        setLengthRequiresMms(mmsRequired, notify);
+    }
+}
Index: vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java
===================================================================
--- vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java	(revision 0)
+++ vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/src/com/mediatek/mms/ui/DialogModeActivity.java	(revision 4302)
@@ -0,0 +1,2424 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.mediatek.mms.ui;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Service;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Configuration;
+import android.database.Cursor;
+import android.database.sqlite.SqliteWrapper;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.ServiceManager;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds;
+import android.provider.ContactsContract.Data;
+import android.provider.Settings;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.text.method.TextKeyListener;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.mms.MmsApp;
+import com.android.mms.MmsConfig;
+import com.android.mms.R;
+import com.android.mms.data.Contact;
+import com.android.mms.data.ContactList;
+import com.android.mms.data.Conversation;
+import com.android.mms.data.WorkingMessage;
+import com.android.mms.data.WorkingMessage.MessageStatusListener;
+import com.android.mms.model.SlideModel;
+import com.android.mms.model.SlideshowModel;
+import com.android.mms.model.TextModel;
+import com.android.mms.transaction.MessagingNotification;
+import com.android.mms.ui.AsyncDialog;
+import com.android.mms.ui.ComposeMessageActivity;
+import com.android.mms.ui.MessageUtils;
+import com.android.mms.ui.MsgContentSlideView;
+import com.android.mms.ui.MsgContentSlideView.MsgContentSlideListener;
+import com.android.mms.ui.Presenter;
+import com.android.mms.ui.PresenterFactory;
+import com.android.mms.ui.SlideViewInterface;
+import com.android.mms.ui.SubSelectDialog;
+import com.android.mms.ui.VideoAttachmentView;
+import com.android.mms.ui.MsgNumSlideview.MsgNumBarSlideListener;
+import com.android.mms.ui.SubSelectDialog.SubClickAndDismissListener;
+import com.android.mms.util.AddressUtils;
+import com.android.mms.util.DraftCache;
+import com.android.mms.util.MessageResource;
+import com.android.mms.util.MmsContentType;
+import com.android.mms.util.MmsLog;
+import com.android.mms.widget.MmsWidgetProvider;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.MultimediaMessagePdu;
+import com.google.android.mms.pdu.NotificationInd;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduPersister;
+
+import com.mediatek.internal.telephony.CellConnMgr;
+import com.mediatek.internal.telephony.DefaultSmsSimSettings;
+import com.mediatek.ipmsg.util.IpMessageUtils;
+import com.mediatek.mms.callback.IDialogModeActivityCallback;
+import com.mediatek.mms.ext.IOpDialogModeActivityExt;
+import com.mediatek.mms.folder.util.FolderModeUtils;
+import com.mediatek.mms.ipmessage.IIpDialogModeActivityExt;
+import com.mediatek.mms.model.FileAttachmentModel;
+import com.mediatek.mms.util.PermissionCheckUtil;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.setting.MmsPreferenceActivity;
+
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Map;
+/** M:
+ * Dialog mode
+ */
+public class DialogModeActivity extends Activity implements
+    MsgNumBarSlideListener,
+    MsgContentSlideListener,
+    OnClickListener,
+    SlideViewInterface,
+    MessageStatusListener,
+    SubClickAndDismissListener,
+    IDialogModeActivityCallback {
+
+    private int mCurUriIdx;
+    private Uri mCurUri;
+    //private MsgNumSlideview mMsgNumBar;
+    private ImageButton mLeftArrow;
+    private ImageButton mRightArrow;
+    private TextView mMsgNumText;
+    private TextView mSender;
+    //private MsgContentSlideView mContentLayout;
+    private TextView mSmsContentText;
+    private TextView mRecvTime;
+    private TextView mSubName;
+    private ImageView mContactImage;
+    private View mMmsView;
+    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+    private View mMmsAttachView;
+    private ImageView mMmsAttachImageView;
+    private TextView mAttachName;
+    private TextView mAttachSize;
+    /// @}
+    private ImageView mMmsImageView;
+    private ImageButton mMmsPlayButton;
+    private EditText mReplyEditor;
+    private ImageButton mSendButton;
+    private TextView mTextCounter;
+    private Button mCloseBtn;
+    private Button mDeleteBtn;
+    //private ImageButton mCloseBtn;
+    private AsyncDialog mAsyncDialog;   // Used for background tasks.
+    private Cursor mCursor;
+    //private boolean mWaitingForSubActivity;
+    private DialogModeReceiver mReceiver;
+    private boolean mContentViewSet;
+    private AlertDialog mSubSelectDialog;
+    private int mAssociatedSubId;
+    private int mSelectedSubId;
+    private WorkingMessage mWorkingMessage;
+    private boolean mSendingMessage;
+    private boolean mWaitingForSendMessage;
+    private int mSubCount;
+    private int[] mSubIdList;
+    private static Drawable sDefaultContactImage;
+
+    private int mPage = MmsConfig.getSmsToMmsTextThreshold();
+
+    private static final String TAG = "Mms/DialogMode";
+    private static final int SMS_ID = 0;
+    private static final int SMS_TID = 1;
+    private static final int SMS_ADDR = 2;
+    private static final int SMS_DATE = 3;
+    private static final int SMS_READ = 4;
+    private static final int SMS_BODY = 5;
+    private static final int SMS_SUB = 6;
+    private static final int SMS_TYPE = 7;
+    private static final String TYPE_MMS = "mms";
+    private static final String TYPE_SMS = "sms";
+    private static final int REQUEST_CODE_ECM_EXIT_DIALOG = 107;
+    private static final String EXIT_ECM_RESULT = "exit_ecm_result";
+    private static final String SELECT_TYPE = "Select_type";
+    private static final int SIM_SELECT_FOR_SEND_MSG = 1;
+    /// M: see this time out use place comment about it's usage.
+    private static final int DRAW_OVER_TIME_OUT = 100;
+
+    private static final String UNREAD_SELECTION = "(read=0 OR seen=0)";
+
+    private static final int FLAG_HOMEKEY_DISPATCHED = 0X80000000;
+    /// M: fix bug ALPS00446919, merge back from ALPS.JB2.MP to ALPS.JB2
+    //private final ArrayList<Uri> mUris;
+    private ArrayList<Uri> mUris;
+    private ArrayList<String> mReplyContent;
+
+    /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+    private TextView mGroupMmsSender;
+    private boolean mIsGroupMms;
+
+    private boolean mHasRegisterReceiver = false;
+    // M: add for OP
+    private IOpDialogModeActivityExt mOpDialogModeActivityExt;
+
+    private View mIpView;
+
+    Runnable mResetMessageRunnable = new Runnable() {
+        public void run() {
+            if(mUris!= null && !mUris.isEmpty()){
+                MmsLog.d(TAG, "mResetMessageRunnable.run");
+                resetMessage();
+            }
+        }
+    };
+
+    Runnable mMessageSentRunnable = new Runnable() {
+        public void run() {
+            MmsLog.d(TAG, "mMessageSentRunnable.run");
+            String body = getString(R.string.strOk);
+            MmsLog.dpi(TAG, "string=" + body);
+            Toast.makeText(getApplicationContext(), body, Toast.LENGTH_SHORT).show();
+        }
+    };
+
+    private final TextWatcher mTextEditorWatcher = new TextWatcher() {
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            return;
+        }
+
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            MmsLog.d(TAG, "mTextEditorWatcher.onTextChanged");
+            // mWorkingMessage.setText(s);
+            updateSendButtonState();
+            updateCounter(s, start, before, count);
+            if (mReplyContent.size() != 0) {
+                mReplyContent.set(mCurUriIdx, s.toString());
+            }
+        }
+
+        public void afterTextChanged(Editable s) {
+            return;
+        }
+    };
+
+    /// M:
+    private ArrayList<Uri> mReadedUris;
+    /** M: this variable is used for a special issue. when use click mms's play button,
+     *  MmsPlayerActivity will be started, and close this activity.
+     *  but the invocation is async, so this activity's finish will be call first.
+     *  when framework started MmsPlayerActivity it will check the invoking activity,
+     *  because this activity is finishing, the new created activity will not put in front.
+     *  so add this flag to control finish activity in onStop.
+     */
+    private boolean mNeedFinish = false;
+
+    private int[] mParams = new int[4];
+    private boolean mReachMax = true;
+
+    private IIpDialogModeActivityExt mIpDialogModeActivity;
+
+    public DialogModeActivity() {
+        mUris = new ArrayList<Uri>();
+        mReplyContent = new ArrayList<String>();
+        mReadedUris = new ArrayList<Uri>();
+
+        mCurUriIdx = 0;
+        mCurUri = null;
+        mCursor = null;
+        mMmsView = null;
+        mMmsImageView = null;
+        mMmsPlayButton = null;
+        //mCellMgr = null;
+        mReceiver = null;
+        mContentViewSet = false;
+        mWorkingMessage = null;
+        //mWaitingForSubActivity = false;
+        /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+        mMmsAttachView = null;
+        mMmsAttachImageView = null;
+        mAttachName = null;
+        mAttachSize = null;
+        /// @}
+
+        // add for ipmessage
+        mIpDialogModeActivity = IpMessageUtils.getIpMessagePlugin(this).getIpDialogModeActivity();
+    }
+
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (PermissionCheckUtil.requestRequiredPermissions(this)) {
+            return;
+        }
+        if (DraftCache.getInstance() == null) {
+            MmsApp.getApplication().onRequestPermissionsResult();
+        }
+
+        // add for op
+        mOpDialogModeActivityExt =
+            OpMessageUtils.getOpMessagePlugin().getOpDialogModeActivityExt();
+        mOpDialogModeActivityExt.setHost(this);
+
+        /// M: do not finish activity when touch outside
+        setFinishOnTouchOutside(false);
+        //getWindow().setFlags(FLAG_HOMEKEY_DISPATCHED,FLAG_HOMEKEY_DISPATCHED);
+
+        MmsLog.d(TAG, "DialogModeActivity.onCreate");
+        addNewUri(getIntent());
+        if (loadCurMsg() != null) {
+            initDialogView();
+            setDialogView();
+            resetMessage();
+        }
+
+        registerReceiver();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        MmsLog.d(TAG, "DialogModeActivity.onResume()");
+        /** M: mReplyEditor.getLineCount() is not right when it is invoked during onCreate.
+         *  in tablet, rotate screen will restore text in EditText, and trigger onTextChanged,
+         *  in the triggered onTextChanged the getLineCount() is still not right.
+         *  even in onResume, getLineCount() is not ensured right.
+         *  the function is right after the layout is drawn. But drawn over no callback.
+         *  so the work around is to check the line count after a millseconds later.
+         *  If the feature hide count when only one line is removed, this code can remove.
+         */
+        if (mOpDialogModeActivityExt.onResume()) {
+            return;
+        }
+
+        Handler tempHandler = new Handler();
+        tempHandler.postDelayed(new Runnable() {
+            public void run() {
+                if (mTextCounter != null && mReplyEditor != null
+                        && mReplyEditor.getLineCount() > 1) {
+                    /// M: the content is set right in onTextChanged. It is just not visible.
+                    mTextCounter.setVisibility(View.VISIBLE);
+                }
+            }
+        }, DRAW_OVER_TIME_OUT);
+    }
+
+    private void registerReceiver() {
+        MmsLog.d(TAG, "DialogModeActivity.registerReceiver");
+        /// M: fix bug ALPS00517135, update sim state dynamically;
+        IntentFilter intentFilter
+                = new IntentFilter(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
+        registerReceiver(mSimReceiver, intentFilter);
+        mHasRegisterReceiver = true;
+        if (mReceiver != null) {
+            return;
+        }
+        mReceiver = new DialogModeReceiver();
+        IntentFilter filter = new IntentFilter("com.android.mms.dialogmode.VIEWED");
+        registerReceiver(mReceiver, filter);
+    }
+
+    private void unRegisterReceiver() {
+        MmsLog.d(TAG, "DialogModeActivity.unRegisterReceiver");
+        /// M: fix bug ALPS00517135, update sim state dynamically
+        if (mHasRegisterReceiver) {
+            mHasRegisterReceiver = false;
+            unregisterReceiver(mSimReceiver);
+            mSimReceiver = null;
+        }
+        if (mReceiver != null) {
+            unregisterReceiver(mReceiver);
+            mReceiver = null;
+        }
+    }
+    @Override
+    protected void onDestroy() {
+        MmsLog.d(TAG, "DialogModeActivity.onDestroy");
+
+        if (!PermissionCheckUtil.checkRequiredPermissions(this)) {
+            super.onDestroy();
+            return;
+        }
+
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        unRegisterReceiver();
+
+        mIpDialogModeActivity.onIpDestroy();
+        /// M: update widget
+        MmsWidgetProvider.notifyDatasetChanged(getApplicationContext());
+        super.onDestroy();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        MmsLog.d(TAG, "DialogModeActivity.onSaveInstanceState");
+        PowerManager powerManager = (PowerManager) getSystemService(Service.POWER_SERVICE);
+        if (!powerManager.isScreenOn()) {
+            MmsLog.d(TAG, "onSaveInstanceState not ScreenOn");
+            return;
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        MmsLog.d(TAG, "DialogModeActivity.onNewIntent");
+        super.onNewIntent(intent);
+        setIntent(intent);
+        String newString = intent.getStringExtra("com.android.mms.transaction.new_msg_uri");
+        if (mCurUri != null && newString != null) {
+            if (!newString.equals(mCurUri.toString())) {
+                addNewUri(intent);
+            } else {
+                MmsLog.d(TAG, "DialogModeActivity.new Uri = current Uri , don't add NewUri ");
+            }
+        }
+        loadCurMsg();
+        initDialogView();
+        setDialogView();
+//        if (mCellMgr == null) {
+//            mCellMgr = new CellConnMgr();
+//            mCellMgr.register(getApplication());
+//        }
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        MmsLog.dpi(TAG, "DialogModeActivity.onActivityResult, requestCode=" + requestCode
+            + ", resultCode=" + resultCode + ", data=" + data);
+        if (resultCode != RESULT_OK) {
+            MmsLog.w(TAG, "fail due to resultCode=" + resultCode);
+            return;
+        }
+
+        if (requestCode == REQUEST_CODE_ECM_EXIT_DIALOG) {
+                boolean outOfEmergencyMode = data.getBooleanExtra(EXIT_ECM_RESULT, false);
+                MmsLog.d(TAG, "REQUEST_CODE_ECM_EXIT_DIALOG, mode=" + outOfEmergencyMode);
+                if (outOfEmergencyMode) {
+                    sendMessage(false);
+                }
+        } else {
+                MmsLog.d(TAG, "bail due to unknown requestCode=" + requestCode);
+        }
+    }
+
+    @Override
+    public void startActivityForResult(Intent intent, int requestCode) {
+        MmsLog.d(TAG, "DialogModeActivity.startActivityForResult");
+        super.startActivityForResult(intent, requestCode);
+    }
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        MmsLog.d(TAG, "onConfigurationChanged is called");
+        super.onConfigurationChanged(newConfig);
+
+    }
+    private AsyncDialog getAsyncDialog() {
+        if (mAsyncDialog == null) {
+            mAsyncDialog = new AsyncDialog(this);
+        }
+        return mAsyncDialog;
+    }
+    private void resetMessage() {
+        MmsLog.d(TAG, "DialogModeActivity.resetMessage");
+
+        // We have to remove the text change listener while the text editor gets cleared and
+        // we subsequently turn the message back into SMS. When the listener is listening while
+        // doing the clearing, it's fighting to update its counts and itself try and turn
+        // the message one way or the other.
+        mReplyEditor.removeTextChangedListener(mTextEditorWatcher);
+        // Clear the text box.
+        TextKeyListener.clear(mReplyEditor.getText());
+
+        if (mWorkingMessage != null) {
+            MmsLog.d(TAG, "clear working message");
+            mWorkingMessage = null;
+        }
+        updateSendButtonState();
+        mReplyEditor.addTextChangedListener(mTextEditorWatcher);
+        //mReplyEditor.setText("");
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+        } else {
+            mReplyEditor.setText("");
+        }
+        mSendingMessage = false;
+    }
+
+    public void onProtocolChanged(boolean mms, boolean needToast) {
+        MmsLog.d(TAG, "DialogModeActivity.onProtocolChanged");
+    }
+
+    public void onAttachmentChanged() {
+        MmsLog.d(TAG, "DialogModeActivity.onAttachmentChanged");
+    }
+
+    public void onPreMmsSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onPreMmsSent");
+    }
+
+    public void onMaxPendingMessagesReached() {
+        MmsLog.d(TAG, "DialogModeActivity.onMaxPendingMessagesReached");
+    }
+
+    public void onAttachmentError(int error) {
+        MmsLog.d(TAG, "DialogModeActivity.onAttachmentError");
+    }
+
+    private void addNewUri(Intent intent) {
+        if (intent == null) {
+            return;
+        }
+        String newString = intent.getStringExtra("com.android.mms.transaction.new_msg_uri");
+        MmsLog.dpi(TAG, "DialogModeActivity.addNewUri, new uri=" + newString);
+        Uri newUri = Uri.parse(newString);
+        mUris.add(mUris.size(), newUri);
+        mReplyContent.add(mReplyContent.size(), null);
+        mCurUriIdx = mUris.size() - 1;
+        MmsLog.d(TAG, "new index=" + mCurUriIdx);
+        // add for ipmessage
+        mIpDialogModeActivity.onIpAddNewUri(intent, newUri);
+    }
+
+    private void initDialogView() {
+        MmsLog.d(TAG, "DialogModeActivity.initDialogView");
+        if (mContentViewSet) {
+            MmsLog.d(TAG, "have init");
+            return;
+        }
+        setContentView(R.layout.msg_dlg_activity);
+        mContentViewSet = true;
+        updateSubInfoList();
+        mLeftArrow = (ImageButton) findViewById(R.id.previous);
+        mLeftArrow.setOnClickListener(this);
+        mRightArrow = (ImageButton) findViewById(R.id.next);
+        mRightArrow.setOnClickListener(this);
+        mMsgNumText = (TextView) findViewById(R.id.msg_counter);
+        mSender = (TextView) findViewById(R.id.recepient_name);
+        TextView groupSender = (TextView) findViewById(R.id.group_sender);
+        Typeface tf = Typeface.create(Typeface.SANS_SERIF, Typeface.NORMAL);
+        if (tf != null) {
+            mSender.setTypeface(tf);
+        }
+        MsgContentSlideView contentLayout;
+        contentLayout = (MsgContentSlideView) findViewById(R.id.content_scroll_view);
+        contentLayout.registerFlingListener(this);
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+        mGroupMmsSender = (TextView) findViewById(R.id.group_mms_sender);
+        mSmsContentText = (TextView) findViewById(R.id.msg_content);
+        if (tf != null) {
+            mSmsContentText.setTypeface(tf);
+        }
+        mRecvTime = (TextView) findViewById(R.id.msg_recv_timer);
+        if (tf != null) {
+            mRecvTime.setTypeface(tf);
+        }
+
+        LinearLayout simInfo = (LinearLayout) findViewById(R.id.sim_info_linear);
+        simInfo.setVisibility(View.VISIBLE);
+
+        mSubName = (TextView) findViewById(R.id.sub_name);
+        mSubName.setVisibility(View.VISIBLE);
+        if (tf != null) {
+            mSubName.setTypeface(tf);
+        }
+        mContactImage = (ImageView) findViewById(R.id.contact_img);
+        sDefaultContactImage = getApplicationContext().getResources().getDrawable(
+            R.drawable.ic_default_contact);
+        mReplyEditor = (EditText) findViewById(R.id.embedded_reply_text_editor);
+        mReplyEditor.addTextChangedListener(mTextEditorWatcher);
+        mReplyEditor
+                .setFilters(new InputFilter[] {new TextLengthFilter(MmsConfig.getMaxTextLimit())});
+
+        mSendButton = (ImageButton) findViewById(R.id.reply_send_button);
+        mSendButton.setOnClickListener(this);
+        mTextCounter = (TextView) findViewById(R.id.text_counter);
+        mCloseBtn = (Button) findViewById(R.id.mark_as_read_btn);
+        mCloseBtn.setOnClickListener(this);
+        mDeleteBtn = (Button) findViewById(R.id.delete_btn);
+        mDeleteBtn.setOnClickListener(this);
+        //mReplyEditor.setText("");
+        MmsLog.d(TAG, "mCurUriIdx" + mCurUriIdx);
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+            MmsLog.dpi(TAG, "content" + content);
+        }
+        mIpView = (View) findViewById(R.id.ip_view);
+
+        // add for ipmessage
+        mIpDialogModeActivity.onIpInitDialogView(this, mUris, mMmsView, mCursor, this,
+                mReplyEditor, mSmsContentText, mIpView, mGroupMmsSender, mContactImage);
+
+        /// M: add for op
+        mOpDialogModeActivityExt.initDialogView(mSubName,
+                (Button) findViewById(R.id.msg_dlg_mms_download_button), mRecvTime,
+                (TextView) findViewById(R.id.send_time_txt),
+                (LinearLayout) findViewById(R.id.double_time_layout),
+                (LinearLayout) this.findViewById(R.id.button_and_counter),
+                (TextView) findViewById(R.id.ct_text_dlg_counter), mCursor);
+    }
+    private void setDialogView() {
+        // Msg count bar
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.setDialogView msgNum" + msgNum);
+        if (msgNum <= 1) {
+            mLeftArrow.setVisibility(View.INVISIBLE);
+            mRightArrow.setVisibility(View.INVISIBLE);
+            mMsgNumText.setVisibility(View.INVISIBLE);
+        } else {
+            mLeftArrow.setVisibility(View.VISIBLE);
+            mRightArrow.setVisibility(View.VISIBLE);
+            mMsgNumText.setVisibility(View.VISIBLE);
+            StringBuilder msgNumStrBuilder = new StringBuilder("");
+            msgNumStrBuilder.append(mCurUriIdx + 1);
+            msgNumStrBuilder.append('/');
+            msgNumStrBuilder.append(msgNum);
+            String msgNumStr = msgNumStrBuilder.toString();
+            MmsLog.dpi(TAG, "msgNumStr" + msgNumStr);
+            mMsgNumText.setText(msgNumStr);
+        }
+        if (mReplyContent.size() != 0) {
+            String content = mReplyContent.get(mCurUriIdx);
+            mReplyEditor.setText(content);
+            mReplyEditor.setSelection(mReplyEditor.getText().length());
+        }
+        mSender.setText(getSenderString());
+        mSmsContentText.setText(getSmsContent());
+        mRecvTime.setText(getReceivedTime());
+
+        /// M: add for OP
+        mOpDialogModeActivityExt.setDialogView(getApplicationContext(),
+                getCurrentSubId(), isCurSMS(), mCursor != null ? mCursor.getInt(SMS_TYPE) : -1,
+                        getSentTime(), getReceivedTime(), (ImageView) findViewById(R.id.sub_icon));
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+        if (mIsGroupMms) {
+            mContactImage.setImageDrawable(sDefaultContactImage);
+        } else {
+            Drawable image = getContactImage();
+            if (image != null) {
+                mContactImage.setImageDrawable(image);
+            }
+        }
+
+        if (isCurSMS()) {
+            if (mMmsView != null) {
+                MmsLog.d(TAG, "Hide MMS views");
+                mMmsView.setVisibility(View.GONE);
+            }
+            if (mMmsAttachView != null) {
+                MmsLog.d(TAG, "Hide MMS vcard or vcalendar views");
+                mMmsAttachView.setVisibility(View.GONE);
+            }
+            if (mSmsContentText != null) {
+                mSmsContentText.setVisibility(View.VISIBLE);
+            }
+        } else if (isCurMMS()) {
+           MmsLog.d(TAG, "a MMS");
+           loadMmsView();
+        }
+
+        // add for ipmessage
+        String simCharSequence = mIpDialogModeActivity.onIpSetDialogView();
+        MessageUtils.setSubIconAndLabel(getCurrentSubId(), simCharSequence, mSubName);
+        updateSendButtonState();
+    }
+
+    public void onSlideToPrev() {
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToPrev, msgNum=" + msgNum);
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToPrev, mCurUriIdx=" + mCurUriIdx);
+        if (msgNum <= 1) {
+            return;
+        }
+        if (mCurUriIdx == 0) {
+            return;
+        }
+        if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+            MmsLog.dpi(TAG, "DialogModeActivity.onSlideToPrev, mCurUri=" + mCurUri.toString());
+            mReadedUris.add(mCurUri);
+        }
+        mCurUriIdx--;
+        loadCurMsg();
+        setDialogView();
+    }
+
+    public void onSlideToNext() {
+        int msgNum = mUris.size();
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToNext, msgNum=" + msgNum);
+        MmsLog.d(TAG, "DialogModeActivity.onSlideToNext, mCurUriIdx=" + mCurUriIdx);
+        if (msgNum <= 1) {
+            return;
+        }
+        if (mCurUriIdx == (msgNum - 1)) {
+            return;
+        }
+        if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+            MmsLog.dpi(TAG, "DialogModeActivity.onSlideToNext, mCurUri=" + mCurUri.toString());
+            mReadedUris.add(mCurUri);
+        }
+        mCurUriIdx++;
+        loadCurMsg();
+        setDialogView();
+    }
+
+    private boolean isCurSMS() {
+        MmsLog.d(TAG, "DialogModeActivity.isCurSMS");
+        if (judgeParameterIsOk() == false) {
+            return false;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        String type = mCurUri.getAuthority();
+        MmsLog.d(TAG, "type=" + type);
+        if (type.equals(TYPE_SMS)) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isCurMMS() {
+        MmsLog.d(TAG, "DialogModeActivity.isCurMMS");
+        if (judgeParameterIsOk() == false) {
+            return false;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        String type = mCurUri.getAuthority();
+        MmsLog.d(TAG, "type=" + type);
+        if (type.equals(TYPE_MMS)) {
+            return true;
+        }
+        return false;
+    }
+
+    private Cursor loadCurMsg() {
+        MmsLog.d(TAG, "DialogModeActivity.loadCurMsg, idx=" + mCurUriIdx);
+        if (judgeParameterIsOk() == false) {
+            return null;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        MmsLog.dpi(TAG, "uri=" + mCurUri.toString());
+        String projection[];
+        if (isCurSMS()) {
+            projection = new String[] {"_id", "thread_id", "address", "date", "read", "body",
+                "sub_id", "date_sent"};
+        } else {
+            projection = new String[] {"_id", "thread_id", "null as address", "date", "read",
+                "sub", "sub_id", "m_type", "date_sent"};
+        }
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        Cursor cursor = mIpDialogModeActivity.loadCurMsg(mCurUri, projection, UNREAD_SELECTION);
+        if (cursor == null) {
+            cursor = getContentResolver().query(mCurUri, projection, UNREAD_SELECTION, null,
+                    null);
+        }
+        if (cursor == null) {
+            MmsLog.d(TAG, "no msg found");
+            mCursor = null;
+            finish();
+            return null;
+        }
+        /// M: this is a invalid uri, load the next.
+        if (cursor.getCount() == 0) {
+            cursor.close();
+            mUris.remove(mCurUriIdx);
+            mReplyContent.remove(mCurUriIdx);
+            if (mUris.size() > 0) {
+                if (mCurUriIdx == mUris.size()) {
+                    mCurUriIdx = mUris.size() - 1;
+                    MmsLog.d(TAG, "load next new index=" + mCurUriIdx);
+                }
+                return loadCurMsg();
+            }
+            finish();
+            return null;
+        }
+
+        mCursor = cursor;
+        return cursor;
+    }
+    private boolean judgeParameterIsOk() {
+        if (mUris.size() <= 0 || mCurUriIdx >= mUris.size()
+                || (Uri) mUris.get(mCurUriIdx) == null) {
+            if (mCursor != null) {
+                mCursor.close();
+            }
+            mCursor = null;
+            mCurUri = null;
+            mCurUriIdx = 0;
+            finish();
+            return false;
+        } else {
+            return true;
+        }
+    }
+    private void removeCurMsg() {
+        MmsLog.d(TAG, "DialogModeActivity.removeCurMsg");
+        if (judgeParameterIsOk() == false) {
+            return;
+        }
+        mCurUri = (Uri) mUris.get(mCurUriIdx);
+        MmsLog.dpi(TAG, "uri=" + mCurUri.toString());
+        MmsLog.d(TAG, "mCurUriIdx=" + mCurUriIdx);
+        mUris.remove(mCurUriIdx);
+        mReplyContent.remove(mCurUriIdx);
+        if (mCurUriIdx != 0) {
+            mCurUriIdx--;
+        }
+        if (mUris.isEmpty()) {
+            MmsLog.d(TAG, "no msg");
+            finish();
+            return;
+        }
+        loadCurMsg();
+        setDialogView();
+    }
+    private String getSenderString() {
+        MmsLog.d(TAG, "DialogModeActivity.getSenderString");
+        if (mCursor == null || mCursor.isClosed()) {
+            MmsLog.d(TAG, "mCursor null");
+            mCursor = null;
+            return "";
+        }
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpGetSenderString() != null) {
+            return mIpDialogModeActivity.onIpGetSenderString();
+        }
+        if (mCursor.moveToFirst()) {
+            if (isCurSMS()) {
+                String recipientIds = mCursor.getString(SMS_ADDR);
+                ContactList recipients;
+                recipients = ContactList.getByNumbers(recipientIds, false, true);
+                // MmsLog.d(TAG, "recipients=" + recipientIds);
+                MmsLog.dpi(TAG, "recipients=" + recipients.formatNames(", "));
+                return recipients.formatNames(", ");
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return "";
+                }
+                ContactList recipients = conv.getRecipients();
+                /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+                mIsGroupMms = MmsPreferenceActivity.getIsGroupMmsEnabled(DialogModeActivity.this)
+                                            && recipients.size() > 1;
+                MmsLog.dpi(TAG, "recipients=" + recipients.formatNames(", "));
+                return recipients.formatNames(", ");
+            }
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getSenderNumber() {
+        MmsLog.d(TAG, "DialogModeActivity.getSenderNumber");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return "";
+        }
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpGetSenderNumber() != null) {
+            return mIpDialogModeActivity.onIpGetSenderNumber();
+        }
+        if (mCursor.moveToFirst()) {
+            if (isCurSMS()) {
+                String addr = mCursor.getString(SMS_ADDR);
+                MmsLog.dpi(TAG, "addr=" + addr);
+                return addr;
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return "";
+                }
+                ContactList recipients = conv.getRecipients();
+                String[] numbers = recipients.getNumbers();
+
+                if (numbers != null && numbers.length != 0) {
+                    MmsLog.dpi(TAG, "number0=" + numbers[0]);
+                    return numbers[0];
+                } else {
+                    MmsLog.d(TAG, "empty number");
+                    return "";
+                }
+            }
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getSmsContent() {
+        MmsLog.d(TAG, "DialogModeActivity.getSmsContent");
+        if (!isCurSMS() || mCursor == null) {
+            return "";
+        }
+        if (mCursor.moveToFirst()) {
+            String content = mCursor.getString(SMS_BODY);
+            MmsLog.dpi(TAG, "content=" + content);
+            return content;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return "";
+        }
+    }
+
+    private String getReceivedTime() {
+        MmsLog.d(TAG, "DialogModeActivity.getReceivedTime");
+        ///M: add for ipmessage
+        String time = mIpDialogModeActivity.getReceivedTime(getApplicationContext(), mCursor);
+        if (!TextUtils.isEmpty(time)) {
+            return time;
+        }
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            long date = mCursor.getLong(SMS_DATE);
+            String strDate;
+            if (isCurSMS()) {
+                strDate = MessageUtils.formatTimeStampString(getApplicationContext(), date);
+            } else {
+                strDate =
+                    MessageUtils.formatTimeStampString(getApplicationContext(), date * 1000L);
+            }
+            MmsLog.d(TAG, "date=" + strDate);
+            builder.append(strDate);
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private String getSentTime() {
+        MmsLog.d(TAG, "DialogModeActivity.getReceivedTime");
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            long date = mCursor.getLong(mCursor.getColumnCount() - 1);
+            String strDate;
+            if (isCurSMS()) {
+                strDate = MessageUtils.formatTimeStampString(getApplicationContext(), date);
+            } else {
+                strDate =
+                    MessageUtils.formatTimeStampString(getApplicationContext(), date * 1000L);
+            }
+            MmsLog.d(TAG, "sentDate=" + strDate);
+            builder.append(strDate);
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private int getCurrentSubId() {
+        int subId = -1;
+        if (mCursor == null) {
+            return subId;
+        }
+        if (mCursor.moveToFirst()) {
+            subId = mCursor.getInt(SMS_SUB);
+        }
+        MmsLog.d(TAG, "getCurrentSubId:" + subId);
+        return subId;
+    }
+
+    private String getSIMName() {
+        MmsLog.d(TAG, "DialogModeActivity.getSIMName");
+        StringBuilder builder = new StringBuilder("");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return builder.toString();
+        }
+        if (mCursor.moveToFirst()) {
+            int subId = mCursor.getInt(SMS_SUB);
+            MmsLog.d(TAG, "subId=" + subId);
+            SubscriptionInfo subInfo = SubscriptionManager.from(MmsApp.getApplication())
+                    .getActiveSubscriptionInfo(subId);
+            builder.append(subInfo.getDisplayName().toString());
+            return builder.toString();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return builder.toString();
+        }
+    }
+
+    private int getSIMColor() {
+        MmsLog.d(TAG, "DialogModeActivity.getSIMColor");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return MessageResource.drawable.sim_background_locked;
+        }
+        if (mCursor.moveToFirst()) {
+            int subId = mCursor.getInt(SMS_SUB);
+            MmsLog.d(TAG, "subId =" + subId);
+            SubscriptionInfo subInfo = SubscriptionManager.from(MmsApp.getApplication())
+                    .getActiveSubscriptionInfo(subId);
+            //MmsLog.d(TAG, "color=" + subInfo.getSimBackgroundLightRes());
+            //MmsLog.d(TAG, "color=" + subInfo.getColor());
+            //return subInfo.getSimBackgroundLightRes();
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            //return EncapsulatedR.drawable.sim_background_locked;
+        }
+        return 1;
+    }
+
+    private Drawable getContactImage() {
+        MmsLog.d(TAG, "DialogModeActivity.getContactImage");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return sDefaultContactImage;
+        }
+        if (mCursor.moveToFirst()) {
+            ContactList recipients;
+            boolean isGroup = false;
+            if (isCurSMS()) {
+                String recipientIds = mCursor.getString(SMS_ADDR);
+                recipients = ContactList.getByNumbers(recipientIds, false, true);
+            } else {
+                Conversation conv = Conversation.get(this, getThreadId(), true);
+                if (conv == null) {
+                    MmsLog.d(TAG, "conv null");
+                    return sDefaultContactImage;
+                }
+                recipients = conv.getRecipients();
+                if (recipients == null) {
+                    return sDefaultContactImage;
+                }
+            }
+            if (recipients == null || recipients.size() == 0) {
+                return sDefaultContactImage;
+            }
+            Contact contact = recipients.get(0);
+            if (contact == null) {
+                MmsLog.d(TAG, "no contact");
+                return sDefaultContactImage;
+            }
+            return contact.getAvatar(getApplicationContext(), sDefaultContactImage, getThreadId());
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return sDefaultContactImage;
+        }
+    }
+
+    private long getThreadId() {
+        MmsLog.d(TAG, "DialogModeActivity.getThreadId");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return -1;
+        }
+        if (mCursor.moveToFirst()) {
+            long tid = mCursor.getLong(SMS_TID);
+            MmsLog.d(TAG, "tid=" + tid);
+            return tid;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return -1;
+        }
+    }
+
+    private Conversation getConversation() {
+        MmsLog.d(TAG, "DialogModeActivity.getConversation");
+        long tid = getThreadId();
+        if (tid < 0) {
+            MmsLog.d(TAG, "invalid tid");
+            return null;
+        }
+        MmsLog.d(TAG, "tid=" + tid);
+        Conversation conv = Conversation.get(this, tid, true); //new Conversation(this, tid, true);
+        if (conv == null) {
+            MmsLog.d(TAG, "conv null");
+            return null;
+        }
+        return conv;
+    }
+
+    // Implements OnClickListener
+    public void onClick(View v) {
+        MmsLog.d(TAG, "DialogModeActivity.onClick");
+        if (v == null) {
+            return;
+        }
+        if (v.equals(mSmsContentText)) {
+            MmsLog.d(TAG, "Clicent content view");
+            openThread(getThreadId());
+        } else if (v.equals(mMmsPlayButton)) { // PLay MMS
+            MmsLog.dpi(TAG, "View this MMS mCurUri: " + mCurUri);
+            if (!isCurMMS()) {
+                return;
+            }
+            MessageUtils.viewMmsMessageAttachment(this, mCurUri, null, getAsyncDialog());
+            if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+                mReadedUris.add(mCurUri);
+            }
+            markAsRead(mReadedUris);
+            /// M: see this variable's note
+            mNeedFinish = true;
+        } else if (v.equals(mSendButton)) {
+            MmsLog.d(TAG, "Send SMS");
+            sendReplySms();
+        } else if (v.equals(mCloseBtn)) {
+            // change the mark as read button to close button.
+            MmsLog.d(TAG, "mark readbtn");
+            if (mCursor != null) {
+                mCursor.close();
+                mCursor = null;
+            }
+            if (mCurUri != null && !mReadedUris.contains(mCurUri)) {
+                MmsLog.dpi(TAG, "mCurUri" + mCurUri.toString());
+                mReadedUris.add(mCurUri);
+            }
+            finish();
+        } else if (v == mDeleteBtn) {
+            // change the delete button to view button.
+            MmsLog.d(TAG, "view the message thread");
+            markAsSeen(mReadedUris);
+
+            // add for ipmessage
+            if (!mIpDialogModeActivity.onIpClick(getThreadId())) {
+                openThread(getThreadId());
+            }
+        } else if (v == mLeftArrow) {
+            onSlideToPrev();
+        } else if (v == mRightArrow) {
+            onSlideToNext();
+        }
+    }
+
+    private void openThread(long threadId) {
+        MmsLog.d(TAG, "DialogModeActivity.openThread " + threadId);
+        int flags = Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP
+                | Intent.FLAG_ACTIVITY_CLEAR_TOP;
+        if (!FolderModeUtils.startFolderViewList(
+                mOpDialogModeActivityExt.openThread(), this, null, flags)) {
+            if (threadId < 0) {
+                return;
+            }
+            /// M: Fix CR : ALPS01011718 @{
+            Intent intent = ComposeMessageActivity.createIntent(this, threadId);
+            intent.putExtra("finish", true);
+            intent.setFlags(flags);
+            /// @}
+            startActivity(intent);
+        }
+        finish();
+    }
+
+    private void loadMmsView() {
+        MmsLog.d(TAG, "DialogModeActivity.loadMmsView ");
+        if (mMmsView == null) {
+            MmsLog.d(TAG, "set Mms views visible");
+            mMmsView = findViewById(R.id.msg_dlg_mms_view);
+            mMmsImageView = (ImageView) findViewById(R.id.msg_dlg_image_view);
+            mMmsPlayButton = (ImageButton) findViewById(R.id.msg_dlg_play_slideshow_button);
+            mMmsPlayButton.setVisibility(View.VISIBLE);
+        }
+        mMmsImageView.setVisibility(View.GONE);
+        if (mMmsAttachView == null) {
+            mMmsAttachView = findViewById(R.id.vca_dlg_image_view);
+            mMmsAttachImageView = (ImageView) findViewById(R.id.vca_image_view);
+            mAttachName = (TextView) findViewById(R.id.file_attachment_name_info);
+            mAttachSize = (TextView) findViewById(R.id.file_attachment_size_info);
+        }
+        loadMmsContents();
+    }
+
+    private void sendReplySms() {
+        MmsLog.d(TAG, "DialogModeActivity.sendReplySms");
+        // add for ipmessage
+        if (mIpDialogModeActivity
+                .onIpSendReplySms(mReplyEditor.getText().toString(), getSenderNumber())) {
+            return;
+        }
+        simSelection();
+    }
+
+    private void simSelection() {
+        MmsLog.d(TAG, "DialogModeActivity.simSelection");
+        MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+
+        String number = getSenderNumber();
+        int messageSubId = SubscriptionManager.getDefaultSmsSubscriptionId();
+        MmsLog.d(TAG, "messageSimId=" + messageSubId);
+        Intent intent = new Intent();
+        intent.putExtra(SELECT_TYPE, SIM_SELECT_FOR_SEND_MSG);
+        long currentSubId = getCurrentSubId();
+
+        if (mOpDialogModeActivityExt.simSelection(mSelectedSubId, mSubCount,
+                number, messageSubId, intent, currentSubId, mSubIdList, this)) {
+            return;
+        }
+
+
+        if (mSubCount == 1) {
+            MmsLog.d(TAG, "mSubCount == 1");
+            mSelectedSubId = mSubIdList[0];
+            confirmSendMessageIfNeeded();
+        } else {
+            if (number == null || number.length() == 0) {
+                mAssociatedSubId = -1;
+            } else {
+                mAssociatedSubId = getContactSIM(number);
+            }
+            MmsLog.d(TAG, "mAssociatedSubId=" + mAssociatedSubId);
+
+            if (messageSubId == DefaultSmsSimSettings.ASK_USER_SUB_ID) {
+                // always ask, show SIM selection dialog
+                showSubSelectedDialog(false, intent);
+                updateSendButtonState();
+            } else if (messageSubId == Settings.System.DEFAULT_SIM_NOT_SET) {
+                if (mAssociatedSubId == -1) {
+                    showSubSelectedDialog(false, intent);
+                    updateSendButtonState();
+                } else {
+                    mSelectedSubId = mAssociatedSubId;
+                    confirmSendMessageIfNeeded();
+                }
+            } else {
+                if (!MessageUtils.isSmsSubIdActive(this, messageSubId)) {
+                    showSubSelectedDialog(false, intent);
+                    updateSendButtonState();
+                } else {
+                    mSelectedSubId = messageSubId;
+                    confirmSendMessageIfNeeded();
+                }
+            }
+        }
+
+        MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+    }
+
+    private int getContactSIM(String number) {
+        MmsLog.dpi(TAG, "DialogModeActivity.getContactSIM, " + number);
+
+        int subId = -1;
+        String formatNumber = MessageUtils.formatNumber(number, this);
+        String TrimFormatNumber = formatNumber;
+        if (formatNumber != null) {
+            TrimFormatNumber = formatNumber.replace(" ", "");
+        }
+        Cursor associateSIMCursor = getApplicationContext().getContentResolver().query(
+                Data.CONTENT_URI,
+                new String[] {
+                    ContactsContract.Data.SIM_ASSOCIATION_ID
+                },
+                Data.MIMETYPE + "='" + CommonDataKinds.Phone.CONTENT_ITEM_TYPE + "' AND ("
+                        + Data.DATA1 + "=?" + " OR " + Data.DATA1 + "=?" + " OR " + Data.DATA4
+                        + "=?" + ") AND (" + ContactsContract.Data.SIM_ASSOCIATION_ID
+                        + "!= -1)", new String[] {
+                        number, formatNumber, TrimFormatNumber
+                }, null);
+        try {
+            if (null == associateSIMCursor) {
+                MmsLog.w(TAG, " queryContactInfo : associateSIMCursor is null");
+            } else {
+                MmsLog.d(TAG, " queryContactInfo : associateSIMCursor is not null. Count["
+                    + associateSIMCursor.getCount() + "]");
+            }
+            if ((null != associateSIMCursor) && (associateSIMCursor.getCount() > 0)) {
+                associateSIMCursor.moveToFirst();
+                // Get only one record is OK
+                subId = (Integer) associateSIMCursor.getInt(0);
+            } else {
+                subId = -1;
+            }
+            MmsLog.d(TAG, "subId=" + subId);
+        } finally {
+            if (associateSIMCursor != null) {
+                associateSIMCursor.close();
+            }
+        }
+        return subId;
+    }
+    private void showSubSelectedDialog(boolean overridePref , Intent intent) {
+        SubSelectDialog subSelectDialog = new SubSelectDialog(this, this);
+        mSubSelectDialog = subSelectDialog.showSubSelectedDialog(true, null, intent);
+    }
+
+    @Override
+    public void onDialogClick(int subId, Intent intent) {
+        mSelectedSubId = subId;
+        updateSendButtonState();
+        if (intent.getIntExtra(SELECT_TYPE, -1) == SIM_SELECT_FOR_SEND_MSG) {
+            confirmSendMessageIfNeeded();
+        }
+    }
+
+    @Override
+    public void onDialogDismiss() {
+        // TODO Auto-generated method stub
+    }
+
+    @Override
+    public void onCancelClick() {
+        // TODO Auto-generated method stub
+    }
+
+    private void confirmSendMessageIfNeeded() {
+        MmsLog.d(TAG, "DialogModeActivity.confirmSendMessageIfNeeded");
+        checkConditionsAndSendMessage(true);
+    }
+
+    private void checkConditionsAndSendMessage(final boolean bCheckEcmMode) {
+        MmsLog.d(TAG, "DialogModeActivity.checkConditionsAndSendMessage");
+        if (mSelectedSubId <= 0) {
+            mSelectedSubId = SubscriptionManager.getDefaultSubscriptionId();
+        }
+        // add CellConnMgr feature
+        final CellConnMgr cellConnMgr = new CellConnMgr(getApplicationContext());
+        final int state = cellConnMgr.getCurrentState(mSelectedSubId, CellConnMgr.STATE_FLIGHT_MODE
+                | CellConnMgr.STATE_SIM_LOCKED | CellConnMgr.STATE_RADIO_OFF);
+        MmsLog.d(TAG, "CellConnMgr, state is " + state);
+        if (!ImsManager.isWfcEnabledByUser(this) &&
+            (((state & CellConnMgr.STATE_FLIGHT_MODE) == CellConnMgr.STATE_FLIGHT_MODE) ||
+            ((state & CellConnMgr.STATE_RADIO_OFF) == CellConnMgr.STATE_RADIO_OFF) ||
+            ((state & (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))
+                  == (CellConnMgr.STATE_FLIGHT_MODE | CellConnMgr.STATE_RADIO_OFF))))  {
+            final ArrayList<String> stringArray = cellConnMgr.getStringUsingState(mSelectedSubId,
+                    state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(android.R.string.ok,
+                        new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                                updateSendButtonState();
+                            }
+                        });
+                builder.show();
+            }
+        }  else if ((state & CellConnMgr.STATE_SIM_LOCKED) == CellConnMgr.STATE_SIM_LOCKED) {
+            final ArrayList<String> stringArray
+                    = cellConnMgr.getStringUsingState(mSelectedSubId, state);
+            MmsLog.d(TAG, "CellConnMgr, stringArray length is " + stringArray.size());
+            if (stringArray.size() == 4) {
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle(stringArray.get(0));
+                builder.setCancelable(true);
+                builder.setMessage(stringArray.get(1));
+                builder.setPositiveButton(stringArray.get(2),
+                        new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                            cellConnMgr.handleRequest(mSelectedSubId, state);
+                            updateSendButtonState();
+                    }
+                });
+                builder.setNegativeButton(stringArray.get(3),
+                        new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                                updateSendButtonState();
+                            }
+                        });
+                builder.show();
+            }
+        } else {
+            sendMessage(bCheckEcmMode);
+        }
+    }
+
+    private void sendMessage(boolean bCheckEcmMode) {
+        MmsLog.d(TAG, "DialogModeActivity.sendMessage," + bCheckEcmMode);
+
+        if (bCheckEcmMode) {
+            MmsLog.d(TAG, "bCheckEcmMode=" + bCheckEcmMode);
+
+            // TODO: expose this in telephony layer for SDK build
+            int phoneId = SubscriptionManager.getPhoneId(mSelectedSubId);
+            String inEcm = TelephonyManager.getTelephonyProperty(phoneId,
+                    TelephonyProperties.PROPERTY_INECM_MODE, null);
+            //String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE);
+            if (Boolean.parseBoolean(inEcm)) {
+                try {
+                    MmsLog.d(TAG, "show notice to block others");
+                    startActivityForResult(new Intent(
+                            TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),
+                        REQUEST_CODE_ECM_EXIT_DIALOG);
+                    return;
+                } catch (ActivityNotFoundException e) {
+                    // continue to send message
+                    MmsLog.e(TAG, "Cannot find EmergencyCallbackModeExitDialog", e);
+                }
+            }
+        }
+        /*
+         * ContactList contactList = isRecipientsEditorVisible()
+         * ? mRecipientsEditor.constructContactsFromInput(false) :
+         * getRecipients(); mDebugRecipients = contactList.serialize();
+         */
+        // add for ipmessage
+        if (mIpDialogModeActivity.onIpSendMessage(mReplyEditor.getText().toString(),
+                getSenderNumber())) {
+            return;
+        }
+
+        if (!mSendingMessage) {
+            /*
+             * if (LogTag.SEVERE_WARNING) {
+             * String sendingRecipients = mConversation.getRecipients().serialize(); if
+             * (!sendingRecipients.equals(mDebugRecipients)) { String workingRecipients =
+             * mWorkingMessage.getWorkingRecipients();
+             * if (!mDebugRecipients.equals(workingRecipients)) {
+             * LogTag.warnPossibleRecipientMismatch(
+             * "ComposeMessageActivity.sendMessage" + " recipients in window: \"" +
+             * mDebugRecipients + "\" differ from recipients from conv: \"" + sendingRecipients +
+             * "\" and working recipients: " + workingRecipients, this); } }
+             * sanityCheckConversation(); }
+             */
+
+            // send can change the recipients. Make sure we remove the listeners first and then add
+            // them back once the recipient list has settled.
+            // removeRecipientsListeners();
+            MmsLog.d(TAG, "new working message");
+            mWorkingMessage = WorkingMessage.createEmpty(this, this);
+            // mWorkingMessage.setMessageStatusListener(this);
+            mWorkingMessage.setConversation(getConversation());
+            mWorkingMessage.setText(mReplyEditor.getText());
+            MmsLog.d(TAG, "mSelectedSubId = " + mSelectedSubId);
+            mWorkingMessage.send("", mSelectedSubId);
+            mSendingMessage = true;
+            mWaitingForSendMessage = true;
+            mCurUri = (Uri) mUris.get(mCurUriIdx);
+            markAsRead(mCurUri);
+        }
+    }
+
+    private void loadMmsContents() {
+        MmsLog.d(TAG, "DialogModeActivity.loadMmsContents");
+
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return;
+        }
+
+        if (!mCursor.moveToFirst()) {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return;
+        }
+        MmsLog.d(TAG, "cursor ok");
+            // check msg type
+            int type = mCursor.getInt(SMS_TYPE);
+            MmsLog.d(TAG, "type=" + type);
+
+            if (PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND == type) {
+                MmsLog.d(TAG, "mms nofity");
+                String content;
+                content = getNotificationContentString(mCurUri);
+                mSmsContentText.setText(content);
+                if (mMmsAttachView != null) {
+                    mMmsAttachView.setVisibility(View.GONE);
+                }
+                if (mMmsView != null) {
+                    mMmsView.setVisibility(View.GONE);
+                }
+                return;
+            }
+
+            // get MMS pdu
+            PduPersister p = PduPersister.getPduPersister(this);
+            MultimediaMessagePdu msg;
+            SlideshowModel slideshow = null;
+
+            try {
+                msg = (MultimediaMessagePdu) p.load(mCurUri);
+            } catch (MmsException e) {
+                MmsLog.d(TAG, e.toString());
+                msg = null;
+            }
+
+            if (msg == null) {
+                MmsLog.d(TAG, "msg null");
+                return;
+            }
+
+            // get slideshow
+        try {
+            slideshow = SlideshowModel.createFromPduBody(this, msg.getBody());
+        } catch (MmsException e) {
+            slideshow = null;
+            e.printStackTrace();
+        }
+            if (slideshow == null) {
+                MmsLog.d(TAG, "loadMmsContents(); slideshow null");
+            } else {
+                MmsLog.d(TAG, "loadMmsContents(); slideshow ok");
+            }
+
+            // set Mms content text
+            EncodedStringValue subObj = msg.getSubject();
+            String subject = null;
+
+            if (subObj != null) {
+                subject = subObj.getString();
+                MmsLog.dpi(TAG, "sub=" + subject);
+            }
+
+            SpannableStringBuilder buf = new SpannableStringBuilder();
+            boolean hasSubject = false;
+
+            // init set a empty string
+            buf.append("");
+
+            // add subject
+            if ((subject != null) && (subject.length() > 0)) {
+                hasSubject = true;
+                buf.append(TextUtils.replace(getResources().getString(R.string.inline_subject),
+                    new String[] {"%s"}, new CharSequence[] {subject}));
+                buf.replace(0, buf.length(), buf);
+            }
+
+            MmsLog.dpi(TAG, "with sub=" + buf.toString());
+
+        if (slideshow == null) {
+            MmsLog.d(TAG, "slideshow null");
+            mMmsView.setVisibility(View.GONE);
+            mMmsAttachView.setVisibility(View.GONE);
+            if (buf.length() == 0) {
+                mSmsContentText.setText("        ");
+            }
+        } else {
+                // append first text to content
+                SlideModel slide = slideshow.get(0);
+                String body;
+
+                if ((slide != null) && slide.hasText()) {
+                    TextModel tm = slide.getText();
+                    body = tm.getText();
+                    MmsLog.dpi(TAG, "body=" + body);
+
+                    if (hasSubject) {
+                        buf.append(" - ");
+                    }
+                    buf.append(body);
+                } else { // First slide no text
+                    if (!hasSubject) {
+                        buf.append("        ");
+                    }
+                }
+                MmsLog.dpi(TAG, "with cont=" + buf.toString());
+                mSmsContentText.setText(buf);
+                mSmsContentText.setVisibility(View.VISIBLE);
+
+                // Set Mms play button
+                boolean needPresent = false;
+                for (int i = 0; i < slideshow.size(); i++) {
+                    MmsLog.d(TAG, "check slide" + i);
+                    slide = slideshow.get(i);
+                    if (slide.hasImage() || slide.hasVideo() || slide.hasAudio()) {
+                        MmsLog.d(TAG, "found");
+                        needPresent = true;
+                        break;
+                    }
+                }
+
+                if (!needPresent) {
+                if (slideshow.size() > 1) {
+                        needPresent = true;
+                }
+            }
+                if (needPresent) {
+                        MmsLog.d(TAG, "present slidehsow");
+                        Presenter presenter = PresenterFactory.getPresenter(
+                            "MmsThumbnailPresenter", this, this, slideshow);
+                        presenter.present(null);
+                        mMmsPlayButton.setOnClickListener(this);
+                        mMmsAttachView.setVisibility(View.GONE);
+                        setSmsContentTextView();
+                } else {
+                    MmsLog.d(TAG, "no media");
+                    mMmsView.setVisibility(View.GONE);
+                    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+                    setVcardOrVcalendar(slideshow);
+                }
+        }
+
+        /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms @{
+        if (mIsGroupMms) {
+            mGroupMmsSender.setVisibility(View.VISIBLE);
+            String name = interpretFrom(msg.getFrom(), mCurUri) + ":";
+            mGroupMmsSender.setText(name);
+        } else {
+            mGroupMmsSender.setVisibility(View.GONE);
+        }
+        /// @}
+    }
+
+    private String getNotificationContentString(Uri uri) {
+        MmsLog.d(TAG, "DialogModeActivity.getNotificationContentString");
+
+        PduPersister p = PduPersister.getPduPersister(this);
+        NotificationInd msg;
+
+        try {
+            msg = (NotificationInd) p.load(mCurUri);
+            /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms @{
+            if (mIsGroupMms) {
+                mGroupMmsSender.setVisibility(View.VISIBLE);
+                String name = interpretFrom(msg.getFrom(), mCurUri) + ":";
+                mGroupMmsSender.setText(name);
+            } else {
+                mGroupMmsSender.setVisibility(View.GONE);
+            }
+            /// @}
+        } catch (MmsException e) {
+            MmsLog.d(TAG, e.toString());
+            return "";
+        }
+        if (msg == null) {
+            MmsLog.d(TAG, "msg null");
+            return "";
+        }
+
+        String msgSizeText = this.getString(R.string.message_size_label)
+            + String.valueOf((msg.getMessageSize() + 1023) / 1024)
+            + this.getString(R.string.kilobyte);
+
+        String timestamp = this.getString(R.string.expire_on, MessageUtils.formatTimeStampString(
+            this, msg.getExpiry() * 1000L));
+
+        String ret = msgSizeText + "\r\n" + timestamp;
+        ret = mOpDialogModeActivityExt.getNotificationContentString(
+                this.getString(R.string.from_label)
+                + (getSenderNumber()), this.getString(R.string.subject_label)
+                + (msg.getSubject() != null ? msg.getSubject().getString() : ""), msgSizeText,
+                timestamp);
+        MmsLog.d(TAG, "ret=" + ret);
+
+        return ret;
+    }
+
+    // SlideshowModel mSlideshow;
+    private SlideshowModel getSlideShow() {
+        MmsLog.d(TAG, "DialogModeActivity.getSlideShow ");
+        if (mCursor == null) {
+            MmsLog.d(TAG, "mCursor null");
+            return null;
+        }
+
+        if (mCursor.moveToFirst()) {
+            MmsLog.d(TAG, "cursor ok");
+
+                PduPersister p = PduPersister.getPduPersister(this);
+                int type = mCursor.getInt(SMS_TYPE);
+                MmsLog.d(TAG, "type=" + type);
+
+                if (PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND == type) {
+                    MmsLog.d(TAG, "mms nofity");
+                    return null;
+                }
+
+                MultimediaMessagePdu msg;
+                try {
+                    msg = (MultimediaMessagePdu) p.load(mCurUri);
+                } catch (MmsException e) {
+                    MmsLog.d(TAG, e.toString());
+                e.printStackTrace();
+                    msg = null;
+                }
+
+                if (msg != null) {
+                SlideshowModel slideshow;
+                try {
+                    slideshow = SlideshowModel
+                            .createFromPduBody(this, msg.getBody());
+                } catch (MmsException e) {
+                    MmsLog.d(TAG, e.toString());
+                    e.printStackTrace();
+                    slideshow = null;
+                }
+                    if (slideshow == null) {
+                        MmsLog.d(TAG, "getSlideShow(); slideshow null");
+                    } else {
+                        MmsLog.d(TAG, "getSlideShow(); slideshow ok");
+                    }
+                    return slideshow;
+                }
+                MmsLog.d(TAG, "msg null");
+
+            return null;
+        } else {
+            MmsLog.d(TAG, "moveToFirst fail");
+            return null;
+        }
+    }
+
+    @Override
+    public void startAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.startAudio");
+    }
+
+    @Override
+    public void startVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.startVideo");
+    }
+
+    @Override
+    public void setAudio(Uri audio, String name, Map<String, ?> extras) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setAudio");
+    }
+
+    @Override
+    public void setTextVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setTextVisibility");
+    }
+
+    @Override
+    public void setText(String name, String text) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setText");
+    }
+
+    @Override
+    public void setImage(String name, Bitmap bitmap) {
+        MmsLog.d(TAG, "DialogModeActivity.setImage " + name);
+        // inflateMmsView();
+
+        try {
+            Bitmap image = bitmap;
+            if (null == image) {
+                MmsLog.d(TAG, "bitmap null");
+                image = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_picture);
+            }
+            MmsLog.d(TAG, "set bitmap to mMmsImageView");
+            mMmsImageView.setImageBitmap(image);
+            mMmsImageView.setVisibility(View.VISIBLE);
+            mMmsView.setVisibility(View.VISIBLE);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage: out of memory:" + e.toString());
+        }
+    }
+
+    @Override
+    public void setImage(Uri mUri) {
+        MmsLog.d(TAG, "DialogModeActivity.setImage(uri) ");
+        try {
+            Bitmap bitmap = null;
+            if (null == mUri) {
+                bitmap = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_picture);
+            } else {
+                //String mScheme = mUri.getScheme();
+                InputStream mInputStream = null;
+                try {
+                    mInputStream = getApplicationContext().getContentResolver().openInputStream(
+                        mUri);
+                    if (mInputStream != null) {
+                        bitmap = BitmapFactory.decodeStream(mInputStream);
+                    }
+                } catch (FileNotFoundException e) {
+                    bitmap = null;
+                } finally {
+                    if (mInputStream != null) {
+                        mInputStream.close();
+                    }
+                }
+            }
+                setImage("", bitmap);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage(Uri): out of memory: ", e);
+        } catch (Exception e) {
+            MmsLog.d(TAG, "setImage(uri) error." + e);
+        }
+    }
+
+    @Override
+    public void reset() {
+        MmsLog.d(TAG, "DialogModeActivity.reset");
+
+        if (mMmsView != null) {
+            mMmsView.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public void setVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setVisibility");
+        mMmsView.setVisibility(View.VISIBLE);
+    }
+
+    @Override
+    public void pauseAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.pauseAudio");
+
+    }
+
+    @Override
+    public void pauseVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.pauseVideo");
+
+    }
+
+    @Override
+    public void seekAudio(int seekTo) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.seekAudio");
+
+    }
+
+    @Override
+    public void seekVideo(int seekTo) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.seekVideo");
+
+    }
+
+    @Override
+    public void setVideoVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setVideoVisibility");
+    }
+
+    @Override
+    public void stopAudio() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.stopAudio");
+    }
+
+    @Override
+    public void stopVideo() {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.stopVideo");
+    }
+
+    @Override
+    public void setVideo(String name, Uri video) {
+        MmsLog.d(TAG, "DialogModeActivity.setVideo");
+        // inflateMmsView();
+
+        try {
+            Bitmap bitmap = VideoAttachmentView.createVideoThumbnail(this, video);
+            if (null == bitmap) {
+                MmsLog.d(TAG, "bitmap null");
+                bitmap = BitmapFactory.decodeResource(getResources(),
+                    R.drawable.ic_missing_thumbnail_video);
+            }
+            MmsLog.d(TAG, "set bitmap to mMmsImageView");
+            mMmsImageView.setImageBitmap(bitmap);
+            mMmsImageView.setVisibility(View.VISIBLE);
+            mMmsView.setVisibility(View.VISIBLE);
+        } catch (java.lang.OutOfMemoryError e) {
+            MmsLog.d(TAG, "setImage: out of memory:" + e.toString());
+        }
+    }
+
+    @Override
+    public void setVideoThumbnail(String name, Bitmap bitmap) {
+        MmsLog.d(TAG, "setVideoThumbnail");
+    }
+
+    @Override
+    public void setImageRegionFit(String fit) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setImageRegionFit");
+    }
+
+    @Override
+    public void setImageVisibility(boolean visible) {
+        // TODO Auto-generated method stub
+        MmsLog.d(TAG, "DialogModeActivity.setImageVisibility");
+        mMmsView.setVisibility(View.VISIBLE);
+    }
+
+    @Override
+    public int getWidth() {
+        MmsLog.d(TAG, "DialogModeActivity.getWidth" + mMmsImageView.getWidth());
+        return mMmsImageView.getWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        MmsLog.d(TAG, "DialogModeActivity.getHeight" + mMmsImageView.getHeight());
+        return mMmsImageView.getHeight();
+    }
+
+    private void updateSendButtonState() {
+        boolean enable = false;
+        int len = 0;
+        if (mReplyEditor != null) {
+            len = mReplyEditor.getText().toString().length();
+        }
+        MmsLog.d(TAG, "DialogModeActivity.updateSendButtonState(): len = " + len);
+
+        if (mSendButton != null) {
+            if (len >= 0) {
+                MmsLog.d(TAG, "updateSendButtonState(): mSubCount = " + mSubCount);
+
+                /** M: MTK Encapsulation ITelephony */
+                // ITelephony phone = ITelephony.Stub
+                //        .asInterface(ServiceManager.checkService("phone"));
+                ITelephony sTelephony
+                        = ITelephony.Stub.asInterface(ServiceManager.getService("phone"));
+                //TelephonyService phone = EncapsulatedTelephonyService.getInstance();
+                if (sTelephony != null) {
+                    if (isAnySimInsert()) { // check SIM state
+                        enable = true;
+                    }
+                }
+            }
+
+            // View sendButton = showSmsOrMmsSendButton(mWorkingMessage.requiresMms());
+            mSendButton.setEnabled(enable);
+            mSendButton.setFocusable(enable);
+            if (enable) {
+                mSendButton.setImageResource(R.drawable.ic_send_ipmsg);
+            } else {
+                mSendButton.setImageResource(R.drawable.ic_send_sms_unsend);
+            }
+        }
+        // add for ipmessage
+        mIpDialogModeActivity.onIpUpdateSendButtonState(mSendButton);
+        mOpDialogModeActivityExt.updateSendButtonState(enable);
+    }
+
+    private boolean isAnySimInsert() {
+        MmsLog.d(TAG, "DialogModeActivity.isAnySimInsert,mSubCount=" + mSubCount);
+        if (mSubCount > 0) {
+            return true;
+        }
+        return false;
+    }
+
+       private void updateSubInfoList() {
+           MmsLog.d(TAG, "updateSubInfoList mSubCount = " + mSubCount);
+           mSubIdList = SubscriptionManager.from(this).getActiveSubscriptionIdList();
+           if (mSubIdList != null) {
+               MmsLog.d(TAG, "updateSubInfoList is not null");
+               mSubCount = mSubIdList.length;
+           } else {
+                   MmsLog.d(TAG, "updateSubInfoList is null");
+                   mSubCount = 0;
+           }
+    }
+
+    private void updateCounter(CharSequence text, int start, int before, int count) {
+        MmsLog.d(TAG, "DialogModeActivity.updateCounter");
+
+        //int[] params = null;
+        //params = SmsMessage.calculateLength(text, false);
+        MmsLog.dpi(TAG, "mParams[0]" + mParams[0]);
+        MmsLog.dpi(TAG, "mParams[1]" + mParams[1]);
+        MmsLog.dpi(TAG, "mParams[2]" + mParams[2]);
+        MmsLog.dpi(TAG, "mParams[3]" + mParams[3]);
+        /*
+         * SmsMessage.calculateLength returns an int[4] with:
+         * int[0] being the number of SMS's required, int[1] the
+         * number of code units used, int[2] is the number of code
+         * units remaining until the next message. int[3] is the
+         * encoding type that should be used for the message.
+         */
+        if (mReachMax == true) {
+            mParams = SmsMessage.calculateLength(text, false);
+            mReachMax = false;
+
+        }
+        int msgCount = mParams[0];
+
+        int remainingInCurrentMessage = mParams[2];
+        //int unitesUsed = params[1];
+
+        // mWorkingMessage.setLengthRequiresMms(
+        // msgCount >= MmsConfig.getSmsToMmsTextThreshold(), true);
+        // Show the counter
+        // Update the remaining characters and number of messages required.
+        // if (mWorkingMessage.requiresMms()) {
+        // mTextCounter.setVisibility(View.GONE);
+        // } else {
+        // mTextCounter.setVisibility(View.VISIBLE);
+        // }
+
+
+        String counterText = remainingInCurrentMessage + "/" + msgCount;
+        MmsLog.dpi(TAG, "counterText=" + counterText);
+        mTextCounter.setText(counterText);
+        mOpDialogModeActivityExt.updateCounter(mTextCounter, mReplyEditor.getLineCount(),
+                remainingInCurrentMessage, msgCount, counterText);
+        // m1
+    }
+    /**
+    * This filter will constrain edits not to make the length of the text
+    * greater than the specified length.
+    */
+    class TextLengthFilter extends InputFilter.LengthFilter {
+        private final Toast mExceedMessageSizeToast;
+        private final int mMaxLength;
+        public TextLengthFilter(int max) {
+            super(max);
+            mMaxLength = max;
+            mExceedMessageSizeToast = Toast.makeText(DialogModeActivity.this,
+                R.string.exceed_message_size_limitation, Toast.LENGTH_SHORT);
+        }
+        public CharSequence filter(CharSequence source, int start, int end, Spanned dest,
+        int dstart, int dend) {
+            /// M: re-compute max sms number count
+            String text = "";
+            String destString = dest.toString();
+            String headString = destString.substring(0, dstart);
+            if (headString != null) {
+                text += headString;
+            }
+            String middleString = source.toString().substring(start, end);
+            if (middleString != null) {
+                text += middleString;
+            }
+            String tailString = destString.substring(dend);
+            if (tailString != null) {
+                text += tailString;
+            }
+            int page = mPage - 1;
+            int maxLength = mMaxLength;
+            // this function is for MO SMS
+
+            MmsLog.d(TAG, "filter is called");
+//            TextEncodingDetails ted = SmsManager.isImsSmsSupported() ?
+//                com.android.internal.telephony.cdma.SmsMessage.calculateLength(text, false) :
+//                com.android.internal.telephony.gsm.SmsMessage.calculateLength(text, false);
+//                TextEncodingDetails ted = com.android.internal.telephony.gsm.SmsMessage
+//            .calculateLength(text, false);
+            mParams  = SmsMessage.calculateLength(text, false);
+            MmsLog.dpi(TAG, "mParams[0]" + mParams[0]);
+            MmsLog.dpi(TAG, "mParams[1]" + mParams[1]);
+            MmsLog.dpi(TAG, "mParams[2]" + mParams[2]);
+            MmsLog.dpi(TAG, "mParams[3]" + mParams[3]);
+            ArrayList<String> list = SmsMessage.fragmentText(text);
+            if (list != null && list.size() > page) {
+                maxLength = 0;
+                for (int i = 0; i < page; i++) {
+                    maxLength += list.get(i).length();
+                }
+                MmsLog.d(TAG, "get maxLength:" + maxLength);
+            }
+            MmsLog.d(TAG, "maxLength:" + maxLength);
+            int keep = maxLength - (dest.length() - (dend - dstart));
+            if (keep < (end - start)) {
+                InputMethodManager mInputMethodManager
+                        = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                mExceedMessageSizeToast.show();
+                if (mInputMethodManager != null) {
+                    mInputMethodManager.restartInput(
+                            DialogModeActivity.this.getWindow().getCurrentFocus());
+                }
+                mReachMax = true;
+            }
+            if (keep <= 0) {
+                return "";
+            } else if (keep >= end - start) {
+                return null; // keep original
+            } else {
+                keep += start;
+                if (Character.isHighSurrogate(source.charAt(keep - 1))) {
+                    --keep;
+                    if (keep == start) {
+                        return "";
+                    }
+                }
+                return source.subSequence(start, keep);
+            }
+        }
+    }
+    private void markAsRead(final Uri uri) {
+        MmsLog.dpi(TAG, "DialogModeActivity.markAsRead, " + uri.toString());
+
+        new Thread(new Runnable() {
+            public void run() {
+                if (!mIpDialogModeActivity.markAsRead(getApplicationContext(), uri)) {
+                    final ContentValues values = new ContentValues(2);
+                    values.put("read", 1);
+                    values.put("seen", 1);
+                    SqliteWrapper.update(getApplicationContext(),
+                            getContentResolver(), uri, values,
+                            null, null);
+                    MessagingNotification.blockingUpdateNewMessageIndicator(
+                            DialogModeActivity.this,
+                            MessagingNotification.THREAD_NONE, false, uri);
+                }
+            }
+        }).start();
+        removeCurMsg();
+    }
+
+    private void markAsRead(final ArrayList<Uri> uris) {
+        final Object[] uriArray = uris.toArray();
+        new Thread(new Runnable() {
+            public void run() {
+                final ContentValues values = new ContentValues(2);
+                values.put("read", 1);
+                values.put("seen", 1);
+                for (Object uriObject : uriArray) {
+                    Uri uri = (Uri) uriObject;
+                    MmsLog.dpi(TAG, "markasread a:" + uri.toString());
+                    if (!mIpDialogModeActivity.markAsRead(getApplicationContext(), uri)) {
+                        SqliteWrapper.update(getApplicationContext(), getContentResolver(), uri,
+                                values, null, null);
+                        MessagingNotification.blockingUpdateNewMessageIndicator(
+                                DialogModeActivity.this,
+                                MessagingNotification.THREAD_NONE, false, uri);
+                    }
+                }
+        } }).start();
+    }
+
+    private void markAsSeen(final ArrayList<Uri> uris) {
+        final Object[] uriArray = uris.toArray();
+        new Thread(new Runnable() {
+            public void run() {
+                final ContentValues values = new ContentValues(2);
+                values.put("seen", 1);
+                for (Object uriObject : uriArray) {
+                    Uri uri = (Uri) uriObject;
+                    MmsLog.dpi(TAG, "markasseen a:" + uri.toString());
+                    SqliteWrapper.update(getApplicationContext(),
+                            getContentResolver(), uri, values, null, null);
+                }
+                ///M: [ALPS01486266] [KK][MT6592][SGLTE][SMS][Must Resolve]after view new message,
+                ///still show unread message notification
+                ///because composeMessageActivity also update notification
+                //MessagingNotification.blockingUpdateNewMessageIndicator(DialogModeActivity.this,
+                        //MessagingNotification.THREAD_NONE, false);
+            }
+        }).start();
+    }
+
+    public class DialogModeReceiver extends BroadcastReceiver {
+
+        private static final String MSG_VIEWED_ACTION = "com.android.mms.dialogmode.VIEWED";
+
+        public void onReceive(Context context, Intent intent) {
+            MmsLog.d(TAG, "DialogModeActivity.DialogModeReceiver.onReceive");
+
+            // TODO Auto-generated method stub
+            if (intent != null) {
+                String action = intent.getAction();
+                if (action == null) {
+                    return;
+                }
+                MmsLog.d(TAG, "action=" + action);
+                DialogModeActivity.this.finish();
+            }
+        }
+    }
+
+
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        MmsLog.d(TAG, "onStop()");
+        if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+            mSubSelectDialog.dismiss();
+        }
+        if (mNeedFinish) {
+            mNeedFinish = false;
+            finish();
+        }
+
+    }
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+    switch (keyCode) {
+        case KeyEvent.KEYCODE_HOME:
+            onClick(mCloseBtn);
+            break;
+        default:
+            break;
+    }
+    return super.onKeyDown(keyCode, event);
+
+}
+    @Override
+    public void onBackPressed() {
+        /// M: take press back just as press close button
+        onClick(mCloseBtn);
+    }
+
+    /// M: fix for bug ALPS00434945, add for vcard and vcalendar.{
+    private void setVcardOrVcalendar(SlideshowModel slideshow) {
+        if (slideshow == null || slideshow.getAttachFiles() == null
+                || slideshow.getAttachFiles().size() == 0) {
+               if (mMmsAttachView != null) {
+                    mMmsAttachView.setVisibility(View.GONE);
+                }
+                if (mMmsView != null) {
+                    mMmsView.setVisibility(View.GONE);
+                }
+            return;
+        }
+        FileAttachmentModel attach = slideshow.getAttachFiles().get(0);
+        String contentType = attach.getContentType();
+        String src = attach.getSrc();
+        long size = attach.getAttachSize();
+        if (contentType.equalsIgnoreCase(MmsContentType.TEXT_VCARD)
+                || contentType.equalsIgnoreCase(MmsContentType.TEXT_VCALENDAR)) {
+            mMmsAttachView.setVisibility(View.VISIBLE);
+            MmsLog.d(TAG, "set vcard or vcarlendar to mMmsImageView");
+            String nameText = "";
+            if (contentType.equalsIgnoreCase(MmsContentType.TEXT_VCARD)) {
+                mMmsAttachImageView.setImageResource(R.drawable.ic_vcard_attach);
+                nameText = getResources().getString(R.string.file_attachment_vcard_name, src);
+            } else {
+                mMmsAttachImageView.setImageResource(R.drawable.ic_vcalendar_attach);
+                nameText = getResources().getString(R.string.file_attachment_vcalendar_name, src);
+            }
+            mAttachName.setText(nameText);
+            mAttachSize.setText(MessageUtils.getHumanReadableSize(size));
+            setSmsContentTextView();
+        }
+    }
+
+    private void setSmsContentTextView() {
+        if (mSmsContentText != null) {
+            CharSequence contentString = mSmsContentText.getText();
+            if (contentString == null || contentString.toString().trim().length() == 0) {
+                mSmsContentText.setVisibility(View.GONE);
+            }
+        }
+    }
+    /// @}
+
+    /// M: fix bug ALPS00439894, MTK MR1 new feature: Group Mms
+    private String interpretFrom(EncodedStringValue from, Uri messageUri) {
+        String address;
+        if (from != null) {
+            address = from.getString();
+        } else {
+            address = AddressUtils.getFrom(DialogModeActivity.this, messageUri);
+        }
+        String contact = TextUtils.isEmpty(address) ?
+                            DialogModeActivity.this.getString(android.R.string.unknownName)
+                            : Contact.get(address, false).getName();
+        return contact;
+    }
+
+    /// M: fix bug ALPS00517135, update sim state dynamically. @{
+    private Handler mSimHanlder = new Handler();
+    private BroadcastReceiver mSimReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            mOpDialogModeActivityExt.onReceive(context, intent);
+            String action = intent.getAction();
+            MmsLog.d(TAG, "onReceive action = " + action);
+            if (action.equals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED)) {
+                if (mSubSelectDialog != null && mSubSelectDialog.isShowing()) {
+                    mSubSelectDialog.dismiss();
+                }
+                updateSubInfoList();
+                updateSendButtonState();
+            }
+        }
+    };
+    /// @}
+
+    // Add for IpMessage callback
+
+    public int getCurUriIdx() {
+        return mCurUriIdx;
+    }
+
+    public void setCurUriIdx(int curUriIdx, Uri curUri) {
+        mCurUri = curUri;
+        mCurUriIdx = curUriIdx;
+    }
+
+    public void onPreMessageSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onPreMessageSent");
+        if(mUris!= null && !mUris.isEmpty()){
+            runOnUiThread(mResetMessageRunnable);
+        }
+    }
+
+    public void onMessageSent() {
+        MmsLog.d(TAG, "DialogModeActivity.onMessageSent");
+        mWaitingForSendMessage = false;
+        runOnUiThread(mMessageSentRunnable);
+    }
+
+    public String getNumber() {
+        Conversation conv = getConversation();
+        if (conv != null) {
+            String num = conv.getRecipients().get(0).getNumber();
+            return num;
+        }
+        return null;
+    }
+
+    public String getName() {
+        Conversation conv = getConversation();
+        if (conv != null) {
+            String nam = conv.getRecipients().get(0).getName();
+            return nam;
+        }
+        return null;
+    }
+
+    public long getIpThreadId() {
+        return getThreadId();
+    }
+
+    public void markIpAsRead(final Uri uri) {
+        markAsRead(uri);
+    }
+
+    public void onIpSubSelection() {
+        simSelection();
+    }
+
+    public int getIpSelectedId() {
+        return (int) mSelectedSubId;
+    }
+
+    public void setIpSelectedSubId(int selectedSubId) {
+        mSelectedSubId = selectedSubId;
+    }
+
+    public void onIpConfirmSendMessageIfNeeded() {
+        confirmSendMessageIfNeeded();
+    }
+
+    public void onIpShowSubSelectedDialog(boolean overridePref , Intent intent) {
+        showSubSelectedDialog(overridePref, intent);
+    }
+
+    public void onIpUpdateSendButtonState() {
+        updateSendButtonState();
+    }
+
+    // add for op callback
+    @Override
+    public void opSetSelectedSubId(int subId) {
+        mSelectedSubId = subId;
+    }
+
+    @Override
+    public void opConfirmSendMessageIfNeeded() {
+        confirmSendMessageIfNeeded();
+    }
+
+    public Uri opGetCurUri() {
+        return mCurUri;
+    }
+
+    public long opGetThreadId() {
+        return getThreadId();
+    }
+
+    public int opGetCurrentSubId() {
+        return getCurrentSubId();
+    }
+}
Index: vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml
===================================================================
--- vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/vendor/mediatek/proprietary/packages/apps/Mms/res/values/strings.xml	(revision 4302)
@@ -0,0 +1,851 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- The name of the SMS/MMS app as it appears to the user in the Home screen, task switcher, etc. -->
+    <string name="app_label">Messaging</string>
+
+    <!-- Command name to open a Compose screen; displays in conversation list.
+         Also used as accessibility text for widget's new message button -->
+    <string name="new_message">New message</string>
+    <!-- Context menu item on an individual message for dialing the sender's phone number -->
+    <string name="menu_call_back">Call <xliff:g id="name">%s</xliff:g></string>
+    <!-- Context menu item on an individual message for emailing the sender -->
+    <string name="menu_send_email">Send email to <xliff:g id="name">%s</xliff:g></string>
+
+    <!-- Menu item for starting a new conversation -->
+    <string name="menu_compose_new">Compose</string>
+    <!-- Menu item for accessing application settings -->
+    <string name="menu_preferences">Settings</string>
+    <!-- Menu shown in the context menu when long pressing on a message when the message contains
+         one or more phone numbers and/or email addresses and the number or email is new to
+         contacts. [CHAR LIMIT=50] -->
+    <string name="menu_add_address_to_contacts">Add <xliff:g id="contactEmailOrNumber">%s</xliff:g> to Contacts</string>
+    <!-- Menu item to call the recipient of the conversation on the phone (imperative verb) -->
+    <string name="menu_call">Call</string>
+    <!-- Menu item for search -->
+    <string name="menu_search">Search</string>
+    <!-- Menu item for deleting all conversations -->
+    <string name="menu_delete_all">Delete all threads</string>
+    <!-- Context menu item on an individual conversation for deleting that conversation -->
+    <string name="menu_delete">Delete thread</string>
+    <!-- Context menu item on an individual conversation for viewing that conversation -->
+    <string name="menu_view">View thread</string>
+    <!-- Menu item for debugging - do not localize -->
+    <string name="menu_debug_dump">DEBUG DUMP</string>
+    <!-- Message that appears on screen while SIM card messages are retrieved -->
+    <string name="refreshing">Refreshing\u2026</string>
+
+    <!-- Menu item to show received cell broadcasts. [CHAR LIMIT=30] -->
+    <string name="menu_cell_broadcasts">Cell broadcasts</string>
+
+    <!-- Tag appearing on conversations in the conversation list that contain a draft message -->
+    <string name="has_draft">Draft</string>
+
+    <!-- Subject to display in the conversation list if there is no subject -->
+    <string name="no_subject_view">(No subject)</string>
+
+    <!-- Name of the local user when displaying sender of an outgoing message (personal pronoun) -->
+    <string name="messagelist_sender_self">Me</string>
+    <!-- Context menu item on an individual message for viewing an attached slideshow -->
+    <string name="view_slideshow">View slideshow</string>
+    <!-- Context menu item on an individual message for viewing message details such as time and date -->
+    <string name="view_message_details">View details</string>
+    <!-- Context menu item on an individual message for viewing a delivery report -->
+    <string name="view_delivery_report">View report</string>
+    <!-- Context menu item on an individual message for deleting only that message -->
+    <string name="delete_message">Delete</string>
+    <!-- Time and date a message is due to expire -->
+    <string name="expire_on">"Expires: <xliff:g id="date">%s</xliff:g>"</string>
+    <!-- Abbreviation for "kilobyte" -->
+    <string name="kilobyte">KB</string>
+
+    <!-- Dialog box title brought up when warning the user that a message could not be delivered -->
+    <string name="undelivered_msg_dialog_title">Undelivered message</string>
+    <!-- Dialog box message indicating that a message could not be delivered, including the time of last attempt -->
+    <string name="undelivered_msg_dialog_body">Unable to send this message.\nAttempt made: <xliff:g id="message">%s</xliff:g>.</string>
+    <!-- Dialog box message indicating that a message could not be delivered -->
+    <string name="undelivered_sms_dialog_body">Unable to send this message.</string>
+    <!-- Menu item for deleting the entire conversation currently being viewed -->
+    <string name="delete_thread">Delete thread</string>
+    <!-- Context menu item on an individual message for forwarding it to another recipient -->
+    <string name="menu_forward">Forward</string>
+    <!-- Text of a button appearing for MMS messages that have not yet been downloaded, causing the message
+         to be downloaded (imperative verb) -->
+    <string name="download">Download</string>
+    <!-- Message displayed in place of the "download message" button once it has been pressed,
+         indicating that the download is in progress -->
+    <string name="downloading">Downloading</string>
+    <!-- Formatting for subject displayed inline, prepended to MMS message text -->
+    <string name="inline_subject">"&lt;Subject: <xliff:g id="subject">%s</xliff:g>&gt;"</string>
+    <!-- Text to display when the actual text is inaccessible due to DRM protection -->
+    <string name="drm_protected_text">"* DRM protected text *"</string>
+    <!-- Error message to display when DRM rights are insufficient to access some data -->
+    <string name="insufficient_drm_rights">Insufficient DRM rights detected.</string>
+    <!-- Individual message context menu item -->
+    <string name="copy_message_text">Copy text</string>
+    <!-- Header for context menu on an individual message -->
+    <string name="message_options">Message options</string>
+    <!-- Header for context menu on an individual slideshow -->
+    <string name="slideshow_options">Slideshow options</string>
+
+    <!-- Menu item in slideshow edit screen for moving the selected slide up in the order -->
+    <string name="move_up">Move up</string>
+    <!-- Menu item in slideshow edit screen for moving the selected slide down in the order -->
+    <string name="move_down">Move down</string>
+    <!-- Menu item in slideshow edit screen for removing the selected slide from the slideshow -->
+    <string name="remove_slide">Remove slide</string>
+    <!-- Menu item in slideshow edit screen for adding a new slide to the slideshow -->
+    <string name="add_slide">Add slide</string>
+    <!-- Text displayed below "Add slide" item in slideshow edit screen -->
+    <string name="add_slide_hint">Select to create new slide.</string>
+    <!-- Menu item in slideshow edit screen for discarding the entire slideshow -->
+    <string name="discard_slideshow">Discard slideshow</string>
+    <!-- Header of slideshow showing which slide is being displayed -->
+    <string name="slide_show_part">Part <xliff:g id="part">%1$s</xliff:g>/<xliff:g id="total">%2$s</xliff:g></string>
+
+
+    <!-- Menu item in slide edit screen for removing the text from the slide being edited -->
+    <string name="remove_text">Remove text</string>
+    <!-- Menu item in slide edit screen for adding a picture to the slide being edited -->
+    <string name="add_picture">Add picture</string>
+    <!-- Menu item in slide edit screen for removing the picture from the slide being edited -->
+    <string name="remove_picture">Remove picture</string>
+    <!-- Menu item in slide edit screen for adding music to the slide being edited -->
+    <string name="add_music">Add music</string>
+    <!-- Menu item in slide edit screen for removing the music from the slide being edited -->
+    <string name="remove_music">Remove music</string>
+    <!-- Menu item in slide edit screen for adding a video to the slide being edited -->
+    <string name="add_video">Add video</string>
+    <!-- Menu item in slide edit screen for removing the video from the slide being edited -->
+    <string name="remove_video">Remove video</string>
+
+    <!-- Hint displayed in message recipient text box when starting a new conversation -->
+    <string name="to_hint">To</string>
+    <!-- Hint displayed in subject edit text box when adding a subject -->
+    <string name="subject_hint">Subject</string>
+
+    <!-- Menu item in conversation screen for attaching something to the message being composed -->
+    <string name="add_attachment">Attach</string>
+    <!-- Menu item in conversation screen for adding a subject to the message being composed -->
+    <string name="add_subject">Add subject</string>
+    <!-- Menu item in conversation screen for discarding the message currently being composed -->
+    <string name="discard">Discard</string>
+
+    <!-- Button next to an attachment during message composition to view the attachment (imperative verb) -->
+    <string name="view">View</string>
+    <!-- Button next to an attachment during message composition to replace the attachment (imperative verb) -->
+    <string name="replace">Replace</string>
+    <!-- Button next to an attachment during message composition to remove the attachment (imperative verb) -->
+    <string name="remove">Remove</string>
+
+    <!-- Button in conversation screen for sending the SMS message currently being composed (imperative verb) -->
+    <string name="send">Send</string>
+    <!-- Text to appear directly below the "Send" text on the SMS/MMS send button. The "MMS" text is on a second line in a smaller font. This is similar to saying "Send (mms)". -->
+    <string name="mms">MMS</string>
+    <!-- Content description for the send button when sending an mms (imperative verb) -->
+    <string name="send_mms">Send MMS</string>
+
+    <!-- Menu item in conversation screen for returning to the conversation list -->
+    <string name="all_threads">All threads</string>
+
+    <!-- Hint text in message body field when keyboard is exposed -->
+    <string name="type_to_compose_text_enter_to_send">Type message</string>
+    <!-- Hint text in message body field when keyboard is hidden -->
+    <string name="open_keyboard_to_compose_message">Open keyboard to type message</string>
+    <!-- Hint text when we are not the default SMS app -->
+    <string name="sending_disabled_not_default_app">Sending disabled</string>
+    <!-- Toast text when user tries to compose while we are not the default SMS app -->
+    <string name="compose_disabled_toast">Can\'t compose. Not default SMS app.</string>
+    <!-- Toast message while an image is being resized -->
+    <string name="compressing">Picture too large. Compressing\u2026</string>
+
+    <!-- Error message indicating the format for the specified media type (e.g. "picture") is unsupported -->
+    <string name="unsupported_media_format">Unsupported <xliff:g id="name">%1$s</xliff:g> format</string>
+    <!-- Message prompting the user to select a different item; item string as type-appropriate (e.g. "picture") -->
+    <string name="select_different_media">Please select a different <xliff:g id="name">%1$s</xliff:g>.</string>
+    <!-- Message indicating that the message size limit has been reached -->
+    <string name="exceed_message_size_limitation">Message size limit reached.</string>
+    <string name="omh_exceed_message_size_limitation">R-UIM message size limit reached</string>
+    <!-- Message indicating that the message is too big and there is no space to attach a video -->
+    <string name="message_too_big_for_video">The message is too big to attach a video.</string>
+    <!-- Error message indicating that the item trying to be attached could not be added -->
+    <string name="failed_to_add_media">Sorry, you cannot add this <xliff:g id="name">%1$s</xliff:g> to your message.</string>
+    <!-- Error message indicating that the picture being attached and resized could not be resized -->
+    <string name="failed_to_resize_image">Picture not resized.</string>
+    <!-- Error message indicating that an image being attached is still too large to send even after resize -->
+    <string name="resize_image_error_information">Sorry, even when resized this picture is too large to send.</string>
+    <!-- String prepended to forwarded messages to indicate they were forwarded -->
+    <string name="forward_prefix">Fwd:\u0020</string>
+    <!-- Dialog box title that appears when a draft message will not be saved due to invalid recipients -->
+    <string name="discard_message">Discard</string>
+    <!-- Dialog message text explaining that a draft message will not be saved due to invalid recipients -->
+    <string name="discard_message_reason">Your message will be discarded because it has no valid recipients.</string>
+    <!-- Dialog box title indicating which recipients are invalid when the user tries to send a message with invalid recipients -->
+    <string name="has_invalid_recipient">Invalid recipient(s): &lt;<xliff:g id="name">%1$s</xliff:g>&gt;</string>
+    <!-- While sending a message, if it has invalid recipient, display this message. -->
+    <string name="invalid_destination">Invalid destination address.</string>
+    <!-- While sending a message, this error is expected to be generated when user does not have
+         MMS enabled on his account. [CHAR LIMIT=NONE] -->
+    <string name="service_not_activated">Service not activated on network.</string>
+    <!-- If a message has expired and is no longer available on MMSC, show this toast. [CHAR LIMIT=NONE] -->
+    <string name="service_message_not_found">Message expired or not available.</string>
+    <!-- If a message can't be sent because of a MMSC network problem, show this toast. [CHAR LIMIT=NONE] -->
+    <string name="service_network_problem">Error network problem.</string>
+    <!-- Dialog message text when the user tries to send a message with invalid recipients -->
+    <string name="invalid_recipient_message">Please correct the recipient(s) or they will not receive the message.</string>
+    <!-- Dialog box title indicating the message cannot be sent because there are no valid recipients -->
+    <string name="cannot_send_message">Cannot send this message</string>
+    <!-- Dialog message text indicating the message cannot be sent because there are no valid recipients -->
+    <string name="cannot_send_message_reason">Your message has no valid recipients.</string>
+    <!-- Error message displayed when the user attempts to forward a message with DRM-locked contents -->
+    <string name="cannot_forward_drm_obj">The DRM object included in the message cannot be forwarded.</string>
+
+    <!-- Brief message that appears when converting a message from SMS to MMS. -->
+    <string name="converting_to_picture_message">Converting to multimedia message\u2026</string>
+    <!-- Brief message that appears when converting a message from MMS to SMS. -->
+    <string name="converting_to_text_message">Converting to text message\u2026</string>
+    <!-- Brief message that appears when the maximum number of slides has been reached -->
+    <string name="cannot_add_slide_anymore">Cannot add more slides.</string>
+    <!-- Brief message that appears when user tries to add picture to a slide which already has a video. -->
+    <string name="cannot_add_picture_and_video">Cannot add video and picture to one slide.</string>
+    <!-- Brief message that appears when the message cannot be saved -->
+    <string name="cannot_save_message">Cannot save message.</string>
+    <!-- Brief message that appears when a message has automatically been saved as a draft -->
+    <string name="message_saved_as_draft">Message saved as draft.</string>
+    <!-- Brief message that appears when too many recipients have been added -->
+    <string name="too_many_recipients">This message has too many recipients (<xliff:g id="currentCount">%1$s</xliff:g>). There is a limit of <xliff:g id="maxLimit">%2$s</xliff:g> recipients.</string>
+    <!-- Brief message that appears when too many videos/pictures are imported -->
+    <string name="too_many_attachments">There is a limit of <xliff:g id="maxLimit">%1$s</xliff:g> attachments. Only the first <xliff:g id="currentCount">%2$s</xliff:g> will be added.</string>
+    <!-- Alert dialog title when adding attachments is taking a while -->
+    <string name="adding_attachments_title">Adding attachments</string>
+    <!-- Alert dialog when adding attachments is taking a while -->
+    <string name="adding_attachments">Please wait while the items are added to the slideshow.</string>
+    <!-- Alert dialog title when creating a slideshow [CHAR LIMIT=none] -->
+    <string name="building_slideshow_title">Building slideshow</string>
+
+    <!-- Error message indicating that an audio attachment cannot be played -->
+    <string name="cannot_play_audio">Cannot play audio.</string>
+
+    <!-- Button in the slide editor screen used to preview the slide (imperative verb) -->
+    <string name="preview">Preview</string>
+    <!-- Menu item in the slide editor screen used to preview the entire slideshow (imperative verb) -->
+    <string name="preview_slideshow">Preview</string>
+    <!-- Button in the slide editor screen used to replace the attached picture -->
+    <string name="replace_image">Replace picture</string>
+    <!-- String for slide duration in seconds -->
+    <string name="duration_sec">Duration (<xliff:g id="duration">%s</xliff:g> sec)</string>
+    <!-- Dialog box title for duration selector -->
+    <string name="duration_selector_title">"Duration for slide "</string>
+    <!-- Dialog box title for slide layout selector -->
+    <string name="layout_selector_title">"Slideshow layout "</string>
+    <!-- Slide layout option for layout at the top -->
+    <string name="layout_top">Layout (top)</string>
+    <!-- Slide layout option for layout at the bottom -->
+    <string name="layout_bottom">Layout (bottom)</string>
+    <!-- Hint in slide text field before text is typed -->
+    <string name="type_to_compose_text_or_leave_blank">Type message, or leave blank</string>
+    <!-- Toast when the user enters a non-numeric value for the duration of a slide -->
+    <string name="duration_not_a_number">Duration must be a number</string>
+    <!-- Toast when the user enters a zero value for the duration of a slide -->
+    <string name="duration_zero">Duration must be greater than zero seconds</string>
+
+    <!-- In duration selection dialog box, short version of "seconds" -->
+    <string name="secs">secs</string>
+    <!-- Options for slide duration in duration selection dialog box -->
+    <string-array name="select_dialog_items">
+         <item>1 second</item>
+         <item>2 seconds</item>
+         <item>3 seconds</item>
+         <item>4 seconds</item>
+         <item>5 seconds</item>
+         <item>6 seconds</item>
+         <item>7 seconds</item>
+         <item>8 seconds</item>
+         <item>9 seconds</item>
+         <item>10 seconds</item>
+         <item>Other\u2026</item>
+    </string-array>
+
+    <!-- Context menu item on a message recipient for viewing their contact info -->
+    <string name="menu_view_contact">View contact</string>
+    <!-- Context menu item on a message recipient for adding them to the user's
+         contacts (used if the recipient is not already in the address book) -->
+    <string name="menu_add_to_contacts">Add to Contacts</string>
+
+    <!-- Sender to be used if the sender address has been hidden -->
+    <string name="hidden_sender_address">Hidden sender address</string>
+
+    <!-- Text to be used for affirmative response button in dialog boxes -->
+    <string name="yes">OK</string>
+    <!-- Text to be used for negative response button in dialog boxes -->
+    <string name="no">Cancel</string>
+    <!-- Text to be used for affirmative response button in setting SMS limits dialog box -->
+    <string name="set">Set</string>
+
+    <!-- Button text used for playing an attachment or slideshow (imperative verb) -->
+    <string name="play">Play</string>
+    <!-- Button text used for editing a slideshow (imperative verb) -->
+    <string name="edit">Edit</string>
+    <!-- Button used for trying to send a message that has some valid recipients and some
+         invalid recipients, in spite of the warning presented to the user -->
+    <string name="try_to_send">Try to send</string>
+
+    <!-- Title of Settings screen -->
+    <string name="preferences_title">"Settings"</string>
+    <!-- Settings screen menu item for restoring all settings to default -->
+    <string name="restore_default">"Restore default settings"</string>
+
+    <!-- Settings screen, section heading for notifications -->
+    <string name="pref_notification_settings_title">Notification settings</string>
+    <!-- Settings screen, section heading for MMS-specific settings -->
+    <string name="pref_mms_settings_title">"Multimedia message (MMS) settings"</string>
+    <!-- Settings screen, section heading for SMS-specific settings -->
+    <string name="pref_sms_settings_title">"Text message (SMS) settings"</string>
+    <!-- Settings screen, section heading for storage-specific settings -->
+    <string name="pref_sms_storage_title">Storage settings</string>
+    <!-- Title for SMS Disabled -->
+    <string name="pref_title_sms_disabled">SMS Disabled</string>
+    <!-- Summary for SMS Disabled -->
+    <string name="pref_summary_sms_disabled">Touch to make Messaging your default SMS app</string>
+    <!-- Title for SMS Enabled -->
+    <string name="pref_title_sms_enabled">SMS Enabled</string>
+    <!-- Summary for SMS Enabled -->
+    <string name="pref_summary_sms_enabled">Touch to change your default SMS app</string>
+
+    <!-- Settings item description for entering SIM card message screen -->
+    <string name="pref_summary_manage_sim_messages">Manage messages stored on your SIM card</string>
+    <!-- Settings item description for boolean MMS delivery report setting -->
+    <string name="pref_summary_mms_delivery_reports">Request a delivery report for each message you send</string>
+    <!-- Settings item description for boolean MMS read report setting -->
+    <string name="pref_summary_mms_read_reports">Request a read report for each message you send</string>
+    <!-- Settings item description for boolean SMS delivery report setting -->
+    <string name="pref_summary_sms_delivery_reports">Request a delivery report for each message you send</string>
+    <!-- Settings item description for boolean auto-delete messages setting -->
+    <string name="pref_summary_auto_delete">Delete old messages as limits are reached</string>
+    <!-- Settings item description for integer auto-delete sms message limit -->
+    <string name="pref_summary_delete_limit"><xliff:g id="count">%1$s</xliff:g> messages per conversation</string>
+    <!-- Settings item description for boolean MMS enable group MMS setting -->
+    <string name="pref_summary_mms_group_mms">Use MMS to send a single message when there are multiple recipients</string>
+    <!-- Settings item for entering SIM card message screen -->
+    <string name="pref_title_manage_sim_messages">Manage SIM card messages</string>
+    <!-- Settings item for boolean option to enable/disable MMS delivery reports -->
+    <string name="pref_title_mms_delivery_reports">Request delivery report</string>
+    <!-- Settings item for boolean option to enable/disable MMS group messages -->
+    <string name="pref_title_mms_group_mms">Group messaging</string>
+    <!-- Settings item for boolean option to enable/disable MMS read reports -->
+    <string name="pref_title_mms_read_reports">Request read report</string>
+    <!-- Settings item for boolean option to enable/disable SMS delivery reports -->
+    <string name="pref_title_sms_delivery_reports">Request delivery report</string>
+    <!-- Settings item for boolean option to enable/disable auto-deletion of messages -->
+    <string name="pref_title_auto_delete">Delete old messages</string>
+    <!-- Settings item for integer option to set SMS delete limit -->
+    <string name="pref_title_sms_delete">Text message limit</string>
+    <!-- Settings item for integer option to set MMS delete limit -->
+    <string name="pref_title_mms_delete">Multimedia message limit</string>
+    <!-- Settings item for boolean option to display message notifications -->
+    <string name="pref_title_notification_enabled">Message notifications</string>
+    <!-- Settings item for boolean option to vibrate during message notification -->
+    <string name="pref_title_notification_vibrateWhen">Vibrate</string>
+    <!-- Settings item for entering ringtone selection screen -->
+    <string name="pref_title_notification_ringtone">Sound</string>
+    <!-- Settings item for setting the number of message to save for each conversation -->
+    <string name="pref_messages_to_save">Set number of messages to save</string>
+    <!-- Settings screen, what to display for Ringtone when the user chooses "silent" [CHAR LIMIT=100]-->
+    <string name="silent_ringtone">Silent</string>
+
+    <!-- The value to use when migrating from old versions for a true vibrate setting -->
+    <string translatable="false" name="prefDefault_vibrate_true">always</string>
+    <!-- The value to use when migrating from old versions for a false vibrate setting -->
+    <string translatable="false" name="prefDefault_vibrate_false">never</string>
+
+    <!-- The vibrateWhen values -->
+    <string-array translatable="false" name="prefValues_vibrateWhen">
+        <item>always</item>
+        <item>silent</item>
+        <item>never</item>
+    </string-array>
+
+    <!-- Dialog title for the Vibrate dialog -->
+    <string name="prefDialogTitle_vibrateWhen">Vibrate</string>
+
+    <!-- Settings item for boolean option to auto-retrieve incoming MMS messages -->
+    <string name="pref_title_mms_auto_retrieval">Auto-retrieve</string>
+    <!-- Settings item description for boolean MMS auto-retrieve option -->
+    <string name="pref_summary_mms_auto_retrieval">Automatically retrieve messages</string>
+    <!-- Settings item for boolean option to auto-retrieve incoming MMS messages while roaming -->
+    <string name="pref_title_mms_retrieval_during_roaming">Roaming auto-retrieve</string>
+    <!-- Settings item description for boolean MMS auto-retrieve while roaming option -->
+    <string name="pref_summary_mms_retrieval_during_roaming">Automatically retrieve messages while roaming</string>
+
+    <!-- Confirm Delete -->
+    <!-- Delete confirmation dialog title -->
+    <string name="confirm_dialog_title">Delete</string>
+    <!-- Delete confirmation dialog title for locked messages -->
+    <string name="confirm_dialog_locked_title">Delete locked message?</string>
+    <!-- This message is displayed in a confirmation dialog when the user selects one or more
+         conversations and then taps the "Delete" button. -->
+    <plurals name="confirm_delete_conversation">
+        <!-- Case of 1 result. -->
+        <item quantity="one">One conversation will be deleted.</item>
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> conversations will be deleted</item>
+    </plurals>
+    <string name="confirm_delete_conversation">The entire thread will be deleted.</string>
+    <!-- Delete all threads confirmation dialog message -->
+    <string name="confirm_delete_all_conversations">All threads will be deleted.</string>
+    <!-- Delete message confirmation dialog message -->
+    <string name="confirm_delete_message">The message will be deleted.</string>
+    <!-- Delete message confirmation dialog message for a locked message -->
+    <string name="confirm_delete_locked_message">Are you sure you want to delete this locked message?</string>
+    <!-- Delete all the messages on the SIM dialog message -->
+    <string name="confirm_delete_all_SIM_messages">All messages on the SIM will be deleted.</string>
+    <!-- Delete the selected message on the SIM dialog message -->
+    <string name="confirm_delete_SIM_message">This message on the SIM will be deleted.</string>
+    <!-- Delete unlocked checkbox title -->
+    <string name="delete_unlocked">Delete locked messages</string>
+    <!-- Delete button title -->
+    <string name="delete">Delete</string>
+    <!-- Action bar mode title when multi-selecting conversations -->
+    <string name="select_conversations">Select conversations</string>
+    <!-- Show this in the middle of the main activity when there are no conversations [CHAR LIMIT=none] -->
+    <string name="no_conversations">No conversations</string>
+    <!-- Show this in the middle of the main activity when loading conversations [CHAR LIMIT=none] -->
+    <string name="loading_conversations">Loading conversations.</string>
+
+    <!-- When the user tries to view message details and some error occurs while
+         retrieving those details, this message will be shown. -->
+    <string name="cannot_get_details">Cannot get details</string>
+    <!-- Title of "Message details" dialog -->
+    <string name="message_details_title">Message details</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_type_label">Type:\u0020</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="text_message">Text message</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="multimedia_message">Multimedia message</string>
+    <!-- "Type" value in "Message details" dialog -->
+    <string name="multimedia_notification">Multimedia message notification</string>
+    <!-- Label in "Message details" dialog showing who sent the message. -->
+    <string name="from_label">From:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="to_address_label">To:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="bcc_label">Bcc:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="sent_label">Sent:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="received_label">Received:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="saved_label">Saved:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="subject_label">Subject:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_size_label">Message size:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="priority_label">Priority:\u0020</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_high">High</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_normal">Normal</string>
+    <!-- "Priority" value in "Message details" dialog -->
+    <string name="priority_low">Low</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="message_class_label">Message class:\u0020</string>
+    <!-- Label in "Message details" dialog -->
+    <string name="error_code_label">Error code:\u0020</string>
+
+   <!-- Menu title for editing a message -->
+   <string name="menu_edit">Edit</string>
+   <!-- Menu title for deleting undelivered messages or messages on
+        the SIM card. -->
+   <string name="menu_delete_messages">Delete messages</string>
+   <string name="menu_delete_all_messages">Delete all messages</string>
+   <!-- Menu title for locking a message -->
+   <string name="menu_lock">Lock</string>
+   <!-- Menu title for unlocking a message -->
+   <string name="menu_unlock">Unlock</string>
+
+    <!-- Manage SIM Messages -->
+    <!-- Menu title to copy a selected message from the SIM card to the phone. -->
+    <string name="sim_copy_to_phone_memory" product="tablet">Copy to tablet memory</string>
+    <!-- Menu title to copy a selected message from the SIM card to the phone. -->
+    <string name="sim_copy_to_phone_memory" product="default">Copy to phone memory</string>
+    <!-- Menu title to delete a selected messaged from the SIM card. -->
+    <string name="sim_delete">Delete</string>
+    <!-- Title of screen displaying messages on SIM card -->
+    <string name="sim_manage_messages_title">Text messages on SIM card</string>
+    <!-- Context menu item but currently commented out in 1.0. -->
+    <string name="sim_view">View</string>
+    <!-- Message that appears on the "SMS messges on SIM card" screen when there are no messages on the SIM card -->
+    <string name="sim_empty">No messages on the SIM card.</string>
+
+    <!-- Delivery Header View -->
+    <!-- Title of "Report" window -->
+    <string name="delivery_header_title">Report</string>
+
+    <!-- Delivery Report Activity -->
+    <!-- Status in "Report" window -->
+    <string name="status_none">(None)</string>
+    <!-- Status in "Report" window -->
+    <string name="status_pending">Pending</string>
+    <!-- Status in "Report" window -->
+    <string name="status_read">Read</string>
+    <!-- Status in "Report" window -->
+    <string name="status_received">Received</string>
+    <!-- Status in "Report" window -->
+    <string name="status_failed">Unsuccessful</string>
+    <!-- Status in "Report" window -->
+    <string name="status_unread">Unread</string>
+    <!-- Status in "Report" window -->
+    <string name="status_rejected">Rejected</string>
+    <!-- Label in "Report" window -->
+    <string name="recipient_label">Recipient:\u0020</string>
+    <!-- Label in "Report" window -->
+    <string name="status_label">Status:\u0020</string>
+    <!-- Label in "Report" window [CHAR LIMIT=50]-->
+    <string name="delivered_label">Delivered:\u0020</string>
+
+
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_image">Pictures</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_take_photo">Capture picture</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_video">Videos</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_record_video">Capture video</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_sound">Audio</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_record_sound">Record audio</string>
+    <!-- Attachment Type Selector Adapter. This string is an option in the "Attach" dialog, "Add music" dialog -->
+    <string name="attach_slideshow">Slideshow</string>
+
+    <!-- Layout Selector Adapter. Slideshow layout dialog option for aligning an icon. -->
+    <string name="select_bottom_text">Text on bottom</string>
+    <!-- Layout Selector Adapter. Slideshow layout dialog option for aligning an icon. -->
+    <string name="select_top_text">Text on top</string>
+
+    <!-- Delivery Report Toast dialog content -->
+    <string name="delivery_toast_body">Message received by %s</string>
+
+    <!-- Unread message Notification dialog text. -->
+    <plurals name="notification_multiple">
+        <item quantity="one">%d unread message.</item>
+        <item quantity="other">%d unread messages.</item>
+    </plurals>
+    <!-- Unread message Notification dialog title. -->
+    <string name="notification_multiple_title">New messages</string>
+
+    <!-- Failed to send/download Notification dialog title. -->
+    <string name="notification_failed_multiple"><xliff:g id="count">%s</xliff:g> messages could not be sent.</string>
+    <!-- Failed to send/download Notification dialog title. -->
+    <string name="notification_failed_multiple_title">Messages not sent</string>
+
+    <!-- Sim Full Notification dialog title. -->
+    <string name="sim_full_title">SIM card full</string>
+    <!-- Sim Full Notification dialog text. -->
+    <string name="sim_full_body">Delete some messages to make room for more.</string>
+
+    <!-- Device Full Notification dialog title. -->
+    <string name="sms_full_title">Message memory full</string>
+    <!-- Device Full Notification dialog text. -->
+    <string name="sms_full_body">Incoming message rejected due to full memory. Please delete old messages.</string>
+
+    <!-- Sms's Being Rejected Notification dialog title. -->
+    <string name="sms_rejected_title">Text message rejected</string>
+    <!-- Sms's Being Rejected Notification dialog text. -->
+    <string name="sms_rejected_body">Incoming message rejected due to unknown reason.</string>
+
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this audio to your message. -->
+    <string name="type_audio">audio</string>
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this picture to your message. -->
+    <string name="type_picture">picture</string>
+    <!-- Multimedia type used in building other messages.
+         For instance: Sorry, you cannot add this video to your message. -->
+    <string name="type_video">video</string>
+
+    <!-- Dialog title for the Read Report dialog. -->
+    <string name="confirm">Confirm</string>
+    <!-- Dialog text for the Read Report dialog. -->
+    <string name="message_send_read_report">A read report will be sent.</string>
+
+    <!-- This is the text of a toast message briefly displayed when a problem occurs
+         while sending. -->
+    <string name="message_queued">Currently unable to send your message. It will be sent when the service becomes available.</string>
+
+    <!-- dialog error message when only is FDN is allowed. -->
+    <string name="fdn_check_failure">You can only send messages to your fixed dialing numbers.</string>
+
+    <!-- Download Manager -->
+    <!-- When an error occurs downloading a new message and a subject isn't available, substitute
+         this default subject. -->
+    <string name="no_subject">(No subject)</string>
+    <!-- When an error occurs downloading a new message and the sender is unknown, substitute
+         this default text. -->
+    <string name="unknown_sender">Unknown sender</string>
+    <!-- When an error occurs downloading a new message, display this message.
+         An example: Download of message Wanna get pizza from dorkman was unsuccessful. -->
+    <string name="dl_failure_notification">Download of message <xliff:g id="subject">%1$s</xliff:g> from <xliff:g id="from">%2$s</xliff:g> was unsuccessful.</string>
+
+    <!-- This is the confirm rate limit alert dialog title. -->
+    <string name="rate_limit_surpassed">Confirm</string>
+    <!-- This is the confirm rate limit alert dialog text. -->
+    <string name="confirm_rate_limit">A large number of multimedia messages are being sent. Is this OK?</string>
+
+    <!-- Message Failed Notification -->
+    <!-- Dialog box title when receiving a message failed. -->
+    <string name="message_download_failed_title">Message not downloaded</string>
+    <!-- Dialog box title when sending a message failed. -->
+    <string name="message_send_failed_title">Message not sent</string>
+    <!-- Dialog box message text when failure occurs sending a message. -->
+    <string name="message_failed_body">Select to review the message and try again.</string>
+    <!-- Dialog box message when there's a problem retrieving messages. -->
+    <string name="download_later">Currently unable to download. Please try again later.</string>
+    <!-- Dialog box message when there's no APN specified on the device. -->
+    <string name="no_apn">No APN specified on the device.</string>
+
+    <!-- Title for audio file picker -->
+    <string name="select_audio">Select audio</string>
+    <!-- Menu title to copy an attachment to the shared storage [CHAR LIMIT=25] -->
+    <string name="copy_to_sdcard">Save attachment</string>
+    <!-- Toast message on successful copy to shared storage [CHAR LIMIT=30] -->
+    <string name="copy_to_sdcard_success">Attachment saved</string>
+    <!-- Toast message on failed copy to shared storage [CHAR LIMIT=30] -->
+    <string name="copy_to_sdcard_fail">Unable to save attachment</string>
+    <!-- Menu title to save a sound as a ringtone -->
+    <string name="save_ringtone">Save as ringtone</string>
+    <!-- Toast message on successful copying ringtone to drm provider -->
+    <string name="saved_ringtone">Ringtone saved</string>
+    <!-- Toast message on failed copying ringtone to drm provider -->
+    <string name="saved_ringtone_fail">Saving ringtone failed</string>
+    <!-- Menu item -->
+    <string name="menu_insert_smiley">Insert smiley</string>
+    <!-- Menu item  [CHAR LIMIT=40] -->
+    <string name="menu_group_participants">Group participants</string>
+
+    <!-- This is the dialog title for the "Select link" dialog, shown when the user clicks on a
+    chat in the chat history view if there are links in the chat message. The dialog displays the
+    links if there are any -->
+    <string name="select_link_title">Select action</string>
+
+    <!-- Name of the Nth slide, shown in the list in the slideshow editor. -->
+    <string name="slide_number">Slide <xliff:g id="number" example="5">%s</xliff:g></string>
+    <!-- Duration of the slide, shown in the list in the slideshow editor -->
+    <plurals name="slide_duration">
+        <!-- Case of 1-second duration. -->
+        <item quantity="one"><xliff:g id="number" example="1">%s</xliff:g> sec</item>
+        <!-- Case of "few" (small number of) seconds of duration. -->
+        <item quantity="few"><xliff:g id="number" example="2">%s</xliff:g> secs</item>
+        <!-- Case of multiple-second duration. -->
+        <item quantity="other"><xliff:g id="number" example="15">%s</xliff:g> secs</item>
+    </plurals>
+
+    <!-- Title of the delivery report activity. -->
+    <string name="delivery_report_activity">Delivery report</string>
+
+    <!-- Title of the activity that tells the user about storage limits. -->
+    <string name="storage_limits_activity">Storage limits</string>
+
+    <!-- Title of the slide duration editor activity. -->
+    <string name="change_duration_activity">Change duration</string>
+
+    <!-- Title of the slideshow editor activity. -->
+    <string name="edit_slideshow_activity">Edit slideshow</string>
+
+    <!-- Title of the recipient list activity. [CHAR LIMIT=NONE] -->
+    <string name="recipient_list_activity">Group participants</string>
+
+    <!-- Title of the slide editor activity. -->
+    <string name="edit_slide_activity">Edit slide</string>
+
+    <!-- Title of the slideshow activity. -->
+    <string name="slideshow_activity">Slideshow</string>
+
+    <!-- Title of the class-0 message activity. -->
+    <string name="class_0_message_activity">Class 0 Message</string>
+
+    <!-- Application name shown when searching -->
+    <string name="search_label">Messaging</string>
+
+    <!-- Search hint -->
+    <string name="search_hint">Search Messaging</string>
+
+    <!-- Search activity name -->
+    <string name="search">Messaging</string>
+    <!-- Search setting description -->
+    <string name="search_setting_description">Text in your messages</string>
+
+    <!--  Search empty results -->
+    <string name="search_empty">No matches</string>
+
+    <!--  Search results title -->
+    <plurals name="search_results_title">
+        <!-- Case of 1 result. -->
+        <item quantity="one"><xliff:g id="number" example="1">%1$s</xliff:g> result for \"<xliff:g id="search" example="???">%2$s</xliff:g>\"</item>
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> results for \"<xliff:g id="search" example="???">%2$s</xliff:g>\"</item>
+    </plurals>
+
+    <!--- String saved in history searches. -->
+    <string name="search_history"><xliff:g id="count">%1$s</xliff:g> results for \"<xliff:g id="search">%2$s</xliff:g>\"</string>
+
+    <!-- Button title in Messaging preferences. -->
+    <string name="confirm_clear_search_title">Clear</string>
+    <!-- Text for the preferences button. -->
+    <string name="confirm_clear_search_text">Search history will be cleared.</string>
+    <!--- Button title in preferences to clear the search history. It's a verb action that takes place
+          immediately when clicked. -->
+    <string name="pref_mms_clear_search_history_title">Clear search history</string>
+    <!--- Button description in preferences to clear the search history. -->
+    <string name="pref_mms_clear_search_history_summary">Clear previous Messaging searches from showing up in the Search box</string>
+
+    <!-- Dialog text for display mode save dialog. -->
+    <string name="save">Save</string>
+
+    <!-- Dialog title for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_title">Limit messages</string>
+
+    <!-- Dialog message for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_message">Do you want to limit the number of messages you save per conversation?</string>
+
+    <!-- Button title for dialog that informs user about new storage settings. -->
+    <string name="storage_limits_setting">Set limits</string>
+
+    <!-- Button title to dismiss dialog that informs user about new storage settings. -->
+    <string name="storage_limits_setting_dismiss">No limits</string>
+
+    <!-- Toast message when a user tries to send a Mms message when there are already too many
+         outstanding unsent message. -->
+    <string name="too_many_unsent_mms">Can\'t send message right now. There are too many unsent multimedia messages.</string>
+
+    <!-- Brief small label shown to right of message when it is being sent. -->
+    <string name="sending_message">Sending\u2026</string>
+
+    <!-- Title of progress dialog for picker -->
+    <string name="pick_too_many_recipients">Too many recipients</string>
+
+    <!-- Message of progress dialog for picker -->
+    <string name="adding_recipients">Adding recipients\u2026</string>
+
+    <!-- In conversation list items, this is the separator between a contact's name
+         and the draft stamp [CHAR LIMIT=5] -->
+    <string name="draft_separator">,\u0020</string>
+
+    <!-- In conversation list items, this comes after the receipient's name and contains
+         the number of messages in the thread [CHAR LIMIT=5] -->
+    <string name="message_count_format">\u00a0<xliff:g id="number" example="1">%1$s</xliff:g></string>
+
+    <!-- When showing a multi-message notification, this is the title [CHAR LIMIT=none] -->
+    <string name="message_count_notification"><xliff:g id="number" example="3">%1$s</xliff:g> new messages</string>
+    <!-- In digest notifications when we show N messages, but there are N+M outstanding messages,
+         this text is displayed at the bottom of the notification. [CHAR LIMIT=50] -->
+    <plurals name="message_count_notification_overflow">
+        <!-- Case of 1 result. -->
+        <item quantity="one">+<xliff:g id="number" example="1">%1$s</xliff:g> other message"</item>
+        <!-- Case of 2 or more results. -->
+        <item quantity="other">+<xliff:g id="number" example="15">%1$s</xliff:g> other messages"</item>
+    </plurals>
+
+    <!-- For debugging: Dialog box title indicating there's a situation where data has unexpectedly
+         changed -->
+    <string name="error_state">Inconsistent state</string>
+    <!-- For debugging: Dialog box text indicating there's a situation where data has unexpectedly
+         changed -->
+    <string name="error_state_text">The state of threads and recipients is inconsistent. Please capture a bug report and report it via http://go/droidanizer </string>
+
+    <!-- In the title of the compose message activity, when there are multiple recipients, we show
+         the number of recipients in the subtitle of the action bar. There's never a case of one. [CHAR LIMIT=50] -->
+    <plurals name="recipient_count">
+        <!-- Case of 0 or 2 or more results. -->
+        <item quantity="other"><xliff:g id="number" example="15">%1$s</xliff:g> people</item>
+    </plurals>
+   <!-- Displayed at the end of the conversation list in the widget. Tapping on this will open the default conversation list. [CHAR LIMIT=35] -->
+    <string name="view_more_conversations">View more conversations</string>
+
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_audio">Audio</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_slideshow">Slideshow</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_video">Video</string>
+    <!-- Attachment type shown in notification. [CHAR LIMIT=35] -->
+    <string name="attachment_picture">Picture</string>
+
+    <!-- Separator between parts of a notification in each line of an inboxStyle notification. [CHAR LIMIT=2] -->
+    <string name="notification_separator">\u0020\u0020</string>
+
+    <!-- An enumeration comma for separating multiple names in notifications. [CHAR LIMIT=2] -->
+    <string name="enumeration_comma">,\u0020</string>
+
+    <!-- In message list items, this string builds the timestamp line when the message is in a group [CHAR LIMIT=NONE] -->
+    <string name="message_timestamp_format"><xliff:g id="string" example="Fred Flinstone">%1$s</xliff:g>\u0020-\u0020<xliff:g id="string" example="9:39AM">%2$s</xliff:g></string>
+
+    <string name="storage_warning_title">"Your phone's storage is full"</string>
+    <string name="storage_warning_content">"You won't receive new SMS/MMS messages"</string>
+
+    <!-- Cell broadcast SMS strings -->
+    <string name="cell_broadcast">Cell broadcast</string>
+    <string name="cell_broadcast_title">Cell broadcast settings</string>
+    <string name="cell_broadcast_settings">SIM card cell broadcast settings</string>
+    <!-- Quick text -->
+    <string name="menu_insert_quick_text">Insert quick text</string>
+    <string name="select_quick_text">Select quick text</string>
+    <string name="add">Add</string>
+    <string name="quick_text_editor">Edit quick text</string>
+    <string name="modify_successful">Modify successfully</string>
+    <string name="modify_unsuccessful">Modify unsuccessfully!</string>
+    <string name="delete_successful">Delete successfully</string>
+    <string name="delete_unsuccessful">Delete unsuccessfully!</string>
+    <string name="add_quick_text_successful">Add quick text successfully</string>
+    <string name="already_have_quick_text">You have this quick text already!</string>
+    <!-- add by feng for attachment -->
+    <string name="file_attachment_common_name">Multi file(<xliff:g id="text">%s</xliff:g>)</string>
+    <string name="file_attachment_contains">contains</string>
+    <string name="file_attachment_files">files</string>
+    <string name="save_attachment">Save Attachment</string>
+    <string name="save_multi_attachment_notes">The multi-file contains several files. Check and save them?</string>
+    <string name="save_single_attachment_notes">It is an nonsupported format file in MMS. Save it to Filemanager?</string>
+    <string name="multi_files">Multi-files</string>
+    <string name="save_single_supportformat_attachment_notes">Save it to Filemanager?</string>
+
+    <!-- add for editor lenght limitation -->
+    <string name="exceed_editor_size_limitation">Text limit reached.</string>
+
+    <string name="add_top_slide">Add slide to top</string>
+    <string name="add_bottom_slide">Add slide to bottom</string>
+    <!--  Strings used forh MMS push of messages in outbox -->
+    <string name="label_mms_send_outbox_msg">MMS Wakeup</string>
+    <string name="desc_mms_send_outbox_msg">Sends out all MMSs from the outbox to the network</string>
+    <!-- Banner in conversation list for making Messaging the default SMS app -->
+    <string name="banner_sms_promo_title_initial">Messaging is not your SMS app</string>
+    <string name="banner_sms_promo_title_application"><xliff:g id="appName">%s</xliff:g> is your SMS app</string>
+    <string name="banner_sms_promo_message">You can change this in Settings</string>
+	<!-- add lei.shi for [task1149499][CBC notification with pop up and tone alert + vibrate in CHILE] at 2015.12.14 begin -->
+    <string name="hide_imm_cb_dialog">Hide</string>
+    <string name="title_imm_cb_dialog">Emergency Alert</string>
+    <!-- add lei.shi for [task1149499][CBC notification with pop up and tone alert + vibrate in CHILE] at 2015.12.14 end -->
+    <string name="send_empty_message_title">Empty Message</string>
+    <string name="send_empty_message_message">Send empty message?</string>
+</resources>
+
