Index: vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Mms/src/com/android/mms/MmsConfig.java
===================================================================
--- vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Mms/src/com/android/mms/MmsConfig.java	(revision 0)
+++ vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Mms/src/com/android/mms/MmsConfig.java	(revision 5506)
@@ -0,0 +1,753 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.res.XmlResourceParser;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.provider.Telephony;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.mms.util.FeatureOption;
+
+import com.mediatek.custom.CustomProperties;
+import com.mediatek.ipmsg.util.IpMessageUtils;
+import com.mediatek.mms.ext.IOpMmsConfigExt;
+import com.mediatek.mms.ipmessage.IMmsConfigExt;
+import com.mediatek.opmsg.util.OpMessageUtils;
+import com.mediatek.telephony.TelephonyManagerEx;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class MmsConfig {
+    private static final String TAG = "MmsConfig";
+    private static final boolean DEBUG = true;
+    private static final boolean LOCAL_LOGV = false;
+
+    private static final String DEFAULT_HTTP_KEY_X_WAP_PROFILE = "x-wap-profile";
+    private static final String DEFAULT_USER_AGENT = "Android-Mms/2.0";
+
+    /// KK migration, for default MMS function. @{
+    private static final String MMS_APP_PACKAGE = "com.android.mms";
+
+    private static final String SMS_PROMO_DISMISSED_KEY = "sms_promo_dismissed_key";
+    ///@}
+    private static final int MAX_IMAGE_HEIGHT = 480;
+    private static final int MAX_IMAGE_WIDTH  = 640;
+
+    /**
+     * Whether to hide MMS functionality from the user (i.e. SMS only).
+     */
+    private static boolean mTransIdEnabled = false;
+    private static int mMmsEnabled = 1;                         // default to true
+    private static int mMaxMessageSize = 300 * 1024;            // default to 300k max size
+    private static String mUserAgent = DEFAULT_USER_AGENT;
+    private static String mUaProfTagName = DEFAULT_HTTP_KEY_X_WAP_PROFILE;
+    private static String mUaProfUrl = null;
+    private static String mHttpParams = null;
+    private static String mHttpParamsLine1Key = null;
+    private static String mEmailGateway = null;
+    private static int mMaxImageHeight = MAX_IMAGE_HEIGHT;      // default value
+    private static int mMaxImageWidth = MAX_IMAGE_WIDTH;        // default value
+    private static int mRecipientLimit = Integer.MAX_VALUE;     // default value
+    private static int mDefaultSMSMessagesPerThread = 10000;    // default value
+    private static int mDefaultMMSMessagesPerThread = 1000;     // default value
+    private static int mMinMessageCountPerThread = 2;           // default value
+    private static int mMaxMessageCountPerThread = 10000;        // default value
+    private static int mMinimumSlideElementDuration = 7;        // default to 7 sec
+    private static boolean mNotifyWapMMSC = false;
+    private static boolean mAllowAttachAudio = true;
+
+    // This flag is somewhat confusing. If mEnableMultipartSMS is true, long sms messages are
+    // always sent as multi-part sms messages, with no checked limit on the number of segments.
+    // If mEnableMultipartSMS is false, then mSmsToMmsTextThreshold is used to determine the
+    // limit of the number of sms segments before turning the long sms message into an mms
+    // message. For example, if mSmsToMmsTextThreshold is 4, then a long sms message with three
+    // or fewer segments will be sent as a multi-part sms. When the user types more characters
+    // to cause the message to be 4 segments or more, the send button will show the MMS tag to
+    // indicate the message will be sent as an mms.
+    private static boolean mEnableMultipartSMS = true;
+
+    private static boolean mEnableSlideDuration = true;
+    private static boolean mEnableMMSReadReports = true;        // key: "enableMMSReadReports"
+    private static boolean mEnableSMSDeliveryReports = true;    // key: "enableSMSDeliveryReports"
+    private static boolean mEnableMMSDeliveryReports = true;    // key: "enableMMSDeliveryReports"
+    private static int mMaxTextLength = -1;
+
+    // This is the max amount of storage multiplied by mMaxMessageSize that we
+    // allow of unsent messages before blocking the user from sending any more
+    // MMS's.
+    private static int mMaxSizeScaleForPendingMmsAllowed = 4;       // default value
+
+    // Email gateway alias support, including the master switch and different rules
+    private static boolean mAliasEnabled = false;
+    private static int mAliasRuleMinChars = 2;
+    private static int mAliasRuleMaxChars = 48;
+
+    private static int mMaxSubjectLength = 40;  // maximum number of characters allowed for mms
+                                                // subject
+
+    /// M: google jb.mr1 patch, group mms
+    // If mEnableGroupMms is true, a message with multiple recipients, regardless of contents,
+    // will be sent as a single MMS message with multiple "TO" fields set for each recipient.
+    // If mEnableGroupMms is false, the group MMS setting/preference will be hidden in the settings
+    // activity.
+    private static boolean mEnableGroupMms = true;
+
+    private static final int RECIPIENTS_LIMIT = 50;
+
+    /// M: Mms size limit, default 300K.
+    private static int mUserSetMmsSizeLimit = 300;
+    /// M: Receive Mms size limit for 2G network
+    private static int mReceiveMmsSizeLimitFor2G = 200;
+    /// M: Receive Mms size limit for TD network
+    private static int mReceiveMmsSizeLimitForTD = 400;
+
+    /// M: default value
+    private static int mMaxRestrictedImageHeight = 1200;
+    private static int mMaxRestrictedImageWidth = 1600;
+    private static int mSmsRecipientLimit = 100;
+
+    private static boolean mDeviceStorageFull = false;
+
+    private static IOpMmsConfigExt mOpConfigExt = null;
+
+    // / M: Add for get max text size from ip message
+    private static Context mContext;
+
+    /// Add for support Auto Test.
+    public static boolean sIsRunTestCase = false;
+    public static boolean sIsDefaultSMSInTestCase = false;
+    /// @}
+
+    private static List<Integer> allQuickTextIds = new ArrayList<Integer>();
+    private static List<String> allQuickTexts = new ArrayList<String>();
+    public static IMmsConfigExt mIpConfig;
+
+    private static int sSmsToMmsTextThreshold = 999;
+    private static int sSmsToMmsTextThresholdForCT = 7;
+
+    private static void initPlugin(Context context) {
+        mOpConfigExt = OpMessageUtils.getOpMessagePlugin().getOpMmsConfigExt();
+        mIpConfig = IpMessageUtils.getIpMessagePlugin(context).getIpConfig();
+    }
+
+    public static void init(Context context) {
+        if (LOCAL_LOGV) {
+            Log.v(TAG, "MmsConfig.init()");
+        }
+        // Always put the mnc/mcc in the log so we can tell which mms_config.xml was loaded.
+        Log.d(TAG, "mnc/mcc: " +
+                android.os.SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC));
+
+        mContext = context;
+        // initialize the operator plugin
+        initPlugin(context);
+
+        loadMmsSettings(context);
+
+        // add for ipmessage
+        mIpConfig.onIpInit(context);
+    }
+
+    /// KK migration, for default MMS function. @{
+    public static boolean isSmsEnabled(Context context) {
+        /// Add for support Auto Test.
+        if (sIsRunTestCase) {
+            return sIsDefaultSMSInTestCase;
+        }
+        /// @}
+        String defaultSmsApplication = Telephony.Sms.getDefaultSmsPackage(context);
+
+        if (defaultSmsApplication != null && defaultSmsApplication.equals(MMS_APP_PACKAGE)) {
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean isSmsPromoDismissed(Context context) {
+        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
+        return preferences.getBoolean(SMS_PROMO_DISMISSED_KEY, false);
+    }
+
+    public static void setSmsPromoDismissed(Context context) {
+        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.putBoolean(SMS_PROMO_DISMISSED_KEY, true);
+        editor.apply();
+    }
+
+    public static Intent getRequestDefaultSmsAppActivity() {
+        final Intent intent = new Intent(Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT);
+        intent.putExtra(Telephony.Sms.Intents.EXTRA_PACKAGE_NAME, MMS_APP_PACKAGE);
+        return intent;
+    }
+    ///@}
+
+    public static int getSmsToMmsTextThresholdForC2K(Context context) {
+        if (hasUSIMInserted(context)) {
+            Log.d(TAG, "get getSmsToMmsTextThresholdForC2K" + sSmsToMmsTextThresholdForCT);
+            return sSmsToMmsTextThresholdForCT;
+        }
+        return sSmsToMmsTextThreshold;
+    }
+
+    /**
+     * M: For OM Version: check whethor has usim card.
+     * @param context the context.
+     * @return ture: has usim; false: not.
+     */
+    private static boolean hasUSIMInserted(Context context) {
+        if (context == null) {
+            return false;
+        }
+        int[] ids = SubscriptionManager.from(context).getActiveSubscriptionIdList();
+        if (ids != null && ids.length > 0) {
+            for (int subId : ids) {
+                if (isUSimType(subId)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * M: For EVDO: check the sim is whether UIM or not.
+     *
+     * @param subId the sim's sub id.
+     * @return true: UIM; false: not UIM.
+     */
+    private static boolean isUSimType(int subId) {
+        String phoneType = TelephonyManagerEx.getDefault().getIccCardType(subId);
+        if (phoneType == null) {
+            Log.d(TAG, "[isUIMType]: phoneType = null");
+            return false;
+        }
+        Log.d(TAG, "[isUIMType]: phoneType = " + phoneType);
+        return phoneType.equalsIgnoreCase("CSIM") || phoneType.equalsIgnoreCase("UIM")
+                || phoneType.equalsIgnoreCase("RUIM");
+    }
+
+    public static boolean getMmsEnabled() {
+        return mMmsEnabled == 1 ? true : false;
+    }
+
+    public static int getMaxMessageSize() {
+        if (LOCAL_LOGV) {
+            Log.v(TAG, "MmsConfig.getMaxMessageSize(): " + mMaxMessageSize);
+        }
+        return mMaxMessageSize;
+    }
+
+    /**
+     * This function returns the value of "enabledTransID" present in mms_config file.
+     * In case of single segment wap push message, this "enabledTransID" indicates whether
+     * TransactionID should be appended to URI or not.
+     */
+    public static boolean getTransIdEnabled() {
+        return mTransIdEnabled;
+    }
+
+    public static String getUserAgent() {
+        /// M: @{
+        String value = CustomProperties.getString(
+                CustomProperties.MODULE_MMS,
+                CustomProperties.USER_AGENT,
+                mUserAgent);
+        /// @}
+        return value;
+    }
+
+    public static String getUaProfTagName() {
+        return mUaProfTagName;
+    }
+
+    public static String getUaProfUrl() {
+        /// M: @{
+        String value = CustomProperties.getString(
+                CustomProperties.MODULE_MMS,
+                CustomProperties.UAPROF_URL,
+                mUaProfUrl);
+        /// @}
+        return value;
+    }
+
+    public static String getHttpParams() {
+        return mHttpParams;
+    }
+
+    public static String getHttpParamsLine1Key() {
+        return mHttpParamsLine1Key;
+    }
+
+    public static String getEmailGateway() {
+        return mEmailGateway;
+    }
+
+    public static int getMaxImageHeight() {
+        return mMaxImageHeight;
+    }
+
+    public static int getMaxImageWidth() {
+        return mMaxImageWidth;
+    }
+
+    public static int getRecipientLimit() {
+        return mRecipientLimit;
+    }
+
+    public static int getDefaultSMSMessagesPerThread() {
+        return mDefaultSMSMessagesPerThread;
+    }
+
+    public static int getDefaultMMSMessagesPerThread() {
+        return mDefaultMMSMessagesPerThread;
+    }
+
+    public static int getMinMessageCountPerThread() {
+        return mMinMessageCountPerThread;
+    }
+
+    public static int getMaxMessageCountPerThread() {
+        return mMaxMessageCountPerThread;
+    }
+
+    public static int getMinimumSlideElementDuration() {
+        return mMinimumSlideElementDuration;
+    }
+
+    public static boolean getMultipartSmsEnabled() {
+        return mEnableMultipartSMS;
+    }
+
+    public static boolean getSlideDurationEnabled() {
+        return mEnableSlideDuration;
+    }
+
+    public static boolean getMMSReadReportsEnabled() {
+        return mEnableMMSReadReports;
+    }
+
+    public static boolean getSMSDeliveryReportsEnabled() {
+        return mEnableSMSDeliveryReports;
+    }
+
+    public static boolean getMMSDeliveryReportsEnabled() {
+        return mEnableMMSDeliveryReports;
+    }
+
+    public static boolean getNotifyWapMMSC() {
+        return mNotifyWapMMSC;
+    }
+
+    public static int getMaxSizeScaleForPendingMmsAllowed() {
+        return mMaxSizeScaleForPendingMmsAllowed;
+    }
+
+    public static boolean isAliasEnabled() {
+        return mAliasEnabled;
+    }
+
+    public static int getAliasMinChars() {
+        return mAliasRuleMinChars;
+    }
+
+    public static int getAliasMaxChars() {
+        return mAliasRuleMaxChars;
+    }
+
+    public static boolean getAllowAttachAudio() {
+        return mAllowAttachAudio;
+    }
+
+    public static int getMaxSubjectLength() {
+        return mMaxSubjectLength;
+    }
+
+    /// M: google jb.mr1 patch, group mms
+    public static boolean getGroupMmsEnabled() {
+        return mEnableGroupMms;
+    }
+
+    public static final void beginDocument(XmlPullParser parser, String firstElementName)
+            throws XmlPullParserException, IOException
+    {
+        int type;
+        while ((type = parser.next()) != parser.START_TAG
+                   && type != parser.END_DOCUMENT) {
+            ;
+        }
+
+        if (type != parser.START_TAG) {
+            throw new XmlPullParserException("No start tag found");
+        }
+
+        if (!parser.getName().equals(firstElementName)) {
+            throw new XmlPullParserException("Unexpected start tag: found " + parser.getName() +
+                    ", expected " + firstElementName);
+        }
+    }
+
+    public static final void nextElement(XmlPullParser parser)
+            throws XmlPullParserException, IOException
+    {
+        int type;
+        while ((type = parser.next()) != parser.START_TAG
+                   && type != parser.END_DOCUMENT) {
+            ;
+        }
+    }
+
+    /// M:
+    /**
+     * Notes:for CMCC customization,whether to enable SL automatically lanuch.
+     * default set false
+     */
+    private static boolean mSlAutoLanuchEnabled = false;
+    public static boolean getSlAutoLanuchEnabled() {
+        return mSlAutoLanuchEnabled;
+    }
+
+    public static void setDeviceStorageFullStatus(boolean bFull) {
+        mDeviceStorageFull = bFull;
+    }
+
+    public static boolean getDeviceStorageFullStatus() {
+        return mDeviceStorageFull;
+    }
+
+    /// M: new feature, init defualt quick text @{
+    public static void setInitQuickText(boolean init) {
+        SharedPreferences sp =
+            PreferenceManager.getDefaultSharedPreferences(MmsApp.getApplication());
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putBoolean("InitQuickText", init);
+        editor.commit();
+    }
+
+    public static boolean getInitQuickText() {
+        SharedPreferences sp =
+            PreferenceManager.getDefaultSharedPreferences(MmsApp.getApplication());
+        boolean isFristInit = sp.getBoolean("InitQuickText", true);
+        return isFristInit;
+    }
+    /// @}
+
+    public static List<String> getQuicktexts() {
+        return allQuickTexts;
+    }
+
+    public static List<Integer> getQuicktextsId() {
+        return allQuickTextIds;
+    }
+
+    public static int updateAllQuicktexts() {
+        Cursor cursor = mContext.getContentResolver().query(Telephony.MmsSms.CONTENT_URI_QUICKTEXT,
+                null, null, null, null);
+        allQuickTextIds.clear();
+        allQuickTexts.clear();
+        String[] defaultTexts = mContext.getResources().getStringArray(R.array.default_quick_texts);
+        int maxId = defaultTexts.length;
+        if (cursor != null) {
+            try {
+                while (cursor.moveToNext()) {
+                    int qtId = cursor.getInt(0);
+                    allQuickTextIds.add(qtId);
+                    String qtText = cursor.getString(1);
+                    if (qtText != null && !qtText.isEmpty()) {
+                        allQuickTexts.add(qtText);
+                    } else {
+                        allQuickTexts.add(defaultTexts[qtId - 1]);
+                    }
+                    if (qtId > maxId) {
+                        maxId = qtId;
+                    }
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return maxId;
+    }
+
+    public static int getUserSetMmsSizeLimit(boolean isBytes) {
+        if (true == isBytes) {
+            return mUserSetMmsSizeLimit * 1024;
+        } else {
+            return mUserSetMmsSizeLimit;
+        }
+    }
+
+    public static void setUserSetMmsSizeLimit(int limit) {
+        mUserSetMmsSizeLimit = limit;
+    }
+
+    public static int getMaxRestrictedImageHeight() {
+        return mMaxRestrictedImageHeight;
+    }
+
+    public static int getMaxRestrictedImageWidth() {
+        return mMaxRestrictedImageWidth;
+    }
+
+    public static int getSmsRecipientLimit() {
+        return mSmsRecipientLimit;
+    }
+
+    public static int getReceiveMmsLimitFor2G() {
+        return mReceiveMmsSizeLimitFor2G;
+    }
+
+    public static int getReceiveMmsLimitForTD() {
+        return mReceiveMmsSizeLimitForTD;
+    }
+
+    /// APARTODO
+//    public static boolean getSIMSmsAtSettingEnabled() {
+//        return mMmsFeatureManagerPlugin.isFeatureEnabled(
+//    IMmsFeatureManagerExt.SHOW_SIM_SMS_ENTRY_IN_SETTINGS);
+//    }
+
+    public static int getPluginMenuIDBase() {
+        return 0x100;
+    }
+
+    private static boolean sSlot1SimExist = true;
+    private static boolean sSlot2SimExist = true;
+    private static int sSlot1RetryCounter = 0;
+    private static int sSlot2RetryCounter = 0;
+    private static final int MAX_RETRY_COUNT = 3;
+    private static long sSim1Id = -1;
+    private static long sSim2Id = -1;
+
+   /* private static void loadSimInfo(Context context) {
+        /// M: sim1 info maybe not loaded yet, load it.
+        if (sSim1Id <= 0 && sSlot1SimExist) {
+            sSim1Id = EncapsulatedSimInfoManager.getIdBySlot(context, PhoneConstants.SIM_ID_1);
+            sSlot1RetryCounter++;
+            /// M: if we tried 3 times and still can't get valid simId , we think the slot is empty.
+            if (sSlot1RetryCounter == MAX_RETRY_COUNT && sSim1Id <= 0) {
+                sSlot1SimExist = false;
+            }
+        }
+        /// M: sim2 info maybe not loaded yet, load it.
+        if (sSim2Id <= 0 && sSlot2SimExist) {
+            sSim2Id = EncapsulatedSimInfoManager.getIdBySlot(context, PhoneConstants.SIM_ID_2);
+            sSlot2RetryCounter++;
+            /// M: if we tried 3 times and still can't get valid simId , we think the slot is empty.
+            if (sSlot2RetryCounter == MAX_RETRY_COUNT && sSim2Id <= 0) {
+                sSlot2SimExist = false;
+            }
+        }
+    }*/
+
+    public static int getMmsRetryPromptIndex() {
+        return mOpConfigExt.getMmsRetryPromptIndex();
+    }
+
+    /// M: this method is changed to use plugin
+    public static int getSmsToMmsTextThreshold() {
+        int limitSmsCount = mOpConfigExt.getSmsToMmsTextThreshold();
+        if (limitSmsCount > 0) {
+            return limitSmsCount;
+        }
+        // Operator Plugin
+        if (FeatureOption.MTK_C2K_SUPPORT) {
+            return getSmsToMmsTextThresholdForC2K(mContext);
+        }
+        return sSmsToMmsTextThreshold;
+    }
+
+    /// M: change this to plugin
+    public static int getMaxTextLimit() {
+        // add for ipmessage
+        if (mIpConfig.getMaxTextLimit(mContext) != 0) {
+            return mIpConfig.getMaxTextLimit(mContext);
+        }
+        return mOpConfigExt.getMaxTextLimit();
+    }
+
+    private static void loadMmsSettings(Context context) {
+        XmlResourceParser parser = context.getResources().getXml(R.xml.mms_config);
+
+        try {
+            beginDocument(parser, "mms_config");
+
+            while (true) {
+                nextElement(parser);
+                String tag = parser.getName();
+                if (tag == null) {
+                    break;
+                }
+                String name = parser.getAttributeName(0);
+                String value = parser.getAttributeValue(0);
+                String text = null;
+                if (parser.next() == XmlPullParser.TEXT) {
+                    text = parser.getText();
+                }
+
+                if (DEBUG) {
+                    Log.v(TAG, "tag: " + tag + " value: " + value + " - " +
+                            text);
+                }
+                if ("name".equalsIgnoreCase(name)) {
+                    if ("bool".equals(tag)) {
+                        // bool config tags go here
+                        if ("enabledMMS".equalsIgnoreCase(value)) {
+                            mMmsEnabled = "true".equalsIgnoreCase(text) ? 1 : 0;
+                        } else if ("enabledTransID".equalsIgnoreCase(value)) {
+                            mTransIdEnabled = "true".equalsIgnoreCase(text);
+                        } else if ("enabledNotifyWapMMSC".equalsIgnoreCase(value)) {
+                            mNotifyWapMMSC = "true".equalsIgnoreCase(text);
+                        } else if ("aliasEnabled".equalsIgnoreCase(value)) {
+                            mAliasEnabled = "true".equalsIgnoreCase(text);
+                        } else if ("allowAttachAudio".equalsIgnoreCase(value)) {
+                            mAllowAttachAudio = "true".equalsIgnoreCase(text);
+                        } else if ("enableMultipartSMS".equalsIgnoreCase(value)) {
+                            mEnableMultipartSMS = "true".equalsIgnoreCase(text);
+                        } else if ("enableSlideDuration".equalsIgnoreCase(value)) {
+                            mEnableSlideDuration = "true".equalsIgnoreCase(text);
+                        } else if ("enableMMSReadReports".equalsIgnoreCase(value)) {
+                            mEnableMMSReadReports = "true".equalsIgnoreCase(text);
+                        } else if ("enableSMSDeliveryReports".equalsIgnoreCase(value)) {
+                            mEnableSMSDeliveryReports = "true".equalsIgnoreCase(text);
+                        } else if ("enableMMSDeliveryReports".equalsIgnoreCase(value)) {
+                            mEnableMMSDeliveryReports = "true".equalsIgnoreCase(text);
+                        /// M: google jb.mr1 patch, group mms
+                        } else if ("enableGroupMms".equalsIgnoreCase(value)) {
+                            mEnableGroupMms = "true".equalsIgnoreCase(text);
+                        }
+                    } else if ("int".equals(tag)) {
+                        // int config tags go here
+                        if ("maxMessageSize".equalsIgnoreCase(value)) {
+                            mMaxMessageSize = Integer.parseInt(text);
+                        } else if ("maxImageHeight".equalsIgnoreCase(value)) {
+                            mMaxImageHeight = Integer.parseInt(text);
+                        } else if ("maxImageWidth".equalsIgnoreCase(value)) {
+                            mMaxImageWidth = Integer.parseInt(text);
+                        }
+                        /// M: @{
+                        else if ("maxRestrictedImageHeight".equalsIgnoreCase(value)) {
+                            mMaxRestrictedImageHeight = Integer.parseInt(text);
+                        } else if ("maxRestrictedImageWidth".equalsIgnoreCase(value)) {
+                            mMaxRestrictedImageWidth = Integer.parseInt(text);
+                        }
+                        /// @}
+                        else if ("defaultSMSMessagesPerThread".equalsIgnoreCase(value)) {
+                            mDefaultSMSMessagesPerThread = Integer.parseInt(text);
+                        } else if ("defaultMMSMessagesPerThread".equalsIgnoreCase(value)) {
+                            mDefaultMMSMessagesPerThread = Integer.parseInt(text);
+                        } else if ("minMessageCountPerThread".equalsIgnoreCase(value)) {
+                            mMinMessageCountPerThread = Integer.parseInt(text);
+                        } else if ("maxMessageCountPerThread".equalsIgnoreCase(value)) {
+                            mMaxMessageCountPerThread = Integer.parseInt(text);
+                        }
+                        else if ("smsToMmsTextThreshold".equalsIgnoreCase(value)) {
+                            /// M: Operator Plugin
+                            mOpConfigExt.setSmsToMmsTextThreshold(Integer.parseInt(text));
+                        }
+                        else if ("recipientLimit".equalsIgnoreCase(value)) {
+                            /// M: Operator Plugin
+                            mOpConfigExt.setMmsRecipientLimit(Integer.parseInt(text));
+                        } else if ("httpSocketTimeout".equalsIgnoreCase(value)) {
+                            mOpConfigExt.setHttpSocketTimeout(Integer.parseInt(text));
+                        } else if ("minimumSlideElementDuration".equalsIgnoreCase(value)) {
+                            mMinimumSlideElementDuration = Integer.parseInt(text);
+                        } else if ("maxSizeScaleForPendingMmsAllowed".equalsIgnoreCase(value)) {
+                            mMaxSizeScaleForPendingMmsAllowed = Integer.parseInt(text);
+                        } else if ("aliasMinChars".equalsIgnoreCase(value)) {
+                            mAliasRuleMinChars = Integer.parseInt(text);
+                        } else if ("aliasMaxChars".equalsIgnoreCase(value)) {
+                            mAliasRuleMaxChars = Integer.parseInt(text);
+                        } else if ("maxMessageTextSize".equalsIgnoreCase(value)) {
+                            /// M: Operator Plugin
+                            mOpConfigExt.setMaxTextLimit(Integer.parseInt(text));
+                        } else if ("maxSubjectLength".equalsIgnoreCase(value)) {
+                            mMaxSubjectLength = Integer.parseInt(text);
+                        }
+                    } else if ("string".equals(tag)) {
+                        // string config tags go here
+                        if ("userAgent".equalsIgnoreCase(value)) {
+                            mUserAgent = text;
+                        } else if ("uaProfTagName".equalsIgnoreCase(value)) {
+                            mUaProfTagName = text;
+                        } else if ("uaProfUrl".equalsIgnoreCase(value)) {
+                            mUaProfUrl = text;
+                        } else if ("httpParams".equalsIgnoreCase(value)) {
+                            mHttpParams = text;
+                        } else if ("httpParamsLine1Key".equalsIgnoreCase(value)) {
+                            mHttpParamsLine1Key = text;
+                        } else if ("emailGatewayNumber".equalsIgnoreCase(value)) {
+                            mEmailGateway = text;
+                        }
+                    }
+                }
+            }
+        } catch (XmlPullParserException e) {
+            Log.e(TAG, "loadMmsSettings caught ", e);
+        } catch (NumberFormatException e) {
+            Log.e(TAG, "loadMmsSettings caught ", e);
+        } catch (IOException e) {
+            Log.e(TAG, "loadMmsSettings caught ", e);
+        } finally {
+            parser.close();
+        }
+
+        String errorStr = null;
+
+        if (getMmsEnabled() && mUaProfUrl == null) {
+            errorStr = "uaProfUrl";
+        }
+
+        if (errorStr != null) {
+            String err =
+                String.format("MmsConfig.loadMmsSettings mms_config.xml missing %s setting",
+                        errorStr);
+            Log.e(TAG, err);
+        }
+    }
+
+    /// M: change this method to plugin
+    public static int getMmsRecipientLimit() {
+        return mOpConfigExt.getMmsRecipientLimit();
+    }
+
+
+    /// M: Add MmsService configure param @{
+    public static Bundle getMmsServiceConfig() {
+        // Operator Plugin
+        return mOpConfigExt.getMmsServiceConfig();
+    }
+    /// @}
+}
Index: vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/dialpad/DialpadFragment.java
===================================================================
--- vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/dialpad/DialpadFragment.java	(revision 0)
+++ vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/dialpad/DialpadFragment.java	(revision 5506)
@@ -0,0 +1,2229 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.dialpad;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.app.Fragment;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.media.AudioManager;
+import android.media.ToneGenerator;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.Trace;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiManager;
+import android.provider.CallLog;
+import android.provider.Contacts.People;
+import android.provider.Contacts.Phones;
+import android.provider.Contacts.PhonesColumns;
+import android.provider.Settings;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.HapticFeedbackConstants;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.BaseAdapter;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.PopupMenu;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.android.contacts.common.CallUtil;
+import com.android.contacts.common.GeoUtil;
+import com.android.contacts.common.util.Constants;
+import com.android.contacts.common.dialog.CallSubjectDialog;
+import com.android.contacts.common.util.PermissionsUtil;
+import com.android.contacts.common.util.PhoneNumberFormatter;
+import com.android.contacts.common.util.PhoneNumberHelper;
+import com.android.contacts.common.util.StopWatch;
+import com.android.contacts.common.widget.FloatingActionButtonController;
+import com.android.dialer.DialtactsActivity;
+import com.android.dialer.NeededForReflection;
+import com.android.dialer.R;
+import com.android.dialer.SpecialCharSequenceMgr;
+import com.android.dialer.calllog.PhoneAccountUtils;
+import com.android.ims.ImsManager;
+import com.android.dialer.util.DialerUtils;
+import com.android.dialer.util.IntentUtil;
+import com.android.dialer.util.IntentUtil.CallIntentBuilder;
+import com.android.dialer.util.TelecomUtil;
+import com.android.incallui.Call.LogState;
+import com.android.phone.common.CallLogAsync;
+import com.android.phone.common.animation.AnimUtils;
+import com.android.phone.common.dialpad.DialpadKeyButton;
+import com.android.phone.common.dialpad.DialpadView;
+
+import com.mediatek.dialer.ext.DialpadExtensionAction;
+import com.mediatek.dialer.ext.ExtensionManager;
+import com.mediatek.dialer.util.DialerFeatureOptions;
+
+import com.mediatek.dialer.util.DialerVolteUtils;
+import com.android.internal.telephony.ITelephony;
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.telecom.TelecomManagerEx;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Timer;
+import java.util.TimerTask;
+
+/**
+ * Fragment that displays a twelve-key phone dialpad.
+ */
+public class DialpadFragment extends Fragment
+        implements View.OnClickListener,
+        View.OnLongClickListener, View.OnKeyListener,
+        AdapterView.OnItemClickListener, TextWatcher,
+        PopupMenu.OnMenuItemClickListener,
+        DialpadKeyButton.OnPressedListener,
+        /// M: add for plug-in @{
+        DialpadExtensionAction {
+        /// @}
+    private static final String TAG = "DialpadFragment";
+        /// M: fix for ALPS03445439 @{
+        private boolean mIsDialpadChooserShown = false;
+        /// @}
+
+    /**
+     * LinearLayout with getter and setter methods for the translationY property using floats,
+     * for animation purposes.
+     */
+    public static class DialpadSlidingRelativeLayout extends RelativeLayout {
+
+        public DialpadSlidingRelativeLayout(Context context) {
+            super(context);
+        }
+
+        public DialpadSlidingRelativeLayout(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        public DialpadSlidingRelativeLayout(Context context, AttributeSet attrs, int defStyle) {
+            super(context, attrs, defStyle);
+        }
+
+        @NeededForReflection
+        public float getYFraction() {
+            final int height = getHeight();
+            if (height == 0) return 0;
+            return getTranslationY() / height;
+        }
+
+        @NeededForReflection
+        public void setYFraction(float yFraction) {
+            setTranslationY(yFraction * getHeight());
+        }
+    }
+
+    public interface OnDialpadQueryChangedListener {
+        void onDialpadQueryChanged(String query);
+    }
+
+    public interface HostInterface {
+        /**
+         * Notifies the parent activity that the space above the dialpad has been tapped with
+         * no query in the dialpad present. In most situations this will cause the dialpad to
+         * be dismissed, unless there happens to be content showing.
+         */
+        boolean onDialpadSpacerTouchWithEmptyQuery();
+    }
+
+    private static final boolean DEBUG = DialtactsActivity.DEBUG;
+
+    // This is the amount of screen the dialpad fragment takes up when fully displayed
+    private static final float DIALPAD_SLIDE_FRACTION = 0.67f;
+
+    private static final String EMPTY_NUMBER = "";
+    private static final char PAUSE = ',';
+    private static final char WAIT = ';';
+
+    /** The length of DTMF tones in milliseconds */
+    private static final int TONE_LENGTH_MS = 150;
+    private static final int TONE_LENGTH_INFINITE = -1;
+
+    /** The DTMF tone volume relative to other sounds in the stream */
+    private static final int TONE_RELATIVE_VOLUME = 80;
+
+    /** Stream type used to play the DTMF tones off call, and mapped to the volume control keys */
+    private static final int DIAL_TONE_STREAM_TYPE = AudioManager.STREAM_DTMF;
+
+
+    private OnDialpadQueryChangedListener mDialpadQueryListener;
+
+    private DialpadView mDialpadView;
+    private EditText mDigits;
+    private int mDialpadSlideInDuration;
+
+    /** Remembers if we need to clear digits field when the screen is completely gone. */
+    private boolean mClearDigitsOnStop;
+
+    private View mOverflowMenuButton;
+    private PopupMenu mOverflowPopupMenu;
+    private View mDelete;
+    private ToneGenerator mToneGenerator;
+    private final Object mToneGeneratorLock = new Object();
+    private View mSpacer;
+
+    private FloatingActionButtonController mFloatingActionButtonController;
+
+    ///M:  WFC @{
+    private static final String SCHEME_TEL = PhoneAccount.SCHEME_TEL;
+    private static final int DIALPAD_WFC_NOTIFICATION_ID = 2;
+    private Context mContext;
+    private int mNotificationCount;
+    private Timer mNotificationTimer;
+    private NotificationManager mNotificationManager;
+    /// @}
+    /**
+     * Set of dialpad keys that are currently being pressed
+     */
+    private final HashSet<View> mPressedDialpadKeys = new HashSet<View>(12);
+
+    private ListView mDialpadChooser;
+    private DialpadChooserAdapter mDialpadChooserAdapter;
+
+    /**
+     * Regular expression prohibiting manual phone call. Can be empty, which means "no rule".
+     */
+    private String mProhibitedPhoneNumberRegexp;
+
+    private PseudoEmergencyAnimator mPseudoEmergencyAnimator;
+
+    // Last number dialed, retrieved asynchronously from the call DB
+    // in onCreate. This number is displayed when the user hits the
+    // send key and cleared in onPause.
+    private final CallLogAsync mCallLog = new CallLogAsync();
+    private String mLastNumberDialed = EMPTY_NUMBER;
+
+    // determines if we want to playback local DTMF tones.
+    private boolean mDTMFToneEnabled;
+
+    /** Identifier for the "Add Call" intent extra. */
+    private static final String ADD_CALL_MODE_KEY = "add_call_mode";
+
+    /**
+     * Identifier for intent extra for sending an empty Flash message for
+     * CDMA networks. This message is used by the network to simulate a
+     * press/depress of the "hookswitch" of a landline phone. Aka "empty flash".
+     *
+     * TODO: Using an intent extra to tell the phone to send this flash is a
+     * temporary measure. To be replaced with an Telephony/TelecomManager call in the future.
+     * TODO: Keep in sync with the string defined in OutgoingCallBroadcaster.java
+     * in Phone app until this is replaced with the Telephony/Telecom API.
+     */
+    private static final String EXTRA_SEND_EMPTY_FLASH
+            = "com.android.phone.extra.SEND_EMPTY_FLASH";
+
+    private String mCurrentCountryIso;
+
+    private CallStateReceiver mCallStateReceiver;
+
+    private class CallStateReceiver extends BroadcastReceiver {
+        /**
+         * Receive call state changes so that we can take down the
+         * "dialpad chooser" if the phone becomes idle while the
+         * chooser UI is visible.
+         */
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // Log.i(TAG, "CallStateReceiver.onReceive");
+            String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+            if ((TextUtils.equals(state, TelephonyManager.EXTRA_STATE_IDLE) ||
+                    TextUtils.equals(state, TelephonyManager.EXTRA_STATE_OFFHOOK))
+                    && isDialpadChooserVisible()) {
+                // Log.i(TAG, "Call ended with dialpad chooser visible!  Taking it down...");
+                // Note there's a race condition in the UI here: the
+                // dialpad chooser could conceivably disappear (on its
+                // own) at the exact moment the user was trying to select
+                // one of the choices, which would be confusing.  (But at
+                // least that's better than leaving the dialpad chooser
+                // onscreen, but useless...)
+                showDialpadChooser(false);
+            }
+        }
+    }
+
+    private boolean mWasEmptyBeforeTextChange;
+
+    /**
+     * This field is set to true while processing an incoming DIAL intent, in order to make sure
+     * that SpecialCharSequenceMgr actions can be triggered by user input but *not* by a
+     * tel: URI passed by some other app.  It will be set to false when all digits are cleared.
+     */
+    private boolean mDigitsFilledByIntent;
+
+    private boolean mStartedFromNewIntent = false;
+    private boolean mFirstLaunch = false;
+    private boolean mAnimate = false;
+
+    private static final String PREF_DIGITS_FILLED_BY_INTENT = "pref_digits_filled_by_intent";
+
+    /** M: [VoLTE ConfCall] indicated phone account has volte conference capability. @{ */
+    private boolean mVolteConfCallEnabled = false;
+    /** @}*/
+
+    private TelephonyManager getTelephonyManager() {
+        return (TelephonyManager) getActivity().getSystemService(Context.TELEPHONY_SERVICE);
+    }
+
+    @Override
+    public Context getContext() {
+        return getActivity();
+    }
+    private ITelephony getITelephony() {
+        return ITelephony.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE));
+    }
+
+    @Override
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+        mWasEmptyBeforeTextChange = TextUtils.isEmpty(s);
+    }
+
+    @Override
+    public void onTextChanged(CharSequence input, int start, int before, int changeCount) {
+        if (mWasEmptyBeforeTextChange != TextUtils.isEmpty(input)) {
+            final Activity activity = getActivity();
+            if (activity != null) {
+                activity.invalidateOptionsMenu();
+                updateMenuOverflowButton(mWasEmptyBeforeTextChange);
+            }
+        }
+
+        // DTMF Tones do not need to be played here any longer -
+        // the DTMF dialer handles that functionality now.
+    }
+
+    @Override
+    public void afterTextChanged(Editable input) {
+        /// M: avoid NPE if this callback is called after activity finished @{
+        if (getActivity() == null) {
+            return;
+        }
+        /// @}
+        // When DTMF dialpad buttons are being pressed, we delay SpecialCharSequenceMgr sequence,
+        // since some of SpecialCharSequenceMgr's behavior is too abrupt for the "touch-down"
+        // behavior.
+        if (!mDigitsFilledByIntent &&
+                SpecialCharSequenceMgr.handleChars(getActivity(), input.toString(), mDigits)) {
+            // A special sequence was entered, clear the digits
+            mDigits.getText().clear();
+        }
+
+        if (isDigitsEmpty()) {
+            mDigitsFilledByIntent = false;
+            mDigits.setCursorVisible(false);
+        }
+
+        if (mDialpadQueryListener != null) {
+            mDialpadQueryListener.onDialpadQueryChanged(mDigits.getText().toString());
+        }
+
+        updateDeleteButtonEnabledState();
+    }
+
+    @Override
+    public void onCreate(Bundle state) {
+        Trace.beginSection(TAG + " onCreate");
+        super.onCreate(state);
+
+        mFirstLaunch = state == null;
+
+        mCurrentCountryIso = GeoUtil.getCurrentCountryIso(getActivity());
+
+        mProhibitedPhoneNumberRegexp = getResources().getString(
+                R.string.config_prohibited_phone_number_regexp);
+
+        if (state != null) {
+            mDigitsFilledByIntent = state.getBoolean(PREF_DIGITS_FILLED_BY_INTENT);
+        }
+
+        mDialpadSlideInDuration = getResources().getInteger(R.integer.dialpad_slide_in_duration);
+
+        if (mCallStateReceiver == null) {
+            IntentFilter callStateIntentFilter = new IntentFilter(
+                    TelephonyManager.ACTION_PHONE_STATE_CHANGED);
+            mCallStateReceiver = new CallStateReceiver();
+            ((Context) getActivity()).registerReceiver(mCallStateReceiver, callStateIntentFilter);
+        }
+
+        /// M: for Plug-in @{
+        ExtensionManager.getInstance().getDialPadExtension().onCreate(
+                getActivity().getApplicationContext(), this, this);
+        /// @}
+
+        Trace.endSection();
+    }
+
+    /**
+     * M: for plug-in, init customer view.
+     */
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        Trace.beginSection(TAG + " onViewCreated init plugin");
+        ExtensionManager.getInstance().getDialPadExtension().onViewCreated(getActivity(), view);
+        Trace.endSection();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) {
+        Trace.beginSection(TAG + " onCreateView");
+        Trace.beginSection(TAG + " inflate view");
+        final View fragmentView = inflater.inflate(R.layout.dialpad_fragment, container,
+                false);
+        Trace.endSection();
+        Trace.beginSection(TAG + " buildLayer");
+        fragmentView.buildLayer();
+        Trace.endSection();
+
+        ///M: WFC @{
+        mContext = getActivity();
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(TelecomManagerEx.ACTION_PHONE_ACCOUNT_CHANGED);
+        filter.addAction(TelecomManagerEx.ACTION_DEFAULT_ACCOUNT_CHANGED);
+        mContext.registerReceiver(mReceiver, filter);
+
+        ///@}
+        /// M: for plug-in @{
+        Trace.beginSection(TAG + " init plugin view");
+        ExtensionManager.getInstance().getDialPadExtension().onCreateView(inflater, container,
+                savedState, fragmentView);
+        Trace.endSection();
+        /// @}
+
+        Trace.beginSection(TAG + " setup views");
+
+        mDialpadView = (DialpadView) fragmentView.findViewById(R.id.dialpad_view);
+        mDialpadView.setCanDigitsBeEdited(true);
+        mDigits = mDialpadView.getDigits();
+        mDigits.setKeyListener(UnicodeDialerKeyListener.INSTANCE);
+        mDigits.setOnClickListener(this);
+        mDigits.setOnKeyListener(this);
+        mDigits.setOnLongClickListener(this);
+        mDigits.addTextChangedListener(this);
+        mDigits.setElegantTextHeight(false);
+        PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(getActivity(), mDigits);
+        // Check for the presence of the keypad
+        View oneButton = fragmentView.findViewById(R.id.one);
+        if (oneButton != null) {
+            configureKeypadListeners(fragmentView);
+        }
+
+        mDelete = mDialpadView.getDeleteButton();
+
+        if (mDelete != null) {
+            mDelete.setOnClickListener(this);
+            mDelete.setOnLongClickListener(this);
+        }
+
+        mSpacer = fragmentView.findViewById(R.id.spacer);
+        mSpacer.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                if (isDigitsEmpty()) {
+                    if (getActivity() != null) {
+                        return ((HostInterface) getActivity()).onDialpadSpacerTouchWithEmptyQuery();
+                    }
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        mDigits.setCursorVisible(false);
+
+        // Set up the "dialpad chooser" UI; see showDialpadChooser().
+        mDialpadChooser = (ListView) fragmentView.findViewById(R.id.dialpadChooser);
+        mDialpadChooser.setOnItemClickListener(this);
+
+        final View floatingActionButtonContainer =
+                fragmentView.findViewById(R.id.dialpad_floating_action_button_container);
+        final ImageButton floatingActionButton =
+                (ImageButton) fragmentView.findViewById(R.id.dialpad_floating_action_button);
+
+        /// M: Need to check if floatingActionButton is null. because in CT
+        // project, OP09 plugin will modify Dialpad layout and floatingActionButton
+        // will be null in that case. @{
+        if (null != floatingActionButton) {
+            floatingActionButton.setOnClickListener(this);
+            mFloatingActionButtonController = new FloatingActionButtonController(getActivity(),
+                    floatingActionButtonContainer, floatingActionButton);
+        }
+        /// @}
+
+        /// M: Fix CR ALPS01863413. Update text field view for ADN query.
+        SpecialCharSequenceMgr.updateTextFieldView(mDigits);
+
+        Trace.endSection();
+        Trace.endSection();
+        return fragmentView;
+    }
+
+    ///M: WFC @{
+   /* *
+      * Update the dialer icon based on WFC is registered or not.
+      *
+      */
+    private void updateWfcUI() {
+        final View floatingActionButton =
+                (ImageButton) getView().findViewById(R.id.dialpad_floating_action_button);
+        if (floatingActionButton != null) {
+            ImageView dialIcon = (ImageView) floatingActionButton;
+            PhoneAccountHandle defaultAccountHandle =
+                    TelecomUtil.getDefaultOutgoingPhoneAccount(getActivity(), SCHEME_TEL);
+            Log.d(TAG, "[WFC] defaultAccountHandle: " + defaultAccountHandle);
+            if (defaultAccountHandle != null) {
+                PhoneAccount phoneAccount = TelecomUtil.getPhoneAccount(getActivity(),
+                        defaultAccountHandle);
+                Log.d(TAG, "[WFC] Phone Account: " + phoneAccount);
+                if (phoneAccount != null){
+                  boolean wfcCapability = phoneAccount.hasCapabilities(
+                                                PhoneAccount.CAPABILITY_WIFI_CALLING);
+                  Log.d(TAG, "[WFC] WFC Capability: " + wfcCapability);
+                  if(wfcCapability){
+                      dialIcon.setImageDrawable(getResources()
+                              .getDrawable(R.drawable.mtk_fab_ic_wfc));
+                      Log.d(TAG, "[WFC] Dial Icon is changed to WFC dial icon");
+                  } else {
+                      dialIcon.setImageDrawable(getResources()
+                              .getDrawable(R.drawable.fab_ic_call));
+                  }
+                } else {
+                    dialIcon.setImageDrawable(getResources()
+                                           .getDrawable(R.drawable.fab_ic_call));
+                }
+            } else {
+                dialIcon.setImageDrawable(getResources().getDrawable(R.drawable.fab_ic_call));
+            }
+        }
+    }
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (TelecomManagerEx.ACTION_PHONE_ACCOUNT_CHANGED.equals(action)
+                    || TelecomManagerEx.ACTION_DEFAULT_ACCOUNT_CHANGED.equals(action)) {
+                Log.i(TAG, "[WFC] Intent recived is " + intent.getAction());
+                updateWfcUI();
+            }
+        }
+    };
+    ///@}
+    private boolean isLayoutReady() {
+        return mDigits != null;
+    }
+
+    @VisibleForTesting
+    public EditText getDigitsWidget() {
+        return mDigits;
+    }
+
+    /**
+     * @return true when {@link #mDigits} is actually filled by the Intent.
+     */
+    private boolean fillDigitsIfNecessary(Intent intent) {
+        // Only fills digits from an intent if it is a new intent.
+        // Otherwise falls back to the previously used number.
+        if (!mFirstLaunch && !mStartedFromNewIntent) {
+            return false;
+        }
+
+        final String action = intent.getAction();
+        if (Intent.ACTION_DIAL.equals(action) || Intent.ACTION_VIEW.equals(action)) {
+            Uri uri = intent.getData();
+            if (uri != null) {
+                if (PhoneAccount.SCHEME_TEL.equals(uri.getScheme())) {
+                    // Put the requested number into the input area
+                    String data = uri.getSchemeSpecificPart();
+                    // Remember it is filled via Intent.
+                    mDigitsFilledByIntent = true;
+                    final String converted = PhoneNumberUtils.convertKeypadLettersToDigits(
+                            PhoneNumberUtils.replaceUnicodeDigits(data));
+                    setFormattedDigits(converted, null);
+                    return true;
+                } else {
+                    if (!PermissionsUtil.hasContactsPermissions(getActivity())) {
+                        return false;
+                    }
+                    String type = intent.getType();
+                    if (People.CONTENT_ITEM_TYPE.equals(type)
+                            || Phones.CONTENT_ITEM_TYPE.equals(type)) {
+                        // Query the phone number
+                        Cursor c = getActivity().getContentResolver().query(intent.getData(),
+                                new String[] {PhonesColumns.NUMBER, PhonesColumns.NUMBER_KEY},
+                                null, null, null);
+                        if (c != null) {
+                            try {
+                                if (c.moveToFirst()) {
+                                    // Remember it is filled via Intent.
+                                    mDigitsFilledByIntent = true;
+                                    // Put the number into the input area
+                                    setFormattedDigits(c.getString(0), c.getString(1));
+                                    return true;
+                                }
+                            } finally {
+                                c.close();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determines whether an add call operation is requested.
+     *
+     * @param intent The intent.
+     * @return {@literal true} if add call operation was requested.  {@literal false} otherwise.
+     */
+    public static boolean isAddCallMode(Intent intent) {
+        if (intent == null) {
+            return false;
+        }
+        final String action = intent.getAction();
+        if (Intent.ACTION_DIAL.equals(action) || Intent.ACTION_VIEW.equals(action)) {
+            // see if we are "adding a call" from the InCallScreen; false by default.
+            return intent.getBooleanExtra(ADD_CALL_MODE_KEY, false);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Checks the given Intent and changes dialpad's UI state. For example, if the Intent requires
+     * the screen to enter "Add Call" mode, this method will show correct UI for the mode.
+     */
+    private void configureScreenFromIntent(Activity parent) {
+        // If we were not invoked with a DIAL intent,
+        if (!(parent instanceof DialtactsActivity)) {
+            setStartedFromNewIntent(false);
+            return;
+        }
+        // See if we were invoked with a DIAL intent. If we were, fill in the appropriate
+        // digits in the dialer field.
+        Intent intent = parent.getIntent();
+
+        if (!isLayoutReady()) {
+            // This happens typically when parent's Activity#onNewIntent() is called while
+            // Fragment#onCreateView() isn't called yet, and thus we cannot configure Views at
+            // this point. onViewCreate() should call this method after preparing layouts, so
+            // just ignore this call now.
+            Log.i(TAG,
+                    "Screen configuration is requested before onCreateView() is called. Ignored");
+            return;
+        }
+
+        boolean needToShowDialpadChooser = false;
+
+        // Be sure *not* to show the dialpad chooser if this is an
+        // explicit "Add call" action, though.
+        final boolean isAddCallMode = isAddCallMode(intent);
+        if (!isAddCallMode) {
+
+            // Don't show the chooser when called via onNewIntent() and phone number is present.
+            // i.e. User clicks a telephone link from gmail for example.
+            // In this case, we want to show the dialpad with the phone number.
+            final boolean digitsFilled = fillDigitsIfNecessary(intent);
+            if (!(mStartedFromNewIntent && digitsFilled)) {
+
+                final String action = intent.getAction();
+                if (Intent.ACTION_DIAL.equals(action) || Intent.ACTION_VIEW.equals(action)
+                        || Intent.ACTION_MAIN.equals(action)) {
+                    // If there's already an active call, bring up an intermediate UI to
+                    // make the user confirm what they really want to do.
+                    if (isPhoneInUse()) {
+                        needToShowDialpadChooser = true;
+                    }
+                }
+
+            }
+        }
+        showDialpadChooser(needToShowDialpadChooser);
+        setStartedFromNewIntent(false);
+    }
+
+    public void setStartedFromNewIntent(boolean value) {
+        mStartedFromNewIntent = value;
+    }
+
+    public void clearCallRateInformation() {
+        setCallRateInformation(null, null);
+    }
+
+    public void setCallRateInformation(String countryName, String displayRate) {
+        mDialpadView.setCallRateInformation(countryName, displayRate);
+    }
+
+    /**
+     * Sets formatted digits to digits field.
+     */
+    private void setFormattedDigits(String data, String normalizedNumber) {
+        final String formatted = getFormattedDigits(data, normalizedNumber, mCurrentCountryIso);
+        if (!TextUtils.isEmpty(formatted)) {
+            Editable digits = mDigits.getText();
+            digits.replace(0, digits.length(), formatted);
+            // for some reason this isn't getting called in the digits.replace call above..
+            // but in any case, this will make sure the background drawable looks right
+            afterTextChanged(digits);
+        }
+    }
+
+    /**
+     * Format the provided string of digits into one that represents a properly formatted phone
+     * number.
+     *
+     * @param dialString String of characters to format
+     * @param normalizedNumber the E164 format number whose country code is used if the given
+     *         phoneNumber doesn't have the country code.
+     * @param countryIso The country code representing the format to use if the provided normalized
+     *         number is null or invalid.
+     * @return the provided string of digits as a formatted phone number, retaining any
+     *         post-dial portion of the string.
+     */
+    @VisibleForTesting
+    static String getFormattedDigits(String dialString, String normalizedNumber, String countryIso) {
+        String number = PhoneNumberUtils.extractNetworkPortion(dialString);
+        // Also retrieve the post dial portion of the provided data, so that the entire dial
+        // string can be reconstituted later.
+        final String postDial = PhoneNumberUtils.extractPostDialPortion(dialString);
+
+        if (TextUtils.isEmpty(number)) {
+            return postDial;
+        }
+
+        number = PhoneNumberUtils.formatNumber(number, normalizedNumber, countryIso);
+
+        if (TextUtils.isEmpty(postDial)) {
+            return number;
+        }
+
+        return number.concat(postDial);
+    }
+
+    private void configureKeypadListeners(View fragmentView) {
+        final int[] buttonIds = new int[] {R.id.one, R.id.two, R.id.three, R.id.four, R.id.five,
+                R.id.six, R.id.seven, R.id.eight, R.id.nine, R.id.star, R.id.zero, R.id.pound};
+
+        DialpadKeyButton dialpadKey;
+
+        for (int i = 0; i < buttonIds.length; i++) {
+            dialpadKey = (DialpadKeyButton) fragmentView.findViewById(buttonIds[i]);
+            dialpadKey.setOnPressedListener(this);
+        }
+
+        // Long-pressing one button will initiate Voicemail.
+        final DialpadKeyButton one = (DialpadKeyButton) fragmentView.findViewById(R.id.one);
+        one.setOnLongClickListener(this);
+
+        // Long-pressing zero button will enter '+' instead.
+        final DialpadKeyButton zero = (DialpadKeyButton) fragmentView.findViewById(R.id.zero);
+        zero.setOnLongClickListener(this);
+    }
+
+    @Override
+    public void onStart() {
+        Trace.beginSection(TAG + " onStart");
+        super.onStart();
+        // if the mToneGenerator creation fails, just continue without it.  It is
+        // a local audio signal, and is not as important as the dtmf tone itself.
+        final long start = System.currentTimeMillis();
+        synchronized (mToneGeneratorLock) {
+            if (mToneGenerator == null) {
+                try {
+                    mToneGenerator = new ToneGenerator(DIAL_TONE_STREAM_TYPE, TONE_RELATIVE_VOLUME);
+                } catch (RuntimeException e) {
+                    Log.w(TAG, "Exception caught while creating local tone generator: " + e);
+                    mToneGenerator = null;
+                }
+            }
+        }
+        final long total = System.currentTimeMillis() - start;
+        if (total > 50) {
+            Log.i(TAG, "Time for ToneGenerator creation: " + total);
+        }
+        Trace.endSection();
+    };
+
+    @Override
+    public void onResume() {
+        Trace.beginSection(TAG + " onResume");
+        super.onResume();
+
+        /// M: [VoLTE ConfCall] initialize value about conference call capability.
+        mVolteConfCallEnabled = supportOneKeyConference(getActivity());
+        Log.d(TAG, "onResume mVolteConfCallEnabled = " + mVolteConfCallEnabled);
+
+        final DialtactsActivity activity = (DialtactsActivity) getActivity();
+        mDialpadQueryListener = activity;
+
+        final StopWatch stopWatch = StopWatch.start("Dialpad.onResume");
+
+        // Query the last dialed number. Do it first because hitting
+        // the DB is 'slow'. This call is asynchronous.
+        queryLastOutgoingCall();
+
+        stopWatch.lap("qloc");
+
+        final ContentResolver contentResolver = activity.getContentResolver();
+
+        /// M: [ALPS01858019] add listener to observer CallLog changes
+        contentResolver.registerContentObserver(CallLog.CONTENT_URI, true, mCallLogObserver);
+
+        // retrieve the DTMF tone play back setting.
+        mDTMFToneEnabled = Settings.System.getInt(contentResolver,
+                Settings.System.DTMF_TONE_WHEN_DIALING, 1) == 1;
+
+        stopWatch.lap("dtwd");
+
+        stopWatch.lap("hptc");
+
+        mPressedDialpadKeys.clear();
+
+        configureScreenFromIntent(getActivity());
+
+        stopWatch.lap("fdin");
+
+        if (!isPhoneInUse()) {
+            // A sanity-check: the "dialpad chooser" UI should not be visible if the phone is idle.
+            showDialpadChooser(false);
+        }
+
+        ///M: WFC @{
+        updateWfcUI();
+        ///@}
+        stopWatch.lap("hnt");
+
+        updateDeleteButtonEnabledState();
+
+        stopWatch.lap("bes");
+
+        stopWatch.stopAndLog(TAG, 50);
+
+        // Populate the overflow menu in onResume instead of onCreate, so that if the SMS activity
+        // is disabled while Dialer is paused, the "Send a text message" option can be correctly
+        // removed when resumed.
+        mOverflowMenuButton = mDialpadView.getOverflowMenuButton();
+        mOverflowPopupMenu = buildOptionsMenu(mOverflowMenuButton);
+        mOverflowMenuButton.setOnTouchListener(mOverflowPopupMenu.getDragToOpenListener());
+        mOverflowMenuButton.setOnClickListener(this);
+        mOverflowMenuButton.setVisibility(isDigitsEmpty() ? View.INVISIBLE : View.VISIBLE);
+        /** M: [VoLTE ConfCall] Always show overflow menu button for conf call. @{ */
+        if (mVolteConfCallEnabled) {
+            mOverflowMenuButton.setVisibility(View.VISIBLE);
+            mOverflowMenuButton.setAlpha(1);
+        }
+        /** @} */
+
+        if (mFirstLaunch) {
+            // The onHiddenChanged callback does not get called the first time the fragment is
+            // attached, so call it ourselves here.
+            onHiddenChanged(false);
+        }
+
+        /// M: for Plug-in @{
+        ExtensionManager.getInstance().getDialPadExtension().onResume();
+        /// @}
+
+        mFirstLaunch = false;
+        Trace.endSection();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        // M: dismiss popup menu, in case of memory leak @{
+        if(mOverflowPopupMenu != null) {
+            mOverflowPopupMenu.dismiss();
+        }
+        // @}
+        // Make sure we don't leave this activity with a tone still playing.
+        stopTone();
+        mPressedDialpadKeys.clear();
+
+        // TODO: I wonder if we should not check if the AsyncTask that
+        // lookup the last dialed number has completed.
+        mLastNumberDialed = EMPTY_NUMBER;  // Since we are going to query again, free stale number.
+
+        SpecialCharSequenceMgr.cleanup();
+
+        /// M: [ALPS01858019] add unregister the call log observer.
+        getActivity().getContentResolver().unregisterContentObserver(mCallLogObserver);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        synchronized (mToneGeneratorLock) {
+            if (mToneGenerator != null) {
+                mToneGenerator.release();
+                mToneGenerator = null;
+            }
+        }
+
+        if (mClearDigitsOnStop) {
+            mClearDigitsOnStop = false;
+            clearDialpad();
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(PREF_DIGITS_FILLED_BY_INTENT, mDigitsFilledByIntent);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (mPseudoEmergencyAnimator != null) {
+            mPseudoEmergencyAnimator.destroy();
+            mPseudoEmergencyAnimator = null;
+        }
+        ((Context) getActivity()).unregisterReceiver(mCallStateReceiver);
+        /// M: for plug-in. @{
+        ExtensionManager.getInstance().getDialPadExtension().onDestroy();
+        /// @}
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        ///M: WFC @{
+        mContext.unregisterReceiver(mReceiver);
+        ///@}
+    }
+    private void keyPressed(int keyCode) {
+        if (getView() == null || getView().getTranslationY() != 0) {
+            return;
+        }
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_1:
+                playTone(ToneGenerator.TONE_DTMF_1, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_2:
+                playTone(ToneGenerator.TONE_DTMF_2, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_3:
+                playTone(ToneGenerator.TONE_DTMF_3, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_4:
+                playTone(ToneGenerator.TONE_DTMF_4, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_5:
+                playTone(ToneGenerator.TONE_DTMF_5, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_6:
+                playTone(ToneGenerator.TONE_DTMF_6, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_7:
+                playTone(ToneGenerator.TONE_DTMF_7, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_8:
+                playTone(ToneGenerator.TONE_DTMF_8, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_9:
+                playTone(ToneGenerator.TONE_DTMF_9, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_0:
+                playTone(ToneGenerator.TONE_DTMF_0, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_POUND:
+                playTone(ToneGenerator.TONE_DTMF_P, TONE_LENGTH_INFINITE);
+                break;
+            case KeyEvent.KEYCODE_STAR:
+                playTone(ToneGenerator.TONE_DTMF_S, TONE_LENGTH_INFINITE);
+                break;
+            default:
+                break;
+        }
+
+        getView().performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
+        mDigits.onKeyDown(keyCode, event);
+
+        // If the cursor is at the end of the text we hide it.
+        final int length = mDigits.length();
+        if (length == mDigits.getSelectionStart() && length == mDigits.getSelectionEnd()) {
+            mDigits.setCursorVisible(false);
+        }
+    }
+
+    @Override
+    public boolean onKey(View view, int keyCode, KeyEvent event) {
+        if (view.getId() == R.id.digits) {
+            if (keyCode == KeyEvent.KEYCODE_ENTER) {
+                handleDialButtonPressed();
+                return true;
+            }
+
+        }
+        return false;
+    }
+
+    /**
+     * When a key is pressed, we start playing DTMF tone, do vibration, and enter the digit
+     * immediately. When a key is released, we stop the tone. Note that the "key press" event will
+     * be delivered by the system with certain amount of delay, it won't be synced with user's
+     * actual "touch-down" behavior.
+     */
+    @Override
+    public void onPressed(View view, boolean pressed) {
+        /** M: Prevent the event if dialpad is not shown. @{ */
+        if (pressed && getActivity() != null
+                && !((DialtactsActivity)getActivity()).isDialpadShown()) {
+            Log.d(TAG, "onPressed but dialpad is not shown, skip !!!");
+            return;
+        }
+        /** @} */
+        if (DEBUG) Log.d(TAG, "onPressed(). view: " + view + ", pressed: " + pressed);
+        if (pressed) {
+            int resId = view.getId();
+            if (resId == R.id.one) {
+                keyPressed(KeyEvent.KEYCODE_1);
+            } else if (resId == R.id.two) {
+                keyPressed(KeyEvent.KEYCODE_2);
+            } else if (resId == R.id.three) {
+                keyPressed(KeyEvent.KEYCODE_3);
+            } else if (resId == R.id.four) {
+                keyPressed(KeyEvent.KEYCODE_4);
+            } else if (resId == R.id.five) {
+                keyPressed(KeyEvent.KEYCODE_5);
+            } else if (resId == R.id.six) {
+                keyPressed(KeyEvent.KEYCODE_6);
+            } else if (resId == R.id.seven) {
+                keyPressed(KeyEvent.KEYCODE_7);
+            } else if (resId == R.id.eight) {
+                keyPressed(KeyEvent.KEYCODE_8);
+            } else if (resId == R.id.nine) {
+                keyPressed(KeyEvent.KEYCODE_9);
+            } else if (resId == R.id.zero) {
+                keyPressed(KeyEvent.KEYCODE_0);
+            } else if (resId == R.id.pound) {
+                keyPressed(KeyEvent.KEYCODE_POUND);
+            } else if (resId == R.id.star) {
+                keyPressed(KeyEvent.KEYCODE_STAR);
+            } else {
+                Log.wtf(TAG, "Unexpected onTouch(ACTION_DOWN) event from: " + view);
+            }
+            mPressedDialpadKeys.add(view);
+        } else {
+            mPressedDialpadKeys.remove(view);
+            if (mPressedDialpadKeys.isEmpty()) {
+                stopTone();
+            }
+        }
+    }
+
+    /**
+     * Called by the containing Activity to tell this Fragment to build an overflow options
+     * menu for display by the container when appropriate.
+     *
+     * @param invoker the View that invoked the options menu, to act as an anchor location.
+     */
+    private PopupMenu buildOptionsMenu(View invoker) {
+        final PopupMenu popupMenu = new PopupMenu(getActivity(), invoker) {
+            @Override
+            public void show() {
+                final Menu menu = getMenu();
+
+                boolean enable = !isDigitsEmpty();
+                for (int i = 0; i < menu.size(); i++) {
+                    MenuItem item = menu.getItem(i);
+                    /// M: [VoLTE ConfCall] Change visible to hide some menu instead of setEnable()
+                    item.setVisible(enable);
+                    if (item.getItemId() == R.id.menu_call_with_note) {
+                        item.setVisible(CallUtil.isCallWithSubjectSupported(getContext()));
+                    }
+                }
+                /** M: [IP Dial] Check whether to show button @{ */
+                //menu.findItem(R.id.menu_ip_dial).setVisible(
+                //        DialerFeatureOptions.isIpPrefixSupport() && enable
+                //       && !PhoneNumberHelper.isUriNumber(mDigits.getText().toString()));
+                menu.findItem(R.id.menu_ip_dial).setVisible(false);
+                /** @} */
+                /** M: [VoLTE ConfCall] Show conference call menu for volte. @{ */
+                mVolteConfCallEnabled = supportOneKeyConference(getActivity());
+                boolean visible = mVolteConfCallEnabled;
+                Log.d(TAG, "buildOptionsMenu, mVolteConfCallEnabled = " + mVolteConfCallEnabled);
+                menu.findItem(R.id.menu_volte_conf_call).setVisible(visible);
+                /** @} */
+
+                super.show();
+            }
+        };
+        popupMenu.inflate(R.menu.dialpad_options);
+        popupMenu.setOnMenuItemClickListener(this);
+        return popupMenu;
+    }
+
+    @Override
+    public void onClick(View view) {
+        /** M: Prevent the event if dialpad is not shown. @{ */
+        if (getActivity() != null
+                && !((DialtactsActivity)getActivity()).isDialpadShown()) {
+            Log.d(TAG, "onClick but dialpad is not shown, skip !!!");
+            return;
+        }
+        /** @} */
+        int resId = view.getId();
+        if (resId == R.id.dialpad_floating_action_button) {
+            view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+            handleDialButtonPressed();
+        } else if (resId == R.id.deleteButton) {
+            keyPressed(KeyEvent.KEYCODE_DEL);
+        } else if (resId == R.id.digits) {
+            if (!isDigitsEmpty()) {
+                mDigits.setCursorVisible(true);
+            }
+        } else if (resId == R.id.dialpad_overflow) {
+            /// M: for plug-in @{
+            ExtensionManager.getInstance().getDialPadExtension().constructPopupMenu(
+                    mOverflowPopupMenu, mOverflowMenuButton, mOverflowPopupMenu.getMenu());
+            /// @}
+            mOverflowPopupMenu.show();
+        } else {
+            Log.wtf(TAG, "Unexpected onClick() event from: " + view);
+            return;
+        }
+    }
+
+    @Override
+    public boolean onLongClick(View view) {
+        final Editable digits = mDigits.getText();
+        final int id = view.getId();
+        if (id == R.id.deleteButton) {
+            digits.clear();
+            return true;
+        } else if (id == R.id.one) {
+            if (isDigitsEmpty() || TextUtils.equals(mDigits.getText(), "1")) {
+                // We'll try to initiate voicemail and thus we want to remove irrelevant string.
+                removePreviousDigitIfPossible('1');
+
+                List<PhoneAccountHandle> subscriptionAccountHandles =
+                        PhoneAccountUtils.getSubscriptionPhoneAccounts(getActivity());
+                boolean hasUserSelectedDefault = subscriptionAccountHandles.contains(
+                        TelecomUtil.getDefaultOutgoingPhoneAccount(getActivity(),
+                                PhoneAccount.SCHEME_VOICEMAIL));
+                boolean needsAccountDisambiguation = subscriptionAccountHandles.size() > 1
+                        && !hasUserSelectedDefault;
+
+                if (needsAccountDisambiguation || isVoicemailAvailable()) {
+                    // On a multi-SIM phone, if the user has not selected a default
+                    // subscription, initiate a call to voicemail so they can select an account
+                    // from the "Call with" dialog.
+                    callVoicemail();
+                } else if (getActivity() != null) {
+                    // Voicemail is unavailable maybe because Airplane mode is turned on.
+                    // Check the current status and show the most appropriate error message.
+                    final boolean isAirplaneModeOn =
+                            Settings.System.getInt(getActivity().getContentResolver(),
+                                    Settings.System.AIRPLANE_MODE_ON, 0) != 0;
+                    if (isAirplaneModeOn) {
+                        DialogFragment dialogFragment = ErrorDialogFragment.newInstance(
+                                R.string.dialog_voicemail_airplane_mode_message);
+                        dialogFragment.show(getFragmentManager(),
+                                "voicemail_request_during_airplane_mode");
+                    } else {
+                        DialogFragment dialogFragment = ErrorDialogFragment.newInstance(
+                                R.string.dialog_voicemail_not_ready_message);
+                        dialogFragment.show(getFragmentManager(), "voicemail_not_ready");
+                    }
+                }
+                return true;
+            }
+            return false;
+        } else if (id == R.id.zero) {
+            if (mPressedDialpadKeys.contains(view)) {
+                // If the zero key is currently pressed, then the long press occurred by touch
+                // (and not via other means like certain accessibility input methods).
+                // Remove the '0' that was input when the key was first pressed.
+                removePreviousDigitIfPossible('0');
+            }
+            keyPressed(KeyEvent.KEYCODE_PLUS);
+            stopTone();
+            mPressedDialpadKeys.remove(view);
+            return true;
+        } else if (id == R.id.digits) {
+            mDigits.setCursorVisible(true);
+            return false;
+        }
+        return false;
+    }
+
+    /**
+     * Remove the digit just before the current position of the cursor, iff the following conditions
+     *  are true:
+     * 1) The cursor is not positioned at index 0.
+     * 2) The digit before the current cursor position matches the current digit.
+     *
+     * @param digit to remove from the digits view.
+     */
+    private void removePreviousDigitIfPossible(char digit) {
+        final int currentPosition = mDigits.getSelectionStart();
+        if (currentPosition > 0 && digit == mDigits.getText().charAt(currentPosition - 1)) {
+            mDigits.setSelection(currentPosition);
+            mDigits.getText().delete(currentPosition - 1, currentPosition);
+        }
+    }
+
+    public void callVoicemail() {
+        DialerUtils.startActivityWithErrorToast(getActivity(),
+                new CallIntentBuilder(CallUtil.getVoicemailUri())
+                        .setCallInitiationType(LogState.INITIATION_DIALPAD)
+                        .build());
+        hideAndClearDialpad(false);
+    }
+
+    private void hideAndClearDialpad(boolean animate) {
+        /// M: Avoid type Incompatible and NPE error @{
+        if (getActivity() instanceof DialtactsActivity) {
+            ((DialtactsActivity) getActivity()).hideDialpadFragment(animate, true);
+        }
+        /// @}
+    }
+
+    public static class ErrorDialogFragment extends DialogFragment {
+        private int mTitleResId;
+        private int mMessageResId;
+
+        private static final String ARG_TITLE_RES_ID = "argTitleResId";
+        private static final String ARG_MESSAGE_RES_ID = "argMessageResId";
+
+        public static ErrorDialogFragment newInstance(int messageResId) {
+            return newInstance(0, messageResId);
+        }
+
+        public static ErrorDialogFragment newInstance(int titleResId, int messageResId) {
+            final ErrorDialogFragment fragment = new ErrorDialogFragment();
+            final Bundle args = new Bundle();
+            args.putInt(ARG_TITLE_RES_ID, titleResId);
+            args.putInt(ARG_MESSAGE_RES_ID, messageResId);
+            fragment.setArguments(args);
+            return fragment;
+        }
+
+        @Override
+        public void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            mTitleResId = getArguments().getInt(ARG_TITLE_RES_ID);
+            mMessageResId = getArguments().getInt(ARG_MESSAGE_RES_ID);
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+            if (mTitleResId != 0) {
+                builder.setTitle(mTitleResId);
+            }
+            if (mMessageResId != 0) {
+                builder.setMessage(mMessageResId);
+            }
+            builder.setPositiveButton(android.R.string.ok,
+                    new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                dismiss();
+                            }
+                    });
+            return builder.create();
+        }
+    }
+
+    /**
+     * In most cases, when the dial button is pressed, there is a
+     * number in digits area. Pack it in the intent, start the
+     * outgoing call broadcast as a separate task and finish this
+     * activity.
+     *
+     * When there is no digit and the phone is CDMA and off hook,
+     * we're sending a blank flash for CDMA. CDMA networks use Flash
+     * messages when special processing needs to be done, mainly for
+     * 3-way or call waiting scenarios. Presumably, here we're in a
+     * special 3-way scenario where the network needs a blank flash
+     * before being able to add the new participant.  (This is not the
+     * case with all 3-way calls, just certain CDMA infrastructures.)
+     *
+     * Otherwise, there is no digit, display the last dialed
+     * number. Don't finish since the user may want to edit it. The
+     * user needs to press the dial button again, to dial it (general
+     * case described above).
+     */
+    private void handleDialButtonPressed() {
+        /// M: [IP Dial] add IP dial
+        handleDialButtonPressed(Constants.DIAL_NUMBER_INTENT_NORMAL);
+    }
+
+    private void handleDialButtonPressed(int type) {
+        if (isDigitsEmpty()) { // No number entered.
+            handleDialButtonClickWithEmptyDigits();
+        } else {
+            final String number = mDigits.getText().toString();
+
+            // "persist.radio.otaspdial" is a temporary hack needed for one carrier's automated
+            // test equipment.
+            // TODO: clean it up.
+            if (number != null
+                    && !TextUtils.isEmpty(mProhibitedPhoneNumberRegexp)
+                    && number.matches(mProhibitedPhoneNumberRegexp)) {
+                Log.i(TAG, "The phone number is prohibited explicitly by a rule.");
+                if (getActivity() != null) {
+                    DialogFragment dialogFragment = ErrorDialogFragment.newInstance(
+                            R.string.dialog_phone_call_prohibited_message);
+                    dialogFragment.show(getFragmentManager(), "phone_prohibited_dialog");
+                }
+
+                // Clear the digits just in case.
+                clearDialpad();
+            } else {
+                final Intent intent;
+                /** M: [IP Dial] check the type of call @{ */
+                if (type != Constants.DIAL_NUMBER_INTENT_NORMAL) {
+                    intent = IntentUtil.getCallIntent(IntentUtil.getCallUri(number),
+                            LogState.INITIATION_DIALPAD, type);
+                } else {
+                    intent = new CallIntentBuilder(number).
+                            setCallInitiationType(LogState.INITIATION_DIALPAD)
+                            .build();
+                }
+                /** @} */
+                DialerUtils.startActivityWithErrorToast(getActivity(), intent);
+                hideAndClearDialpad(false);
+
+            }
+        }
+    }
+
+    public void clearDialpad() {
+        if (mDigits != null) {
+            mDigits.getText().clear();
+        }
+    }
+
+    public void handleDialButtonClickWithEmptyDigits() {
+        /// M:refactor CDMA phone is in call check
+        if (isCdmaInCall()) {
+            // TODO: Move this logic into services/Telephony
+            //
+            // This is really CDMA specific. On GSM is it possible
+            // to be off hook and wanted to add a 3rd party using
+            // the redial feature.
+            startActivity(newFlashIntent());
+        } else {
+            if (!TextUtils.isEmpty(mLastNumberDialed)) {
+                // Recall the last number dialed.
+                mDigits.setText(mLastNumberDialed);
+
+                // ...and move the cursor to the end of the digits string,
+                // so you'll be able to delete digits using the Delete
+                // button (just as if you had typed the number manually.)
+                //
+                // Note we use mDigits.getText().length() here, not
+                // mLastNumberDialed.length(), since the EditText widget now
+                // contains a *formatted* version of mLastNumberDialed (due to
+                // mTextWatcher) and its length may have changed.
+                mDigits.setSelection(mDigits.getText().length());
+            } else {
+                // There's no "last number dialed" or the
+                // background query is still running. There's
+                // nothing useful for the Dial button to do in
+                // this case.  Note: with a soft dial button, this
+                // can never happens since the dial button is
+                // disabled under these conditons.
+                playTone(ToneGenerator.TONE_PROP_NACK);
+            }
+        }
+    }
+
+    /**
+     * Plays the specified tone for TONE_LENGTH_MS milliseconds.
+     */
+    private void playTone(int tone) {
+        playTone(tone, TONE_LENGTH_MS);
+    }
+
+    /**
+     * Play the specified tone for the specified milliseconds
+     *
+     * The tone is played locally, using the audio stream for phone calls.
+     * Tones are played only if the "Audible touch tones" user preference
+     * is checked, and are NOT played if the device is in silent mode.
+     *
+     * The tone length can be -1, meaning "keep playing the tone." If the caller does so, it should
+     * call stopTone() afterward.
+     *
+     * @param tone a tone code from {@link ToneGenerator}
+     * @param durationMs tone length.
+     */
+    private void playTone(int tone, int durationMs) {
+        // if local tone playback is disabled, just return.
+        if (!mDTMFToneEnabled) {
+            return;
+        }
+
+        // Also do nothing if the phone is in silent mode.
+        // We need to re-check the ringer mode for *every* playTone()
+        // call, rather than keeping a local flag that's updated in
+        // onResume(), since it's possible to toggle silent mode without
+        // leaving the current activity (via the ENDCALL-longpress menu.)
+        AudioManager audioManager =
+                (AudioManager) getActivity().getSystemService(Context.AUDIO_SERVICE);
+        int ringerMode = audioManager.getRingerMode();
+        if ((ringerMode == AudioManager.RINGER_MODE_SILENT)
+            || (ringerMode == AudioManager.RINGER_MODE_VIBRATE)) {
+            return;
+        }
+
+        synchronized (mToneGeneratorLock) {
+            if (mToneGenerator == null) {
+                Log.w(TAG, "playTone: mToneGenerator == null, tone: " + tone);
+                return;
+            }
+
+            // Start the new tone (will stop any playing tone)
+            mToneGenerator.startTone(tone, durationMs);
+        }
+    }
+
+    /**
+     * Stop the tone if it is played.
+     */
+    private void stopTone() {
+        // if local tone playback is disabled, just return.
+        if (!mDTMFToneEnabled) {
+            return;
+        }
+        synchronized (mToneGeneratorLock) {
+            if (mToneGenerator == null) {
+                Log.w(TAG, "stopTone: mToneGenerator == null");
+                return;
+            }
+            mToneGenerator.stopTone();
+        }
+    }
+
+    /**
+     * Brings up the "dialpad chooser" UI in place of the usual Dialer
+     * elements (the textfield/button and the dialpad underneath).
+     *
+     * We show this UI if the user brings up the Dialer while a call is
+     * already in progress, since there's a good chance we got here
+     * accidentally (and the user really wanted the in-call dialpad instead).
+     * So in this situation we display an intermediate UI that lets the user
+     * explicitly choose between the in-call dialpad ("Use touch tone
+     * keypad") and the regular Dialer ("Add call").  (Or, the option "Return
+     * to call in progress" just goes back to the in-call UI with no dialpad
+     * at all.)
+     *
+     * @param enabled If true, show the "dialpad chooser" instead
+     *                of the regular Dialer UI
+     */
+    private void showDialpadChooser(boolean enabled) {
+        if (getActivity() == null) {
+            return;
+        }
+        // Check if onCreateView() is already called by checking one of View objects.
+        if (!isLayoutReady()) {
+            return;
+        }
+
+        if (enabled) {
+            Log.d(TAG, "Showing dialpad chooser!");
+            if (mDialpadView != null) {
+                mDialpadView.setVisibility(View.GONE);
+            }
+
+            /// M: Need to check if floatingActionButton is null. because in CT
+            // project, OP09 plugin will modify Dialpad layout and floatingActionButton
+            // will be null in that case. @{
+            if (null != mFloatingActionButtonController) {
+                mFloatingActionButtonController.setVisible(false);
+            }
+            /// @}
+
+            mDialpadChooser.setVisibility(View.VISIBLE);
+
+            // Instantiate the DialpadChooserAdapter and hook it up to the
+            // ListView.  We do this only once.
+            if (mDialpadChooserAdapter == null) {
+                mDialpadChooserAdapter = new DialpadChooserAdapter(getActivity());
+            }
+            mDialpadChooser.setAdapter(mDialpadChooserAdapter);
+            /// M: fix for ALPS03445439 @{
+            if (getActivity() instanceof DialtactsActivity) {
+                ((DialtactsActivity) getActivity()).onDialpadShown();
+            }
+            mIsDialpadChooserShown = true;
+            /// @}
+        } else {
+            Log.d(TAG, "Displaying normal Dialer UI.");
+            if (mDialpadView != null) {
+                mDialpadView.setVisibility(View.VISIBLE);
+            } else {
+                mDigits.setVisibility(View.VISIBLE);
+            }
+
+            /**
+             * M: If the scaleOut() of FloatingActionButtonController be called
+             * at previous, the floating button and container would all be set
+             * to GONE. But the setVisible() method only set the floating
+             * container to visible. So that the floating button is GONE yet.
+             * So, it should call the scaleIn() to make sure all of them be set
+             * to visible. @{
+             */
+            /*
+             * mFloatingActionButtonController.setVisible(true);
+             */
+
+            /// M: Need to check if floatingActionButton is null. because in CT
+            // project, OP09 plugin will modify Dialpad layout and floatingActionButton
+            // will be null in that case. @{
+            if (null != mFloatingActionButtonController) {
+                mFloatingActionButtonController.scaleIn(0);
+            }
+            /// @}
+
+            /** @} */
+            mDialpadChooser.setVisibility(View.GONE);
+            //if (getActivity() instanceof DialtactsActivity) {
+            //    ((DialtactsActivity) getActivity()).onDialpadShown();
+            //}
+            /// M: fix for ALPS03445439 @{
+            mIsDialpadChooserShown = false;
+            /// @}
+        }
+
+        /// M: for plug-in @{
+        ExtensionManager.getInstance().getDialPadExtension().showDialpadChooser(enabled);
+        /// @}
+    }
+
+    /**
+     * @return true if we're currently showing the "dialpad chooser" UI.
+     */
+    private boolean isDialpadChooserVisible() {
+        return mDialpadChooser.getVisibility() == View.VISIBLE;
+    }
+
+    /**
+     * Simple list adapter, binding to an icon + text label
+     * for each item in the "dialpad chooser" list.
+     */
+    private static class DialpadChooserAdapter extends BaseAdapter {
+        private LayoutInflater mInflater;
+
+        // Simple struct for a single "choice" item.
+        static class ChoiceItem {
+            String text;
+            Bitmap icon;
+            int id;
+
+            public ChoiceItem(String s, Bitmap b, int i) {
+                text = s;
+                icon = b;
+                id = i;
+            }
+        }
+
+        // IDs for the possible "choices":
+        static final int DIALPAD_CHOICE_USE_DTMF_DIALPAD = 101;
+        static final int DIALPAD_CHOICE_RETURN_TO_CALL = 102;
+        static final int DIALPAD_CHOICE_ADD_NEW_CALL = 103;
+
+        private static final int NUM_ITEMS = 3;
+        private ChoiceItem mChoiceItems[] = new ChoiceItem[NUM_ITEMS];
+
+        public DialpadChooserAdapter(Context context) {
+            // Cache the LayoutInflate to avoid asking for a new one each time.
+            mInflater = LayoutInflater.from(context);
+
+            // Initialize the possible choices.
+            // TODO: could this be specified entirely in XML?
+
+            // - "Use touch tone keypad"
+            mChoiceItems[0] = new ChoiceItem(
+                    context.getString(R.string.dialer_useDtmfDialpad),
+                    BitmapFactory.decodeResource(context.getResources(),
+                                                 R.drawable.ic_dialer_fork_tt_keypad),
+                    DIALPAD_CHOICE_USE_DTMF_DIALPAD);
+
+            // - "Return to call in progress"
+            mChoiceItems[1] = new ChoiceItem(
+                    context.getString(R.string.dialer_returnToInCallScreen),
+                    BitmapFactory.decodeResource(context.getResources(),
+                                                 R.drawable.ic_dialer_fork_current_call),
+                    DIALPAD_CHOICE_RETURN_TO_CALL);
+
+            // - "Add call"
+            mChoiceItems[2] = new ChoiceItem(
+                    context.getString(R.string.dialer_addAnotherCall),
+                    BitmapFactory.decodeResource(context.getResources(),
+                                                 R.drawable.ic_dialer_fork_add_call),
+                    DIALPAD_CHOICE_ADD_NEW_CALL);
+        }
+
+        @Override
+        public int getCount() {
+            return NUM_ITEMS;
+        }
+
+        /**
+         * Return the ChoiceItem for a given position.
+         */
+        @Override
+        public Object getItem(int position) {
+            return mChoiceItems[position];
+        }
+
+        /**
+         * Return a unique ID for each possible choice.
+         */
+        @Override
+        public long getItemId(int position) {
+            return position;
+        }
+
+        /**
+         * Make a view for each row.
+         */
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            // When convertView is non-null, we can reuse it (there's no need
+            // to reinflate it.)
+            if (convertView == null) {
+                convertView = mInflater.inflate(R.layout.dialpad_chooser_list_item, null);
+            }
+
+            TextView text = (TextView) convertView.findViewById(R.id.text);
+            text.setText(mChoiceItems[position].text);
+
+            ImageView icon = (ImageView) convertView.findViewById(R.id.icon);
+            icon.setImageBitmap(mChoiceItems[position].icon);
+
+            return convertView;
+        }
+    }
+
+    /**
+     * Handle clicks from the dialpad chooser.
+     */
+    @Override
+    public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
+        DialpadChooserAdapter.ChoiceItem item =
+                (DialpadChooserAdapter.ChoiceItem) parent.getItemAtPosition(position);
+        int itemId = item.id;
+        if (itemId == DialpadChooserAdapter.DIALPAD_CHOICE_USE_DTMF_DIALPAD) {// Log.i(TAG, "DIALPAD_CHOICE_USE_DTMF_DIALPAD");
+            // Fire off an intent to go back to the in-call UI
+            // with the dialpad visible.
+            returnToInCallScreen(true);
+        } else if (itemId == DialpadChooserAdapter.DIALPAD_CHOICE_RETURN_TO_CALL) {// Log.i(TAG, "DIALPAD_CHOICE_RETURN_TO_CALL");
+            // Fire off an intent to go back to the in-call UI
+            // (with the dialpad hidden).
+            returnToInCallScreen(false);
+        } else if (itemId == DialpadChooserAdapter.DIALPAD_CHOICE_ADD_NEW_CALL) {// Log.i(TAG, "DIALPAD_CHOICE_ADD_NEW_CALL");
+            // Ok, guess the user really did want to be here (in the
+            // regular Dialer) after all.  Bring back the normal Dialer UI.
+            showDialpadChooser(false);
+        } else {
+            Log.w(TAG, "onItemClick: unexpected itemId: " + itemId);
+        }
+    }
+
+    /**
+     * Returns to the in-call UI (where there's presumably a call in
+     * progress) in response to the user selecting "use touch tone keypad"
+     * or "return to call" from the dialpad chooser.
+     */
+    private void returnToInCallScreen(boolean showDialpad) {
+        TelecomUtil.showInCallScreen(getActivity(), showDialpad);
+
+        // Finally, finish() ourselves so that we don't stay on the
+        // activity stack.
+        // Note that we do this whether or not the showCallScreenWithDialpad()
+        // call above had any effect or not!  (That call is a no-op if the
+        // phone is idle, which can happen if the current call ends while
+        // the dialpad chooser is up.  In this case we can't show the
+        // InCallScreen, and there's no point staying here in the Dialer,
+        // so we just take the user back where he came from...)
+        getActivity().finish();
+    }
+
+    /**
+     * @return true if the phone is "in use", meaning that at least one line
+     *              is active (ie. off hook or ringing or dialing, or on hold).
+     */
+    private boolean isPhoneInUse() {
+        final Context context = getActivity();
+        if (context != null) {
+            return TelecomUtil.isInCall(context);
+        }
+        return false;
+    }
+
+    /**
+     * @return true if the phone is a CDMA phone type
+     */
+    private boolean phoneIsCdma() {
+        return getTelephonyManager().getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA;
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        int resId = item.getItemId();
+        if (resId == R.id.menu_2s_pause) {
+            updateDialString(PAUSE);
+            return true;
+        } else if (resId == R.id.menu_add_wait) {
+            updateDialString(WAIT);
+            return true;
+        /** M: [IP Dial] click IP dial on popup menu @{ */
+        } else if (resId == R.id.menu_ip_dial) {
+            return onIpDialMenuItemSelected();
+        /** @} */
+        /** M: [VoLTE ConfCall] handle conference call menu. @{ */
+        } else if (resId == R.id.menu_volte_conf_call) {
+            Activity activity = getActivity();
+            if (activity != null) {
+                DialerVolteUtils.handleMenuVolteConfCall(activity);
+            }
+            return true;
+        /** @} */
+        } else if (resId == R.id.menu_call_with_note) {
+            CallSubjectDialog.start(getActivity(), mDigits.getText().toString());
+            hideAndClearDialpad(false);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Updates the dial string (mDigits) after inserting a Pause character (,)
+     * or Wait character (;).
+     */
+    private void updateDialString(char newDigit) {
+        if (newDigit != WAIT && newDigit != PAUSE) {
+            throw new IllegalArgumentException(
+                    "Not expected for anything other than PAUSE & WAIT");
+        }
+
+        int selectionStart;
+        int selectionEnd;
+
+        // SpannableStringBuilder editable_text = new SpannableStringBuilder(mDigits.getText());
+        int anchor = mDigits.getSelectionStart();
+        int point = mDigits.getSelectionEnd();
+
+        selectionStart = Math.min(anchor, point);
+        selectionEnd = Math.max(anchor, point);
+
+        if (selectionStart == -1) {
+            selectionStart = selectionEnd = mDigits.length();
+        }
+
+        Editable digits = mDigits.getText();
+
+        if (canAddDigit(digits, selectionStart, selectionEnd, newDigit)) {
+            digits.replace(selectionStart, selectionEnd, Character.toString(newDigit));
+
+            if (selectionStart != selectionEnd) {
+              // Unselect: back to a regular cursor, just pass the character inserted.
+              mDigits.setSelection(selectionStart + 1);
+            }
+        }
+    }
+
+    /**
+     * Update the enabledness of the "Dial" and "Backspace" buttons if applicable.
+     */
+    private void updateDeleteButtonEnabledState() {
+        if (getActivity() == null) {
+            return;
+        }
+        final boolean digitsNotEmpty = !isDigitsEmpty();
+        mDelete.setEnabled(digitsNotEmpty);
+    }
+
+    /**
+     * Handle transitions for the menu button depending on the state of the digits edit text.
+     * Transition out when going from digits to no digits and transition in when the first digit
+     * is pressed.
+     * @param transitionIn True if transitioning in, False if transitioning out
+     */
+    private void updateMenuOverflowButton(boolean transitionIn) {
+        /** M: [VoLTE ConfCall] Always show overflow menu button for conf call. @{ */
+        if (mVolteConfCallEnabled) {
+            return;
+        }
+        /** @} */
+        mOverflowMenuButton = mDialpadView.getOverflowMenuButton();
+        if (transitionIn) {
+            AnimUtils.fadeIn(mOverflowMenuButton, AnimUtils.DEFAULT_DURATION);
+        } else {
+            AnimUtils.fadeOut(mOverflowMenuButton, AnimUtils.DEFAULT_DURATION);
+        }
+    }
+
+    /**
+     * Check if voicemail is enabled/accessible.
+     *
+     * @return true if voicemail is enabled and accessible. Note that this can be false
+     * "temporarily" after the app boot.
+     */
+    private boolean isVoicemailAvailable() {
+        try {
+            PhoneAccountHandle defaultUserSelectedAccount =
+                    TelecomUtil.getDefaultOutgoingPhoneAccount(getActivity(),
+                            PhoneAccount.SCHEME_VOICEMAIL);
+            if (defaultUserSelectedAccount == null) {
+                // In a single-SIM phone, there is no default outgoing phone account selected by
+                // the user, so just call TelephonyManager#getVoicemailNumber directly.
+                return !TextUtils.isEmpty(getTelephonyManager().getVoiceMailNumber());
+            } else {
+                return !TextUtils.isEmpty(TelecomUtil.getVoicemailNumber(getActivity(),
+                        defaultUserSelectedAccount));
+            }
+        } catch (SecurityException se) {
+            // Possibly no READ_PHONE_STATE privilege.
+            Log.w(TAG, "SecurityException is thrown. Maybe privilege isn't sufficient.");
+        }
+        return false;
+    }
+
+    /**
+     * Returns true of the newDigit parameter can be added at the current selection
+     * point, otherwise returns false.
+     * Only prevents input of WAIT and PAUSE digits at an unsupported position.
+     * Fails early if start == -1 or start is larger than end.
+     */
+    @VisibleForTesting
+    /* package */ static boolean canAddDigit(CharSequence digits, int start, int end,
+                                             char newDigit) {
+        if(newDigit != WAIT && newDigit != PAUSE) {
+            throw new IllegalArgumentException(
+                    "Should not be called for anything other than PAUSE & WAIT");
+        }
+
+        // False if no selection, or selection is reversed (end < start)
+        if (start == -1 || end < start) {
+            return false;
+        }
+
+        // unsupported selection-out-of-bounds state
+        if (start > digits.length() || end > digits.length()) return false;
+
+        // Special digit cannot be the first digit
+        if (start == 0) return false;
+
+        if (newDigit == WAIT) {
+            // preceding char is ';' (WAIT)
+            if (digits.charAt(start - 1) == WAIT) return false;
+
+            // next char is ';' (WAIT)
+            if ((digits.length() > end) && (digits.charAt(end) == WAIT)) return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * @return true if the widget with the phone number digits is empty.
+     */
+    private boolean isDigitsEmpty() {
+        return mDigits.length() == 0;
+    }
+
+    /**
+     * Starts the asyn query to get the last dialed/outgoing
+     * number. When the background query finishes, mLastNumberDialed
+     * is set to the last dialed number or an empty string if none
+     * exists yet.
+     */
+    private void queryLastOutgoingCall() {
+        mLastNumberDialed = EMPTY_NUMBER;
+        if (!PermissionsUtil.hasPhonePermissions(getActivity())) {
+            return;
+        }
+        CallLogAsync.GetLastOutgoingCallArgs lastCallArgs =
+                new CallLogAsync.GetLastOutgoingCallArgs(
+                    getActivity(),
+                    new CallLogAsync.OnLastOutgoingCallComplete() {
+                        @Override
+                        public void lastOutgoingCall(String number) {
+                            // TODO: Filter out emergency numbers if
+                            // the carrier does not want redial for
+                            // these.
+                            // If the fragment has already been detached since the last time
+                            // we called queryLastOutgoingCall in onResume there is no point
+                            // doing anything here.
+                            if (getActivity() == null) return;
+                            mLastNumberDialed = number;
+                            updateDeleteButtonEnabledState();
+                        }
+                    });
+        mCallLog.getLastOutgoingCall(lastCallArgs);
+    }
+
+    private Intent newFlashIntent() {
+        final Intent intent = new CallIntentBuilder(EMPTY_NUMBER).build();
+        intent.putExtra(EXTRA_SEND_EMPTY_FLASH, true);
+        return intent;
+    }
+
+    @Override
+    public void onHiddenChanged(boolean hidden) {
+        super.onHiddenChanged(hidden);
+        final DialtactsActivity activity = (DialtactsActivity) getActivity();
+        final DialpadView dialpadView = (DialpadView) getView().findViewById(R.id.dialpad_view);
+        if (activity == null) return;
+        if (!hidden && !isDialpadChooserVisible()) {
+            if (mAnimate) {
+                dialpadView.animateShow();
+            }
+
+            /// M: [VoLTE ConfCall] initialize value about conference call capability. @{
+            mVolteConfCallEnabled = supportOneKeyConference(getActivity());
+            Log.d(TAG, "onHiddenChanged false mVolteConfCallEnabled = " + mVolteConfCallEnabled);
+            // Always show overflow menu button for conf call, otherwise hide it.
+            if (mOverflowMenuButton != null) {
+                if (mVolteConfCallEnabled) {
+                    mOverflowMenuButton.setVisibility(View.VISIBLE);
+                    mOverflowMenuButton.setAlpha(1);
+                } else if (isDigitsEmpty()) {
+                    mOverflowMenuButton.setVisibility(View.INVISIBLE);
+                }
+            }
+            /// @}
+
+            /// M: Need to check if floatingActionButton is null. because in CT
+            // project, OP09 plugin will modify Dialpad layout and floatingActionButton
+            // will be null in that case. @{
+            if (null != mFloatingActionButtonController) {
+                mFloatingActionButtonController.setVisible(false);
+                mFloatingActionButtonController.scaleIn(mAnimate ? mDialpadSlideInDuration : 0);
+            }
+            /// @}
+
+            /// M: for Plug-in @{
+            ExtensionManager.getInstance().
+                    getDialPadExtension().onHiddenChanged(
+                            true, mAnimate ? mDialpadSlideInDuration : 0);
+            /// @}
+            activity.onDialpadShown();
+            mDigits.requestFocus();
+        }
+
+        /// M: Need to check if floatingActionButton is null. because in CT
+        // project, OP09 plugin will modify Dialpad layout and floatingActionButton
+        // will be null in that case. @{
+        if (hidden && null != mFloatingActionButtonController) {
+            if (mAnimate) {
+                mFloatingActionButtonController.scaleOut();
+            } else {
+                mFloatingActionButtonController.setVisible(false);
+            }
+        }
+        /// @}
+
+        /// M: for Plug-in @{
+        if (hidden && mAnimate) {
+            ExtensionManager.getInstance().
+                    getDialPadExtension().onHiddenChanged(false, 0);
+        }
+        /// @}
+    }
+
+    public void setAnimate(boolean value) {
+        mAnimate = value;
+    }
+
+    public boolean getAnimate() {
+        return mAnimate;
+    }
+
+    public void setYFraction(float yFraction) {
+        ((DialpadSlidingRelativeLayout) getView()).setYFraction(yFraction);
+    }
+
+    public int getDialpadHeight() {
+        if (mDialpadView == null) {
+            return 0;
+        }
+        /// M: fix for ALPS03445439 @{
+        if (mIsDialpadChooserShown && mDialpadChooser != null) {
+            return mDialpadChooser.getHeight();
+        }
+        ///@}
+        return mDialpadView.getHeight();
+    }
+
+    public void process_quote_emergency_unquote(String query) {
+        if (PseudoEmergencyAnimator.PSEUDO_EMERGENCY_NUMBER.equals(query)) {
+            if (mPseudoEmergencyAnimator == null) {
+                mPseudoEmergencyAnimator = new PseudoEmergencyAnimator(
+                        new PseudoEmergencyAnimator.ViewProvider() {
+                            @Override
+                            public View getView() {
+                                return DialpadFragment.this.getView();
+                            }
+                        });
+            }
+            mPseudoEmergencyAnimator.start();
+        } else {
+            if (mPseudoEmergencyAnimator != null) {
+                mPseudoEmergencyAnimator.end();
+            }
+        }
+    }
+
+    /** M: [IP Dial] add IP dial @{ */
+    protected boolean onIpDialMenuItemSelected() {
+        handleDialButtonPressed(Constants.DIAL_NUMBER_INTENT_IP);
+        return true;
+    }
+    /** @} */
+
+    /**
+     * M: add for plug-in.
+     */
+    @Override
+    public void doCallOptionHandle(Intent intent) {
+        DialerUtils.startActivityWithErrorToast(getActivity(), intent);
+        hideAndClearDialpad(false);
+    }
+
+   /**
+    * Shows WFC related notification on status bar when open DialpadFragment
+    *
+    */
+    public void showWfcNotification() {
+        Log.i(TAG, "[WFC]showWfcNotification ");
+        String wfcText = null;
+        String wfcTextSummary = null;
+        int wfcIcon = 0;
+        final int TIMER_COUNT = 2;
+        PhoneAccountHandle defaultAccountHandle =
+            TelecomUtil.getDefaultOutgoingPhoneAccount(getActivity(), SCHEME_TEL);
+        boolean isWfcEnabled = ( (TelephonyManager)mContext
+                .getSystemService(Context.TELEPHONY_SERVICE)).isWifiCallingAvailable();
+        if (isWfcEnabled) {
+            wfcText = mContext.getResources().getString(R.string.calls_over_wifi);
+            wfcIcon = com.mediatek.internal.R.drawable.wfc_notify_registration_success;
+            wfcTextSummary = mContext.getResources()
+                    .getString(R.string.wfc_notification_summary);
+        } else if (isSimPresent(mContext) && !isRatPresent(mContext)) {
+            Log.i(TAG, "[WFC]!isRatPresent(mContext) ");
+            wfcText = mContext.getResources().getString(R.string.connect_to_wifi);
+            wfcIcon = com.mediatek.internal.R.drawable.wfc_notify_registration_error;
+            wfcTextSummary = mContext.getResources()
+                    .getString(R.string.wfc_notification_summary_fail);
+        }
+        if (wfcText != null) {
+            Log.i(TAG, "[WFC]wfc_text " + wfcText);
+            mNotificationTimer = new Timer();
+            mNotificationManager =
+                    (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+            mNotificationTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    mNotificationCount ++;
+                    Log.i(TAG, "[WFC]count:" + mNotificationCount);
+                    if (mNotificationCount == TIMER_COUNT) {
+                        Log.i(TAG, "[WFC]Canceling notification on time expire mNotiCount"
+                                + mNotificationCount);
+                        stopWfcNotification();
+                    }
+                 }
+             }, 100, 100);
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(wfcText)
+                    .setContentText(mContext.getResources()
+                            .getString(R.string.wfc_notification_summary))
+                    .setSmallIcon(wfcIcon)
+                    .setTicker(wfcText)
+                    .setOngoing(true)
+                    .build();
+            Log.i(TAG, "[WFC]Showing WFC notification");
+            mNotificationManager.notify(DIALPAD_WFC_NOTIFICATION_ID, noti);
+        } else {
+            return;
+        }
+    }
+
+
+   /**
+    * Removes the notification from status bar shown for WFC
+    *
+    */
+    public void stopWfcNotification() {
+        Log.i(TAG, "[WFC]canceling notification on stopNotification");
+        if (mNotificationTimer != null) {
+            mNotificationTimer.cancel();
+        };
+        mNotificationCount = 0;
+        if (mNotificationManager != null) {
+            mNotificationManager.cancel(DIALPAD_WFC_NOTIFICATION_ID);
+        }
+    }
+
+   /**
+    * Checks whether SIM is present or not
+    *
+    * @param context
+    */
+    private boolean isSimPresent(Context context) {
+        boolean ret = false;
+        int[] subs =
+                SubscriptionManager.from(context).getActiveSubscriptionIdList();
+        if (subs.length == 0) {
+            ret =  false;
+        } else {
+             ret = true;
+        }
+        Log.i(TAG, "[WFC]isSimPresent ret " + ret);
+        return ret;
+    }
+
+   /**
+    * Checks whether any of RAT present: 2G/3G/LTE/Wi-Fi
+    *
+    *@param context
+    */
+    private boolean isRatPresent(Context context) {
+        Log.i(TAG, "[WFC]isRatPresent");
+        int cellularState = ServiceState.STATE_IN_SERVICE;
+        ITelephonyEx telephonyEx = ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+        Bundle bundle = null;
+        try {
+            bundle = telephonyEx
+                    .getServiceState(SubscriptionManager.getDefaultVoiceSubscriptionId());
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        if (bundle != null) {
+            cellularState = ServiceState.newFromBundle(bundle).getState();
+        }
+        Log.i(TAG, "[wfc]cellularState:" + cellularState);
+        WifiManager wifiManager =
+                (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        ConnectivityManager cm =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo wifi =
+                cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (wifi == null && cellularState != ServiceState.STATE_IN_SERVICE) {
+             Log.i(TAG, "[wfc]wifi=null,and cellularState != ServiceState.STATE_IN_SERVICE");
+             return false;
+        } else if (wifi == null && cellularState == ServiceState.STATE_IN_SERVICE) {
+            Log.i(TAG, "[wfc]wifi=null,but cellularState != ServiceState.STATE_IN_SERVICE");
+            return true;
+        }
+        Log.i(TAG, "[wfc]wifi state:" + wifiManager.getWifiState());
+        Log.i(TAG, "[wfc]wifi connected:" + wifi.isConnected());
+        if ((wifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED
+                || (wifiManager.getWifiState() == WifiManager.WIFI_STATE_ENABLED
+                && !wifi.isConnected())) && cellularState != ServiceState.STATE_IN_SERVICE) {
+            Log.i(TAG, "[wfc]No RAT present");
+            return false;
+        } else {
+            Log.i(TAG, "[wfc]RAT present");
+            return true;
+        }
+    }
+    ///@}
+
+    /** M: [ALPS01858019] add listener observer CallLog changes. @{ */
+    private ContentObserver mCallLogObserver = new ContentObserver(new Handler()) {
+        public void onChange(boolean selfChange) {
+            if (DialpadFragment.this.isAdded()) {
+                Log.d(TAG, "Observered the CallLog changes. queryLastOutgoingCall");
+                queryLastOutgoingCall();
+            }
+        };
+    };
+    /** @} */
+
+    /** M: add for check CDMA phone is in call or not. @{ */
+    private boolean isCdmaInCall() {
+        for (int subId : SubscriptionManager.from(mContext).getActiveSubscriptionIdList()) {
+            if ((TelephonyManager.from(mContext).getCallState(subId)
+                    != TelephonyManager.CALL_STATE_IDLE)
+                    && (TelephonyManager.from(mContext).getCurrentPhoneType(subId)
+                    == TelephonyManager.PHONE_TYPE_CDMA)) {
+                Log.d(TAG, "Cdma In Call");
+                return true;
+            }
+        }
+        return false;
+    }
+    /** @} */
+
+    /**
+     * M: Checking whether the volte conference is supported or not.
+     * @param context
+     * @return ture if volte conference is supported
+     */
+    private boolean supportOneKeyConference(Context context) {
+        // We have to requery contacts numbers from provider now.
+        // Which requires contacts permissions.
+        final boolean hasContactsPermission =
+                PermissionsUtil.hasContactsPermissions(context);
+        return DialerVolteUtils.isVolteConfCallEnable(context) && hasContactsPermission;
+    }
+}
Index: vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java
===================================================================
--- vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java	(revision 0)
+++ vendor/branch/5058A_BRIGHTSTAR_Ecuador/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java	(revision 5506)
@@ -0,0 +1,886 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.calllog;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.net.Uri;
+import android.provider.CallLog;
+import android.provider.CallLog.Calls;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.telecom.PhoneAccountHandle;
+import android.text.BidiFormatter;
+import android.text.TextDirectionHeuristics;
+import android.text.TextUtils;
+import android.view.ContextMenu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewStub;
+import android.view.ViewTreeObserver;
+import android.widget.LinearLayout;
+import android.widget.QuickContactBadge;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.contacts.common.CallUtil;
+import com.android.contacts.common.ClipboardUtils;
+import com.android.contacts.common.ContactPhotoManager;
+import com.android.contacts.common.ContactPhotoManager.DefaultImageRequest;
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.common.compat.PhoneNumberUtilsCompat;
+import com.android.contacts.common.dialog.CallSubjectDialog;
+import com.android.contacts.common.testing.NeededForTesting;
+import com.android.contacts.common.util.PhoneNumberHelper;
+import com.android.contacts.common.util.UriUtils;
+import com.android.dialer.DialtactsActivity;
+import com.android.dialer.R;
+import com.android.dialer.calllog.calllogcache.CallLogCache;
+import com.android.dialer.compat.FilteredNumberCompat;
+import com.android.dialer.database.FilteredNumberAsyncQueryHandler;
+import com.android.dialer.filterednumber.BlockNumberDialogFragment;
+import com.android.dialer.filterednumber.FilteredNumbersUtil;
+import com.android.dialer.logging.Logger;
+import com.android.dialer.logging.ScreenEvent;
+import com.android.dialer.service.ExtendedBlockingButtonRenderer;
+import com.android.dialer.util.DialerUtils;
+import com.android.dialer.util.PhoneNumberUtil;
+import com.android.dialer.voicemail.VoicemailPlaybackLayout;
+import com.android.dialer.voicemail.VoicemailPlaybackPresenter;
+import com.android.dialerbind.ObjectFactory;
+
+import com.mediatek.dialer.ext.ExtensionManager;
+import com.mediatek.dialer.util.DialerFeatureOptions;
+import com.mediatek.dialer.util.DialerVolteUtils;
+
+import com.google.common.collect.Lists;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This is an object containing references to views contained by the call log list item. This
+ * improves performance by reducing the frequency with which we need to find views by IDs.
+ *
+ * This object also contains UI logic pertaining to the view, to isolate it from the CallLogAdapter.
+ */
+public final class CallLogListItemViewHolder extends RecyclerView.ViewHolder
+        implements View.OnClickListener, MenuItem.OnMenuItemClickListener,
+        View.OnCreateContextMenuListener {
+
+    /** The root view of the call log list item */
+    public final View rootView;
+    /** The quick contact badge for the contact. */
+    public final QuickContactBadge quickContactView;
+    /** The primary action view of the entry. */
+    public final View primaryActionView;
+    /** The details of the phone call. */
+    public final PhoneCallDetailsViews phoneCallDetailsViews;
+    /** The text of the header for a day grouping. */
+    public final TextView dayGroupHeader;
+    /** The view containing the details for the call log row, including the action buttons. */
+    public final CardView callLogEntryView;
+    /** The actionable view which places a call to the number corresponding to the call log row. */
+    public final ImageView primaryActionButtonView;
+
+    /** The view containing call log item actions.  Null until the ViewStub is inflated. */
+    public View actionsView;
+    /** The button views below are assigned only when the action section is expanded. */
+    public VoicemailPlaybackLayout voicemailPlaybackView;
+    public View callButtonView;
+    public View videoCallButtonView;
+    public View createNewContactButtonView;
+    public View addToExistingContactButtonView;
+    public View sendMessageView;
+    public View detailsButtonView;
+    /// M: [IP Dial] For IP Prefix feature
+    public View ipDialButtonView;
+    /** M: [VoLTE ConfCallLog] the conference call numbers if it was conference call @{ */
+    public ArrayList<String> confCallNumbers;
+    /** @} */
+    public View callWithNoteButtonView;
+    public ImageView workIconView;
+	public TextView emergencyNumberView;
+
+    /**
+     * The row Id for the first call associated with the call log entry.  Used as a key for the
+     * map used to track which call log entries have the action button section expanded.
+     */
+    public long rowId;
+
+    /**
+     * The call Ids for the calls represented by the current call log entry.  Used when the user
+     * deletes a call log entry.
+     */
+    public long[] callIds;
+
+    /**
+     * The callable phone number for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public String number;
+
+    /**
+     * The post-dial numbers that are dialed following the phone number.
+     */
+    public String postDialDigits;
+
+    /**
+     * The formatted phone number to display.
+     */
+    public String displayNumber;
+
+    /**
+     * The phone number presentation for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public int numberPresentation;
+
+    /**
+     * The type of the phone number (e.g. main, work, etc).
+     */
+    public String numberType;
+
+    /**
+     * The country iso for the call. Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public String countryIso;
+
+    /**
+     * The type of call for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public int callType;
+
+    /**
+     * ID for blocked numbers database.
+     * Set when context menu is created, if the number is blocked.
+     */
+    public Integer blockId;
+
+    /**
+     * The account for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public PhoneAccountHandle accountHandle;
+
+    /**
+     * If the call has an associated voicemail message, the URI of the voicemail message for
+     * playback.  Cached here as the voicemail intent is only set when the actions ViewStub is
+     * inflated.
+     */
+    public String voicemailUri;
+
+    /**
+     * The name or number associated with the call.  Cached here for use when setting content
+     * descriptions on buttons in the actions ViewStub when it is inflated.
+     */
+    public CharSequence nameOrNumber;
+
+    /**
+     * The call type or Location associated with the call. Cached here for use when setting text
+     * for a voicemail log's call button
+     */
+    public CharSequence callTypeOrLocation;
+
+    /**
+     * Whether this row is for a business or not.
+     */
+    public boolean isBusiness;
+
+    /**
+     * The contact info for the contact displayed in this list item.
+     */
+    public ContactInfo info;
+
+    /**
+     * Whether the current log entry is a blocked number or not. Used in updatePhoto()
+     */
+    public boolean isBlocked;
+
+    /**
+     * Whether this is the archive tab or not.
+     */
+    public final boolean isArchiveTab;
+
+    private final Context mContext;
+    private final CallLogCache mCallLogCache;
+    private final CallLogListItemHelper mCallLogListItemHelper;
+    private final VoicemailPlaybackPresenter mVoicemailPlaybackPresenter;
+    private final FilteredNumberAsyncQueryHandler mFilteredNumberAsyncQueryHandler;
+
+    private final BlockNumberDialogFragment.Callback mFilteredNumberDialogCallback;
+
+    private final int mPhotoSize;
+    private ViewStub mExtendedBlockingViewStub;
+    private final ExtendedBlockingButtonRenderer mExtendedBlockingButtonRenderer;
+
+    private View.OnClickListener mExpandCollapseListener;
+    private boolean mVoicemailPrimaryActionButtonClicked;
+
+    private CallLogListItemViewHolder(
+            Context context,
+            ExtendedBlockingButtonRenderer.Listener eventListener,
+            View.OnClickListener expandCollapseListener,
+            CallLogCache callLogCache,
+            CallLogListItemHelper callLogListItemHelper,
+            VoicemailPlaybackPresenter voicemailPlaybackPresenter,
+            FilteredNumberAsyncQueryHandler filteredNumberAsyncQueryHandler,
+            BlockNumberDialogFragment.Callback filteredNumberDialogCallback,
+            View rootView,
+            QuickContactBadge quickContactView,
+            View primaryActionView,
+            PhoneCallDetailsViews phoneCallDetailsViews,
+            CardView callLogEntryView,
+            TextView dayGroupHeader,
+            ImageView primaryActionButtonView,
+            TextView emergencyNumberView,
+            boolean isArchiveTab) {
+        super(rootView);
+
+        mContext = context;
+        mExpandCollapseListener = expandCollapseListener;
+        mCallLogCache = callLogCache;
+        mCallLogListItemHelper = callLogListItemHelper;
+        mVoicemailPlaybackPresenter = voicemailPlaybackPresenter;
+        mFilteredNumberAsyncQueryHandler = filteredNumberAsyncQueryHandler;
+        mFilteredNumberDialogCallback = filteredNumberDialogCallback;
+
+        this.rootView = rootView;
+        this.quickContactView = quickContactView;
+        this.primaryActionView = primaryActionView;
+        this.phoneCallDetailsViews = phoneCallDetailsViews;
+        this.callLogEntryView = callLogEntryView;
+        this.dayGroupHeader = dayGroupHeader;
+        this.primaryActionButtonView = primaryActionButtonView;
+        this.workIconView = (ImageView) rootView.findViewById(R.id.work_profile_icon);
+		this.emergencyNumberView=(TextView)rootView.findViewById(R.id.emergency_call);
+        this.isArchiveTab = isArchiveTab;
+        Resources resources = mContext.getResources();
+        mPhotoSize = mContext.getResources().getDimensionPixelSize(R.dimen.contact_photo_size);
+
+        // Set text height to false on the TextViews so they don't have extra padding.
+        phoneCallDetailsViews.nameView.setElegantTextHeight(false);
+        phoneCallDetailsViews.callLocationAndDate.setElegantTextHeight(false);
+
+        quickContactView.setOverlay(null);
+        if (CompatUtils.hasPrioritizedMimeType()) {
+            quickContactView.setPrioritizedMimeType(Phone.CONTENT_ITEM_TYPE);
+        }
+        primaryActionButtonView.setOnClickListener(this);
+        primaryActionView.setOnClickListener(mExpandCollapseListener);
+        primaryActionView.setOnCreateContextMenuListener(this);
+        mExtendedBlockingButtonRenderer =
+                ObjectFactory.newExtendedBlockingButtonRenderer(mContext, eventListener);
+    }
+
+    public static CallLogListItemViewHolder create(
+            View view,
+            Context context,
+            ExtendedBlockingButtonRenderer.Listener eventListener,
+            View.OnClickListener expandCollapseListener,
+            CallLogCache callLogCache,
+            CallLogListItemHelper callLogListItemHelper,
+            VoicemailPlaybackPresenter voicemailPlaybackPresenter,
+            FilteredNumberAsyncQueryHandler filteredNumberAsyncQueryHandler,
+            BlockNumberDialogFragment.Callback filteredNumberDialogCallback,
+            boolean isArchiveTab) {
+
+        return new CallLogListItemViewHolder(
+                context,
+                eventListener,
+                expandCollapseListener,
+                callLogCache,
+                callLogListItemHelper,
+                voicemailPlaybackPresenter,
+                filteredNumberAsyncQueryHandler,
+                filteredNumberDialogCallback,
+                view,
+                (QuickContactBadge) view.findViewById(R.id.quick_contact_photo),
+                view.findViewById(R.id.primary_action_view),
+                PhoneCallDetailsViews.fromView(view),
+                (CardView) view.findViewById(R.id.call_log_row),
+                (TextView) view.findViewById(R.id.call_log_day_group_label),
+                (ImageView) view.findViewById(R.id.primary_action_button),
+                (TextView)view.findViewById(R.id.emergency_call),
+                isArchiveTab);
+    }
+
+    @Override
+    public void onCreateContextMenu(
+            final ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+        if (TextUtils.isEmpty(number)) {
+            return;
+        }
+
+        if (callType == CallLog.Calls.VOICEMAIL_TYPE) {
+            menu.setHeaderTitle(mContext.getResources().getText(R.string.voicemail));
+        } else {
+            menu.setHeaderTitle(PhoneNumberUtilsCompat.createTtsSpannable(
+                    BidiFormatter.getInstance().unicodeWrap(number, TextDirectionHeuristics.LTR)));
+        }
+
+        menu.add(ContextMenu.NONE, R.id.context_menu_copy_to_clipboard, ContextMenu.NONE,
+                R.string.action_copy_number_text)
+                .setOnMenuItemClickListener(this);
+
+        // The edit number before call does not show up if any of the conditions apply:
+        // 1) Number cannot be called
+        // 2) Number is the voicemail number
+        // 3) Number is a SIP address
+
+        if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation)
+                && !mCallLogCache.isVoicemailNumber(accountHandle, number)
+                && !PhoneNumberUtil.isSipNumber(number)) {
+            menu.add(ContextMenu.NONE, R.id.context_menu_edit_before_call, ContextMenu.NONE,
+                    R.string.action_edit_number_before_call)
+                    .setOnMenuItemClickListener(this);
+        }
+
+        if (callType == CallLog.Calls.VOICEMAIL_TYPE
+                && phoneCallDetailsViews.voicemailTranscriptionView.length() > 0) {
+            menu.add(ContextMenu.NONE, R.id.context_menu_copy_transcript_to_clipboard,
+                    ContextMenu.NONE, R.string.copy_transcript_text)
+                    .setOnMenuItemClickListener(this);
+        }
+
+        if (FilteredNumberCompat.canAttemptBlockOperations(mContext)
+                && FilteredNumbersUtil.canBlockNumber(mContext, number, countryIso)) {
+            mFilteredNumberAsyncQueryHandler.isBlockedNumber(
+                    new FilteredNumberAsyncQueryHandler.OnCheckBlockedListener() {
+                        @Override
+                        public void onCheckComplete(Integer id) {
+                            blockId = id;
+                            int blockTitleId = blockId == null ? R.string.action_block_number
+                                    : R.string.action_unblock_number;
+                            final MenuItem blockItem = menu.add(
+                                    ContextMenu.NONE,
+                                    R.id.context_menu_block_number,
+                                    ContextMenu.NONE,
+                                    blockTitleId);
+                            blockItem.setOnMenuItemClickListener(
+                                    CallLogListItemViewHolder.this);
+                        }
+                    }, number, countryIso);
+        }
+
+        Logger.logScreenView(ScreenEvent.CALL_LOG_CONTEXT_MENU, (Activity) mContext);
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        int resId = item.getItemId();
+        if (resId == R.id.context_menu_block_number) {
+            /**
+             * M:find parent view for block number dialog.
+             * Use parent view to avoid current listitem view be recycled during scroling.@{
+             * */
+            View v = ((Activity) mContext).findViewById(R.id.floating_action_button_container);
+            int parentViewId = (v == null) ? ((View)rootView.getParent()).getId()
+                    : R.id.floating_action_button_container;
+            /**@}*/
+            /// M: Do not show dialog if activity is finish. @{
+            if (((Activity) mContext).isFinishing() || ((Activity) mContext).isDestroyed()) {
+                return true;
+            }
+            /// @}
+            FilteredNumberCompat
+                    .showBlockNumberDialogFlow(mContext.getContentResolver(), blockId, number,
+                            countryIso, displayNumber,
+                            parentViewId/**M:R.id.floating_action_button_container*/,
+                            ((Activity) mContext).getFragmentManager(),
+                            mFilteredNumberDialogCallback);
+            return true;
+        } else if (resId == R.id.context_menu_copy_to_clipboard) {
+            ClipboardUtils.copyText(mContext, null, number, true);
+            return true;
+        } else if (resId == R.id.context_menu_copy_transcript_to_clipboard) {
+            ClipboardUtils.copyText(mContext, null,
+                    phoneCallDetailsViews.voicemailTranscriptionView.getText(), true);
+            return true;
+        } else if (resId == R.id.context_menu_edit_before_call) {
+            final Intent intent = new Intent(
+                    Intent.ACTION_DIAL, CallUtil.getCallUri(number));
+            intent.setClass(mContext, DialtactsActivity.class);
+            DialerUtils.startActivityWithErrorToast(mContext, intent);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Configures the action buttons in the expandable actions ViewStub. The ViewStub is not
+     * inflated during initial binding, so click handlers, tags and accessibility text must be set
+     * here, if necessary.
+     */
+    public void inflateActionViewStub() {
+        ViewStub stub = (ViewStub) rootView.findViewById(R.id.call_log_entry_actions_stub);
+        if (stub != null) {
+            actionsView = stub.inflate();
+
+            voicemailPlaybackView = (VoicemailPlaybackLayout) actionsView
+                    .findViewById(R.id.voicemail_playback_layout);
+            if (isArchiveTab) {
+                voicemailPlaybackView.hideArchiveButton();
+            }
+
+
+            callButtonView = actionsView.findViewById(R.id.call_action);
+            callButtonView.setOnClickListener(this);
+
+            videoCallButtonView = actionsView.findViewById(R.id.video_call_action);
+            videoCallButtonView.setOnClickListener(this);
+
+            createNewContactButtonView = actionsView.findViewById(R.id.create_new_contact_action);
+            createNewContactButtonView.setOnClickListener(this);
+
+            addToExistingContactButtonView =
+                    actionsView.findViewById(R.id.add_to_existing_contact_action);
+            addToExistingContactButtonView.setOnClickListener(this);
+
+            sendMessageView = actionsView.findViewById(R.id.send_message_action);
+            sendMessageView.setOnClickListener(this);
+
+            detailsButtonView = actionsView.findViewById(R.id.details_action);
+            detailsButtonView.setOnClickListener(this);
+
+            /** M: [IP Dial] add IP Dial @{ */
+            ipDialButtonView = actionsView.findViewById(R.id.ipdial_action);
+            ipDialButtonView.setOnClickListener(this);
+            /** @} */
+
+            callWithNoteButtonView = actionsView.findViewById(R.id.call_with_note_action);
+            callWithNoteButtonView.setOnClickListener(this);
+
+            mExtendedBlockingViewStub =
+                    (ViewStub) actionsView.findViewById(R.id.extended_blocking_actions_container);
+        }
+
+        bindActionButtons();
+    }
+
+    private void updatePrimaryActionButton(boolean isExpanded) {
+        if (!TextUtils.isEmpty(voicemailUri)) {
+            // Treat as voicemail list item; show play button if not expanded.
+            if (!isExpanded) {
+                primaryActionButtonView.setImageResource(R.drawable.ic_play_arrow_24dp);
+                primaryActionButtonView.setContentDescription(TextUtils.expandTemplate(
+                        mContext.getString(R.string.description_voicemail_action),
+                        nameOrNumber));
+                primaryActionButtonView.setVisibility(View.VISIBLE);
+            } else {
+                primaryActionButtonView.setVisibility(View.GONE);
+            }
+        } else {
+            // Treat as normal list item; show call button, if possible.
+            if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation)) {
+                boolean isVoicemailNumber =
+                        mCallLogCache.isVoicemailNumber(accountHandle, number);
+                /// M: [Suggested Account] Supporting suggested account @{
+                /// Give all the calls a suggestion first.
+                if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                    primaryActionButtonView.setTag(IntentProvider
+                            .getSuggestedReturnCallIntentProvider(number + postDialDigits,
+                                    accountHandle));
+                /// @}
+                } else if (isVoicemailNumber) {
+                    // Call to generic voicemail number, in case there are multiple accounts.
+                    primaryActionButtonView.setTag(
+                            IntentProvider.getReturnVoicemailCallIntentProvider());
+                } else {
+                    primaryActionButtonView.setTag(IntentProvider
+                            .getReturnCallIntentProvider(number + postDialDigits));
+                }
+                /** M: [IMS Call] For Volte IMS call @{ */
+                if (DialerFeatureOptions.isImsCallSupport()
+                        && PhoneNumberHelper.isUriNumber(number)
+                        && PhoneAccountUtils.isSubScriptionAccount(mContext, accountHandle)) {
+                    primaryActionButtonView.setTag(
+                            IntentProvider.getReturnIMSCallIntentProvider(number + postDialDigits));
+                }
+                /** @} */
+
+                primaryActionButtonView.setContentDescription(TextUtils.expandTemplate(
+                        mContext.getString(R.string.description_call_action),
+                        nameOrNumber));
+                primaryActionButtonView.setImageResource(R.drawable.ic_call_24dp);
+                primaryActionButtonView.setVisibility(View.VISIBLE);
+                /** M: [VoLTE ConfCallLog] For Volte Conference callLog @{ */
+                if (confCallNumbers != null) {
+                    if (DialerVolteUtils.isVolteConfCallEnable(mContext)) {
+                        primaryActionButtonView.setTag(IntentProvider
+                                .getReturnVolteConfCallIntentProvider(confCallNumbers));
+                    } else {
+                        primaryActionButtonView.setTag(null);
+                        primaryActionButtonView.setVisibility(View.GONE);
+                    }
+                }
+                /** @} */
+            } else {
+                primaryActionButtonView.setTag(null);
+                primaryActionButtonView.setVisibility(View.GONE);
+            }
+        }
+    }
+
+    /**
+     * Binds text titles, click handlers and intents to the voicemail, details and callback action
+     * buttons.
+     */
+    private void bindActionButtons() {
+        /** M: [VoLTE ConfCallLog] Only show call detail button for conference callLog @{ */
+        if (confCallNumbers != null) {
+            callButtonView.setVisibility(View.GONE);
+            videoCallButtonView.setVisibility(View.GONE);
+            voicemailPlaybackView.setVisibility(View.GONE);
+            createNewContactButtonView.setVisibility(View.GONE);
+            addToExistingContactButtonView.setVisibility(View.GONE);
+            sendMessageView.setVisibility(View.GONE);
+            ipDialButtonView.setVisibility(View.GONE);
+            callWithNoteButtonView.setVisibility(View.GONE);
+            detailsButtonView.setVisibility(View.VISIBLE);
+            detailsButtonView.setTag(
+                    IntentProvider.getCallDetailIntentProvider(
+                            rowId, callIds, null, true));
+            return;
+        } else {
+            // Other buttons will change its visible at below code of this
+            // method except sendMessageView. So, make it visible.
+            sendMessageView.setVisibility(View.VISIBLE);
+        }
+        /** @} */
+
+        boolean canPlaceCallToNumber =
+                PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation);
+
+        if (!TextUtils.isEmpty(voicemailUri) && canPlaceCallToNumber) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                callButtonView.setTag(IntentProvider
+                        .getSuggestedReturnCallIntentProvider(number,
+                                accountHandle));
+            } else {
+                callButtonView.setTag(IntentProvider
+                        .getReturnCallIntentProvider(number));
+            }
+            /// @}
+            ((TextView) callButtonView.findViewById(R.id.call_action_text))
+                    .setText(TextUtils.expandTemplate(
+                            mContext.getString(R.string.call_log_action_call),
+                            nameOrNumber));
+            TextView callTypeOrLocationView = ((TextView) callButtonView.findViewById(
+                    R.id.call_type_or_location_text));
+            if (callType == Calls.VOICEMAIL_TYPE && !TextUtils.isEmpty(callTypeOrLocation)) {
+                callTypeOrLocationView.setText(callTypeOrLocation);
+                callTypeOrLocationView.setVisibility(View.VISIBLE);
+            } else {
+                callTypeOrLocationView.setVisibility(View.GONE);
+            }
+            callButtonView.setVisibility(View.VISIBLE);
+        } else {
+            callButtonView.setVisibility(View.GONE);
+        }
+
+        // If one of the calls had video capabilities, show the video call button.
+        // if (mCallLogCache.isVideoEnabled() && canPlaceCallToNumber &&
+        //        phoneCallDetailsViews.callTypeIcons.isVideoShown()) {
+        /// M: using plugin API to override the video button showing logic.
+        /// NOTE: the parameters should be passed as the index defined in ICallLogExtension
+        boolean isVideoButtonEnabled =
+                ExtensionManager.getInstance().getCallLogExtension().isVideoButtonEnabled(
+                mCallLogCache.isVideoEnabled(), canPlaceCallToNumber,
+                phoneCallDetailsViews.callTypeIcons.isVideoShown(),
+                phoneCallDetailsViews.callTypeIcons,
+                number, info != null ? info.lookupUri : null);
+        if (isVideoButtonEnabled) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                videoCallButtonView.setTag(IntentProvider
+                        .getSuggestedReturnVideoCallIntentProvider(number,
+                                accountHandle));
+            } else {
+                videoCallButtonView.setTag(IntentProvider
+                        .getReturnVideoCallIntentProvider(number));
+            }
+            /// @}
+            videoCallButtonView.setVisibility(View.VISIBLE);
+        } else {
+            videoCallButtonView.setVisibility(View.GONE);
+        }
+
+        // For voicemail calls, show the voicemail playback layout; hide otherwise.
+        if (callType == Calls.VOICEMAIL_TYPE && mVoicemailPlaybackPresenter != null
+                && !TextUtils.isEmpty(voicemailUri)) {
+            voicemailPlaybackView.setVisibility(View.VISIBLE);
+
+            Uri uri = Uri.parse(voicemailUri);
+            mVoicemailPlaybackPresenter.setPlaybackView(
+                    voicemailPlaybackView, uri, mVoicemailPrimaryActionButtonClicked);
+            mVoicemailPrimaryActionButtonClicked = false;
+            // Only mark voicemail as read when not in archive tab
+            if (!isArchiveTab) {
+                CallLogAsyncTaskUtil.markVoicemailAsRead(mContext, uri);
+            }
+        } else {
+            voicemailPlaybackView.setVisibility(View.GONE);
+        }
+
+        if (callType == Calls.VOICEMAIL_TYPE) {
+            detailsButtonView.setVisibility(View.GONE);
+        } else {
+            detailsButtonView.setVisibility(View.VISIBLE);
+            detailsButtonView.setTag(
+                    IntentProvider.getCallDetailIntentProvider(rowId, callIds, null));
+        }
+
+        if (info != null && UriUtils.isEncodedContactUri(info.lookupUri)) {
+            createNewContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(
+                    info.lookupUri, info.name, info.number, info.type, true /* isNewContact */));
+            createNewContactButtonView.setVisibility(View.VISIBLE);
+
+            addToExistingContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(
+                    info.lookupUri, info.name, info.number, info.type, false /* isNewContact */));
+            addToExistingContactButtonView.setVisibility(View.VISIBLE);
+        } else {
+            createNewContactButtonView.setVisibility(View.GONE);
+            addToExistingContactButtonView.setVisibility(View.GONE);
+        }
+
+        if (canPlaceCallToNumber) {
+            sendMessageView.setTag(IntentProvider.getSendSmsIntentProvider(number));
+            sendMessageView.setVisibility(View.VISIBLE);
+        } else {
+            sendMessageView.setVisibility(View.GONE);
+        }
+
+        /** M: [IP Dial] Add IP Dial @{ */
+        if (DialerFeatureOptions.isIpPrefixSupport() && canPlaceCallToNumber
+                && !PhoneNumberHelper.isUriNumber(number)) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                ipDialButtonView.setTag(IntentProvider
+                        .getSuggestedIpDialCallIntentProvider(number, accountHandle));
+            } else {
+                ipDialButtonView.setTag(IntentProvider
+                        .getIpDialCallIntentProvider(number));
+            }
+            /// @}
+            ipDialButtonView.setVisibility(View.GONE);
+        } else {
+            ipDialButtonView.setVisibility(View.GONE);
+        }
+        /** @} */
+        mCallLogListItemHelper.setActionContentDescriptions(this);
+
+        boolean supportsCallSubject =
+                mCallLogCache.doesAccountSupportCallSubject(accountHandle);
+        boolean isVoicemailNumber =
+                mCallLogCache.isVoicemailNumber(accountHandle, number);
+        callWithNoteButtonView.setVisibility(
+                supportsCallSubject && !isVoicemailNumber ? View.VISIBLE : View.GONE);
+
+        if(mExtendedBlockingButtonRenderer != null){
+            List<View> completeLogListItems = Lists.newArrayList(
+                    createNewContactButtonView,
+                    addToExistingContactButtonView,
+                    sendMessageView,
+                    callButtonView,
+                    callWithNoteButtonView,
+                    detailsButtonView,
+                    voicemailPlaybackView);
+
+            List<View> blockedNumberVisibleViews = Lists.newArrayList(detailsButtonView);
+            List<View> extendedBlockingVisibleViews = Lists.newArrayList(detailsButtonView);
+
+            ExtendedBlockingButtonRenderer.ViewHolderInfo viewHolderInfo =
+                    new ExtendedBlockingButtonRenderer.ViewHolderInfo(
+                            completeLogListItems,
+                            extendedBlockingVisibleViews,
+                            blockedNumberVisibleViews,
+                            number,
+                            countryIso,
+                            nameOrNumber.toString(),
+                            displayNumber);
+            mExtendedBlockingButtonRenderer.setViewHolderInfo(viewHolderInfo);
+
+            mExtendedBlockingButtonRenderer.render(mExtendedBlockingViewStub);
+        }
+
+       ///M: Plug-in call to customize Action buttons
+        ExtensionManager.getInstance().getCallLogExtension().
+                                           customizeBindActionButtons(this);
+    }
+
+    /**
+     * Show or hide the action views, such as voicemail, details, and add contact.
+     *
+     * If the action views have never been shown yet for this view, inflate the view stub.
+     */
+    public void showActions(boolean show) {
+        showOrHideVoicemailTranscriptionView(show);
+
+        if (show) {
+            // Inflate the view stub if necessary, and wire up the event handlers.
+            inflateActionViewStub();
+
+            actionsView.setVisibility(View.VISIBLE);
+            actionsView.setAlpha(1.0f);
+        } else {
+            // When recycling a view, it is possible the actionsView ViewStub was previously
+            // inflated so we should hide it in this case.
+            if (actionsView != null) {
+                actionsView.setVisibility(View.GONE);
+            }
+        }
+
+        updatePrimaryActionButton(show);
+
+        /// M: add for plug-in. @{
+        ExtensionManager.getInstance().getCallLogExtension().showActions(this, show);
+        /// @}
+
+    }
+
+    public void showOrHideVoicemailTranscriptionView(boolean isExpanded) {
+        if (callType != Calls.VOICEMAIL_TYPE) {
+            return;
+        }
+
+        final TextView view = phoneCallDetailsViews.voicemailTranscriptionView;
+        if (!isExpanded || TextUtils.isEmpty(view.getText())) {
+            view.setVisibility(View.GONE);
+            return;
+        }
+        view.setVisibility(View.VISIBLE);
+    }
+
+    public void updatePhoto() {
+        quickContactView.assignContactUri(info.lookupUri);
+
+        final boolean isVoicemail = mCallLogCache.isVoicemailNumber(accountHandle, number);
+        int contactType = ContactPhotoManager.TYPE_DEFAULT;
+        if (isVoicemail) {
+            contactType = ContactPhotoManager.TYPE_VOICEMAIL;
+        } else if (isBusiness) {
+            contactType = ContactPhotoManager.TYPE_BUSINESS;
+        }
+        /// M: [VoLTE ConfCallLog] Show Volte Conference contact icon @{
+        final boolean isConference = confCallNumbers != null;
+        if (isConference) {
+            contactType = ContactPhotoManager.TYPE_CONFERENCE_CALL;
+            quickContactView.assignContactUri(null);
+        }
+        /// @}
+
+        final String lookupKey = isConference ? null : UriUtils.getLookupKeyFromUri(info.lookupUri);
+        final String displayName = TextUtils.isEmpty(info.name) ? displayNumber : info.name;
+        final DefaultImageRequest request = new DefaultImageRequest(
+                displayName, lookupKey, contactType, true /* isCircular */);
+
+        /// M: if this contact is SIM contact,call log need show SIM icon @{
+        request.subId = info.contactSimId;
+        request.photoId = info.isSdnContact;
+        /// @}
+
+        /// M: if is conference call, just show conference contact photo
+        if (info.photoId == 0 && info.photoUri != null && !isConference) {
+            ContactPhotoManager.getInstance(mContext).loadPhoto(quickContactView, info.photoUri,
+                    mPhotoSize, false /* darkTheme */, true /* isCircular */, request);
+        } else {
+            ContactPhotoManager.getInstance(mContext).loadThumbnail(quickContactView,
+                    isConference ? 0 : info.photoId,
+                    false /* darkTheme */, true /* isCircular */, request);
+        }
+
+        if (mExtendedBlockingButtonRenderer != null) {
+            mExtendedBlockingButtonRenderer.updatePhotoAndLabelIfNecessary(
+                    number,
+                    countryIso,
+                    quickContactView,
+                    phoneCallDetailsViews.callLocationAndDate);
+        }
+    }
+
+    @Override
+    public void onClick(View view) {
+        if (view.getId() == R.id.primary_action_button && !TextUtils.isEmpty(voicemailUri)) {
+            mVoicemailPrimaryActionButtonClicked = true;
+            mExpandCollapseListener.onClick(primaryActionView);
+        } else if (view.getId() == R.id.call_with_note_action) {
+            CallSubjectDialog.start(
+                    (Activity) mContext,
+                    info.photoId,
+                    info.photoUri,
+                    info.lookupUri,
+                    (String) nameOrNumber /* top line of contact view in call subject dialog */,
+                    isBusiness,
+                    number,
+                    TextUtils.isEmpty(info.name) ? null : displayNumber, /* second line of contact
+                                                                           view in dialog. */
+                    numberType, /* phone number type (e.g. mobile) in second line of contact view */
+                    accountHandle);
+        } else {
+            final IntentProvider intentProvider = (IntentProvider) view.getTag();
+            if (intentProvider != null) {
+                final Intent intent = intentProvider.getIntent(mContext);
+                // See IntentProvider.getCallDetailIntentProvider() for why this may be null.
+                if (intent != null) {
+                    DialerUtils.startActivityWithErrorToast(mContext, intent);
+                }
+            }
+        }
+    }
+
+    @NeededForTesting
+    public static CallLogListItemViewHolder createForTest(Context context) {
+        Resources resources = context.getResources();
+        CallLogCache callLogCache =
+                CallLogCache.getCallLogCache(context);
+        PhoneCallDetailsHelper phoneCallDetailsHelper = new PhoneCallDetailsHelper(
+                context, resources, callLogCache);
+
+        CallLogListItemViewHolder viewHolder = new CallLogListItemViewHolder(
+                context,
+                null,
+                null /* expandCollapseListener */,
+                callLogCache,
+                new CallLogListItemHelper(phoneCallDetailsHelper, resources, callLogCache),
+                null /* voicemailPlaybackPresenter */,
+                null /* filteredNumberAsyncQueryHandler */,
+                null /* filteredNumberDialogCallback */,
+                new View(context),
+                new QuickContactBadge(context),
+                new LinearLayout(context) /*M: primaryActionView */,
+                PhoneCallDetailsViews.createForTest(context),
+                new CardView(context),
+                new TextView(context),
+                new ImageView(context),
+                new TextView(context),
+                false);
+        viewHolder.detailsButtonView = new TextView(context);
+        viewHolder.actionsView = new View(context);
+        viewHolder.voicemailPlaybackView = new VoicemailPlaybackLayout(context);
+        viewHolder.workIconView = new ImageButton(context);
+		viewHolder.emergencyNumberView= new TextView(context);
+        return viewHolder;
+    }
+}
