Index: vendor/branch/5058A_Telcel/packages/services/Telephony/src/com/android/services/telephony/DisconnectCauseUtil.java
===================================================================
--- vendor/branch/5058A_Telcel/packages/services/Telephony/src/com/android/services/telephony/DisconnectCauseUtil.java	(revision 0)
+++ vendor/branch/5058A_Telcel/packages/services/Telephony/src/com/android/services/telephony/DisconnectCauseUtil.java	(revision 4004)
@@ -0,0 +1,525 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/**
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.services.telephony;
+
+import android.content.Context;
+import android.media.ToneGenerator;
+/// M: CC: Modem reset related handling @{
+import android.provider.Settings;
+/// @}
+import android.telecom.DisconnectCause;
+
+import com.android.phone.PhoneGlobals;
+import com.android.phone.common.R;
+import com.android.phone.ImsUtil;
+
+import com.mediatek.phone.ext.ExtensionManager;
+
+
+public class DisconnectCauseUtil {
+
+   /**
+    * Converts from a disconnect code in {@link android.telephony.DisconnectCause} into a more generic
+    * {@link android.telecom.DisconnectCause}.object, possibly populated with a localized message
+    * and tone.
+    *
+    * @param context The context.
+    * @param telephonyDisconnectCause The code for the reason for the disconnect.
+    */
+    public static DisconnectCause toTelecomDisconnectCause(int telephonyDisconnectCause) {
+        return toTelecomDisconnectCause(telephonyDisconnectCause, null /* reason */);
+    }
+
+   /**
+    * Converts from a disconnect code in {@link android.telephony.DisconnectCause} into a more generic
+    * {@link android.telecom.DisconnectCause}.object, possibly populated with a localized message
+    * and tone.
+    *
+    * @param context The context.
+    * @param telephonyDisconnectCause The code for the reason for the disconnect.
+    * @param reason Description of the reason for the disconnect, not intended for the user to see..
+    */
+    public static DisconnectCause toTelecomDisconnectCause(
+            int telephonyDisconnectCause, String reason) {
+        Context context = PhoneGlobals.getInstance();
+        /// M:OP01 change the disconnect cause from IMCOMING_REJECTED to MISSED @{
+        telephonyDisconnectCause = ExtensionManager.getIncomingCallExt().changeDisconnectCause(
+                telephonyDisconnectCause);
+        /// @}
+        return new DisconnectCause(
+                toTelecomDisconnectCauseCode(telephonyDisconnectCause),
+                toTelecomDisconnectCauseLabel(context, telephonyDisconnectCause),
+                toTelecomDisconnectCauseDescription(context, telephonyDisconnectCause),
+                toTelecomDisconnectReason(telephonyDisconnectCause, reason),
+                toTelecomDisconnectCauseTone(telephonyDisconnectCause));
+    }
+
+    /**
+     * Convert the {@link android.telephony.DisconnectCause} disconnect code into a
+     * {@link android.telecom.DisconnectCause} disconnect code.
+     * @return The disconnect code as defined in {@link android.telecom.DisconnectCause}.
+     */
+    private static int toTelecomDisconnectCauseCode(int telephonyDisconnectCause) {
+        switch (telephonyDisconnectCause) {
+            case android.telephony.DisconnectCause.LOCAL:
+                return DisconnectCause.LOCAL;
+
+            case android.telephony.DisconnectCause.NORMAL:
+                return DisconnectCause.REMOTE;
+
+            case android.telephony.DisconnectCause.OUTGOING_CANCELED:
+            /// M: CC: Error message due to CellConnMgr checking @{
+            case android.telephony.DisconnectCause.OUTGOING_CANCELED_BY_SERVICE:
+            /// @}
+                return DisconnectCause.CANCELED;
+
+            case android.telephony.DisconnectCause.INCOMING_MISSED:
+                return DisconnectCause.MISSED;
+
+            case android.telephony.DisconnectCause.INCOMING_REJECTED:
+                return DisconnectCause.REJECTED;
+
+            case android.telephony.DisconnectCause.BUSY:
+                return DisconnectCause.BUSY;
+
+            case android.telephony.DisconnectCause.CALL_BARRED:
+            case android.telephony.DisconnectCause.CDMA_ACCESS_BLOCKED:
+            case android.telephony.DisconnectCause.CDMA_NOT_EMERGENCY:
+            case android.telephony.DisconnectCause.CS_RESTRICTED:
+            case android.telephony.DisconnectCause.CS_RESTRICTED_EMERGENCY:
+            case android.telephony.DisconnectCause.CS_RESTRICTED_NORMAL:
+            case android.telephony.DisconnectCause.EMERGENCY_ONLY:
+            case android.telephony.DisconnectCause.FDN_BLOCKED:
+            case android.telephony.DisconnectCause.LIMIT_EXCEEDED:
+            case android.telephony.DisconnectCause.VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
+                return DisconnectCause.RESTRICTED;
+
+            case android.telephony.DisconnectCause.CDMA_ACCESS_FAILURE:
+            case android.telephony.DisconnectCause.CDMA_ALREADY_ACTIVATED:
+            case android.telephony.DisconnectCause.CDMA_CALL_LOST:
+            case android.telephony.DisconnectCause.CDMA_DROP:
+            case android.telephony.DisconnectCause.CDMA_INTERCEPT:
+            case android.telephony.DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
+            case android.telephony.DisconnectCause.CDMA_PREEMPTED:
+            case android.telephony.DisconnectCause.CDMA_REORDER:
+            case android.telephony.DisconnectCause.CDMA_RETRY_ORDER:
+            case android.telephony.DisconnectCause.CDMA_SO_REJECT:
+            case android.telephony.DisconnectCause.CONGESTION:
+            case android.telephony.DisconnectCause.ICC_ERROR:
+            case android.telephony.DisconnectCause.INVALID_CREDENTIALS:
+            case android.telephony.DisconnectCause.INVALID_NUMBER:
+            case android.telephony.DisconnectCause.LOST_SIGNAL:
+            case android.telephony.DisconnectCause.NO_PHONE_NUMBER_SUPPLIED:
+            case android.telephony.DisconnectCause.NUMBER_UNREACHABLE:
+            case android.telephony.DisconnectCause.OUTGOING_FAILURE:
+            case android.telephony.DisconnectCause.OUT_OF_NETWORK:
+            case android.telephony.DisconnectCause.OUT_OF_SERVICE:
+            case android.telephony.DisconnectCause.POWER_OFF:
+            case android.telephony.DisconnectCause.SERVER_ERROR:
+            case android.telephony.DisconnectCause.SERVER_UNREACHABLE:
+            case android.telephony.DisconnectCause.TIMED_OUT:
+            case android.telephony.DisconnectCause.UNOBTAINABLE_NUMBER:
+            case android.telephony.DisconnectCause.VOICEMAIL_NUMBER_MISSING:
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_USSD:
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_SS:
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_DIAL:
+            case android.telephony.DisconnectCause.ERROR_UNSPECIFIED:
+            case android.telephony.DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED:
+            case android.telephony.DisconnectCause.DATA_DISABLED:
+            case android.telephony.DisconnectCause.DATA_LIMIT_REACHED:
+            case android.telephony.DisconnectCause.DIALED_ON_WRONG_SLOT:
+            /// M: CC: Error message due to VoLTE SS checking @{
+            case android.telephony.DisconnectCause.VOLTE_SS_DATA_OFF:
+            /// @}
+                return DisconnectCause.ERROR;
+
+            case android.telephony.DisconnectCause.DIALED_MMI:
+            case android.telephony.DisconnectCause.EXITED_ECM:
+            case android.telephony.DisconnectCause.MMI:
+            case android.telephony.DisconnectCause.IMS_MERGED_SUCCESSFULLY:
+                return DisconnectCause.OTHER;
+
+            ///M: WFC @{
+            case android.telephony.DisconnectCause.WFC_WIFI_SIGNAL_LOST:
+            case android.telephony.DisconnectCause.WFC_ISP_PROBLEM:
+            case android.telephony.DisconnectCause.WFC_HANDOVER_WIFI_FAIL:
+            case android.telephony.DisconnectCause.WFC_HANDOVER_LTE_FAIL:
+                  return DisconnectCause.WFC_CALL_ERROR;
+            /// @}
+
+            case android.telephony.DisconnectCause.NOT_VALID:
+            case android.telephony.DisconnectCause.NOT_DISCONNECTED:
+                return DisconnectCause.UNKNOWN;
+
+            case android.telephony.DisconnectCause.CALL_PULLED:
+                return DisconnectCause.CALL_PULLED;
+
+            case android.telephony.DisconnectCause.ANSWERED_ELSEWHERE:
+                return DisconnectCause.ANSWERED_ELSEWHERE;
+
+            default:
+                ///M: OP07 <returns DisconnectCause.UNKNOWN for
+                ///default and if OP07 then corresponding plugin specific error code>
+                Log.w("DisconnectCauseUtil.toTelecomDisconnectCauseCode",
+                        "Unrecognized Telephony DisconnectCause "
+                        + telephonyDisconnectCause);
+                return ExtensionManager.getDisconnectCauseExt()
+                        .toDisconnectCauseCode(telephonyDisconnectCause
+                        , DisconnectCause.UNKNOWN);
+        }
+    }
+
+    /**
+     * Returns a label for to the disconnect cause to be shown to the user.
+     */
+    private static CharSequence toTelecomDisconnectCauseLabel(
+            Context context, int telephonyDisconnectCause) {
+        if (context == null ) {
+            return "";
+        }
+
+        Integer resourceId = null;
+        switch (telephonyDisconnectCause) {
+            case android.telephony.DisconnectCause.BUSY:
+                resourceId = R.string.callFailed_userBusy;
+                break;
+
+            case android.telephony.DisconnectCause.CONGESTION:
+                resourceId = R.string.callFailed_congestion;
+                break;
+
+            case android.telephony.DisconnectCause.TIMED_OUT:
+                resourceId = R.string.callFailed_timedOut;
+                break;
+
+            case android.telephony.DisconnectCause.SERVER_UNREACHABLE:
+                resourceId = R.string.callFailed_server_unreachable;
+                break;
+
+            case android.telephony.DisconnectCause.NUMBER_UNREACHABLE:
+                resourceId = R.string.callFailed_number_unreachable;
+                break;
+
+            case android.telephony.DisconnectCause.INVALID_CREDENTIALS:
+                resourceId = R.string.callFailed_invalid_credentials;
+                break;
+
+            case android.telephony.DisconnectCause.SERVER_ERROR:
+                resourceId = R.string.callFailed_server_error;
+                break;
+
+            case android.telephony.DisconnectCause.OUT_OF_NETWORK:
+                resourceId = R.string.callFailed_out_of_network;
+                break;
+
+            case android.telephony.DisconnectCause.LOST_SIGNAL:
+            case android.telephony.DisconnectCause.CDMA_DROP:
+                resourceId = R.string.callFailed_noSignal;
+                break;
+
+            case android.telephony.DisconnectCause.LIMIT_EXCEEDED:
+                resourceId = R.string.callFailed_limitExceeded;
+                break;
+
+            case android.telephony.DisconnectCause.POWER_OFF:
+                resourceId = R.string.callFailed_powerOff;
+                break;
+
+            case android.telephony.DisconnectCause.ICC_ERROR:
+                resourceId = R.string.callFailed_simError;
+                break;
+
+            case android.telephony.DisconnectCause.OUT_OF_SERVICE:
+                resourceId = R.string.callFailed_outOfService;
+                break;
+
+            case android.telephony.DisconnectCause.INVALID_NUMBER:
+            case android.telephony.DisconnectCause.UNOBTAINABLE_NUMBER:
+                resourceId = R.string.callFailed_unobtainable_number;
+                break;
+
+            case android.telephony.DisconnectCause.CALL_PULLED:
+                resourceId = R.string.callEnded_pulled;
+                break;
+
+            case android.telephony.DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED:
+                resourceId = R.string.callFailed_maximum_reached;
+                break;
+
+            case android.telephony.DisconnectCause.DATA_DISABLED:
+                resourceId = R.string.callFailed_data_disabled;
+                break;
+
+            case android.telephony.DisconnectCause.DATA_LIMIT_REACHED:
+                resourceId = R.string.callFailed_data_limit_reached;
+                break;
+
+            /// M: WFC @{
+            case android.telephony.DisconnectCause.WFC_WIFI_SIGNAL_LOST:
+                resourceId = R.string.wfc_wifi_call_drop;
+                break;
+            case android.telephony.DisconnectCause.WFC_ISP_PROBLEM:
+                resourceId = R.string.wfc_internet_connection_lost;
+                break;
+            case android.telephony.DisconnectCause.WFC_HANDOVER_WIFI_FAIL:
+                resourceId = R.string.wfc_wifi_call_drop;
+                break;
+            case android.telephony.DisconnectCause.WFC_HANDOVER_LTE_FAIL:
+                resourceId = R.string.wfc_no_network;
+                break;
+            ///@}
+
+            default:
+                break;
+        }
+        return resourceId == null ? ExtensionManager.getDisconnectCauseExt()
+                .toDisconnectCauseLabel(telephonyDisconnectCause ,"")
+                : context.getResources().getString(resourceId);
+    }
+
+    /**
+     * Returns a description of the disconnect cause to be shown to the user.
+     */
+    private static CharSequence toTelecomDisconnectCauseDescription(
+            Context context, int telephonyDisconnectCause) {
+        if (context == null ) {
+            return "";
+        }
+
+        Integer resourceId = null;
+        switch (telephonyDisconnectCause) {
+            case android.telephony.DisconnectCause.CALL_BARRED:
+                resourceId = R.string.callFailed_cb_enabled;
+                break;
+
+            case android.telephony.DisconnectCause.CDMA_ALREADY_ACTIVATED:
+                resourceId = R.string.callFailed_cdma_activation;
+                break;
+
+            case android.telephony.DisconnectCause.FDN_BLOCKED:
+                resourceId = R.string.callFailed_fdn_only;
+                break;
+
+            case android.telephony.DisconnectCause.CS_RESTRICTED:
+                resourceId = R.string.callFailed_dsac_restricted;
+                break;
+
+            case android.telephony.DisconnectCause.CS_RESTRICTED_EMERGENCY:
+                resourceId = R.string.callFailed_dsac_restricted_emergency;
+                break;
+
+            case android.telephony.DisconnectCause.CS_RESTRICTED_NORMAL:
+                resourceId = R.string.callFailed_dsac_restricted_normal;
+                break;
+
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_USSD:
+                resourceId = R.string.callFailed_dialToUssd;
+                break;
+
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_SS:
+                resourceId = R.string.callFailed_dialToSs;
+                break;
+
+            case android.telephony.DisconnectCause.DIAL_MODIFIED_TO_DIAL:
+                resourceId = R.string.callFailed_dialToDial;
+                break;
+
+            case android.telephony.DisconnectCause.OUTGOING_FAILURE:
+                // We couldn't successfully place the call; there was some
+                // failure in the telephony layer.
+                // TODO: Need UI spec for this failure case; for now just
+                // show a generic error.
+                resourceId = R.string.incall_error_call_failed;
+                break;
+
+            case android.telephony.DisconnectCause.POWER_OFF:
+                // Radio is explictly powered off because the device is in airplane mode.
+
+                // TODO: Offer the option to turn the radio on, and automatically retry the call
+                // once network registration is complete.
+
+                if (ImsUtil.shouldPromoteWfc(context)) {
+                    resourceId = R.string.incall_error_promote_wfc;
+                } else if (ImsUtil.isWfcModeWifiOnly(context)) {
+                    resourceId = R.string.incall_error_wfc_only_no_wireless_network;
+                } else if (ImsUtil.isWfcEnabled(context)) {
+                    resourceId = R.string.incall_error_power_off_wfc;
+                } else {
+                    /// M: CC: Modem reset related handling @{
+                    // Avoid to send power off error description (UI show turn off
+                    // airplane mode) to Telecom when modem reset because airplane mode
+                    // is off(power on) in Setting actually.
+                    if (Settings.Global.getInt(context.getContentResolver(),
+                            Settings.Global.AIRPLANE_MODE_ON, 0) > 0) {
+                        resourceId = R.string.incall_error_power_off;
+                    }
+                    //resourceId = R.string.incall_error_power_off;
+                    /// @}
+                }
+                break;
+
+            case android.telephony.DisconnectCause.CDMA_NOT_EMERGENCY:
+                // Only emergency calls are allowed when in emergency callback mode.
+                resourceId = R.string.incall_error_ecm_emergency_only;
+                break;
+
+            case android.telephony.DisconnectCause.EMERGENCY_ONLY:
+                // Only emergency numbers are allowed, but we tried to dial
+                // a non-emergency number.
+                resourceId = R.string.incall_error_emergency_only;
+                break;
+
+            case android.telephony.DisconnectCause.OUT_OF_SERVICE:
+                // No network connection.
+                if (ImsUtil.shouldPromoteWfc(context)) {
+                    resourceId = R.string.incall_error_promote_wfc;
+                } else if (ImsUtil.isWfcModeWifiOnly(context)) {
+                    resourceId = R.string.incall_error_wfc_only_no_wireless_network;
+                } else if (ImsUtil.isWfcEnabled(context)) {
+                    resourceId = R.string.incall_error_out_of_service_wfc;
+                } else {
+                    resourceId = R.string.incall_error_out_of_service;
+                }
+                break;
+
+            case android.telephony.DisconnectCause.NO_PHONE_NUMBER_SUPPLIED:
+                // The supplied Intent didn't contain a valid phone number.
+                // (This is rare and should only ever happen with broken
+                // 3rd-party apps.) For now just show a generic error.
+                resourceId = R.string.incall_error_no_phone_number_supplied;
+                break;
+
+            case android.telephony.DisconnectCause.VOICEMAIL_NUMBER_MISSING:
+                // TODO: Need to bring up the "Missing Voicemail Number" dialog, which
+                // will ultimately take us to the Call Settings.
+                resourceId = R.string.dialog_voicemail_not_ready_message;
+                break;
+
+            case android.telephony.DisconnectCause.VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
+                resourceId = R.string.callFailed_video_call_tty_enabled;
+                break;
+
+            case android.telephony.DisconnectCause.CALL_PULLED:
+                resourceId = R.string.callEnded_pulled;
+                break;
+
+            case android.telephony.DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED:
+                resourceId = R.string.callFailed_maximum_reached;
+
+            case android.telephony.DisconnectCause.OUTGOING_CANCELED:
+                // We don't want to show any dialog for the canceled case since the call was
+                // either canceled by the user explicitly (end-call button pushed immediately)
+                // or some other app canceled the call and immediately issued a new CALL to
+                // replace it.
+                break;
+
+            case android.telephony.DisconnectCause.DATA_DISABLED:
+                resourceId = R.string.callFailed_data_disabled;
+                break;
+
+            case android.telephony.DisconnectCause.DATA_LIMIT_REACHED:
+                resourceId = R.string.callFailed_data_limit_reached_description;
+                break;
+
+            /// M: CC: Error message due to VoLTE SS checking @{
+            case android.telephony.DisconnectCause.VOLTE_SS_DATA_OFF:
+                resourceId = R.string.volte_ss_not_available_tips;
+                break;
+            /// @}
+            /// M: ALPS02151583. UI doesn't show response when dialing an invalid number. @{
+            case android.telephony.DisconnectCause.NUMBER_UNREACHABLE:
+                resourceId = R.string.callFailed_number_unreachable;
+                break;
+            /// @}
+            ///M: WFC @{
+            case android.telephony.DisconnectCause.WFC_WIFI_SIGNAL_LOST:
+                resourceId = R.string.wfc_wifi_call_drop_summary;
+                break;
+            case android.telephony.DisconnectCause.WFC_ISP_PROBLEM:
+                resourceId = R.string.wfc_internet_lost_summary;
+                break;
+            case android.telephony.DisconnectCause.WFC_HANDOVER_WIFI_FAIL:
+                resourceId = R.string.wfc_wifi_handover_fail;
+                break;
+            case android.telephony.DisconnectCause.WFC_HANDOVER_LTE_FAIL:
+                resourceId = R.string.wfc_wifi_lte_handover_fail;
+                break;
+            /// @}
+            /// M: CC: Error message due to CellConnMgr checking @{
+            case android.telephony.DisconnectCause.OUTGOING_CANCELED_BY_SERVICE:
+                break;
+            /// @}
+
+            default:
+                break;
+        }
+        return resourceId == null ? ExtensionManager.getDisconnectCauseExt()
+                .toDisconnectCauseDescription(telephonyDisconnectCause, "")
+                : context.getResources().getString(resourceId);
+    }
+
+    private static String toTelecomDisconnectReason(int telephonyDisconnectCause, String reason) {
+        String causeAsString = android.telephony.DisconnectCause.toString(telephonyDisconnectCause);
+        if (reason == null) {
+            return causeAsString;
+        } else {
+            return reason + ", " + causeAsString;
+        }
+    }
+
+    /**
+     * Returns the tone to play for the disconnect cause, or UNKNOWN if none should be played.
+     */
+    private static int toTelecomDisconnectCauseTone(int telephonyDisconnectCause) {
+        switch (telephonyDisconnectCause) {
+            case android.telephony.DisconnectCause.BUSY:
+                return ToneGenerator.TONE_SUP_BUSY;
+
+            case android.telephony.DisconnectCause.CONGESTION:
+                return ToneGenerator.TONE_SUP_CONGESTION;
+
+            case android.telephony.DisconnectCause.CDMA_REORDER:
+                return ToneGenerator.TONE_CDMA_REORDER;
+
+            case android.telephony.DisconnectCause.CDMA_INTERCEPT:
+                return ToneGenerator.TONE_CDMA_ABBR_INTERCEPT;
+
+            case android.telephony.DisconnectCause.CDMA_DROP:
+            case android.telephony.DisconnectCause.OUT_OF_SERVICE:
+                return ToneGenerator.TONE_CDMA_CALLDROP_LITE;
+
+            case android.telephony.DisconnectCause.UNOBTAINABLE_NUMBER:
+                return ToneGenerator.TONE_SUP_ERROR;
+
+            case android.telephony.DisconnectCause.ERROR_UNSPECIFIED:
+            case android.telephony.DisconnectCause.LOCAL:
+            case android.telephony.DisconnectCause.NORMAL:
+            case android.telephony.DisconnectCause.VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
+                return ToneGenerator.TONE_PROP_PROMPT;
+
+            case android.telephony.DisconnectCause.IMS_MERGED_SUCCESSFULLY:
+                // Do not play any tones if disconnected because of a successful merge.
+            default:
+                return ToneGenerator.TONE_UNKNOWN;
+        }
+    }
+}
Index: vendor/branch/5058A_Telcel/frameworks/base/telephony/java/android/telephony/DisconnectCause.java
===================================================================
--- vendor/branch/5058A_Telcel/frameworks/base/telephony/java/android/telephony/DisconnectCause.java	(revision 0)
+++ vendor/branch/5058A_Telcel/frameworks/base/telephony/java/android/telephony/DisconnectCause.java	(revision 4004)
@@ -0,0 +1,672 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+/**
+ * Contains disconnect call causes generated by the framework and the RIL.
+ * @hide
+ */
+public class DisconnectCause {
+
+    /** The disconnect cause is not valid (Not received a disconnect cause) */
+    public static final int NOT_VALID                      = -1;
+    /** Has not yet disconnected */
+    public static final int NOT_DISCONNECTED               = 0;
+    /** An incoming call that was missed and never answered */
+    public static final int INCOMING_MISSED                = 1;
+    /** Normal; Remote hangup*/
+    public static final int NORMAL                         = 2;
+    /** Normal; Local hangup */
+    public static final int LOCAL                          = 3;
+    /** Outgoing call to busy line */
+    public static final int BUSY                           = 4;
+    /** Outgoing call to congested network */
+    public static final int CONGESTION                     = 5;
+    /** Not presently used */
+    public static final int MMI                            = 6;
+    /** Invalid dial string */
+    public static final int INVALID_NUMBER                 = 7;
+    /** Cannot reach the peer */
+    public static final int NUMBER_UNREACHABLE             = 8;
+    /** Cannot reach the server */
+    public static final int SERVER_UNREACHABLE             = 9;
+    /** Invalid credentials */
+    public static final int INVALID_CREDENTIALS            = 10;
+    /** Calling from out of network is not allowed */
+    public static final int OUT_OF_NETWORK                 = 11;
+    /** Server error */
+    public static final int SERVER_ERROR                   = 12;
+    /** Client timed out */
+    public static final int TIMED_OUT                      = 13;
+    /** Client went out of network range */
+    public static final int LOST_SIGNAL                    = 14;
+    /** GSM or CDMA ACM limit exceeded */
+    public static final int LIMIT_EXCEEDED                 = 15;
+    /** An incoming call that was rejected */
+    public static final int INCOMING_REJECTED              = 16;
+    /** Radio is turned off explicitly */
+    public static final int POWER_OFF                      = 17;
+    /** Out of service */
+    public static final int OUT_OF_SERVICE                 = 18;
+    /** No ICC, ICC locked, or other ICC error */
+    public static final int ICC_ERROR                      = 19;
+    /** Call was blocked by call barring */
+    public static final int CALL_BARRED                    = 20;
+    /** Call was blocked by fixed dial number */
+    public static final int FDN_BLOCKED                    = 21;
+    /** Call was blocked by restricted all voice access */
+    public static final int CS_RESTRICTED                  = 22;
+    /** Call was blocked by restricted normal voice access */
+    public static final int CS_RESTRICTED_NORMAL           = 23;
+    /** Call was blocked by restricted emergency voice access */
+    public static final int CS_RESTRICTED_EMERGENCY        = 24;
+    /** Unassigned number */
+    public static final int UNOBTAINABLE_NUMBER            = 25;
+    /** MS is locked until next power cycle */
+    public static final int CDMA_LOCKED_UNTIL_POWER_CYCLE  = 26;
+    /** Drop call*/
+    public static final int CDMA_DROP                      = 27;
+    /** INTERCEPT order received, MS state idle entered */
+    public static final int CDMA_INTERCEPT                 = 28;
+    /** MS has been redirected, call is cancelled */
+    public static final int CDMA_REORDER                   = 29;
+    /** Service option rejection */
+    public static final int CDMA_SO_REJECT                 = 30;
+    /** Requested service is rejected, retry delay is set */
+    public static final int CDMA_RETRY_ORDER               = 31;
+    /** Unable to obtain access to the CDMA system */
+    public static final int CDMA_ACCESS_FAILURE            = 32;
+    /** Not a preempted call */
+    public static final int CDMA_PREEMPTED                 = 33;
+    /** Not an emergency call */
+    public static final int CDMA_NOT_EMERGENCY             = 34;
+    /** Access Blocked by CDMA network */
+    public static final int CDMA_ACCESS_BLOCKED            = 35;
+    /** Unknown error or not specified */
+    public static final int ERROR_UNSPECIFIED              = 36;
+    /**
+     * Only emergency numbers are allowed, but we tried to dial
+     * a non-emergency number.
+     */
+    // TODO: This should be the same as NOT_EMERGENCY
+    public static final int EMERGENCY_ONLY                 = 37;
+    /**
+     * The supplied CALL Intent didn't contain a valid phone number.
+     */
+    public static final int NO_PHONE_NUMBER_SUPPLIED       = 38;
+    /**
+     * Our initial phone number was actually an MMI sequence.
+     */
+    public static final int DIALED_MMI                     = 39;
+    /**
+     * We tried to call a voicemail: URI but the device has no
+     * voicemail number configured.
+     */
+    public static final int VOICEMAIL_NUMBER_MISSING       = 40;
+    /**
+     * This status indicates that InCallScreen should display the
+     * CDMA-specific "call lost" dialog.  (If an outgoing call fails,
+     * and the CDMA "auto-retry" feature is enabled, *and* the retried
+     * call fails too, we display this specific dialog.)
+     *
+     * TODO: this is currently unused, since the "call lost" dialog
+     * needs to be triggered by a *disconnect* event, rather than when
+     * the InCallScreen first comes to the foreground.  For now we use
+     * the needToShowCallLostDialog field for this (see below.)
+     */
+    public static final int CDMA_CALL_LOST                 = 41;
+    /**
+     * This status indicates that the call was placed successfully,
+     * but additionally, the InCallScreen needs to display the
+     * "Exiting ECM" dialog.
+     *
+     * (Details: "Emergency callback mode" is a CDMA-specific concept
+     * where the phone disallows data connections over the cell
+     * network for some period of time after you make an emergency
+     * call.  If the phone is in ECM and you dial a non-emergency
+     * number, that automatically *cancels* ECM, but we additionally
+     * need to warn the user that ECM has been canceled (see bug
+     * 4207607.))
+     *
+     * TODO: Rethink where the best place to put this is. It is not a notification
+     * of a failure of the connection -- it is an additional message that accompanies
+     * a successful connection giving the user important information about what happened.
+     *
+     * {@hide}
+     */
+    public static final int EXITED_ECM                     = 42;
+
+    /**
+     * The outgoing call failed with an unknown cause.
+     */
+    public static final int OUTGOING_FAILURE               = 43;
+
+    /**
+     * The outgoing call was canceled by the {@link android.telecom.ConnectionService}.
+     */
+    public static final int OUTGOING_CANCELED              = 44;
+
+    /**
+     * The call, which was an IMS call, disconnected because it merged with another call.
+     */
+    public static final int IMS_MERGED_SUCCESSFULLY        = 45;
+
+    /**
+     * Stk Call Control modified DIAL request to USSD request.
+     * {@hide}
+     */
+    public static final int DIAL_MODIFIED_TO_USSD          = 46;
+    /**
+     * Stk Call Control modified DIAL request to SS request.
+     * {@hide}
+     */
+    public static final int DIAL_MODIFIED_TO_SS            = 47;
+    /**
+     * Stk Call Control modified DIAL request to DIAL with modified data.
+     * {@hide}
+     */
+    public static final int DIAL_MODIFIED_TO_DIAL          = 48;
+
+    /**
+     * The call was terminated because CDMA phone service and roaming have already been activated.
+     * {@hide}
+     */
+    public static final int CDMA_ALREADY_ACTIVATED         = 49;
+
+    /**
+     * The call was terminated because it is not possible to place a video call while TTY is
+     * enabled.
+     * {@hide}
+     */
+    public static final int VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED = 50;
+
+    /**
+     * The call was terminated because it was pulled to another device.
+     * {@hide}
+     */
+    public static final int CALL_PULLED = 51;
+
+    /**
+     * The call was terminated because it was answered on another device.
+     * {@hide}
+     */
+    public static final int ANSWERED_ELSEWHERE = 52;
+
+    /**
+     * The call was terminated because the maximum allowable number of calls has been reached.
+     * {@hide}
+     */
+    public static final int MAXIMUM_NUMBER_OF_CALLS_REACHED = 53;
+
+    /**
+     * The call was terminated because cellular data has been disabled.
+     * Used when in a video call and the user disables cellular data via the settings.
+     * {@hide}
+     */
+    public static final int DATA_DISABLED = 54;
+
+    /**
+     * The call was terminated because the data policy has disabled cellular data.
+     * Used when in a video call and the user has exceeded the device data limit.
+     * {@hide}
+     */
+    public static final int DATA_LIMIT_REACHED = 55;
+
+    /**
+     * The emergency call was terminated because it was dialed on the wrong SIM slot.
+     * The call needs to be redialed the other slot.
+     * {@hide}
+     */
+    public static final int DIALED_ON_WRONG_SLOT = 56;
+
+    //*********************************************************************************************
+    // When adding a disconnect type:
+    // 1) Please assign the new type the next id value below.
+    // 2) Increment the next id value below to a new value.
+    // 3) Update MAXIMUM_VALID_VALUE to the new disconnect type.
+    // 4) Update toString() with the newly added disconnect type.
+    // 5) Update android.telecom.DisconnectCauseUtil with any mappings to a telecom.DisconnectCause.
+    //
+    // NextId: 57
+    //*********************************************************************************************
+
+    /// M: CC: Extend Call Fail Cause @{
+    /// [ALPS00093395]
+    /**
+     * @hide
+     */
+    public static final int MTK_DISCONNECTED_CAUSE_BASE = DIALED_ON_WRONG_SLOT;
+    /** no route to destination
+     * @hide
+     */
+    public static final int NO_ROUTE_TO_DESTINATION        = MTK_DISCONNECTED_CAUSE_BASE + 1;
+    /** no user responding
+     * @hide
+     */
+    public static final int NO_USER_RESPONDING             = MTK_DISCONNECTED_CAUSE_BASE + 2;
+    /** user alerting, no answer
+     * @hide
+     */
+    public static final int USER_ALERTING_NO_ANSWER        = MTK_DISCONNECTED_CAUSE_BASE + 3;
+    /** call rejected
+     * @hide
+     */
+    public static final int CALL_REJECTED                  = MTK_DISCONNECTED_CAUSE_BASE + 4;
+    /** invalid number format
+     * @hide
+     */
+    public static final int INVALID_NUMBER_FORMAT          = MTK_DISCONNECTED_CAUSE_BASE + 5;
+    /** facility rejected
+     * @hide
+     */
+    public static final int FACILITY_REJECTED              = MTK_DISCONNECTED_CAUSE_BASE + 6;
+    /** normal, unspecified
+     * @hide
+     */
+    public static final int NORMAL_UNSPECIFIED             = MTK_DISCONNECTED_CAUSE_BASE + 7;
+    /** no circuit/channel available
+     * @hide
+     */
+    public static final int NO_CIRCUIT_AVAIL               = MTK_DISCONNECTED_CAUSE_BASE + 8;
+    /** switching equipment congestion
+     * @hide
+     */
+    public static final int SWITCHING_CONGESTION           = MTK_DISCONNECTED_CAUSE_BASE + 9;
+    /** resource unavailable, unspecified
+     * @hide
+     */
+    public static final int RESOURCE_UNAVAILABLE           = MTK_DISCONNECTED_CAUSE_BASE + 10;
+    /** bearer capability not authorized
+     * @hide
+     */
+    public static final int BEARER_NOT_AUTHORIZED          = MTK_DISCONNECTED_CAUSE_BASE + 11;
+    /** bearer capability not presently available
+     * @hide
+     */
+    public static final int BEARER_NOT_AVAIL               = MTK_DISCONNECTED_CAUSE_BASE + 12;
+    /** service or option not available, unspecified
+     * @hide
+     */
+    public static final int SERVICE_NOT_AVAILABLE          = MTK_DISCONNECTED_CAUSE_BASE + 13;
+    /** bearer service not implemented
+     * @hide
+     */
+    public static final int BEARER_NOT_IMPLEMENT           = MTK_DISCONNECTED_CAUSE_BASE + 14;
+    /** Requested facility not implemented
+     * @hide
+     */
+    public static final int FACILITY_NOT_IMPLEMENT         = MTK_DISCONNECTED_CAUSE_BASE + 15;
+    /** only restricted digital information bearer capability is available
+     * @hide
+     */
+    public static final int RESTRICTED_BEARER_AVAILABLE    = MTK_DISCONNECTED_CAUSE_BASE + 16;
+    /** service or option not implemented, unspecified
+     * @hide
+     */
+    public static final int OPTION_NOT_AVAILABLE           = MTK_DISCONNECTED_CAUSE_BASE + 17;
+    /** incompatible destination
+     * @hide
+     */
+    public static final int INCOMPATIBLE_DESTINATION       = MTK_DISCONNECTED_CAUSE_BASE + 18;
+    /** RR connection release
+     * @hide
+     */
+    public static final int CHANNEL_UNACCEPTABLE           = MTK_DISCONNECTED_CAUSE_BASE + 19;
+    /**
+     * @hide
+     */
+    public static final int OPERATOR_DETERMINED_BARRING    = MTK_DISCONNECTED_CAUSE_BASE + 20;
+    /**
+     * @hide
+     */
+    public static final int PRE_EMPTION                    = MTK_DISCONNECTED_CAUSE_BASE + 21;
+    /**
+     * @hide
+     */
+    public static final int NON_SELECTED_USER_CLEARING     = MTK_DISCONNECTED_CAUSE_BASE + 22;
+    /**
+     * @hide
+     */
+    public static final int DESTINATION_OUT_OF_ORDER       = MTK_DISCONNECTED_CAUSE_BASE + 23;
+    /**
+     * @hide
+     */
+    public static final int ACCESS_INFORMATION_DISCARDED   = MTK_DISCONNECTED_CAUSE_BASE + 24;
+    /**
+     * @hide
+     */
+    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = MTK_DISCONNECTED_CAUSE_BASE + 25;
+    /**
+     * @hide
+     */
+    public static final int INCOMING_CALL_BARRED_WITHIN_CUG   = MTK_DISCONNECTED_CAUSE_BASE + 26;
+    /**
+     * @hide
+     */
+    public static final int INVALID_TRANSACTION_ID_VALUE   = MTK_DISCONNECTED_CAUSE_BASE + 27;
+    /**
+     * @hide
+     */
+    public static final int USER_NOT_MEMBER_OF_CUG         = MTK_DISCONNECTED_CAUSE_BASE + 28;
+    /**
+     * @hide
+     */
+    public static final int INVALID_TRANSIT_NETWORK_SELECTION = MTK_DISCONNECTED_CAUSE_BASE + 29;
+    /**
+     * @hide
+     */
+    public static final int SEMANTICALLY_INCORRECT_MESSAGE = MTK_DISCONNECTED_CAUSE_BASE + 30;
+    /**
+     * @hide
+     */
+    public static final int INVALID_MANDATORY_INFORMATION  = MTK_DISCONNECTED_CAUSE_BASE + 31;
+    /**
+     * @hide
+     */
+    public static final int MESSAGE_TYPE_NON_EXISTENT      = MTK_DISCONNECTED_CAUSE_BASE + 32;
+    /**
+     * @hide
+     */
+    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE = MTK_DISCONNECTED_CAUSE_BASE + 33;
+    /**
+     * @hide
+     */
+    public static final int IE_NON_EXISTENT_OR_NOT_IMPLEMENTED = MTK_DISCONNECTED_CAUSE_BASE + 34;
+    /**
+     * @hide
+     */
+    public static final int CONDITIONAL_IE_ERROR           = MTK_DISCONNECTED_CAUSE_BASE + 35;
+    /**
+     * @hide
+     */
+    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = MTK_DISCONNECTED_CAUSE_BASE + 36;
+    /**
+     * @hide
+     */
+    public static final int RECOVERY_ON_TIMER_EXPIRY       = MTK_DISCONNECTED_CAUSE_BASE + 37;
+    /**
+     * @hide
+     */
+    public static final int PROTOCOL_ERROR_UNSPECIFIED     = MTK_DISCONNECTED_CAUSE_BASE + 38;
+    /**
+     * @hide
+     */
+    public static final int INTERWORKING_UNSPECIFIED       = MTK_DISCONNECTED_CAUSE_BASE + 39;
+    /**
+     * @hide
+     */
+    public static final int CM_MM_RR_CONNECTION_RELEASE    = MTK_DISCONNECTED_CAUSE_BASE + 40;
+    /// @}
+    /// M: CC: Error message due to CellConnMgr checking @{
+    /**
+     * @hide
+     */
+    public static final int OUTGOING_CANCELED_BY_SERVICE   = MTK_DISCONNECTED_CAUSE_BASE + 41;
+    /// @}
+    /// M: CC: Error message due to VoLTE SS checking @{
+    /**
+     * Reject MMI for setting SS under VoLTE without data setting enabled, since XCAP is thru HTTP
+     * It shares same error string as modifying SS setting under same scenario.
+     * see {@link com.android.services.telephony.DisconnectCauseUtil#toTelecomDisconnectCauseLabel}
+     * @hide
+     */
+    public static final int VOLTE_SS_DATA_OFF              = MTK_DISCONNECTED_CAUSE_BASE + 42;
+    /// @}
+
+    /// M: IMS feature. @{
+    public static final int IMS_EMERGENCY_REREG = 380;
+    /// @}
+
+    /// M: ALPS02112553. Define new disconnected cause for WFC. @{
+    public static final int WFC_WIFI_SIGNAL_LOST = 400;
+    public static final int WFC_ISP_PROBLEM = 401;
+    public static final int WFC_HANDOVER_WIFI_FAIL = 402;
+    public static final int WFC_HANDOVER_LTE_FAIL = 403;
+    /// @}
+
+    /// M: ALPS02501206. For OP07 requirement. @{
+    public static final int ECC_OVER_WIFI_UNSUPPORTED = 404;
+    public static final int WFC_UNAVAILABLE_IN_CURRENT_LOCATION = 405;
+    /// @}
+
+    /** Smallest valid value for call disconnect codes. */
+    public static final int MINIMUM_VALID_VALUE = NOT_DISCONNECTED;
+
+    /** Largest valid value for call disconnect codes. */
+    public static final int MAXIMUM_VALID_VALUE = DIALED_ON_WRONG_SLOT;
+
+    /** Private constructor to avoid class instantiation. */
+    private DisconnectCause() {
+        // Do nothing.
+    }
+
+    /** Returns descriptive string for the specified disconnect cause. */
+    public static String toString(int cause) {
+        switch (cause) {
+        case NOT_DISCONNECTED:
+            return "NOT_DISCONNECTED";
+        case INCOMING_MISSED:
+            return "INCOMING_MISSED";
+        case NORMAL:
+            return "NORMAL";
+        case LOCAL:
+            return "LOCAL";
+        case BUSY:
+            return "BUSY";
+        case CONGESTION:
+            return "CONGESTION";
+        case INVALID_NUMBER:
+            return "INVALID_NUMBER";
+        case NUMBER_UNREACHABLE:
+            return "NUMBER_UNREACHABLE";
+        case SERVER_UNREACHABLE:
+            return "SERVER_UNREACHABLE";
+        case INVALID_CREDENTIALS:
+            return "INVALID_CREDENTIALS";
+        case OUT_OF_NETWORK:
+            return "OUT_OF_NETWORK";
+        case SERVER_ERROR:
+            return "SERVER_ERROR";
+        case TIMED_OUT:
+            return "TIMED_OUT";
+        case LOST_SIGNAL:
+            return "LOST_SIGNAL";
+        case LIMIT_EXCEEDED:
+            return "LIMIT_EXCEEDED";
+        case INCOMING_REJECTED:
+            return "INCOMING_REJECTED";
+        case POWER_OFF:
+            return "POWER_OFF";
+        case OUT_OF_SERVICE:
+            return "OUT_OF_SERVICE";
+        case ICC_ERROR:
+            return "ICC_ERROR";
+        case CALL_BARRED:
+            return "CALL_BARRED";
+        case FDN_BLOCKED:
+            return "FDN_BLOCKED";
+        case CS_RESTRICTED:
+            return "CS_RESTRICTED";
+        case CS_RESTRICTED_NORMAL:
+            return "CS_RESTRICTED_NORMAL";
+        case CS_RESTRICTED_EMERGENCY:
+            return "CS_RESTRICTED_EMERGENCY";
+        case UNOBTAINABLE_NUMBER:
+            return "UNOBTAINABLE_NUMBER";
+        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
+            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
+        case CDMA_DROP:
+            return "CDMA_DROP";
+        case CDMA_INTERCEPT:
+            return "CDMA_INTERCEPT";
+        case CDMA_REORDER:
+            return "CDMA_REORDER";
+        case CDMA_SO_REJECT:
+            return "CDMA_SO_REJECT";
+        case CDMA_RETRY_ORDER:
+            return "CDMA_RETRY_ORDER";
+        case CDMA_ACCESS_FAILURE:
+            return "CDMA_ACCESS_FAILURE";
+        case CDMA_PREEMPTED:
+            return "CDMA_PREEMPTED";
+        case CDMA_NOT_EMERGENCY:
+            return "CDMA_NOT_EMERGENCY";
+        case CDMA_ACCESS_BLOCKED:
+            return "CDMA_ACCESS_BLOCKED";
+        case EMERGENCY_ONLY:
+            return "EMERGENCY_ONLY";
+        case NO_PHONE_NUMBER_SUPPLIED:
+            return "NO_PHONE_NUMBER_SUPPLIED";
+        case DIALED_MMI:
+            return "DIALED_MMI";
+        case VOICEMAIL_NUMBER_MISSING:
+            return "VOICEMAIL_NUMBER_MISSING";
+        case CDMA_CALL_LOST:
+            return "CDMA_CALL_LOST";
+        case EXITED_ECM:
+            return "EXITED_ECM";
+        case DIAL_MODIFIED_TO_USSD:
+            return "DIAL_MODIFIED_TO_USSD";
+        case DIAL_MODIFIED_TO_SS:
+            return "DIAL_MODIFIED_TO_SS";
+        case DIAL_MODIFIED_TO_DIAL:
+            return "DIAL_MODIFIED_TO_DIAL";
+        case ERROR_UNSPECIFIED:
+            return "ERROR_UNSPECIFIED";
+        case OUTGOING_FAILURE:
+            return "OUTGOING_FAILURE";
+        case OUTGOING_CANCELED:
+            return "OUTGOING_CANCELED";
+        case IMS_MERGED_SUCCESSFULLY:
+            return "IMS_MERGED_SUCCESSFULLY";
+        case CDMA_ALREADY_ACTIVATED:
+            return "CDMA_ALREADY_ACTIVATED";
+        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
+            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
+        case CALL_PULLED:
+            return "CALL_PULLED";
+        case ANSWERED_ELSEWHERE:
+            return "ANSWERED_ELSEWHERE";
+        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
+            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
+        case DATA_DISABLED:
+            return "DATA_DISABLED";
+        case DATA_LIMIT_REACHED:
+            return "DATA_LIMIT_REACHED";
+        case DIALED_ON_WRONG_SLOT:
+            return "DIALED_ON_WRONG_SLOT";
+        /// M: CC: Extend Call Fail Cause @{
+        /// [ALPS00093395]
+        case NO_ROUTE_TO_DESTINATION:
+            return "NO_ROUTE_TO_DESTINATION";
+        case NO_USER_RESPONDING:
+            return "NO_USER_RESPONDING";
+        case USER_ALERTING_NO_ANSWER:
+            return "USER_ALERTING_NO_ANSWER";
+        case CALL_REJECTED:
+            return "CALL_REJECTED";
+        case INVALID_NUMBER_FORMAT:
+            return "INVALID_NUMBER_FORMAT";
+        case FACILITY_REJECTED:
+            return "FACILITY_REJECTED";
+        case NORMAL_UNSPECIFIED:
+            return "NORMAL_UNSPECIFIED";
+        case NO_CIRCUIT_AVAIL:
+            return "NO_CIRCUIT_AVAIL";
+        case SWITCHING_CONGESTION:
+            return "SWITCHING_CONGESTION";
+        case RESOURCE_UNAVAILABLE:
+            return "RESOURCE_UNAVAILABLE";
+        case BEARER_NOT_AUTHORIZED:
+            return "BEARER_NOT_AUTHORIZED";
+        case BEARER_NOT_AVAIL:
+            return "BEARER_NOT_AVAIL";
+        case SERVICE_NOT_AVAILABLE:
+            return "SERVICE_NOT_AVAILABLE";
+        case BEARER_NOT_IMPLEMENT:
+            return "BEARER_NOT_IMPLEMENT";
+        case FACILITY_NOT_IMPLEMENT:
+            return "FACILITY_NOT_IMPLEMENT";
+        case RESTRICTED_BEARER_AVAILABLE:
+            return "RESTRICTED_BEARER_AVAILABLE";
+        case OPTION_NOT_AVAILABLE:
+            return "OPTION_NOT_AVAILABLE";
+        case INCOMPATIBLE_DESTINATION:
+            return "INCOMPATIBLE_DESTINATION";
+        case CHANNEL_UNACCEPTABLE:
+            return "CHANNEL_UNACCEPTABLE";
+        case OPERATOR_DETERMINED_BARRING:
+            return "OPERATOR_DETERMINED_BARRING";
+        case PRE_EMPTION:
+            return "PRE_EMPTION";
+        case NON_SELECTED_USER_CLEARING:
+            return "NON_SELECTED_USER_CLEARING";
+        case DESTINATION_OUT_OF_ORDER:
+            return "DESTINATION_OUT_OF_ORDER";
+        case ACCESS_INFORMATION_DISCARDED:
+            return "ACCESS_INFORMATION_DISCARDED";
+        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
+            return "REQUESTED_FACILITY_NOT_SUBSCRIBED";
+        case INCOMING_CALL_BARRED_WITHIN_CUG:
+            return "INCOMING_CALL_BARRED_WITHIN_CUG";
+        case INVALID_TRANSACTION_ID_VALUE:
+            return "INVALID_TRANSACTION_ID_VALUE";
+        case USER_NOT_MEMBER_OF_CUG:
+            return "USER_NOT_MEMBER_OF_CUG";
+        case INVALID_TRANSIT_NETWORK_SELECTION:
+            return "INVALID_TRANSIT_NETWORK_SELECTION";
+        case SEMANTICALLY_INCORRECT_MESSAGE:
+            return "SEMANTICALLY_INCORRECT_MESSAGE";
+        case INVALID_MANDATORY_INFORMATION:
+            return "INVALID_MANDATORY_INFORMATION";
+        case MESSAGE_TYPE_NON_EXISTENT:
+            return "MESSAGE_TYPE_NON_EXISTENT";
+        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE:
+            return "MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE";
+        case IE_NON_EXISTENT_OR_NOT_IMPLEMENTED:
+            return "IE_NON_EXISTENT_OR_NOT_IMPLEMENTED";
+        case CONDITIONAL_IE_ERROR:
+            return "CONDITIONAL_IE_ERROR";
+        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
+            return "MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE";
+        case RECOVERY_ON_TIMER_EXPIRY:
+            return "RECOVERY_ON_TIMER_EXPIRY";
+        case PROTOCOL_ERROR_UNSPECIFIED:
+            return "PROTOCOL_ERROR_UNSPECIFIED";
+        case INTERWORKING_UNSPECIFIED:
+            return "INTERWORKING_UNSPECIFIED";
+        case CM_MM_RR_CONNECTION_RELEASE:
+            return "CM_MM_RR_CONNECTION_RELEASE";
+        /// @}
+        /// M: CC: Error message due to CellConnMgr checking @{
+        case OUTGOING_CANCELED_BY_SERVICE:
+            return "OUTGOING_CANCELED_BY_SERVICE";
+        /// @}
+        /// M: CC: Error message due to VoLTE SS checking @{
+        case VOLTE_SS_DATA_OFF:
+            return "VOLTE_SS_DATA_OFF";
+        /// @}
+        default:
+            return "INVALID: " + cause;
+        }
+    }
+}
Index: vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/CallFailCause.java
===================================================================
--- vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/CallFailCause.java	(revision 0)
+++ vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/CallFailCause.java	(revision 4004)
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+/**
+ * Call fail causes from TS 24.008 .
+ * These are mostly the cause codes we need to distinguish for the UI.
+ * See 22.001 Annex F.4 for mapping of cause codes to local tones.
+ *
+ * CDMA call failure reasons are derived from the possible call failure scenarios described
+ * in "CDMA IS2000 - Release A (C.S0005-A v6.0)" standard.
+ *
+ * {@hide}
+ *
+ */
+public interface CallFailCause {
+    // Unassigned/Unobtainable number
+    int UNOBTAINABLE_NUMBER = 1;
+
+    int NORMAL_CLEARING     = 16;
+    // Busy Tone
+    int USER_BUSY           = 17;
+
+    // No Tone
+    int NUMBER_CHANGED      = 22;
+    int STATUS_ENQUIRY      = 30;
+    int NORMAL_UNSPECIFIED  = 31;
+
+    // Congestion Tone
+    int NO_CIRCUIT_AVAIL    = 34;
+    int TEMPORARY_FAILURE   = 41;
+    int SWITCHING_CONGESTION    = 42;
+    int CHANNEL_NOT_AVAIL   = 44;
+    int QOS_NOT_AVAIL       = 49;
+    int BEARER_NOT_AVAIL    = 58;
+
+    // others
+    int ACM_LIMIT_EXCEEDED = 68;
+    int CALL_BARRED        = 240;
+    int FDN_BLOCKED        = 241;
+
+    // Stk Call Control
+    int DIAL_MODIFIED_TO_USSD = 244;
+    int DIAL_MODIFIED_TO_SS   = 245;
+    int DIAL_MODIFIED_TO_DIAL = 246;
+
+    int CDMA_LOCKED_UNTIL_POWER_CYCLE  = 1000;
+    int CDMA_DROP                      = 1001;
+    int CDMA_INTERCEPT                 = 1002;
+    int CDMA_REORDER                   = 1003;
+    int CDMA_SO_REJECT                 = 1004;
+    int CDMA_RETRY_ORDER               = 1005;
+    int CDMA_ACCESS_FAILURE            = 1006;
+    int CDMA_PREEMPTED                 = 1007;
+
+    // For non-emergency number dialed while in emergency callback mode.
+    int CDMA_NOT_EMERGENCY             = 1008;
+
+    // Access Blocked by CDMA Network.
+    int CDMA_ACCESS_BLOCKED            = 1009;
+
+    int ERROR_UNSPECIFIED = 0xffff;
+
+    /// M: CC: Extend Call Fail Cause @{
+    int NO_ROUTE_TO_DESTINATION = 3;
+    int CHANNEL_UNACCEPTABLE = 6;
+    int OPERATOR_DETERMINED_BARRING = 8;
+    int NO_USER_RESPONDING = 18;
+    int USER_ALERTING_NO_ANSWER = 19;
+    int CALL_REJECTED = 21;
+    int PRE_EMPTION = 25;
+    int NON_SELECTED_USER_CLEARING = 26;
+    int DESTINATION_OUT_OF_ORDER = 27;
+    int INVALID_NUMBER_FORMAT = 28;
+    int FACILITY_REJECTED = 29;
+    int NETWORK_OUT_OF_ORDER = 38;
+    int ACCESS_INFORMATION_DISCARDED = 43;
+    int RESOURCE_UNAVAILABLE = 47;
+    int REQUESTED_FACILITY_NOT_SUBSCRIBED = 50;
+    int INCOMING_CALL_BARRED_WITHIN_CUG = 55;
+    int BEARER_NOT_AUTHORIZED = 57;
+    int SERVICE_NOT_AVAILABLE = 63;
+    int BEARER_NOT_IMPLEMENT = 65;
+    int FACILITY_NOT_IMPLEMENT = 69;
+    int RESTRICTED_BEARER_AVAILABLE = 70;
+    int OPTION_NOT_AVAILABLE = 79;
+    int INVALID_TRANSACTION_ID_VALUE = 81;
+    int USER_NOT_MEMBER_OF_CUG = 87;
+    int INCOMPATIBLE_DESTINATION = 88;
+    int INVALID_TRANSIT_NETWORK_SELECTION = 91;
+    int SEMANTICALLY_INCORRECT_MESSAGE = 95;
+    int INVALID_MANDATORY_INFORMATION = 96;
+    int MESSAGE_TYPE_NON_EXISTENT = 97;
+    int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE = 98;
+    int IE_NON_EXISTENT_OR_NOT_IMPLEMENTED = 99;
+    int CONDITIONAL_IE_ERROR = 100;
+    int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 101;
+    int RECOVERY_ON_TIMER_EXPIRY = 102;
+    int PROTOCOL_ERROR_UNSPECIFIED = 111;
+    int INTERWORKING_UNSPECIFIED = 127;
+    int IMEI_NOT_ACCEPTED = 243;
+    int CM_MM_RR_CONNECTION_RELEASE = 2165;
+    /// @}
+
+    /// M: IMS feature. @{
+    /* Normal call failed, need to dial as ECC */
+    int IMS_EMERGENCY_REREG = 380;
+    /// @}
+
+}
Index: vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaConnection.java
===================================================================
--- vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaConnection.java	(revision 0)
+++ vendor/branch/5058A_Telcel/frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaConnection.java	(revision 4004)
@@ -0,0 +1,1548 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PersistableBundle;
+import android.os.PowerManager;
+import android.os.Registrant;
+import android.os.SystemClock;
+import android.telephony.CarrierConfigManager;
+import android.telephony.DisconnectCause;
+import android.telephony.Rlog;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.ServiceState;
+import android.text.TextUtils;
+
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
+
+/// M: CC: GsmConnection OP07 Plugin for delay of postDialChar @{
+// [ALPS00330882]
+import android.os.SystemProperties;
+import com.mediatek.common.MPlugin;
+import com.mediatek.common.telephony.IGsmConnectionExt;
+/// @}
+
+/// M: CC: update isEmergency according to TeleService
+import android.os.RemoteException;
+import android.os.ServiceManager;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+
+/**
+ * {@hide}
+ */
+public class GsmCdmaConnection extends Connection {
+    private static final String LOG_TAG = "GsmCdmaConnection";
+    private static final String PROP_LOG_TAG = "GsmCdmaConn";
+    private static final boolean DBG = true;
+    /// M: Log optimization @{
+    //private static final boolean VDBG = false;
+    private static final boolean VDBG =
+            (android.os.SystemProperties.getInt("persist.log.tag.tel_dbg", 0) == 1);
+    /// @}
+
+    //***** Instance Variables
+
+    GsmCdmaCallTracker mOwner;
+    GsmCdmaCall mParent;
+
+    boolean mDisconnected;
+
+    public int mIndex;          // index in GsmCdmaCallTracker.connections[], -1 if unassigned
+                        // The GsmCdma index is 1 + this
+
+    /*
+     * These time/timespan values are based on System.currentTimeMillis(),
+     * i.e., "wall clock" time.
+     */
+    long mDisconnectTime;
+
+    UUSInfo mUusInfo;
+    int mPreciseCause = 0;
+    String mVendorCause;
+
+    /// M: CC: For 3G VT only @{
+    boolean mIsVideo;
+    /// @}
+
+    Connection mOrigConnection;
+
+    Handler mHandler;
+
+    private PowerManager.WakeLock mPartialWakeLock;
+
+    private boolean mIsEmergencyCall = false;
+
+    // The cached delay to be used between DTMF tones fetched from carrier config.
+    private int mDtmfToneDelay = 0;
+
+    /// M: CDMA process call accepted @{
+    private static final int MO_CALL_VIBRATE_TIME = 200;  // msec
+    private boolean mIsRealConnected; // Indicate if the MO call has been accepted by remote side
+    private boolean mReceivedAccepted; // Indicate if we receive call accepted event
+    /// @}
+
+    //***** Event Constants
+    static final int EVENT_DTMF_DONE = 1;
+    static final int EVENT_PAUSE_DONE = 2;
+    static final int EVENT_NEXT_POST_DIAL = 3;
+    static final int EVENT_WAKE_LOCK_TIMEOUT = 4;
+    static final int EVENT_DTMF_DELAY_DONE = 5;
+
+    //***** Constants
+    static final int PAUSE_DELAY_MILLIS_GSM = 3 * 1000;
+    static final int PAUSE_DELAY_MILLIS_CDMA = 2 * 1000;
+    static final int WAKE_LOCK_TIMEOUT_MILLIS = 60*1000;
+
+    /// M: CC: GsmConnection OP07 Plugin for delay of postDialChar
+    // [ALPS00330882]
+    static final int PAUSE_DELAY_FIRST_MILLIS_GSM = 500;
+
+    /// M: CC: Vzw/CTVolte ECC @{
+    TelephonyDevController mTelDevController = TelephonyDevController.getInstance();
+
+    private boolean hasC2kOverImsModem() {
+        if (mTelDevController != null && mTelDevController.getModem(0) != null &&
+                mTelDevController.getModem(0).hasC2kOverImsModem() == true) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+
+    //***** Inner Classes
+
+    class MyHandler extends Handler {
+        MyHandler(Looper l) {super(l);}
+
+        @Override
+        public void
+        handleMessage(Message msg) {
+
+            switch (msg.what) {
+                case EVENT_NEXT_POST_DIAL:
+                case EVENT_DTMF_DELAY_DONE:
+                case EVENT_PAUSE_DONE:
+                    processNextPostDialChar();
+                    break;
+                case EVENT_WAKE_LOCK_TIMEOUT:
+                    releaseWakeLock();
+                    break;
+                case EVENT_DTMF_DONE:
+                    // We may need to add a delay specified by carrier between DTMF tones that are
+                    // sent out.
+                    mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_DTMF_DELAY_DONE),
+                            mDtmfToneDelay);
+                    break;
+            }
+        }
+    }
+
+    //***** Constructors
+
+    /** This is probably an MT call that we first saw in a CLCC response or a hand over. */
+    public GsmCdmaConnection (GsmCdmaPhone phone, DriverCall dc, GsmCdmaCallTracker ct, int index) {
+        super(phone.getPhoneType());
+        createWakeLock(phone.getContext());
+        acquireWakeLock();
+
+        mOwner = ct;
+        mHandler = new MyHandler(mOwner.getLooper());
+
+        mAddress = dc.number;
+
+        // M: CC: For 93, MD can switch phoneType when SIM not inserted,
+        // TeleService won't trigger phone switch, so check both SIM's ECC
+        //mIsEmergencyCall = PhoneNumberUtils.isLocalEmergencyNumber(phone.getContext(), mAddress);
+        if (hasC2kOverImsModem() &&
+                !android.telephony.TelephonyManager.getDefault().hasIccCard(phone.getPhoneId())) {
+            mIsEmergencyCall = PhoneNumberUtils.isLocalEmergencyNumber(
+                    phone.getContext(), mAddress);
+        } else {
+            mIsEmergencyCall = PhoneNumberUtils.isLocalEmergencyNumber(
+                    phone.getContext(), phone.getSubId(), mAddress);
+        }
+
+        mIsIncoming = dc.isMT;
+        mCreateTime = System.currentTimeMillis();
+        mCnapName = dc.name;
+        mCnapNamePresentation = dc.namePresentation;
+        mNumberPresentation = dc.numberPresentation;
+        mUusInfo = dc.uusInfo;
+
+        mIndex = index;
+
+        /// M: CC: For 3G VT only @{
+        mIsVideo = dc.isVideo;
+        /// @}
+
+        mParent = parentFromDCState(dc.state);
+        mParent.attach(this, dc);
+
+        fetchDtmfToneDelay(phone);
+    }
+
+    /** This is an MO call, created when dialing */
+    public GsmCdmaConnection (GsmCdmaPhone phone, String dialString, GsmCdmaCallTracker ct,
+                              GsmCdmaCall parent, boolean isEmergencyCall) {
+        super(phone.getPhoneType());
+        createWakeLock(phone.getContext());
+        acquireWakeLock();
+
+        mOwner = ct;
+        mHandler = new MyHandler(mOwner.getLooper());
+
+        if (isPhoneTypeGsm()) {
+            mDialString = dialString;
+        } else {
+            Rlog.d(LOG_TAG, "[GsmCdmaConn] GsmCdmaConnection: dialString=" +
+                    maskDialString(dialString));
+            dialString = formatDialString(dialString);
+            Rlog.d(LOG_TAG,
+                    "[GsmCdmaConn] GsmCdmaConnection:formated dialString=" +
+                            maskDialString(dialString));
+        }
+
+        mAddress = PhoneNumberUtils.extractNetworkPortionAlt(dialString);
+        mIsEmergencyCall = isEmergencyCall;
+        mPostDialString = PhoneNumberUtils.extractPostDialPortion(dialString);
+
+        mIndex = -1;
+
+        mIsIncoming = false;
+        mCnapName = null;
+        mCnapNamePresentation = PhoneConstants.PRESENTATION_ALLOWED;
+        mNumberPresentation = PhoneConstants.PRESENTATION_ALLOWED;
+        mCreateTime = System.currentTimeMillis();
+
+        if (parent != null) {
+            mParent = parent;
+            if (isPhoneTypeGsm()) {
+                parent.attachFake(this, GsmCdmaCall.State.DIALING);
+            } else {
+                //for the three way call case, not change parent state
+                if (parent.mState == GsmCdmaCall.State.ACTIVE) {
+                    parent.attachFake(this, GsmCdmaCall.State.ACTIVE);
+                } else {
+                    parent.attachFake(this, GsmCdmaCall.State.DIALING);
+                }
+
+            }
+        }
+
+        fetchDtmfToneDelay(phone);
+
+        /// M: CDMA process call accepted @{
+        mIsRealConnected = false;
+        mReceivedAccepted = false;
+        /// @}
+    }
+
+    //CDMA
+    /** This is a Call waiting call*/
+    public GsmCdmaConnection(Context context, CdmaCallWaitingNotification cw, GsmCdmaCallTracker ct,
+                             GsmCdmaCall parent) {
+        super(parent.getPhone().getPhoneType());
+        createWakeLock(context);
+        acquireWakeLock();
+
+        mOwner = ct;
+        mHandler = new MyHandler(mOwner.getLooper());
+        mAddress = cw.number;
+        mNumberPresentation = cw.numberPresentation;
+        mCnapName = cw.name;
+        mCnapNamePresentation = cw.namePresentation;
+        mIndex = -1;
+        mIsIncoming = true;
+        mCreateTime = System.currentTimeMillis();
+        mConnectTime = 0;
+        mParent = parent;
+        parent.attachFake(this, GsmCdmaCall.State.WAITING);
+    }
+
+
+    public void dispose() {
+        clearPostDialListeners();
+        if (mParent != null) {
+            mParent.detach(this);
+        }
+        releaseAllWakeLocks();
+    }
+
+    static boolean
+    equalsHandlesNulls (Object a, Object b) {
+        return (a == null) ? (b == null) : a.equals (b);
+    }
+
+    //CDMA
+    /**
+     * format original dial string
+     * 1) convert international dialing prefix "+" to
+     *    string specified per region
+     *
+     * 2) handle corner cases for PAUSE/WAIT dialing:
+     *
+     *    If PAUSE/WAIT sequence at the end, ignore them.
+     *
+     *    If consecutive PAUSE/WAIT sequence in the middle of the string,
+     *    and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
+     */
+    public static String formatDialString(String phoneNumber) {
+        /**
+         * TODO(cleanup): This function should move to PhoneNumberUtils, and
+         * tests should be added.
+         */
+
+        if (phoneNumber == null) {
+            return null;
+        }
+        int length = phoneNumber.length();
+        StringBuilder ret = new StringBuilder();
+        char c;
+        int currIndex = 0;
+
+        while (currIndex < length) {
+            c = phoneNumber.charAt(currIndex);
+            if (isPause(c) || isWait(c)) {
+                if (currIndex < length - 1) {
+                    // if PW not at the end
+                    int nextIndex = findNextPCharOrNonPOrNonWCharIndex(phoneNumber, currIndex);
+                    // If there is non PW char following PW sequence
+                    if (nextIndex < length) {
+                        char pC = findPOrWCharToAppend(phoneNumber, currIndex, nextIndex);
+                        ret.append(pC);
+                        // If PW char sequence has more than 2 PW characters,
+                        // skip to the last PW character since the sequence already be
+                        // converted to WAIT character
+                        if (nextIndex > (currIndex + 1)) {
+                            currIndex = nextIndex - 1;
+                        }
+                    } else if (nextIndex == length) {
+                        // It means PW characters at the end, ignore
+                        currIndex = length - 1;
+                    }
+                }
+            } else {
+                ret.append(c);
+            }
+            currIndex++;
+        }
+        return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
+    }
+
+    /*package*/ boolean
+    compareTo(DriverCall c) {
+        // On mobile originated (MO) calls, the phone number may have changed
+        // due to a SIM Toolkit call control modification.
+        //
+        // We assume we know when MO calls are created (since we created them)
+        // and therefore don't need to compare the phone number anyway.
+        if (! (mIsIncoming || c.isMT)) return true;
+
+        // A new call appearing by SRVCC may have invalid number
+        //  if IMS service is not tightly coupled with cellular modem stack.
+        // Thus we prefer the preexisting handover connection instance.
+        if (isPhoneTypeGsm() && mOrigConnection != null) return true;
+
+        // ... but we can compare phone numbers on MT calls, and we have
+        // no control over when they begin, so we might as well
+
+        String cAddress = PhoneNumberUtils.stringFromStringAndTOA(c.number, c.TOA);
+        return mIsIncoming == c.isMT && equalsHandlesNulls(mAddress, cAddress);
+    }
+
+    @Override
+    public String getOrigDialString(){
+        return mDialString;
+    }
+
+    @Override
+    public GsmCdmaCall getCall() {
+        return mParent;
+    }
+
+    @Override
+    public long getDisconnectTime() {
+        return mDisconnectTime;
+    }
+
+    @Override
+    public long getHoldDurationMillis() {
+        if (getState() != GsmCdmaCall.State.HOLDING) {
+            // If not holding, return 0
+            return 0;
+        } else {
+            return SystemClock.elapsedRealtime() - mHoldingStartTime;
+        }
+    }
+
+    @Override
+    public GsmCdmaCall.State getState() {
+        if (mDisconnected) {
+            return GsmCdmaCall.State.DISCONNECTED;
+        } else {
+            return super.getState();
+        }
+    }
+
+    @Override
+    public void hangup() throws CallStateException {
+        if (!mDisconnected) {
+            mOwner.hangup(this);
+        } else {
+            throw new CallStateException ("disconnected");
+        }
+    }
+
+    @Override
+    public void separate() throws CallStateException {
+        if (!mDisconnected) {
+            mOwner.separate(this);
+        } else {
+            throw new CallStateException ("disconnected");
+        }
+    }
+
+    @Override
+    public void proceedAfterWaitChar() {
+        if (mPostDialState != PostDialState.WAIT) {
+            Rlog.w(LOG_TAG, "GsmCdmaConnection.proceedAfterWaitChar(): Expected "
+                    + "getPostDialState() to be WAIT but was " + mPostDialState);
+            return;
+        }
+
+        setPostDialState(PostDialState.STARTED);
+
+        processNextPostDialChar();
+    }
+
+    @Override
+    public void proceedAfterWildChar(String str) {
+        if (mPostDialState != PostDialState.WILD) {
+            Rlog.w(LOG_TAG, "GsmCdmaConnection.proceedAfterWaitChar(): Expected "
+                + "getPostDialState() to be WILD but was " + mPostDialState);
+            return;
+        }
+
+        setPostDialState(PostDialState.STARTED);
+
+        // make a new postDialString, with the wild char replacement string
+        // at the beginning, followed by the remaining postDialString.
+
+        StringBuilder buf = new StringBuilder(str);
+        buf.append(mPostDialString.substring(mNextPostDialChar));
+        mPostDialString = buf.toString();
+        mNextPostDialChar = 0;
+        if (Phone.DEBUG_PHONE) {
+            log("proceedAfterWildChar: new postDialString is " +
+                    mPostDialString);
+        }
+
+        processNextPostDialChar();
+    }
+
+    @Override
+    public void cancelPostDial() {
+        setPostDialState(PostDialState.CANCELLED);
+    }
+
+    /**
+     * Called when this Connection is being hung up locally (eg, user pressed "end")
+     * Note that at this point, the hangup request has been dispatched to the radio
+     * but no response has yet been received so update() has not yet been called
+     */
+    void
+    onHangupLocal() {
+        mCause = DisconnectCause.LOCAL;
+        mPreciseCause = 0;
+        mVendorCause = null;
+    }
+
+    /**
+     * Maps RIL call disconnect code to {@link DisconnectCause}.
+     * @param causeCode RIL disconnect code
+     * @return the corresponding value from {@link DisconnectCause}
+     */
+    int disconnectCauseFromCode(int causeCode) {
+        /**
+         * See 22.001 Annex F.4 for mapping of cause codes
+         * to local tones
+         */
+
+        switch (causeCode) {
+            case CallFailCause.USER_BUSY:
+                return DisconnectCause.BUSY;
+
+            case CallFailCause.NO_CIRCUIT_AVAIL:
+            case CallFailCause.TEMPORARY_FAILURE:
+            case CallFailCause.SWITCHING_CONGESTION:
+            case CallFailCause.CHANNEL_NOT_AVAIL:
+            case CallFailCause.QOS_NOT_AVAIL:
+            case CallFailCause.BEARER_NOT_AVAIL:
+                return DisconnectCause.CONGESTION;
+
+            case CallFailCause.ACM_LIMIT_EXCEEDED:
+                return DisconnectCause.LIMIT_EXCEEDED;
+
+            case CallFailCause.CALL_BARRED:
+                return DisconnectCause.CALL_BARRED;
+
+            case CallFailCause.FDN_BLOCKED:
+                return DisconnectCause.FDN_BLOCKED;
+
+            case CallFailCause.UNOBTAINABLE_NUMBER:
+                return DisconnectCause.UNOBTAINABLE_NUMBER;
+
+            case CallFailCause.DIAL_MODIFIED_TO_USSD:
+                return DisconnectCause.DIAL_MODIFIED_TO_USSD;
+
+            case CallFailCause.DIAL_MODIFIED_TO_SS:
+                return DisconnectCause.DIAL_MODIFIED_TO_SS;
+
+            case CallFailCause.DIAL_MODIFIED_TO_DIAL:
+                return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
+
+            case CallFailCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
+                return DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE;
+
+            case CallFailCause.CDMA_DROP:
+                return DisconnectCause.CDMA_DROP;
+
+            case CallFailCause.CDMA_INTERCEPT:
+                return DisconnectCause.CDMA_INTERCEPT;
+
+            case CallFailCause.CDMA_REORDER:
+                return DisconnectCause.CDMA_REORDER;
+
+            case CallFailCause.CDMA_SO_REJECT:
+                return DisconnectCause.CDMA_SO_REJECT;
+
+            case CallFailCause.CDMA_RETRY_ORDER:
+                return DisconnectCause.CDMA_RETRY_ORDER;
+
+            case CallFailCause.CDMA_ACCESS_FAILURE:
+                return DisconnectCause.CDMA_ACCESS_FAILURE;
+
+            case CallFailCause.CDMA_PREEMPTED:
+                return DisconnectCause.CDMA_PREEMPTED;
+
+            case CallFailCause.CDMA_NOT_EMERGENCY:
+                return DisconnectCause.CDMA_NOT_EMERGENCY;
+
+            case CallFailCause.CDMA_ACCESS_BLOCKED:
+                return DisconnectCause.CDMA_ACCESS_BLOCKED;
+
+            /// M: CC: Extend Call Fail Cause @{
+            case CallFailCause.NO_ROUTE_TO_DESTINATION:
+                return DisconnectCause.NO_ROUTE_TO_DESTINATION;
+
+            case CallFailCause.NO_USER_RESPONDING:
+                return DisconnectCause.NO_USER_RESPONDING;
+
+            /**
+             * Google default behavior:
+             * Return DisconnectCause.ERROR_UNSPECIFIED to avoid UNKNOWN cause in inCallUI,
+             * which will add 5s delay, instead of 2s delay for ERROR cause
+             * USER_ALERTING_NO_ANSWER(+CEER: 19)
+             */
+            //case CallFailCause.USER_ALERTING_NO_ANSWER:
+            //    return DisconnectCause.USER_ALERTING_NO_ANSWER;
+
+            /**
+             * Google default behavior:
+             * Return DisconnectCause.ERROR_UNSPECIFIED to play TONE_CALL_ENDED for
+             * CALL_REJECTED(+CEER: 21) and NORMAL_UNSPECIFIED(+CEER: 31)
+             */
+            //case CallFailCause.CALL_REJECTED:
+            //    return DisconnectCause.CALL_REJECTED;
+
+            //case CallFailCause.NORMAL_UNSPECIFIED:
+            //    return DisconnectCause.NORMAL_UNSPECIFIED;
+
+            case CallFailCause.INVALID_NUMBER_FORMAT:
+                return DisconnectCause.INVALID_NUMBER_FORMAT;
+
+            case CallFailCause.FACILITY_REJECTED:
+                return DisconnectCause.FACILITY_REJECTED;
+
+            case CallFailCause.RESOURCE_UNAVAILABLE:
+                return DisconnectCause.RESOURCE_UNAVAILABLE;
+
+            case CallFailCause.BEARER_NOT_AUTHORIZED:
+                return DisconnectCause.BEARER_NOT_AUTHORIZED;
+
+            case CallFailCause.SERVICE_NOT_AVAILABLE:
+
+            case CallFailCause.NETWORK_OUT_OF_ORDER:
+                return DisconnectCause.SERVICE_NOT_AVAILABLE;
+
+            case CallFailCause.BEARER_NOT_IMPLEMENT:
+                return DisconnectCause.BEARER_NOT_IMPLEMENT;
+
+            case CallFailCause.FACILITY_NOT_IMPLEMENT:
+                return DisconnectCause.FACILITY_NOT_IMPLEMENT;
+
+            case CallFailCause.RESTRICTED_BEARER_AVAILABLE:
+                return DisconnectCause.RESTRICTED_BEARER_AVAILABLE;
+
+            /**
+             * In China network, ECC server ends call with error cause CM_SER_OPT_UNIMPL(+CEER: 79)
+             * Return DisconnectCause.NORMAL to not trigger ECC retry
+             */
+            //case CallFailCause.OPTION_NOT_AVAILABLE:
+            //    return DisconnectCause.OPTION_NOT_AVAILABLE;
+
+            case CallFailCause.INCOMPATIBLE_DESTINATION:
+                return DisconnectCause.INCOMPATIBLE_DESTINATION;
+
+            case CallFailCause.CM_MM_RR_CONNECTION_RELEASE:
+                return DisconnectCause.CM_MM_RR_CONNECTION_RELEASE;
+
+            case CallFailCause.CHANNEL_UNACCEPTABLE:
+                return DisconnectCause.CHANNEL_UNACCEPTABLE;
+
+            case CallFailCause.OPERATOR_DETERMINED_BARRING:
+                return DisconnectCause.OPERATOR_DETERMINED_BARRING;
+
+            case CallFailCause.PRE_EMPTION:
+                return DisconnectCause.PRE_EMPTION;
+
+            case CallFailCause.NON_SELECTED_USER_CLEARING:
+                return DisconnectCause.NON_SELECTED_USER_CLEARING;
+
+            case CallFailCause.DESTINATION_OUT_OF_ORDER:
+                return DisconnectCause.DESTINATION_OUT_OF_ORDER;
+
+            case CallFailCause.ACCESS_INFORMATION_DISCARDED:
+                return DisconnectCause.ACCESS_INFORMATION_DISCARDED;
+
+            case CallFailCause.REQUESTED_FACILITY_NOT_SUBSCRIBED:
+                return DisconnectCause.REQUESTED_FACILITY_NOT_SUBSCRIBED;
+
+            case CallFailCause.INCOMING_CALL_BARRED_WITHIN_CUG:
+                return DisconnectCause.INCOMING_CALL_BARRED_WITHIN_CUG;
+
+            case CallFailCause.INVALID_TRANSACTION_ID_VALUE:
+                return DisconnectCause.INVALID_TRANSACTION_ID_VALUE;
+
+            case CallFailCause.USER_NOT_MEMBER_OF_CUG:
+                return DisconnectCause.USER_NOT_MEMBER_OF_CUG;
+
+            case CallFailCause.INVALID_TRANSIT_NETWORK_SELECTION:
+                return DisconnectCause.INVALID_TRANSIT_NETWORK_SELECTION;
+
+            case CallFailCause.SEMANTICALLY_INCORRECT_MESSAGE:
+                return DisconnectCause.SEMANTICALLY_INCORRECT_MESSAGE;
+
+            case CallFailCause.INVALID_MANDATORY_INFORMATION:
+                return DisconnectCause.INVALID_MANDATORY_INFORMATION;
+
+            case CallFailCause.MESSAGE_TYPE_NON_EXISTENT:
+                return DisconnectCause.MESSAGE_TYPE_NON_EXISTENT;
+
+            case CallFailCause.MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE:
+                return DisconnectCause.MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE;
+
+            case CallFailCause.IE_NON_EXISTENT_OR_NOT_IMPLEMENTED:
+                return DisconnectCause.IE_NON_EXISTENT_OR_NOT_IMPLEMENTED;
+
+            case CallFailCause.CONDITIONAL_IE_ERROR:
+                return DisconnectCause.CONDITIONAL_IE_ERROR;
+
+            case CallFailCause.MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
+                return DisconnectCause.MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
+
+            case CallFailCause.RECOVERY_ON_TIMER_EXPIRY:
+                return DisconnectCause.RECOVERY_ON_TIMER_EXPIRY;
+
+            case CallFailCause.PROTOCOL_ERROR_UNSPECIFIED:
+                return DisconnectCause.PROTOCOL_ERROR_UNSPECIFIED;
+
+            /**
+             * Google default behavior:
+             * Return DisconnectCause.ERROR_UNSPECIFIED to avoid UNKNOWN cause in inCallUI,
+             * which will add 5s delay, instead of 2s delay for ERROR cause
+             * INTERWORKING_UNSPECIFIED(+CEER: 127)
+             */
+            //case CallFailCause.INTERWORKING_UNSPECIFIED:
+            //    return DisconnectCause.INTERWORKING_UNSPECIFIED;
+
+            /// M: CC: ECC disconnection special handling @{
+            // Report DisconnectCause.NORMAL for IMEI_NOT_ACCEPTED
+            // For GCF test, ECC might be rejected and not trigger ECC retry in this case.
+            case CallFailCause.IMEI_NOT_ACCEPTED:
+                if (PhoneNumberUtils.isEmergencyNumber(getAddress())) {
+                    return DisconnectCause.NORMAL;
+                }
+            /// @}
+
+            case CallFailCause.ERROR_UNSPECIFIED:
+            case CallFailCause.NORMAL_CLEARING:
+            default:
+                GsmCdmaPhone phone = mOwner.getPhone();
+                int serviceState = phone.getServiceState().getState();
+                UiccCardApplication cardApp = phone.getUiccCardApplication();
+                AppState uiccAppState = (cardApp != null) ? cardApp.getState() :
+                    AppState.APPSTATE_UNKNOWN;
+
+                /// M: @{
+                proprietaryLog("disconnectCauseFromCode, causeCode:" + causeCode
+                        + ", cardApp:" + cardApp
+                        + ", serviceState:" + serviceState
+                        + ", uiccAppState:" + uiccAppState);
+                /// @}
+
+                if (serviceState == ServiceState.STATE_POWER_OFF) {
+                    return DisconnectCause.POWER_OFF;
+                }
+
+                /// M: CC: update isEmergency according to UI
+                // Number might become non-ECC after phone type switch or vice versa
+                // align mIsEmergencyCall according to TeleService state
+                if (hasC2kOverImsModem() && !mIsEmergencyCall) {
+                    ITelephonyEx telEx = ITelephonyEx.Stub.asInterface(
+                            ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+                    if (telEx != null) {
+                        try {
+                            mIsEmergencyCall = telEx.isEccInProgress();
+                        } catch (RemoteException e) {
+                            Rlog.e(PROP_LOG_TAG, "Exception of isEccInProgress");
+                        }
+                    }
+                }
+                /// @}
+
+                if (!mIsEmergencyCall) {
+                    // Only send OUT_OF_SERVICE if it is not an emergency call. We can still
+                    // technically be in STATE_OUT_OF_SERVICE or STATE_EMERGENCY_ONLY during
+                    // an emergency call and when it ends, we do not want to mistakenly generate
+                    // an OUT_OF_SERVICE disconnect cause during normal call ending.
+                    if ((serviceState == ServiceState.STATE_OUT_OF_SERVICE
+                            || serviceState == ServiceState.STATE_EMERGENCY_ONLY)) {
+                        return DisconnectCause.OUT_OF_SERVICE;
+                    }
+                    // If we are placing an emergency call and the SIM is currently PIN/PUK
+                    // locked the AppState will always not be equal to APPSTATE_READY.
+                    if (uiccAppState != AppState.APPSTATE_READY) {
+                        if (isPhoneTypeGsm()) {
+                            return DisconnectCause.ICC_ERROR;
+                        } else { // CDMA
+                            if (phone.mCdmaSubscriptionSource ==
+                                    CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM) {
+                                return DisconnectCause.ICC_ERROR;
+                            }
+                        }
+                    }
+                }
+                if (isPhoneTypeGsm()) {
+                    if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
+                        if (phone.mSST.mRestrictedState.isCsRestricted()) {
+                            return DisconnectCause.CS_RESTRICTED;
+                        } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
+                            return DisconnectCause.CS_RESTRICTED_EMERGENCY;
+                        } else if (phone.mSST.mRestrictedState.isCsNormalRestricted()) {
+                            return DisconnectCause.CS_RESTRICTED_NORMAL;
+                        }
+                    }
+                }
+                if (causeCode == CallFailCause.NORMAL_CLEARING) {
+                    return DisconnectCause.NORMAL;
+                }
+
+                /// M: CC: ECC disconnection special handling @{
+                // Report DisconnectCause.NORMAL for NORMAL_UNSPECIFIED
+                /**
+                 * Some network play in band information when ECC in DIALING state.
+                 * if ECC release from network, don't set to ERROR_UNSPECIFIED
+                 * to avoid Telecom retry dialing.
+                 */
+                if (mIsEmergencyCall) {
+                    if (causeCode == CallFailCause.NORMAL_UNSPECIFIED ||
+                            causeCode == CallFailCause.OPTION_NOT_AVAILABLE) {
+                        return DisconnectCause.NORMAL;
+                    }
+                }
+                /// @}
+
+                // If nothing else matches, report unknown call drop reason
+                // to app, not NORMAL call end.
+                return DisconnectCause.ERROR_UNSPECIFIED;
+        }
+    }
+
+    /*package*/ void
+    onRemoteDisconnect(int causeCode, String vendorCause) {
+        this.mPreciseCause = causeCode;
+        this.mVendorCause = vendorCause;
+        onDisconnect(disconnectCauseFromCode(causeCode));
+    }
+
+    /**
+     * Called when the radio indicates the connection has been disconnected.
+     * @param cause call disconnect cause; values are defined in {@link DisconnectCause}
+     */
+    @Override
+    public boolean onDisconnect(int cause) {
+        boolean changed = false;
+
+        mCause = cause;
+
+        if (!mDisconnected) {
+            doDisconnect();
+
+            if (DBG) Rlog.d(LOG_TAG, "onDisconnect: cause=" + cause);
+
+            mOwner.getPhone().notifyDisconnect(this);
+
+            if (mParent != null) {
+                changed = mParent.connectionDisconnected(this);
+            }
+
+            mOrigConnection = null;
+        }
+        clearPostDialListeners();
+        releaseWakeLock();
+        return changed;
+    }
+
+    //CDMA
+    /** Called when the call waiting connection has been hung up */
+    /*package*/ void
+    onLocalDisconnect() {
+        if (!mDisconnected) {
+            doDisconnect();
+            if (VDBG) Rlog.d(LOG_TAG, "onLoalDisconnect" );
+
+            if (mParent != null) {
+                mParent.detach(this);
+            }
+        }
+        releaseWakeLock();
+    }
+
+    // Returns true if state has changed, false if nothing changed
+    public boolean
+    update (DriverCall dc) {
+        GsmCdmaCall newParent;
+        boolean changed = false;
+        boolean wasConnectingInOrOut = isConnectingInOrOut();
+        boolean wasHolding = (getState() == GsmCdmaCall.State.HOLDING);
+
+        newParent = parentFromDCState(dc.state);
+
+        if (Phone.DEBUG_PHONE) log("parent= " +mParent +", newParent= " + newParent);
+
+        //Ignore dc.number and dc.name in case of a handover connection
+        if (isPhoneTypeGsm() && mOrigConnection != null) {
+            if (Phone.DEBUG_PHONE) log("update: mOrigConnection is not null");
+        } else {
+            log(" mNumberConverted " + mNumberConverted);
+            if (!equalsHandlesNulls(mAddress, dc.number) && (!mNumberConverted
+                    || !equalsHandlesNulls(mConvertedNumber, dc.number))) {
+                if (Phone.DEBUG_PHONE) log("update: phone # changed!");
+                mAddress = dc.number;
+                changed = true;
+            }
+        }
+
+        // A null cnapName should be the same as ""
+        if (TextUtils.isEmpty(dc.name)) {
+            /// M: CC: CLCC without name information handling @{
+            /* Name information is not updated by +CLCC, dc.name will be empty always,
+               so ignore the following statements */
+            //if (!TextUtils.isEmpty(mCnapName)) {
+            //    changed = true;
+            //    mCnapName = "";
+            //}
+            /// @}
+        } else if (!dc.name.equals(mCnapName)) {
+            changed = true;
+            mCnapName = dc.name;
+        }
+
+        if (Phone.DEBUG_PHONE) log("--dssds----"+mCnapName);
+        mCnapNamePresentation = dc.namePresentation;
+        mNumberPresentation = dc.numberPresentation;
+
+        /// M: CC: For 3G VT only @{
+        if (mIsVideo != dc.isVideo) {
+             mIsVideo = dc.isVideo;
+             changed = true;
+        }
+        /// @}
+
+        if (newParent != mParent) {
+            if (mParent != null) {
+                mParent.detach(this);
+            }
+            newParent.attach(this, dc);
+            mParent = newParent;
+            changed = true;
+        } else {
+            boolean parentStateChange;
+            parentStateChange = mParent.update (this, dc);
+            changed = changed || parentStateChange;
+        }
+
+        /** Some state-transition events */
+
+        if (Phone.DEBUG_PHONE) log(
+                "update: parent=" + mParent +
+                ", hasNewParent=" + (newParent != mParent) +
+                ", wasConnectingInOrOut=" + wasConnectingInOrOut +
+                ", wasHolding=" + wasHolding +
+                ", isConnectingInOrOut=" + isConnectingInOrOut() +
+                /// M: CC: For 3G VT only @{
+                ", isVideo=" + mIsVideo +
+                /// @}
+                ", changed=" + changed);
+
+
+        if (wasConnectingInOrOut && !isConnectingInOrOut()) {
+            onConnectedInOrOut();
+        }
+
+        if (changed && !wasHolding && (getState() == GsmCdmaCall.State.HOLDING)) {
+            // We've transitioned into HOLDING
+            onStartedHolding();
+        }
+
+        /// M: CDMA process call accepted @{
+        if (!isPhoneTypeGsm()) {
+            proprietaryLog("state:" + getState() + ", mReceivedAccepted:" + mReceivedAccepted);
+            if (getState() == GsmCdmaCall.State.ACTIVE && mReceivedAccepted) {
+                if (onCdmaCallAccept()) {
+                    mOwner.mPhone.notifyCdmaCallAccepted();
+                }
+                mReceivedAccepted = false;
+            }
+        }
+        /// @}
+
+        return changed;
+    }
+
+    /**
+     * Called when this Connection is in the foregroundCall
+     * when a dial is initiated.
+     * We know we're ACTIVE, and we know we're going to end up
+     * HOLDING in the backgroundCall
+     */
+    void
+    fakeHoldBeforeDial() {
+        if (mParent != null) {
+            mParent.detach(this);
+        }
+
+        mParent = mOwner.mBackgroundCall;
+        mParent.attachFake(this, GsmCdmaCall.State.HOLDING);
+
+        onStartedHolding();
+    }
+
+    /// M: CC: Proprietary CRSS handling @{
+    /**
+     * Called when this Connection is fail to enter backgroundCall,
+     * because we switch fail.
+     * (We thinkwe're going to end upHOLDING in the backgroundCall when dial is initiated)
+     */
+    void
+    resumeHoldAfterDialFailed() {
+        if (mParent != null) {
+            mParent.detach(this);
+        }
+
+        mParent = mOwner.mForegroundCall;
+        mParent.attachFake(this, GsmCdmaCall.State.ACTIVE);
+    }
+    /// @}
+
+    /*package*/public int
+    getGsmCdmaIndex() throws CallStateException {
+        if (mIndex >= 0) {
+            return mIndex + 1;
+        } else {
+            throw new CallStateException ("GsmCdma index not yet assigned");
+        }
+    }
+
+    /**
+     * An incoming or outgoing call has connected
+     */
+    void
+    onConnectedInOrOut() {
+        mConnectTime = System.currentTimeMillis();
+        mConnectTimeReal = SystemClock.elapsedRealtime();
+        mDuration = 0;
+
+        // bug #678474: incoming call interpreted as missed call, even though
+        // it sounds like the user has picked up the call.
+        if (Phone.DEBUG_PHONE) {
+            log("onConnectedInOrOut: connectTime=" + mConnectTime);
+        }
+
+        if (!mIsIncoming) {
+            // outgoing calls only
+            /// M: CDMA process call accepted @{
+            if (isPhoneTypeGsm()) {
+                processNextPostDialChar();
+            } else {
+                // send DTMF when the CDMA call is really accepted.
+                int count = mParent.mConnections.size();
+                proprietaryLog("mParent.mConnections.size():" + count);
+                if (!isInChina() && !mIsRealConnected && count == 1) {
+                    mIsRealConnected = true;
+                    processNextPostDialChar();
+                    vibrateForAccepted();
+                    mOwner.mPhone.notifyCdmaCallAccepted();
+                }
+                if (count > 1) {
+                    mIsRealConnected = true;
+                    processNextPostDialChar();
+                }
+            }
+            /// @}
+        } else {
+            // Only release wake lock for incoming calls, for outgoing calls the wake lock
+            // will be released after any pause-dial is completed
+            releaseWakeLock();
+        }
+    }
+
+    private void
+    doDisconnect() {
+        mIndex = -1;
+        mDisconnectTime = System.currentTimeMillis();
+        mDuration = SystemClock.elapsedRealtime() - mConnectTimeReal;
+        mDisconnected = true;
+        clearPostDialListeners();
+    }
+
+    /*package*/ void
+    onStartedHolding() {
+        mHoldingStartTime = SystemClock.elapsedRealtime();
+    }
+
+    /**
+     * Performs the appropriate action for a post-dial char, but does not
+     * notify application. returns false if the character is invalid and
+     * should be ignored
+     */
+    private boolean
+    processPostDialChar(char c) {
+        if (PhoneNumberUtils.is12Key(c)) {
+            mOwner.mCi.sendDtmf(c, mHandler.obtainMessage(EVENT_DTMF_DONE));
+        } else if (isPause(c)) {
+            if (!isPhoneTypeGsm()) {
+                setPostDialState(PostDialState.PAUSE);
+            }
+            // From TS 22.101:
+            // It continues...
+            // Upon the called party answering the UE shall send the DTMF digits
+            // automatically to the network after a delay of 3 seconds( 20 ).
+            // The digits shall be sent according to the procedures and timing
+            // specified in 3GPP TS 24.008 [13]. The first occurrence of the
+            // "DTMF Control Digits Separator" shall be used by the ME to
+            // distinguish between the addressing digits (i.e. the phone number)
+            // and the DTMF digits. Upon subsequent occurrences of the
+            // separator,
+            // the UE shall pause again for 3 seconds ( 20 ) before sending
+            // any further DTMF digits.
+            /// M: CC: GsmConnection OP07 Plugin for delay of postDialChar @{
+            // [ALPS00330882]
+            // ADAPT test case.
+            //mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PAUSE_DONE),
+            //        isPhoneTypeGsm() ? PAUSE_DELAY_MILLIS_GSM: PAUSE_DELAY_MILLIS_CDMA);
+            if (isPhoneTypeGsm()) {
+                if (mNextPostDialChar == 1 &&
+                        !(SystemProperties.get("ro.mtk_bsp_package").equals("1"))) {
+                    // The first occurrence.
+                    // We don't need to pause here, but wait for just a bit anyway
+                    try {
+                        IGsmConnectionExt mGsmConnectionExt = MPlugin.createInstance(
+                                IGsmConnectionExt.class.getName(), mOwner.mPhone.getContext());
+                        if (mGsmConnectionExt != null) {
+                            mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PAUSE_DONE),
+                                    mGsmConnectionExt.getFirstPauseDelayMSeconds(
+                                    PAUSE_DELAY_FIRST_MILLIS_GSM));
+                        } else {
+                            Rlog.e(PROP_LOG_TAG, "Fail to initialize IGsmConnectionExt");
+                        }
+                    } catch (Exception e) {
+                        Rlog.e(PROP_LOG_TAG, "Fail to create plug-in");
+                        e.printStackTrace();
+                    }
+                } else {
+                    // the UE shall pause again for 3 seconds ( 20 ) before sending
+                    // any further DTMF digits.
+                    mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PAUSE_DONE),
+                            PAUSE_DELAY_MILLIS_GSM);
+                }
+            } else {
+                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PAUSE_DONE),
+                        PAUSE_DELAY_MILLIS_CDMA);
+            }
+            /// @}
+        } else if (isWait(c)) {
+            setPostDialState(PostDialState.WAIT);
+        } else if (isWild(c)) {
+            setPostDialState(PostDialState.WILD);
+        } else {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public String
+    getRemainingPostDialString() {
+        String subStr = super.getRemainingPostDialString();
+        if (!isPhoneTypeGsm() && !TextUtils.isEmpty(subStr)) {
+            int wIndex = subStr.indexOf(PhoneNumberUtils.WAIT);
+            int pIndex = subStr.indexOf(PhoneNumberUtils.PAUSE);
+
+            if (wIndex > 0 && (wIndex < pIndex || pIndex <= 0)) {
+                subStr = subStr.substring(0, wIndex);
+            } else if (pIndex > 0) {
+                subStr = subStr.substring(0, pIndex);
+            }
+        }
+        return subStr;
+    }
+
+    //CDMA
+    public void updateParent(GsmCdmaCall oldParent, GsmCdmaCall newParent){
+        if (newParent != oldParent) {
+            if (oldParent != null) {
+                oldParent.detach(this);
+            }
+            newParent.attachFake(this, GsmCdmaCall.State.ACTIVE);
+            mParent = newParent;
+        }
+    }
+
+    @Override
+    protected void finalize()
+    {
+        /**
+         * It is understood that This finializer is not guaranteed
+         * to be called and the release lock call is here just in
+         * case there is some path that doesn't call onDisconnect
+         * and or onConnectedInOrOut.
+         */
+        if (mPartialWakeLock.isHeld()) {
+            Rlog.e(LOG_TAG, "[GsmCdmaConn] UNEXPECTED; mPartialWakeLock is held when finalizing.");
+        }
+        clearPostDialListeners();
+        releaseWakeLock();
+    }
+
+    private void
+    processNextPostDialChar() {
+        char c = 0;
+        Registrant postDialHandler;
+
+        if (mPostDialState == PostDialState.CANCELLED) {
+            releaseWakeLock();
+            return;
+        }
+
+        if (mPostDialString == null ||
+                mPostDialString.length() <= mNextPostDialChar ||
+                /// M: CC: DTMF request special handling @{
+                // Stop processNextPostDialChar when conn is disconnected
+                mDisconnected == true) {
+                /// @}
+            setPostDialState(PostDialState.COMPLETE);
+
+            // We were holding a wake lock until pause-dial was complete, so give it up now
+            releaseWakeLock();
+
+            // notifyMessage.arg1 is 0 on complete
+            c = 0;
+        } else {
+            boolean isValid;
+
+            setPostDialState(PostDialState.STARTED);
+
+            c = mPostDialString.charAt(mNextPostDialChar++);
+
+            isValid = processPostDialChar(c);
+
+            if (!isValid) {
+                // Will call processNextPostDialChar
+                mHandler.obtainMessage(EVENT_NEXT_POST_DIAL).sendToTarget();
+                // Don't notify application
+                Rlog.e(LOG_TAG, "processNextPostDialChar: c=" + c + " isn't valid!");
+                return;
+            }
+        }
+
+        notifyPostDialListenersNextChar(c);
+
+        // TODO: remove the following code since the handler no longer executes anything.
+        postDialHandler = mOwner.getPhone().getPostDialHandler();
+
+        Message notifyMessage;
+
+        if (postDialHandler != null
+                && (notifyMessage = postDialHandler.messageForRegistrant()) != null) {
+            // The AsyncResult.result is the Connection object
+            PostDialState state = mPostDialState;
+            AsyncResult ar = AsyncResult.forMessage(notifyMessage);
+            ar.result = this;
+            ar.userObj = state;
+
+            // arg1 is the character that was/is being processed
+            notifyMessage.arg1 = c;
+
+            //Rlog.v("GsmCdma", "##### processNextPostDialChar: send msg to postDialHandler, arg1=" + c);
+            notifyMessage.sendToTarget();
+        }
+    }
+
+    /** "connecting" means "has never been ACTIVE" for both incoming
+     *  and outgoing calls
+     */
+    private boolean
+    isConnectingInOrOut() {
+        return mParent == null || mParent == mOwner.mRingingCall
+            || mParent.mState == GsmCdmaCall.State.DIALING
+            || mParent.mState == GsmCdmaCall.State.ALERTING;
+    }
+
+    private GsmCdmaCall
+    parentFromDCState (DriverCall.State state) {
+        switch (state) {
+            case ACTIVE:
+            case DIALING:
+            case ALERTING:
+                return mOwner.mForegroundCall;
+            //break;
+
+            case HOLDING:
+                return mOwner.mBackgroundCall;
+            //break;
+
+            case INCOMING:
+            case WAITING:
+                return mOwner.mRingingCall;
+            //break;
+
+            default:
+                throw new RuntimeException("illegal call state: " + state);
+        }
+    }
+
+    /**
+     * Set post dial state and acquire wake lock while switching to "started" or "pause"
+     * state, the wake lock will be released if state switches out of "started" or "pause"
+     * state or after WAKE_LOCK_TIMEOUT_MILLIS.
+     * @param s new PostDialState
+     */
+    private void setPostDialState(PostDialState s) {
+        if (s == PostDialState.STARTED ||
+                s == PostDialState.PAUSE) {
+            synchronized (mPartialWakeLock) {
+                if (mPartialWakeLock.isHeld()) {
+                    mHandler.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+                } else {
+                    acquireWakeLock();
+                }
+                Message msg = mHandler.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
+                mHandler.sendMessageDelayed(msg, WAKE_LOCK_TIMEOUT_MILLIS);
+            }
+        } else {
+            mHandler.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            releaseWakeLock();
+        }
+        mPostDialState = s;
+        notifyPostDialListeners();
+    }
+
+    private void
+    createWakeLock(Context context) {
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        mPartialWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+    }
+
+    private void
+    acquireWakeLock() {
+        log("acquireWakeLock, " + hashCode());
+        mPartialWakeLock.acquire();
+    }
+
+    private void
+    releaseWakeLock() {
+        synchronized(mPartialWakeLock) {
+            if (mPartialWakeLock.isHeld()) {
+                log("releaseWakeLock, " + hashCode());
+                mPartialWakeLock.release();
+            }
+        }
+    }
+
+    private void
+    releaseAllWakeLocks() {
+        synchronized(mPartialWakeLock) {
+            while (mPartialWakeLock.isHeld()) {
+                mPartialWakeLock.release();
+            }
+        }
+    }
+
+    private static boolean isPause(char c) {
+        return c == PhoneNumberUtils.PAUSE;
+    }
+
+    private static boolean isWait(char c) {
+        return c == PhoneNumberUtils.WAIT;
+    }
+
+    private static boolean isWild(char c) {
+        return c == PhoneNumberUtils.WILD;
+    }
+
+    //CDMA
+    // This function is to find the next PAUSE character index if
+    // multiple pauses in a row. Otherwise it finds the next non PAUSE or
+    // non WAIT character index.
+    private static int
+    findNextPCharOrNonPOrNonWCharIndex(String phoneNumber, int currIndex) {
+        boolean wMatched = isWait(phoneNumber.charAt(currIndex));
+        int index = currIndex + 1;
+        int length = phoneNumber.length();
+        while (index < length) {
+            char cNext = phoneNumber.charAt(index);
+            // if there is any W inside P/W sequence,mark it
+            if (isWait(cNext)) {
+                wMatched = true;
+            }
+            // if any characters other than P/W chars after P/W sequence
+            // we break out the loop and append the correct
+            if (!isWait(cNext) && !isPause(cNext)) {
+                break;
+            }
+            index++;
+        }
+
+        // It means the PAUSE character(s) is in the middle of dial string
+        // and it needs to be handled one by one.
+        if ((index < length) && (index > (currIndex + 1))  &&
+                ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
+            return (currIndex + 1);
+        }
+        return index;
+    }
+
+    //CDMA
+    // This function returns either PAUSE or WAIT character to append.
+    // It is based on the next non PAUSE/WAIT character in the phoneNumber and the
+    // index for the current PAUSE/WAIT character
+    private static char
+    findPOrWCharToAppend(String phoneNumber, int currPwIndex, int nextNonPwCharIndex) {
+        char c = phoneNumber.charAt(currPwIndex);
+        char ret;
+
+        // Append the PW char
+        ret = (isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
+
+        // If the nextNonPwCharIndex is greater than currPwIndex + 1,
+        // it means the PW sequence contains not only P characters.
+        // Since for the sequence that only contains P character,
+        // the P character is handled one by one, the nextNonPwCharIndex
+        // equals to currPwIndex + 1.
+        // In this case, skip P, append W.
+        if (nextNonPwCharIndex > (currPwIndex + 1)) {
+            ret = PhoneNumberUtils.WAIT;
+        }
+        return ret;
+    }
+
+    private String maskDialString(String dialString) {
+        if (VDBG) {
+            return dialString;
+        }
+
+        return "<MASKED>";
+    }
+
+    private void fetchDtmfToneDelay(GsmCdmaPhone phone) {
+        CarrierConfigManager configMgr = (CarrierConfigManager)
+                phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        PersistableBundle b = configMgr.getConfigForSubId(phone.getSubId());
+        if (b != null) {
+            mDtmfToneDelay = b.getInt(phone.getDtmfToneDelayKey());
+        }
+    }
+
+    private boolean isPhoneTypeGsm() {
+        return mOwner.getPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_GSM;
+    }
+
+    private void log(String msg) {
+        Rlog.d(LOG_TAG, "[GsmCdmaConn] " + msg);
+    }
+
+    @Override
+    public int getNumberPresentation() {
+        return mNumberPresentation;
+    }
+
+    @Override
+    public UUSInfo getUUSInfo() {
+        return mUusInfo;
+    }
+
+    public int getPreciseDisconnectCause() {
+        return mPreciseCause;
+    }
+
+    @Override
+    public String getVendorDisconnectCause() {
+        return mVendorCause;
+    }
+
+    @Override
+    public void migrateFrom(Connection c) {
+        if (c == null) return;
+
+        super.migrateFrom(c);
+
+        this.mUusInfo = c.getUUSInfo();
+
+        this.setUserData(c.getUserData());
+    }
+
+    @Override
+    public Connection getOrigConnection() {
+        return mOrigConnection;
+    }
+
+    @Override
+    public boolean isMultiparty() {
+        /// M: For IMS SRVCC. mOrigConnection is used when SRVCC, but it should not believie
+        // its isMultiparty() @{
+        // if (mOrigConnection != null) {
+        //    return mOrigConnection.isMultiparty();
+        // }
+        if (mParent != null) {
+            return mParent.isMultiparty();
+        }
+        /// @}
+
+        return false;
+    }
+
+    /// M: CC: Proprietary incoming call handling @{
+    /// Reject MT when another MT already exists via EAIC disapproval
+    public void onReplaceDisconnect(int cause) {
+        this.mCause = cause;
+
+        if (!mDisconnected) {
+            mIndex = -1;
+
+            mDisconnectTime = System.currentTimeMillis();
+            mDuration = SystemClock.elapsedRealtime() - mConnectTimeReal;
+            mDisconnected = true;
+
+            log("onReplaceDisconnect: cause=" + cause);
+
+            if (mParent != null) {
+                mParent.connectionDisconnected(this);
+            }
+        }
+        releaseWakeLock();
+    }
+    /// @}
+
+    /// M: CDMA process call accepted @{
+    /**
+     * Check if this connection is really connected.
+     * @return true if this connection is really connected, or return false.
+     * @hide
+     */
+    public boolean isRealConnected() {
+        return mIsRealConnected;
+    }
+
+    boolean onCdmaCallAccept() {
+        proprietaryLog("onCdmaCallAccept, mIsRealConnected:" + mIsRealConnected
+                + ", state:" + getState());
+        if (getState() != GsmCdmaCall.State.ACTIVE) {
+            mReceivedAccepted = true;
+            return false;
+        }
+        mConnectTimeReal = SystemClock.elapsedRealtime();
+        mDuration = 0;
+        mConnectTime = System.currentTimeMillis();
+        if (!mIsRealConnected) {
+            mIsRealConnected = true;
+            // send DTMF when the CDMA call is really accepted.
+            processNextPostDialChar();
+            vibrateForAccepted();
+        }
+        return true;
+    }
+
+    private boolean isInChina() {
+        String numeric = android.telephony.TelephonyManager.getDefault()
+                .getNetworkOperatorForPhone(mOwner.mPhone.getPhoneId());
+        proprietaryLog("isInChina, numeric:" + numeric);
+        return numeric.indexOf("460") == 0;
+    }
+
+    private void vibrateForAccepted() {
+        //if CDMA phone accepted, start a Vibrator
+        android.os.Vibrator vibrator
+                = (android.os.Vibrator) mOwner.mPhone.getContext().getSystemService(
+                Context.VIBRATOR_SERVICE);
+        vibrator.vibrate(MO_CALL_VIBRATE_TIME);
+    }
+    /// @}
+
+    /// M: CC: For 3G VT only @{
+    public boolean isVideo() {
+        proprietaryLog("GsmConnection: isVideo = " + mIsVideo);
+        return mIsVideo;
+    }
+    /// @}
+
+    /// M: For IMS conference SRVCC. @{
+    void updateConferenceParticipantAddress(String address) {
+        mAddress = address;
+    }
+    /// @}
+
+    void proprietaryLog(String s) {
+        Rlog.d(PROP_LOG_TAG, s);
+    }
+}
