Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/PhoneCallDetails.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/PhoneCallDetails.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/PhoneCallDetails.java	(revision 14847)
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer;
+
+import com.android.contacts.common.ContactsUtils.UserType;
+import com.android.contacts.common.preference.ContactsPreferences;
+import com.android.contacts.common.util.ContactDisplayUtils;
+import com.android.dialer.calllog.PhoneNumberDisplayUtil;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.net.Uri;
+import android.provider.CallLog.Calls;
+import android.support.annotation.Nullable;
+import android.telecom.PhoneAccountHandle;
+import android.text.TextUtils;
+
+/**
+ * The details of a phone call to be shown in the UI.
+ */
+public class PhoneCallDetails {
+    // The number of the other party involved in the call.
+    public CharSequence number;
+    // Post-dial digits associated with the outgoing call.
+    public String postDialDigits;
+    // The secondary line number the call was received via.
+    public String viaNumber;
+    // The number presenting rules set by the network, e.g., {@link Calls#PRESENTATION_ALLOWED}
+    public int numberPresentation;
+    // The formatted version of {@link #number}.
+    public CharSequence formattedNumber;
+    // The country corresponding with the phone number.
+    public String countryIso;
+    // The geocoded location for the phone number.
+    public String geocode;
+
+    /**
+     * The type of calls, as defined in the call log table, e.g., {@link Calls#INCOMING_TYPE}.
+     * <p>
+     * There might be multiple types if this represents a set of entries grouped together.
+     */
+    public int[] callTypes;
+	public int isVolteCall;
+
+    // The date of the call, in milliseconds since the epoch.
+    public long date;
+    // The duration of the call in milliseconds, or 0 for missed calls.
+    public long duration;
+    // The name of the contact, or the empty string.
+    public CharSequence namePrimary;
+    // The alternative name of the contact, e.g. last name first, or the empty string
+    public CharSequence nameAlternative;
+    /**
+     * The user's preference on name display order, last name first or first time first.
+     * {@see ContactsPreferences}
+     */
+    public int nameDisplayOrder;
+    // The type of phone, e.g., {@link Phone#TYPE_HOME}, 0 if not available.
+    public int numberType;
+    // The custom label associated with the phone number in the contact, or the empty string.
+    public CharSequence numberLabel;
+    // The URI of the contact associated with this phone call.
+    public Uri contactUri;
+
+    /**
+     * The photo URI of the picture of the contact that is associated with this phone call or
+     * null if there is none.
+     * <p>
+     * This is meant to store the high-res photo only.
+     */
+    public Uri photoUri;
+
+    // The source type of the contact associated with this call.
+    public int sourceType;
+
+    // The object id type of the contact associated with this call.
+    public String objectId;
+
+    // The unique identifier for the account associated with the call.
+    public PhoneAccountHandle accountHandle;
+
+    // Features applicable to this call.
+    public int features;
+
+    // Total data usage for this call.
+    public Long dataUsage;
+
+    // Voicemail transcription
+    public String transcription;
+
+    // The display string for the number.
+    public String displayNumber;
+
+    // Whether the contact number is a voicemail number.
+    public boolean isVoicemail;
+
+    /** The {@link UserType} of the contact */
+    public @UserType long contactUserType;
+
+    /**
+     * If this is a voicemail, whether the message is read. For other types of calls, this defaults
+     * to {@code true}.
+     */
+    public boolean isRead = true;
+
+    /// M: [IP Dial] the ipPrefix
+    public String ipPrefix = null;
+
+    ///M: [VoLTE ConfCallLog] record the conference call log id
+    public long conferenceId;
+
+    /**
+     * Constructor with required fields for the details of a call with a number associated with a
+     * contact.
+     */
+    public PhoneCallDetails(
+            Context context,
+            CharSequence number,
+            int numberPresentation,
+            CharSequence formattedNumber,
+            CharSequence postDialDigits,
+            boolean isVoicemail) {
+        this.number = number;
+        this.numberPresentation = numberPresentation;
+        this.formattedNumber = formattedNumber;
+        this.isVoicemail = isVoicemail;
+        this.postDialDigits = postDialDigits.toString();
+        this.displayNumber = PhoneNumberDisplayUtil.getDisplayNumber(
+                context,
+                this.number,
+                this.numberPresentation,
+                this.formattedNumber,
+                this.postDialDigits,
+                this.isVoicemail).toString();
+    }
+
+    /**
+     * Returns the preferred name for the call details as specified by the
+     * {@link #nameDisplayOrder}
+     *
+     * @return the preferred name
+     */
+    public CharSequence getPreferredName() {
+        if (nameDisplayOrder == ContactsPreferences.DISPLAY_ORDER_PRIMARY
+                || TextUtils.isEmpty(nameAlternative)) {
+            return namePrimary;
+        }
+        return nameAlternative;
+    }
+
+    /**
+     * Construct the "on {accountLabel} via {viaNumber}" accessibility description for the account
+     * list item, depending on the existence of the accountLabel and viaNumber.
+     * @param viaNumber The number that this call is being placed via.
+     * @param accountLabel The {@link PhoneAccount} label that this call is being placed with.
+     * @return The description of the account that this call has been placed on.
+     */
+    public static CharSequence createAccountLabelDescription(Resources resources,
+            @Nullable String viaNumber, @Nullable CharSequence accountLabel) {
+
+        if((!TextUtils.isEmpty(viaNumber)) && !TextUtils.isEmpty(accountLabel)) {
+            String msg = resources.getString(R.string.description_via_number_phone_account,
+                    accountLabel, viaNumber);
+            CharSequence accountNumberLabel = ContactDisplayUtils.getTelephoneTtsSpannable(msg,
+                    viaNumber);
+            return (accountNumberLabel == null) ? msg : accountNumberLabel;
+        } else if (!TextUtils.isEmpty(viaNumber)) {
+            CharSequence viaNumberLabel = ContactDisplayUtils.getTtsSpannedPhoneNumber(resources,
+                    R.string.description_via_number, viaNumber);
+            return (viaNumberLabel == null) ? viaNumber : viaNumberLabel;
+        } else if (!TextUtils.isEmpty(accountLabel)) {
+            return TextUtils.expandTemplate(
+                    resources.getString(R.string.description_phone_account), accountLabel);
+        }
+        return "";
+    }
+}
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogAdapter.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogAdapter.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogAdapter.java	(revision 14847)
@@ -0,0 +1,1144 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.calllog;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Trace;
+import android.preference.PreferenceManager;
+import android.provider.CallLog;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.telecom.PhoneAccountHandle;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.ArrayMap;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.AccessibilityDelegate;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+
+import com.android.contacts.common.ContactsUtils;
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.common.compat.PhoneNumberUtilsCompat;
+import com.android.contacts.common.preference.ContactsPreferences;
+import com.android.contacts.common.util.PermissionsUtil;
+import com.android.dialer.DialtactsActivity;
+import com.android.dialer.PhoneCallDetails;
+import com.android.dialer.R;
+import com.android.dialer.calllog.calllogcache.CallLogCache;
+import com.android.dialer.contactinfo.ContactInfoCache;
+import com.android.dialer.contactinfo.ContactInfoCache.OnContactInfoChangedListener;
+import com.android.dialer.database.FilteredNumberAsyncQueryHandler;
+import com.android.dialer.database.VoicemailArchiveContract;
+import com.android.dialer.filterednumber.BlockNumberDialogFragment.Callback;
+import com.android.dialer.logging.InteractionEvent;
+import com.android.dialer.logging.Logger;
+import com.android.dialer.service.ExtendedBlockingButtonRenderer;
+import com.android.dialer.util.DialerUtils;
+import com.android.dialer.util.PhoneNumberUtil;
+import com.android.dialer.voicemail.VoicemailPlaybackPresenter;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import com.mediatek.dialer.ext.ExtensionManager;
+import com.mediatek.dialer.search.Throttle;
+import com.mediatek.dialer.util.DialerFeatureOptions;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Adapter class to fill in data for the Call Log.
+ */
+public class CallLogAdapter extends GroupingListAdapter
+        implements CallLogGroupBuilder.GroupCreator,
+                VoicemailPlaybackPresenter.OnVoicemailDeletedListener,
+                ExtendedBlockingButtonRenderer.Listener {
+
+    // Types of activities the call log adapter is used for
+    public static final int ACTIVITY_TYPE_CALL_LOG = 1;
+    public static final int ACTIVITY_TYPE_ARCHIVE = 2;
+    public static final int ACTIVITY_TYPE_DIALTACTS = 3;
+
+    /** Interface used to initiate a refresh of the content. */
+    public interface CallFetcher {
+        public void fetchCalls();
+    }
+
+    private static final int NO_EXPANDED_LIST_ITEM = -1;
+    // ConcurrentHashMap doesn't store null values. Use this value for numbers which aren't blocked.
+    private static final int NOT_BLOCKED = -1;
+
+    private static final int VOICEMAIL_PROMO_CARD_POSITION = 0;
+
+    protected static final int VIEW_TYPE_NORMAL = 0;
+    private static final int VIEW_TYPE_VOICEMAIL_PROMO_CARD = 1;
+
+    /**
+     * The key for the show voicemail promo card preference which will determine whether the promo
+     * card was permanently dismissed or not.
+     */
+    private static final String SHOW_VOICEMAIL_PROMO_CARD = "show_voicemail_promo_card";
+    private static final boolean SHOW_VOICEMAIL_PROMO_CARD_DEFAULT = true;
+
+    protected final Context mContext;
+    private final ContactInfoHelper mContactInfoHelper;
+    protected final VoicemailPlaybackPresenter mVoicemailPlaybackPresenter;
+    private final CallFetcher mCallFetcher;
+    private final FilteredNumberAsyncQueryHandler mFilteredNumberAsyncQueryHandler;
+    private final Map<String, Boolean> mBlockedNumberCache = new ArrayMap<>();
+
+    protected ContactInfoCache mContactInfoCache;
+
+    private final int mActivityType;
+
+    private static final String KEY_EXPANDED_POSITION = "expanded_position";
+    private static final String KEY_EXPANDED_ROW_ID = "expanded_row_id";
+
+    // Tracks the position of the currently expanded list item.
+    private int mCurrentlyExpandedPosition = RecyclerView.NO_POSITION;
+    // Tracks the rowId of the currently expanded list item, so the position can be updated if there
+    // are any changes to the call log entries, such as additions or removals.
+    private long mCurrentlyExpandedRowId = NO_EXPANDED_LIST_ITEM;
+    private int mHiddenPosition = RecyclerView.NO_POSITION;
+    private Uri mHiddenItemUri = null;
+    private boolean mPendingHide = false;
+
+    /**
+     *  Hashmap, keyed by call Id, used to track the day group for a call.  As call log entries are
+     *  put into the primary call groups in {@link com.android.dialer.calllog.CallLogGroupBuilder},
+     *  they are also assigned a secondary "day group".  This hashmap tracks the day group assigned
+     *  to all calls in the call log.  This information is used to trigger the display of a day
+     *  group header above the call log entry at the start of a day group.
+     *  Note: Multiple calls are grouped into a single primary "call group" in the call log, and
+     *  the cursor used to bind rows includes all of these calls.  When determining if a day group
+     *  change has occurred it is necessary to look at the last entry in the call log to determine
+     *  its day group.  This hashmap provides a means of determining the previous day group without
+     *  having to reverse the cursor to the start of the previous day call log entry.
+     */
+    private HashMap<Long, Integer> mDayGroups = new HashMap<>();
+
+    private boolean mLoading = true;
+
+    private SharedPreferences mPrefs;
+
+    private ContactsPreferences mContactsPreferences;
+
+    protected boolean mShowVoicemailPromoCard = false;
+
+    /** Instance of helper class for managing views. */
+    private final CallLogListItemHelper mCallLogListItemHelper;
+
+    /** Cache for repeated requests to Telecom/Telephony. */
+    protected final CallLogCache mCallLogCache;
+
+    /** Helper to group call log entries. */
+    private final CallLogGroupBuilder mCallLogGroupBuilder;
+
+    /**
+     * The OnClickListener used to expand or collapse the action buttons of a call log entry.
+     */
+    private final View.OnClickListener mExpandCollapseListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            CallLogListItemViewHolder viewHolder = (CallLogListItemViewHolder) v.getTag();
+            if (viewHolder == null) {
+                return;
+            }
+
+            if (mVoicemailPlaybackPresenter != null) {
+                // Always reset the voicemail playback state on expand or collapse.
+                mVoicemailPlaybackPresenter.resetAll();
+            }
+
+            if (viewHolder.getAdapterPosition() == mCurrentlyExpandedPosition) {
+                // Hide actions, if the clicked item is the expanded item.
+                viewHolder.showActions(false);
+
+                mCurrentlyExpandedPosition = RecyclerView.NO_POSITION;
+                mCurrentlyExpandedRowId = NO_EXPANDED_LIST_ITEM;
+            } else {
+                if (viewHolder.callType == CallLog.Calls.MISSED_TYPE) {
+                    CallLogAsyncTaskUtil.markCallAsRead(mContext, viewHolder.callIds);
+                    if (mActivityType == ACTIVITY_TYPE_DIALTACTS) {
+                        ((DialtactsActivity) v.getContext()).updateTabUnreadCounts();
+                    }
+                }
+                expandViewHolderActions(viewHolder);
+            }
+
+        }
+    };
+
+    /**
+     * Click handler used to dismiss the promo card when the user taps the "ok" button.
+     */
+    private final View.OnClickListener mOkActionListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            dismissVoicemailPromoCard();
+        }
+    };
+
+    /**
+     * Click handler used to send the user to the voicemail settings screen and then dismiss the
+     * promo card.
+     */
+    private final View.OnClickListener mVoicemailSettingsActionListener =
+            new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            Intent intent = new Intent(TelephonyManager.ACTION_CONFIGURE_VOICEMAIL);
+            mContext.startActivity(intent);
+            dismissVoicemailPromoCard();
+        }
+    };
+
+    private void expandViewHolderActions(CallLogListItemViewHolder viewHolder) {
+        // If another item is expanded, notify it that it has changed. Its actions will be
+        // hidden when it is re-binded because we change mCurrentlyExpandedPosition below.
+        if (mCurrentlyExpandedPosition != RecyclerView.NO_POSITION) {
+            notifyItemChanged(mCurrentlyExpandedPosition);
+        }
+        // Show the actions for the clicked list item.
+        viewHolder.showActions(true);
+        mCurrentlyExpandedPosition = viewHolder.getAdapterPosition();
+        mCurrentlyExpandedRowId = viewHolder.rowId;
+        // M: Add for Presence
+        ExtensionManager.getInstance().getCallLogExtension()
+                .onExpandViewHolderActions(viewHolder.number);
+    }
+
+    /**
+     * Expand the actions on a list item when focused in Talkback mode, to aid discoverability.
+     */
+    private AccessibilityDelegate mAccessibilityDelegate = new AccessibilityDelegate() {
+        @Override
+        public boolean onRequestSendAccessibilityEvent(
+                ViewGroup host, View child, AccessibilityEvent event) {
+            if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
+                // Only expand if actions are not already expanded, because triggering the expand
+                // function on clicks causes the action views to lose the focus indicator.
+                CallLogListItemViewHolder viewHolder = (CallLogListItemViewHolder) host.getTag();
+                if (mCurrentlyExpandedPosition != viewHolder.getAdapterPosition()) {
+                    if (mVoicemailPlaybackPresenter != null) {
+                        // Always reset the voicemail playback state on expand.
+                        mVoicemailPlaybackPresenter.resetAll();
+                    }
+
+                    expandViewHolderActions((CallLogListItemViewHolder) host.getTag());
+                }
+            }
+            return super.onRequestSendAccessibilityEvent(host, child, event);
+        }
+    };
+
+    protected final OnContactInfoChangedListener mOnContactInfoChangedListener =
+            new OnContactInfoChangedListener() {
+                @Override
+                public void onContactInfoChanged() {
+                    notifyDataSetChanged();
+                }
+            };
+
+    public CallLogAdapter(
+            Context context,
+            CallFetcher callFetcher,
+            ContactInfoHelper contactInfoHelper,
+            VoicemailPlaybackPresenter voicemailPlaybackPresenter,
+            int activityType) {
+        super(context);
+
+        mContext = context;
+        mCallFetcher = callFetcher;
+        mContactInfoHelper = contactInfoHelper;
+        mVoicemailPlaybackPresenter = voicemailPlaybackPresenter;
+        if (mVoicemailPlaybackPresenter != null) {
+            mVoicemailPlaybackPresenter.setOnVoicemailDeletedListener(this);
+        }
+
+        mActivityType = activityType;
+
+        mContactInfoCache = new ContactInfoCache(
+                mContactInfoHelper, mOnContactInfoChangedListener);
+        if (!PermissionsUtil.hasContactsPermissions(context)) {
+            mContactInfoCache.disableRequestProcessing(true);
+        }
+
+        Resources resources = mContext.getResources();
+        CallTypeHelper callTypeHelper = new CallTypeHelper(resources);
+
+        mCallLogCache = CallLogCache.getCallLogCache(mContext);
+
+        PhoneCallDetailsHelper phoneCallDetailsHelper =
+                new PhoneCallDetailsHelper(mContext, resources, mCallLogCache);
+        mCallLogListItemHelper =
+                new CallLogListItemHelper(phoneCallDetailsHelper, resources, mCallLogCache);
+        mCallLogGroupBuilder = new CallLogGroupBuilder(this);
+        mFilteredNumberAsyncQueryHandler =
+                new FilteredNumberAsyncQueryHandler(mContext.getContentResolver());
+
+        mPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+        mContactsPreferences = new ContactsPreferences(mContext);
+        maybeShowVoicemailPromoCard();
+        /// M: To improve scroll performance, using throttle observer to do call fetching. @{
+        mChangeObserver = new ThrottledObserver(new Handler(), mContext, new Runnable() {
+            @Override
+            public void run() {
+                onContentChanged();
+            }
+        }, "CallLogAdapter");
+        /// @}
+    }
+
+    public void onSaveInstanceState(Bundle outState) {
+        outState.putInt(KEY_EXPANDED_POSITION, mCurrentlyExpandedPosition);
+        outState.putLong(KEY_EXPANDED_ROW_ID, mCurrentlyExpandedRowId);
+    }
+
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        if (savedInstanceState != null) {
+            mCurrentlyExpandedPosition =
+                    savedInstanceState.getInt(KEY_EXPANDED_POSITION, RecyclerView.NO_POSITION);
+            mCurrentlyExpandedRowId =
+                    savedInstanceState.getLong(KEY_EXPANDED_ROW_ID, NO_EXPANDED_LIST_ITEM);
+        }
+    }
+
+    @Override
+    public void onBlockedNumber(String number,String countryIso) {
+        String cacheKey = PhoneNumberUtils.formatNumberToE164(number, countryIso);
+        if (!TextUtils.isEmpty(cacheKey)) {
+            mBlockedNumberCache.put(cacheKey, true);
+            notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public void onUnblockedNumber( String number, String countryIso) {
+        String cacheKey = PhoneNumberUtils.formatNumberToE164(number, countryIso);
+        if (!TextUtils.isEmpty(cacheKey)) {
+            mBlockedNumberCache.put(cacheKey, false);
+            notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Requery on background thread when {@link Cursor} changes.
+     */
+    @Override
+    protected void onContentChanged() {
+        mCallFetcher.fetchCalls();
+    }
+
+    public void setLoading(boolean loading) {
+        mLoading = loading;
+    }
+
+    public boolean isEmpty() {
+        if (mLoading) {
+            // We don't want the empty state to show when loading.
+            return false;
+        } else {
+            return getItemCount() == 0;
+        }
+    }
+
+    public void invalidateCache() {
+        mContactInfoCache.invalidate();
+    }
+
+    public void onResume() {
+        if (PermissionsUtil.hasPermission(mContext, android.Manifest.permission.READ_CONTACTS)) {
+            /// M: enable request process if permission is enable
+            mContactInfoCache.disableRequestProcessing(false);
+            mContactInfoCache.start();
+        }
+        mContactsPreferences.refreshValue(ContactsPreferences.DISPLAY_ORDER_KEY);
+    }
+
+    public void onPause() {
+        pauseCache();
+
+        if (mHiddenItemUri != null) {
+            CallLogAsyncTaskUtil.deleteVoicemail(mContext, mHiddenItemUri, null);
+        }
+    }
+
+    @VisibleForTesting
+    /* package */ void pauseCache() {
+        mContactInfoCache.stop();
+        mCallLogCache.reset();
+    }
+
+    @Override
+    protected void addGroups(Cursor cursor) {
+        mCallLogGroupBuilder.addGroups(cursor);
+    }
+
+    @Override
+    public void addVoicemailGroups(Cursor cursor) {
+        mCallLogGroupBuilder.addVoicemailGroups(cursor);
+    }
+
+    @Override
+    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        if (viewType == VIEW_TYPE_VOICEMAIL_PROMO_CARD) {
+            return createVoicemailPromoCardViewHolder(parent);
+        }
+        return createCallLogEntryViewHolder(parent);
+    }
+
+    /**
+     * Creates a new call log entry {@link ViewHolder}.
+     *
+     * @param parent the parent view.
+     * @return The {@link ViewHolder}.
+     */
+    private ViewHolder createCallLogEntryViewHolder(ViewGroup parent) {
+        LayoutInflater inflater = LayoutInflater.from(mContext);
+        View view = inflater.inflate(R.layout.call_log_list_item, parent, false);
+        CallLogListItemViewHolder viewHolder = CallLogListItemViewHolder.create(
+                view,
+                mContext,
+                this,
+                mExpandCollapseListener,
+                mCallLogCache,
+                mCallLogListItemHelper,
+                mVoicemailPlaybackPresenter,
+                mFilteredNumberAsyncQueryHandler,
+                new Callback() {
+                    @Override
+                    public void onFilterNumberSuccess() {
+                        Logger.logInteraction(
+                                InteractionEvent.BLOCK_NUMBER_CALL_LOG);
+                    }
+
+                    @Override
+                    public void onUnfilterNumberSuccess() {
+                        Logger.logInteraction(
+                                InteractionEvent.UNBLOCK_NUMBER_CALL_LOG);
+                    }
+
+                    @Override
+                    public void onChangeFilteredNumberUndo() {}
+                }, mActivityType == ACTIVITY_TYPE_ARCHIVE);
+
+        viewHolder.callLogEntryView.setTag(viewHolder);
+        viewHolder.callLogEntryView.setAccessibilityDelegate(mAccessibilityDelegate);
+
+        viewHolder.primaryActionView.setTag(viewHolder);
+
+        return viewHolder;
+    }
+
+    /**
+     * Binds the views in the entry to the data in the call log.
+     * TODO: This gets called 20-30 times when Dialer starts up for a single call log entry and
+     * should not. It invokes cross-process methods and the repeat execution can get costly.
+     *
+     * @param viewHolder The view corresponding to this entry.
+     * @param position The position of the entry.
+     */
+    @Override
+    public void onBindViewHolder(ViewHolder viewHolder, int position) {
+        Trace.beginSection("onBindViewHolder: " + position);
+
+        switch (getItemViewType(position)) {
+            case VIEW_TYPE_VOICEMAIL_PROMO_CARD:
+                bindVoicemailPromoCardViewHolder(viewHolder);
+                break;
+            default:
+                bindCallLogListViewHolder(viewHolder, position);
+                break;
+        }
+
+        Trace.endSection();
+    }
+
+    /**
+     * Binds the promo card view holder.
+     *
+     * @param viewHolder The promo card view holder.
+     */
+    protected void bindVoicemailPromoCardViewHolder(ViewHolder viewHolder) {
+        PromoCardViewHolder promoCardViewHolder = (PromoCardViewHolder) viewHolder;
+
+        promoCardViewHolder.getSecondaryActionView()
+                .setOnClickListener(mVoicemailSettingsActionListener);
+        promoCardViewHolder.getPrimaryActionView().setOnClickListener(mOkActionListener);
+    }
+
+    /**
+     * M: [Volte ConfCallLog] Change into 'protected' for inheriting.
+     * Binds the view holder for the call log list item view.
+     *
+     * @param viewHolder The call log list item view holder.
+     * @param position The position of the list item.
+     */
+
+    protected void bindCallLogListViewHolder(ViewHolder viewHolder, int position) {
+        Cursor c = (Cursor) getItem(position);
+        if (c == null) {
+            return;
+        }
+        int count = getGroupSize(position);
+
+        final String number = c.getString(CallLogQuery.NUMBER);
+		final int isVolteCall = c.getInt(CallLogQuery.IS_VOLTE_CALL);
+        final String countryIso = c.getString(CallLogQuery.COUNTRY_ISO);
+        final String postDialDigits = CompatUtils.isNCompatible()
+                && mActivityType != ACTIVITY_TYPE_ARCHIVE ?
+                c.getString(CallLogQuery.POST_DIAL_DIGITS) : "";
+        final String viaNumber = CompatUtils.isNCompatible()
+                && mActivityType != ACTIVITY_TYPE_ARCHIVE ?
+                c.getString(CallLogQuery.VIA_NUMBER) : "";
+        final int numberPresentation = c.getInt(CallLogQuery.NUMBER_PRESENTATION);
+        final PhoneAccountHandle accountHandle = PhoneAccountUtils.getAccount(
+                c.getString(CallLogQuery.ACCOUNT_COMPONENT_NAME),
+                c.getString(CallLogQuery.ACCOUNT_ID));
+        final ContactInfo cachedContactInfo = ContactInfoHelper.getContactInfo(c);
+        final boolean isVoicemailNumber =
+                mCallLogCache.isVoicemailNumber(accountHandle, number);
+
+        // Note: Binding of the action buttons is done as required in configureActionViews when the
+        // user expands the actions ViewStub.
+
+        ContactInfo info = ContactInfo.EMPTY;
+
+        if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation) && !isVoicemailNumber) {
+                // Lookup contacts with this number
+                info = mContactInfoCache.getValue(number + postDialDigits,
+                                countryIso, cachedContactInfo);
+        }
+
+        CharSequence formattedNumber = info.formattedNumber == null
+                ? null : PhoneNumberUtilsCompat.createTtsSpannable(info.formattedNumber);
+
+        final PhoneCallDetails details = new PhoneCallDetails(
+                mContext, number, numberPresentation, formattedNumber,
+                postDialDigits, isVoicemailNumber);
+        details.viaNumber = viaNumber;
+        details.accountHandle = accountHandle;
+        details.countryIso = countryIso;
+        details.date = c.getLong(CallLogQuery.DATE);
+        details.duration = c.getLong(CallLogQuery.DURATION);
+        details.features = getCallFeatures(c, count);
+        details.geocode = c.getString(CallLogQuery.GEOCODED_LOCATION);
+        details.transcription = c.getString(CallLogQuery.TRANSCRIPTION);
+        details.callTypes = getCallTypes(c, count);
+		details.isVolteCall = c.getInt(CallLogQuery.IS_VOLTE_CALL);
+
+        if (!c.isNull(CallLogQuery.DATA_USAGE)) {
+            details.dataUsage = c.getLong(CallLogQuery.DATA_USAGE);
+        }
+
+        if (!TextUtils.isEmpty(info.name) || !TextUtils.isEmpty(info.nameAlternative)) {
+            details.contactUri = info.lookupUri;
+            details.namePrimary = info.name;
+            details.nameAlternative = info.nameAlternative;
+            details.nameDisplayOrder = mContactsPreferences.getDisplayOrder();
+            details.numberType = info.type;
+            details.numberLabel = info.label;
+            details.photoUri = info.photoUri;
+            details.sourceType = info.sourceType;
+            details.objectId = info.objectId;
+            details.contactUserType = info.userType;
+        }
+
+        final CallLogListItemViewHolder views = (CallLogListItemViewHolder) viewHolder;
+        views.info = info;
+        views.rowId = c.getLong(CallLogQuery.ID);
+        // Store values used when the actions ViewStub is inflated on expansion.
+        views.number = number;
+		views.isVolteCall = details.isVolteCall;
+        views.postDialDigits = details.postDialDigits;
+        views.displayNumber = details.displayNumber;
+        views.numberPresentation = numberPresentation;
+
+        views.accountHandle = accountHandle;
+        // Stash away the Ids of the calls so that we can support deleting a row in the call log.
+        views.callIds = getCallIds(c, count);
+        views.isBusiness = mContactInfoHelper.isBusiness(info.sourceType);
+        views.numberType = (String) Phone.getTypeLabel(mContext.getResources(), details.numberType,
+                details.numberLabel);
+        // Default case: an item in the call log.
+        views.primaryActionView.setVisibility(View.VISIBLE);
+        views.workIconView.setVisibility(
+                details.contactUserType == ContactsUtils.USER_TYPE_WORK ? View.VISIBLE : View.GONE);
+
+        // Check if the day group has changed and display a header if necessary.
+        int currentGroup = getDayGroupForCall(views.rowId);
+        int previousGroup = getPreviousDayGroup(c);
+        if (currentGroup != previousGroup) {
+            views.dayGroupHeader.setVisibility(View.VISIBLE);
+            views.dayGroupHeader.setText(getGroupDescription(currentGroup));
+        } else {
+            views.dayGroupHeader.setVisibility(View.GONE);
+        }
+
+        if (mActivityType == ACTIVITY_TYPE_ARCHIVE) {
+            views.callType = CallLog.Calls.VOICEMAIL_TYPE;
+            views.voicemailUri = VoicemailArchiveContract.VoicemailArchive.buildWithId(c.getInt(
+                    c.getColumnIndex(VoicemailArchiveContract.VoicemailArchive._ID)))
+                    .toString();
+
+        } else {
+            if (details.callTypes[0] == CallLog.Calls.VOICEMAIL_TYPE ||
+                    details.callTypes[0] == CallLog.Calls.MISSED_TYPE) {
+                details.isRead = c.getInt(CallLogQuery.IS_READ) == 1;
+            }
+            views.callType = c.getInt(CallLogQuery.CALL_TYPE);
+            views.voicemailUri = c.getString(CallLogQuery.VOICEMAIL_URI);
+        }
+
+        /// M: [Dialer Global Search] Highlight the search text @{
+        if (DialerFeatureOptions.DIALER_GLOBAL_SEARCH && mUpperCaseQueryString != null
+                && mUpperCaseQueryString.length > 0) {
+            mCallLogListItemHelper.setHighlightedText(mUpperCaseQueryString);
+        }
+        /// @}
+
+        /// M: [VoLTE ConfCallLog] For Volte Conference CallLog @{
+        long confCallId = -1;
+        if (DialerFeatureOptions.isVolteConfCallLogSupport()) {
+            confCallId = c.getLong(CallLogQuery.CONFERENCE_CALL_ID);
+        }
+        if (confCallId > 0 && !mIsConfCallMemberList) {
+            ArrayList<String> numbers = getConferenceCallNumbers(c, count);
+            details.date = getConferenceCallDate(c, count);
+            details.namePrimary = getConferenceCallName(c, count);
+            views.confCallNumbers = numbers;
+            int firstCallType = details.callTypes[0];
+            details.callTypes = new int[1];
+            details.callTypes[0] = firstCallType;
+            Log.d(TAG, "Volte ConfCall numbers= " + PhoneNumberUtil.pii(numbers) + ", date="
+                    + details.date + ", name=" + details.namePrimary);
+        } else {
+            views.confCallNumbers = null;
+        }
+        /// @}
+
+        mCallLogListItemHelper.setPhoneCallDetails(views, details);
+
+        if (mCurrentlyExpandedRowId == views.rowId) {
+            // In case ViewHolders were added/removed, update the expanded position if the rowIds
+            // match so that we can restore the correct expanded state on rebind.
+            /**
+             * M:original code: mCurrentlyExpandedPosition = position; @{
+             */
+            if(mIsConfCallMemberList) {
+                // The first position is call detail header
+                mCurrentlyExpandedPosition = position + 1;
+            } else {
+                mCurrentlyExpandedPosition = position;
+            }
+            /**@}*/
+            views.showActions(true);
+        } else {
+            views.showActions(false);
+		}
+		
+		Log.i("chenhu", "number="+number);
+		Log.i("chenhu", "isVolteCall="+isVolteCall);
+
+		if (isVolteCall == 1) {
+			views.calllogVolteTypeView.setVisibility(View.VISIBLE);
+		} else {
+			views.calllogVolteTypeView.setVisibility(View.GONE);
+        }
+		
+		if(PhoneNumberUtils.isEmergencyNumber(number)){
+			//for feature: FR_EMC_CALL_INFO_IN_INDIA = true
+			setEmcTitle(views, number);
+			views.emergencyNumberView.setVisibility(View.VISIBLE);
+		}else{
+			views.emergencyNumberView.setVisibility(View.GONE);
+		}
+		
+        views.updatePhoto();
+        /// M: why AOSP call it twice? delete it
+        //mCallLogListItemHelper.setPhoneCallDetails(views, details);
+
+        /// M: for Plug-in @{
+        ExtensionManager.getInstance().getRCSeCallLogExtension().bindPluginViewForCallLogList(
+                mContext, (ViewGroup) views.primaryActionView, number);
+
+        ExtensionManager.getInstance().getCallLogExtension()
+                .setCallAccountForCallLogList(mContext,
+                        ((CallLogListItemViewHolder) viewHolder).primaryActionView, accountHandle);
+        /// @}
+    }
+	private void setEmcTitle(CallLogListItemViewHolder views, String number){
+		boolean bFrEmcIndia = mContext.getResources().getBoolean(com.android.internal.R.bool.FR_EMC_CALL_INFO_IN_INDIA);
+		if(bFrEmcIndia && (views != null) && (views.emergencyNumberView != null)){
+			String arrEmc[][] = {
+				{"100","Police Emergency"},
+				{"101","Fire Emergency"},
+				{"102","Ambulance Emergency"},
+				//{"112","Emergency Number"},
+			};
+			views.emergencyNumberView.setText(R.string.emergency_number);
+			for(int i = 0; i < arrEmc.length; i++){
+				if(arrEmc[i][0].equals(number)){
+					views.emergencyNumberView.setText(arrEmc[i][1]);
+					break;
+				}
+			}
+		}
+	}
+
+    private String getPreferredDisplayName(ContactInfo contactInfo) {
+        if (mContactsPreferences.getDisplayOrder() == ContactsPreferences.DISPLAY_ORDER_PRIMARY ||
+                TextUtils.isEmpty(contactInfo.nameAlternative)) {
+            return contactInfo.name;
+        }
+        return contactInfo.nameAlternative;
+    }
+
+    @Override
+    public int getItemCount() {
+        return super.getItemCount() + (mShowVoicemailPromoCard ? 1 : 0)
+                - (mHiddenPosition != RecyclerView.NO_POSITION ? 1 : 0);
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        if (position == VOICEMAIL_PROMO_CARD_POSITION && mShowVoicemailPromoCard) {
+            return VIEW_TYPE_VOICEMAIL_PROMO_CARD;
+        }
+        return super.getItemViewType(position);
+    }
+
+    /**
+     * Retrieves an item at the specified position, taking into account the presence of a promo
+     * card.
+     *
+     * @param position The position to retrieve.
+     * @return The item at that position.
+     */
+    @Override
+    public Object getItem(int position) {
+        return super.getItem(position - (mShowVoicemailPromoCard ? 1 : 0)
+                + ((mHiddenPosition != RecyclerView.NO_POSITION && position >= mHiddenPosition)
+                ? 1 : 0));
+    }
+
+    @Override
+    public int getGroupSize(int position) {
+        return super.getGroupSize(position - (mShowVoicemailPromoCard ? 1 : 0));
+    }
+
+    protected boolean isCallLogActivity() {
+        return mActivityType == ACTIVITY_TYPE_CALL_LOG;
+    }
+
+    /**
+     * In order to implement the "undo" function, when a voicemail is "deleted" i.e. when the user
+     * clicks the delete button, the deleted item is temporarily hidden from the list. If a user
+     * clicks delete on a second item before the first item's undo option has expired, the first
+     * item is immediately deleted so that only one item can be "undoed" at a time.
+     */
+    @Override
+    public void onVoicemailDeleted(Uri uri) {
+        if (mHiddenItemUri == null) {
+            // Immediately hide the currently expanded card.
+            mHiddenPosition = mCurrentlyExpandedPosition;
+            notifyDataSetChanged();
+        } else {
+            // This means that there was a previous item that was hidden in the UI but not
+            // yet deleted from the database (call it a "pending delete"). Delete this previous item
+            // now since it is only possible to do one "undo" at a time.
+            CallLogAsyncTaskUtil.deleteVoicemail(mContext, mHiddenItemUri, null);
+
+            // Set pending hide action so that the current item is hidden only after the previous
+            // item is permanently deleted.
+            mPendingHide = true;
+        }
+
+        collapseExpandedCard();
+
+        // Save the new hidden item uri in case it needs to be deleted from the database when
+        // a user attempts to delete another item.
+        mHiddenItemUri = uri;
+    }
+
+    private void collapseExpandedCard() {
+        mCurrentlyExpandedRowId = NO_EXPANDED_LIST_ITEM;
+        mCurrentlyExpandedPosition = RecyclerView.NO_POSITION;
+    }
+
+    /**
+     * When the list is changing all stored position is no longer valid.
+     */
+    public void invalidatePositions() {
+        mCurrentlyExpandedPosition = RecyclerView.NO_POSITION;
+        mHiddenPosition = RecyclerView.NO_POSITION;
+    }
+
+    /**
+     * When the user clicks "undo", the hidden item is unhidden.
+     */
+    @Override
+    public void onVoicemailDeleteUndo() {
+        mHiddenPosition = RecyclerView.NO_POSITION;
+        mHiddenItemUri = null;
+
+        mPendingHide = false;
+        notifyDataSetChanged();
+    }
+
+    /**
+     * This callback signifies that a database deletion has completed. This means that if there is
+     * an item pending deletion, it will be hidden because the previous item that was in "undo" mode
+     * has been removed from the database. Otherwise it simply resets the hidden state because there
+     * are no pending deletes and thus no hidden items.
+     */
+    @Override
+    public void onVoicemailDeletedInDatabase() {
+        if (mPendingHide) {
+            mHiddenPosition = mCurrentlyExpandedPosition;
+            mPendingHide = false;
+        } else {
+            // There should no longer be any hidden item because it has been deleted from the
+            // database.
+            mHiddenPosition = RecyclerView.NO_POSITION;
+            mHiddenItemUri = null;
+        }
+    }
+
+    /**
+     * Retrieves the day group of the previous call in the call log.  Used to determine if the day
+     * group has changed and to trigger display of the day group text.
+     *
+     * @param cursor The call log cursor.
+     * @return The previous day group, or DAY_GROUP_NONE if this is the first call.
+     */
+    private int getPreviousDayGroup(Cursor cursor) {
+        // We want to restore the position in the cursor at the end.
+        int startingPosition = cursor.getPosition();
+        int dayGroup = CallLogGroupBuilder.DAY_GROUP_NONE;
+        if (cursor.moveToPrevious()) {
+            // If the previous entry is hidden (deleted in the UI but not in the database), skip it
+            // and check the card above it. A list with the voicemail promo card at the top will be
+            // 1-indexed because the 0th index is the promo card iteself.
+            int previousViewPosition = mShowVoicemailPromoCard ? startingPosition :
+                startingPosition - 1;
+            if (previousViewPosition != mHiddenPosition ||
+                    (previousViewPosition == mHiddenPosition && cursor.moveToPrevious())) {
+                long previousRowId = cursor.getLong(CallLogQuery.ID);
+                dayGroup = getDayGroupForCall(previousRowId);
+            }
+        }
+        cursor.moveToPosition(startingPosition);
+        return dayGroup;
+    }
+
+    /**
+     * Given a call Id, look up the day group that the call belongs to.  The day group data is
+     * populated in {@link com.android.dialer.calllog.CallLogGroupBuilder}.
+     *
+     * @param callId The call to retrieve the day group for.
+     * @return The day group for the call.
+     */
+    private int getDayGroupForCall(long callId) {
+        if (mDayGroups.containsKey(callId)) {
+            return mDayGroups.get(callId);
+        }
+        return CallLogGroupBuilder.DAY_GROUP_NONE;
+    }
+
+    /**
+     * Returns the call types for the given number of items in the cursor.
+     * <p>
+     * It uses the next {@code count} rows in the cursor to extract the types.
+     * <p>
+     * It position in the cursor is unchanged by this function.
+     */
+    private int[] getCallTypes(Cursor cursor, int count) {
+        if (mActivityType == ACTIVITY_TYPE_ARCHIVE) {
+            return new int[] {CallLog.Calls.VOICEMAIL_TYPE};
+        }
+        int position = cursor.getPosition();
+        int[] callTypes = new int[count];
+        for (int index = 0; index < count; ++index) {
+            callTypes[index] = cursor.getInt(CallLogQuery.CALL_TYPE);
+            cursor.moveToNext();
+        }
+        cursor.moveToPosition(position);
+        return callTypes;
+    }
+
+    /**
+     * Determine the features which were enabled for any of the calls that make up a call log
+     * entry.
+     *
+     * @param cursor The cursor.
+     * @param count The number of calls for the current call log entry.
+     * @return The features.
+     */
+    private int getCallFeatures(Cursor cursor, int count) {
+        int features = 0;
+        int position = cursor.getPosition();
+        for (int index = 0; index < count; ++index) {
+            features |= cursor.getInt(CallLogQuery.FEATURES);
+            cursor.moveToNext();
+        }
+        cursor.moveToPosition(position);
+        return features;
+    }
+
+    /**
+     * Sets whether processing of requests for contact details should be enabled.
+     *
+     * This method should be called in tests to disable such processing of requests when not
+     * needed.
+     */
+    @VisibleForTesting
+    void disableRequestProcessingForTest() {
+        // TODO: Remove this and test the cache directly.
+        mContactInfoCache.disableRequestProcessing(true);
+    }
+
+    @VisibleForTesting
+    void injectContactInfoForTest(String number, String countryIso, ContactInfo contactInfo) {
+        // TODO: Remove this and test the cache directly.
+        mContactInfoCache.injectContactInfoForTest(number, countryIso, contactInfo);
+    }
+
+    /**
+     * Stores the day group associated with a call in the call log.
+     *
+     * @param rowId The row Id of the current call.
+     * @param dayGroup The day group the call belongs in.
+     */
+    @Override
+    public void setDayGroup(long rowId, int dayGroup) {
+        if (!mDayGroups.containsKey(rowId)) {
+            mDayGroups.put(rowId, dayGroup);
+        }
+    }
+
+    /**
+     * Clears the day group associations on re-bind of the call log.
+     */
+    @Override
+    public void clearDayGroups() {
+        mDayGroups.clear();
+    }
+
+    /**
+     * Retrieves the call Ids represented by the current call log row.
+     *
+     * @param cursor Call log cursor to retrieve call Ids from.
+     * @param groupSize Number of calls associated with the current call log row.
+     * @return Array of call Ids.
+     */
+    private long[] getCallIds(final Cursor cursor, final int groupSize) {
+        // We want to restore the position in the cursor at the end.
+        int startingPosition = cursor.getPosition();
+        long[] ids = new long[groupSize];
+        // Copy the ids of the rows in the group.
+        for (int index = 0; index < groupSize; ++index) {
+            ids[index] = cursor.getLong(CallLogQuery.ID);
+            cursor.moveToNext();
+        }
+        cursor.moveToPosition(startingPosition);
+        return ids;
+    }
+
+    /**
+     * Determines the description for a day group.
+     *
+     * @param group The day group to retrieve the description for.
+     * @return The day group description.
+     */
+    private CharSequence getGroupDescription(int group) {
+       if (group == CallLogGroupBuilder.DAY_GROUP_TODAY) {
+           return mContext.getResources().getString(R.string.call_log_header_today);
+       } else if (group == CallLogGroupBuilder.DAY_GROUP_YESTERDAY) {
+           return mContext.getResources().getString(R.string.call_log_header_yesterday);
+       } else {
+           return mContext.getResources().getString(R.string.call_log_header_other);
+       }
+    }
+
+    /**
+     * Determines if the voicemail promo card should be shown or not.  The voicemail promo card will
+     * be shown as the first item in the voicemail tab.
+     */
+    private void maybeShowVoicemailPromoCard() {
+        boolean showPromoCard = mPrefs.getBoolean(SHOW_VOICEMAIL_PROMO_CARD,
+                SHOW_VOICEMAIL_PROMO_CARD_DEFAULT);
+        mShowVoicemailPromoCard = mActivityType != ACTIVITY_TYPE_ARCHIVE &&
+                (mVoicemailPlaybackPresenter != null) && showPromoCard;
+    }
+
+    /**
+     * Dismisses the voicemail promo card and refreshes the call log.
+     */
+    private void dismissVoicemailPromoCard() {
+        mPrefs.edit().putBoolean(SHOW_VOICEMAIL_PROMO_CARD, false).apply();
+        mShowVoicemailPromoCard = false;
+        notifyItemRemoved(VOICEMAIL_PROMO_CARD_POSITION);
+    }
+
+    /**
+     * Creates the view holder for the voicemail promo card.
+     *
+     * @param parent The parent view.
+     * @return The {@link ViewHolder}.
+     */
+    protected ViewHolder createVoicemailPromoCardViewHolder(ViewGroup parent) {
+        LayoutInflater inflater = LayoutInflater.from(mContext);
+        View view = inflater.inflate(R.layout.voicemail_promo_card, parent, false);
+
+        PromoCardViewHolder viewHolder = PromoCardViewHolder.create(view);
+        return viewHolder;
+    }
+
+    /// M: [Dialer Global Search] New Feature CallLogSearch @{
+    private char[] mUpperCaseQueryString;
+
+    // Add for call log search feature
+    public void setQueryString(String queryString) {
+        if (TextUtils.isEmpty(queryString)) {
+            mUpperCaseQueryString = null;
+        } else {
+            mUpperCaseQueryString = queryString.toUpperCase().toCharArray();
+        }
+    }
+    /// @}
+
+    /// M: [VoLTE ConfCallLog] For volte conference callLog @{
+    private static String TAG = "CallLogAdapter";
+
+    private boolean mIsConfCallMemberList = false;
+
+    /**
+     * Is this adapter used to show the conference call member list
+     */
+    public void setIsConfCallMemberList(boolean isConfCallMemberList) {
+        mIsConfCallMemberList = isConfCallMemberList;
+    }
+
+    private ArrayList<String> getConferenceCallNumbers(Cursor cursor, int count) {
+        int position = cursor.getPosition();
+        ArrayList<String> numbers = new ArrayList<String>(count);
+        for (int index = 0; index < count; ++index) {
+            /// M: add postDialDigits when get numbers @{
+            final String postDialDigits = CompatUtils.isNCompatible()
+                    && mActivityType != ACTIVITY_TYPE_ARCHIVE ?
+                    cursor.getString(CallLogQuery.POST_DIAL_DIGITS) : "";
+            numbers.add(cursor.getString(CallLogQuery.NUMBER) + postDialDigits);
+            /// @}
+            cursor.moveToNext();
+        }
+        cursor.moveToPosition(position);
+        return numbers;
+    }
+
+    private long getConferenceCallDate(Cursor cursor, int count) {
+        int position = cursor.getPosition();
+        long minDate = cursor.getLong(CallLogQuery.DATE);
+        for (int index = 1; index < count; ++index) {
+            cursor.moveToNext();
+            long date = cursor.getLong(CallLogQuery.DATE);
+            if (minDate > date) {
+                minDate = date;
+            }
+        }
+        cursor.moveToPosition(position);
+        return minDate;
+    }
+
+    private String getConferenceCallName(Cursor cursor, int count) {
+        int position = cursor.getPosition();
+        ArrayList<CharSequence> names = new ArrayList<CharSequence>(count);
+        for (int index = 0; index < count; ++index) {
+            String name = getName(cursor);
+            if (TextUtils.isEmpty(name)) {
+                /// M: add postDialDigits when show numbers @{
+                final String postDialDigits = CompatUtils.isNCompatible()
+                        && mActivityType != ACTIVITY_TYPE_ARCHIVE ?
+                        cursor.getString(CallLogQuery.POST_DIAL_DIGITS) : "";
+                names.add(cursor.getString(CallLogQuery.NUMBER) + postDialDigits);
+                /// @}
+            } else {
+                names.add(name);
+            }
+            cursor.moveToNext();
+        }
+        cursor.moveToPosition(position);
+        return DialerUtils.join(mContext.getResources(), names).toString();
+    }
+
+    private String getName(Cursor c) {
+        final ContactInfo cachedContactInfo = mContactInfoHelper.getContactInfo(c);
+        final String number = c.getString(CallLogQuery.NUMBER);
+        final int numberPresentation = c.getInt(CallLogQuery.NUMBER_PRESENTATION);
+        final String countryIso = c.getString(CallLogQuery.COUNTRY_ISO);
+        /// M: add postDialDigits when lookup contacts @{
+        final String postDialDigits = CompatUtils.isNCompatible()
+                && mActivityType != ACTIVITY_TYPE_ARCHIVE ?
+                c.getString(CallLogQuery.POST_DIAL_DIGITS) : "";
+        /// @}
+
+        ContactInfo info = ContactInfo.EMPTY;
+        if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation)) {
+            // Lookup contacts with this number
+            info = mContactInfoCache.getValue(number + postDialDigits,
+                    countryIso, cachedContactInfo);
+        }
+        return info.name;
+    }
+    /// @}
+
+    /**
+     * M: To improve scroll performance, using throttle observer to do call fetching @{
+     */
+    private class ThrottledObserver extends ContentObserver {
+        private final Throttle mThrottle;
+
+        public ThrottledObserver(Handler handler, Context context, Runnable runnable,
+                String name) {
+            super(handler);
+            mThrottle = new Throttle(name, runnable, handler, 500, 1500);
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            mThrottle.onEvent();
+        }
+    }
+    /** @}*/
+}
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogListItemViewHolder.java	(revision 14847)
@@ -0,0 +1,893 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.calllog;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.net.Uri;
+import android.provider.CallLog;
+import android.provider.CallLog.Calls;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.telecom.PhoneAccountHandle;
+import android.text.BidiFormatter;
+import android.text.TextDirectionHeuristics;
+import android.text.TextUtils;
+import android.view.ContextMenu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewStub;
+import android.view.ViewTreeObserver;
+import android.widget.LinearLayout;
+import android.widget.QuickContactBadge;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.contacts.common.CallUtil;
+import com.android.contacts.common.ClipboardUtils;
+import com.android.contacts.common.ContactPhotoManager;
+import com.android.contacts.common.ContactPhotoManager.DefaultImageRequest;
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.common.compat.PhoneNumberUtilsCompat;
+import com.android.contacts.common.dialog.CallSubjectDialog;
+import com.android.contacts.common.testing.NeededForTesting;
+import com.android.contacts.common.util.PhoneNumberHelper;
+import com.android.contacts.common.util.UriUtils;
+import com.android.dialer.DialtactsActivity;
+import com.android.dialer.R;
+import com.android.dialer.calllog.calllogcache.CallLogCache;
+import com.android.dialer.compat.FilteredNumberCompat;
+import com.android.dialer.database.FilteredNumberAsyncQueryHandler;
+import com.android.dialer.filterednumber.BlockNumberDialogFragment;
+import com.android.dialer.filterednumber.FilteredNumbersUtil;
+import com.android.dialer.logging.Logger;
+import com.android.dialer.logging.ScreenEvent;
+import com.android.dialer.service.ExtendedBlockingButtonRenderer;
+import com.android.dialer.util.DialerUtils;
+import com.android.dialer.util.PhoneNumberUtil;
+import com.android.dialer.voicemail.VoicemailPlaybackLayout;
+import com.android.dialer.voicemail.VoicemailPlaybackPresenter;
+import com.android.dialerbind.ObjectFactory;
+
+import com.mediatek.dialer.ext.ExtensionManager;
+import com.mediatek.dialer.util.DialerFeatureOptions;
+import com.mediatek.dialer.util.DialerVolteUtils;
+
+import com.google.common.collect.Lists;
+
+import java.util.ArrayList;
+import java.util.List;
+import android.util.Log;
+
+/**
+ * This is an object containing references to views contained by the call log list item. This
+ * improves performance by reducing the frequency with which we need to find views by IDs.
+ *
+ * This object also contains UI logic pertaining to the view, to isolate it from the CallLogAdapter.
+ */
+public final class CallLogListItemViewHolder extends RecyclerView.ViewHolder
+        implements View.OnClickListener, MenuItem.OnMenuItemClickListener,
+        View.OnCreateContextMenuListener {
+
+    /** The root view of the call log list item */
+    public final View rootView;
+    /** The quick contact badge for the contact. */
+    public final QuickContactBadge quickContactView;
+	public final ImageView calllogVolteTypeView;
+    /** The primary action view of the entry. */
+    public final View primaryActionView;
+    /** The details of the phone call. */
+    public final PhoneCallDetailsViews phoneCallDetailsViews;
+    /** The text of the header for a day grouping. */
+    public final TextView dayGroupHeader;
+    /** The view containing the details for the call log row, including the action buttons. */
+    public final CardView callLogEntryView;
+    /** The actionable view which places a call to the number corresponding to the call log row. */
+    public final ImageView primaryActionButtonView;
+
+    /** The view containing call log item actions.  Null until the ViewStub is inflated. */
+    public View actionsView;
+    /** The button views below are assigned only when the action section is expanded. */
+    public VoicemailPlaybackLayout voicemailPlaybackView;
+    public View callButtonView;
+    public View videoCallButtonView;
+    public View createNewContactButtonView;
+    public View addToExistingContactButtonView;
+    public View sendMessageView;
+    public View detailsButtonView;
+    /// M: [IP Dial] For IP Prefix feature
+    public View ipDialButtonView;
+    /** M: [VoLTE ConfCallLog] the conference call numbers if it was conference call @{ */
+    public ArrayList<String> confCallNumbers;
+    /** @} */
+    public View callWithNoteButtonView;
+    public ImageView workIconView;
+	public TextView emergencyNumberView;
+
+    /**
+     * The row Id for the first call associated with the call log entry.  Used as a key for the
+     * map used to track which call log entries have the action button section expanded.
+     */
+    public long rowId;
+
+    /**
+     * The call Ids for the calls represented by the current call log entry.  Used when the user
+     * deletes a call log entry.
+     */
+    public long[] callIds;
+
+    /**
+     * The callable phone number for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public String number;
+
+    /**
+     * The post-dial numbers that are dialed following the phone number.
+     */
+    public String postDialDigits;
+
+    /**
+     * The formatted phone number to display.
+     */
+    public String displayNumber;
+
+    /**
+     * The phone number presentation for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public int numberPresentation;
+
+    /**
+     * The type of the phone number (e.g. main, work, etc).
+     */
+    public String numberType;
+
+    /**
+     * The country iso for the call. Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public String countryIso;
+
+    /**
+     * The type of call for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public int callType;
+	public int isVolteCall;
+
+    /**
+     * ID for blocked numbers database.
+     * Set when context menu is created, if the number is blocked.
+     */
+    public Integer blockId;
+
+    /**
+     * The account for the current call log entry.  Cached here as the call back
+     * intent is set only when the actions ViewStub is inflated.
+     */
+    public PhoneAccountHandle accountHandle;
+
+    /**
+     * If the call has an associated voicemail message, the URI of the voicemail message for
+     * playback.  Cached here as the voicemail intent is only set when the actions ViewStub is
+     * inflated.
+     */
+    public String voicemailUri;
+
+    /**
+     * The name or number associated with the call.  Cached here for use when setting content
+     * descriptions on buttons in the actions ViewStub when it is inflated.
+     */
+    public CharSequence nameOrNumber;
+
+    /**
+     * The call type or Location associated with the call. Cached here for use when setting text
+     * for a voicemail log's call button
+     */
+    public CharSequence callTypeOrLocation;
+
+    /**
+     * Whether this row is for a business or not.
+     */
+    public boolean isBusiness;
+
+    /**
+     * The contact info for the contact displayed in this list item.
+     */
+    public ContactInfo info;
+
+    /**
+     * Whether the current log entry is a blocked number or not. Used in updatePhoto()
+     */
+    public boolean isBlocked;
+
+    /**
+     * Whether this is the archive tab or not.
+     */
+    public final boolean isArchiveTab;
+
+    private final Context mContext;
+    private final CallLogCache mCallLogCache;
+    private final CallLogListItemHelper mCallLogListItemHelper;
+    private final VoicemailPlaybackPresenter mVoicemailPlaybackPresenter;
+    private final FilteredNumberAsyncQueryHandler mFilteredNumberAsyncQueryHandler;
+
+    private final BlockNumberDialogFragment.Callback mFilteredNumberDialogCallback;
+
+    private final int mPhotoSize;
+    private ViewStub mExtendedBlockingViewStub;
+    private final ExtendedBlockingButtonRenderer mExtendedBlockingButtonRenderer;
+
+    private View.OnClickListener mExpandCollapseListener;
+    private boolean mVoicemailPrimaryActionButtonClicked;
+
+    private CallLogListItemViewHolder(
+            Context context,
+            ExtendedBlockingButtonRenderer.Listener eventListener,
+            View.OnClickListener expandCollapseListener,
+            CallLogCache callLogCache,
+            CallLogListItemHelper callLogListItemHelper,
+            VoicemailPlaybackPresenter voicemailPlaybackPresenter,
+            FilteredNumberAsyncQueryHandler filteredNumberAsyncQueryHandler,
+            BlockNumberDialogFragment.Callback filteredNumberDialogCallback,
+            View rootView,
+            QuickContactBadge quickContactView,
+			ImageView calllogVolteTypeView,
+            View primaryActionView,
+            PhoneCallDetailsViews phoneCallDetailsViews,
+            CardView callLogEntryView,
+            TextView dayGroupHeader,
+            ImageView primaryActionButtonView,
+            TextView emergencyNumberView,
+            boolean isArchiveTab) {
+        super(rootView);
+
+        mContext = context;
+        mExpandCollapseListener = expandCollapseListener;
+        mCallLogCache = callLogCache;
+        mCallLogListItemHelper = callLogListItemHelper;
+        mVoicemailPlaybackPresenter = voicemailPlaybackPresenter;
+        mFilteredNumberAsyncQueryHandler = filteredNumberAsyncQueryHandler;
+        mFilteredNumberDialogCallback = filteredNumberDialogCallback;
+
+        this.rootView = rootView;
+        this.quickContactView = quickContactView;
+		this.calllogVolteTypeView = calllogVolteTypeView;
+        this.primaryActionView = primaryActionView;
+        this.phoneCallDetailsViews = phoneCallDetailsViews;
+        this.callLogEntryView = callLogEntryView;
+        this.dayGroupHeader = dayGroupHeader;
+        this.primaryActionButtonView = primaryActionButtonView;
+        this.workIconView = (ImageView) rootView.findViewById(R.id.work_profile_icon);
+		this.emergencyNumberView=(TextView)rootView.findViewById(R.id.emergency_call);
+        this.isArchiveTab = isArchiveTab;
+        Resources resources = mContext.getResources();
+        mPhotoSize = mContext.getResources().getDimensionPixelSize(R.dimen.contact_photo_size);
+
+        // Set text height to false on the TextViews so they don't have extra padding.
+        phoneCallDetailsViews.nameView.setElegantTextHeight(false);
+        phoneCallDetailsViews.callLocationAndDate.setElegantTextHeight(false);
+
+        quickContactView.setOverlay(null);
+        if (CompatUtils.hasPrioritizedMimeType()) {
+            quickContactView.setPrioritizedMimeType(Phone.CONTENT_ITEM_TYPE);
+        }
+        primaryActionButtonView.setOnClickListener(this);
+        primaryActionView.setOnClickListener(mExpandCollapseListener);
+        primaryActionView.setOnCreateContextMenuListener(this);
+        mExtendedBlockingButtonRenderer =
+                ObjectFactory.newExtendedBlockingButtonRenderer(mContext, eventListener);
+    }
+
+    public static CallLogListItemViewHolder create(
+            View view,
+            Context context,
+            ExtendedBlockingButtonRenderer.Listener eventListener,
+            View.OnClickListener expandCollapseListener,
+            CallLogCache callLogCache,
+            CallLogListItemHelper callLogListItemHelper,
+            VoicemailPlaybackPresenter voicemailPlaybackPresenter,
+            FilteredNumberAsyncQueryHandler filteredNumberAsyncQueryHandler,
+            BlockNumberDialogFragment.Callback filteredNumberDialogCallback,
+            boolean isArchiveTab) {
+
+        return new CallLogListItemViewHolder(
+                context,
+                eventListener,
+                expandCollapseListener,
+                callLogCache,
+                callLogListItemHelper,
+                voicemailPlaybackPresenter,
+                filteredNumberAsyncQueryHandler,
+                filteredNumberDialogCallback,
+                view,
+                (QuickContactBadge) view.findViewById(R.id.quick_contact_photo),
+				(ImageView) view.findViewById(R.id.calllog_volte_type),
+                view.findViewById(R.id.primary_action_view),
+                PhoneCallDetailsViews.fromView(view),
+                (CardView) view.findViewById(R.id.call_log_row),
+                (TextView) view.findViewById(R.id.call_log_day_group_label),
+                (ImageView) view.findViewById(R.id.primary_action_button),
+                (TextView)view.findViewById(R.id.emergency_call),
+                isArchiveTab);
+    }
+
+    @Override
+    public void onCreateContextMenu(
+            final ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+        if (TextUtils.isEmpty(number)) {
+            return;
+        }
+
+        if (callType == CallLog.Calls.VOICEMAIL_TYPE) {
+            menu.setHeaderTitle(mContext.getResources().getText(R.string.voicemail));
+        } else {
+            menu.setHeaderTitle(PhoneNumberUtilsCompat.createTtsSpannable(
+                    BidiFormatter.getInstance().unicodeWrap(number, TextDirectionHeuristics.LTR)));
+        }
+
+        menu.add(ContextMenu.NONE, R.id.context_menu_copy_to_clipboard, ContextMenu.NONE,
+                R.string.action_copy_number_text)
+                .setOnMenuItemClickListener(this);
+
+        // The edit number before call does not show up if any of the conditions apply:
+        // 1) Number cannot be called
+        // 2) Number is the voicemail number
+        // 3) Number is a SIP address
+
+        if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation)
+                && !mCallLogCache.isVoicemailNumber(accountHandle, number)
+                && !PhoneNumberUtil.isSipNumber(number)) {
+            menu.add(ContextMenu.NONE, R.id.context_menu_edit_before_call, ContextMenu.NONE,
+                    R.string.action_edit_number_before_call)
+                    .setOnMenuItemClickListener(this);
+        }
+
+        if (callType == CallLog.Calls.VOICEMAIL_TYPE
+                && phoneCallDetailsViews.voicemailTranscriptionView.length() > 0) {
+            menu.add(ContextMenu.NONE, R.id.context_menu_copy_transcript_to_clipboard,
+                    ContextMenu.NONE, R.string.copy_transcript_text)
+                    .setOnMenuItemClickListener(this);
+        }
+
+        if (FilteredNumberCompat.canAttemptBlockOperations(mContext)
+                && FilteredNumbersUtil.canBlockNumber(mContext, number, countryIso)) {
+            mFilteredNumberAsyncQueryHandler.isBlockedNumber(
+                    new FilteredNumberAsyncQueryHandler.OnCheckBlockedListener() {
+                        @Override
+                        public void onCheckComplete(Integer id) {
+                            blockId = id;
+                            int blockTitleId = blockId == null ? R.string.action_block_number
+                                    : R.string.action_unblock_number;
+                            final MenuItem blockItem = menu.add(
+                                    ContextMenu.NONE,
+                                    R.id.context_menu_block_number,
+                                    ContextMenu.NONE,
+                                    blockTitleId);
+                            blockItem.setOnMenuItemClickListener(
+                                    CallLogListItemViewHolder.this);
+                        }
+                    }, number, countryIso);
+        }
+
+        Logger.logScreenView(ScreenEvent.CALL_LOG_CONTEXT_MENU, (Activity) mContext);
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        int resId = item.getItemId();
+        if (resId == R.id.context_menu_block_number) {
+            /**
+             * M:find parent view for block number dialog.
+             * Use parent view to avoid current listitem view be recycled during scroling.@{
+             * */
+            View v = ((Activity) mContext).findViewById(R.id.floating_action_button_container);
+            int parentViewId = (v == null) ? ((View)rootView.getParent()).getId()
+                    : R.id.floating_action_button_container;
+            /**@}*/
+            /// M: Do not show dialog if activity is finish. @{
+            if (((Activity) mContext).isFinishing() || ((Activity) mContext).isDestroyed()) {
+                return true;
+            }
+            /// @}
+            FilteredNumberCompat
+                    .showBlockNumberDialogFlow(mContext.getContentResolver(), blockId, number,
+                            countryIso, displayNumber,
+                            parentViewId/**M:R.id.floating_action_button_container*/,
+                            ((Activity) mContext).getFragmentManager(),
+                            mFilteredNumberDialogCallback);
+            return true;
+        } else if (resId == R.id.context_menu_copy_to_clipboard) {
+            ClipboardUtils.copyText(mContext, null, number, true);
+            return true;
+        } else if (resId == R.id.context_menu_copy_transcript_to_clipboard) {
+            ClipboardUtils.copyText(mContext, null,
+                    phoneCallDetailsViews.voicemailTranscriptionView.getText(), true);
+            return true;
+        } else if (resId == R.id.context_menu_edit_before_call) {
+            final Intent intent = new Intent(
+                    Intent.ACTION_DIAL, CallUtil.getCallUri(number));
+            intent.setClass(mContext, DialtactsActivity.class);
+            DialerUtils.startActivityWithErrorToast(mContext, intent);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Configures the action buttons in the expandable actions ViewStub. The ViewStub is not
+     * inflated during initial binding, so click handlers, tags and accessibility text must be set
+     * here, if necessary.
+     */
+    public void inflateActionViewStub() {
+        ViewStub stub = (ViewStub) rootView.findViewById(R.id.call_log_entry_actions_stub);
+        if (stub != null) {
+            actionsView = stub.inflate();
+
+            voicemailPlaybackView = (VoicemailPlaybackLayout) actionsView
+                    .findViewById(R.id.voicemail_playback_layout);
+            if (isArchiveTab) {
+                voicemailPlaybackView.hideArchiveButton();
+            }
+
+
+            callButtonView = actionsView.findViewById(R.id.call_action);
+            callButtonView.setOnClickListener(this);
+
+            videoCallButtonView = actionsView.findViewById(R.id.video_call_action);
+            videoCallButtonView.setOnClickListener(this);
+
+            createNewContactButtonView = actionsView.findViewById(R.id.create_new_contact_action);
+            createNewContactButtonView.setOnClickListener(this);
+
+            addToExistingContactButtonView =
+                    actionsView.findViewById(R.id.add_to_existing_contact_action);
+            addToExistingContactButtonView.setOnClickListener(this);
+
+            sendMessageView = actionsView.findViewById(R.id.send_message_action);
+            sendMessageView.setOnClickListener(this);
+
+            detailsButtonView = actionsView.findViewById(R.id.details_action);
+            detailsButtonView.setOnClickListener(this);
+
+            /** M: [IP Dial] add IP Dial @{ */
+            ipDialButtonView = actionsView.findViewById(R.id.ipdial_action);
+            ipDialButtonView.setOnClickListener(this);
+            /** @} */
+
+            callWithNoteButtonView = actionsView.findViewById(R.id.call_with_note_action);
+            callWithNoteButtonView.setOnClickListener(this);
+
+            mExtendedBlockingViewStub =
+                    (ViewStub) actionsView.findViewById(R.id.extended_blocking_actions_container);
+        }
+
+        bindActionButtons();
+    }
+
+    private void updatePrimaryActionButton(boolean isExpanded) {
+        if (!TextUtils.isEmpty(voicemailUri)) {
+            // Treat as voicemail list item; show play button if not expanded.
+            if (!isExpanded) {
+                primaryActionButtonView.setImageResource(R.drawable.ic_play_arrow_24dp);
+                primaryActionButtonView.setContentDescription(TextUtils.expandTemplate(
+                        mContext.getString(R.string.description_voicemail_action),
+                        nameOrNumber));
+                primaryActionButtonView.setVisibility(View.VISIBLE);
+            } else {
+                primaryActionButtonView.setVisibility(View.GONE);
+            }
+        } else {
+            // Treat as normal list item; show call button, if possible.
+            if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation)) {
+                boolean isVoicemailNumber =
+                        mCallLogCache.isVoicemailNumber(accountHandle, number);
+                /// M: [Suggested Account] Supporting suggested account @{
+                /// Give all the calls a suggestion first.
+                if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                    primaryActionButtonView.setTag(IntentProvider
+                            .getSuggestedReturnCallIntentProvider(number + postDialDigits,
+                                    accountHandle));
+                /// @}
+                } else if (isVoicemailNumber) {
+                    // Call to generic voicemail number, in case there are multiple accounts.
+                    primaryActionButtonView.setTag(
+                            IntentProvider.getReturnVoicemailCallIntentProvider());
+                } else {
+                    primaryActionButtonView.setTag(IntentProvider
+                            .getReturnCallIntentProvider(number + postDialDigits));
+                }
+                /** M: [IMS Call] For Volte IMS call @{ */
+                if (DialerFeatureOptions.isImsCallSupport()
+                        && PhoneNumberHelper.isUriNumber(number)
+                        && PhoneAccountUtils.isSubScriptionAccount(mContext, accountHandle)) {
+                    primaryActionButtonView.setTag(
+                            IntentProvider.getReturnIMSCallIntentProvider(number + postDialDigits));
+                }
+                /** @} */
+
+                primaryActionButtonView.setContentDescription(TextUtils.expandTemplate(
+                        mContext.getString(R.string.description_call_action),
+                        nameOrNumber));
+                primaryActionButtonView.setImageResource(R.drawable.ic_call_24dp);
+                primaryActionButtonView.setVisibility(View.VISIBLE);
+                /** M: [VoLTE ConfCallLog] For Volte Conference callLog @{ */
+                if (confCallNumbers != null) {
+                    if (DialerVolteUtils.isVolteConfCallEnable(mContext)) {
+                        primaryActionButtonView.setTag(IntentProvider
+                                .getReturnVolteConfCallIntentProvider(confCallNumbers));
+                    } else {
+                        primaryActionButtonView.setTag(null);
+                        primaryActionButtonView.setVisibility(View.GONE);
+                    }
+                }
+                /** @} */
+            } else {
+                primaryActionButtonView.setTag(null);
+                primaryActionButtonView.setVisibility(View.GONE);
+            }
+        }
+    }
+
+    /**
+     * Binds text titles, click handlers and intents to the voicemail, details and callback action
+     * buttons.
+     */
+    private void bindActionButtons() {
+        /** M: [VoLTE ConfCallLog] Only show call detail button for conference callLog @{ */
+        if (confCallNumbers != null) {
+            callButtonView.setVisibility(View.GONE);
+            videoCallButtonView.setVisibility(View.GONE);
+            voicemailPlaybackView.setVisibility(View.GONE);
+            createNewContactButtonView.setVisibility(View.GONE);
+            addToExistingContactButtonView.setVisibility(View.GONE);
+            sendMessageView.setVisibility(View.GONE);
+            ipDialButtonView.setVisibility(View.GONE);
+            callWithNoteButtonView.setVisibility(View.GONE);
+            detailsButtonView.setVisibility(View.VISIBLE);
+            detailsButtonView.setTag(
+                    IntentProvider.getCallDetailIntentProvider(
+                            rowId, callIds, null, true));
+            return;
+        } else {
+            // Other buttons will change its visible at below code of this
+            // method except sendMessageView. So, make it visible.
+            sendMessageView.setVisibility(View.VISIBLE);
+        }
+        /** @} */
+
+        boolean canPlaceCallToNumber =
+                PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation);
+
+        if (!TextUtils.isEmpty(voicemailUri) && canPlaceCallToNumber) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                callButtonView.setTag(IntentProvider
+                        .getSuggestedReturnCallIntentProvider(number,
+                                accountHandle));
+            } else {
+                callButtonView.setTag(IntentProvider
+                        .getReturnCallIntentProvider(number));
+            }
+            /// @}
+            ((TextView) callButtonView.findViewById(R.id.call_action_text))
+                    .setText(TextUtils.expandTemplate(
+                            mContext.getString(R.string.call_log_action_call),
+                            nameOrNumber));
+            TextView callTypeOrLocationView = ((TextView) callButtonView.findViewById(
+                    R.id.call_type_or_location_text));
+            if (callType == Calls.VOICEMAIL_TYPE && !TextUtils.isEmpty(callTypeOrLocation)) {
+                callTypeOrLocationView.setText(callTypeOrLocation);
+                callTypeOrLocationView.setVisibility(View.VISIBLE);
+            } else {
+                callTypeOrLocationView.setVisibility(View.GONE);
+            }
+            callButtonView.setVisibility(View.VISIBLE);
+        } else {
+            callButtonView.setVisibility(View.GONE);
+        }
+
+        // If one of the calls had video capabilities, show the video call button.
+        // if (mCallLogCache.isVideoEnabled() && canPlaceCallToNumber &&
+        //        phoneCallDetailsViews.callTypeIcons.isVideoShown()) {
+        /// M: using plugin API to override the video button showing logic.
+        /// NOTE: the parameters should be passed as the index defined in ICallLogExtension
+        boolean isVideoButtonEnabled =
+                ExtensionManager.getInstance().getCallLogExtension().isVideoButtonEnabled(
+                mCallLogCache.isVideoEnabled(), canPlaceCallToNumber,
+                phoneCallDetailsViews.callTypeIcons.isVideoShown(),
+                phoneCallDetailsViews.callTypeIcons,
+                number, info != null ? info.lookupUri : null);
+        if (isVideoButtonEnabled) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                videoCallButtonView.setTag(IntentProvider
+                        .getSuggestedReturnVideoCallIntentProvider(number,
+                                accountHandle));
+            } else {
+                videoCallButtonView.setTag(IntentProvider
+                        .getReturnVideoCallIntentProvider(number));
+            }
+            /// @}
+            videoCallButtonView.setVisibility(View.VISIBLE);
+        } else {
+            videoCallButtonView.setVisibility(View.GONE);
+        }
+
+        // For voicemail calls, show the voicemail playback layout; hide otherwise.
+        if (callType == Calls.VOICEMAIL_TYPE && mVoicemailPlaybackPresenter != null
+                && !TextUtils.isEmpty(voicemailUri)) {
+            voicemailPlaybackView.setVisibility(View.VISIBLE);
+
+            Uri uri = Uri.parse(voicemailUri);
+            mVoicemailPlaybackPresenter.setPlaybackView(
+                    voicemailPlaybackView, uri, mVoicemailPrimaryActionButtonClicked);
+            mVoicemailPrimaryActionButtonClicked = false;
+            // Only mark voicemail as read when not in archive tab
+            if (!isArchiveTab) {
+                CallLogAsyncTaskUtil.markVoicemailAsRead(mContext, uri);
+            }
+        } else {
+            voicemailPlaybackView.setVisibility(View.GONE);
+        }
+
+        if (callType == Calls.VOICEMAIL_TYPE) {
+            detailsButtonView.setVisibility(View.GONE);
+        } else {
+            detailsButtonView.setVisibility(View.VISIBLE);
+            detailsButtonView.setTag(
+                    IntentProvider.getCallDetailIntentProvider(rowId, callIds, null));
+        }
+
+        if (info != null && UriUtils.isEncodedContactUri(info.lookupUri)) {
+            createNewContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(
+                    info.lookupUri, info.name, info.number, info.type, true /* isNewContact */));
+            createNewContactButtonView.setVisibility(View.VISIBLE);
+
+            addToExistingContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(
+                    info.lookupUri, info.name, info.number, info.type, false /* isNewContact */));
+            addToExistingContactButtonView.setVisibility(View.VISIBLE);
+        } else {
+            createNewContactButtonView.setVisibility(View.GONE);
+            addToExistingContactButtonView.setVisibility(View.GONE);
+        }
+
+        if (canPlaceCallToNumber) {
+            sendMessageView.setTag(IntentProvider.getSendSmsIntentProvider(number));
+            sendMessageView.setVisibility(View.VISIBLE);
+        } else {
+            sendMessageView.setVisibility(View.GONE);
+        }
+
+        /** M: [IP Dial] Add IP Dial @{ */
+        if (DialerFeatureOptions.isIpPrefixSupport() && canPlaceCallToNumber
+                && !PhoneNumberHelper.isUriNumber(number)) {
+            /// M: [Suggested Account] Supporting suggested account @{
+            if (DialerFeatureOptions.isSuggestedAccountSupport()) {
+                ipDialButtonView.setTag(IntentProvider
+                        .getSuggestedIpDialCallIntentProvider(number, accountHandle));
+            } else {
+                ipDialButtonView.setTag(IntentProvider
+                        .getIpDialCallIntentProvider(number));
+            }
+            /// @}
+            ipDialButtonView.setVisibility(View.VISIBLE);
+        } else {
+            ipDialButtonView.setVisibility(View.GONE);
+        }
+        /** @} */
+        mCallLogListItemHelper.setActionContentDescriptions(this);
+
+        boolean supportsCallSubject =
+                mCallLogCache.doesAccountSupportCallSubject(accountHandle);
+        boolean isVoicemailNumber =
+                mCallLogCache.isVoicemailNumber(accountHandle, number);
+        callWithNoteButtonView.setVisibility(
+                supportsCallSubject && !isVoicemailNumber ? View.VISIBLE : View.GONE);
+
+        if(mExtendedBlockingButtonRenderer != null){
+            List<View> completeLogListItems = Lists.newArrayList(
+                    createNewContactButtonView,
+                    addToExistingContactButtonView,
+                    sendMessageView,
+                    callButtonView,
+                    callWithNoteButtonView,
+                    detailsButtonView,
+                    voicemailPlaybackView);
+
+            List<View> blockedNumberVisibleViews = Lists.newArrayList(detailsButtonView);
+            List<View> extendedBlockingVisibleViews = Lists.newArrayList(detailsButtonView);
+
+            ExtendedBlockingButtonRenderer.ViewHolderInfo viewHolderInfo =
+                    new ExtendedBlockingButtonRenderer.ViewHolderInfo(
+                            completeLogListItems,
+                            extendedBlockingVisibleViews,
+                            blockedNumberVisibleViews,
+                            number,
+                            countryIso,
+                            nameOrNumber.toString(),
+                            displayNumber);
+            mExtendedBlockingButtonRenderer.setViewHolderInfo(viewHolderInfo);
+
+            mExtendedBlockingButtonRenderer.render(mExtendedBlockingViewStub);
+        }
+
+       ///M: Plug-in call to customize Action buttons
+        ExtensionManager.getInstance().getCallLogExtension().
+                                           customizeBindActionButtons(this);
+    }
+
+    /**
+     * Show or hide the action views, such as voicemail, details, and add contact.
+     *
+     * If the action views have never been shown yet for this view, inflate the view stub.
+     */
+    public void showActions(boolean show) {
+        showOrHideVoicemailTranscriptionView(show);
+
+        if (show) {
+            // Inflate the view stub if necessary, and wire up the event handlers.
+            inflateActionViewStub();
+
+            actionsView.setVisibility(View.VISIBLE);
+            actionsView.setAlpha(1.0f);
+        } else {
+            // When recycling a view, it is possible the actionsView ViewStub was previously
+            // inflated so we should hide it in this case.
+            if (actionsView != null) {
+                actionsView.setVisibility(View.GONE);
+            }
+        }
+
+        updatePrimaryActionButton(show);
+
+        /// M: add for plug-in. @{
+        ExtensionManager.getInstance().getCallLogExtension().showActions(this, show);
+        /// @}
+
+    }
+
+    public void showOrHideVoicemailTranscriptionView(boolean isExpanded) {
+        if (callType != Calls.VOICEMAIL_TYPE) {
+            return;
+        }
+
+        final TextView view = phoneCallDetailsViews.voicemailTranscriptionView;
+        if (!isExpanded || TextUtils.isEmpty(view.getText())) {
+            view.setVisibility(View.GONE);
+            return;
+        }
+        view.setVisibility(View.VISIBLE);
+    }
+
+    public void updatePhoto() {
+        quickContactView.assignContactUri(info.lookupUri);
+
+        final boolean isVoicemail = mCallLogCache.isVoicemailNumber(accountHandle, number);
+        int contactType = ContactPhotoManager.TYPE_DEFAULT;
+        if (isVoicemail) {
+            contactType = ContactPhotoManager.TYPE_VOICEMAIL;
+        } else if (isBusiness) {
+            contactType = ContactPhotoManager.TYPE_BUSINESS;
+        }
+        /// M: [VoLTE ConfCallLog] Show Volte Conference contact icon @{
+        final boolean isConference = confCallNumbers != null;
+        if (isConference) {
+            contactType = ContactPhotoManager.TYPE_CONFERENCE_CALL;
+            quickContactView.assignContactUri(null);
+        }
+        /// @}
+
+        final String lookupKey = isConference ? null : UriUtils.getLookupKeyFromUri(info.lookupUri);
+        final String displayName = TextUtils.isEmpty(info.name) ? displayNumber : info.name;
+        final DefaultImageRequest request = new DefaultImageRequest(
+                displayName, lookupKey, contactType, true /* isCircular */);
+
+        /// M: if this contact is SIM contact,call log need show SIM icon @{
+        request.subId = info.contactSimId;
+        request.photoId = info.isSdnContact;
+        /// @}
+
+        /// M: if is conference call, just show conference contact photo
+        if (info.photoId == 0 && info.photoUri != null && !isConference) {
+            ContactPhotoManager.getInstance(mContext).loadPhoto(quickContactView, info.photoUri,
+                    mPhotoSize, false /* darkTheme */, true /* isCircular */, request);
+        } else {
+            ContactPhotoManager.getInstance(mContext).loadThumbnail(quickContactView,
+                    isConference ? 0 : info.photoId,
+                    false /* darkTheme */, true /* isCircular */, request);
+        }
+
+        if (mExtendedBlockingButtonRenderer != null) {
+            mExtendedBlockingButtonRenderer.updatePhotoAndLabelIfNecessary(
+                    number,
+                    countryIso,
+                    quickContactView,
+                    phoneCallDetailsViews.callLocationAndDate);
+        }
+    }
+
+    @Override
+    public void onClick(View view) {
+        if (view.getId() == R.id.primary_action_button && !TextUtils.isEmpty(voicemailUri)) {
+            mVoicemailPrimaryActionButtonClicked = true;
+            mExpandCollapseListener.onClick(primaryActionView);
+        } else if (view.getId() == R.id.call_with_note_action) {
+            CallSubjectDialog.start(
+                    (Activity) mContext,
+                    info.photoId,
+                    info.photoUri,
+                    info.lookupUri,
+                    (String) nameOrNumber /* top line of contact view in call subject dialog */,
+                    isBusiness,
+                    number,
+                    TextUtils.isEmpty(info.name) ? null : displayNumber, /* second line of contact
+                                                                           view in dialog. */
+                    numberType, /* phone number type (e.g. mobile) in second line of contact view */
+                    accountHandle);
+        } else {
+            final IntentProvider intentProvider = (IntentProvider) view.getTag();
+            if (intentProvider != null) {
+                final Intent intent = intentProvider.getIntent(mContext);
+                // See IntentProvider.getCallDetailIntentProvider() for why this may be null.
+                if (intent != null) {
+                    DialerUtils.startActivityWithErrorToast(mContext, intent);
+                }
+            }
+        }
+    }
+
+    @NeededForTesting
+    public static CallLogListItemViewHolder createForTest(Context context) {
+        Resources resources = context.getResources();
+        CallLogCache callLogCache =
+                CallLogCache.getCallLogCache(context);
+        PhoneCallDetailsHelper phoneCallDetailsHelper = new PhoneCallDetailsHelper(
+                context, resources, callLogCache);
+
+        CallLogListItemViewHolder viewHolder = new CallLogListItemViewHolder(
+                context,
+                null,
+                null /* expandCollapseListener */,
+                callLogCache,
+                new CallLogListItemHelper(phoneCallDetailsHelper, resources, callLogCache),
+                null /* voicemailPlaybackPresenter */,
+                null /* filteredNumberAsyncQueryHandler */,
+                null /* filteredNumberDialogCallback */,
+                new View(context),
+                new QuickContactBadge(context),
+				new ImageView(context),
+                new LinearLayout(context) /*M: primaryActionView */,
+                PhoneCallDetailsViews.createForTest(context),
+                new CardView(context),
+                new TextView(context),
+                new ImageView(context),
+                new TextView(context),
+                false);
+        viewHolder.detailsButtonView = new TextView(context);
+        viewHolder.actionsView = new View(context);
+        viewHolder.voicemailPlaybackView = new VoicemailPlaybackLayout(context);
+        viewHolder.workIconView = new ImageButton(context);
+		viewHolder.emergencyNumberView= new TextView(context);
+        return viewHolder;
+    }
+}
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogQuery.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogQuery.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/src/com/android/dialer/calllog/CallLogQuery.java	(revision 14847)
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.calllog;
+
+import com.google.common.collect.Lists;
+
+import android.provider.CallLog.Calls;
+import android.provider.ContactsContract.Contacts;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.RawContacts;
+
+import com.mediatek.dialer.util.DialerFeatureOptions;
+
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.dialer.compat.CallsSdkCompat;
+import com.android.dialer.compat.DialerCompatUtils;
+
+import java.util.List;
+
+/**
+ * The query for the call log table.
+ */
+public final class CallLogQuery {
+
+    public static final String[] _PROJECTION_INTERNAL = new String[] {
+            Calls._ID,                          // 0
+            Calls.NUMBER,                       // 1
+            Calls.DATE,                         // 2
+            Calls.DURATION,                     // 3
+            Calls.TYPE,                         // 4
+            Calls.COUNTRY_ISO,                  // 5
+            Calls.VOICEMAIL_URI,                // 6
+            Calls.GEOCODED_LOCATION,            // 7
+            Calls.CACHED_NAME,                  // 8
+            Calls.CACHED_NUMBER_TYPE,           // 9
+            Calls.CACHED_NUMBER_LABEL,          // 10
+            Calls.CACHED_LOOKUP_URI,            // 11
+            Calls.CACHED_MATCHED_NUMBER,        // 12
+            Calls.CACHED_NORMALIZED_NUMBER,     // 13
+            Calls.CACHED_PHOTO_ID,              // 14
+            Calls.CACHED_FORMATTED_NUMBER,      // 15
+            Calls.IS_READ,                      // 16
+            Calls.NUMBER_PRESENTATION,          // 17
+            Calls.PHONE_ACCOUNT_COMPONENT_NAME, // 18
+            Calls.PHONE_ACCOUNT_ID,             // 19
+            Calls.FEATURES,                     // 20
+            Calls.DATA_USAGE,                   // 21
+            Calls.TRANSCRIPTION,                // 22
+			Calls.IS_VOLTE_CALL,                // 23
+    };
+
+    public static final int ID = 0;
+    public static final int NUMBER = 1;
+    public static final int DATE = 2;
+    public static final int DURATION = 3;
+    public static final int CALL_TYPE = 4;
+    public static final int COUNTRY_ISO = 5;
+    public static final int VOICEMAIL_URI = 6;
+    public static final int GEOCODED_LOCATION = 7;
+    public static final int CACHED_NAME = 8;
+    public static final int CACHED_NUMBER_TYPE = 9;
+    public static final int CACHED_NUMBER_LABEL = 10;
+    public static final int CACHED_LOOKUP_URI = 11;
+    public static final int CACHED_MATCHED_NUMBER = 12;
+    public static final int CACHED_NORMALIZED_NUMBER = 13;
+    public static final int CACHED_PHOTO_ID = 14;
+    public static final int CACHED_FORMATTED_NUMBER = 15;
+    public static final int IS_READ = 16;
+    public static final int NUMBER_PRESENTATION = 17;
+    public static final int ACCOUNT_COMPONENT_NAME = 18;
+    public static final int ACCOUNT_ID = 19;
+    public static final int FEATURES = 20;
+    public static final int DATA_USAGE = 21;
+    public static final int TRANSCRIPTION = 22;
+	public static final int IS_VOLTE_CALL = 23;
+
+    /// M: [VoLTE ConfCallLog] For Volte conference call calllog
+    public static int CONFERENCE_CALL_ID = -1;
+
+    // Indices for columns that may not be available, depending on the Sdk Version
+    /**
+     * Only available in versions >= M
+     * Call {@link DialerCompatUtils#isCallsCachedPhotoUriCompatible()} prior to use
+     */
+    public static int CACHED_PHOTO_URI = -1;
+
+    /**
+     * Only available in versions > M
+     * Call {@link CompatUtils#isNCompatible()} prior to use
+     */
+    public static int POST_DIAL_DIGITS = -1;
+    public static int VIA_NUMBER = -1;
+
+    public static final String[] _PROJECTION;
+
+    static {
+        List<String> projectionList = Lists.newArrayList(_PROJECTION_INTERNAL);
+        if (DialerCompatUtils.isCallsCachedPhotoUriCompatible()) {
+            projectionList.add(Calls.CACHED_PHOTO_URI);
+            CACHED_PHOTO_URI = projectionList.size() - 1;
+        }
+        if (CompatUtils.isNCompatible()) {
+            projectionList.add(CallsSdkCompat.POST_DIAL_DIGITS);
+            POST_DIAL_DIGITS = projectionList.size() - 1;
+            projectionList.add(CallsSdkCompat.VIA_NUMBER);
+            VIA_NUMBER = projectionList.size() - 1;
+        }
+
+        /// M: [VoLTE ConfCallLog] For Volte conference call calllog. @{
+        if (DialerFeatureOptions.isVolteConfCallLogSupport()) {
+            projectionList.add(Calls.CONFERENCE_CALL_ID);
+            CONFERENCE_CALL_ID = projectionList.size() - 1;
+        }
+        /// @}
+
+        /// M:[MTK SIM Contacts feature] @{
+        if (DialerFeatureOptions.isSimContactsSupport()) {
+            projectionList.add(Calls.CACHED_INDICATE_PHONE_SIM);
+            projectionList.add(Calls.CACHED_IS_SDN_CONTACT);
+        }
+        /// @}
+
+        _PROJECTION = projectionList.toArray(new String[projectionList.size()]);
+    }
+}
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-hdpi/ic_calllog_volte_type.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-hdpi/ic_calllog_volte_type.png
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-hdpi/ic_calllog_volte_type.png	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-hdpi/ic_calllog_volte_type.png	(revision 14847)

Property changes on: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-hdpi/ic_calllog_volte_type.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-mdpi/ic_calllog_volte_type.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-mdpi/ic_calllog_volte_type.png
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-mdpi/ic_calllog_volte_type.png	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-mdpi/ic_calllog_volte_type.png	(revision 14847)

Property changes on: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-mdpi/ic_calllog_volte_type.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-xhdpi/ic_calllog_volte_type.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-xhdpi/ic_calllog_volte_type.png
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-xhdpi/ic_calllog_volte_type.png	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-xhdpi/ic_calllog_volte_type.png	(revision 14847)

Property changes on: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/drawable-xhdpi/ic_calllog_volte_type.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/layout/call_log_list_item.xml
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/layout/call_log_list_item.xml	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/res/layout/call_log_list_item.xml	(revision 14847)
@@ -0,0 +1,215 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/call_log_list_item"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical">
+
+    <!-- Day group heading. Used to show a "today", "yesterday", "last week" or "other" heading
+         above a group of call log entries. -->
+    <TextView
+        android:id="@+id/call_log_day_group_label"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="start"
+        android:layout_marginStart="@dimen/call_log_start_margin"
+        android:layout_marginEnd="@dimen/call_log_outer_margin"
+        android:fontFamily="sans-serif-medium"
+        android:textColor="@color/call_log_day_group_heading_color"
+        android:textSize="@dimen/call_log_day_group_heading_size"
+        android:paddingTop="@dimen/call_log_day_group_padding_top"
+        android:paddingBottom="@dimen/call_log_day_group_padding_bottom" />
+
+    <android.support.v7.widget.CardView
+        android:id="@+id/call_log_row"
+        style="@style/CallLogCardStyle">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <!-- Primary area containing the contact badge and caller information -->
+            <LinearLayout
+                android:id="@+id/primary_action_view"
+                android:background="?android:attr/selectableItemBackground"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:paddingStart="@dimen/call_log_start_margin"
+                android:paddingEnd="@dimen/call_log_outer_margin"
+                android:paddingTop="@dimen/call_log_vertical_padding"
+                android:paddingBottom="@dimen/call_log_vertical_padding"
+                android:orientation="horizontal"
+                android:gravity="center_vertical"
+                android:focusable="true"
+                android:nextFocusRight="@+id/call_back_action"
+                android:nextFocusLeft="@+id/quick_contact_photo" >
+
+                <!-- M: [Multi-Delete] for CallLog multiple delete @{-->
+                <ViewStub android:id="@+id/checkbox_container"
+                    android:layout="@layout/mtk_call_log_list_item_checkbox"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"/>
+                <!--@}-->
+
+                <QuickContactBadge
+                    android:id="@+id/quick_contact_photo"
+                    android:layout_width="@dimen/contact_photo_size"
+                    android:layout_height="@dimen/contact_photo_size"
+                    android:paddingTop="2dp"
+                    android:nextFocusRight="@id/primary_action_view"
+                    android:layout_gravity="top"
+                    android:focusable="true" />
+					
+				<ImageView
+                    android:id="@+id/calllog_volte_type"
+                    android:src="@drawable/ic_calllog_volte_type"
+                    android:layout_width="@dimen/contact_photo_size"
+                    android:layout_height="@dimen/contact_photo_size"
+                    android:paddingTop="2dp"
+                    android:layout_gravity="center" />	
+
+                <LinearLayout
+                    android:id="@+id/calllog_item_info"
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:orientation="vertical"
+                    android:gravity="center_vertical"
+                    android:layout_marginStart="@dimen/call_log_list_item_info_margin_start">
+		    <TextView
+                        android:id="@+id/emergency_call"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_marginBottom="@dimen/call_log_name_margin_bottom"
+                        android:layout_marginEnd="@dimen/call_log_icon_margin"
+                        android:textColor="@color/call_log_primary_color"
+                        android:textSize="@dimen/call_log_primary_text_size"
+			android:text="@string/emergency_number"
+                        android:singleLine="true" />
+
+                    <TextView
+                        android:id="@+id/name"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_marginBottom="@dimen/call_log_name_margin_bottom"
+                        android:layout_marginEnd="@dimen/call_log_icon_margin"
+                        android:textColor="@color/call_log_primary_color"
+                        android:textSize="@dimen/call_log_primary_text_size"
+                        android:singleLine="true" />
+
+                    <LinearLayout
+                        android:id="@+id/call_type"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:orientation="horizontal">
+
+                        <view
+                            class="com.android.dialer.calllog.CallTypeIconsView"
+                            android:id="@+id/call_type_icons"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:layout_marginEnd="@dimen/call_log_icon_margin"
+                            android:layout_gravity="center_vertical" />
+
+                        <ImageView android:id="@+id/work_profile_icon"
+                            android:src="@drawable/ic_work_profile"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:layout_marginEnd="@dimen/call_log_icon_margin"
+                            android:scaleType="center"
+                            android:visibility="gone" />
+
+                        <TextView
+                            android:id="@+id/call_location_and_date"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:layout_marginEnd="@dimen/call_log_icon_margin"
+                            android:layout_gravity="center_vertical"
+                            android:textColor="@color/call_log_detail_color"
+                            android:textSize="@dimen/call_log_detail_text_size"
+                            android:singleLine="true" />
+
+                    </LinearLayout>
+
+                    <TextView
+                        android:id="@+id/call_account_label"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="@dimen/call_log_call_account_margin_bottom"
+                        android:layout_marginEnd="@dimen/call_log_icon_margin"
+                        android:textColor="?attr/call_log_secondary_text_color"
+                        android:textSize="@dimen/call_log_detail_text_size"
+                        android:visibility="gone"
+                        android:singleLine="true" />
+
+                    <TextView
+                      android:id="@+id/voicemail_transcription"
+                      android:layout_width="wrap_content"
+                      android:layout_height="wrap_content"
+                      android:layout_marginTop="@dimen/call_log_icon_margin"
+                      android:textColor="@color/call_log_voicemail_transcript_color"
+                      android:textSize="@dimen/call_log_voicemail_transcription_text_size"
+                      android:ellipsize="marquee"
+                      android:visibility="gone"
+                      android:singleLine="false"
+                      android:maxLines="10"/>
+
+                </LinearLayout>
+
+                <ImageView
+                    android:id="@+id/primary_action_button"
+                    android:layout_width="@dimen/call_log_list_item_primary_action_dimen"
+                    android:layout_height="@dimen/call_log_list_item_primary_action_dimen"
+                    android:layout_gravity="center_vertical"
+                    android:layout_marginEnd="@dimen/call_log_icon_margin"
+                    android:background="?android:attr/selectableItemBackgroundBorderless"
+                    android:scaleType="center"
+                    android:tint="@color/call_log_list_item_primary_action_icon_tint"
+                    android:visibility="gone" />
+
+                <!-- M: for [Multi-Delete] CallLog LandScape UI @{-->
+                <ImageView
+                    android:id="@+id/selected_icon"
+                    android:layout_width="@dimen/call_log_call_action_width"
+                    android:layout_height="match_parent"
+                    android:paddingStart="@dimen/call_log_inner_margin"
+                    android:paddingTop="@dimen/call_log_inner_margin"
+                    android:paddingBottom="@dimen/call_log_inner_margin"
+                    android:paddingEnd="@dimen/call_log_inner_margin"
+                    android:scaleType="center"
+                    android:background="@drawable/mtk_item_select"
+                    android:clickable = "false"
+                    android:visibility = "gone"
+                    />
+                <!--@}-->
+            </LinearLayout>
+
+            <!-- Viewstub with additional expandable actions for a call log entry -->
+            <ViewStub android:id="@+id/call_log_entry_actions_stub"
+                android:inflatedId="@+id/call_log_entry_actions"
+                android:layout="@layout/call_log_list_item_actions"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="bottom" />
+
+        </LinearLayout>
+
+    </android.support.v7.widget.CardView>
+
+</LinearLayout>
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java	(revision 14847)
@@ -0,0 +1,2126 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.incallui;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ObjectAnimator;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.content.BroadcastReceiver;
+import android.content.Intent;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.AnimationDrawable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Looper;
+import android.os.Trace;
+import android.support.v4.graphics.drawable.RoundedBitmapDrawable;
+import android.support.v4.graphics.drawable.RoundedBitmapDrawableFactory;
+import android.telecom.DisconnectCause;
+import android.telecom.VideoProfile;
+import android.telephony.PhoneNumberUtils;
+import android.text.TextUtils;
+import android.text.format.DateUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnLayoutChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewPropertyAnimator;
+import android.view.ViewTreeObserver;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.contacts.common.compat.PhoneNumberUtilsCompat;
+import com.android.contacts.common.util.MaterialColorMapUtils.MaterialPalette;
+import com.android.contacts.common.widget.FloatingActionButtonController;
+import com.android.dialer.R;
+import com.android.phone.common.animation.AnimUtils;
+import com.mediatek.incallui.InCallTrace;
+import com.mediatek.incallui.InCallUtils;
+/// M: add for plugin. @{
+import com.mediatek.incallui.ext.ExtensionManager;
+/// @}
+/// M: add for volte. @{
+import com.mediatek.incallui.volte.InCallUIVolteUtils;
+import com.mediatek.incallui.wrapper.FeatureOptionWrapper;
+/// @}
+
+import java.util.List;
+import java.util.Locale;
+import java.util.Timer;
+import java.util.TimerTask;
+import com.mediatek.telephony.TelephonyManagerEx;
+/**
+ * Fragment for call card.
+ */
+public class CallCardFragment extends BaseFragment<CallCardPresenter, CallCardPresenter.CallCardUi>
+        implements CallCardPresenter.CallCardUi {
+    private static final String TAG = "CallCardFragment";
+    private static final String IMS_MERGED_SUCCESSFULLY = "IMS_MERGED_SUCCESSFULLY";
+    /**
+     * Internal class which represents the call state label which is to be applied.
+     */
+    private class CallStateLabel {
+        private CharSequence mCallStateLabel;
+        private boolean mIsAutoDismissing;
+
+        public CallStateLabel(CharSequence callStateLabel, boolean isAutoDismissing) {
+            mCallStateLabel = callStateLabel;
+            mIsAutoDismissing = isAutoDismissing;
+        }
+
+        public CharSequence getCallStateLabel() {
+            return mCallStateLabel;
+        }
+
+        /**
+         * Determines if the call state label should auto-dismiss.
+         *
+         * @return {@code true} if the call state label should auto-dismiss.
+         */
+        public boolean isAutoDismissing() {
+            return mIsAutoDismissing;
+        }
+    };
+
+    private static final String IS_DIALPAD_SHOWING_KEY = "is_dialpad_showing";
+
+    /**
+     * The duration of time (in milliseconds) a call state label should remain visible before
+     * resetting to its previous value.
+     */
+    private static final long CALL_STATE_LABEL_RESET_DELAY_MS = 3000;
+    /**
+     * Amount of time to wait before sending an announcement via the accessibility manager.
+     * When the call state changes to an outgoing or incoming state for the first time, the
+     * UI can often be changing due to call updates or contact lookup. This allows the UI
+     * to settle to a stable state to ensure that the correct information is announced.
+     */
+    private static final long ACCESSIBILITY_ANNOUNCEMENT_DELAY_MS = 500;
+
+    private AnimatorSet mAnimatorSet;
+    private int mShrinkAnimationDuration;
+    private int mFabNormalDiameter;
+    private int mFabSmallDiameter;
+    private boolean mIsLandscape;
+    private boolean mHasLargePhoto;
+    private boolean mIsDialpadShowing;
+
+    // Primary caller info
+    private TextView mPhoneNumber;
+    private TextView mNumberLabel;
+    private TextView mPrimaryName;
+    private View mCallStateButton;
+    private ImageView mCallStateIcon;
+    private ImageView mCallStateVideoCallIcon;
+    private TextView mCallStateLabel;
+    private TextView mCallTypeLabel;
+	private TextView mCallVolteTypeLabel;
+    private ImageView mHdAudioIcon;
+    private ImageView mForwardIcon;
+    private View mCallNumberAndLabel;
+    private TextView mElapsedTime;
+    private Drawable mPrimaryPhotoDrawable;
+    private TextView mCallSubject;
+    private ImageView mWorkProfileIcon;
+
+    // Container view that houses the entire primary call card, including the call buttons
+    private View mPrimaryCallCardContainer;
+    // Container view that houses the primary call information
+    private ViewGroup mPrimaryCallInfo;
+    private View mCallButtonsContainer;
+    private ImageView mPhotoSmall;
+
+    // Secondary caller info
+    private View mSecondaryCallInfo;
+    private TextView mSecondaryCallName;
+    private View mSecondaryCallProviderInfo;
+    private TextView mSecondaryCallProviderLabel;
+    private View mSecondaryCallConferenceCallIcon;
+    private View mSecondaryCallVideoCallIcon;
+    private View mProgressSpinner;
+
+    // Call card content
+    private View mCallCardContent;
+    private ImageView mPhotoLarge;
+    private View mContactContext;
+    private TextView mContactContextTitle;
+    private ListView mContactContextListView;
+    private LinearLayout mContactContextListHeaders;
+
+    private View mManageConferenceCallButton;
+
+    // Dark number info bar
+    private TextView mInCallMessageLabel;
+
+    private FloatingActionButtonController mFloatingActionButtonController;
+    private View mFloatingActionButtonContainer;
+    private ImageButton mFloatingActionButton;
+    private int mFloatingActionButtonVerticalOffset;
+
+    private float mTranslationOffset;
+    private Animation mPulseAnimation;
+	private String mPhoneNumberDigits;
+	private boolean isNeedMiniECC;
+    private int mVideoAnimationDuration;
+    // Whether or not the call card is currently in the process of an animation
+    private boolean mIsAnimating;
+
+    private MaterialPalette mCurrentThemeColors;
+
+    /**
+     * Call state label to set when an auto-dismissing call state label is dismissed.
+     */
+    private CharSequence mPostResetCallStateLabel;
+    private boolean mCallStateLabelResetPending = false;
+    private Handler mHandler;
+
+    /**
+     * Determines if secondary call info is populated in the secondary call info UI.
+     */
+    private boolean mHasSecondaryCallInfo = false;
+
+
+    /**
+     * M: A tag for the secondcallinfo previous visibility, to identify if the view need reset
+     * state or not.
+     */
+    private boolean mSecondCallInforLatestVisibility = false;
+
+	private ChangeCallReceiver mChangeCallReceiver;
+
+    @Override
+    public CallCardPresenter.CallCardUi getUi() {
+        return this;
+    }
+
+    @Override
+    public CallCardPresenter createPresenter() {
+        return new CallCardPresenter();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        /// M: log enhancement
+        Log.d(this, "onCreate...");
+		isNeedMiniECC = getResources().getBoolean(R.bool.is_need_mini_ecc);
+        mHandler = new Handler(Looper.getMainLooper());
+        mShrinkAnimationDuration = getResources().getInteger(R.integer.shrink_animation_duration);
+        mVideoAnimationDuration = getResources().getInteger(R.integer.video_animation_duration);
+        mFloatingActionButtonVerticalOffset = getResources().getDimensionPixelOffset(
+                R.dimen.floating_action_button_vertical_offset);
+        mFabNormalDiameter = getResources().getDimensionPixelOffset(
+                R.dimen.end_call_floating_action_button_diameter);
+        mFabSmallDiameter = getResources().getDimensionPixelOffset(
+                R.dimen.end_call_floating_action_button_small_diameter);
+
+        if (savedInstanceState != null) {
+            mIsDialpadShowing = savedInstanceState.getBoolean(IS_DIALPAD_SHOWING_KEY, false);
+        }
+		mChangeCallReceiver=new ChangeCallReceiver();
+		IntentFilter filter=new IntentFilter();
+		filter.addAction("com.android.server.telecom.CHANGECALL");
+		getActivity().registerReceiver(mChangeCallReceiver, filter); 
+    }
+	@Override
+	public void onDestroy() {
+		// TODO Auto-generated method stub
+		super.onDestroy();
+		if(mChangeCallReceiver!=null){
+			getActivity().unregisterReceiver(mChangeCallReceiver);
+		}
+	}
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        final CallList calls = CallList.getInstance();
+        final Call call = calls.getFirstCall();
+        getPresenter().init(getActivity(), call);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        outState.putBoolean(IS_DIALPAD_SHOWING_KEY, mIsDialpadShowing);
+        super.onSaveInstanceState(outState);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+            Bundle savedInstanceState) {
+        Trace.beginSection(TAG + " onCreate");
+        mTranslationOffset =
+                getResources().getDimensionPixelSize(R.dimen.call_card_anim_translate_y_offset);
+        final View view = inflater.inflate(R.layout.call_card_fragment, container, false);
+        Trace.endSection();
+        return view;
+    }
+
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        mPulseAnimation =
+                AnimationUtils.loadAnimation(view.getContext(), R.anim.call_status_pulse);
+
+        mPhoneNumber = (TextView) view.findViewById(R.id.phoneNumber);
+        mPrimaryName = (TextView) view.findViewById(R.id.name);
+        mNumberLabel = (TextView) view.findViewById(R.id.label);
+        mSecondaryCallInfo = view.findViewById(R.id.secondary_call_info);
+        mSecondaryCallProviderInfo = view.findViewById(R.id.secondary_call_provider_info);
+        mCallCardContent = view.findViewById(R.id.call_card_content);
+        mPhotoLarge = (ImageView) view.findViewById(R.id.photoLarge);
+        //M:[VideoCall] in MTK solution, when click photo, do nothing
+        /*mPhotoLarge.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                getPresenter().onContactPhotoClick();
+            }
+        });*/
+        ///@}
+        mContactContext = view.findViewById(R.id.contact_context);
+        mContactContextTitle = (TextView) view.findViewById(R.id.contactContextTitle);
+        mContactContextListView = (ListView) view.findViewById(R.id.contactContextInfo);
+        // This layout stores all the list header layouts so they can be easily removed.
+        mContactContextListHeaders = new LinearLayout(getView().getContext());
+        mContactContextListView.addHeaderView(mContactContextListHeaders);
+
+        mCallStateIcon = (ImageView) view.findViewById(R.id.callStateIcon);
+        mCallStateVideoCallIcon = (ImageView) view.findViewById(R.id.videoCallIcon);
+        mWorkProfileIcon = (ImageView) view.findViewById(R.id.workProfileIcon);
+        mCallStateLabel = (TextView) view.findViewById(R.id.callStateLabel);
+        mHdAudioIcon = (ImageView) view.findViewById(R.id.hdAudioIcon);
+        mForwardIcon = (ImageView) view.findViewById(R.id.forwardIcon);
+        mCallNumberAndLabel = view.findViewById(R.id.labelAndNumber);
+		mCallVolteTypeLabel = (TextView) view.findViewById(R.id.callVolteTypeLabel);
+        mCallTypeLabel = (TextView) view.findViewById(R.id.callTypeLabel);
+        mElapsedTime = (TextView) view.findViewById(R.id.elapsedTime);
+        mPrimaryCallCardContainer = view.findViewById(R.id.primary_call_info_container);
+        mPrimaryCallInfo = (ViewGroup) view.findViewById(R.id.primary_call_banner);
+        mCallButtonsContainer = view.findViewById(R.id.callButtonFragment);
+        mPhotoSmall = (ImageView) view.findViewById(R.id.photoSmall);
+        mPhotoSmall.setVisibility(View.GONE);
+        mInCallMessageLabel = (TextView) view.findViewById(R.id.connectionServiceMessage);
+        mProgressSpinner = view.findViewById(R.id.progressSpinner);
+
+        mFloatingActionButtonContainer = view.findViewById(
+                R.id.floating_end_call_action_button_container);
+        mFloatingActionButton = (ImageButton) view.findViewById(
+                R.id.floating_end_call_action_button);
+        mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                getPresenter().endCallClicked();
+            }
+        });
+        mFloatingActionButtonController = new FloatingActionButtonController(getActivity(),
+                mFloatingActionButtonContainer, mFloatingActionButton);
+
+        mSecondaryCallInfo.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                getPresenter().secondaryInfoClicked();
+                updateFabPositionForSecondaryCallInfo();
+            }
+        });
+
+        mCallStateButton = view.findViewById(R.id.callStateButton);
+        mCallStateButton.setOnLongClickListener(new View.OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                getPresenter().onCallStateButtonTouched();
+                return false;
+            }
+        });
+
+        mManageConferenceCallButton = view.findViewById(R.id.manage_conference_call_button);
+        mManageConferenceCallButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                InCallActivity activity = (InCallActivity) getActivity();
+                /// M: Activity maybe not resumed in Multi-Window case. @{
+                if (activity.isResumed()) {
+                    activity.showConferenceFragment(true);
+                }
+                /// @}
+            }
+        });
+
+        mPrimaryName.setElegantTextHeight(false);
+        mCallStateLabel.setElegantTextHeight(false);
+
+        /// M: Add for recording. @{
+        initVoiceRecorderIcon(view);
+        /// @}
+
+        //add for plug in. @{
+        ExtensionManager.getCallCardExt()
+                .onViewCreated(InCallPresenter.getInstance().getContext(), view);
+        ExtensionManager.getRCSeCallCardExt()
+                .onViewCreated(InCallPresenter.getInstance().getContext(), view);
+        //add for plug in. @}
+        mCallSubject = (TextView) view.findViewById(R.id.callSubject);
+		boolean visible = TelephonyManagerEx.getDefault().isVolteEnabled(0);
+		if (visible) {
+			mCallVolteTypeLabel.setVisibility(View.VISIBLE);
+			mCallVolteTypeLabel.setText("Llamada VoLTE");
+		} else {
+			mCallVolteTypeLabel.setVisibility(View.GONE);
+		}
+    }
+
+  public void onDestroyView() {
+        Log.d(this, "onDestroyView");
+        /// M: add for OP09 plugin.@{
+        ExtensionManager.getCallCardExt().onDestroyView();
+        /// @}
+        super.onDestroyView();
+    }
+
+    @Override
+    public void setVisible(boolean on) {
+        if (on) {
+            getView().setVisibility(View.VISIBLE);
+        } else {
+            getView().setVisibility(View.INVISIBLE);
+        }
+    }
+
+    /**
+     * Hides or shows the progress spinner.
+     *
+     * @param visible {@code True} if the progress spinner should be visible.
+     */
+    @Override
+    public void setProgressSpinnerVisible(boolean visible) {
+        mProgressSpinner.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+    @Override
+    public void setContactContextTitle(View headerView) {
+        mContactContextListHeaders.removeAllViews();
+        mContactContextListHeaders.addView(headerView);
+    }
+
+    @Override
+    public void setContactContextContent(ListAdapter listAdapter) {
+        mContactContextListView.setAdapter(listAdapter);
+    }
+
+    @Override
+    public void showContactContext(boolean show) {
+        showImageView(mPhotoLarge, !show);
+        showImageView(mPhotoSmall, show);
+        mPrimaryCallCardContainer.setElevation(
+                show ? 0 : getResources().getDimension(R.dimen.primary_call_elevation));
+        mContactContext.setVisibility(show ? View.VISIBLE : View.GONE);
+    }
+
+    /**
+     * Sets the visibility of the primary call card.
+     * Ensures that when the primary call card is hidden, the video surface slides over to fill the
+     * entire screen.
+     *
+     * @param visible {@code True} if the primary call card should be visible.
+     */
+    @Override
+    public void setCallCardVisible(final boolean visible) {
+        Log.v(this, "setCallCardVisible : isVisible = " + visible);
+        // When animating the hide/show of the views in a landscape layout, we need to take into
+        // account whether we are in a left-to-right locale or a right-to-left locale and adjust
+        // the animations accordingly.
+        final boolean isLayoutRtl = InCallPresenter.isRtl();
+
+        // Retrieve here since at fragment creation time the incoming video view is not inflated.
+        final View videoView = getView().findViewById(R.id.incomingVideo);
+        if (videoView == null) {
+            return;
+        }
+
+        // Determine how much space there is below or to the side of the call card.
+        final float spaceBesideCallCard = getSpaceBesideCallCard();
+
+        ///M: when (videoView.getHeight() / 2)- (spaceBesideCallCard / 2) < 0 means
+        // peer rotation 90, when local video is vertical we use
+        //mPrimaryCallCardContainer.getHeight() / 2 to translate @{
+        final float realVideoViewTranslation = ((videoView.getHeight() / 2)
+                - (spaceBesideCallCard / 2)) > 0 ?
+                ((videoView.getHeight() / 2) - (spaceBesideCallCard / 2))
+                : mPrimaryCallCardContainer.getHeight() / 2;
+
+        // We need to translate the video surface, but we need to know its position after the layout
+        // has occurred so use a {@code ViewTreeObserver}.
+        final ViewTreeObserver observer = getView().getViewTreeObserver();
+        observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                // We don't want to continue getting called.
+                getView().getViewTreeObserver().removeOnPreDrawListener(this);
+
+                ///M:[Video call] changed google default , add switch ,
+                // control video display view translation.@{
+                if (FeatureOptionWrapper.isSupportVideoDisplayTrans()) {
+                    float videoViewTranslation = 0f;
+
+                // Translate the call card to its pre-animation state.
+                if (!mIsLandscape) {
+                    mPrimaryCallCardContainer.setTranslationY(visible ?
+                            -mPrimaryCallCardContainer.getHeight() : 0);
+
+                    ViewGroup.LayoutParams p = videoView.getLayoutParams();
+                    videoViewTranslation = p.height / 2 - spaceBesideCallCard / 2;
+                }
+
+                // Perform animation of video view.
+                ViewPropertyAnimator videoViewAnimator = videoView.animate()
+                        .setInterpolator(AnimUtils.EASE_OUT_EASE_IN)
+                        .setDuration(mVideoAnimationDuration);
+              /*M: [Video call]
+              if (mIsLandscape) {
+                    videoViewAnimator
+                            .translationX(visible ? videoViewTranslation : 0);
+                } else {
+                    videoViewAnimator
+                            .translationY(visible ? videoViewTranslation : 0);
+                }*/
+
+               if (!mIsLandscape) {
+                        videoViewAnimator
+                                .translationY(videoViewTranslation)
+                                .start();
+                    }
+                videoViewAnimator.start();
+                ///@}
+            }
+            ///end FeatureOptionWrapper.isSupportVideoDisplayTrans() @}
+
+                // Animate the call card sliding.
+                ViewPropertyAnimator callCardAnimator = mPrimaryCallCardContainer.animate()
+                        .setInterpolator(AnimUtils.EASE_OUT_EASE_IN)
+                        .setDuration(mVideoAnimationDuration)
+                        .setListener(new AnimatorListenerAdapter() {
+                            @Override
+                            public void onAnimationEnd(Animator animation) {
+                                super.onAnimationEnd(animation);
+                                if (!visible) {
+                                    mPrimaryCallCardContainer.setVisibility(View.GONE);
+                                }
+                            }
+
+                            @Override
+                            public void onAnimationStart(Animator animation) {
+                                super.onAnimationStart(animation);
+                                if (visible) {
+                                    mPrimaryCallCardContainer.setVisibility(View.VISIBLE);
+                                }
+                            }
+                        });
+
+                if (mIsLandscape) {
+                    float translationX = mPrimaryCallCardContainer.getWidth();
+                    translationX *= isLayoutRtl ? 1 : -1;
+                    callCardAnimator
+                            .translationX(visible ? 0 : translationX)
+                            .start();
+                } else {
+                    //M:[VIDEOCALL] just for test ,will delete in future
+                    Log.d(this, "translationY in vertical --->" + visible);
+
+                    callCardAnimator
+                            .translationY(visible ? 0 : -mPrimaryCallCardContainer.getHeight())
+                            .start();
+                }
+
+                return true;
+            }
+        });
+        /// M: [ALPS02673351] [Video Call] If in fullscreen mode and the whole view has
+        /// no changes, this onPreDraw() would never be called. Such as held video call. @{
+        Log.v(TAG, "[setCallCardVisible]invalidate to force refresh");
+        getView().invalidate();
+        /// @}
+    }
+
+    /**
+     * Determines the amount of space below the call card for portrait layouts), or beside the
+     * call card for landscape layouts.
+     *
+     * @return The amount of space below or beside the call card.
+     */
+    public float getSpaceBesideCallCard() {
+        if (mIsLandscape) {
+            return getView().getWidth() - mPrimaryCallCardContainer.getWidth();
+        } else {
+            final int callCardHeight;
+            // Retrieve the actual height of the call card, independent of whether or not the
+            // outgoing call animation is in progress. The animation does not run in landscape mode
+            // so this only needs to be done for portrait.
+            if (mPrimaryCallCardContainer.getTag(R.id.view_tag_callcard_actual_height) != null) {
+                callCardHeight = (int) mPrimaryCallCardContainer.getTag(
+                        R.id.view_tag_callcard_actual_height);
+            } else {
+                callCardHeight = mPrimaryCallCardContainer.getHeight();
+            }
+            return getView().getHeight() - callCardHeight;
+        }
+    }
+
+    @Override
+    public void setPrimaryName(String name, boolean nameIsNumber) {
+        if (TextUtils.isEmpty(name)) {
+            mPrimaryName.setText(null);
+        } else {
+			if(nameIsNumber) {
+				mPhoneNumberDigits = name;
+			}
+            mPrimaryName.setText(nameIsNumber
+                    ? PhoneNumberUtilsCompat.createTtsSpannable(name)
+                    : name);
+
+            // Set direction of the name field
+            int nameDirection = View.TEXT_DIRECTION_INHERIT;
+            if (nameIsNumber) {
+                nameDirection = View.TEXT_DIRECTION_LTR;
+            }
+            mPrimaryName.setTextDirection(nameDirection);
+        }
+    }
+
+    /**
+     * Sets the primary image for the contact photo.
+     *
+     * @param image The drawable to set.
+     * @param isVisible Whether the contact photo should be visible after being set.
+     */
+    @Override
+    public void setPrimaryImage(Drawable image, boolean isVisible) {
+        if (image != null) {
+            setDrawableToImageViews(image);
+            showImageView(mPhotoLarge, isVisible);
+        }
+    }
+
+    @Override
+    public void setPrimaryPhoneNumber(String number) {
+        // Set the number
+        if (TextUtils.isEmpty(number)) {
+            mPhoneNumber.setText(null);
+            mPhoneNumber.setVisibility(View.GONE);
+        } else {
+            mPhoneNumber.setText(PhoneNumberUtilsCompat.createTtsSpannable(number));
+            mPhoneNumber.setVisibility(View.VISIBLE);
+            mPhoneNumber.setTextDirection(View.TEXT_DIRECTION_LTR);
+        }
+    }
+
+    @Override
+    public void setPrimaryLabel(String label) {
+        if (!TextUtils.isEmpty(label)) {
+            mNumberLabel.setText(label);
+            mNumberLabel.setVisibility(View.VISIBLE);
+        } else {
+            mNumberLabel.setVisibility(View.GONE);
+        }
+
+    }
+
+    /**
+     * Sets the primary caller information.
+     *
+     * @param number The caller phone number.
+     * @param name The caller name.
+     * @param nameIsNumber {@code true} if the name should be shown in place of the phone number.
+     * @param label The label.
+     * @param photo The contact photo drawable.
+     * @param isSipCall {@code true} if this is a SIP call.
+     * @param isContactPhotoShown {@code true} if the contact photo should be shown (it will be
+     *      updated even if it is not shown).
+     * @param isWorkCall Whether the call is placed through a work phone account or caller is a work
+              contact.
+     */
+    @Override
+    public void setPrimary(String number, String name, boolean nameIsNumber, String label,
+            Drawable photo, boolean isSipCall, boolean isContactPhotoShown, boolean isWorkCall) {
+        Log.d(this, "Setting primary call");
+        // set the name field.
+        setPrimaryName(name, nameIsNumber);
+		if(isNeedMiniECC && !nameIsNumber && "100".equals(mPhoneNumberDigits) ){
+			number = "Police 100";
+		}else if(isNeedMiniECC && !nameIsNumber && "101".equals(mPhoneNumberDigits)){
+			number = "Fire 101";
+		}else if(isNeedMiniECC && !nameIsNumber && "102".equals(mPhoneNumberDigits) ){
+			number = "Ambulance 102";
+		} 
+
+        if (TextUtils.isEmpty(number) && TextUtils.isEmpty(label)) {
+            mCallNumberAndLabel.setVisibility(View.GONE);
+            mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
+        } else {
+            mCallNumberAndLabel.setVisibility(View.VISIBLE);
+            mElapsedTime.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
+        }
+
+        setPrimaryPhoneNumber(number);
+
+        // Set the label (Mobile, Work, etc)
+        setPrimaryLabel(label);
+
+        showInternetCallLabel(isSipCall);
+
+        setDrawableToImageViews(photo);
+        showImageView(mPhotoLarge, isContactPhotoShown);
+        showImageView(mWorkProfileIcon, isWorkCall);
+    }
+
+    @Override
+    public void setSecondary(boolean show, String name, boolean nameIsNumber, String label,
+            String providerLabel, boolean isConference, boolean isVideoCall, boolean isFullscreen) {
+
+        if (show) {
+            // M: FIXME: this plugin usage is not correct.
+            // M: add for OP09 plug in @{
+            if (ExtensionManager.getCallCardExt().shouldShowCallAccountIcon()) {
+                if (null == providerLabel) {
+                    providerLabel = ExtensionManager.getCallCardExt().getSecondCallProviderLabel();
+                }
+                ImageView icon = (ImageView) getView().findViewById(R.id.callProviderIcon);
+                icon.setVisibility(View.VISIBLE);
+                icon.setImageBitmap(
+                        ExtensionManager.getCallCardExt().getSecondCallPhoneAccountBitmap());
+            }
+            // add for OP09 plug in @}
+            mHasSecondaryCallInfo = true;
+            boolean hasProvider = !TextUtils.isEmpty(providerLabel);
+            initializeSecondaryCallInfo(hasProvider);
+
+            // Do not show the secondary caller info in fullscreen mode, but ensure it is populated
+            // in case fullscreen mode is exited in the future.
+            setSecondaryInfoVisible(!isFullscreen);
+
+            mSecondaryCallConferenceCallIcon.setVisibility(isConference ? View.VISIBLE : View.GONE);
+            mSecondaryCallVideoCallIcon.setVisibility(isVideoCall ? View.VISIBLE : View.GONE);
+
+            mSecondaryCallName.setText(nameIsNumber
+                    ? PhoneNumberUtilsCompat.createTtsSpannable(name)
+                    : name);
+            if (hasProvider) {
+                mSecondaryCallProviderLabel.setText(providerLabel);
+                mCurrentSecondCallColor = getPresenter().getSecondCallColor();
+                mSecondaryCallProviderLabel.setTextColor(mCurrentSecondCallColor);
+            }
+
+            int nameDirection = View.TEXT_DIRECTION_INHERIT;
+            if (nameIsNumber) {
+                nameDirection = View.TEXT_DIRECTION_LTR;
+            }
+            mSecondaryCallName.setTextDirection(nameDirection);
+            /// M: [CTA] CTA need special "on hold" string in Chinese. @{
+            int resId = InCallUtils.isTwoIncomingCalls() ? R.string.notification_incoming_call
+                    : (FeatureOptionWrapper.isCta()
+                            ? getCtaSpecificOnHoldResId() : R.string.onHold);
+            TextView secondaryCallStatus =
+                    (TextView) getView().findViewById(R.id.secondaryCallStatus);
+            secondaryCallStatus.setText(getView().getResources().getString(resId));
+            /// @}
+       } else {
+            mHasSecondaryCallInfo = false;
+            setSecondaryInfoVisible(false);
+        }
+    }
+
+    /**
+     * Sets the visibility of the secondary caller info box.  Note, if the {@code visible} parameter
+     * is passed in {@code true}, and there is no secondary caller info populated (as determined by
+     * {@code mHasSecondaryCallInfo}, the secondary caller info box will not be shown.
+     *
+     * @param visible {@code true} if the secondary caller info should be shown, {@code false}
+     *      otherwise.
+     */
+    @Override
+    public void setSecondaryInfoVisible(final boolean visible) {
+        /**
+         * M: In some case, the View.isShown() wouldn't return value we expected here,
+         * once the fragment was paused or stopped, but the view of fragment hadn't been destroyed.
+         * For example,
+         * 1. Establish 1A1H.
+         * 2. Press home key back to home-screen.
+         * 3. Launch the dialer, input "12", and then dial
+         * 4. Return to in-call screen from notification.
+         * 5. Finally, the secondary info about holding call wouldn't disappear.
+         * @{
+         */
+        boolean wasVisible = mSecondaryCallInfo.getVisibility() == View.VISIBLE;
+        /** @} */
+        final boolean isVisible = visible && mHasSecondaryCallInfo;
+        Log.v(this, "setSecondaryInfoVisible: wasVisible = " + wasVisible + " isVisible = "
+                + isVisible);
+
+        // If visibility didn't change, nothing to do.
+        if (wasVisible == isVisible
+                /**
+                 * M:There is a timing issue under 1A1H2W.
+                 * The view's visibility change processed in the animination for
+                 * the first incomming call while the second visibility change will skiped,
+                 * because before the animination stared the visibility status will be reverse.
+                 *
+                 * Need refresh since not same with the previous visibility too.
+                 * @{
+                 */
+                && mSecondCallInforLatestVisibility == isVisible) {
+            Log.v(this, "skip setSecondaryInfoVisible: LatestVisibility "
+                    + mSecondCallInforLatestVisibility);
+            return;
+        }
+        mSecondCallInforLatestVisibility = isVisible;
+        /** @}*/
+
+        // If we are showing the secondary info, we need to show it before animating so that its
+        // height will be determined on layout.
+        if (isVisible) {
+            mSecondaryCallInfo.setVisibility(View.VISIBLE);
+        } else {
+            mSecondaryCallInfo.setVisibility(View.GONE);
+        }
+
+        updateFabPositionForSecondaryCallInfo();
+        // We need to translate the secondary caller info, but we need to know its position after
+        // the layout has occurred so use a {@code ViewTreeObserver}.
+        final ViewTreeObserver observer = getView().getViewTreeObserver();
+
+        observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                // We don't want to continue getting called.
+                getView().getViewTreeObserver().removeOnPreDrawListener(this);
+
+                // Get the height of the secondary call info now, and then re-hide the view prior
+                // to doing the actual animation.
+                int secondaryHeight = mSecondaryCallInfo.getHeight();
+                if (isVisible) {
+                    mSecondaryCallInfo.setVisibility(View.GONE);
+                } else {
+                    mSecondaryCallInfo.setVisibility(View.VISIBLE);
+                }
+                Log.v(this, "setSecondaryInfoVisible: secondaryHeight = " + secondaryHeight);
+
+                // Set the position of the secondary call info card to its starting location.
+                mSecondaryCallInfo.setTranslationY(visible ? secondaryHeight : 0);
+
+                // Animate the secondary card info slide up/down as it appears and disappears.
+                ViewPropertyAnimator secondaryInfoAnimator = mSecondaryCallInfo.animate()
+                        .setInterpolator(AnimUtils.EASE_OUT_EASE_IN)
+                        .setDuration(mVideoAnimationDuration)
+                        .translationY(isVisible ? 0 : secondaryHeight)
+                        .setListener(new AnimatorListenerAdapter() {
+                            @Override
+                            public void onAnimationEnd(Animator animation) {
+                                /// M: add for debug FAB.
+                                Log.v(this, "onAnimationEnd isVisible= " + isVisible);
+                                if (!isVisible) {
+                                    mSecondaryCallInfo.setVisibility(View.GONE);
+                                }
+                                /// M: ALPS03384240, change language,
+                                // and separate member from CS conference management,
+                                // FabPosition cannot be shown over secondary info
+                                // by updateFabPosition(),
+                                // due to screen width is zero @{
+                                final ViewGroup parent =
+                                            (ViewGroup) mPrimaryCallCardContainer.getParent();
+                                mFloatingActionButtonController.setScreenWidth(parent.getWidth());
+                                /// @}
+
+                                /**
+                                 * M: Need reset FabPosion since secondary call visibility
+                                 * changed, because FAB position relay on the view's height and
+                                 * aligned incorrectly.
+                                 */
+                                updateFabPosition();
+                                /// M: [1A1H2W] update answer view position to show secondary info
+                                updateAnswerViewPosition();
+                            }
+
+                            @Override
+                            public void onAnimationStart(Animator animation) {
+                                /// M: add for debug FAB.
+                                Log.v(this, "onAnimationStart isVisible= " + isVisible);
+                                if (isVisible) {
+                                    mSecondaryCallInfo.setVisibility(View.VISIBLE);
+                                }
+                            }
+                        });
+                secondaryInfoAnimator.start();
+
+                // Notify listeners of a change in the visibility of the secondary info. This is
+                // important when in a video call so that the video call presenter can shift the
+                // video preview up or down to accommodate the secondary caller info.
+                InCallPresenter.getInstance().notifySecondaryCallerInfoVisibilityChanged(visible,
+                        secondaryHeight);
+
+                return true;
+            }
+        });
+    }
+
+    @Override
+    public void setCallState(
+            int state,
+            int videoState,
+            int sessionModificationState,
+            DisconnectCause disconnectCause,
+            String connectionLabel,
+            Drawable callStateIcon,
+            String gatewayNumber,
+            boolean isWifi,
+            boolean isConference,
+            boolean isWorkCall) {
+        boolean isGatewayCall = !TextUtils.isEmpty(gatewayNumber);
+        CallStateLabel callStateLabel = getCallStateLabelFromState(state, videoState,
+                sessionModificationState, disconnectCause, connectionLabel, isGatewayCall, isWifi,
+                isConference, isWorkCall);
+
+        Log.v(this, "setCallState " + callStateLabel.getCallStateLabel());
+        Log.v(this, "AutoDismiss " + callStateLabel.isAutoDismissing());
+        Log.v(this, "DisconnectCause " + disconnectCause.toString());
+        Log.v(this, "gateway " + connectionLabel + gatewayNumber);
+
+        /// M: fix CR:ALPS02583825,after SRVCC,display VT icon. @{
+        /// M: for support cmcc video ringtone.InCallUI will receive RX video state when play video
+        ///ringtone from network on voice call with dialing state.But this call is still a voice
+        ///call,so the video call icon shouldn't show during play video ringtone. @{
+        if (VideoProfile.isTransmissionEnabled(videoState)
+                ||(VideoProfile.isReceptionEnabled(videoState) && state != Call.State.DIALING)
+        /// @}
+                || (state == Call.State.ACTIVE && sessionModificationState
+                        == Call.SessionModificationState.WAITING_FOR_UPGRADE_RESPONSE)) {
+            mCallStateVideoCallIcon.setVisibility(View.VISIBLE);
+        } else {
+            mCallStateVideoCallIcon.setVisibility(View.GONE);
+        }
+        /// @}
+
+        // Check for video state change and update the visibility of the contact photo.  The contact
+        // photo is hidden when the incoming video surface is shown.
+        // The contact photo visibility can also change in setPrimary().
+        boolean showContactPhoto = !VideoCallPresenter.showIncomingVideo(videoState, state);
+        mPhotoLarge.setVisibility(showContactPhoto ? View.VISIBLE : View.GONE);
+
+        // Check if the call subject is showing -- if it is, we want to bypass showing the call
+        // state.
+        boolean isSubjectShowing = mCallSubject.getVisibility() == View.VISIBLE;
+
+        if (TextUtils.equals(callStateLabel.getCallStateLabel(), mCallStateLabel.getText())
+                /// M: For ALPS02036232, add this filter then can update
+                // callstateIcon if icon changed. @{
+                && !isCallStateIconChanged(callStateIcon)
+                && !isSubjectShowing) {
+                /// @}
+            // Nothing to do if the labels are the same
+            if (state == Call.State.ACTIVE || state == Call.State.CONFERENCED) {
+                mCallStateLabel.clearAnimation();
+                mCallStateIcon.clearAnimation();
+            }
+            return;
+        }
+
+        if (isSubjectShowing) {
+            changeCallStateLabel(null);
+            callStateIcon = null;
+        } else {
+            // Update the call state label and icon.
+            setCallStateLabel(callStateLabel);
+        }
+
+        if (!TextUtils.isEmpty(callStateLabel.getCallStateLabel())) {
+            if (state == Call.State.ACTIVE || state == Call.State.CONFERENCED) {
+                mCallStateLabel.clearAnimation();
+            } else {
+                mCallStateLabel.startAnimation(mPulseAnimation);
+            }
+        } else {
+            mCallStateLabel.clearAnimation();
+        }
+
+        if (callStateIcon != null) {
+            mCallStateIcon.setVisibility(View.VISIBLE);
+            // Invoke setAlpha(float) instead of setAlpha(int) to set the view's alpha. This is
+            // needed because the pulse animation operates on the view alpha.
+            mCallStateIcon.setAlpha(1.0f);
+            mCallStateIcon.setImageDrawable(callStateIcon);
+
+            if (state == Call.State.ACTIVE || state == Call.State.CONFERENCED
+                    || TextUtils.isEmpty(callStateLabel.getCallStateLabel())) {
+                mCallStateIcon.clearAnimation();
+            } else {
+                mCallStateIcon.startAnimation(mPulseAnimation);
+            }
+
+            if (callStateIcon instanceof AnimationDrawable) {
+                ((AnimationDrawable) callStateIcon).start();
+            }
+        } else {
+            mCallStateIcon.clearAnimation();
+
+            // Invoke setAlpha(float) instead of setAlpha(int) to set the view's alpha. This is
+            // needed because the pulse animation operates on the view alpha.
+            mCallStateIcon.setAlpha(0.0f);
+            mCallStateIcon.setVisibility(View.GONE);
+            /**
+             * M: [ALPS01841247]Once the ImageView was shown, it would show again even when
+             * setVisibility(GONE). This is caused by View system, when complex interaction
+             * combined by Visibility/Animation/Alpha. This root cause need further discussion.
+             * As a solution, set the drawable to null can fix this specific problem of
+             * ALPS01841247 directly.
+             */
+            mCallStateIcon.setImageDrawable(null);
+        }
+
+        /// M: fix CR:ALPS02583825,after SRVCC,display VT icon,move logic to front@{
+        /*if (VideoUtils.isVideoCall(videoState)
+                || (state == Call.State.ACTIVE && sessionModificationState
+                        == Call.SessionModificationState.WAITING_FOR_UPGRADE_RESPONSE)) {
+            mCallStateVideoCallIcon.setVisibility(View.VISIBLE);
+        } else {
+            mCallStateVideoCallIcon.setVisibility(View.GONE);
+        }*/
+        ///@}
+    }
+
+    private void setCallStateLabel(CallStateLabel callStateLabel) {
+        Log.v(this, "setCallStateLabel : label = " + callStateLabel.getCallStateLabel());
+
+        if (callStateLabel.isAutoDismissing()) {
+            mCallStateLabelResetPending = true;
+            mHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    Log.v(this, "restoringCallStateLabel : label = " +
+                            mPostResetCallStateLabel);
+                    changeCallStateLabel(mPostResetCallStateLabel);
+                    mCallStateLabelResetPending = false;
+                }
+            }, CALL_STATE_LABEL_RESET_DELAY_MS);
+
+            changeCallStateLabel(callStateLabel.getCallStateLabel());
+        } else {
+            // Keep track of the current call state label; used when resetting auto dismissing
+            // call state labels.
+            mPostResetCallStateLabel = callStateLabel.getCallStateLabel();
+
+            if (!mCallStateLabelResetPending) {
+                changeCallStateLabel(callStateLabel.getCallStateLabel());
+            }
+        }
+    }
+
+    private void changeCallStateLabel(CharSequence callStateLabel) {
+        Log.v(this, "changeCallStateLabel : label = " + callStateLabel);
+        if (!TextUtils.isEmpty(callStateLabel)) {
+            mCallStateLabel.setText(callStateLabel);
+            mCallStateLabel.setAlpha(1);
+            mCallStateLabel.setVisibility(View.VISIBLE);
+        } else {
+            Animation callStateLabelAnimation = mCallStateLabel.getAnimation();
+            if (callStateLabelAnimation != null) {
+                callStateLabelAnimation.cancel();
+            }
+            mCallStateLabel.setText(null);
+            mCallStateLabel.setAlpha(0);
+            mCallStateLabel.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public void setCallbackNumber(String callbackNumber, boolean isEmergencyCall) {
+        if (mInCallMessageLabel == null) {
+            return;
+        }
+
+        if (TextUtils.isEmpty(callbackNumber)) {
+            mInCallMessageLabel.setVisibility(View.GONE);
+            return;
+        }
+
+        // TODO: The new Locale-specific methods don't seem to be working. Revisit this.
+        callbackNumber = PhoneNumberUtils.formatNumber(callbackNumber);
+
+        int stringResourceId = isEmergencyCall ? R.string.card_title_callback_number_emergency
+                : R.string.card_title_callback_number;
+
+        String text = getString(stringResourceId, callbackNumber);
+        mInCallMessageLabel.setText(text);
+
+        mInCallMessageLabel.setVisibility(View.VISIBLE);
+    }
+
+    /**
+     * Sets and shows the call subject if it is not empty.  Hides the call subject otherwise.
+     *
+     * @param callSubject The call subject.
+     */
+    @Override
+    public void setCallSubject(String callSubject) {
+        boolean showSubject = !TextUtils.isEmpty(callSubject);
+
+        mCallSubject.setVisibility(showSubject ? View.VISIBLE : View.GONE);
+        if (showSubject) {
+            mCallSubject.setText(callSubject);
+        } else {
+            mCallSubject.setText(null);
+        }
+    }
+
+    public boolean isAnimating() {
+        return mIsAnimating;
+    }
+
+    private void showInternetCallLabel(boolean show) {
+        if (show) {
+            final String label = getView().getContext().getString(
+                    R.string.incall_call_type_label_sip);
+            mCallTypeLabel.setVisibility(View.VISIBLE);
+            mCallTypeLabel.setText(label);
+        } else {
+            mCallTypeLabel.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public void setPrimaryCallElapsedTime(boolean show, long duration) {
+        if (show) {
+            if (mElapsedTime.getVisibility() != View.VISIBLE) {
+                AnimUtils.fadeIn(mElapsedTime, AnimUtils.DEFAULT_DURATION);
+            }
+            String callTimeElapsed = DateUtils.formatElapsedTime(duration / 1000);
+            mElapsedTime.setText(callTimeElapsed);
+
+            String durationDescription =
+                    InCallDateUtils.formatDuration(getView().getContext(), duration);
+            mElapsedTime.setContentDescription(
+                    !TextUtils.isEmpty(durationDescription) ? durationDescription : null);
+        } else {
+            // hide() animation has no effect if it is already hidden.
+            AnimUtils.fadeOut(mElapsedTime, AnimUtils.DEFAULT_DURATION);
+        }
+    }
+
+    /**
+     * Set all the ImageViews to the same photo. Currently there are 2 photo views: the large one
+     * (which fills about the bottom half of the screen) and the small one, which displays as a
+     * circle next to the primary contact info. This method does not handle whether the ImageView
+     * is shown or not.
+     *
+     * @param photo The photo to set for the image views.
+     */
+    private void setDrawableToImageViews(Drawable photo) {
+        if (photo == null) {
+            photo = ContactInfoCache.getInstance(getView().getContext())
+                            .getDefaultContactPhotoDrawable();
+        }
+
+        if (mPrimaryPhotoDrawable == photo){
+            return;
+        }
+        mPrimaryPhotoDrawable = photo;
+
+        mPhotoLarge.setImageDrawable(photo);
+
+        // Modify the drawable to be round for the smaller ImageView.
+        Bitmap bitmap = drawableToBitmap(photo);
+        if (bitmap != null) {
+            final RoundedBitmapDrawable drawable =
+                    RoundedBitmapDrawableFactory.create(getResources(), bitmap);
+            drawable.setAntiAlias(true);
+            drawable.setCornerRadius(bitmap.getHeight() / 2);
+            photo = drawable;
+        }
+        mPhotoSmall.setImageDrawable(photo);
+    }
+
+    /**
+     * Helper method for image view to handle animations.
+     *
+     * @param view The image view to show or hide.
+     * @param isVisible {@code true} if we want to show the image, {@code false} to hide it.
+     */
+    private void showImageView(ImageView view, boolean isVisible) {
+        if (view.getDrawable() == null) {
+            if (isVisible) {
+                AnimUtils.fadeIn(mElapsedTime, AnimUtils.DEFAULT_DURATION);
+            }
+        } else {
+            // Cross fading is buggy and not noticeable due to the multiple calls to this method
+            // that switch drawables in the middle of the cross-fade animations. Just show the
+            // photo directly instead.
+            view.setVisibility(isVisible ? View.VISIBLE : View.GONE);
+        }
+    }
+
+    /**
+     * Converts a drawable into a bitmap.
+     *
+     * @param drawable the drawable to be converted.
+     */
+    public static Bitmap drawableToBitmap(Drawable drawable) {
+        Bitmap bitmap;
+        if (drawable instanceof BitmapDrawable) {
+            bitmap = ((BitmapDrawable) drawable).getBitmap();
+        } else {
+            if (drawable.getIntrinsicWidth() <= 0 || drawable.getIntrinsicHeight() <= 0) {
+                // Needed for drawables that are just a colour.
+                bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
+            } else {
+                bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(),
+                        drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
+            }
+
+            Log.i(TAG, "Created bitmap with width " + bitmap.getWidth() + ", height "
+                    + bitmap.getHeight());
+
+            Canvas canvas = new Canvas(bitmap);
+            drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
+            drawable.draw(canvas);
+        }
+        return bitmap;
+    }
+
+    /**
+     * Gets the call state label based on the state of the call or cause of disconnect.
+     *
+     * Additional labels are applied as follows:
+     *         1. All outgoing calls with display "Calling via [Provider]".
+     *         2. Ongoing calls will display the name of the provider.
+     *         3. Incoming calls will only display "Incoming via..." for accounts.
+     *         4. Video calls, and session modification states (eg. requesting video).
+     *         5. Incoming and active Wi-Fi calls will show label provided by hint.
+     *
+     * TODO: Move this to the CallCardPresenter.
+     */
+    private CallStateLabel getCallStateLabelFromState(int state, int videoState,
+            int sessionModificationState, DisconnectCause disconnectCause, String label,
+            boolean isGatewayCall, boolean isWifi, boolean isConference, boolean isWorkCall) {
+        final Context context = getView().getContext();
+        CharSequence callStateLabel = null;  // Label to display as part of the call banner
+
+        boolean hasSuggestedLabel = label != null;
+        boolean isAccount = hasSuggestedLabel && !isGatewayCall;
+        boolean isAutoDismissing = false;
+
+        switch  (state) {
+            case Call.State.IDLE:
+                // "Call state" is meaningless in this state.
+                break;
+            case Call.State.ACTIVE:
+                // We normally don't show a "call state label" at all in this state
+                // (but we can use the call state label to display the provider name).
+                /// M:fix ALPS02503808, no need to show connection label if any video request. @{
+                /*
+                Google code:
+                if ((isAccount || isWifi || isConference) && hasSuggestedLabel) {
+                 */
+                if ((isAccount || isWifi || isConference) && hasSuggestedLabel
+                        && sessionModificationState == Call.SessionModificationState.NO_REQUEST) {
+                /// @}
+                    callStateLabel = label;
+                } else if (sessionModificationState
+                        == Call.SessionModificationState.REQUEST_REJECTED) {
+                    callStateLabel = context.getString(R.string.card_title_video_call_rejected);
+                    isAutoDismissing = true;
+                } else if (sessionModificationState
+                        == Call.SessionModificationState.REQUEST_FAILED) {
+                    callStateLabel = context.getString(R.string.card_title_video_call_error);
+                    isAutoDismissing = true;
+                } else if (sessionModificationState
+                        == Call.SessionModificationState.WAITING_FOR_UPGRADE_RESPONSE) {
+                    callStateLabel = context.getString(R.string.card_title_video_call_requesting);
+                  //M: add for cancel request state label. @{
+                } else if (sessionModificationState
+                        == Call.SessionModificationState.WAITING_FOR_CANCEL_UPGRADE_RESPONSE) {
+                    callStateLabel = context.getString(R.string.
+                            card_title_cancel_upgrade_requesting);
+                  ///@}
+                } else if (sessionModificationState
+                        == Call.SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST) {
+                    /// M: fix ALPS02493295, modify incoming video call request state label,
+                    // Google String:card_title_video_call_requesting. @{
+                    callStateLabel = context.getString(R.string
+                            .notification_requesting_video_call);
+                    // @}
+                    callStateLabel = appendCountdown(callStateLabel);
+                } else if (VideoUtils.isVideoCall(videoState)) {
+                    callStateLabel = context.getString(R.string.card_title_video_call);
+                }
+                break;
+            case Call.State.ONHOLD:
+                callStateLabel = context.getString(R.string.card_title_on_hold);
+                break;
+            case Call.State.CONNECTING:
+            case Call.State.DIALING:
+                if (hasSuggestedLabel && !isWifi) {
+                    callStateLabel = context.getString(R.string.calling_via_template, label);
+                } else {
+                    callStateLabel = context.getString(R.string.card_title_dialing);
+                }
+                break;
+            case Call.State.REDIALING:
+                callStateLabel = context.getString(R.string.card_title_redialing);
+                break;
+            case Call.State.INCOMING:
+            case Call.State.CALL_WAITING:
+                /// M: [VoLTE conference]incoming volte conference @{
+                if (isIncomingVolteConferenceCall()) {
+                    callStateLabel = context.getString(R.string.card_title_incoming_conference);
+                    break;
+                }
+               /// @}
+
+                if (isWifi && hasSuggestedLabel) {
+                    callStateLabel = label;
+                } else if (isAccount) {
+                    callStateLabel = context.getString(R.string.incoming_via_template, label);
+                } else if (VideoUtils.isVideoCall(videoState)) {
+                    callStateLabel = context.getString(R.string.notification_incoming_video_call);
+                } else {
+                    callStateLabel =
+                            context.getString(isWorkCall ? R.string.card_title_incoming_work_call
+                                    : R.string.card_title_incoming_call);
+                }
+                break;
+            case Call.State.DISCONNECTING:
+                // While in the DISCONNECTING state we display a "Hanging up"
+                // message in order to make the UI feel more responsive.  (In
+                // GSM it's normal to see a delay of a couple of seconds while
+                // negotiating the disconnect with the network, so the "Hanging
+                // up" state at least lets the user know that we're doing
+                // something.  This state is currently not used with CDMA.)
+                callStateLabel = context.getString(R.string.card_title_hanging_up);
+                break;
+            case Call.State.DISCONNECTED:
+                callStateLabel = disconnectCause.getLabel();
+                // M:fix CR:ALPS02584915,UI show error when merge conference call.
+                if (TextUtils.isEmpty(callStateLabel) && !IMS_MERGED_SUCCESSFULLY.equals
+                        (disconnectCause.getReason())) {
+                    Log.d(this," disconnect reason is not ims merged successfully");
+                    callStateLabel = context.getString(R.string.card_title_call_ended);
+                }
+                break;
+            case Call.State.CONFERENCED:
+                callStateLabel = context.getString(R.string.card_title_conf_call);
+                break;
+            default:
+                Log.wtf(this, "updateCallStateWidgets: unexpected call: " + state);
+        }
+        return new CallStateLabel(callStateLabel, isAutoDismissing);
+    }
+
+    private void initializeSecondaryCallInfo(boolean hasProvider) {
+        // mSecondaryCallName is initialized here (vs. onViewCreated) because it is inaccessible
+        // until mSecondaryCallInfo is inflated in the call above.
+        if (mSecondaryCallName == null) {
+            mSecondaryCallName = (TextView) getView().findViewById(R.id.secondaryCallName);
+            mSecondaryCallConferenceCallIcon =
+                    getView().findViewById(R.id.secondaryCallConferenceCallIcon);
+            mSecondaryCallVideoCallIcon =
+                    getView().findViewById(R.id.secondaryCallVideoCallIcon);
+        }
+
+        if (mSecondaryCallProviderLabel == null && hasProvider) {
+            mSecondaryCallProviderInfo.setVisibility(View.VISIBLE);
+            mSecondaryCallProviderLabel = (TextView) getView()
+                    .findViewById(R.id.secondaryCallProviderLabel);
+        }
+    }
+
+    public void dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
+        if (event.getEventType() == AccessibilityEvent.TYPE_ANNOUNCEMENT) {
+            // Indicate this call is in active if no label is provided. The label is empty when
+            // the call is in active, not in other status such as onhold or dialing etc.
+            if (!mCallStateLabel.isShown() || TextUtils.isEmpty(mCallStateLabel.getText())) {
+                event.getText().add(
+                        TextUtils.expandTemplate(
+                                getResources().getText(R.string.accessibility_call_is_active),
+                                mPrimaryName.getText()));
+            } else {
+                dispatchPopulateAccessibilityEvent(event, mCallStateLabel);
+                dispatchPopulateAccessibilityEvent(event, mPrimaryName);
+                dispatchPopulateAccessibilityEvent(event, mCallTypeLabel);
+                dispatchPopulateAccessibilityEvent(event, mPhoneNumber);
+            }
+            return;
+        }
+        dispatchPopulateAccessibilityEvent(event, mCallStateLabel);
+        dispatchPopulateAccessibilityEvent(event, mPrimaryName);
+        dispatchPopulateAccessibilityEvent(event, mPhoneNumber);
+        dispatchPopulateAccessibilityEvent(event, mCallTypeLabel);
+        dispatchPopulateAccessibilityEvent(event, mSecondaryCallName);
+        dispatchPopulateAccessibilityEvent(event, mSecondaryCallProviderLabel);
+
+        return;
+    }
+
+    @Override
+    public void sendAccessibilityAnnouncement() {
+        mHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                if (getView() != null && getView().getParent() != null &&
+                        isAccessibilityEnabled(getContext())) {
+                    AccessibilityEvent event = AccessibilityEvent.obtain(
+                            AccessibilityEvent.TYPE_ANNOUNCEMENT);
+                    dispatchPopulateAccessibilityEvent(event);
+                    getView().getParent().requestSendAccessibilityEvent(getView(), event);
+                }
+            }
+
+            private boolean isAccessibilityEnabled(Context context) {
+                AccessibilityManager accessibilityManager =
+                        (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
+                return accessibilityManager != null && accessibilityManager.isEnabled();
+
+            }
+        }, ACCESSIBILITY_ANNOUNCEMENT_DELAY_MS);
+    }
+
+    @Override
+    public void setEndCallButtonEnabled(boolean enabled, boolean animate) {
+        /// MTK add this log. @{
+        Log.d(this, "setEndCallButtonEnabled enabled = " + enabled
+                + ", animate = " + animate + "; old state = "
+                + mFloatingActionButton.isEnabled() + ", vs =",
+                mFloatingActionButtonContainer.getVisibility());
+        /// @}
+        /// M: not show endcall btn when animation not end for ALPS02159995 @{
+        if(enabled == true && mFloatingActionButton.isEnabled()
+                && mFloatingActionButtonContainer.getVisibility() == View.GONE){
+            mFloatingActionButton.setEnabled(false);
+        }
+        /// @}
+        if (enabled != mFloatingActionButton.isEnabled()) {
+            if (animate) {
+                if (enabled) {
+                    mFloatingActionButtonController.scaleIn(AnimUtils.NO_DELAY);
+                } else {
+                    mFloatingActionButtonController.scaleOut();
+                }
+            } else {
+                if (enabled) {
+                    mFloatingActionButtonContainer.setScaleX(1);
+                    mFloatingActionButtonContainer.setScaleY(1);
+                    mFloatingActionButtonContainer.setVisibility(View.VISIBLE);
+                } else {
+                    mFloatingActionButtonContainer.setVisibility(View.GONE);
+                }
+            }
+            mFloatingActionButton.setEnabled(enabled);
+            updateFabPosition();
+        }
+    }
+
+    /**
+     * Changes the visibility of the HD audio icon.
+     *
+     * @param visible {@code true} if the UI should show the HD audio icon.
+     */
+    @Override
+    public void showHdAudioIndicator(boolean visible) {
+        mHdAudioIcon.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+    /**
+     * Changes the visibility of the forward icon.
+     *
+     * @param visible {@code true} if the UI should show the forward icon.
+     */
+    @Override
+    public void showForwardIndicator(boolean visible) {
+        mForwardIcon.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+
+    /**
+     * Changes the visibility of the "manage conference call" button.
+     *
+     * @param visible Whether to set the button to be visible or not.
+     */
+    @Override
+    public void showManageConferenceCallButton(boolean visible) {
+        mManageConferenceCallButton.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+    /**
+     * Determines the current visibility of the manage conference button.
+     *
+     * @return {@code true} if the button is visible.
+     */
+    @Override
+    public boolean isManageConferenceVisible() {
+        return mManageConferenceCallButton.getVisibility() == View.VISIBLE;
+    }
+
+    /**
+     * Determines the current visibility of the call subject.
+     *
+     * @return {@code true} if the subject is visible.
+     */
+    @Override
+    public boolean isCallSubjectVisible() {
+        return mCallSubject.getVisibility() == View.VISIBLE;
+    }
+
+    /**
+     * Get the overall InCallUI background colors and apply to call card.
+     */
+    @Override
+    public void updateColors() {
+        MaterialPalette themeColors = InCallPresenter.getInstance().getThemeColors();
+
+        if (mCurrentThemeColors != null && mCurrentThemeColors.equals(themeColors)) {
+            return;
+        }
+        if (themeColors == null) {
+            return;
+        }
+        /// M:fix CR:ALPS02321720, JE about ColorDrawable can not be cast
+        /// to GradientDrawable. @{
+        if (getResources().getBoolean(R.bool.is_layout_landscape)
+            && mPrimaryCallCardContainer.getBackground() instanceof GradientDrawable) {
+        /// @}
+            final GradientDrawable drawable =
+                    (GradientDrawable) mPrimaryCallCardContainer.getBackground();
+            drawable.setColor(themeColors.mPrimaryColor);
+        } else {
+			if(!isEmergencyCall()){
+				mPrimaryCallCardContainer.setBackgroundColor(themeColors.mPrimaryColor);
+			} else {
+				mPrimaryCallCardContainer.setBackgroundColor(getResources().getColor(R.color.emergency_call_bg));
+			}
+        }
+		if(!isEmergencyCall()){
+			mCallButtonsContainer.setBackgroundColor(themeColors.mPrimaryColor);
+		} else {
+			mCallButtonsContainer.setBackgroundColor(getResources().getColor(R.color.emergency_call_bg));
+		}
+        mCallSubject.setTextColor(themeColors.mPrimaryColor);
+        mContactContext.setBackgroundColor(themeColors.mPrimaryColor);
+        //TODO: set color of message text in call context "recent messages" to be the theme color.
+
+        mCurrentThemeColors = themeColors;
+    }
+
+    private void dispatchPopulateAccessibilityEvent(AccessibilityEvent event, View view) {
+        if (view == null) return;
+        final List<CharSequence> eventText = event.getText();
+        int size = eventText.size();
+        view.dispatchPopulateAccessibilityEvent(event);
+        // if no text added write null to keep relative position
+        if (size == eventText.size()) {
+            eventText.add(null);
+        }
+    }
+
+    @Override
+    public void animateForNewOutgoingCall() {
+        Log.d(this, "[animateForNewOutgoingCall]");
+        final ViewGroup parent = (ViewGroup) mPrimaryCallCardContainer.getParent();
+
+        final ViewTreeObserver observer = getView().getViewTreeObserver();
+
+        /**
+         * M: [ALPS02494688] Seldom, the onGlobalLayout might not be called. As a result,
+         * the CallCardFragment would stay in animating state forever.
+         * Ref. InCallPresenter.onCallListChange(), it would stop responding to any call
+         * state change if CallCardFragment keep animating. To avoid this seldom issue,
+         * we move this line to where the animation.start() was called.
+         * google default code:
+         * mIsAnimating = true;
+         */
+
+        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                final ViewTreeObserver observer = getView().getViewTreeObserver();
+                if (!observer.isAlive()) {
+                    return;
+                }
+                observer.removeOnGlobalLayoutListener(this);
+
+                final LayoutIgnoringListener listener = new LayoutIgnoringListener();
+                mPrimaryCallCardContainer.addOnLayoutChangeListener(listener);
+
+                // Prepare the state of views before the slide animation
+                final int originalHeight = mPrimaryCallCardContainer.getHeight();
+                mPrimaryCallCardContainer.setTag(R.id.view_tag_callcard_actual_height,
+                        originalHeight);
+                mPrimaryCallCardContainer.setBottom(parent.getHeight());
+
+                // Set up FAB.
+                mFloatingActionButtonContainer.setVisibility(View.GONE);
+                mFloatingActionButtonController.setScreenWidth(parent.getWidth());
+
+                mCallButtonsContainer.setAlpha(0);
+                mCallStateLabel.setAlpha(0);
+                mPrimaryName.setAlpha(0);
+                mCallTypeLabel.setAlpha(0);
+                mCallNumberAndLabel.setAlpha(0);
+
+                assignTranslateAnimation(mCallStateLabel, 1);
+                assignTranslateAnimation(mCallStateIcon, 1);
+                assignTranslateAnimation(mPrimaryName, 2);
+                assignTranslateAnimation(mCallNumberAndLabel, 3);
+                assignTranslateAnimation(mCallTypeLabel, 4);
+                assignTranslateAnimation(mCallButtonsContainer, 5);
+
+                final Animator animator = getShrinkAnimator(parent.getHeight(), originalHeight);
+
+                animator.addListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        /// M: add for MO performance analysis
+                        InCallTrace.begin("ShrinkAnimation end");
+                        /// M: add for monitor call card animation process
+                        Log.i(this, "[onAnimationEnd] end of shrink animation.");
+                        mPrimaryCallCardContainer.setTag(R.id.view_tag_callcard_actual_height,
+                                null);
+                        setViewStatePostAnimation(listener);
+                        mIsAnimating = false;
+                        InCallPresenter.getInstance().onShrinkAnimationComplete();
+
+                        /// M: fix ALPS02302284. update floating end button to animate after
+                        /// the primary call card exit shrink animation from bottom to top. @{
+                        updateFabPosition();
+                        /// @}
+                        /// M: add for MO performance analysis
+                        InCallTrace.end("ShrinkAnimation end");
+                    }
+                });
+                /**
+                 * M: [ALPS02494688] Marking the CallCardFragment in animating state at where
+                 * the animation really happened.
+                 */
+                Log.i(this, "[animateForNewOutgoingCall]start ShrinkAnimation");
+                mIsAnimating = true;
+
+                /// M: add for MO performance analysis @{
+                InCallTrace.begin("ShrinkAnimation start");
+                animator.start();
+                InCallTrace.end("ShrinkAnimation start");
+                /// @}
+            }
+        });
+    }
+
+    @Override
+    public void showNoteSentToast() {
+        Toast.makeText(getContext(), R.string.note_sent, Toast.LENGTH_LONG).show();
+    }
+
+    public void onDialpadVisibilityChange(boolean isShown) {
+        mIsDialpadShowing = isShown;
+        updateFabPosition();
+    }
+
+    private void updateFabPosition() {
+        /**
+         * M: skip update Fab position with animation when FAB is not visible and size is 0X0,
+         * hwui will throw exception when draw view size is 0 and hardware layertype. @{
+         */
+        Log.d(this, "[updateFabPosition] Dialpad:" + mIsDialpadShowing
+                + ",FAB dump: " + mFloatingActionButtonContainer);
+        if (!mFloatingActionButtonController.isVisible()
+                && (mFloatingActionButtonContainer.getWidth() == 0 &&
+                mFloatingActionButtonContainer.getHeight() == 0)) {
+            return;
+        }
+        /** @} */
+
+        int offsetY = 0;
+        if (!mIsDialpadShowing) {
+            offsetY = mFloatingActionButtonVerticalOffset;
+            /// M: Unnecessarily offset in Landscape and change the isShown to
+            // getVisibility check for some case Visibility is change but the
+            // view has not attached to the rootView so will cause the fab
+            // position can not be set correct after it attached.
+            if (mSecondaryCallInfo.getVisibility() == View.VISIBLE
+                    && mHasLargePhoto && !mIsLandscape) {
+                offsetY -= mSecondaryCallInfo.getHeight();
+            }
+            Log.d(this,
+                    "offsetY:"
+                            + offsetY
+                            + ",mSecondaryHeight: "
+                            + mSecondaryCallInfo.getHeight());
+        }
+        mFloatingActionButtonController.align(
+                FloatingActionButtonController.ALIGN_MIDDLE /* align base */,
+                0 /* offsetX */,
+                offsetY,
+                true);
+        mFloatingActionButtonController.resize(
+                mIsDialpadShowing ? mFabSmallDiameter : mFabNormalDiameter, true);
+    }
+
+    @Override
+    public Context getContext() {
+        return getActivity();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        /// M: log enhancement
+        Log.d(this, "onResume...");
+        // If the previous launch animation is still running, cancel it so that we don't get
+        // stuck in an intermediate animation state.
+        if (mAnimatorSet != null && mAnimatorSet.isRunning()) {
+            mAnimatorSet.cancel();
+        }
+
+        mIsLandscape = getResources().getBoolean(R.bool.is_layout_landscape);
+        mHasLargePhoto = getResources().getBoolean(R.bool.has_large_photo);
+
+        final ViewGroup parent = ((ViewGroup) mPrimaryCallCardContainer.getParent());
+        final ViewTreeObserver observer = parent.getViewTreeObserver();
+        parent.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                ViewTreeObserver viewTreeObserver = observer;
+                if (!viewTreeObserver.isAlive()) {
+                    viewTreeObserver = parent.getViewTreeObserver();
+                }
+                viewTreeObserver.removeOnGlobalLayoutListener(this);
+                mFloatingActionButtonController.setScreenWidth(parent.getWidth());
+                updateFabPosition();
+            }
+        });
+
+        updateColors();
+    }
+
+    /**
+     * Adds a global layout listener to update the FAB's positioning on the next layout. This allows
+     * us to position the FAB after the secondary call info's height has been calculated.
+     */
+    private void updateFabPositionForSecondaryCallInfo() {
+        mSecondaryCallInfo.getViewTreeObserver().addOnGlobalLayoutListener(
+                new ViewTreeObserver.OnGlobalLayoutListener() {
+                    @Override
+                    public void onGlobalLayout() {
+                        final ViewTreeObserver observer = mSecondaryCallInfo.getViewTreeObserver();
+                        if (!observer.isAlive()) {
+                            return;
+                        }
+                        observer.removeOnGlobalLayoutListener(this);
+
+                        onDialpadVisibilityChange(mIsDialpadShowing);
+                    }
+                });
+    }
+
+    /**
+     * Animator that performs the upwards shrinking animation of the blue call card scrim.
+     * At the start of the animation, each child view is moved downwards by a pre-specified amount
+     * and then translated upwards together with the scrim.
+     */
+    private Animator getShrinkAnimator(int startHeight, int endHeight) {
+        final ObjectAnimator shrinkAnimator =
+                ObjectAnimator.ofInt(mPrimaryCallCardContainer, "bottom", startHeight, endHeight);
+        shrinkAnimator.setDuration(mShrinkAnimationDuration);
+        shrinkAnimator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                mFloatingActionButton.setEnabled(true);
+            }
+        });
+        shrinkAnimator.setInterpolator(AnimUtils.EASE_IN);
+        return shrinkAnimator;
+    }
+
+    private void assignTranslateAnimation(View view, int offset) {
+        view.setLayerType(View.LAYER_TYPE_HARDWARE, null);
+        view.buildLayer();
+        view.setTranslationY(mTranslationOffset * offset);
+        view.animate().translationY(0).alpha(1).withLayer()
+                .setDuration(mShrinkAnimationDuration).setInterpolator(AnimUtils.EASE_IN);
+    }
+
+    private void setViewStatePostAnimation(View view) {
+        view.setTranslationY(0);
+        view.setAlpha(1);
+    }
+
+    private void setViewStatePostAnimation(OnLayoutChangeListener layoutChangeListener) {
+        setViewStatePostAnimation(mCallButtonsContainer);
+        setViewStatePostAnimation(mCallStateLabel);
+        setViewStatePostAnimation(mPrimaryName);
+        setViewStatePostAnimation(mCallTypeLabel);
+        setViewStatePostAnimation(mCallNumberAndLabel);
+        setViewStatePostAnimation(mCallStateIcon);
+
+        mPrimaryCallCardContainer.removeOnLayoutChangeListener(layoutChangeListener);
+
+        /// M: For ALPS01761179 & ALPS01794859, don't show end button if state
+        // is incoming or disconnected. @{
+        final Call call = CallList.getInstance().getFirstCall();
+        if (call != null) {
+            int state = call.getState();
+            if (!Call.State.isIncoming(state) && Call.State.isConnectingOrConnected(state)) {
+                mFloatingActionButtonController.scaleIn(AnimUtils.NO_DELAY);
+                Log.d(this, "setViewStatePostAnimation end.");
+            /// M: For ALPS01828090 disable end call button when end button do not show under
+            // call state is disconnected.
+            // in order to setEndCallButtonEnabled() can get right mFloatingActionButton state
+            // to show end button to other connecting or connected calls @{
+            } else if (mFloatingActionButton.isEnabled()) {
+                Log.i(this, "mFloatingActionButton.setEnabled(false) when end button do not show");
+                mFloatingActionButton.setEnabled(false);
+            }
+            /// @}
+        }
+        /// @}
+    }
+
+    private final class LayoutIgnoringListener implements View.OnLayoutChangeListener {
+        @Override
+        public void onLayoutChange(View v,
+                int left,
+                int top,
+                int right,
+                int bottom,
+                int oldLeft,
+                int oldTop,
+                int oldRight,
+                int oldBottom) {
+            v.setLeft(oldLeft);
+            v.setRight(oldRight);
+            v.setTop(oldTop);
+            v.setBottom(oldBottom);
+        }
+    }
+
+    /// M: For second call color @{
+    private int mCurrentSecondCallColor;
+    /// @}
+
+    // Fix ALPS01759672. @{
+    @Override
+    public void setSecondaryEnabled(boolean enabled) {
+        if (mSecondaryCallInfo != null) {
+            mSecondaryCallInfo.setEnabled(enabled);
+        }
+    }
+
+    // @}
+
+    /// M: For second call color @{
+    /**
+     * Get the second call color and apply to second call provider label.
+     */
+    public void updateSecondCallColor() {
+        int secondCallColor = getPresenter().getSecondCallColor();
+        if (mCurrentSecondCallColor == secondCallColor) {
+            return;
+        }
+        if (mSecondaryCallProviderLabel != null) {
+            mSecondaryCallProviderLabel.setTextColor(secondCallColor);
+        }
+        mCurrentSecondCallColor = secondCallColor;
+    }
+
+    /**
+     * M: check whether the callStateIcon has no change.
+     * @param callStateIcon call state icon
+     * @return true if no change
+     */
+    private boolean isCallStateIconChanged(Drawable callStateIcon) {
+        return (mCallStateIcon.getDrawable() != null && callStateIcon == null)
+                || (mCallStateIcon.getDrawable() == null && callStateIcon != null);
+    }
+    /// @}
+
+    /**
+     * M: check incoming call conference call or not.
+     * @return
+     */
+    private boolean isIncomingVolteConferenceCall() {
+        Call call = CallList.getInstance().getIncomingCall();
+        return InCallUIVolteUtils.isIncomingVolteConferenceCall(call);
+    }
+
+    /// M: [Voice Record]recording indication icon @{
+    private ImageView mVoiceRecorderIcon;
+	private TextView mVoiceRecorderTimer;
+
+    private Timer mTimer = null;
+	public static long mStartTime = 0;
+    Handler mTimerHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case 1236:
+                synchronized (this) {
+                    updateVoiceRecorderTimer();
+                }
+                break;
+
+            default:
+                break;
+            }
+        }
+    };
+    private TimerTask mRecordeTrask = null;
+    private void initVoiceRecorderIcon(View view) {
+        mVoiceRecorderIcon = (ImageView) view.findViewById(R.id.voiceRecorderIcon);
+        mVoiceRecorderIcon.setImageResource(R.drawable.voice_record);
+        mVoiceRecorderIcon.setVisibility(View.INVISIBLE);
+		mVoiceRecorderTimer = (TextView) view.findViewById(R.id.voiceRecorderTime);
+		mVoiceRecorderTimer.setText("00:00");
+		mVoiceRecorderTimer.setVisibility(View.INVISIBLE);
+    }
+
+    @Override
+    public void updateVoiceRecordIcon(boolean show) {
+        mVoiceRecorderIcon.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
+        AnimationDrawable ad = (AnimationDrawable) mVoiceRecorderIcon.getDrawable();
+        if (ad != null) {
+            if (show && !ad.isRunning()) {
+                ad.start();
+            } else if (!show && ad.isRunning()) {
+                ad.stop();
+            }
+        }
+		
+		mVoiceRecorderTimer.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
+		if (show && isManageConferenceVisible()) {
+            mVoiceRecorderTimer.setTextColor(0xff0000ff);
+        } else {
+            mVoiceRecorderTimer.setTextColor(0xffffffff);
+        }
+		if(show) {
+			if(mStartTime == 0) {
+				mStartTime = System.currentTimeMillis();
+				mVoiceRecorderTimer.setText("00:00");
+			} else {
+				updateVoiceRecorderTimer();
+			}
+			if(mTimer == null) {
+				mTimer = new Timer();
+			}
+			if(mRecordeTrask != null) {
+				mRecordeTrask.cancel();
+			}
+			mRecordeTrask = new TimerTask() {
+				@Override
+				public void run() {
+				    // TODO Auto-generated method stub
+				    Message message = mTimerHandler.obtainMessage(1236);
+				    mTimerHandler.sendMessage(message);
+				}
+			};
+			mTimer.schedule(mRecordeTrask, 500, 1000);
+		}
+		else{
+			mStartTime = 0;
+			if(mTimer != null ) {
+				mTimer.cancel();
+				mTimer = null;
+			}
+			if(mRecordeTrask != null) {
+				mRecordeTrask.cancel();
+				mRecordeTrask = null;
+			}
+		}
+        /// M:[RCS] plugin API @{
+        ExtensionManager.getRCSeCallCardExt().updateVoiceRecordIcon(show);
+        /// @}
+    }
+    /// @}
+	private void updateVoiceRecorderTimer(){
+		long during = (System.currentTimeMillis()- mStartTime) / 1000;
+		long sec = during % 60;
+		long min = during / 60;
+		StringBuffer sb = new StringBuffer();
+		if(min < 10) {
+			sb.append("0");
+		}
+		sb.append(min+":");
+		if(sec < 10) {
+			sb.append("0");
+		}
+		sb.append(sec+"");
+		if(mVoiceRecorderTimer != null) {
+			mVoiceRecorderTimer.setText(sb.toString());
+		}
+    }
+    /**
+     * M: [CTA]CTA required that in Simplified Chinese, the text label of the secondary/tertiary
+     * call should be changed to another string rather than google default.
+     * @return the right resId CTS required.
+     */
+    private int getCtaSpecificOnHoldResId() {
+        Locale currentLocale = getActivity().getResources().getConfiguration().locale;
+        if (Locale.SIMPLIFIED_CHINESE.getCountry().equals(currentLocale.getCountry())
+                && Locale.SIMPLIFIED_CHINESE.getLanguage().equals(currentLocale.getLanguage())) {
+            return R.string.onHold_cta;
+        }
+        return R.string.onHold;
+    }
+
+    private CharSequence appendCountdown(CharSequence originalText) {
+        long countdown = getPresenter().getCountdown();
+        if (countdown < 0) {
+            return originalText;
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(originalText).append(" (").append(countdown).append(")");
+        return sb.toString();
+    }
+
+    /**
+     * M: Determines the height of the call card.
+     *
+     * @return The height of the call card.
+     */
+    public float getCallCardViewHeight() {
+        return getView().getHeight();
+    }
+
+    /**
+     * M: Determines the width of the call card.
+     *
+     * @return The width of the call card.
+     */
+    public float getCallCardViewWidth() {
+        return getView().getWidth();
+    }
+
+    /**
+     * M: get whether VideoDisplayView is visible .
+     *
+     * @return false means can't visible.
+     */
+    @Override
+    public boolean isVideoDisplayViewVisible() {
+        if(getView() == null) {
+            return false;
+        }
+        final View videoView = getView().findViewById(R.id.incomingVideo);
+        if(videoView == null) {
+            return false;
+        }
+        return videoView.getVisibility() == View.VISIBLE ;
+    }
+
+    /**
+     * M: set photo visible or not .
+     */
+    @Override
+    public void setPhotoVisible(boolean visible) {
+        if(mPhotoLarge == null) {
+            Log.d(this, "[setPhotoVisible]mPhotoLarge is null return");
+            return ;
+        }
+        mPhotoLarge.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+    /**
+     * M: [Video call]In landscape mode, the End button should placed to somewhere
+     * no covering CallCard and Preview.
+     * @return the offset from middle.
+     */
+    private int getEndButtonOffsetXFromMiddle() {
+        // For port, the end button would be in the middle of the screen.
+        if (!mIsLandscape) {
+            return 0;
+        }
+        // For land, the end button would be placed a little right to the middle to
+        // avoid covering neither CallCard nor Preview.
+        // We decided to place the left edge of the end button to the middle.
+        // refer to the updateFabPosition() method.
+        int endButtonSize = mIsDialpadShowing ? mFabSmallDiameter : mFabNormalDiameter;
+        return endButtonSize / 2;
+    }
+
+    /**
+     * M: [1A1H2W]when enter or leave 2W, update the mSecondaryCallInfo view position.
+     */
+    private void updateAnswerViewPosition() {
+        int bottomPadding = 0;
+        if (CallList.getInstance().getSecondaryIncomingCall() != null) {
+            bottomPadding = mSecondaryCallInfo.getHeight();
+        }
+
+        View answerView = getView() != null ?
+                getView().findViewById(R.id.answer_and_dialpad_container) : null;
+        if (answerView == null) {
+            return;
+        }
+
+        int oldBottomPadding = answerView.getPaddingBottom();
+        if (bottomPadding != oldBottomPadding) {
+            answerView.setPadding(answerView.getPaddingLeft(), answerView.getPaddingTop(),
+                    answerView.getPaddingRight(), bottomPadding);
+            Log.d(this, "updateSecondaryCallInfoPosition, bottomPadding = " + bottomPadding);
+            answerView.invalidate();
+        }
+    }
+	
+	private boolean isEmergencyCall() {
+		final CallList calls = CallList.getInstance();
+        final Call call = calls.getFirstCall();
+		if (call != null) {
+			return call.isEmergencyCall();
+		} else {
+			return false;
+		}
+	}
+	class ChangeCallReceiver extends BroadcastReceiver{
+
+		@Override
+		public void onReceive(Context context, Intent intent) {
+			String action=intent.getAction();
+			if("com.android.server.telecom.CHANGECALL".equals(action)){
+				getPresenter().secondaryInfoClicked();
+                updateFabPositionForSecondaryCallInfo();
+			}
+		}
+	} 
+}
Index: vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/res/layout/primary_call_info.xml
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/res/layout/primary_call_info.xml	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/apps/Dialer/InCallUI/res/layout/primary_call_info.xml	(revision 14847)
@@ -0,0 +1,243 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+  ~ Copyright (C) 2013 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+
+<!-- "Call Banner" for primary call, the foregound or ringing call. The "call banner" is a block
+    of info about a single call, including the contact name, phone number, call time counter, and
+    other status info.  This info is shown as a "banner" overlaid across the top of contact photo.
+    -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        android:id="@+id/primary_call_banner"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:paddingStart="@dimen/call_banner_side_padding"
+        android:paddingEnd="@dimen/call_banner_side_padding"
+        android:clipChildren="false"
+        android:clipToPadding="false"
+        android:gravity="center">
+
+    <LinearLayout android:id="@+id/callSubjectLayout"
+                  android:layout_width="match_parent"
+                  android:layout_height="wrap_content"
+                  android:orientation="horizontal"
+                  android:clipChildren="false"
+                  android:clipToPadding="false">
+
+        <TextView android:id="@+id/callSubject"
+                  android:layout_width="wrap_content"
+                  android:layout_height="wrap_content"
+                  android:textAlignment="viewStart"
+                  android:textAppearance="?android:attr/textAppearanceSmall"
+                  android:textColor="@color/incall_call_banner_background_color"
+                  android:textSize="@dimen/call_label_text_size"
+                  android:background="@drawable/subject_bubble"
+                  android:maxLines="2"
+                  android:ellipsize="end"
+                  android:singleLine="false"
+                  android:visibility="gone" />
+    </LinearLayout>
+
+    <!-- M: ALPS03365142, fix callStateLabel layout issue,
+         android:baselineAligned="false" -->
+    <LinearLayout android:id="@+id/callStateButton"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:clipChildren="false"
+        android:clipToPadding="false"
+        android:baselineAligned="false">
+
+        <ImageView android:id="@+id/workProfileIcon"
+            android:src="@drawable/ic_work_profile"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_weight="0"
+            android:layout_marginEnd="8dp"
+            android:baselineAlignBottom="true"
+            android:tint="@color/incall_accent_color"
+            android:scaleType="center"
+            android:visibility="gone" />
+
+        <!-- Subscription provider or WiFi calling icon displayed to the left of the label -->
+        <ImageView android:id="@+id/callStateIcon"
+            android:layout_width="24dp"
+            android:layout_height="match_parent"
+            android:layout_marginEnd="10dp"
+            android:tint="@color/incall_accent_color"
+            android:alpha="0.0"
+            android:scaleType="fitCenter"
+            android:visibility="gone" />
+
+        <ImageView android:id="@+id/videoCallIcon"
+            android:src="@drawable/ic_toolbar_video"
+            android:layout_width="16dp"
+            android:layout_height="match_parent"
+            android:layout_marginEnd="16dp"
+            android:baselineAlignBottom="true"
+            android:tint="@color/incall_accent_color"
+            android:scaleType="center"
+            android:visibility="gone" />
+
+        <com.android.phone.common.widget.ResizingTextTextView
+            xmlns:ex="http://schemas.android.com/apk/res-auto"
+            android:id="@+id/callStateLabel"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:textAlignment="viewStart"
+            android:textAppearance="?android:attr/textAppearanceLarge"
+            android:textColor="@color/incall_accent_color"
+            android:textSize="@dimen/call_status_text_size"
+            android:alpha="0.7"
+            android:singleLine="true"
+            android:gravity="start"
+            android:ellipsize="end"
+            ex:resizing_text_min_size="@dimen/call_status_text_min_size" />
+
+    </LinearLayout>
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <!-- Name (or the phone number, if we don't have a name to display). -->
+        <com.android.phone.common.widget.ResizingTextTextView
+            xmlns:ex="http://schemas.android.com/apk/res-auto"
+            android:id="@+id/name"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="-5dp"
+            android:fontFamily="sans-serif-light"
+            android:textAlignment="viewStart"
+            android:textAppearance="?android:attr/textAppearanceLarge"
+            android:textSize="@dimen/call_name_text_min_size"
+            android:singleLine="true"
+            android:ellipsize="marquee"
+            android:marqueeRepeatLimit="marquee_forever"
+            android:focusable="true"
+            ex:resizing_text_min_size="@dimen/call_name_text_min_size" />
+
+        <!-- Contact photo for primary call info -->
+        <ImageView android:id="@+id/photoSmall"
+            android:layout_width="@dimen/contact_context_small_photo_size"
+            android:layout_height="@dimen/contact_context_small_photo_size"
+            android:layout_centerVertical="true"
+            android:layout_alignParentEnd="true"
+            android:scaleType="centerCrop"
+            android:importantForAccessibility="no"
+            android:src="@drawable/img_no_image_automirrored" />
+    </RelativeLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:clipChildren="false"
+        android:clipToPadding="false">
+
+        <ImageView android:id="@+id/hdAudioIcon"
+            android:src="@drawable/ic_hd_24dp"
+            android:layout_width="24dp"
+            android:layout_height="match_parent"
+            android:layout_marginEnd="8dp"
+            android:tint="@color/incall_call_banner_subtext_color"
+            android:scaleType="fitCenter"
+            android:visibility="gone" />
+
+        <ImageView android:id="@+id/forwardIcon"
+            android:src="@drawable/ic_forward_white_24dp"
+            android:layout_width="24dp"
+            android:layout_height="match_parent"
+            android:layout_marginEnd="8dp"
+            android:tint="@color/incall_call_banner_subtext_color"
+            android:scaleType="fitCenter"
+            android:visibility="gone" />
+
+        <!-- Label (like "Mobile" or "Work", if present) and phone number, side by side -->
+        <LinearLayout android:id="@+id/labelAndNumber"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:orientation="horizontal">
+
+            <!--M: fix ALPS02341761, update text view content layout:
+                add properties: android:ellipsize="middle" and android:maxWidth="70dp"-->
+            <TextView android:id="@+id/label"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="0"
+                android:textAppearance="?android:attr/textAppearanceSmall"
+                android:textColor="@color/incall_call_banner_subtext_color"
+                android:textSize="@dimen/call_label_text_size"
+                android:singleLine="true"
+                android:ellipsize="middle"
+                android:maxWidth="70dp"
+                android:textDirection="ltr"
+                android:visibility="gone" />
+
+            <!--M: fix ALPS02341761, update text view content layout:
+                add properties: android:ellipsize="start"; update: android:singleLine="false" to be "true"-->
+            <TextView android:id="@+id/phoneNumber"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:layout_marginStart="6dp"
+                android:textAlignment="viewStart"
+                android:textAppearance="?android:attr/textAppearanceSmall"
+                android:textColor="@color/incall_call_banner_subtext_color"
+                android:textSize="@dimen/call_label_text_size"
+                android:singleLine="true"
+                android:ellipsize="start"
+                android:visibility="gone" />
+
+        </LinearLayout>
+
+        <!-- Elapsed time indication for a call in progress. -->
+        <TextView android:id="@+id/elapsedTime"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_weight="0"
+            android:textAlignment="viewEnd"
+            android:textAppearance="?android:attr/textAppearanceSmall"
+            android:textColor="@color/incall_call_banner_subtext_color"
+            android:textSize="@dimen/call_label_text_size"
+            android:singleLine="true"
+            android:visibility="gone" />
+
+    </LinearLayout>
+	
+	<TextView android:id="@+id/callVolteTypeLabel"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAppearance="?android:attr/textAppearanceSmall"
+        android:textColor="@color/incall_call_banner_text_color"
+        android:maxLines="1"
+        android:ellipsize="end"
+        android:visibility="gone" />
+
+    <!-- Call type indication: a special label and/or branding
+     for certain kinds of calls (like "SIP call" for a SIP call.) -->
+    <TextView android:id="@+id/callTypeLabel"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAppearance="?android:attr/textAppearanceSmall"
+        android:textColor="@color/incall_call_banner_text_color"
+        android:maxLines="1"
+        android:ellipsize="end"
+        android:visibility="gone" />
+
+</LinearLayout> <!-- End of call_banner -->
Index: vendor/branch/5058A_Claro_Peru/packages/services/Telecomm/src/com/android/server/telecom/CallLogManager.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/services/Telecomm/src/com/android/server/telecom/CallLogManager.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/services/Telecomm/src/com/android/server/telecom/CallLogManager.java	(revision 14847)
@@ -0,0 +1,1011 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright 2014, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.telecom;
+
+import android.annotation.Nullable;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.location.Country;
+import android.location.CountryDetector;
+import android.location.CountryListener;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.UserHandle;
+import android.os.PersistableBundle;
+import android.provider.CallLog.Calls;
+import android.provider.CallLog.ConferenceCalls;
+import android.telecom.Connection;
+import android.telecom.DisconnectCause;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telecom.VideoProfile;
+import android.telephony.CarrierConfigManager;
+import android.telephony.PhoneNumberUtils;
+import android.widget.Toast;
+import android.text.TextUtils;
+
+//begin added by jiayi.wang for task 3682185 at 2017.01.04
+import android.content.ContentProviderClient;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+//end added by jiayi.wang for task 3682185 at 2017.01.04
+
+// TODO: Needed for move to system service: import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.CallerInfo;
+import com.mediatek.telecom.ext.ExtensionManager;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Locale;
+import com.mediatek.telephony.TelephonyManagerEx;
+
+/**
+ * Helper class that provides functionality to write information about calls and their associated
+ * caller details to the call log. All logging activity will be performed asynchronously in a
+ * background thread to avoid blocking on the main thread.
+ */
+@VisibleForTesting
+public final class CallLogManager extends CallsManagerListenerBase {
+
+    public interface LogCallCompletedListener {
+        void onLogCompleted(@Nullable Uri uri);
+    }
+
+    /**
+     * Parameter object to hold the arguments to add a call in the call log DB.
+     */
+    private static class AddCallArgs {
+        /**
+         * @param callerInfo Caller details.
+         * @param number The phone number to be logged.
+         * @param presentation Number presentation of the phone number to be logged.
+         * @param callType The type of call (e.g INCOMING_TYPE). @see
+         *     {@link android.provider.CallLog} for the list of values.
+         * @param features The features of the call (e.g. FEATURES_VIDEO). @see
+         *     {@link android.provider.CallLog} for the list of values.
+         * @param creationDate Time when the call was created (milliseconds since epoch).
+         * @param durationInMillis Duration of the call (milliseconds).
+         * @param dataUsage Data usage in bytes, or null if not applicable.
+         * @param logCallCompletedListener optional callback called after the call is logged.
+         * @param conferenceCallLogId The conference call callLog id.
+         * @param conferenceDurationInMillis The conference call duration.
+         */
+        public AddCallArgs(Context context, CallerInfo callerInfo, String number,
+                String postDialDigits, String viaNumber, int presentation, int callType,
+                int features, PhoneAccountHandle accountHandle, long creationDate,
+                long durationInMillis, Long dataUsage, UserHandle initiatingUser,
+                @Nullable LogCallCompletedListener logCallCompletedListener,
+                long conferenceCallLogId, /* M: For Conference call */
+                long conferenceDurationInMillis /* M: For Conference call */) {
+            this.context = context;
+            this.callerInfo = callerInfo;
+            this.number = number;
+            this.postDialDigits = postDialDigits;
+            this.viaNumber = viaNumber;
+            this.presentation = presentation;
+            this.callType = callType;
+            this.features = features;
+            this.accountHandle = accountHandle;
+            this.timestamp = creationDate;
+            this.durationInSec = (int)(durationInMillis / 1000);
+            this.dataUsage = dataUsage;
+            this.initiatingUser = initiatingUser;
+            this.logCallCompletedListener = logCallCompletedListener;
+            /// M: For Volte conference call calllog
+            this.conferenceCallLogId = conferenceCallLogId;
+            this.conferenceDurationInSec = (int)(conferenceDurationInMillis / 1000);
+        }
+        // Since the members are accessed directly, we don't use the
+        // mXxxx notation.
+        public final Context context;
+        public final CallerInfo callerInfo;
+        public final String number;
+        public final String postDialDigits;
+        public final String viaNumber;
+        public final int presentation;
+        public final int callType;
+        public final int features;
+        public final PhoneAccountHandle accountHandle;
+        public final long timestamp;
+        public final int durationInSec;
+        public final Long dataUsage;
+        public final UserHandle initiatingUser;
+        /// M: For Volte conference call calllog
+        public final long conferenceCallLogId;
+        public final int conferenceDurationInSec;
+
+        @Nullable
+        public final LogCallCompletedListener logCallCompletedListener;
+    }
+
+    private static final String TAG = CallLogManager.class.getSimpleName();
+
+    private final Context mContext;
+    private final PhoneAccountRegistrar mPhoneAccountRegistrar;
+    private final MissedCallNotifier mMissedCallNotifier;
+    private static final String ACTION_CALLS_TABLE_ADD_ENTRY =
+                "com.android.server.telecom.intent.action.CALLS_ADD_ENTRY";
+    private static final String PERMISSION_PROCESS_CALLLOG_INFO =
+                "android.permission.PROCESS_CALLLOG_INFO";
+    private static final String CALL_TYPE = "callType";
+    private static final String CALL_DURATION = "duration";
+
+    //begin added by jiayi.wang for task 3682185 at 2017.01.04
+    private static final String SCHEME = "content";
+    private static final String AUTHORITY = "com.tct.diagnostics.provider.diagnosticsinfo";
+    private static final String TABLE_NAME = "diagnostics";
+    private static final Uri CONTENT_URI = new Uri.Builder().scheme(SCHEME).authority(AUTHORITY).path(TABLE_NAME).build();
+    //end added by jiayi.wang for task 3682185 at 2017.01.04
+
+    private Object mLock;
+    private String mCurrentCountryIso;
+
+    public CallLogManager(Context context, PhoneAccountRegistrar phoneAccountRegistrar,
+            MissedCallNotifier missedCallNotifier) {
+        mContext = context;
+        mPhoneAccountRegistrar = phoneAccountRegistrar;
+        mMissedCallNotifier = missedCallNotifier;
+        mLock = new Object();
+    }
+
+    @Override
+    public void onCallStateChanged(Call call, int oldState, int newState) {
+        int disconnectCause = call.getDisconnectCause().getCode();
+        boolean isNewlyDisconnected =
+                newState == CallState.DISCONNECTED || newState == CallState.ABORTED;
+        boolean isCallCanceled = isNewlyDisconnected && disconnectCause == DisconnectCause.CANCELED;
+        /// M: Ignore Conference child call, because its DisconnectCause always is CANCELED @{
+        if (call.getConferenceCallLogId() > 0) {
+            isCallCanceled = false;
+        }
+        Log.d(TAG, "onCallStateChanged [" + call.getId()
+                + ", " + Log.piiHandle(call.getOriginalHandle())
+                + "] isNewlyDisconnected:" + isNewlyDisconnected
+                + ", oldState:" + CallState.toString(oldState)
+                + ", newState:" + CallState.toString(newState)
+                + ", call.isConference():" + call.isConference()
+                + ", isCallCanceled:" + isCallCanceled
+                + ", hasParent:" + (call.getParentCall() != null)
+                + ", ConferenceCallLogId:" + call.getConferenceCallLogId());
+        /// @}
+
+        // Log newly disconnected calls only if:
+        // 1) It was not in the "choose account" phase when disconnected
+        // 2) It is a conference call
+        // 3) Call was not explicitly canceled
+        // 4) Call is not an external call
+        if (isNewlyDisconnected &&
+                (oldState != CallState.SELECT_PHONE_ACCOUNT &&
+                 !call.isConference() &&
+                 !isCallCanceled) &&
+                !call.isExternalCall()) {
+            int type;
+            if (!call.isIncoming()) {
+                type = Calls.OUTGOING_TYPE;
+            } else if (disconnectCause == DisconnectCause.MISSED) {
+                type = Calls.MISSED_TYPE;
+            } else if (disconnectCause == DisconnectCause.ANSWERED_ELSEWHERE) {
+                type = Calls.ANSWERED_EXTERNALLY_TYPE;
+            } else if (disconnectCause == DisconnectCause.REJECTED) {
+                type = Calls.REJECTED_TYPE;
+            } else {
+                type = Calls.INCOMING_TYPE;
+            }
+
+            /// M: Show call duration @{
+            String disconnectReason = call.getDisconnectCause().getReason() == null ? ""
+                    : call.getDisconnectCause().getReason();
+            if (oldState != CallState.DIALING && oldState != CallState.RINGING
+                    && call.getConferenceCallLogId() <= 0
+                    && !disconnectReason.contains(IMS_MERGED_SUCCESSFULLY)) {
+                showCallDuration(call);
+            }
+            /// @}
+
+            logCall(call, type, true /*showNotificationForMissedCall*/);
+			//begin added by jiayi.wang for task 3682185 at 2017.01.04
+            if (isDiagnosticProject()) {
+                recordCall(disconnectCause,type);
+            }
+            //end added by jiayi.wang for task 3682185 at 2017.01.04
+        }
+
+        /// M: Log the conference unconnected participants (such as connect fail, remote reject)
+        /// which need handle specially due to they can not be generated telecom call. @{
+        if (isNewlyDisconnected && call.isConferenceDial() &&
+            call.isConference() && !isCallCanceled) {
+            logConferenceUnconnectedParticipants(call);
+        }
+        /// @}
+        if (isNewlyDisconnected && call.isConference() && !isCallCanceled) {
+            insertOrUpdateConferenceDuration(call);
+        }
+    }
+
+    private void insertOrUpdateConferenceDuration(Call call) {
+        Log.d(TAG, "insertOrUpdateConferenceDuration");
+        final long id = getConferenceCallLogId(call.getConferenceCallLogId());
+        Log.d(TAG, "mapped conference ID is " + id);
+        ContentResolver resolver = mContext.getContentResolver();
+        final int duration = (int)(call.getAgeMillis() / 1000);
+        Log.d(TAG, "duration in seconds is " + duration);
+        ConferenceCalls.updateConferenceDurationIfNeeded(
+                                                         resolver,
+                                                         id,
+                                                         duration);
+
+    }
+
+    /// M: Log the conference unconnected participants
+    void logConferenceUnconnectedParticipants(Call conferenceCall) {
+        long confCallLogId = conferenceCall.getConferenceCallLogId();
+        if (confCallLogId <= 0) {
+            // Use conference create time as the conference temp id
+            confCallLogId = conferenceCall.getCreationTimeMillis();
+            conferenceCall.setConferenceCallLogId(confCallLogId);
+        }
+        Log.d(TAG, "logConferenceUnconnectedParticipants confCallLogId=" + confCallLogId);
+        for (String number : conferenceCall.getUnconnectedParticipants()) {
+            String postDialDigits = number != null
+                    ? PhoneNumberUtils.extractPostDialPortion(number) : "";
+            /// M: Avoid to log duplicated post dial digits. @{
+            if (!TextUtils.isEmpty(postDialDigits)
+                    && postDialDigits.equals(PhoneNumberUtils.extractPostDialPortion(number))) {
+                number = PhoneNumberUtils.extractNetworkPortionAlt(number);
+            }
+            /// @}
+            int handlePresentation = TelecomManager.PRESENTATION_ALLOWED;
+            int type = Calls.OUTGOING_TYPE;
+            int callFeatures = getCallFeatures(conferenceCall.getVideoStateHistory(), false);
+            PhoneAccountHandle accountHandle = conferenceCall.getTargetPhoneAccount();
+            long creationTime = conferenceCall.getCreationTimeMillis();
+            boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(number);
+            UserHandle initUser = conferenceCall.getInitiatingUser();
+            logCall(null, number, postDialDigits, "",
+                    handlePresentation, type, callFeatures, accountHandle,
+                    creationTime, 0, null, isEmergencyNumber, initUser,
+                    null, confCallLogId, -1);
+        }
+    }
+
+    void logCall(Call call, int type, boolean showNotificationForMissedCall) {
+        if (type == Calls.MISSED_TYPE && showNotificationForMissedCall) {
+            logCall(call, Calls.MISSED_TYPE,
+                    new LogCallCompletedListener() {
+                        @Override
+                        public void onLogCompleted(@Nullable Uri uri) {
+                            mMissedCallNotifier.showMissedCallNotification(call);
+                        }
+                    });
+        } else {
+            logCall(call, type, null);
+        }
+    }
+
+    /**
+     * Logs a call to the call log based on the {@link Call} object passed in.
+     *
+     * @param call The call object being logged
+     * @param callLogType The type of call log entry to log this call as. See:
+     *     {@link android.provider.CallLog.Calls#INCOMING_TYPE}
+     *     {@link android.provider.CallLog.Calls#OUTGOING_TYPE}
+     *     {@link android.provider.CallLog.Calls#MISSED_TYPE}
+     * @param logCallCompletedListener optional callback called after the call is logged.
+     */
+    void logCall(Call call, int callLogType,
+        @Nullable LogCallCompletedListener logCallCompletedListener) {
+        final long creationTime = call.getCreationTimeMillis();
+        final long age = call.getAgeMillis();
+
+        final String logNumber = getLogNumber(call);
+        /// M: ALPS01899538, when dial a empty voice mail number fail, should not log this @{
+        if (PhoneAccount.SCHEME_VOICEMAIL.equals(getLogScheme(call))
+                && TextUtils.isEmpty(logNumber)) {
+            Log.d(TAG, "Empty voice mail logNumber");
+            return;
+        }
+        /// @}
+
+        /// M: Update the CS call into IMS call callLog for conference SRVCC case @{
+        if (handleConferenceSrvccCallLog(call, logNumber)) {
+            return;
+        }
+        /// @}
+
+        Log.d(TAG, "logNumber set to: %s", Log.pii(logNumber));
+
+        final PhoneAccountHandle emergencyAccountHandle =
+                TelephonyUtil.getDefaultEmergencyPhoneAccount().getAccountHandle();
+
+        String formattedViaNumber = PhoneNumberUtils.formatNumber(call.getViaNumber(),
+                getCountryIso());
+        formattedViaNumber = (formattedViaNumber != null) ?
+                formattedViaNumber : call.getViaNumber();
+
+        PhoneAccountHandle accountHandle = call.getTargetPhoneAccount();
+        if (emergencyAccountHandle.equals(accountHandle)) {
+            accountHandle = null;
+        }
+
+        Long callDataUsage = call.getCallDataUsage() == Call.DATA_USAGE_NOT_SET ? null :
+                call.getCallDataUsage();
+
+        int callFeatures = getCallFeatures(call.getVideoStateHistory(),
+                call.getDisconnectCause().getCode() == DisconnectCause.CALL_PULLED);
+
+        ///M: Plugin to get call features corresponds to different call type
+        callFeatures = ExtensionManager.getCallMgrExt().getCallFeatures(
+                call.getConnectionManagerPhoneAccount(), callFeatures);
+
+        long conferenceDuration = -1;
+        if (call.getParentCall() != null) {
+            conferenceDuration = call.getParentCall().getAgeMillis();
+        }
+        Log.d(TAG, "conferenceDuration: " + conferenceDuration);
+
+        logCall(call.getCallerInfo(), logNumber, call.getPostDialDigits(), formattedViaNumber,
+                call.getHandlePresentation(), callLogType, callFeatures, accountHandle,
+                creationTime, age, callDataUsage, call.isEmergencyCall(), call.getInitiatingUser(),
+                logCallCompletedListener,
+                call.getConferenceCallLogId(), /* M: For Volte Conference call */
+                conferenceDuration /* M: For Volte Conference call */);
+    }
+
+    /**
+     * Inserts a call into the call log, based on the parameters passed in.
+     *
+     * @param callerInfo Caller details.
+     * @param number The number the call was made to or from.
+     * @param postDialDigits The post-dial digits that were dialed after the number,
+     *                       if it was an outgoing call. Otherwise ''.
+     * @param presentation
+     * @param callType The type of call.
+     * @param features The features of the call.
+     * @param start The start time of the call, in milliseconds.
+     * @param duration The duration of the call, in milliseconds.
+     * @param dataUsage The data usage for the call, null if not applicable.
+     * @param isEmergency {@code true} if this is an emergency call, {@code false} otherwise.
+     * @param logCallCompletedListener optional callback called after the call is logged.
+     * @param conferenceCallLogId The conference call callLog id.
+     * @param conferenceDuration The duration of conference, in milliseconds.
+     */
+    private void logCall(
+            CallerInfo callerInfo,
+            String number,
+            String postDialDigits,
+            String viaNumber,
+            int presentation,
+            int callType,
+            int features,
+            PhoneAccountHandle accountHandle,
+            long start,
+            long duration,
+            Long dataUsage,
+            boolean isEmergency,
+            UserHandle initiatingUser,
+            @Nullable LogCallCompletedListener logCallCompletedListener,
+            long conferenceCallLogId, /* M: For Volte Conference call */
+            long conferenceDuration /* M: For Volte Conference call */) {
+
+        // On some devices, to avoid accidental redialing of emergency numbers, we *never* log
+        // emergency calls to the Call Log.  (This behavior is set on a per-product basis, based
+        // on carrier requirements.)
+        boolean okToLogEmergencyNumber = false;
+        CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(
+                Context.CARRIER_CONFIG_SERVICE);
+        PersistableBundle configBundle = configManager.getConfig();
+        if (configBundle != null) {
+            okToLogEmergencyNumber = configBundle.getBoolean(
+                    CarrierConfigManager.KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL);
+        }
+
+        // Don't log emergency numbers if the device doesn't allow it.
+        //final boolean isOkToLogThisCall = !isEmergency || okToLogEmergencyNumber;
+		final boolean isOkToLogThisCall = isEmergency || okToLogEmergencyNumber;
+        sendAddCallBroadcast(callType, duration);
+
+        boolean showAllCallLog = true;
+        if (isOkToLogThisCall || showAllCallLog) {
+            Log.d(TAG, "Logging Calllog entry: " + callerInfo + ", "
+                    + Log.pii(number) + "," + presentation + ", " + callType
+                    + ", " + start + ", " + duration + ", " + conferenceCallLogId);
+            AddCallArgs args = new AddCallArgs(mContext, callerInfo, number, postDialDigits,
+                    viaNumber, presentation, callType, features, accountHandle, start, duration,
+                    dataUsage, initiatingUser, logCallCompletedListener,
+                    conferenceCallLogId, /* M: For Conference call */
+                    conferenceDuration /* M: For Conference call */);
+            logCallAsync(args);
+        } else {
+          Log.d(TAG, "Not adding emergency call to call log.");
+        }
+    }
+
+    //lance modify for Diagnostic @{
+    private boolean isDiagnosticProject() {
+        return "1".equals(SystemProperties.get("ro.tct.diagnostic"));
+    }
+    // @}
+
+    //begin added by jiayi.wang for task 3682185 at 2017.01.04
+    private void recordCall(int disconnectCause,int callType) {
+        ContentValues values = new ContentValues();
+        values.put("action","ADD");
+        boolean isOutGoing = (callType == Calls.OUTGOING_TYPE);
+        if (isOutGoing) {
+            values.put("PHONE_MO_VOICE",String.valueOf(1));
+        } else {
+            values.put("PHONE_MT_VOICE",String.valueOf(1));
+        }
+        switch (disconnectCause) {
+            case DisconnectCause.LOCAL:
+                values.put("DISCONNECT_LOCAL",String.valueOf(1));
+                break;
+            case DisconnectCause.REMOTE:
+                values.put("DISCONNECT_REMOTE",String.valueOf(1));
+                break;
+            case DisconnectCause.CANCELED:
+                values.put("DISCONNECT_CANCELED",String.valueOf(1));
+                break;
+            case DisconnectCause.MISSED:
+                values.put("DISCONNECT_MISSED",String.valueOf(1));
+                break;
+            case DisconnectCause.REJECTED:
+                values.put("DISCONNECT_REJECTED",String.valueOf(1));
+                break;
+            case DisconnectCause.BUSY:
+                values.put("DISCONNECT_BUSY",String.valueOf(1));
+                break;
+            case DisconnectCause.RESTRICTED:
+                values.put("DISCONNECT_RESTRICTED",String.valueOf(1));
+                break;
+            case DisconnectCause.ERROR:
+                values.put("DISCONNECT_ERROR",String.valueOf(1));
+                break;
+            case DisconnectCause.UNKNOWN:
+                values.put("DISCONNECT_UNKNOWN",String.valueOf(1));
+                break;
+            case DisconnectCause.OTHER:
+                values.put("DISCONNECT_OTHER",String.valueOf(1));
+                break;
+            default:
+                values.put("DISCONNECT_UNKNOWN",String.valueOf(1));
+                break;
+        }
+        ContentProviderClient privider = mContext.getContentResolver().acquireUnstableContentProviderClient(AUTHORITY);
+        try {
+            if (privider != null) {
+                privider.update(CONTENT_URI, values, null, null);
+            }
+        } catch (IllegalArgumentException e) {
+             Log.d("LSH","llegalArgumentException Exception: "+e);
+        } catch (RemoteException e) {
+             Log.d("LSH","write2DB() RemoteException Exception: "+e);
+        } finally {
+             if (privider != null) {
+                privider.release();
+             }
+        }
+    }
+    //end added by jiayi.wang for task 3682185 at 2017.01.04
+    /**
+     * Based on the video state of the call, determines the call features applicable for the call.
+     *
+     * @param videoState The video state.
+     * @param isPulledCall {@code true} if this call was pulled to another device.
+     * @return The call features.
+     */
+    private static int getCallFeatures(int videoState, boolean isPulledCall) {
+        int features = 0;
+        if (VideoProfile.isVideo(videoState)) {
+            features |= Calls.FEATURES_VIDEO;
+        }
+        if (isPulledCall) {
+            features |= Calls.FEATURES_PULLED_EXTERNALLY;
+        }
+        return features;
+    }
+
+    /**
+     * Retrieve the phone number from the call, and then process it before returning the
+     * actual number that is to be logged.
+     *
+     * @param call The phone connection.
+     * @return the phone number to be logged.
+     */
+    private String getLogNumber(Call call) {
+        Uri handle = call.getOriginalHandle();
+
+        if (handle == null) {
+            return null;
+        }
+
+        String handleString = handle.getSchemeSpecificPart();
+        if (!PhoneNumberUtils.isUriNumber(handleString)) {
+            handleString = PhoneNumberUtils.stripSeparators(handleString);
+        }
+        /// M: ALPS02795957, Avoid to log duplicated post dial digits. @{
+        String postDial = call.getPostDialDigits();
+        if (!TextUtils.isEmpty(postDial)
+                && postDial.equals(PhoneNumberUtils.extractPostDialPortion(handleString))) {
+            handleString = PhoneNumberUtils.extractNetworkPortionAlt(handleString);
+            Log.d(TAG, "Remove duplicate post dial digits: " + postDial);
+        }
+        /// @}
+        return handleString;
+    }
+
+    /**
+     * Adds the call defined by the parameters in the provided AddCallArgs to the CallLogProvider
+     * using an AsyncTask to avoid blocking the main thread.
+     *
+     * @param args Prepopulated call details.
+     * @return A handle to the AsyncTask that will add the call to the call log asynchronously.
+     */
+    public AsyncTask<AddCallArgs, Void, Uri[]> logCallAsync(AddCallArgs args) {
+        return new LogCallAsyncTask().execute(args);
+    }
+
+    /**
+     * Helper AsyncTask to access the call logs database asynchronously since database operations
+     * can take a long time depending on the system's load. Since it extends AsyncTask, it uses
+     * its own thread pool.
+     */
+    private class LogCallAsyncTask extends AsyncTask<AddCallArgs, Void, Uri[]> {
+        /// M: For conference SRVCC
+        private AddCallArgs[] mAddCallArgs = null;
+
+        private LogCallCompletedListener[] mListeners;
+
+        @Override
+        protected Uri[] doInBackground(AddCallArgs... callList) {
+            mAddCallArgs = callList;
+            int count = callList.length;
+            Uri[] result = new Uri[count];
+            mListeners = new LogCallCompletedListener[count];
+            for (int i = 0; i < count; i++) {
+                AddCallArgs c = callList[i];
+                mListeners[i] = c.logCallCompletedListener;
+                try {
+                    // May block.
+                    result[i] = addCall(c);
+                } catch (Exception e) {
+                    // This is very rare but may happen in legitimate cases.
+                    // E.g. If the phone is encrypted and thus write request fails, it may cause
+                    // some kind of Exception (right now it is IllegalArgumentException, but this
+                    // might change).
+                    //
+                    // We don't want to crash the whole process just because of that, so just log
+                    // it instead.
+                    Log.e(TAG, e, "Exception raised during adding CallLog entry.");
+                    result[i] = null;
+                }
+            }
+            return result;
+        }
+
+        private Uri addCall(AddCallArgs c) {
+            PhoneAccount phoneAccount = mPhoneAccountRegistrar
+                    .getPhoneAccountUnchecked(c.accountHandle);
+            if (phoneAccount != null &&
+                    phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_MULTI_USER)) {
+                ///M:add log
+                Log.i(TAG, "addCallLog, c.initiatingUser=" + c.initiatingUser);
+                if (c.initiatingUser != null &&
+                        UserUtil.isManagedProfile(mContext, c.initiatingUser)) {
+                    return addCall(c, c.initiatingUser);
+                } else {
+                    return addCall(c, null);
+                }
+            } else {
+                return addCall(c, c.accountHandle == null ? null : c.accountHandle.getUserHandle());
+            }
+        }
+
+        /**
+         * Insert the call to a specific user or all users except managed profile.
+         * @param c context
+         * @param userToBeInserted user handle of user that the call going be inserted to. null
+         *                         if insert to all users except managed profile.
+         */
+        private Uri addCall(AddCallArgs c, UserHandle userToBeInserted) {
+            ///M:add log
+            Log.i(TAG, "addCallLog, userToBeInserted=" + userToBeInserted);
+            /// M: For Volte conference call calllog
+            long conferenceCallLogId = getConferenceCallLogId(c.conferenceCallLogId);
+			int isVolteCall = 0;
+			boolean bvalue = TelephonyManagerEx.getDefault().isVolteEnabled(0);
+			if (bvalue) {
+				isVolteCall = 1;
+			}
+            return Calls.addCall(c.callerInfo, c.context, c.number, c.postDialDigits, c.viaNumber,
+                    c.presentation, c.callType, c.features, c.accountHandle, c.timestamp,
+                    c.durationInSec, c.dataUsage, userToBeInserted == null,
+                    userToBeInserted, false/* M: is read */,
+                    conferenceCallLogId, /* M: For Volte conference call calllog */
+					isVolteCall, /* is volte call */
+                    c.conferenceDurationInSec /* M: For Volte conference call calllog */);
+        }
+
+
+        @Override
+        protected void onPostExecute(Uri[] result) {
+            for (int i = 0; i < result.length; i++) {
+                Uri uri = result[i];
+                /*
+                 Performs a simple sanity check to make sure the call was written in the database.
+                 Typically there is only one result per call so it is easy to identify which one
+                 failed.
+                 */
+                if (uri == null) {
+                    Log.w(TAG, "Failed to write call to the log.");
+                }
+                if (mListeners[i] != null) {
+                    mListeners[i].onLogCompleted(uri);
+                }
+            }
+            /// M: If it was conference child, we record the Uri used for
+            /// conference SRVCC case. @{
+            for (int i = 0; i < mAddCallArgs.length; i++) {
+                AddCallArgs c = mAddCallArgs[i];
+                if (c.conferenceCallLogId > 0 && result[i] != null) {
+                    updateSrvccConferenceCallLogs(c.conferenceCallLogId, c.number, result[i]);
+                }
+            }
+            /// @}
+        }
+    }
+
+    private void sendAddCallBroadcast(int callType, long duration) {
+        Intent callAddIntent = new Intent(ACTION_CALLS_TABLE_ADD_ENTRY);
+        callAddIntent.putExtra(CALL_TYPE, callType);
+        callAddIntent.putExtra(CALL_DURATION, duration);
+        mContext.sendBroadcast(callAddIntent, PERMISSION_PROCESS_CALLLOG_INFO);
+    }
+
+    private String getCountryIsoFromCountry(Country country) {
+        if(country == null) {
+            // Fallback to Locale if there are issues with CountryDetector
+            Log.w(TAG, "Value for country was null. Falling back to Locale.");
+            return Locale.getDefault().getCountry();
+        }
+
+        return country.getCountryIso();
+    }
+
+    /**
+     * Get the current country code
+     *
+     * @return the ISO 3166-1 two letters country code of current country.
+     */
+    public String getCountryIso() {
+        synchronized (mLock) {
+            if (mCurrentCountryIso == null) {
+                Log.i(TAG, "Country cache is null. Detecting Country and Setting Cache...");
+                final CountryDetector countryDetector =
+                        (CountryDetector) mContext.getSystemService(Context.COUNTRY_DETECTOR);
+                Country country = null;
+                if (countryDetector != null) {
+                    country = countryDetector.detectCountry();
+
+                    countryDetector.addCountryListener((newCountry) -> {
+                        Log.startSession("CLM.oCD");
+                        try {
+                            synchronized (mLock) {
+                                Log.i(TAG, "Country ISO changed. Retrieving new ISO...");
+                                mCurrentCountryIso = getCountryIsoFromCountry(newCountry);
+                            }
+                        } finally {
+                            Log.endSession();
+                        }
+                    }, Looper.getMainLooper());
+                }
+                mCurrentCountryIso = getCountryIsoFromCountry(country);
+            }
+            return mCurrentCountryIso;
+        }
+    }
+
+    /**
+     * M: ALPS01899538, add for getting scheme from call.
+     * @param call
+     * @return the phone number scheme to be logged.
+     */
+    private String getLogScheme(Call call) {
+        Uri handle = call.getOriginalHandle();
+
+        if (handle == null) {
+            return null;
+        }
+        String scheme = handle.getScheme();
+        return scheme;
+    }
+
+    /// M: Show call duration @{
+    private final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    private void showCallDuration(Call call) {
+        final long callDuration = call.getAgeMillis();
+
+        Log.d(TAG, "showCallDuration: " + callDuration);
+
+        if (callDuration / 1000 != 0) {
+            // Must post to main thread because this method called in binder call thread
+            mHandler.post(new java.lang.Runnable() {
+                @Override
+                public void run() {
+                    Toast.makeText(mContext, getFormateDuration((int) (callDuration / 1000)),
+                            Toast.LENGTH_SHORT).show();
+                }
+            });
+        }
+    }
+
+    private String getFormateDuration(long duration) {
+        long hours = 0;
+        long minutes = 0;
+        long seconds = 0;
+
+        if (duration >= 3600) {
+            hours = duration / 3600;
+            minutes = (duration - hours * 3600) / 60;
+            seconds = duration - hours * 3600 - minutes * 60;
+        } else if (duration >= 60) {
+            minutes = duration / 60;
+            seconds = duration - minutes * 60;
+        } else {
+            seconds = duration;
+        }
+
+        String duration_title = mContext.getResources().getString(R.string.call_duration_title);
+        String duration_content = mContext.getResources().getString(R.string.call_duration_format, hours, minutes, seconds);
+        return  duration_title + " (" + duration_content + ")";
+    }
+    /// @}
+
+    /// M: For Volte conference call calllog @{
+    // For skip the duration toast of IMS merged calls
+    private static final String IMS_MERGED_SUCCESSFULLY = "IMS_MERGED_SUCCESSFULLY";
+
+    private HashMap<Long, Long> mConferenceCallLogIdMap = new HashMap<Long, Long>();
+
+    private synchronized long getConferenceCallLogId(long tempConferenceId) {
+        if (tempConferenceId <= 0) {
+            return 0;
+        }
+        Long confCallLogId = mConferenceCallLogIdMap.get(tempConferenceId);
+        if (confCallLogId == null || confCallLogId <= 0) {
+            // Conference has not save calllog into database, save it now
+            ContentValues values = new ContentValues();
+            // The temp conference id is conference creating time
+            values.put(ConferenceCalls.CONFERENCE_DATE, tempConferenceId);
+            Uri confUri = null;
+            try {
+                confUri = mContext.getContentResolver().insert(
+                        ConferenceCalls.CONTENT_URI, values);
+            } catch (Exception e) {
+                Log.e(TAG, e, "Exception raised during adding conference entry.");
+                return 0;
+            }
+            try {
+                confCallLogId = ContentUris.parseId(confUri);
+            } catch (Exception ex) {
+                Log.e(TAG, ex, "Failed to parse conference saved uri:" + confUri);
+                return 0;
+            }
+            if (confCallLogId == null || confCallLogId <= 0) {
+                Log.d(TAG, "Invalid saved conference Id: " + confCallLogId);
+                return 0;
+            }
+            mConferenceCallLogIdMap.put(tempConferenceId, confCallLogId);
+            Log.d(TAG, "Temp conference Id: " + tempConferenceId + " Map to " + confCallLogId);
+        }
+        return confCallLogId;
+    }
+
+    /**
+     * M: In order to save the relationships between the conference and its
+     * participants into callLog. We put the conference callLog id into the the
+     * participant call while this call be changed to a participant of the
+     * conference. And if the conference has no conference callLog id, we save
+     * the conference into database first to get its callLog id.
+     */
+    @Override
+    public void onIsConferencedChanged(Call call) {
+        Log.d(TAG, "onIsConferencedChanged Call: " + call);
+        // If the call is conference call child
+        Call confCall = call.getParentCall();
+        if (confCall != null) {
+            // It is conference call child
+            long confCallLogId = confCall.getConferenceCallLogId();
+            if (confCallLogId <= 0) {
+                // Use conference create time as the conference temp id
+                confCallLogId = confCall.getCreationTimeMillis();
+                confCall.setConferenceCallLogId(confCallLogId);
+                Log.d(TAG, "New conference, set a new temp id: " + confCallLogId);
+                /// M: For Volte conference SRVCC case. Now the phone only support
+                /// one conference call existing simultaneously. So, Clear the
+                /// previous residual info while new conference setup. @{
+                Log.d(TAG, "Clear mSrvccConferenceCallLogs");
+                synchronized (mSrvccConferenceCallLogs) {
+                    mSrvccConferenceCallLogs.clear();
+                }
+                /// @}
+            }
+            Log.d(TAG, "Set temp conference Id:" + confCallLogId + " to Call:" + call.getId());
+            call.setConferenceCallLogId(confCallLogId);
+        }
+    }
+    /// @}
+
+    /// M: For Volte conference SRVCC case. @{
+    /**
+     * The Volte conference would not be disconnected while SRVCC occurred. But
+     * the children IMS calls would be disconnected and changed to new CS calls.
+     * If use the normal logging method a child SRVCC call would be logged as
+     * two callLogs. It is bad user experiences. So, the child IMS call and CS
+     * call should merge into one callLog. Here is the logic to implement this
+     * feature. First we record the IMS call numbers and their callLog Uris into
+     * a memory map. Then find the corresponding Uri from the map according the
+     * call number while the CS call disconnecting. Finally, use the Uri to
+     * update the callLog info, such as duration.
+     */
+    private HashMap<Long, HashMap<String, Uri>> mSrvccConferenceCallLogs =
+            new HashMap<Long, HashMap<String, Uri>>();
+
+    private void addSrvccConferenceCallLogs(long conferenceCallLogId,
+            String logNumber, Uri callLogUri) {
+        Log.d(TAG, "addSrvccConferenceCallLogs confId: " + conferenceCallLogId
+                + ", logNumber:" + logNumber + ", callLogUri:" + callLogUri);
+        if (TextUtils.isEmpty(logNumber)) {
+            return;
+        }
+        synchronized (mSrvccConferenceCallLogs) {
+            HashMap<String, Uri> callLogs = mSrvccConferenceCallLogs.get(conferenceCallLogId);
+            if (callLogs == null) {
+                callLogs = new HashMap<String, Uri>();
+                mSrvccConferenceCallLogs.put(conferenceCallLogId, callLogs);
+            }
+            callLogs.put(logNumber, callLogUri);
+        }
+    }
+
+    private void updateSrvccConferenceCallLogs(long conferenceCallLogId, String logNumber,
+            Uri callLogUri) {
+        Log.d(TAG, "updateSrvccConferenceCallLogs confId: " + conferenceCallLogId
+                + ", logNumber:" + logNumber + ", callLogUri:" + callLogUri);
+        if (TextUtils.isEmpty(logNumber)) {
+            return;
+        }
+        synchronized (mSrvccConferenceCallLogs) {
+            HashMap<String, Uri> callLogs = mSrvccConferenceCallLogs.get(conferenceCallLogId);
+            if (callLogs != null) {
+                callLogs.put(logNumber, callLogUri);
+            }
+        }
+    }
+
+    private Uri removeSrvccConferenceCallLogs(
+            long conferenceCallLogId, String logNumber) {
+        Log.d(TAG, "removeSrvccConferenceCallLogs confId: " + conferenceCallLogId
+                + ", logNumber:" + logNumber);
+        synchronized (mSrvccConferenceCallLogs) {
+            HashMap<String, Uri> callLogs = mSrvccConferenceCallLogs.get(conferenceCallLogId);
+            if (callLogs == null || TextUtils.isEmpty(logNumber)) {
+                return null;
+            }
+            String removedCallLogNumber = null;
+            for (String number : callLogs.keySet()) {
+                if (logNumber.equals(number)
+                        || logNumber.equals(PhoneNumberUtils
+                                .getUsernameFromUriNumber(number))) {
+                    removedCallLogNumber = number;
+                    break;
+                }
+            }
+            if (removedCallLogNumber != null) {
+                Log.d(TAG, "removeSrvccConferenceCallLogs"
+                        + " removedCallLogNumber:" + removedCallLogNumber);
+                return callLogs.remove(removedCallLogNumber);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * M: Handle the Volte conference SRVCC case.
+     * @param childCall the conference child call.
+     * @param childCall the call number to be logged.
+     * @return true if the its conference SRVCC CS child call and be updated into callLog.
+     */
+    private boolean handleConferenceSrvccCallLog(Call childCall, String logNumber) {
+        if (childCall.getConferenceCallLogId() <= 0) {
+            return false;
+        }
+        if (childCall.hasProperty(Connection.PROPERTY_VOLTE)) {
+            // It is IMS call and it may be changed to be CS call at SRVCC case.
+            // So, temporarily record it.
+            addSrvccConferenceCallLogs(childCall.getConferenceCallLogId(),
+                    logNumber, null);
+            return false;
+        }
+        if (!childCall.hasProperty(Connection.PROPERTY_VOLTE)) {
+            // It is CS call. Find the previous relative IMS call, if we found
+            // update the Call data into IMS call data.
+            Uri callLogUri = removeSrvccConferenceCallLogs(
+                    childCall.getConferenceCallLogId(), logNumber);
+            if (callLogUri != null) {
+                new UpdateConferenceCallLogAsyncTask(childCall.getContext(),
+                        childCall, callLogUri).execute();
+                return true;
+            } else {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * The AsyncTask to update the conference callLog info. Now we only update the duration.
+     */
+    private class UpdateConferenceCallLogAsyncTask extends AsyncTask<Void, Void, Void> {
+        private final Call mChildCall;
+        private final Context mContext;
+        private final Uri mCallLogUri;
+
+        UpdateConferenceCallLogAsyncTask(Context context, Call newChildCall, Uri callLogUri) {
+            mContext = context;
+            mChildCall = newChildCall;
+            mCallLogUri = callLogUri;
+        }
+
+        @Override
+        protected Void doInBackground(Void... args) {
+            Cursor c = null;
+            try {
+                c = mContext.getContentResolver().query(mCallLogUri,
+                        new String[] { Calls.DURATION }, null, null, null);
+                c.moveToFirst();
+                // call duration in seconds
+                long duration = c.getLong(0) + (mChildCall.getAgeMillis() / 1000);
+                ContentValues values = new ContentValues();
+                values.put(Calls.DURATION, duration);
+                Log.d(TAG, "Update " + mCallLogUri + " with duration=" + duration);
+                mContext.getContentResolver().update(mCallLogUri, values, null, null);
+            } catch (Exception e) {
+                Log.e(TAG, e, "Exception raised during update conference CallLog.");
+            } finally {
+                if (c != null) {
+                    c.close();
+                }
+            }
+            return null;
+        }
+    }
+    /// @}
+}
Index: vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogProvider.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogProvider.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogProvider.java	(revision 14847)
@@ -0,0 +1,888 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.providers.contacts;
+
+import static com.android.providers.contacts.util.DbQueryUtils.checkForSupportedColumns;
+import static com.android.providers.contacts.util.DbQueryUtils.getEqualityClause;
+import static com.android.providers.contacts.util.DbQueryUtils.getInequalityClause;
+
+import android.app.AppOpsManager;
+import android.app.SearchManager;
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDiskIOException;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.os.Process;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.CallLog;
+import android.provider.CallLog.Calls;
+import android.provider.CallLog.ConferenceCalls;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telephony.PhoneNumberUtils;
+import android.text.TextUtils;
+import android.util.Log;
+import com.android.providers.contacts.CallLogDatabaseHelper.DbProperties;
+import com.android.providers.contacts.CallLogDatabaseHelper.Tables;
+import com.android.providers.contacts.util.SelectionBuilder;
+import com.android.providers.contacts.util.UserUtils;
+import com.mediatek.providers.contacts.CallLogProviderEx;
+import com.mediatek.providers.contacts.LogUtils;
+import com.google.common.annotations.VisibleForTesting;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Call log content provider.
+ */
+public class CallLogProvider extends ContentProvider {
+    private static final String TAG = CallLogProvider.class.getSimpleName();
+
+    public static final boolean VERBOSE_LOGGING = false; // DO NOT SUBMIT WITH TRUE
+
+    private static final int BACKGROUND_TASK_INITIALIZE = 0;
+    private static final int BACKGROUND_TASK_ADJUST_PHONE_ACCOUNT = 1;
+
+    /** Selection clause for selecting all calls that were made after a certain time */
+    private static final String MORE_RECENT_THAN_SELECTION = Calls.DATE + "> ?";
+    /** Selection clause to use to exclude voicemail records.  */
+    private static final String EXCLUDE_VOICEMAIL_SELECTION = getInequalityClause(
+            Calls.TYPE, Calls.VOICEMAIL_TYPE);
+    /** Selection clause to exclude hidden records. */
+    private static final String EXCLUDE_HIDDEN_SELECTION = getEqualityClause(
+            Calls.PHONE_ACCOUNT_HIDDEN, 0);
+
+    @VisibleForTesting
+    static final String[] CALL_LOG_SYNC_PROJECTION = new String[] {
+        Calls.NUMBER,
+        Calls.NUMBER_PRESENTATION,
+        Calls.TYPE,
+        Calls.FEATURES,
+        Calls.DATE,
+        Calls.DURATION,
+        Calls.DATA_USAGE,
+        Calls.PHONE_ACCOUNT_COMPONENT_NAME,
+        Calls.PHONE_ACCOUNT_ID,
+        Calls.ADD_FOR_ALL_USERS,
+        /// M: Sync more fields @{
+        Calls.COUNTRY_ISO,
+        Calls.VOICEMAIL_URI,
+        Calls.GEOCODED_LOCATION,
+        Calls.IS_READ,
+        Calls.POST_DIAL_DIGITS,
+        Calls.VIA_NUMBER,
+        Calls.CONFERENCE_CALL_ID,
+        Calls.IP_PREFIX
+        //// @}
+    };
+
+    static final String[] MINIMAL_PROJECTION = new String[] { Calls._ID };
+
+    private static final int CALLS = 1;
+
+    private static final int CALLS_ID = 2;
+
+    private static final int CALLS_FILTER = 3;
+
+    private static final String UNHIDE_BY_PHONE_ACCOUNT_QUERY =
+            "UPDATE " + Tables.CALLS + " SET " + Calls.PHONE_ACCOUNT_HIDDEN + "=0 WHERE " +
+            Calls.PHONE_ACCOUNT_COMPONENT_NAME + "=? AND " + Calls.PHONE_ACCOUNT_ID + "=?;";
+
+    private static final String UNHIDE_BY_ADDRESS_QUERY =
+            "UPDATE " + Tables.CALLS + " SET " + Calls.PHONE_ACCOUNT_HIDDEN + "=0 WHERE " +
+            Calls.PHONE_ACCOUNT_ADDRESS + "=?;";
+
+    private static final int CALLS_SEARCH_FILTER = 4;
+    private static final int CONFERENCE_CALLS = 5;
+    private static final int CONFERENCE_CALLS_ID = 6;
+    private static final int SEARCH_SUGGESTIONS = 10001;
+    private static final int SEARCH_SHORTCUT = 10002;
+
+    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    static {
+        sURIMatcher.addURI(CallLog.AUTHORITY, "calls", CALLS);
+        sURIMatcher.addURI(CallLog.AUTHORITY, "calls/#", CALLS_ID);
+        sURIMatcher.addURI(CallLog.AUTHORITY, "calls/filter/*", CALLS_FILTER);
+        sURIMatcher.addURI(CallLog.AUTHORITY, "calls/search_filter/*", CALLS_SEARCH_FILTER);
+        sURIMatcher.addURI(CallLog.AUTHORITY,
+                SearchManager.SUGGEST_URI_PATH_QUERY, SEARCH_SUGGESTIONS);
+        sURIMatcher.addURI(CallLog.AUTHORITY,
+                SearchManager.SUGGEST_URI_PATH_QUERY + "/*", SEARCH_SUGGESTIONS);
+        sURIMatcher.addURI(CallLog.AUTHORITY,
+                SearchManager.SUGGEST_URI_PATH_SHORTCUT + "/*", SEARCH_SHORTCUT);
+        sURIMatcher.addURI(CallLog.AUTHORITY, "conference_calls", CONFERENCE_CALLS);
+        sURIMatcher.addURI(CallLog.AUTHORITY, "conference_calls/#", CONFERENCE_CALLS_ID);
+
+        // Shadow provider only supports "/calls".
+        sURIMatcher.addURI(CallLog.SHADOW_AUTHORITY, "calls", CALLS);
+    }
+
+    private static final HashMap<String, String> sCallsProjectionMap;
+    static {
+
+        // Calls projection map
+        sCallsProjectionMap = new HashMap<String, String>();
+        /// M: Add table name to the _id filed for table jion query
+        sCallsProjectionMap.put(Calls._ID, Tables.CALLS + "._id as " + Calls._ID);
+        sCallsProjectionMap.put(Calls.NUMBER, Calls.NUMBER);
+        sCallsProjectionMap.put(Calls.POST_DIAL_DIGITS, Calls.POST_DIAL_DIGITS);
+        sCallsProjectionMap.put(Calls.VIA_NUMBER, Calls.VIA_NUMBER);
+        sCallsProjectionMap.put(Calls.NUMBER_PRESENTATION, Calls.NUMBER_PRESENTATION);
+        sCallsProjectionMap.put(Calls.DATE, Calls.DATE);
+        sCallsProjectionMap.put(Calls.DURATION, Calls.DURATION);
+        sCallsProjectionMap.put(Calls.DATA_USAGE, Calls.DATA_USAGE);
+        sCallsProjectionMap.put(Calls.TYPE, Calls.TYPE);
+        sCallsProjectionMap.put(Calls.FEATURES, Calls.FEATURES);
+        sCallsProjectionMap.put(Calls.PHONE_ACCOUNT_COMPONENT_NAME, Calls.PHONE_ACCOUNT_COMPONENT_NAME);
+        sCallsProjectionMap.put(Calls.PHONE_ACCOUNT_ID, Calls.PHONE_ACCOUNT_ID);
+        sCallsProjectionMap.put(Calls.PHONE_ACCOUNT_ADDRESS, Calls.PHONE_ACCOUNT_ADDRESS);
+        sCallsProjectionMap.put(Calls.NEW, Calls.NEW);
+        sCallsProjectionMap.put(Calls.VOICEMAIL_URI, Calls.VOICEMAIL_URI);
+        sCallsProjectionMap.put(Calls.TRANSCRIPTION, Calls.TRANSCRIPTION);
+        sCallsProjectionMap.put(Calls.IS_READ, Calls.IS_READ);
+        sCallsProjectionMap.put(Calls.CACHED_NAME, Calls.CACHED_NAME);
+        sCallsProjectionMap.put(Calls.CACHED_NUMBER_TYPE, Calls.CACHED_NUMBER_TYPE);
+        sCallsProjectionMap.put(Calls.CACHED_NUMBER_LABEL, Calls.CACHED_NUMBER_LABEL);
+        sCallsProjectionMap.put(Calls.COUNTRY_ISO, Calls.COUNTRY_ISO);
+        sCallsProjectionMap.put(Calls.GEOCODED_LOCATION, Calls.GEOCODED_LOCATION);
+        sCallsProjectionMap.put(Calls.CACHED_LOOKUP_URI, Calls.CACHED_LOOKUP_URI);
+        sCallsProjectionMap.put(Calls.CACHED_MATCHED_NUMBER, Calls.CACHED_MATCHED_NUMBER);
+        sCallsProjectionMap.put(Calls.CACHED_NORMALIZED_NUMBER, Calls.CACHED_NORMALIZED_NUMBER);
+        sCallsProjectionMap.put(Calls.CACHED_PHOTO_ID, Calls.CACHED_PHOTO_ID);
+        sCallsProjectionMap.put(Calls.CACHED_PHOTO_URI, Calls.CACHED_PHOTO_URI);
+        sCallsProjectionMap.put(Calls.CACHED_FORMATTED_NUMBER, Calls.CACHED_FORMATTED_NUMBER);
+        sCallsProjectionMap.put(Calls.ADD_FOR_ALL_USERS, Calls.ADD_FOR_ALL_USERS);
+        sCallsProjectionMap.put(Calls.LAST_MODIFIED, Calls.LAST_MODIFIED);
+        /// M: @{
+        sCallsProjectionMap.put(Calls.IP_PREFIX, Calls.IP_PREFIX);
+        sCallsProjectionMap.put(Calls.CONFERENCE_CALL_ID, Calls.CONFERENCE_CALL_ID);
+        sCallsProjectionMap.put(Calls.CACHED_INDICATE_PHONE_SIM, Calls.CACHED_INDICATE_PHONE_SIM);
+        sCallsProjectionMap.put(Calls.CACHED_IS_SDN_CONTACT, Calls.CACHED_IS_SDN_CONTACT);
+		sCallsProjectionMap.put(Calls.IS_VOLTE_CALL, Calls.IS_VOLTE_CALL);
+        /// @}
+    }
+
+    /// M: For conference calllog join table query @{
+    private static final String CALLS_JOIN_CONFERENCE = Tables.CALLS
+            + " LEFT JOIN " + Tables.CONFERENCE_CALLS + " ON "
+            + Calls.CONFERENCE_CALL_ID + "=" + Tables.CONFERENCE_CALLS + "."
+            + ConferenceCalls._ID;
+
+    private static final String CALLS_JOIN_CONFERENCE_SORT_DATE = "(CASE WHEN " +
+            Calls.CONFERENCE_CALL_ID + ">0 THEN " + ConferenceCalls.CONFERENCE_DATE
+            + " ELSE " + Calls.DATE + " END)";
+    /// @}
+
+    private HandlerThread mBackgroundThread;
+    private Handler mBackgroundHandler;
+    private volatile CountDownLatch mReadAccessLatch;
+
+    private CallLogDatabaseHelper mDbHelper;
+    private DatabaseUtils.InsertHelper mCallsInserter;
+    private boolean mUseStrictPhoneNumberComparation;
+    private VoicemailPermissions mVoicemailPermissions;
+    private CallLogInsertionHelper mCallLogInsertionHelper;
+    /// M: @{
+    private CallLogProviderEx mCallLogProviderEx;
+    /// @}
+
+    protected boolean isShadow() {
+        return false;
+    }
+
+    protected final String getProviderName() {
+        return this.getClass().getSimpleName();
+    }
+
+    @Override
+    public boolean onCreate() {
+        setAppOps(AppOpsManager.OP_READ_CALL_LOG, AppOpsManager.OP_WRITE_CALL_LOG);
+        if (Log.isLoggable(Constants.PERFORMANCE_TAG, Log.DEBUG)) {
+            Log.d(Constants.PERFORMANCE_TAG, getProviderName() + ".onCreate start");
+        }
+        final Context context = getContext();
+        mDbHelper = getDatabaseHelper(context);
+        mUseStrictPhoneNumberComparation =
+            context.getResources().getBoolean(
+                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);
+        mVoicemailPermissions = new VoicemailPermissions(context);
+        /// M: @{
+        mCallLogProviderEx = CallLogProviderEx.getInstance(context);
+        /// @}
+        mCallLogInsertionHelper = createCallLogInsertionHelper(context);
+
+        mBackgroundThread = new HandlerThread(getProviderName() + "Worker",
+                Process.THREAD_PRIORITY_BACKGROUND);
+        mBackgroundThread.start();
+        mBackgroundHandler = new Handler(mBackgroundThread.getLooper()) {
+            @Override
+            public void handleMessage(Message msg) {
+                performBackgroundTask(msg.what, msg.obj);
+            }
+        };
+
+        mReadAccessLatch = new CountDownLatch(1);
+
+        scheduleBackgroundTask(BACKGROUND_TASK_INITIALIZE, null);
+
+        if (Log.isLoggable(Constants.PERFORMANCE_TAG, Log.DEBUG)) {
+            Log.d(Constants.PERFORMANCE_TAG, getProviderName() + ".onCreate finish");
+        }
+        return true;
+    }
+
+    @VisibleForTesting
+    protected CallLogInsertionHelper createCallLogInsertionHelper(final Context context) {
+        return DefaultCallLogInsertionHelper.getInstance(context);
+    }
+
+    protected CallLogDatabaseHelper getDatabaseHelper(final Context context) {
+        return CallLogDatabaseHelper.getInstance(context);
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
+            String sortOrder) {
+        if (VERBOSE_LOGGING) {
+            Log.v(TAG, "query: uri=" + uri + "  projection=" + Arrays.toString(projection) +
+                    "  selection=[" + selection + "]  args=" + Arrays.toString(selectionArgs) +
+                    "  order=[" + sortOrder + "] CPID=" + Binder.getCallingPid() +
+                    " User=" + UserUtils.getCurrentUserHandle(getContext()));
+        }
+        waitForAccess(mReadAccessLatch);
+        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+        qb.setTables(Tables.CALLS);
+        qb.setProjectionMap(sCallsProjectionMap);
+        qb.setStrict(true);
+
+        final SelectionBuilder selectionBuilder = new SelectionBuilder(selection);
+        checkVoicemailPermissionAndAddRestriction(uri, selectionBuilder, true /*isQuery*/);
+        selectionBuilder.addClause(EXCLUDE_HIDDEN_SELECTION);
+
+        final int match = sURIMatcher.match(uri);
+        /// M: For conference calllog join table query @{
+        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
+        LogUtils.d(TAG, "match == " + match);
+        if (sortOrder != null && sortOrder.contains(Calls.SORT_DATE)) {
+            if (match == CALLS) {
+                qb.setTables(CALLS_JOIN_CONFERENCE);
+                sortOrder = sortOrder.replace(Calls.SORT_DATE, CALLS_JOIN_CONFERENCE_SORT_DATE);
+            } else {
+                sortOrder = sortOrder.replace(Calls.SORT_DATE, Calls.DATE);
+            }
+        }
+        /// @}
+        switch (match) {
+            case CALLS:
+                break;
+
+            case CALLS_ID: {
+                selectionBuilder.addClause(getEqualityClause(Calls._ID,
+                        parseCallIdFromUri(uri)));
+                break;
+            }
+
+            case CALLS_FILTER: {
+                List<String> pathSegments = uri.getPathSegments();
+                String phoneNumber = pathSegments.size() >= 2 ? pathSegments.get(2) : null;
+                if (!TextUtils.isEmpty(phoneNumber)) {
+                    qb.appendWhere("PHONE_NUMBERS_EQUAL(number, ");
+                    qb.appendWhereEscapeString(phoneNumber);
+                    qb.appendWhere(mUseStrictPhoneNumberComparation ? ", 1)" : ", 0)");
+                } else {
+                    qb.appendWhere(Calls.NUMBER_PRESENTATION + "!="
+                            + Calls.PRESENTATION_ALLOWED);
+                }
+                break;
+            }
+            /// M: @{
+            case CALLS_SEARCH_FILTER:
+            case CONFERENCE_CALLS_ID:
+            case CONFERENCE_CALLS:
+            case SEARCH_SUGGESTIONS:
+            case SEARCH_SHORTCUT: {
+                return mCallLogProviderEx.queryCallLog(db, qb, uri, projection, selection,
+                    selectionArgs, sortOrder);
+        }
+            /// @}
+            default:
+                throw new IllegalArgumentException("Unknown URL " + uri);
+        }
+        LogUtils.d(TAG, "   In call log providers,  selectionBuilder=" + selectionBuilder.build());
+
+        final int limit = getIntParam(uri, Calls.LIMIT_PARAM_KEY, 0);
+        final int offset = getIntParam(uri, Calls.OFFSET_PARAM_KEY, 0);
+        String limitClause = null;
+        if (limit > 0) {
+            limitClause = offset + "," + limit;
+        }
+
+        /**
+         * M: remove original code here
+         * Original Code:
+        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
+         */
+        final Cursor c = qb.query(db, projection, selectionBuilder.build(), selectionArgs, null,
+                null, sortOrder, limitClause);
+        if (c != null) {
+            c.setNotificationUri(getContext().getContentResolver(), CallLog.CONTENT_URI);
+            LogUtils.d(TAG, "query count == " + c.getCount());
+        }
+        return c;
+    }
+
+    /**
+     * Gets an integer query parameter from a given uri.
+     *
+     * @param uri The uri to extract the query parameter from.
+     * @param key The query parameter key.
+     * @param defaultValue A default value to return if the query parameter does not exist.
+     * @return The value from the query parameter in the Uri.  Or the default value if the parameter
+     * does not exist in the uri.
+     * @throws IllegalArgumentException when the value in the query parameter is not an integer.
+     */
+    private int getIntParam(Uri uri, String key, int defaultValue) {
+        String valueString = uri.getQueryParameter(key);
+        if (valueString == null) {
+            return defaultValue;
+        }
+
+        try {
+            return Integer.parseInt(valueString);
+        } catch (NumberFormatException e) {
+            String msg = "Integer required for " + key + " parameter but value '" + valueString +
+                    "' was found instead.";
+            throw new IllegalArgumentException(msg, e);
+        }
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        int match = sURIMatcher.match(uri);
+        switch (match) {
+            case CALLS:
+                return Calls.CONTENT_TYPE;
+            case CALLS_ID:
+                return Calls.CONTENT_ITEM_TYPE;
+            case CALLS_FILTER:
+                return Calls.CONTENT_TYPE;
+            /// M: @{
+            case CALLS_SEARCH_FILTER:
+                return Calls.CONTENT_TYPE;
+            case SEARCH_SUGGESTIONS:
+                return Calls.CONTENT_TYPE;
+            case CONFERENCE_CALLS_ID:
+                return Calls.CONTENT_TYPE;
+            case CONFERENCE_CALLS:
+                return Calls.CONTENT_TYPE;
+            /// @}
+            default:
+                throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        if (VERBOSE_LOGGING) {
+            Log.v(TAG, "insert: uri=" + uri + "  values=[" + values + "]" +
+                    " CPID=" + Binder.getCallingPid());
+        }
+
+        /// M: @{
+        int prio = Process.getThreadPriority(Process.myTid());
+        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
+        Uri retUri = null;
+        long lStart = System.currentTimeMillis();
+        LogUtils.d(TAG, "insert() + ===========");
+
+        if (CONFERENCE_CALLS == sURIMatcher.match(uri)) {
+            retUri = mCallLogProviderEx.insertConferenceCall(
+                    mDbHelper.getWritableDatabase(), uri, values);
+            LogUtils.d(TAG, "insert()  =========== Uri:" + retUri);
+            LogUtils.d(TAG, "insert()- =========== Time:" + (System.currentTimeMillis() - lStart));
+            Process.setThreadPriority(prio);
+            return retUri;
+        }
+        /// @}
+
+        waitForAccess(mReadAccessLatch);
+        checkForSupportedColumns(sCallsProjectionMap, values);
+        // Inserting a voicemail record through call_log requires the voicemail
+        // permission and also requires the additional voicemail param set.
+        if (hasVoicemailValue(values)) {
+            checkIsAllowVoicemailRequest(uri);
+            mVoicemailPermissions.checkCallerHasWriteAccess(getCallingPackage());
+        }
+        if (mCallsInserter == null) {
+            SQLiteDatabase db = mDbHelper.getWritableDatabase();
+            mCallsInserter = new DatabaseUtils.InsertHelper(db, Tables.CALLS);
+        }
+
+        ContentValues copiedValues = new ContentValues(values);
+
+        // Add the computed fields to the copied values.
+        mCallLogInsertionHelper.addComputedValues(copiedValues);
+
+        /**M:remove the duplicated one before add for non-owner user.@{*/
+        mCallLogProviderEx.removeDuplictedCallLogForUser(mDbHelper, values);
+        /**@}*/
+        long rowId = getDatabaseModifier(mCallsInserter).insert(copiedValues);
+        /// M: @{
+        if (rowId > 0) {
+            retUri = ContentUris.withAppendedId(uri, rowId);
+        }
+        LogUtils.d(TAG, "insert()  =========== Uri:" + retUri);
+        LogUtils.d(TAG, "insert()- =========== Time:" + (System.currentTimeMillis() - lStart));
+        Process.setThreadPriority(prio);
+        return retUri;
+        /// @}
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        if (VERBOSE_LOGGING) {
+            Log.v(TAG, "update: uri=" + uri +
+                    "  selection=[" + selection + "]  args=" + Arrays.toString(selectionArgs) +
+                    "  values=[" + values + "] CPID=" + Binder.getCallingPid() +
+                    " User=" + UserUtils.getCurrentUserHandle(getContext()));
+        }
+        waitForAccess(mReadAccessLatch);
+        /** M: if it is conference uri, do not need check columns.@{ */
+        if (CONFERENCE_CALLS_ID != sURIMatcher.match(uri)) {
+            checkForSupportedColumns(sCallsProjectionMap, values);
+        }
+        /**@}*/
+        // Request that involves changing record type to voicemail requires the
+        // voicemail param set in the uri.
+        if (hasVoicemailValue(values)) {
+            checkIsAllowVoicemailRequest(uri);
+        }
+
+        SelectionBuilder selectionBuilder = new SelectionBuilder(selection);
+        checkVoicemailPermissionAndAddRestriction(uri, selectionBuilder, false /*isQuery*/);
+
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+        final int matchedUriId = sURIMatcher.match(uri);
+        switch (matchedUriId) {
+            case CALLS:
+                break;
+
+            case CALLS_ID:
+                selectionBuilder.addClause(getEqualityClause(Calls._ID, parseCallIdFromUri(uri)));
+                break;
+
+            /// M: For Conference CallLog updating. @{
+            case CONFERENCE_CALLS_ID:
+                SelectionBuilder ccSelectionBuilder = new SelectionBuilder(selection);
+                ccSelectionBuilder.addClause(
+                        getEqualityClause(ConferenceCalls._ID, parseCallIdFromUri(uri)));
+                int count = db.update(Tables.CONFERENCE_CALLS,
+                        values, ccSelectionBuilder.build(), selectionArgs);
+                return count;
+            ///@}
+
+            default:
+                throw new UnsupportedOperationException("Cannot update URL: " + uri);
+        }
+
+        return getDatabaseModifier(db).update(uri, Tables.CALLS, values, selectionBuilder.build(),
+                selectionArgs);
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        if (VERBOSE_LOGGING) {
+            Log.v(TAG, "delete: uri=" + uri +
+                    "  selection=[" + selection + "]  args=" + Arrays.toString(selectionArgs) +
+                    " CPID=" + Binder.getCallingPid() +
+                    " User=" + UserUtils.getCurrentUserHandle(getContext()));
+        }
+        waitForAccess(mReadAccessLatch);
+        SelectionBuilder selectionBuilder = new SelectionBuilder(selection);
+        checkVoicemailPermissionAndAddRestriction(uri, selectionBuilder, false /*isQuery*/);
+
+        /**
+         * M: Original Android code:
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+         *
+         * @{
+         */
+
+        SQLiteDatabase db = null;
+        try {
+            db = mDbHelper.getWritableDatabase();
+        } catch (SQLiteDiskIOException err) {
+            err.printStackTrace();
+            return 0;
+        }
+
+        /**
+         * @}
+         */
+
+        final int matchedUriId = sURIMatcher.match(uri);
+        switch (matchedUriId) {
+            case CALLS:
+                // TODO: Special case - We may want to forward the delete request on user 0 to the
+                // shadow provider too.
+                return getDatabaseModifier(db).delete(Tables.CALLS,
+                        selectionBuilder.build(), selectionArgs);
+            /// M: For Conference CallLog updating. @{
+            case CONFERENCE_CALLS_ID:
+                SelectionBuilder ccSelectionBuilder = new SelectionBuilder(selection);
+                ccSelectionBuilder.addClause(getEqualityClause(ConferenceCalls._ID,
+                        ContentUris.parseId(uri)));
+                selection = ccSelectionBuilder.build();
+            case CONFERENCE_CALLS:
+                return mCallLogProviderEx.deleteConferenceCalls(db, uri, selection, selectionArgs);
+            ///@}
+            default:
+                throw new UnsupportedOperationException("Cannot delete that URL: " + uri);
+        }
+    }
+
+    void adjustForNewPhoneAccount(PhoneAccountHandle handle) {
+        scheduleBackgroundTask(BACKGROUND_TASK_ADJUST_PHONE_ACCOUNT, handle);
+    }
+
+    /**
+     * Returns a {@link DatabaseModifier} that takes care of sending necessary notifications
+     * after the operation is performed.
+     */
+    private DatabaseModifier getDatabaseModifier(SQLiteDatabase db) {
+        return new DbModifierWithNotification(Tables.CALLS, db, getContext());
+    }
+
+    /**
+     * Same as {@link #getDatabaseModifier(SQLiteDatabase)} but used for insert helper operations
+     * only.
+     */
+    private DatabaseModifier getDatabaseModifier(DatabaseUtils.InsertHelper insertHelper) {
+        return new DbModifierWithNotification(Tables.CALLS, insertHelper, getContext());
+    }
+
+    private static final Integer VOICEMAIL_TYPE = new Integer(Calls.VOICEMAIL_TYPE);
+    private boolean hasVoicemailValue(ContentValues values) {
+        return VOICEMAIL_TYPE.equals(values.getAsInteger(Calls.TYPE));
+    }
+
+    /**
+     * Checks if the supplied uri requests to include voicemails and take appropriate
+     * action.
+     * <p> If voicemail is requested, then check for voicemail permissions. Otherwise
+     * modify the selection to restrict to non-voicemail entries only.
+     */
+    private void checkVoicemailPermissionAndAddRestriction(Uri uri,
+            SelectionBuilder selectionBuilder, boolean isQuery) {
+        if (isAllowVoicemailRequest(uri)) {
+            if (isQuery) {
+                mVoicemailPermissions.checkCallerHasReadAccess(getCallingPackage());
+            } else {
+                mVoicemailPermissions.checkCallerHasWriteAccess(getCallingPackage());
+            }
+        } else {
+            selectionBuilder.addClause(EXCLUDE_VOICEMAIL_SELECTION);
+        }
+    }
+
+    /**
+     * Determines if the supplied uri has the request to allow voicemails to be
+     * included.
+     */
+    private boolean isAllowVoicemailRequest(Uri uri) {
+        return uri.getBooleanQueryParameter(Calls.ALLOW_VOICEMAILS_PARAM_KEY, false);
+    }
+
+    /**
+     * Checks to ensure that the given uri has allow_voicemail set. Used by
+     * insert and update operations to check that ContentValues with voicemail
+     * call type must use the voicemail uri.
+     * @throws IllegalArgumentException if allow_voicemail is not set.
+     */
+    private void checkIsAllowVoicemailRequest(Uri uri) {
+        if (!isAllowVoicemailRequest(uri)) {
+            throw new IllegalArgumentException(
+                    String.format("Uri %s cannot be used for voicemail record." +
+                            " Please set '%s=true' in the uri.", uri,
+                            Calls.ALLOW_VOICEMAILS_PARAM_KEY));
+        }
+    }
+
+   /**
+    * Parses the call Id from the given uri, assuming that this is a uri that
+    * matches CALLS_ID. For other uri types the behaviour is undefined.
+    * @throws IllegalArgumentException if the id included in the Uri is not a valid long value.
+    */
+    private long parseCallIdFromUri(Uri uri) {
+        try {
+            return Long.parseLong(uri.getPathSegments().get(1));
+        } catch (NumberFormatException e) {
+            throw new IllegalArgumentException("Invalid call id in uri: " + uri, e);
+        }
+    }
+
+    /**
+     * Sync all calllog entries that were inserted
+     */
+    private void syncEntries() {
+        if (isShadow()) {
+            return; // It's the shadow provider itself.  No copying.
+        }
+
+        final UserManager userManager = UserUtils.getUserManager(getContext());
+
+        // TODO: http://b/24944959
+        if (!Calls.shouldHaveSharedCallLogEntries(getContext(), userManager,
+                userManager.getUserHandle())) {
+            return;
+        }
+
+        final int myUserId = userManager.getUserHandle();
+
+        // See the comment in Calls.addCall() for the logic.
+
+        if (userManager.isSystemUser()) {
+            // If it's the system user, just copy from shadow.
+            syncEntriesFrom(UserHandle.USER_SYSTEM, /* sourceIsShadow = */ true,
+                    /* forAllUsersOnly =*/ false);
+        } else {
+            // Otherwise, copy from system's real provider, as well as self's shadow.
+            syncEntriesFrom(UserHandle.USER_SYSTEM, /* sourceIsShadow = */ false,
+                    /* forAllUsersOnly =*/ true);
+            syncEntriesFrom(myUserId, /* sourceIsShadow = */ true,
+                    /* forAllUsersOnly =*/ false);
+        }
+    }
+
+    private void syncEntriesFrom(int sourceUserId, boolean sourceIsShadow,
+            boolean forAllUsersOnly) {
+
+        final Uri sourceUri = sourceIsShadow ? Calls.SHADOW_CONTENT_URI : Calls.CONTENT_URI;
+
+        final long lastSyncTime = getLastSyncTime(sourceIsShadow);
+
+        final Uri uri = ContentProvider.maybeAddUserId(sourceUri, sourceUserId);
+        final long newestTimeStamp;
+        final ContentResolver cr = getContext().getContentResolver();
+
+        final StringBuilder selection = new StringBuilder();
+
+        selection.append(
+                "(" + EXCLUDE_VOICEMAIL_SELECTION + ") AND (" + MORE_RECENT_THAN_SELECTION + ")");
+
+        if (forAllUsersOnly) {
+            selection.append(" AND (" + Calls.ADD_FOR_ALL_USERS + "=1)");
+        }
+
+        final Cursor cursor = cr.query(
+                uri,
+                CALL_LOG_SYNC_PROJECTION,
+                selection.toString(),
+                new String[] {String.valueOf(lastSyncTime)},
+                Calls.DATE + " ASC");
+        if (cursor == null) {
+            return;
+        }
+        try {
+            newestTimeStamp = copyEntriesFromCursor(cursor, lastSyncTime, sourceIsShadow);
+        } finally {
+            cursor.close();
+        }
+        if (sourceIsShadow) {
+            // delete all entries in shadow.
+            cr.delete(uri, Calls.DATE + "<= ?", new String[] {String.valueOf(newestTimeStamp)});
+        }
+    }
+
+    /**
+     * Un-hides any hidden call log entries that are associated with the specified handle.
+     *
+     * @param handle The handle to the newly registered {@link android.telecom.PhoneAccount}.
+     */
+    private void adjustForNewPhoneAccountInternal(PhoneAccountHandle handle) {
+        String[] handleArgs =
+                new String[] { handle.getComponentName().flattenToString(), handle.getId() };
+
+        // Check to see if any entries exist for this handle. If so (not empty), run the un-hiding
+        // update. If not, then try to identify the call from the phone number.
+        Cursor cursor = query(Calls.CONTENT_URI, MINIMAL_PROJECTION,
+                Calls.PHONE_ACCOUNT_COMPONENT_NAME + " =? AND " + Calls.PHONE_ACCOUNT_ID + " =?",
+                handleArgs, null);
+
+        if (cursor != null) {
+            try {
+                if (cursor.getCount() >= 1) {
+                    // run un-hiding process based on phone account
+                    mDbHelper.getWritableDatabase().execSQL(
+                            UNHIDE_BY_PHONE_ACCOUNT_QUERY, handleArgs);
+                } else {
+                    TelecomManager tm = TelecomManager.from(getContext());
+                    if (tm != null) {
+
+                        PhoneAccount account = tm.getPhoneAccount(handle);
+                        if (account != null && account.getAddress() != null) {
+                            // We did not find any items for the specific phone account, so run the
+                            // query based on the phone number instead.
+                            mDbHelper.getWritableDatabase().execSQL(UNHIDE_BY_ADDRESS_QUERY,
+                                    new String[] { account.getAddress().toString() });
+                        }
+
+                    }
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+
+    }
+
+    /**
+     * @param cursor to copy call log entries from
+     */
+    @VisibleForTesting
+    long copyEntriesFromCursor(Cursor cursor, long lastSyncTime, boolean forShadow) {
+        long latestTimestamp = 0;
+        final ContentValues values = new ContentValues();
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+        db.beginTransaction();
+        try {
+            final String[] args = new String[2];
+            cursor.moveToPosition(-1);
+            while (cursor.moveToNext()) {
+                values.clear();
+                DatabaseUtils.cursorRowToContentValues(cursor, values);
+
+                final String startTime = values.getAsString(Calls.DATE);
+                final String number = values.getAsString(Calls.NUMBER);
+
+                if (startTime == null || number == null) {
+                    continue;
+                }
+
+                if (cursor.isLast()) {
+                    try {
+                        latestTimestamp = Long.valueOf(startTime);
+                    } catch (NumberFormatException e) {
+                        Log.e(TAG, "Call log entry does not contain valid start time: "
+                                + startTime);
+                    }
+                }
+
+                // Avoid duplicating an already existing entry (which is uniquely identified by
+                // the number, and the start time)
+                args[0] = startTime;
+                args[1] = number;
+                if (DatabaseUtils.queryNumEntries(db, Tables.CALLS,
+                        Calls.DATE + " = ? AND " + Calls.NUMBER + " = ?", args) > 0) {
+                    continue;
+                }
+
+                /// M: Remove the null value but not accept null as default columns @{
+                if (values.get(Calls.POST_DIAL_DIGITS) == null) {
+                    values.remove(Calls.POST_DIAL_DIGITS);
+                }
+                if (values.get(Calls.VIA_NUMBER) == null) {
+                    values.remove(Calls.VIA_NUMBER);
+                }
+                /// @}
+
+                db.insert(Tables.CALLS, null, values);
+            }
+
+            if (latestTimestamp > lastSyncTime) {
+                setLastTimeSynced(latestTimestamp, forShadow);
+            }
+
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+        return latestTimestamp;
+    }
+
+    private static String getLastSyncTimePropertyName(boolean forShadow) {
+        return forShadow
+                ? DbProperties.CALL_LOG_LAST_SYNCED_FOR_SHADOW
+                : DbProperties.CALL_LOG_LAST_SYNCED;
+    }
+
+    @VisibleForTesting
+    long getLastSyncTime(boolean forShadow) {
+        try {
+            return Long.valueOf(mDbHelper.getProperty(getLastSyncTimePropertyName(forShadow), "0"));
+        } catch (NumberFormatException e) {
+            return 0;
+        }
+    }
+
+    private void setLastTimeSynced(long time, boolean forShadow) {
+        mDbHelper.setProperty(getLastSyncTimePropertyName(forShadow), String.valueOf(time));
+    }
+
+    private static void waitForAccess(CountDownLatch latch) {
+        if (latch == null) {
+            return;
+        }
+
+        while (true) {
+            try {
+                latch.await();
+                return;
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+
+    private void scheduleBackgroundTask(int task, Object arg) {
+        mBackgroundHandler.obtainMessage(task, arg).sendToTarget();
+    }
+
+    private void performBackgroundTask(int task, Object arg) {
+        if (task == BACKGROUND_TASK_INITIALIZE) {
+            try {
+                syncEntries();
+            } finally {
+                mReadAccessLatch.countDown();
+                mReadAccessLatch = null;
+            }
+        } else if (task == BACKGROUND_TASK_ADJUST_PHONE_ACCOUNT) {
+            adjustForNewPhoneAccountInternal((PhoneAccountHandle) arg);
+        }
+    }
+}
Index: vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogDatabaseHelper.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogDatabaseHelper.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/packages/providers/ContactsProvider/src/com/android/providers/contacts/CallLogDatabaseHelper.java	(revision 14847)
@@ -0,0 +1,395 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.providers.contacts;
+
+import android.annotation.Nullable;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.provider.CallLog.Calls;
+import android.provider.CallLog.ConferenceCalls;
+import android.provider.VoicemailContract;
+import android.provider.VoicemailContract.Status;
+import android.provider.VoicemailContract.Voicemails;
+import android.util.Log;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.providers.contacts.util.PropertyUtils;
+import com.mediatek.providers.contacts.CallLogProviderEx;
+
+/**
+ * SQLite database (helper) for {@link CallLogProvider} and {@link VoicemailContentProvider}.
+ */
+public class CallLogDatabaseHelper {
+    private static final String TAG = "CallLogDatabaseHelper";
+
+    private static final int DATABASE_VERSION = 4;
+
+    private static final boolean DEBUG = false; // DON'T SUBMIT WITH TRUE
+
+    private static final String DATABASE_NAME = "calllog.db";
+
+    private static final String SHADOW_DATABASE_NAME = "calllog_shadow.db";
+
+    private static CallLogDatabaseHelper sInstance;
+
+    /** Instance for the "shadow" provider. */
+    private static CallLogDatabaseHelper sInstanceForShadow;
+
+    private final Context mContext;
+
+    private final OpenHelper mOpenHelper;
+
+    public interface Tables {
+        String CALLS = "calls";
+        String VOICEMAIL_STATUS = "voicemail_status";
+        /// M: Conference calls table
+        String CONFERENCE_CALLS = "conference_calls";
+    }
+
+    public interface DbProperties {
+        String CALL_LOG_LAST_SYNCED = "call_log_last_synced";
+        String CALL_LOG_LAST_SYNCED_FOR_SHADOW = "call_log_last_synced_for_shadow";
+        String DATA_MIGRATED = "migrated";
+    }
+
+    /**
+     * Constants used in the contacts DB helper, which are needed for migration.
+     *
+     * DO NOT CHANCE ANY OF THE CONSTANTS.
+     */
+    private interface LegacyConstants {
+        /** Table name used in the contacts DB.*/
+        String CALLS_LEGACY = "calls";
+
+        /** Table name used in the contacts DB.*/
+        String VOICEMAIL_STATUS_LEGACY = "voicemail_status";
+
+        /** Prop name used in the contacts DB.*/
+        String CALL_LOG_LAST_SYNCED_LEGACY = "call_log_last_synced";
+    }
+
+    private final class OpenHelper extends SQLiteOpenHelper {
+        public OpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,
+                int version) {
+            super(context, name, factory, version);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            if (DEBUG) {
+                Log.d(TAG, "onCreate");
+            }
+
+            PropertyUtils.createPropertiesTable(db);
+
+            // *** NOTE ABOUT CHANGING THE DB SCHEMA ***
+            //
+            // The CALLS and VOICEMAIL_STATUS table used to be in the contacts2.db.  So we need to
+            // migrate from these legacy tables, if exist, after creating the calllog DB, which is
+            // done in migrateFromLegacyTables().
+            //
+            // This migration is slightly different from a regular upgrade step, because it's always
+            // performed from the legacy schema (of the latest version -- because the migration
+            // source is always the latest DB after all the upgrade steps) to the *latest* schema
+            // at once.
+            //
+            // This means certain kind of changes are not doable without changing the
+            // migration logic.  For example, if you rename a column in the DB, the migration step
+            // will need to be updated to handle the column name change.
+
+            db.execSQL("CREATE TABLE " + Tables.CALLS + " (" +
+                    Calls._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+                    Calls.NUMBER + " TEXT," +
+                    Calls.NUMBER_PRESENTATION + " INTEGER NOT NULL DEFAULT " +
+                    Calls.PRESENTATION_ALLOWED + "," +
+                    Calls.POST_DIAL_DIGITS + " TEXT NOT NULL DEFAULT ''," +
+                    Calls.VIA_NUMBER + " TEXT NOT NULL DEFAULT ''," +
+                    Calls.DATE + " INTEGER," +
+                    Calls.DURATION + " INTEGER," +
+                    Calls.DATA_USAGE + " INTEGER," +
+                    Calls.TYPE + " INTEGER," +
+                    Calls.FEATURES + " INTEGER NOT NULL DEFAULT 0," +
+                    Calls.PHONE_ACCOUNT_COMPONENT_NAME + " TEXT," +
+                    Calls.PHONE_ACCOUNT_ID + " TEXT," +
+                    Calls.PHONE_ACCOUNT_ADDRESS + " TEXT," +
+                    Calls.PHONE_ACCOUNT_HIDDEN + " INTEGER NOT NULL DEFAULT 0," +
+                    Calls.SUB_ID + " INTEGER DEFAULT -1," +
+                    Calls.NEW + " INTEGER," +
+                    Calls.CACHED_NAME + " TEXT," +
+                    Calls.CACHED_NUMBER_TYPE + " INTEGER," +
+                    Calls.CACHED_NUMBER_LABEL + " TEXT," +
+                    Calls.COUNTRY_ISO + " TEXT," +
+                    Calls.VOICEMAIL_URI + " TEXT," +
+                    Calls.IS_READ + " INTEGER," +
+                    Calls.GEOCODED_LOCATION + " TEXT," +
+                    Calls.CACHED_LOOKUP_URI + " TEXT," +
+                    Calls.CACHED_MATCHED_NUMBER + " TEXT," +
+                    Calls.CACHED_NORMALIZED_NUMBER + " TEXT," +
+                    Calls.CACHED_PHOTO_ID + " INTEGER NOT NULL DEFAULT 0," +
+                    Calls.CACHED_PHOTO_URI + " TEXT," +
+                    Calls.CACHED_FORMATTED_NUMBER + " TEXT," +
+                    Calls.ADD_FOR_ALL_USERS + " INTEGER NOT NULL DEFAULT 1," +
+                    Calls.LAST_MODIFIED + " INTEGER DEFAULT 0," +
+                    Voicemails._DATA + " TEXT," +
+                    Voicemails.HAS_CONTENT + " INTEGER," +
+                    Voicemails.MIME_TYPE + " TEXT," +
+                    Voicemails.SOURCE_DATA + " TEXT," +
+                    Voicemails.SOURCE_PACKAGE + " TEXT," +
+                    Voicemails.TRANSCRIPTION + " TEXT," +
+                    Voicemails.STATE + " INTEGER," +
+                    Voicemails.DIRTY + " INTEGER NOT NULL DEFAULT 0," +
+                    Voicemails.DELETED + " INTEGER NOT NULL DEFAULT 0," +
+                    /// M: Add the ip prefix , conference id, sim indicate, is sdn @{
+                    Calls.IP_PREFIX +  " TEXT," +
+                    Calls.CONFERENCE_CALL_ID +  " INTEGER," +
+                    Calls.CACHED_INDICATE_PHONE_SIM + " INTEGER NOT NULL DEFAULT -1," +
+                    Calls.CACHED_IS_SDN_CONTACT + " INTEGER NOT NULL DEFAULT 0," +
+					Calls.IS_VOLTE_CALL +  " INTEGER NOT NULL DEFAULT 0" +
+                    /// @}
+                    ");");
+
+            /// M: Create conference table @{
+            CallLogProviderEx.createConferenceCallsTable(db);
+            /// @}
+
+            db.execSQL("CREATE TABLE " + Tables.VOICEMAIL_STATUS + " (" +
+                    VoicemailContract.Status._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+                    VoicemailContract.Status.SOURCE_PACKAGE + " TEXT NOT NULL," +
+                    VoicemailContract.Status.PHONE_ACCOUNT_COMPONENT_NAME + " TEXT," +
+                    VoicemailContract.Status.PHONE_ACCOUNT_ID + " TEXT," +
+                    VoicemailContract.Status.SETTINGS_URI + " TEXT," +
+                    VoicemailContract.Status.VOICEMAIL_ACCESS_URI + " TEXT," +
+                    VoicemailContract.Status.CONFIGURATION_STATE + " INTEGER," +
+                    VoicemailContract.Status.DATA_CHANNEL_STATE + " INTEGER," +
+                    VoicemailContract.Status.NOTIFICATION_CHANNEL_STATE + " INTEGER," +
+                    VoicemailContract.Status.QUOTA_OCCUPIED + " INTEGER DEFAULT -1," +
+                    VoicemailContract.Status.QUOTA_TOTAL + " INTEGER DEFAULT -1," +
+                    VoicemailContract.Status.SOURCE_TYPE + " TEXT" +
+                    ");");
+
+            migrateFromLegacyTables(db);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            if (DEBUG) {
+                Log.d(TAG, "onUpgrade");
+            }
+
+            if (oldVersion < 2) {
+                upgradeToVersion2(db);
+            }
+
+            if (oldVersion < 3) {
+                upgradeToVersion3(db);
+            }
+				
+			if (oldVersion < 4) {
+                upgradeToVersion4(db);
+            }
+        }
+    }
+
+    @VisibleForTesting
+    CallLogDatabaseHelper(Context context, String databaseName) {
+        mContext = context;
+        mOpenHelper = new OpenHelper(mContext, databaseName, /* factory=*/ null, DATABASE_VERSION);
+    }
+
+    public static synchronized CallLogDatabaseHelper getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new CallLogDatabaseHelper(context, DATABASE_NAME);
+        }
+        return sInstance;
+    }
+
+    public static synchronized CallLogDatabaseHelper getInstanceForShadow(Context context) {
+        if (sInstanceForShadow == null) {
+            // Shadow provider is always encryption-aware.
+            sInstanceForShadow = new CallLogDatabaseHelper(
+                    context.createDeviceProtectedStorageContext(), SHADOW_DATABASE_NAME);
+        }
+        return sInstanceForShadow;
+    }
+
+    public SQLiteDatabase getReadableDatabase() {
+        return mOpenHelper.getReadableDatabase();
+    }
+
+    public SQLiteDatabase getWritableDatabase() {
+        return mOpenHelper.getWritableDatabase();
+    }
+
+    public String getProperty(String key, String defaultValue) {
+        return PropertyUtils.getProperty(getReadableDatabase(), key, defaultValue);
+    }
+
+    public void setProperty(String key, String value) {
+        PropertyUtils.setProperty(getWritableDatabase(), key, value);
+    }
+
+    /**
+     * Add the {@link Calls.VIA_NUMBER} Column to the CallLog Database.
+     */
+    private void upgradeToVersion2(SQLiteDatabase db) {
+        db.execSQL("ALTER TABLE " + Tables.CALLS + " ADD " + Calls.VIA_NUMBER +
+                " TEXT NOT NULL DEFAULT ''");
+    }
+
+    /**
+     * Add the {@link Status.SOURCE_TYPE} Column to the VoicemailStatus Database.
+     */
+    private void upgradeToVersion3(SQLiteDatabase db) {
+        db.execSQL("ALTER TABLE " + Tables.VOICEMAIL_STATUS + " ADD " + Status.SOURCE_TYPE +
+                " TEXT");
+        db.execSQL("ALTER TABLE " + Tables.CONFERENCE_CALLS + " ADD " +
+                ConferenceCalls.CONFERENCE_DURATION + " INTEGER DEFAULT -1");
+    }
+	
+		private void upgradeToVersion4(SQLiteDatabase db) {
+        db.execSQL("ALTER TABLE " + Tables.CALLS + " ADD " + Calls.IS_VOLTE_CALL +
+                " INTEGER NOT NULL DEFAULT 0");
+    }
+
+    /**
+     * Perform the migration from the contacts2.db (of the latest version) to the current calllog/
+     * voicemail status tables.
+     */
+    private void migrateFromLegacyTables(SQLiteDatabase calllog) {
+        final SQLiteDatabase contacts = getContactsWritableDatabaseForMigration();
+
+        if (contacts == null) {
+            Log.w(TAG, "Contacts DB == null, skipping migration. (running tests?)");
+            return;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "migrateFromLegacyTables");
+        }
+
+        if ("1".equals(PropertyUtils.getProperty(calllog, DbProperties.DATA_MIGRATED, ""))) {
+            return;
+        }
+
+        Log.i(TAG, "Migrating from old tables...");
+
+        contacts.beginTransaction();
+        try {
+            if (!tableExists(contacts, LegacyConstants.CALLS_LEGACY)
+                    || !tableExists(contacts, LegacyConstants.VOICEMAIL_STATUS_LEGACY)) {
+                // This is fine on new devices. (or after a "clear data".)
+                Log.i(TAG, "Source tables don't exist.");
+                return;
+            }
+            calllog.beginTransaction();
+            try {
+
+                final ContentValues cv = new ContentValues();
+
+                try (Cursor source = contacts.rawQuery(
+                        "SELECT * FROM " + LegacyConstants.CALLS_LEGACY, null)) {
+                    while (source.moveToNext()) {
+                        cv.clear();
+
+                        DatabaseUtils.cursorRowToContentValues(source, cv);
+                        /// M: Remove the data_id, raw_contact_id fields @{
+                        cv.remove("raw_contact_id");
+                        cv.remove("data_id");
+                        /// @}
+
+                        calllog.insertOrThrow(Tables.CALLS, null, cv);
+                    }
+                }
+
+                try (Cursor source = contacts.rawQuery("SELECT * FROM " +
+                        LegacyConstants.VOICEMAIL_STATUS_LEGACY, null)) {
+                    while (source.moveToNext()) {
+                        cv.clear();
+
+                        DatabaseUtils.cursorRowToContentValues(source, cv);
+
+                        calllog.insertOrThrow(Tables.VOICEMAIL_STATUS, null, cv);
+                    }
+                }
+
+                contacts.execSQL("DROP TABLE " + LegacyConstants.CALLS_LEGACY + ";");
+                contacts.execSQL("DROP TABLE " + LegacyConstants.VOICEMAIL_STATUS_LEGACY + ";");
+
+                /// M: Migrate the conference and dialer search @{
+                if (tableExists(contacts,"conference_calls")) {
+                    try (Cursor source = contacts.rawQuery(
+                            "SELECT * FROM conference_calls ", null)) {
+                        while (source.moveToNext()) {
+                            cv.clear();
+
+                            DatabaseUtils.cursorRowToContentValues(source, cv);
+
+                            calllog.insertOrThrow(Tables.CONFERENCE_CALLS, null, cv);
+                        }
+                    }
+                    contacts.execSQL("DROP TABLE conference_calls;");
+                }
+                // Drop dialer search tables
+                CallLogProviderEx.dropDialerSearchTables(contacts);
+                /// @}
+
+                // Also copy the last sync time.
+                PropertyUtils.setProperty(calllog, DbProperties.CALL_LOG_LAST_SYNCED,
+                        PropertyUtils.getProperty(contacts,
+                                LegacyConstants.CALL_LOG_LAST_SYNCED_LEGACY, null));
+
+                Log.i(TAG, "Migration completed.");
+
+                calllog.setTransactionSuccessful();
+            } finally {
+                calllog.endTransaction();
+            }
+
+            contacts.setTransactionSuccessful();
+        } catch (RuntimeException e) {
+            // We don't want to be stuck here, so we just swallow exceptions...
+            Log.w(TAG, "Exception caught during migration", e);
+        } finally {
+            contacts.endTransaction();
+        }
+        PropertyUtils.setProperty(calllog, DbProperties.DATA_MIGRATED, "1");
+    }
+
+    @VisibleForTesting
+    static boolean tableExists(SQLiteDatabase db, String table) {
+        return DatabaseUtils.longForQuery(db,
+                "select count(*) from sqlite_master where type='table' and name=?",
+                new String[] {table}) > 0;
+    }
+
+    @VisibleForTesting
+    @Nullable // We return null during tests when migration is not needed.
+    SQLiteDatabase getContactsWritableDatabaseForMigration() {
+        return ContactsDatabaseHelper.getInstance(mContext).getWritableDatabase();
+    }
+
+    @VisibleForTesting
+    void closeForTest() {
+        mOpenHelper.close();
+    }
+
+    public void wipeForTest() {
+        getWritableDatabase().execSQL("DELETE FROM " + Tables.CALLS);
+    }
+}
Index: vendor/branch/5058A_Claro_Peru/frameworks/base/core/java/android/provider/CallLog.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/frameworks/base/core/java/android/provider/CallLog.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/frameworks/base/core/java/android/provider/CallLog.java	(revision 14847)
@@ -0,0 +1,1140 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package android.provider;
+
+import android.content.ContentProvider;
+
+
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.UserInfo;
+import android.database.Cursor;
+import android.location.Country;
+import android.location.CountryDetector;
+import android.net.Uri;
+import android.os.Build;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.ContactsContract.CommonDataKinds.Callable;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.DataUsageFeedback;
+import android.telecom.PhoneAccount;
+import android.telecom.PhoneAccountHandle;
+import android.telecom.TelecomManager;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.telephony.CallerInfo;
+import com.android.internal.telephony.PhoneConstants;
+
+import java.util.List;
+
+
+/**
+ * The CallLog provider contains information about placed and received calls.
+ */
+public class CallLog {
+    private static final String LOG_TAG = "CallLog";
+    ///M:enable log for non-user loads
+    private static final boolean VERBOSE_LOG =
+            !("user".equals(Build.TYPE));// DON'T SUBMIT WITH TRUE.
+
+    public static final String AUTHORITY = "call_log";
+
+    /**
+     * The content:// style URL for this provider
+     */
+    public static final Uri CONTENT_URI =
+        Uri.parse("content://" + AUTHORITY);
+
+
+    /**
+     * The "shadow" provider stores calllog when the real calllog provider is encrypted.  The
+     * real provider will alter copy from it when it starts, and remove the entries in the shadow.
+     *
+     * <p>See the comment in {@link Calls#addCall} for the details.
+     *
+     * @hide
+     */
+    public static final String SHADOW_AUTHORITY = "call_log_shadow";
+
+    /**
+     * Contains the recent calls.
+     */
+    public static class Calls implements BaseColumns {
+        /**
+         * The content:// style URL for this table
+         */
+        public static final Uri CONTENT_URI =
+                Uri.parse("content://call_log/calls");
+
+        /** @hide */
+        public static final Uri SHADOW_CONTENT_URI =
+                Uri.parse("content://call_log_shadow/calls");
+
+        /**
+         * The content:// style URL for filtering this table on phone numbers
+         */
+        public static final Uri CONTENT_FILTER_URI =
+                Uri.parse("content://call_log/calls/filter");
+
+        /**
+         * Query parameter used to limit the number of call logs returned.
+         * <p>
+         * TYPE: integer
+         */
+        public static final String LIMIT_PARAM_KEY = "limit";
+
+        /**
+         * Query parameter used to specify the starting record to return.
+         * <p>
+         * TYPE: integer
+         */
+        public static final String OFFSET_PARAM_KEY = "offset";
+
+        /**
+         * An optional URI parameter which instructs the provider to allow the operation to be
+         * applied to voicemail records as well.
+         * <p>
+         * TYPE: Boolean
+         * <p>
+         * Using this parameter with a value of {@code true} will result in a security error if the
+         * calling package does not have appropriate permissions to access voicemails.
+         *
+         * @hide
+         */
+        public static final String ALLOW_VOICEMAILS_PARAM_KEY = "allow_voicemails";
+
+        /**
+         * An optional extra used with {@link #CONTENT_TYPE Calls.CONTENT_TYPE} and
+         * {@link Intent#ACTION_VIEW} to specify that the presented list of calls should be
+         * filtered for a particular call type.
+         *
+         * Applications implementing a call log UI should check for this extra, and display a
+         * filtered list of calls based on the specified call type. If not applicable within the
+         * application's UI, it should be silently ignored.
+         *
+         * <p>
+         * The following example brings up the call log, showing only missed calls.
+         * <pre>
+         * Intent intent = new Intent(Intent.ACTION_VIEW);
+         * intent.setType(CallLog.Calls.CONTENT_TYPE);
+         * intent.putExtra(CallLog.Calls.EXTRA_CALL_TYPE_FILTER, CallLog.Calls.MISSED_TYPE);
+         * startActivity(intent);
+         * </pre>
+         * </p>
+         */
+        public static final String EXTRA_CALL_TYPE_FILTER =
+                "android.provider.extra.CALL_TYPE_FILTER";
+
+        /**
+         * Content uri used to access call log entries, including voicemail records. You must have
+         * the READ_CALL_LOG and WRITE_CALL_LOG permissions to read and write to the call log, as
+         * well as READ_VOICEMAIL and WRITE_VOICEMAIL permissions to read and write voicemails.
+         */
+        public static final Uri CONTENT_URI_WITH_VOICEMAIL = CONTENT_URI.buildUpon()
+                .appendQueryParameter(ALLOW_VOICEMAILS_PARAM_KEY, "true")
+                .build();
+
+        /**
+         * The default sort order for this table
+         */
+        public static final String DEFAULT_SORT_ORDER = "date DESC";
+
+        /**
+         * The MIME type of {@link #CONTENT_URI} and {@link #CONTENT_FILTER_URI}
+         * providing a directory of calls.
+         */
+        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/calls";
+
+        /**
+         * The MIME type of a {@link #CONTENT_URI} sub-directory of a single
+         * call.
+         */
+        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/calls";
+
+        /**
+         * The type of the call (incoming, outgoing or missed).
+         * <P>Type: INTEGER (int)</P>
+         *
+         * <p>
+         * Allowed values:
+         * <ul>
+         * <li>{@link #INCOMING_TYPE}</li>
+         * <li>{@link #OUTGOING_TYPE}</li>
+         * <li>{@link #MISSED_TYPE}</li>
+         * <li>{@link #VOICEMAIL_TYPE}</li>
+         * <li>{@link #REJECTED_TYPE}</li>
+         * <li>{@link #BLOCKED_TYPE}</li>
+         * <li>{@link #ANSWERED_EXTERNALLY_TYPE}</li>
+         * </ul>
+         * </p>
+         */
+        public static final String TYPE = "type";
+
+        /** Call log type for incoming calls. */
+        public static final int INCOMING_TYPE = 1;
+        /** Call log type for outgoing calls. */
+        public static final int OUTGOING_TYPE = 2;
+        /** Call log type for missed calls. */
+        public static final int MISSED_TYPE = 3;
+        /** Call log type for voicemails. */
+        public static final int VOICEMAIL_TYPE = 4;
+        /** Call log type for calls rejected by direct user action. */
+        public static final int REJECTED_TYPE = 5;
+        /** Call log type for calls blocked automatically. */
+        public static final int BLOCKED_TYPE = 6;
+        /**
+         * Call log type for a call which was answered on another device.  Used in situations where
+         * a call rings on multiple devices simultaneously and it ended up being answered on a
+         * device other than the current one.
+         */
+        public static final int ANSWERED_EXTERNALLY_TYPE = 7;
+
+        /**
+         * M: Call log type for auto rejected calls.
+         * @hide
+         * @internal
+         */
+        public static final int AUTO_REJECT_TYPE = 8;
+
+        /**
+         * Bit-mask describing features of the call (e.g. video).
+         *
+         * <P>Type: INTEGER (int)</P>
+         */
+        public static final String FEATURES = "features";
+
+        /** Call had video. */
+        public static final int FEATURES_VIDEO = 0x1;
+
+        /** Call was pulled externally. */
+        public static final int FEATURES_PULLED_EXTERNALLY = 0x2;
+
+        /**
+         * The phone number as the user entered it.
+         * <P>Type: TEXT</P>
+         */
+        public static final String NUMBER = "number";
+
+        /**
+         * The number presenting rules set by the network.
+         *
+         * <p>
+         * Allowed values:
+         * <ul>
+         * <li>{@link #PRESENTATION_ALLOWED}</li>
+         * <li>{@link #PRESENTATION_RESTRICTED}</li>
+         * <li>{@link #PRESENTATION_UNKNOWN}</li>
+         * <li>{@link #PRESENTATION_PAYPHONE}</li>
+         * </ul>
+         * </p>
+         *
+         * <P>Type: INTEGER</P>
+         */
+        public static final String NUMBER_PRESENTATION = "presentation";
+
+        /** Number is allowed to display for caller id. */
+        public static final int PRESENTATION_ALLOWED = 1;
+        /** Number is blocked by user. */
+        public static final int PRESENTATION_RESTRICTED = 2;
+        /** Number is not specified or unknown by network. */
+        public static final int PRESENTATION_UNKNOWN = 3;
+        /** Number is a pay phone. */
+        public static final int PRESENTATION_PAYPHONE = 4;
+
+        /**
+         * The ISO 3166-1 two letters country code of the country where the
+         * user received or made the call.
+         * <P>
+         * Type: TEXT
+         * </P>
+         */
+        public static final String COUNTRY_ISO = "countryiso";
+
+        /**
+         * The date the call occured, in milliseconds since the epoch
+         * <P>Type: INTEGER (long)</P>
+         */
+        public static final String DATE = "date";
+
+        /**
+         * The duration of the call in seconds
+         * <P>Type: INTEGER (long)</P>
+         */
+        public static final String DURATION = "duration";
+
+        /**
+         * The data usage of the call in bytes.
+         * <P>Type: INTEGER (long)</P>
+         */
+        public static final String DATA_USAGE = "data_usage";
+
+        /**
+         * Whether or not the call has been acknowledged
+         * <P>Type: INTEGER (boolean)</P>
+         */
+        public static final String NEW = "new";
+
+        /**
+         * The cached name associated with the phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_NAME = "name";
+
+        /**
+         * The cached number type (Home, Work, etc) associated with the
+         * phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String CACHED_NUMBER_TYPE = "numbertype";
+
+        /**
+         * The cached number label, for a custom number type, associated with the
+         * phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_NUMBER_LABEL = "numberlabel";
+
+        /**
+         * URI of the voicemail entry. Populated only for {@link #VOICEMAIL_TYPE}.
+         * <P>Type: TEXT</P>
+         */
+        public static final String VOICEMAIL_URI = "voicemail_uri";
+
+        /**
+         * Transcription of the call or voicemail entry. This will only be populated for call log
+         * entries of type {@link #VOICEMAIL_TYPE} that have valid transcriptions.
+         */
+        public static final String TRANSCRIPTION = "transcription";
+
+        /**
+         * Whether this item has been read or otherwise consumed by the user.
+         * <p>
+         * Unlike the {@link #NEW} field, which requires the user to have acknowledged the
+         * existence of the entry, this implies the user has interacted with the entry.
+         * <P>Type: INTEGER (boolean)</P>
+         */
+        public static final String IS_READ = "is_read";
+
+        /**
+         * A geocoded location for the number associated with this call.
+         * <p>
+         * The string represents a city, state, or country associated with the number.
+         * <P>Type: TEXT</P>
+         */
+        public static final String GEOCODED_LOCATION = "geocoded_location";
+
+        /**
+         * The cached URI to look up the contact associated with the phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_LOOKUP_URI = "lookup_uri";
+
+        /**
+         * The cached phone number of the contact which matches this entry, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_MATCHED_NUMBER = "matched_number";
+
+        /**
+         * The cached normalized(E164) version of the phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_NORMALIZED_NUMBER = "normalized_number";
+
+        /**
+         * The cached photo id of the picture associated with the phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: INTEGER (long)</P>
+         */
+        public static final String CACHED_PHOTO_ID = "photo_id";
+
+        /**
+         * The cached photo URI of the picture associated with the phone number, if it exists.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT (URI)</P>
+         */
+        public static final String CACHED_PHOTO_URI = "photo_uri";
+
+        /**
+         * The cached phone number, formatted with formatting rules based on the country the
+         * user was in when the call was made or received.
+         *
+         * <p>This value is typically filled in by the dialer app for the caching purpose,
+         * so it's not guaranteed to be present, and may not be current if the contact
+         * information associated with this number has changed.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CACHED_FORMATTED_NUMBER = "formatted_number";
+
+        // Note: PHONE_ACCOUNT_* constant values are "subscription_*" due to a historic naming
+        // that was encoded into call log databases.
+
+        /**
+         * The component name of the account used to place or receive the call; in string form.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PHONE_ACCOUNT_COMPONENT_NAME = "subscription_component_name";
+
+        /**
+         * The identifier for the account used to place or receive the call.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PHONE_ACCOUNT_ID = "subscription_id";
+
+        /**
+         * The address associated with the account used to place or receive the call; in string
+         * form. For SIM-based calls, this is the user's own phone number.
+         * <P>Type: TEXT</P>
+         *
+         * @hide
+         */
+        public static final String PHONE_ACCOUNT_ADDRESS = "phone_account_address";
+
+        /**
+         * Indicates that the entry will be hidden from all queries until the associated
+         * {@link android.telecom.PhoneAccount} is registered with the system.
+         * <P>Type: INTEGER</P>
+         *
+         * @hide
+         */
+        public static final String PHONE_ACCOUNT_HIDDEN = "phone_account_hidden";
+
+        /**
+         * The subscription ID used to place this call.  This is no longer used and has been
+         * replaced with PHONE_ACCOUNT_COMPONENT_NAME/PHONE_ACCOUNT_ID.
+         * For ContactsProvider internal use only.
+         * <P>Type: INTEGER</P>
+         *
+         * @Deprecated
+         * @hide
+         */
+        public static final String SUB_ID = "sub_id";
+
+        /**
+         * The post-dial portion of a dialed number, including any digits dialed after a
+         * {@link TelecomManager#DTMF_CHARACTER_PAUSE} or a {@link
+         * TelecomManager#DTMF_CHARACTER_WAIT} and these characters themselves.
+         * <P>Type: TEXT</P>
+         */
+        public static final String POST_DIAL_DIGITS = "post_dial_digits";
+
+        /**
+         * For an incoming call, the secondary line number the call was received via.
+         * When a SIM card has multiple phone numbers associated with it, the via number indicates
+         * which of the numbers associated with the SIM was called.
+         */
+        public static final String VIA_NUMBER = "via_number";
+
+        /**
+         * Indicates that the entry will be copied from primary user to other users.
+         * <P>Type: INTEGER</P>
+         *
+         * @hide
+         */
+        public static final String ADD_FOR_ALL_USERS = "add_for_all_users";
+
+        /**
+         * The date the row is last inserted, updated, or marked as deleted, in milliseconds
+         * since the epoch. Read only.
+         * <P>Type: INTEGER (long)</P>
+         */
+        public static final String LAST_MODIFIED = "last_modified";
+
+        /**
+         * If a successful call is made that is longer than this duration, update the phone number
+         * in the ContactsProvider with the normalized version of the number, based on the user's
+         * current country code.
+         */
+        private static final int MIN_DURATION_FOR_NORMALIZED_NUMBER_UPDATE_MS = 1000 * 10;
+
+        /**
+         * Adds a call to the call log.
+         *
+         * @param ci the CallerInfo object to get the target contact from.  Can be null
+         * if the contact is unknown.
+         * @param context the context used to get the ContentResolver
+         * @param number the phone number to be added to the calls db
+         * @param presentation enum value from PhoneConstants.PRESENTATION_xxx, which
+         *        is set by the network and denotes the number presenting rules for
+         *        "allowed", "payphone", "restricted" or "unknown"
+         * @param callType enumerated values for "incoming", "outgoing", or "missed"
+         * @param features features of the call (e.g. Video).
+         * @param accountHandle The accountHandle object identifying the provider of the call
+         * @param start time stamp for the call in milliseconds
+         * @param duration call duration in seconds
+         * @param dataUsage data usage for the call in bytes, null if data usage was not tracked for
+         *                  the call.
+         * @result The URI of the call log entry belonging to the user that made or received this
+         *        call.
+         * {@hide}
+         */
+        public static Uri addCall(CallerInfo ci, Context context, String number,
+                int presentation, int callType, int features, PhoneAccountHandle accountHandle,
+                long start, int duration, Long dataUsage) {
+            return addCall(ci, context, number, /* postDialDigits =*/ "", /* viaNumber =*/ "",
+                    presentation, callType, features, accountHandle, start, duration,
+                    dataUsage, /* addForAllUsers =*/ false, /* userToBeInsertedTo =*/ null,
+                    /* is_read =*/ false);
+        }
+
+
+        /**
+         * Adds a call to the call log.
+         *
+         * @param ci the CallerInfo object to get the target contact from.  Can be null
+         * if the contact is unknown.
+         * @param context the context used to get the ContentResolver
+         * @param number the phone number to be added to the calls db
+         * @param viaNumber the secondary number that the incoming call received with. If the
+         *       call was received with the SIM assigned number, then this field must be ''.
+         * @param presentation enum value from PhoneConstants.PRESENTATION_xxx, which
+         *        is set by the network and denotes the number presenting rules for
+         *        "allowed", "payphone", "restricted" or "unknown"
+         * @param callType enumerated values for "incoming", "outgoing", or "missed"
+         * @param features features of the call (e.g. Video).
+         * @param accountHandle The accountHandle object identifying the provider of the call
+         * @param start time stamp for the call in milliseconds
+         * @param duration call duration in seconds
+         * @param dataUsage data usage for the call in bytes, null if data usage was not tracked for
+         *                  the call.
+         * @param addForAllUsers If true, the call is added to the call log of all currently
+         *        running users. The caller must have the MANAGE_USERS permission if this is true.
+         * @param userToBeInsertedTo {@link UserHandle} of user that the call is going to be
+         *                           inserted to. null if it is inserted to the current user. The
+         *                           value is ignored if @{link addForAllUsers} is true.
+         * @result The URI of the call log entry belonging to the user that made or received this
+         *        call.
+         * {@hide}
+         */
+        public static Uri addCall(CallerInfo ci, Context context, String number,
+                String postDialDigits, String viaNumber, int presentation, int callType,
+                int features, PhoneAccountHandle accountHandle, long start, int duration,
+                Long dataUsage, boolean addForAllUsers, UserHandle userToBeInsertedTo) {
+            return addCall(ci, context, number, postDialDigits, viaNumber, presentation, callType,
+                    features, accountHandle, start, duration, dataUsage, addForAllUsers,
+                    userToBeInsertedTo, /* is_read =*/ false);
+        }
+
+        /**
+         * Adds a call to the call log.
+         *
+         * @param ci the CallerInfo object to get the target contact from.  Can be null
+         * if the contact is unknown.
+         * @param context the context used to get the ContentResolver
+         * @param number the phone number to be added to the calls db
+         * @param postDialDigits the post-dial digits that were dialed after the number,
+         *        if it was outgoing. Otherwise it is ''.
+         * @param viaNumber the secondary number that the incoming call received with. If the
+         *        call was received with the SIM assigned number, then this field must be ''.
+         * @param presentation enum value from PhoneConstants.PRESENTATION_xxx, which
+         *        is set by the network and denotes the number presenting rules for
+         *        "allowed", "payphone", "restricted" or "unknown"
+         * @param callType enumerated values for "incoming", "outgoing", or "missed"
+         * @param features features of the call (e.g. Video).
+         * @param accountHandle The accountHandle object identifying the provider of the call
+         * @param start time stamp for the call in milliseconds
+         * @param duration call duration in seconds
+         * @param dataUsage data usage for the call in bytes, null if data usage was not tracked for
+         *                  the call.
+         * @param addForAllUsers If true, the call is added to the call log of all currently
+         *        running users. The caller must have the MANAGE_USERS permission if this is true.
+         * @param userToBeInsertedTo {@link UserHandle} of user that the call is going to be
+         *                           inserted to. null if it is inserted to the current user. The
+         *                           value is ignored if @{link addForAllUsers} is true.
+         * @param is_read Flag to show if the missed call log has been read by the user or not.
+         *                Used for call log restore of missed calls.
+         *
+         * @result The URI of the call log entry belonging to the user that made or received this
+         *        call.  This could be of the shadow provider.  Do not return it to non-system apps,
+         *        as they don't have permissions.
+         * {@hide}
+         */
+        public static Uri addCall(CallerInfo ci, Context context, String number,
+                String postDialDigits, String viaNumber, int presentation, int callType,
+                int features, PhoneAccountHandle accountHandle, long start, int duration,
+                Long dataUsage, boolean addForAllUsers, UserHandle userToBeInsertedTo,
+                boolean is_read) {
+             /// M: Add a parameter for Volte Conference call Calllog
+            return addCall(ci, context, number, postDialDigits, viaNumber, presentation, callType,
+                    features, accountHandle, start, duration, dataUsage, addForAllUsers,
+                    userToBeInsertedTo, is_read, -1, 0, -1);
+        }
+
+        /**
+         * M: Add a parameter for Volte Conference call Calllog
+         * Adds a call to the call log.
+         *
+         * @param ci the CallerInfo object to get the target contact from.  Can be null
+         * if the contact is unknown.
+         * @param context the context used to get the ContentResolver
+         * @param number the phone number to be added to the calls db
+         * @param postDialDigits the post-dial digits that were dialed after the number,
+         *        if it was outgoing. Otherwise it is ''.
+         * @param viaNumber the secondary number that the incoming call received with. If the
+         *        call was received with the SIM assigned number, then this field must be ''.
+         * @param presentation enum value from PhoneConstants.PRESENTATION_xxx, which
+         *        is set by the network and denotes the number presenting rules for
+         *        "allowed", "payphone", "restricted" or "unknown"
+         * @param callType enumerated values for "incoming", "outgoing", or "missed"
+         * @param features features of the call (e.g. Video).
+         * @param accountHandle The accountHandle object identifying the provider of the call
+         * @param start time stamp for the call in milliseconds
+         * @param duration call duration in seconds
+         * @param dataUsage data usage for the call in bytes, null if data usage was not tracked for
+         *                  the call.
+         * @param addForAllUsers If true, the call is added to the call log of all currently
+         *        running users. The caller must have the MANAGE_USERS permission if this is true.
+         * @param userToBeInsertedTo {@link UserHandle} of user that the call is going to be
+         *                           inserted to. null if it is inserted to the current user. The
+         *                           value is ignored if @{link addForAllUsers} is true.
+         * @param is_read Flag to show if the missed call log has been read by the user or not.
+         *                Used for call log restore of missed calls.
+         * @param conferenceCallId The conference call id in database.
+         * @param conferenceDuration conference duration in seconds
+         *
+         * @return The URI of the call log entry belonging to the user that made or received this
+         *        call.  This could be of the shadow provider.  Do not return it to non-system apps,
+         *        as they don't have permissions.
+         * {@hide}
+         */
+        public static Uri addCall(CallerInfo ci, Context context, String number,
+                String postDialDigits, String viaNumber, int presentation, int callType,
+                int features, PhoneAccountHandle accountHandle, long start, int duration,
+                Long dataUsage, boolean addForAllUsers, UserHandle userToBeInsertedTo,
+                boolean is_read, long conferenceCallId, int isVolteCall, int conferenceDuration) {
+            if (VERBOSE_LOG) {
+                Log.v(LOG_TAG, String.format("Add call: number=%s, user=%s, for all=%s",
+                        number, userToBeInsertedTo, addForAllUsers));
+            }
+            final ContentResolver resolver = context.getContentResolver();
+            int numberPresentation = PRESENTATION_ALLOWED;
+
+            TelecomManager tm = null;
+            try {
+                tm = TelecomManager.from(context);
+            } catch (UnsupportedOperationException e) {}
+
+            String accountAddress = null;
+            if (tm != null && accountHandle != null) {
+                PhoneAccount account = tm.getPhoneAccount(accountHandle);
+                if (account != null) {
+                    Uri address = account.getSubscriptionAddress();
+                    if (address != null) {
+                        accountAddress = address.getSchemeSpecificPart();
+                    }
+                }
+            }
+
+            // Remap network specified number presentation types
+            // PhoneConstants.PRESENTATION_xxx to calllog number presentation types
+            // Calls.PRESENTATION_xxx, in order to insulate the persistent calllog
+            // from any future radio changes.
+            // If the number field is empty set the presentation type to Unknown.
+            if (presentation == PhoneConstants.PRESENTATION_RESTRICTED) {
+                numberPresentation = PRESENTATION_RESTRICTED;
+            } else if (presentation == PhoneConstants.PRESENTATION_PAYPHONE) {
+                numberPresentation = PRESENTATION_PAYPHONE;
+            } else if (TextUtils.isEmpty(number)
+                    || presentation == PhoneConstants.PRESENTATION_UNKNOWN) {
+                numberPresentation = PRESENTATION_UNKNOWN;
+            }
+            if (numberPresentation != PRESENTATION_ALLOWED) {
+                number = "";
+                if (ci != null) {
+                    ci.name = "";
+                }
+            }
+
+            // accountHandle information
+            String accountComponentString = null;
+            String accountId = null;
+            if (accountHandle != null) {
+                accountComponentString = accountHandle.getComponentName().flattenToString();
+                accountId = accountHandle.getId();
+            }
+
+            ContentValues values = new ContentValues(6);
+
+            values.put(NUMBER, number);
+            values.put(POST_DIAL_DIGITS, postDialDigits);
+            values.put(VIA_NUMBER, viaNumber);
+            values.put(NUMBER_PRESENTATION, Integer.valueOf(numberPresentation));
+            values.put(TYPE, Integer.valueOf(callType));
+            values.put(FEATURES, features);
+            values.put(DATE, Long.valueOf(start));
+            values.put(DURATION, Long.valueOf(duration));
+            if (dataUsage != null) {
+                values.put(DATA_USAGE, dataUsage);
+            }
+            values.put(PHONE_ACCOUNT_COMPONENT_NAME, accountComponentString);
+            values.put(PHONE_ACCOUNT_ID, accountId);
+            values.put(PHONE_ACCOUNT_ADDRESS, accountAddress);
+            values.put(NEW, Integer.valueOf(1));
+            values.put(ADD_FOR_ALL_USERS, addForAllUsers ? 1 : 0);
+
+            if (callType == MISSED_TYPE) {
+                values.put(IS_READ, Integer.valueOf(is_read ? 1 : 0));
+            }
+
+            if ((ci != null) && (ci.contactIdOrZero > 0)) {
+                // Update usage information for the number associated with the contact ID.
+                // We need to use both the number and the ID for obtaining a data ID since other
+                // contacts may have the same number.
+
+                final Cursor cursor;
+
+                // We should prefer normalized one (probably coming from
+                // Phone.NORMALIZED_NUMBER column) first. If it isn't available try others.
+                if (ci.normalizedNumber != null) {
+                    final String normalizedPhoneNumber = ci.normalizedNumber;
+                    cursor = resolver.query(Phone.CONTENT_URI,
+                            new String[] { Phone._ID },
+                            Phone.CONTACT_ID + " =? AND " + Phone.NORMALIZED_NUMBER + " =?",
+                            new String[] { String.valueOf(ci.contactIdOrZero),
+                                    normalizedPhoneNumber},
+                            null);
+                } else {
+                    final String phoneNumber = ci.phoneNumber != null ? ci.phoneNumber : number;
+                    cursor = resolver.query(
+                            Uri.withAppendedPath(Callable.CONTENT_FILTER_URI,
+                                    Uri.encode(phoneNumber)),
+                            new String[] { Phone._ID },
+                            Phone.CONTACT_ID + " =?",
+                            new String[] { String.valueOf(ci.contactIdOrZero) },
+                            null);
+                }
+
+                if (cursor != null) {
+                    try {
+                        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+                            final String dataId = cursor.getString(0);
+                            updateDataUsageStatForData(resolver, dataId);
+                            if (duration >= MIN_DURATION_FOR_NORMALIZED_NUMBER_UPDATE_MS
+                                    && callType == Calls.OUTGOING_TYPE
+                                    && TextUtils.isEmpty(ci.normalizedNumber)) {
+                                updateNormalizedNumber(context, resolver, dataId, number);
+                            }
+                        }
+                    } finally {
+                        cursor.close();
+                    }
+                }
+            }
+
+            /// M: new feature:IP dial enhancement start @{
+            String ipPrefix = null;
+            if (tm != null) {
+                PhoneAccount phoneAccount = tm.getPhoneAccount(accountHandle);
+                int subId = TelephonyManager.from(context).getSubIdForPhoneAccount(phoneAccount);
+                ipPrefix = Settings.System.getString(resolver, "ipprefix" + subId);
+            }
+            if (null != ipPrefix && null != number && number.startsWith(ipPrefix)
+                    && !number.equals(ipPrefix) && callType == Calls.OUTGOING_TYPE) {
+                values.put(IP_PREFIX, ipPrefix);
+                String tmpNumber = number.substring(ipPrefix.length(), number.length());
+                values.put(NUMBER, tmpNumber);
+            }
+            /// @}
+
+            /// M: Add for Volte Conference call Calllog @{
+            values.put(CONFERENCE_CALL_ID, conferenceCallId);
+			values.put(IS_VOLTE_CALL, Integer.valueOf(isVolteCall));
+            ConferenceCalls.updateConferenceDurationIfNeeded(
+                                                             resolver,
+                                                             conferenceCallId,
+                                                             conferenceDuration);
+            /// @}
+
+            /*
+                Writing the calllog works in the following way:
+                - All user entries
+                    - if user-0 is encrypted, insert to user-0's shadow only.
+                      (other users should also be encrypted, so nothing to do for other users.)
+                    - if user-0 is decrypted, insert to user-0's real provider, as well as
+                      all other users that are running and decrypted and should have calllog.
+
+                - Single user entry.
+                    - If the target user is encryted, insert to its shadow.
+                    - Otherwise insert to its real provider.
+
+                When the (real) calllog provider starts, it copies entries that it missed from
+                elsewhere.
+                - When user-0's (real) provider starts, it copies from user-0's shadow, and clears
+                  the shadow.
+
+                - When other users (real) providers start, unless it shouldn't have calllog entries,
+                     - Copy from the user's shadow, and clears the shadow.
+                     - Copy from user-0's entries that are FOR_ALL_USERS = 1.  (and don't clear it.)
+             */
+
+            Uri result = null;
+
+            final UserManager userManager = context.getSystemService(UserManager.class);
+            final int currentUserId = userManager.getUserHandle();
+
+            if (addForAllUsers) {
+                // First, insert to the system user.
+                final Uri uriForSystem = addEntryAndRemoveExpiredEntries(
+                        context, userManager, UserHandle.SYSTEM, values);
+                if (uriForSystem == null
+                        || SHADOW_AUTHORITY.equals(uriForSystem.getAuthority())) {
+                    // This means the system user is still encrypted and the entry has inserted
+                    // into the shadow.  This means other users are still all encrypted.
+                    // Nothing further to do; just return null.
+                    return null;
+                }
+                if (UserHandle.USER_SYSTEM == currentUserId) {
+                    result = uriForSystem;
+                }
+
+                // Otherwise, insert to all other users that are running and unlocked.
+
+                final List<UserInfo> users = userManager.getUsers(true);
+
+                final int count = users.size();
+                for (int i = 0; i < count; i++) {
+                    final UserInfo userInfo = users.get(i);
+                    final UserHandle userHandle = userInfo.getUserHandle();
+                    final int userId = userHandle.getIdentifier();
+
+                    if (userHandle.isSystem()) {
+                        // Already written.
+                        continue;
+                    }
+
+                    if (!shouldHaveSharedCallLogEntries(context, userManager, userId)) {
+                        ///M: add log
+                        if (VERBOSE_LOG) {
+                            Log.v(LOG_TAG, "Shouldn't have calllog entries. userId=" + userId);
+                        }
+                        // Shouldn't have calllog entries.
+                        continue;
+                    }
+
+                    // For other users, we write only when they're running *and* decrypted.
+                    // Other providers will copy from the system user's real provider, when they
+                    // start.
+                    if (userManager.isUserRunning(userHandle)
+                            && userManager.isUserUnlocked(userHandle)) {
+                        final Uri uri = addEntryAndRemoveExpiredEntries(context, userManager,
+                                userHandle, values);
+                        if (userId == currentUserId) {
+                            result = uri;
+                        }
+                    }
+                }
+            } else {
+                // Single-user entry. Just write to that user, assuming it's running.  If the
+                // user is encrypted, we write to the shadow calllog.
+
+                final UserHandle targetUserHandle = userToBeInsertedTo != null
+                        ? userToBeInsertedTo
+                        : UserHandle.of(currentUserId);
+                result = addEntryAndRemoveExpiredEntries(context, userManager, targetUserHandle,
+                        values);
+            }
+            return result;
+        }
+
+        /** @hide */
+        public static boolean shouldHaveSharedCallLogEntries(Context context,
+                UserManager userManager, int userId) {
+            if (userManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS,
+                    UserHandle.of(userId))) {
+                return false;
+            }
+            final UserInfo userInfo = userManager.getUserInfo(userId);
+            return userInfo != null && !userInfo.isManagedProfile();
+        }
+
+        /**
+         * Query the call log database for the last dialed number.
+         * @param context Used to get the content resolver.
+         * @return The last phone number dialed (outgoing) or an empty
+         * string if none exist yet.
+         */
+        public static String getLastOutgoingCall(Context context) {
+            final ContentResolver resolver = context.getContentResolver();
+            Cursor c = null;
+            try {
+                c = resolver.query(
+                    CONTENT_URI,
+                    new String[] {NUMBER},
+                    TYPE + " = " + OUTGOING_TYPE,
+                    null,
+                    DEFAULT_SORT_ORDER + " LIMIT 1");
+                if (c == null || !c.moveToFirst()) {
+                    return "";
+                }
+                return c.getString(0);
+            } finally {
+                if (c != null) c.close();
+            }
+        }
+
+        private static Uri addEntryAndRemoveExpiredEntries(Context context, UserManager userManager,
+                UserHandle user, ContentValues values) {
+            final ContentResolver resolver = context.getContentResolver();
+
+            // Since we're doing this operation on behalf of an app, we only
+            // want to use the actual "unlocked" state.
+            final Uri uri = ContentProvider.maybeAddUserId(
+                    userManager.isUserUnlocked(user) ? CONTENT_URI : SHADOW_CONTENT_URI,
+                    user.getIdentifier());
+
+            if (VERBOSE_LOG) {
+                Log.v(LOG_TAG, String.format("Inserting to %s", uri));
+            }
+
+            try {
+                final Uri result = resolver.insert(uri, values);
+                ///M:add log
+                if (VERBOSE_LOG) {
+                    Log.v(LOG_TAG, String.format("Inserting result %s", result));
+                }
+                resolver.delete(uri, "_id IN " +
+                        "(SELECT _id FROM calls ORDER BY " + DEFAULT_SORT_ORDER
+                        + " LIMIT -1 OFFSET 500)", null);
+                return result;
+            } catch (IllegalArgumentException e) {
+                Log.w(LOG_TAG, "Failed to insert calllog", e);
+                // Even though we make sure the target user is running and decrypted before calling
+                // this method, there's a chance that the user just got shut down, in which case
+                // we'll still get "IllegalArgumentException: Unknown URL content://call_log/calls".
+                return null;
+            }
+        }
+
+        private static void updateDataUsageStatForData(ContentResolver resolver, String dataId) {
+            final Uri feedbackUri = DataUsageFeedback.FEEDBACK_URI.buildUpon()
+                    .appendPath(dataId)
+                    .appendQueryParameter(DataUsageFeedback.USAGE_TYPE,
+                                DataUsageFeedback.USAGE_TYPE_CALL)
+                    .build();
+            resolver.update(feedbackUri, new ContentValues(), null, null);
+        }
+
+        /*
+         * Update the normalized phone number for the given dataId in the ContactsProvider, based
+         * on the user's current country.
+         */
+        private static void updateNormalizedNumber(Context context, ContentResolver resolver,
+                String dataId, String number) {
+            if (TextUtils.isEmpty(number) || TextUtils.isEmpty(dataId)) {
+                return;
+            }
+            final String countryIso = getCurrentCountryIso(context);
+            if (TextUtils.isEmpty(countryIso)) {
+                return;
+            }
+            final String normalizedNumber = PhoneNumberUtils.formatNumberToE164(number,
+                    getCurrentCountryIso(context));
+            if (TextUtils.isEmpty(normalizedNumber)) {
+                return;
+            }
+            final ContentValues values = new ContentValues();
+            values.put(Phone.NORMALIZED_NUMBER, normalizedNumber);
+            resolver.update(Data.CONTENT_URI, values, Data._ID + "=?", new String[] {dataId});
+        }
+
+        private static String getCurrentCountryIso(Context context) {
+            String countryIso = null;
+            final CountryDetector detector = (CountryDetector) context.getSystemService(
+                    Context.COUNTRY_DETECTOR);
+            if (detector != null) {
+                final Country country = detector.detectCountry();
+                if (country != null) {
+                    countryIso = country.getCountryIso();
+                }
+            }
+            return countryIso;
+        }
+
+        /// M: Code added by Mediatek inc. @{
+        /**
+         * save call log corresponding phone number ID
+         * @hide
+         * @internal
+         */
+        public static final String DATA_ID = "data_id";
+
+        /**
+         * save raw contact id of a call log corresponding to phone number
+         * @hide
+         * @internal
+         */
+        public static final String RAW_CONTACT_ID = "raw_contact_id";
+
+        /**
+         * save IP prefix of a call log
+         * @hide
+         * @internal
+         */
+        public static final String IP_PREFIX = "ip_prefix";
+
+        /**
+         * save conference call id of a call log in a conference call
+         * @hide
+         */
+        public static final String CONFERENCE_CALL_ID = "conference_call_id";
+		public static final String IS_VOLTE_CALL = "is_volte_call";
+
+        /**
+         * the projection of calls date or conference call date
+         * @hide
+         */
+        public static final String SORT_DATE = "sort_date";
+
+       /**
+        * An opaque value that indicate contact store location.
+        * "-1", indicates phone contacts, others, indicate sim id of a sim contact
+        * @hide
+        */
+        public static final String CACHED_INDICATE_PHONE_SIM = "indicate_phone_or_sim_contact";
+
+        /**
+         * For SIM contact's flag, SDN's contacts value is 1,
+         * ADN's contacts value is 0 card.
+         * @hide
+         */
+        public static final String CACHED_IS_SDN_CONTACT = "is_sdn_contact";
+        /// @}
+    }
+
+    /// M: Code added by Mediatek inc. @{
+    /**
+     * Columns for conference calls table
+     * @hide
+     */
+    public static final class ConferenceCalls implements BaseColumns {
+        private ConferenceCalls() {
+        }
+
+        /**
+         * The content:// style URL for this table
+         * @hide
+         */
+        public static final Uri CONTENT_URI =
+                Uri.parse("content://call_log/conference_calls");
+
+        /**
+         * Save group id if the conference call is started from a contacts group
+         * @hide
+         */
+        public static final String GROUP_ID = "group_id";
+
+        /**
+         * Save conference call date, in milliseconds since the epoch
+         * @hide
+         */
+        public static final String CONFERENCE_DATE = "conference_date";
+
+        /**
+         * Conference call duration in seconds.
+         * @hide
+         */
+        public static final String CONFERENCE_DURATION = "conference_duration";
+
+        /**
+         * Update conference duration if the new value is greater.
+         * @param resolver ContentResolver instance
+         * @param id       Conference ID in database
+         * @param duration new duration value
+         */
+        public static void updateConferenceDurationIfNeeded(
+                                                            ContentResolver resolver,
+                                                            long id,
+                                                            int duration) {
+            Cursor cursor = null;
+            try {
+                cursor = resolver.query(
+                                        ConferenceCalls.CONTENT_URI,
+                                        new String[] { ConferenceCalls.CONFERENCE_DURATION },
+                                        ConferenceCalls._ID + "=?",
+                                        new String[] { String.valueOf(id)},
+                                        null);
+                if (cursor != null && cursor.getCount() > 0) {
+                    cursor.moveToFirst();
+                    int existingDuration = cursor.getInt(
+                                               cursor.getColumnIndexOrThrow(
+                                                   ConferenceCalls.CONFERENCE_DURATION));
+                    if (duration > existingDuration) {
+                        Log.v(LOG_TAG, "new: " + duration + ", old: " + existingDuration);
+                        ContentValues values = new ContentValues();
+                        values.put(ConferenceCalls.CONFERENCE_DURATION, duration);
+                        resolver.update(
+                            // We only support update on single ID for now
+                            ContentUris.withAppendedId(ConferenceCalls.CONTENT_URI, id),
+                            values,
+                            null,
+                            null);
+                    }
+                }
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+    }
+
+    /// @}
+}
Index: vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/mediatek/systemui/statusbar/networktype/NetworkTypeUtils.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/mediatek/systemui/statusbar/networktype/NetworkTypeUtils.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/mediatek/systemui/statusbar/networktype/NetworkTypeUtils.java	(revision 14847)
@@ -0,0 +1,102 @@
+
+package com.mediatek.systemui.statusbar.networktype;
+
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.systemui.R;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl.Config;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An utility class to access network type.
+ */
+public class NetworkTypeUtils {
+    private static final String TAG = "NetworkTypeUtils";
+
+    public static final int VOLTE_ICON = R.drawable.stat_sys_volte;
+	public static final int VOLTE_ICON_ACTIVE = R.drawable.stat_sys_volte_active;
+    public static final int WFC_ICON = R.drawable.stat_sys_wfc;
+
+
+    static final Map<Integer, Integer> sNetworkTypeIcons = new HashMap<Integer, Integer>() {
+        {
+            // For CDMA 3G
+            put(TelephonyManager.NETWORK_TYPE_EVDO_0, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_EVDO_A, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_EVDO_B, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_EHRPD, R.drawable.stat_sys_network_type_3g);
+            // For CDMA 1x
+            put(TelephonyManager.NETWORK_TYPE_CDMA, R.drawable.stat_sys_network_type_1x);
+            put(TelephonyManager.NETWORK_TYPE_1xRTT, R.drawable.stat_sys_network_type_1x);
+            // Edge
+            put(TelephonyManager.NETWORK_TYPE_EDGE, R.drawable.stat_sys_network_type_e);
+            // 3G
+            put(TelephonyManager.NETWORK_TYPE_UMTS, R.drawable.stat_sys_network_type_3g);
+            // For 4G
+            put(TelephonyManager.NETWORK_TYPE_LTE, R.drawable.stat_sys_network_type_4g);
+            // 3G
+            put(TelephonyManager.NETWORK_TYPE_HSDPA, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_HSUPA, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_HSPA, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_HSPAP, R.drawable.stat_sys_network_type_3g);
+            put(TelephonyManager.NETWORK_TYPE_IWLAN, 0);
+        }
+    };
+
+    /**
+     * Map the network type into the related icons.
+     * @param serviceState ServiceState to get current network type.
+     * @param config Config passed in.
+     * @param hasService true for in service.
+     * @return Network type's icon.
+     */
+    public static int getNetworkTypeIcon(ServiceState serviceState, Config config,
+            boolean hasService) {
+        if (!hasService) {
+            // Not in service, no network type.
+            return 0;
+        }
+        int tempNetworkType = getNetworkType(serviceState);
+
+        Integer iconId = sNetworkTypeIcons.get(tempNetworkType);
+        if (iconId == null) {
+            iconId = tempNetworkType == TelephonyManager.NETWORK_TYPE_UNKNOWN ? 0 :
+                     config.showAtLeast3G ? R.drawable.stat_sys_network_type_3g :
+                                            R.drawable.stat_sys_network_type_g;
+        }
+        Log.d(TAG, "getNetworkTypeIcon iconId = " + iconId);
+        return iconId.intValue();
+    }
+
+    private static int getNetworkType(ServiceState serviceState) {
+        int type = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        if (serviceState != null) {
+            type = serviceState.getDataNetworkType() != TelephonyManager.NETWORK_TYPE_UNKNOWN ?
+                    serviceState.getDataNetworkType() : serviceState.getVoiceNetworkType();
+        }
+        Log.d(TAG, "getNetworkType: type=" + type);
+        return type;
+    }
+
+    /// M: Support 4G+ icon" @{
+    public static int getDataNetTypeFromServiceState(int srcDataNetType, ServiceState sState){
+        int destDataNetType = srcDataNetType;
+        if (destDataNetType == TelephonyManager.NETWORK_TYPE_LTE
+               || destDataNetType == TelephonyManager.NETWORK_TYPE_LTEA) {
+            if (sState != null){
+                destDataNetType = (sState.getProprietaryDataRadioTechnology() == 0 ?
+                    TelephonyManager.NETWORK_TYPE_LTE : TelephonyManager.NETWORK_TYPE_LTEA);
+            }
+        }
+
+        Log.d(TAG, "getDataNetTypeFromServiceState:srcDataNetType = "
+            + srcDataNetType + ", destDataNetType " + destDataNetType);
+
+        return destDataNetType;
+    }
+    ///@}
+}
Index: vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
===================================================================
--- vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java	(revision 14847)
@@ -0,0 +1,901 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.systemui.statusbar.policy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.NetworkCapabilities;
+import android.os.Looper;
+import android.os.SystemProperties;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.ims.ImsManager;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsException;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.cdma.EriInfo;
+import com.android.systemui.R;
+import com.android.systemui.statusbar.policy.NetworkController.IconState;
+import com.android.systemui.statusbar.policy.NetworkController.SignalCallback;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl.Config;
+import com.android.systemui.statusbar.policy.NetworkControllerImpl.SubscriptionDefaults;
+import com.mediatek.systemui.ext.IMobileIconExt;
+import com.mediatek.systemui.ext.ISystemUIStatusBarExt;
+import com.mediatek.systemui.PluginManager;
+import com.mediatek.systemui.statusbar.networktype.NetworkTypeUtils;
+
+import com.mediatek.telephony.TelephonyManagerEx;
+
+import java.io.PrintWriter;
+import java.util.BitSet;
+import java.util.Objects;
+
+
+public class MobileSignalController extends SignalController<
+        MobileSignalController.MobileState, MobileSignalController.MobileIconGroup> {
+    private static final String TAG = "MobileSignalController";
+
+    private final TelephonyManager mPhone;
+    private final SubscriptionDefaults mDefaults;
+    private final String mNetworkNameDefault;
+    private final String mNetworkNameSeparator;
+    @VisibleForTesting
+    final PhoneStateListener mPhoneStateListener;
+    // Save entire info for logging, we only use the id.
+    /// M: Fix bug ALPS02416794
+    /*final*/ SubscriptionInfo mSubscriptionInfo;
+
+    // @VisibleForDemoMode
+    final SparseArray<MobileIconGroup> mNetworkToIconLookup;
+
+    // Since some pieces of the phone state are interdependent we store it locally,
+    // this could potentially become part of MobileState for simplification/complication
+    // of code.
+    private int mDataNetType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+    private int mDataState = TelephonyManager.DATA_DISCONNECTED;
+    private ServiceState mServiceState;
+    private SignalStrength mSignalStrength;
+    private MobileIconGroup mDefaultIcons;
+    private Config mConfig;
+
+    /// M: Add for Plugin feature. @ {
+    private IMobileIconExt mMobileIconExt;
+    private ISystemUIStatusBarExt mStatusBarExt;
+    /// @ }
+
+    // TODO: Reduce number of vars passed in, if we have the NetworkController, probably don't
+    // need listener lists anymore.
+    public MobileSignalController(Context context, Config config, boolean hasMobileData,
+            TelephonyManager phone, CallbackHandler callbackHandler,
+            NetworkControllerImpl networkController, SubscriptionInfo info,
+            SubscriptionDefaults defaults, Looper receiverLooper) {
+        super("MobileSignalController(" + info.getSubscriptionId() + ")", context,
+                NetworkCapabilities.TRANSPORT_CELLULAR, callbackHandler,
+                networkController);
+        mNetworkToIconLookup = new SparseArray<>();
+        mConfig = config;
+        mPhone = phone;
+        mDefaults = defaults;
+        mSubscriptionInfo = info;
+        /// M: Init plugin @ {
+        mMobileIconExt = PluginManager.getMobileIconExt(context);
+        mStatusBarExt = PluginManager.getSystemUIStatusBarExt(context);
+        /// @ }
+        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
+                receiverLooper);
+        mNetworkNameSeparator = getStringIfExists(R.string.status_bar_network_name_separator);
+        mNetworkNameDefault = getStringIfExists(
+                com.android.internal.R.string.lockscreen_carrier_default);
+
+        mapIconSets();
+
+        String networkName = info.getCarrierName() != null ? info.getCarrierName().toString()
+                : mNetworkNameDefault;
+        mLastState.networkName = mCurrentState.networkName = networkName;
+        mLastState.networkNameData = mCurrentState.networkNameData = networkName;
+        mLastState.enabled = mCurrentState.enabled = hasMobileData;
+        mLastState.iconGroup = mCurrentState.iconGroup = mDefaultIcons;
+        /// M: Support volte icon
+        initImsRegisterState();
+        // Get initial data sim state.
+        updateDataSim();
+    }
+
+    /// M: Support volte icon @{
+    private void initImsRegisterState(){
+        int phoneId = SubscriptionManager.getPhoneId(mSubscriptionInfo.getSubscriptionId());
+        try {
+            boolean imsRegStatus = ImsManager
+                    .getInstance(mContext, phoneId).getImsRegInfo();
+            mCurrentState.imsRegState = imsRegStatus
+                    ? ServiceState.STATE_IN_SERVICE : ServiceState.STATE_OUT_OF_SERVICE;
+            Log.d(mTag, "init imsRegState:" + mCurrentState.imsRegState
+                    + ",phoneId:" + phoneId);
+        } catch (ImsException ex) {
+            Log.e(mTag, "Fail to get Ims Status");
+        }
+    }
+    /// @}
+    public void setConfiguration(Config config) {
+        mConfig = config;
+        mapIconSets();
+        updateTelephony();
+    }
+
+    public int getDataContentDescription() {
+        return getIcons().mDataContentDescription;
+    }
+
+    public void setAirplaneMode(boolean airplaneMode) {
+        mCurrentState.airplaneMode = airplaneMode;
+        notifyListenersIfNecessary();
+    }
+
+    public void setUserSetupComplete(boolean userSetup) {
+        mCurrentState.userSetup = userSetup;
+        notifyListenersIfNecessary();
+    }
+
+    @Override
+    public void updateConnectivity(BitSet connectedTransports, BitSet validatedTransports) {
+        boolean isValidated = validatedTransports.get(mTransportType);
+        mCurrentState.isDefault =
+                connectedTransports.get(mTransportType) &&
+                // M: Add one more condition to judge whether the cellular connection is this subid
+                mNetworkController.isCellularConnected(mSubscriptionInfo.getSubscriptionId());
+
+        // Only show this as not having connectivity if we are default.
+        mCurrentState.inetCondition = (isValidated || !mCurrentState.isDefault) ? 1 : 0;
+        Log.d(mTag,"mCurrentState.inetCondition = " + mCurrentState.inetCondition);
+        /// M: Disable inetCondition check as this condition is not sufficient in some cases.
+        /// So always set it is in net with value 1. @ {
+        mCurrentState.inetCondition =
+                mMobileIconExt.customizeMobileNetCondition(1);
+        /// @}
+        notifyListenersIfNecessary();
+    }
+
+    public void setCarrierNetworkChangeMode(boolean carrierNetworkChangeMode) {
+        mCurrentState.carrierNetworkChangeMode = carrierNetworkChangeMode;
+        updateTelephony();
+    }
+
+    /**
+     * Start listening for phone state changes.
+     */
+    public void registerListener() {
+        mPhone.listen(mPhoneStateListener,
+                PhoneStateListener.LISTEN_SERVICE_STATE
+                        | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS
+                        | PhoneStateListener.LISTEN_CALL_STATE
+                        | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE
+                        | PhoneStateListener.LISTEN_DATA_ACTIVITY
+                        | PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE);
+        mStatusBarExt.registerOpStateListener();
+    }
+
+    /**
+     * Stop listening for phone state changes.
+     */
+    public void unregisterListener() {
+        mPhone.listen(mPhoneStateListener, 0);
+    }
+
+    /**
+     * Produce a mapping of data network types to icon groups for simple and quick use in
+     * updateTelephony.
+     */
+    private void mapIconSets() {
+        mNetworkToIconLookup.clear();
+
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
+
+        if (!mConfig.showAtLeast3G) {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN,
+                    TelephonyIcons.UNKNOWN);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
+
+            mDefaultIcons = TelephonyIcons.G;
+        } else {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA,
+                    TelephonyIcons.THREE_G);
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT,
+                    TelephonyIcons.THREE_G);
+            mDefaultIcons = TelephonyIcons.THREE_G;
+        }
+
+        MobileIconGroup hGroup = TelephonyIcons.THREE_G;
+        if (mConfig.hspaDataDistinguishable) {
+            hGroup = TelephonyIcons.H;
+        }
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
+
+        if (mConfig.show4gForLte) {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
+            if (mConfig.hideLtePlus) {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.FOUR_G);
+            } else {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.FOUR_G_PLUS);
+            }
+        } else {
+            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
+            if (mConfig.hideLtePlus) {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.LTE);
+            } else {
+                mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA,
+                        TelephonyIcons.LTE_PLUS);
+            }
+        }
+        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
+    }
+
+    @Override
+    public void notifyListeners(SignalCallback callback) {
+        MobileIconGroup icons = getIcons();
+
+        String contentDescription = getStringIfExists(getContentDescription());
+        String dataContentDescription = getStringIfExists(icons.mDataContentDescription);
+        final boolean dataDisabled = mCurrentState.iconGroup == TelephonyIcons.DATA_DISABLED
+                && mCurrentState.userSetup;
+
+        /// M: Customize the signal strength icon id. @ {
+        int iconId = getCurrentIconId();
+        iconId = mStatusBarExt.getCustomizeSignalStrengthIcon(
+                    mSubscriptionInfo.getSubscriptionId(),
+                    iconId,
+                    mSignalStrength,
+                    mDataNetType,
+                    mServiceState);
+        /// @ }
+
+        // Show icon in QS when we are connected or need to show roaming or data is disabled.
+        boolean showDataIcon = mCurrentState.dataConnected
+                || mCurrentState.iconGroup == TelephonyIcons.ROAMING
+                || dataDisabled;
+        IconState statusIcon = new IconState(mCurrentState.enabled && !mCurrentState.airplaneMode,
+                iconId, contentDescription);
+
+        int qsTypeIcon = 0;
+        IconState qsIcon = null;
+        String description = null;
+        // Only send data sim callbacks to QS.
+        if (mCurrentState.dataSim) {
+            qsTypeIcon = showDataIcon ? icons.mQsDataType : 0;
+            qsIcon = new IconState(mCurrentState.enabled
+                    && !mCurrentState.isEmergency, getQsCurrentIconId(), contentDescription);
+            description = mCurrentState.isEmergency ? null : mCurrentState.networkName;
+        }
+        boolean activityIn = mCurrentState.dataConnected
+                        && !mCurrentState.carrierNetworkChangeMode
+                        && mCurrentState.activityIn;
+        boolean activityOut = mCurrentState.dataConnected
+                        && !mCurrentState.carrierNetworkChangeMode
+                        && mCurrentState.activityOut;
+        showDataIcon &= mCurrentState.isDefault
+                || mCurrentState.iconGroup == TelephonyIcons.ROAMING
+                || dataDisabled;
+        int typeIcon = showDataIcon ? icons.mDataType : 0;
+        /** M: Support [Network Type on StatusBar], change the implement methods.
+          * Get the network icon base on service state.
+          * Add one more parameter for network type.
+          * @ { **/
+        int networkIcon = mCurrentState.networkIcon;
+
+        /// M: Support volte icon.Bug fix when airplane mode is on go to hide volte icon
+        int volteIcon = mCurrentState.airplaneMode && !isWfcEnable()
+                ? 0 : mCurrentState.volteIcon;
+
+        /// M: when data disabled, common show data icon as x, but op do not need show it @ {
+        mStatusBarExt.isDataDisabled(mSubscriptionInfo.getSubscriptionId(), dataDisabled);
+        /// @ }
+
+        /// M: Customize the data type icon id. @ {
+        typeIcon = mStatusBarExt.getDataTypeIcon(
+                        mSubscriptionInfo.getSubscriptionId(),
+                        typeIcon,
+                        mDataNetType,
+                        mCurrentState.dataConnected ? TelephonyManager.DATA_CONNECTED :
+                            TelephonyManager.DATA_DISCONNECTED,
+                        mServiceState);
+        /// @ }
+        /// M: Customize the network type icon id. @ {
+        networkIcon = mStatusBarExt.getNetworkTypeIcon(
+                        mSubscriptionInfo.getSubscriptionId(),
+                        networkIcon,
+                        mDataNetType,
+                        mServiceState);
+        /// @ }
+
+        callback.setMobileDataIndicators(statusIcon, qsIcon, typeIcon, networkIcon, volteIcon,
+                qsTypeIcon, activityIn, activityOut, dataContentDescription, description,
+                icons.mIsWide, mSubscriptionInfo.getSubscriptionId());
+        /** @ }*/
+
+        /// M: update plmn label @{
+        mNetworkController.refreshPlmnCarrierLabel();
+        /// @}
+    }
+
+    @Override
+    protected MobileState cleanState() {
+        return new MobileState();
+    }
+
+    private boolean hasService() {
+        if (mServiceState != null) {
+            // Consider the device to be in service if either voice or data
+            // service is available. Some SIM cards are marketed as data-only
+            // and do not support voice service, and on these SIM cards, we
+            // want to show signal bars for data service as well as the "no
+            // service" or "emergency calls only" text that indicates that voice
+            // is not available.
+            switch (mServiceState.getVoiceRegState()) {
+                case ServiceState.STATE_POWER_OFF:
+                    return false;
+                case ServiceState.STATE_OUT_OF_SERVICE:
+                case ServiceState.STATE_EMERGENCY_ONLY:
+                    return mServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+                default:
+                    return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isCdma() {
+        return (mSignalStrength != null) && !mSignalStrength.isGsm();
+    }
+
+    public boolean isEmergencyOnly() {
+        return (mServiceState != null && mServiceState.isEmergencyOnly());
+    }
+
+    private boolean isRoaming() {
+        if (isCdma()) {
+            /// M: fix ALPS02742814
+            if (mServiceState == null) {
+                return false;
+            }
+            final int iconMode = mServiceState.getCdmaEriIconMode();
+            return mServiceState != null
+                    && mServiceState.getCdmaEriIconIndex() != EriInfo.ROAMING_INDICATOR_OFF
+                    && (iconMode == EriInfo.ROAMING_ICON_MODE_NORMAL
+                        || iconMode == EriInfo.ROAMING_ICON_MODE_FLASH);
+        } else {
+            boolean isInRoaming =  mServiceState != null && mServiceState.getRoaming();
+            return mStatusBarExt.needShowRoamingIcons(isInRoaming);
+        }
+    }
+
+    /// M: Support VoLte @{
+    public boolean isLteNetWork() {
+        return (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE
+            || mDataNetType == TelephonyManager.NETWORK_TYPE_LTE_CA);
+    }
+    /// M: @}
+
+    private boolean isCarrierNetworkChangeActive() {
+        return mCurrentState.carrierNetworkChangeMode;
+    }
+
+    public void handleBroadcast(Intent intent) {
+        String action = intent.getAction();
+        if (action.equals(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION)) {
+            updateNetworkName(intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_SPN, false),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_SPN),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_DATA_SPN),
+                    intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_PLMN, false),
+                    intent.getStringExtra(TelephonyIntents.EXTRA_PLMN));
+            notifyListenersIfNecessary();
+        } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
+            updateDataSim();
+            notifyListenersIfNecessary();
+        } else if (action.equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+          /// M: support dual Ims. @{
+            handleImsAction(intent);
+            notifyListenersIfNecessary();
+            /// @}
+        }
+    }
+
+    /// M: Add for volte @{
+    private void handleImsAction(Intent intent){
+        mCurrentState.imsRegState = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY,
+                ServiceState.STATE_OUT_OF_SERVICE);
+        mCurrentState.imsCap = getImsEnableCap(intent);
+        mCurrentState.volteIcon = getVolteIcon();
+        /// M: add for disconnected volte feature. @{
+        mStatusBarExt.setImsRegInfo(mSubscriptionInfo.getSubscriptionId(),
+                mCurrentState.imsRegState, isImsOverWfc());
+        /// @}
+        Log.d(mTag, "handleImsAction imsRegstate=" + mCurrentState.imsRegState + ",imsCap = " +
+                mCurrentState.imsCap + ",volteIconId=" + mCurrentState.volteIcon);
+    }
+    private int getVolteIcon() {
+        int icon = 0;
+        if (isImsOverWfc()) {
+            boolean isNonSsProject
+                = !(SystemProperties.get("persist.radio.multisim.config", "ss").equals("ss"));
+            if (isNonSsProject) {
+                icon = NetworkTypeUtils.WFC_ICON;
+            }
+        } else if (isImsOverVoice() && isLteNetWork() &&
+            mCurrentState.imsRegState == ServiceState.STATE_IN_SERVICE) {
+            icon = NetworkTypeUtils.VOLTE_ICON_ACTIVE;
+        }
+        return icon;
+    }
+    private int getImsEnableCap(Intent intent) {
+        int cap = ImsConfig.FeatureConstants.FEATURE_TYPE_UNKNOWN;
+        boolean[] enabledFeatures =
+                intent.getBooleanArrayExtra(ImsManager.EXTRA_IMS_ENABLE_CAP_KEY);
+        if (enabledFeatures != null) {
+            if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI]) {
+                cap = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+            } else if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE]) {
+                cap = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+            }
+        }
+        return cap;
+    }
+    public boolean isImsOverWfc() {
+        return mCurrentState.imsCap == ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+    }
+    private boolean isImsOverVoice() {
+        return mCurrentState.imsCap == ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+    }
+
+    public boolean isWfcEnable() {
+        boolean isWfcEnabled = TelephonyManagerEx.getDefault().isWifiCallingEnabled(
+            mSubscriptionInfo.getSubscriptionId());
+        return isWfcEnabled;
+    }
+    /// @}
+
+    private void updateDataSim() {
+        int defaultDataSub = mDefaults.getDefaultDataSubId();
+        if (SubscriptionManager.isValidSubscriptionId(defaultDataSub)) {
+            mCurrentState.dataSim = defaultDataSub == mSubscriptionInfo.getSubscriptionId();
+        } else {
+            // There doesn't seem to be a data sim selected, however if
+            // there isn't a MobileSignalController with dataSim set, then
+            // QS won't get any callbacks and will be blank.  Instead
+            // lets just assume we are the data sim (which will basically
+            // show one at random) in QS until one is selected.  The user
+            // should pick one soon after, so we shouldn't be in this state
+            // for long.
+            mCurrentState.dataSim = true;
+        }
+    }
+
+    /**
+     * Updates the network's name based on incoming spn and plmn.
+     */
+    void updateNetworkName(boolean showSpn, String spn, String dataSpn,
+            boolean showPlmn, String plmn) {
+        if (CHATTY) {
+            Log.d("CarrierLabel", "updateNetworkName showSpn=" + showSpn
+                    + " spn=" + spn + " dataSpn=" + dataSpn
+                    + " showPlmn=" + showPlmn + " plmn=" + plmn);
+        }
+        StringBuilder str = new StringBuilder();
+        StringBuilder strData = new StringBuilder();
+        if (showPlmn && plmn != null) {
+            str.append(plmn);
+            strData.append(plmn);
+        }
+        if (showSpn && spn != null) {
+            if (str.length() != 0) {
+                str.append(mNetworkNameSeparator);
+            }
+            str.append(spn);
+        }
+        if (str.length() != 0) {
+            mCurrentState.networkName = str.toString();
+        } else {
+            mCurrentState.networkName = mNetworkNameDefault;
+        }
+        if (showSpn && dataSpn != null) {
+            if (strData.length() != 0) {
+                strData.append(mNetworkNameSeparator);
+            }
+            strData.append(dataSpn);
+        }
+
+        // M: ALPS02744648 for C2K, there isn't dataspn parameter, when no plmn
+        // and no dataspn, show spn instead "no service" here @{
+        if (strData.length() == 0 && showSpn && spn != null) {
+            Log.d("CarrierLabel", "show spn instead 'no service' here: " + spn);
+            strData.append(spn);
+        }
+        // @}
+
+        if (strData.length() != 0) {
+            mCurrentState.networkNameData = strData.toString();
+        } else {
+            mCurrentState.networkNameData = mNetworkNameDefault;
+        }
+    }
+
+    /**
+     * Updates the current state based on mServiceState, mSignalStrength, mDataNetType,
+     * mDataState, and mSimState.  It should be called any time one of these is updated.
+     * This will call listeners if necessary.
+     */
+    private final void updateTelephony() {
+        if (DEBUG) {
+            Log.d(mTag, "updateTelephonySignalStrength: hasService=" + hasService()
+                    + " ss=" + mSignalStrength);
+        }
+        mCurrentState.connected = hasService() && mSignalStrength != null;
+        handleIWLANNetwork();
+        if (mCurrentState.connected) {
+            if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
+                mCurrentState.level = mSignalStrength.getCdmaLevel();
+            } else {
+                mCurrentState.level = mSignalStrength.getLevel();
+            }
+            /// M: Customize the signal strength level. @ {
+            mCurrentState.level = mStatusBarExt.getCustomizeSignalStrengthLevel(
+                    mCurrentState.level, mSignalStrength, mServiceState);
+            /// @ }
+        }
+        if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
+            mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
+        } else {
+            mCurrentState.iconGroup = mDefaultIcons;
+        }
+        /// M: Add for data network type.
+        mCurrentState.dataNetType = mDataNetType;
+        mCurrentState.dataConnected = mCurrentState.connected
+                && mDataState == TelephonyManager.DATA_CONNECTED;
+        /// M: Add for op network tower type.
+        mCurrentState.customizedState = mStatusBarExt.getCustomizeCsState(mServiceState,
+                mCurrentState.customizedState);
+        /// M: Add for op signal strength tower icon.
+        mCurrentState.customizedSignalStrengthIcon = mStatusBarExt.getCustomizeSignalStrengthIcon(
+                mSubscriptionInfo.getSubscriptionId(),
+                mCurrentState.customizedSignalStrengthIcon,
+                mSignalStrength,
+                mDataNetType,
+                mServiceState);
+
+        if (isCarrierNetworkChangeActive()) {
+            mCurrentState.iconGroup = TelephonyIcons.CARRIER_NETWORK_CHANGE;
+        } else if (isRoaming()) {
+            /*
+            if (mCurrentState.iconGroup == TelephonyIcons.LTE ) {
+                mCurrentState.iconGroup = TelephonyIcons.LTE_R;
+            } else if (mCurrentState.iconGroup == TelephonyIcons.FOUR_G) {
+                mCurrentState.iconGroup = TelephonyIcons.FOUR_G_R;
+            } else if (mCurrentState.iconGroup == TelephonyIcons.H) {
+                mCurrentState.iconGroup = TelephonyIcons.H_PLUS_R;
+            } else if (mCurrentState.iconGroup == TelephonyIcons.THREE_G){
+                mCurrentState.iconGroup = TelephonyIcons.THREE_G_R;
+            } else if (mCurrentState.iconGroup == TelephonyIcons.E) {
+                mCurrentState.iconGroup = TelephonyIcons.E_R;
+            } else {
+                mCurrentState.iconGroup = TelephonyIcons.ROAMING;
+            }
+            */
+            if (mCurrentState.dataConnected) {
+                if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_GPRS ||
+                    mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_EDGE) {
+                    mCurrentState.iconGroup = TelephonyIcons.E_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_UMTS ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSPA ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSPAP) {
+                    mCurrentState.iconGroup = TelephonyIcons.THREE_G_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSDPA ||
+                        mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_HSUPA) {
+                    mCurrentState.iconGroup = TelephonyIcons.H_PLUS_R;
+                } else if (mCurrentState.dataNetType == TelephonyManager.NETWORK_TYPE_LTE) {
+                    mCurrentState.iconGroup = TelephonyIcons.FOUR_G_R;
+                }
+            } else {
+                mCurrentState.iconGroup = TelephonyIcons.ROAMING;
+            }
+        } else if (isDataDisabled()) {
+            mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
+        }
+        if (isEmergencyOnly() != mCurrentState.isEmergency) {
+            mCurrentState.isEmergency = isEmergencyOnly();
+            mNetworkController.recalculateEmergency();
+        }
+        // Fill in the network name if we think we have it.
+        if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null
+                && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
+            mCurrentState.networkName = mServiceState.getOperatorAlphaShort();
+        }
+        /// M: For network type big icon.
+        mCurrentState.networkIcon =
+            NetworkTypeUtils.getNetworkTypeIcon(mServiceState, mConfig, hasService());
+        /// M: For volte type icon.
+        mCurrentState.volteIcon = getVolteIcon();
+
+        notifyListenersIfNecessary();
+    }
+
+    private boolean isDataDisabled() {
+        return !mPhone.getDataEnabled(mSubscriptionInfo.getSubscriptionId());
+    }
+
+    /// M: bug fix for ALPS02603527.
+    /** IWLAN is special case in which the transmission via WIFI, no need cellular network, then
+    whenever PS type is IWLAN, cellular network is not connected. However, in special case, CS may
+    still connect under IWLAN with valid network type.
+    **/
+     private void handleIWLANNetwork() {
+        /// M: fix ALPS02742814
+        if (mCurrentState.connected && mServiceState != null &&
+            mServiceState.getDataNetworkType() == TelephonyManager.NETWORK_TYPE_IWLAN &&
+            mServiceState.getVoiceNetworkType() == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
+            Log.d(mTag,"Current is IWLAN network only, no cellular network available");
+            mCurrentState.connected = false;
+        }
+        /// M: Add for plugin wifi-only mode.
+        mCurrentState.connected = mStatusBarExt.updateSignalStrengthWifiOnlyMode(
+            mServiceState, mCurrentState.connected);
+    }
+
+    @VisibleForTesting
+    void setActivity(int activity) {
+        mCurrentState.activityIn = activity == TelephonyManager.DATA_ACTIVITY_INOUT
+                || activity == TelephonyManager.DATA_ACTIVITY_IN;
+        mCurrentState.activityOut = activity == TelephonyManager.DATA_ACTIVITY_INOUT
+                || activity == TelephonyManager.DATA_ACTIVITY_OUT;
+        notifyListenersIfNecessary();
+    }
+
+    @Override
+    public void dump(PrintWriter pw) {
+        super.dump(pw);
+        pw.println("  mSubscription=" + mSubscriptionInfo + ",");
+        pw.println("  mServiceState=" + mServiceState + ",");
+        pw.println("  mSignalStrength=" + mSignalStrength + ",");
+        pw.println("  mDataState=" + mDataState + ",");
+        pw.println("  mDataNetType=" + mDataNetType + ",");
+    }
+
+    class MobilePhoneStateListener extends PhoneStateListener {
+        public MobilePhoneStateListener(int subId, Looper looper) {
+            super(subId, looper);
+        }
+
+        @Override
+        public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+            if (DEBUG) {
+                Log.d(mTag, "onSignalStrengthsChanged signalStrength=" + signalStrength +
+                        ((signalStrength == null) ? "" : (" level=" + signalStrength.getLevel())));
+            }
+            mSignalStrength = signalStrength;
+            updateTelephony();
+        }
+
+        @Override
+        public void onServiceStateChanged(ServiceState state) {
+            if (DEBUG) {
+                Log.d(mTag, "onServiceStateChanged voiceState=" + state.getVoiceRegState()
+                        + " dataState=" + state.getDataRegState());
+            }
+            mServiceState = state;
+            mDataNetType = state.getDataNetworkType();
+            //TODO:: Double check with FWK
+            if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null &&
+                    mServiceState.isUsingCarrierAggregation()) {
+                mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
+            }
+            updateTelephony();
+        }
+
+        @Override
+        public void onDataConnectionStateChanged(int state, int networkType) {
+            if (DEBUG) {
+                Log.d(mTag, "onDataConnectionStateChanged: state=" + state
+                        + " type=" + networkType);
+            }
+            mDataState = state;
+            mDataNetType = networkType;
+            //TODO:: Double check with FWK
+            if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null &&
+                    mServiceState.isUsingCarrierAggregation()) {
+                mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
+            }
+            updateTelephony();
+        }
+
+        @Override
+        public void onDataActivity(int direction) {
+            if (DEBUG) {
+                Log.d(mTag, "onDataActivity: direction=" + direction);
+            }
+            setActivity(direction);
+        }
+
+        @Override
+        public void onCarrierNetworkChange(boolean active) {
+            if (DEBUG) {
+                Log.d(mTag, "onCarrierNetworkChange: active=" + active);
+            }
+            mCurrentState.carrierNetworkChangeMode = active;
+
+            updateTelephony();
+        }
+    };
+
+    static class MobileIconGroup extends SignalController.IconGroup {
+        final int mDataContentDescription; // mContentDescriptionDataType
+        final int mDataType;
+        final boolean mIsWide;
+        final int mQsDataType;
+
+        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
+                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
+                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
+                int qsDataType) {
+            super(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
+                    qsDiscState, discContentDesc);
+            mDataContentDescription = dataContentDesc;
+            mDataType = dataType;
+            mIsWide = isWide;
+            mQsDataType = qsDataType;
+        }
+    }
+
+    static class MobileState extends SignalController.State {
+        String networkName;
+        String networkNameData;
+        boolean dataSim;
+        boolean dataConnected;
+        boolean isEmergency;
+        boolean airplaneMode;
+        boolean carrierNetworkChangeMode;
+        boolean isDefault;
+        boolean userSetup;
+
+        /// M: For network type big icon.
+        int networkIcon;
+        /// M: Add for data network type.
+        int dataNetType;
+        /// M: Add for op network tower type.
+        int customizedState;
+        /// M: Add for op signal strength tower icon.
+        int customizedSignalStrengthIcon;
+        /// M: Add for volte @{
+        int imsRegState = ServiceState.STATE_POWER_OFF;
+        int imsCap;
+        int volteIcon;
+        /// @}
+        @Override
+        public void copyFrom(State s) {
+            super.copyFrom(s);
+            MobileState state = (MobileState) s;
+            dataSim = state.dataSim;
+            networkName = state.networkName;
+            networkNameData = state.networkNameData;
+            dataConnected = state.dataConnected;
+            isDefault = state.isDefault;
+            isEmergency = state.isEmergency;
+            airplaneMode = state.airplaneMode;
+            carrierNetworkChangeMode = state.carrierNetworkChangeMode;
+            userSetup = state.userSetup;
+
+            /// M: For network type big icon.
+            networkIcon = state.networkIcon;
+            /// M: Add for data network type.
+            dataNetType = state.dataNetType;
+            /// M: Add for op network tower type.
+            customizedState = state.customizedState;
+            /// M: Add for op signal strength tower icon.
+            customizedSignalStrengthIcon = state.customizedSignalStrengthIcon;
+            /// M: Add for volte
+            imsRegState = state.imsRegState;
+            imsCap = state.imsCap;
+            volteIcon = state.volteIcon;
+        }
+
+        @Override
+        protected void toString(StringBuilder builder) {
+            super.toString(builder);
+            builder.append(',');
+            builder.append("dataSim=").append(dataSim).append(',');
+            builder.append("networkName=").append(networkName).append(',');
+            builder.append("networkNameData=").append(networkNameData).append(',');
+            builder.append("dataConnected=").append(dataConnected).append(',');
+            builder.append("isDefault=").append(isDefault).append(',');
+            builder.append("isEmergency=").append(isEmergency).append(',');
+            builder.append("airplaneMode=").append(airplaneMode).append(',');
+            builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode)
+                    .append(',');
+            builder.append("userSetup=").append(userSetup);
+
+            /// M: For network type big icon.
+            builder.append("networkIcon").append(networkIcon).append(',');
+            /// M: Add for data network type.
+            builder.append("dataNetType").append(dataNetType).append(',');
+            /// M: Add for op network tower type.
+            builder.append("customizedState").append(customizedState).append(',');
+            /// M: Add for op signal strength tower icon.
+            builder.append("customizedSignalStrengthIcon").append(customizedSignalStrengthIcon)
+                    .append(',');
+            /// M: Add for volte.
+            builder.append("imsRegState=").append(imsRegState).append(',');
+            builder.append("imsCap=").append(imsCap).append(',');
+            builder.append("volteIconId=").append(volteIcon).append(',');
+            builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return super.equals(o)
+                    && Objects.equals(((MobileState) o).networkName, networkName)
+                    && Objects.equals(((MobileState) o).networkNameData, networkNameData)
+                    && ((MobileState) o).dataSim == dataSim
+                    && ((MobileState) o).dataConnected == dataConnected
+                    && ((MobileState) o).isEmergency == isEmergency
+                    && ((MobileState) o).airplaneMode == airplaneMode
+                    && ((MobileState) o).carrierNetworkChangeMode == carrierNetworkChangeMode
+                    /// M: For network type big icon.
+                    && ((MobileState) o).networkIcon == networkIcon
+                    && ((MobileState) o).volteIcon == volteIcon
+                    /// M: Add for data network type.
+                    && ((MobileState) o).dataNetType == dataNetType
+                    /// M: Add for op network tower type.
+                    && ((MobileState) o).customizedState == customizedState
+                    /// M: Add for op signal strength tower icon.
+                    && ((MobileState) o).customizedSignalStrengthIcon ==
+                                             customizedSignalStrengthIcon
+                    && ((MobileState) o).userSetup == userSetup
+                    && ((MobileState) o).isDefault == isDefault;
+        }
+    }
+
+    /// M: Support for PLMN. @{
+    public SubscriptionInfo getControllerSubInfo() {
+        return mSubscriptionInfo;
+    }
+
+    public boolean getControllserHasService() {
+        return hasService();
+    }
+    /// M: Support for PLMN. @}
+}
Index: vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/res_ext/drawable-xxhdpi/stat_sys_volte_active.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/res_ext/drawable-xxhdpi/stat_sys_volte_active.png
===================================================================
--- vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/res_ext/drawable-xxhdpi/stat_sys_volte_active.png	(revision 0)
+++ vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/res_ext/drawable-xxhdpi/stat_sys_volte_active.png	(revision 14847)

Property changes on: vendor/branch/5058A_Claro_Peru/frameworks/base/packages/SystemUI/res_ext/drawable-xxhdpi/stat_sys_volte_active.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
