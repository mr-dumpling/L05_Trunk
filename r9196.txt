Index: vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberBackupAgent.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberBackupAgent.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberBackupAgent.java	(revision 9196)
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.providers.blockednumber;
+
+import android.annotation.Nullable;
+import android.app.backup.BackupAgent;
+import android.app.backup.BackupDataInput;
+import android.app.backup.BackupDataOutput;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.os.ParcelFileDescriptor;
+import android.provider.BlockedNumberContract;
+import android.util.Log;
+
+import libcore.io.IoUtils;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+/**
+ * A backup agent to enable backup and restore of blocked numbers.
+ */
+public class BlockedNumberBackupAgent extends BackupAgent {
+    private static final String[] BLOCKED_NUMBERS_PROJECTION = new String[] {
+            BlockedNumberContract.BlockedNumbers.COLUMN_ID,
+            BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER,
+            BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER,
+    };
+    private static final String TAG = "BlockedNumberBackup";
+    private static final int VERSION = 1;
+    private static final boolean DEBUG = false; // DO NOT SUBMIT WITH TRUE.
+
+    @Override
+    public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput backupDataOutput,
+                         ParcelFileDescriptor newState) throws IOException {
+        logV("Backing up blocked numbers.");
+
+        DataInputStream dataInputStream =
+                new DataInputStream(new FileInputStream(oldState.getFileDescriptor()));
+        final BackupState state;
+        try {
+            state = readState(dataInputStream);
+        } finally {
+            IoUtils.closeQuietly(dataInputStream);
+        }
+
+        runBackup(state, backupDataOutput, getAllBlockedNumbers());
+
+        DataOutputStream dataOutputStream =
+                new DataOutputStream(new FileOutputStream(newState.getFileDescriptor()));
+        try {
+            writeNewState(dataOutputStream, state);
+        } finally {
+            dataOutputStream.close();
+        }
+    }
+
+    @Override
+    public void onRestore(BackupDataInput data, int appVersionCode,
+                          ParcelFileDescriptor newState) throws IOException {
+        logV("Restoring blocked numbers.");
+
+        while (data.readNextHeader()) {
+            BackedUpBlockedNumber blockedNumber = readBlockedNumberFromData(data);
+            if (blockedNumber != null) {
+                writeToProvider(blockedNumber);
+            }
+        }
+    }
+
+    private BackupState readState(DataInputStream dataInputStream) throws IOException {
+        int version = VERSION;
+        if (dataInputStream.available() > 0) {
+            version = dataInputStream.readInt();
+        }
+        BackupState state = new BackupState(version, new TreeSet<Integer>());
+        while (dataInputStream.available() > 0) {
+            state.ids.add(dataInputStream.readInt());
+        }
+        return state;
+    }
+
+    private void runBackup(BackupState state, BackupDataOutput backupDataOutput,
+                           Iterable<BackedUpBlockedNumber> allBlockedNumbers) throws IOException {
+        SortedSet<Integer> deletedBlockedNumbers = new TreeSet<>(state.ids);
+
+        for (BackedUpBlockedNumber blockedNumber : allBlockedNumbers) {
+            if (state.ids.contains(blockedNumber.id)) {
+                // Existing blocked number: do not delete.
+                deletedBlockedNumbers.remove(blockedNumber.id);
+            } else {
+                logV("Adding blocked number to backup: " + blockedNumber);
+                // New blocked number
+                addToBackup(backupDataOutput, blockedNumber);
+                state.ids.add(blockedNumber.id);
+            }
+        }
+
+        for (int id : deletedBlockedNumbers) {
+            logV("Removing blocked number from backup: " + id);
+            removeFromBackup(backupDataOutput, id);
+            state.ids.remove(id);
+        }
+    }
+
+    private void addToBackup(BackupDataOutput output, BackedUpBlockedNumber blockedNumber)
+            throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        DataOutputStream dataOutputStream = new DataOutputStream(outputStream);
+        dataOutputStream.writeInt(VERSION);
+        writeString(dataOutputStream, blockedNumber.originalNumber);
+        writeString(dataOutputStream, blockedNumber.e164Number);
+        dataOutputStream.flush();
+
+        output.writeEntityHeader(Integer.toString(blockedNumber.id), outputStream.size());
+        output.writeEntityData(outputStream.toByteArray(), outputStream.size());
+    }
+
+    private void writeString(DataOutputStream dataOutputStream, @Nullable String value)
+            throws IOException {
+        if (value == null) {
+            dataOutputStream.writeBoolean(false);
+        } else {
+            dataOutputStream.writeBoolean(true);
+            dataOutputStream.writeUTF(value);
+        }
+    }
+
+    @Nullable
+    private String readString(DataInputStream dataInputStream)
+            throws IOException {
+        if (dataInputStream.readBoolean()) {
+            return dataInputStream.readUTF();
+        } else {
+            return null;
+        }
+    }
+
+    private void removeFromBackup(BackupDataOutput output, int id) throws IOException {
+        output.writeEntityHeader(Integer.toString(id), -1);
+    }
+
+    private Iterable<BackedUpBlockedNumber> getAllBlockedNumbers() {
+        List<BackedUpBlockedNumber> blockedNumbers = new ArrayList<>();
+        ContentResolver resolver = getContentResolver();
+        Cursor cursor = resolver.query(
+                BlockedNumberContract.BlockedNumbers.CONTENT_URI, BLOCKED_NUMBERS_PROJECTION, null,
+                null, null);
+        if (cursor != null) {
+            try {
+                while (cursor.moveToNext()) {
+                    blockedNumbers.add(createBlockedNumberFromCursor(cursor));
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return blockedNumbers;
+    }
+
+    private BackedUpBlockedNumber createBlockedNumberFromCursor(Cursor cursor) {
+        return new BackedUpBlockedNumber(
+                cursor.getInt(0), cursor.getString(1), cursor.getString(2));
+    }
+
+    private void writeNewState(DataOutputStream dataOutputStream, BackupState state)
+            throws IOException {
+        dataOutputStream.writeInt(VERSION);
+        for (int i : state.ids) {
+            dataOutputStream.writeInt(i);
+        }
+    }
+
+    @Nullable
+    private BackedUpBlockedNumber readBlockedNumberFromData(BackupDataInput data) {
+        int id;
+        try {
+            id = Integer.parseInt(data.getKey());
+        } catch (NumberFormatException e) {
+            Log.e(TAG, "Unexpected key found in restore: " + data.getKey());
+            return null;
+        }
+
+        try {
+            byte[] byteArray = new byte[data.getDataSize()];
+            data.readEntityData(byteArray, 0, byteArray.length);
+            DataInputStream dataInput = new DataInputStream(new ByteArrayInputStream(byteArray));
+            dataInput.readInt(); // Ignore version.
+            BackedUpBlockedNumber blockedNumber =
+                    new BackedUpBlockedNumber(id, readString(dataInput), readString(dataInput));
+            logV("Restoring blocked number: " + blockedNumber);
+            return blockedNumber;
+        } catch (IOException e) {
+            Log.e(TAG, "Error reading blocked number for: " + id + ": " + e.getMessage());
+            return null;
+        }
+    }
+
+    private void writeToProvider(BackedUpBlockedNumber blockedNumber) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER,
+                blockedNumber.originalNumber);
+        contentValues.put(BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER,
+                blockedNumber.e164Number);
+        try {
+            getContentResolver().insert(
+                    BlockedNumberContract.BlockedNumbers.CONTENT_URI, contentValues);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to insert blocked number " + blockedNumber + " :" + e.getMessage());
+        }
+    }
+
+    private static boolean isDebug() {
+        return Log.isLoggable(TAG, Log.DEBUG);
+    }
+
+    private static void logV(String msg) {
+        if (DEBUG) {
+            Log.v(TAG, msg);
+        }
+    }
+
+    private static class BackupState {
+        final int version;
+        final SortedSet<Integer> ids;
+
+        BackupState(int version, SortedSet<Integer> ids) {
+            this.version = version;
+            this.ids = ids;
+        }
+    }
+
+    private static class BackedUpBlockedNumber {
+        final int id;
+        final String originalNumber;
+        final String e164Number;
+
+        BackedUpBlockedNumber(int id, String originalNumber, String e164Number) {
+            this.id = id;
+            this.originalNumber = originalNumber;
+            this.e164Number = e164Number;
+        }
+
+        @Override
+        public String toString() {
+            if (isDebug()) {
+                return String.format("[%d, original number: %s, e164 number: %s]",
+                        id, originalNumber, e164Number);
+            } else {
+                return String.format("[%d]", id);
+            }
+        }
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberDatabaseHelper.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberDatabaseHelper.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberDatabaseHelper.java	(revision 9196)
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.providers.blockednumber;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.provider.BlockedNumberContract.BlockedNumbers;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.util.Preconditions;
+
+public class BlockedNumberDatabaseHelper {
+    private static final int DATABASE_VERSION = 2;
+
+    private static final String DATABASE_NAME = "blockednumbers.db";
+
+    private static BlockedNumberDatabaseHelper sInstance;
+
+    private final Context mContext;
+
+    private final OpenHelper mOpenHelper;
+
+    public interface Tables {
+        String BLOCKED_NUMBERS = "blocked";
+    }
+
+    private static final class OpenHelper extends SQLiteOpenHelper {
+        public OpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,
+                          int version) {
+            super(context, name, factory, version);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            createTables(db);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            if (oldVersion < 2) {
+                db.execSQL("DROP TABLE IF EXISTS blocked");
+                createTables(db);
+            }
+        }
+
+        private void createTables(SQLiteDatabase db) {
+            db.execSQL("CREATE TABLE " + Tables.BLOCKED_NUMBERS + " (" +
+                    BlockedNumbers.COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+                    BlockedNumbers.COLUMN_ORIGINAL_NUMBER + " TEXT NOT NULL UNIQUE," +
+                    BlockedNumbers.COLUMN_E164_NUMBER + " TEXT" +
+                    ")");
+
+            db.execSQL("CREATE INDEX blocked_number_idx_original ON " + Tables.BLOCKED_NUMBERS +
+                    " (" + BlockedNumbers.COLUMN_ORIGINAL_NUMBER + ");");
+            db.execSQL("CREATE INDEX blocked_number_idx_e164 ON " + Tables.BLOCKED_NUMBERS + " (" +
+                    BlockedNumbers.COLUMN_E164_NUMBER +
+                    ");");
+        }
+    }
+
+    @VisibleForTesting
+    public static BlockedNumberDatabaseHelper newInstanceForTest(Context context) {
+        return new BlockedNumberDatabaseHelper(context, /* instanceIsForTesting =*/ true);
+    }
+
+    private BlockedNumberDatabaseHelper(Context context, boolean instanceIsForTesting) {
+        Preconditions.checkNotNull(context);
+        mContext = context;
+        mOpenHelper = new OpenHelper(mContext,
+                instanceIsForTesting ? null : DATABASE_NAME, null, DATABASE_VERSION);
+    }
+
+    public static synchronized BlockedNumberDatabaseHelper getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new BlockedNumberDatabaseHelper(
+                    context,
+                    /* instanceIsForTesting = */ false);
+        }
+        return sInstance;
+    }
+
+    public SQLiteDatabase getReadableDatabase() {
+        return mOpenHelper.getReadableDatabase();
+    }
+
+    public SQLiteDatabase getWritableDatabase() {
+        return mOpenHelper.getWritableDatabase();
+    }
+
+    public void wipeForTest() {
+        getWritableDatabase().execSQL("DELETE FROM " + Tables.BLOCKED_NUMBERS);
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberProvider.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberProvider.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/providers/BlockedNumberProvider/src/com/android/providers/blockednumber/BlockedNumberProvider.java	(revision 9196)
@@ -0,0 +1,574 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.providers.blockednumber;
+
+import android.Manifest;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.AppOpsManager;
+import android.app.backup.BackupManager;
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.UriMatcher;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.os.Process;
+import android.os.UserManager;
+import android.provider.BlockedNumberContract;
+import android.provider.BlockedNumberContract.SystemContract;
+import android.telecom.TelecomManager;
+import android.telephony.CarrierConfigManager;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.common.content.ProjectionMap;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.providers.blockednumber.BlockedNumberDatabaseHelper.Tables;
+
+import java.util.Arrays;
+
+/**
+ * Blocked phone number provider.
+ *
+ * <p>Note the provider allows emergency numbers.  The caller (telecom) should never call it with
+ * emergency numbers.
+ */
+public class BlockedNumberProvider extends ContentProvider {
+    static final String TAG = "BlockedNumbers";
+
+    private static final boolean DEBUG = false; // DO NOT SUBMIT WITH TRUE.
+
+    private static final int BLOCKED_LIST = 1000;
+    private static final int BLOCKED_ID = 1001;
+
+    private static final UriMatcher sUriMatcher;
+
+    private static final String PREF_FILE = "block_number_provider_prefs";
+    private static final String BLOCK_SUPPRESSION_EXPIRY_TIME_PREF =
+            "block_suppression_expiry_time_pref";
+    private static final int MAX_BLOCKING_DISABLED_DURATION_SECONDS = 7 * 24 * 3600; // 1 week
+    // Normally, we allow calls from self, *except* in unit tests, where we clear this flag
+    // to emulate calls from other apps.
+    @VisibleForTesting
+    static boolean ALLOW_SELF_CALL = true;
+
+    static {
+        sUriMatcher = new UriMatcher(0);
+        sUriMatcher.addURI(BlockedNumberContract.AUTHORITY, "blocked", BLOCKED_LIST);
+        sUriMatcher.addURI(BlockedNumberContract.AUTHORITY, "blocked/#", BLOCKED_ID);
+    }
+
+    private static final ProjectionMap sBlockedNumberColumns = ProjectionMap.builder()
+            .add(BlockedNumberContract.BlockedNumbers.COLUMN_ID)
+            .add(BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER)
+            .add(BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER)
+            .build();
+
+    private static final String ID_SELECTION =
+            BlockedNumberContract.BlockedNumbers.COLUMN_ID + "=?";
+
+    private static final String ORIGINAL_NUMBER_SELECTION =
+            BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER + "=?";
+
+    private static final String E164_NUMBER_SELECTION =
+            BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER + "=?";
+
+    @VisibleForTesting
+    protected BlockedNumberDatabaseHelper mDbHelper;
+    @VisibleForTesting
+    protected BackupManager mBackupManager;
+
+    @Override
+    public boolean onCreate() {
+        mDbHelper = BlockedNumberDatabaseHelper.getInstance(getContext());
+        mBackupManager = new BackupManager(getContext());
+        return true;
+    }
+
+    @Override
+    public String getType(@NonNull Uri uri) {
+        final int match = sUriMatcher.match(uri);
+        switch (match) {
+            case BLOCKED_LIST:
+                return BlockedNumberContract.BlockedNumbers.CONTENT_TYPE;
+            case BLOCKED_ID:
+                return BlockedNumberContract.BlockedNumbers.CONTENT_ITEM_TYPE;
+            default:
+                throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+    }
+
+    @Override
+    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
+        enforceWritePermissionAndPrimaryUser();
+
+        final int match = sUriMatcher.match(uri);
+        switch (match) {
+            case BLOCKED_LIST:
+                Uri blockedUri = insertBlockedNumber(values);
+                getContext().getContentResolver().notifyChange(blockedUri, null);
+                mBackupManager.dataChanged();
+                return blockedUri;
+            default:
+                throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+    }
+
+    /**
+     * Implements the "blocked/" insert.
+     */
+    private Uri insertBlockedNumber(ContentValues cv) {
+        throwIfSpecified(cv, BlockedNumberContract.BlockedNumbers.COLUMN_ID);
+
+        final String phoneNumber = cv.getAsString(
+                BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER);
+
+        if (TextUtils.isEmpty(phoneNumber)) {
+            throw new IllegalArgumentException("Missing a required column " +
+                    BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER);
+        }
+
+        // Fill in with autogenerated columns.
+        final String e164Number = Utils.getE164Number(getContext(), phoneNumber,
+                cv.getAsString(BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER));
+        cv.put(BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER, e164Number);
+
+        if (DEBUG) {
+            Log.d(TAG, String.format("inserted blocked number: %s", cv));
+        }
+
+        // Then insert.
+        final long id = mDbHelper.getWritableDatabase().insertWithOnConflict(
+                BlockedNumberDatabaseHelper.Tables.BLOCKED_NUMBERS, null, cv,
+                SQLiteDatabase.CONFLICT_REPLACE);
+
+        return ContentUris.withAppendedId(BlockedNumberContract.BlockedNumbers.CONTENT_URI, id);
+    }
+
+    private static void throwIfSpecified(ContentValues cv, String column) {
+        if (cv.containsKey(column)) {
+            throw new IllegalArgumentException("Column " + column + " must not be specified");
+        }
+    }
+
+    @Override
+    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection,
+            @Nullable String[] selectionArgs) {
+        enforceWritePermissionAndPrimaryUser();
+
+        throw new UnsupportedOperationException(
+                "Update is not supported.  Use delete + insert instead");
+    }
+
+    @Override
+    public int delete(@NonNull Uri uri, @Nullable String selection,
+            @Nullable String[] selectionArgs) {
+        enforceWritePermissionAndPrimaryUser();
+
+        final int match = sUriMatcher.match(uri);
+        int numRows;
+        switch (match) {
+            case BLOCKED_LIST:
+                numRows = deleteBlockedNumber(selection, selectionArgs);
+                break;
+            case BLOCKED_ID:
+                numRows = deleteBlockedNumberWithId(ContentUris.parseId(uri), selection);
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+        mBackupManager.dataChanged();
+        return numRows;
+    }
+
+    /**
+     * Implements the "blocked/#" delete.
+     */
+    private int deleteBlockedNumberWithId(long id, String selection) {
+        throwForNonEmptySelection(selection);
+
+        return deleteBlockedNumber(ID_SELECTION, new String[]{Long.toString(id)});
+    }
+
+    /**
+     * Implements the "blocked/" delete.
+     */
+    private int deleteBlockedNumber(String selection, String[] selectionArgs) {
+        final SQLiteDatabase db = mDbHelper.getWritableDatabase();
+
+        // When selection is specified, compile it within (...) to detect SQL injection.
+        if (!TextUtils.isEmpty(selection)) {
+            db.validateSql("select 1 FROM " + Tables.BLOCKED_NUMBERS + " WHERE " +
+                    Utils.wrapSelectionWithParens(selection),
+                    /* cancellationSignal =*/ null);
+        }
+
+        return db.delete(
+                BlockedNumberDatabaseHelper.Tables.BLOCKED_NUMBERS,
+                selection, selectionArgs);
+    }
+
+    @Override
+    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection,
+            @Nullable String[] selectionArgs, @Nullable String sortOrder) {
+        enforceReadPermissionAndPrimaryUser();
+
+        return query(uri, projection, selection, selectionArgs, sortOrder, null);
+    }
+
+    @Override
+    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection,
+            @Nullable String[] selectionArgs, @Nullable String sortOrder,
+            @Nullable CancellationSignal cancellationSignal) {
+        enforceReadPermissionAndPrimaryUser();
+
+        final int match = sUriMatcher.match(uri);
+        Cursor cursor;
+        switch (match) {
+            case BLOCKED_LIST:
+                cursor = queryBlockedList(projection, selection, selectionArgs, sortOrder,
+                        cancellationSignal);
+                break;
+            case BLOCKED_ID:
+                cursor = queryBlockedListWithId(ContentUris.parseId(uri), projection, selection,
+                        cancellationSignal);
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+        // Tell the cursor what uri to watch, so it knows when its source data changes
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+        return cursor;
+    }
+
+    /**
+     * Implements the "blocked/#" query.
+     */
+    private Cursor queryBlockedListWithId(long id, String[] projection, String selection,
+            CancellationSignal cancellationSignal) {
+        throwForNonEmptySelection(selection);
+
+        return queryBlockedList(projection, ID_SELECTION, new String[]{Long.toString(id)},
+                null, cancellationSignal);
+    }
+
+    /**
+     * Implements the "blocked/" query.
+     */
+    private Cursor queryBlockedList(String[] projection, String selection, String[] selectionArgs,
+            String sortOrder, CancellationSignal cancellationSignal) {
+        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+        qb.setStrict(true);
+        qb.setTables(BlockedNumberDatabaseHelper.Tables.BLOCKED_NUMBERS);
+        qb.setProjectionMap(sBlockedNumberColumns);
+
+        return qb.query(mDbHelper.getReadableDatabase(), projection, selection, selectionArgs,
+                /* groupBy =*/ null, /* having =*/null, sortOrder,
+                /* limit =*/ null, cancellationSignal);
+    }
+
+    private void throwForNonEmptySelection(String selection) {
+        if (!TextUtils.isEmpty(selection)) {
+            throw new IllegalArgumentException(
+                    "When ID is specified in URI, selection must be null");
+        }
+    }
+
+    @Override
+    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) {
+        final Bundle res = new Bundle();
+        switch (method) {
+            case BlockedNumberContract.METHOD_IS_BLOCKED:
+                enforceReadPermissionAndPrimaryUser();
+
+                res.putBoolean(BlockedNumberContract.RES_NUMBER_IS_BLOCKED, isBlocked(arg));
+                break;
+            case BlockedNumberContract.METHOD_CAN_CURRENT_USER_BLOCK_NUMBERS:
+                // No permission checks: any app should be able to access this API.
+                res.putBoolean(
+                        BlockedNumberContract.RES_CAN_BLOCK_NUMBERS, canCurrentUserBlockUsers());
+                break;
+            case BlockedNumberContract.METHOD_UNBLOCK:
+                enforceWritePermissionAndPrimaryUser();
+
+                res.putInt(BlockedNumberContract.RES_NUM_ROWS_DELETED, unblock(arg));
+                break;
+            case SystemContract.METHOD_NOTIFY_EMERGENCY_CONTACT:
+                enforceSystemWritePermissionAndPrimaryUser();
+
+                notifyEmergencyContact();
+                break;
+            case SystemContract.METHOD_END_BLOCK_SUPPRESSION:
+                enforceSystemWritePermissionAndPrimaryUser();
+
+                endBlockSuppression();
+                break;
+            case SystemContract.METHOD_GET_BLOCK_SUPPRESSION_STATUS:
+                enforceSystemReadPermissionAndPrimaryUser();
+
+                SystemContract.BlockSuppressionStatus status = getBlockSuppressionStatus();
+                res.putBoolean(SystemContract.RES_IS_BLOCKING_SUPPRESSED, status.isSuppressed);
+                res.putLong(SystemContract.RES_BLOCKING_SUPPRESSED_UNTIL_TIMESTAMP,
+                        status.untilTimestampMillis);
+                break;
+            case SystemContract.METHOD_SHOULD_SYSTEM_BLOCK_NUMBER:
+                enforceSystemReadPermissionAndPrimaryUser();
+                res.putBoolean(
+                        BlockedNumberContract.RES_NUMBER_IS_BLOCKED, shouldSystemBlockNumber(arg));
+                break;
+            default:
+                enforceReadPermissionAndPrimaryUser();
+
+                throw new IllegalArgumentException("Unsupported method " + method);
+        }
+        return res;
+    }
+
+    private int unblock(String phoneNumber) {
+        if (TextUtils.isEmpty(phoneNumber)) {
+            return 0;
+        }
+
+        StringBuilder selectionBuilder = new StringBuilder(ORIGINAL_NUMBER_SELECTION);
+        String[] selectionArgs = new String[]{phoneNumber};
+        final String e164Number = Utils.getE164Number(getContext(), phoneNumber, null);
+        if (!TextUtils.isEmpty(e164Number)) {
+            selectionBuilder.append(" or " + E164_NUMBER_SELECTION);
+            selectionArgs = new String[]{phoneNumber, e164Number};
+        }
+        String selection = selectionBuilder.toString();
+        if (DEBUG) {
+            Log.d(TAG, String.format("Unblocking numbers using selection: %s, args: %s",
+                    selection, Arrays.toString(selectionArgs)));
+        }
+        return deleteBlockedNumber(selection, selectionArgs);
+    }
+
+    private boolean isEmergencyNumber(String phoneNumber) {
+        if (TextUtils.isEmpty(phoneNumber)) {
+            return false;
+        }
+
+        final String e164Number = Utils.getE164Number(getContext(), phoneNumber, null);
+        return PhoneNumberUtils.isEmergencyNumber(phoneNumber)
+                || PhoneNumberUtils.isEmergencyNumber(e164Number);
+    }
+
+    private boolean isBlocked(String phoneNumber) {
+        if (TextUtils.isEmpty(phoneNumber)) {
+            return false;
+        }
+
+        final String inE164 = Utils.getE164Number(getContext(), phoneNumber, null); // may be empty.
+
+        if (DEBUG) {
+            Log.d(TAG, String.format("isBlocked: in=%s, e164=%s", phoneNumber, inE164));
+        }
+
+        final Cursor c = mDbHelper.getReadableDatabase().rawQuery(
+                "SELECT " +
+                BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER + "," +
+                BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER +
+                " FROM " + BlockedNumberDatabaseHelper.Tables.BLOCKED_NUMBERS +
+                " WHERE " + BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER + "=?1" +
+                " OR (?2 != '' AND " +
+                        BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER + "=?2)",
+                new String[] {phoneNumber, inE164}
+                );
+        try {
+            while (c.moveToNext()) {
+                if (DEBUG) {
+                    final String original = c.getString(0);
+                    final String e164 = c.getString(1);
+
+                    Log.d(TAG, String.format("match found: original=%s, e164=%s", original, e164));
+                }
+                return true;
+            }
+        } finally {
+            c.close();
+        }
+        // No match found.
+        return false;
+    }
+
+    private boolean canCurrentUserBlockUsers() {
+        UserManager userManager = getContext().getSystemService(UserManager.class);
+        return userManager.isPrimaryUser();
+    }
+
+    private void notifyEmergencyContact() {
+        writeBlockSuppressionExpiryTimePref(System.currentTimeMillis() +
+                getBlockSuppressSecondsFromCarrierConfig() * 1000);
+        notifyBlockSuppressionStateChange();
+    }
+
+    private void endBlockSuppression() {
+        // Nothing to do if blocks are not being suppressed.
+        if (getBlockSuppressionStatus().isSuppressed) {
+            writeBlockSuppressionExpiryTimePref(0);
+            notifyBlockSuppressionStateChange();
+        }
+    }
+
+    private SystemContract.BlockSuppressionStatus getBlockSuppressionStatus() {
+        SharedPreferences pref = getContext().getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
+        long blockSuppressionExpiryTimeMillis = pref.getLong(BLOCK_SUPPRESSION_EXPIRY_TIME_PREF, 0);
+        return new SystemContract.BlockSuppressionStatus(System.currentTimeMillis() <
+                blockSuppressionExpiryTimeMillis, blockSuppressionExpiryTimeMillis);
+    }
+
+    private boolean shouldSystemBlockNumber(String phoneNumber) {
+        if (getBlockSuppressionStatus().isSuppressed) {
+            return false;
+        }
+        if (isEmergencyNumber(phoneNumber)) {
+            return false;
+        }
+        return isBlocked(phoneNumber);
+    }
+
+    private void writeBlockSuppressionExpiryTimePref(long expiryTimeMillis) {
+        SharedPreferences pref = getContext().getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
+        SharedPreferences.Editor editor = pref.edit();
+        editor.putLong(BLOCK_SUPPRESSION_EXPIRY_TIME_PREF, expiryTimeMillis);
+        editor.apply();
+    }
+
+    private long getBlockSuppressSecondsFromCarrierConfig() {
+        CarrierConfigManager carrierConfigManager =
+                getContext().getSystemService(CarrierConfigManager.class);
+        int carrierConfigValue = carrierConfigManager.getConfig().getInt
+                (CarrierConfigManager.KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT);
+        boolean isValidValue = carrierConfigValue >=0 && carrierConfigValue <=
+                MAX_BLOCKING_DISABLED_DURATION_SECONDS;
+        return isValidValue ? carrierConfigValue : CarrierConfigManager.getDefaultConfig().getInt(
+                CarrierConfigManager.KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT);
+    }
+
+    /**
+     * Returns {@code false} when the caller is not root, the user selected dialer, the
+     * default SMS app or a carrier app.
+     */
+    private boolean checkForPrivilegedApplications() {
+        if (Binder.getCallingUid() == Process.ROOT_UID) {
+            return true;
+        }
+
+        final String callingPackage = getCallingPackage();
+        if (TextUtils.isEmpty(callingPackage)) {
+            Log.w(TAG, "callingPackage not accessible");
+        } else {
+            final TelecomManager telecom = getContext().getSystemService(TelecomManager.class);
+
+            if (callingPackage.equals(telecom.getDefaultDialerPackage())
+                    || callingPackage.equals(telecom.getSystemDialerPackage())) {
+                return true;
+            }
+            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);
+            if (appOps.noteOp(AppOpsManager.OP_WRITE_SMS,
+                    Binder.getCallingUid(), callingPackage) == AppOpsManager.MODE_ALLOWED) {
+                return true;
+            }
+
+            final TelephonyManager telephonyManager =
+                    getContext().getSystemService(TelephonyManager.class);
+            return telephonyManager.checkCarrierPrivilegesForPackage(callingPackage) ==
+                    TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;
+        }
+        return false;
+    }
+
+    private void notifyBlockSuppressionStateChange() {
+        Intent intent = new Intent(SystemContract.ACTION_BLOCK_SUPPRESSION_STATE_CHANGED);
+        getContext().sendBroadcast(intent, Manifest.permission.READ_BLOCKED_NUMBERS);
+    }
+
+    private void enforceReadPermission() {
+        checkForPermission(android.Manifest.permission.READ_BLOCKED_NUMBERS);
+    }
+
+    private void enforceReadPermissionAndPrimaryUser() {
+        checkForPermissionAndPrimaryUser(android.Manifest.permission.READ_BLOCKED_NUMBERS);
+    }
+
+    private void enforceWritePermissionAndPrimaryUser() {
+        checkForPermissionAndPrimaryUser(android.Manifest.permission.WRITE_BLOCKED_NUMBERS);
+    }
+
+    private void checkForPermissionAndPrimaryUser(String permission) {
+        checkForPermission(permission);
+        if (!canCurrentUserBlockUsers()) {
+            throwCurrentUserNotPermittedSecurityException();
+        }
+    }
+
+    private void checkForPermission(String permission) {
+        boolean permitted = passesSystemPermissionCheck(permission)
+                || checkForPrivilegedApplications() || isSelf();
+        if (!permitted) {
+            throwSecurityException();
+        }
+    }
+
+    private void enforceSystemReadPermissionAndPrimaryUser() {
+        enforceSystemPermissionAndUser(android.Manifest.permission.READ_BLOCKED_NUMBERS);
+    }
+
+    private void enforceSystemWritePermissionAndPrimaryUser() {
+        enforceSystemPermissionAndUser(android.Manifest.permission.WRITE_BLOCKED_NUMBERS);
+    }
+
+    private void enforceSystemPermissionAndUser(String permission) {
+        if (!canCurrentUserBlockUsers()) {
+            throwCurrentUserNotPermittedSecurityException();
+        }
+
+        if (!passesSystemPermissionCheck(permission)) {
+            throwSecurityException();
+        }
+    }
+
+    private boolean passesSystemPermissionCheck(String permission) {
+        return getContext().checkCallingPermission(permission)
+                == PackageManager.PERMISSION_GRANTED;
+    }
+
+    private boolean isSelf() {
+        return ALLOW_SELF_CALL && Binder.getCallingPid() == Process.myPid();
+    }
+
+    private void throwSecurityException() {
+        throw new SecurityException("Caller must be system, default dialer or default SMS app");
+    }
+
+    private void throwCurrentUserNotPermittedSecurityException() {
+        throw new SecurityException("The current user cannot perform this operation");
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/AndroidManifest.xml
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/AndroidManifest.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/AndroidManifest.xml	(revision 9196)
@@ -0,0 +1,706 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2006 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+    package="com.android.contacts"
+    android:versionCode="10422"
+    android:versionName="1.4.22">
+
+
+    <uses-sdk android:minSdkVersion="21" android:targetSdkVersion="25" />
+    <original-package android:name="com.android.contacts" />
+
+    <uses-permission android:name="android.permission.CALL_PRIVILEGED" />
+    <uses-permission android:name="android.permission.CALL_PHONE" />
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+    <uses-permission android:name="android.permission.WRITE_CONTACTS" />
+    <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
+    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
+    <uses-permission android:name="android.permission.GET_ACCOUNTS_PRIVILEGED" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.READ_PROFILE" />
+    <uses-permission android:name="android.permission.WRITE_PROFILE" />
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.NFC" />
+    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.USE_CREDENTIALS" />
+    <uses-permission android:name="android.permission.VIBRATE" />
+    <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/>
+    <!-- Following used for QuickContacts -->
+    <uses-permission android:name="android.permission.READ_CALL_LOG" />
+    <uses-permission android:name="android.permission.READ_SMS" />
+    <uses-permission android:name="android.permission.READ_CALENDAR" />
+    <uses-permission android:name="com.android.voicemail.permission.READ_VOICEMAIL" />
+    <!-- Following used for Contact metadata syncing -->
+    <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
+
+    <!-- start M: add by mtk for writing second storage permission. -->
+    <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />
+    <!-- end -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.BLUETOOTH"/>
+    <uses-permission android:name="android.permission.WRITE_APN_SETTINGS"/>
+    <uses-permission android:name="android.permission.MANAGE_DOCUMENTS" />
+    <!-- M: Used by HotKnot share contact -->
+    <uses-permission android:name="android.permission.HOTKNOT" />
+    <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <!-- start M: Add for VoiceCommand -->
+    <uses-permission android:name="android.permission.MANAGE_VOICE_KEYPHRASES" />
+    <!-- end -->
+    <!-- start M: Add for CMCC RCS -->
+    <uses-permission android:name="com.cmcc.ccs.READ_PROFILE" />
+    <uses-permission android:name="com.cmcc.ccs.WRITE_PROFILE" />
+    <!-- end -->
+
+    <application
+        android:name="com.android.contacts.ContactsApplication"
+        android:label="@string/applicationLabel"
+        android:icon="@mipmap/ic_contacts_launcher"
+        android:roundIcon="@mipmap/ic_contacts_launcher"
+        android:taskAffinity="android.task.contacts"
+        android:hardwareAccelerated="true"
+        android:supportsRtl="true"
+        android:usesCleartextTraffic="false"
+    >
+
+        <!-- The main Contacts activity with the contact list, favorites, and groups. -->
+        <activity android:name=".activities.PeopleActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/PeopleTheme"
+            android:clearTaskOnLaunch="true"
+            android:launchMode="singleTop"
+            android:resizeableActivity="true"
+        >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <category android:name="android.intent.category.APP_CONTACTS" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.contacts.action.LIST_DEFAULT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.LIST_CONTACTS" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.LIST_ALL_CONTACTS" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.LIST_CONTACTS_WITH_PHONES" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter android:label="@string/starredList">
+                <action android:name="com.android.contacts.action.LIST_STARRED" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter android:label="@string/frequentList">
+                <action android:name="com.android.contacts.action.LIST_FREQUENT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter android:label="@string/strequentList">
+                <action android:name="com.android.contacts.action.LIST_STREQUENT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.TAB" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.SEARCH" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.SEARCH" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.dir/person" />
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+            </intent-filter>
+
+            <meta-data android:name="android.app.searchable"
+                android:resource="@xml/searchable"
+            />
+
+           <meta-data android:name="android.app.shortcuts"
+                android:resource="@xml/shortcuts"
+            />
+
+        </activity>
+
+        <activity android:name=".activities.ContactSelectionActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/ContactPickerTheme"
+            android:launchMode="singleTop"
+            android:clearTaskOnLaunch="true"
+            android:uiOptions="splitActionBarWhenNarrow"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.INSERT_OR_EDIT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/raw_contact" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.PICK" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+                <data android:mimeType="vnd.android.cursor.dir/person" />
+                <data android:mimeType="vnd.android.cursor.dir/phone_v2" />
+                <data android:mimeType="vnd.android.cursor.dir/phone" />
+                <data android:mimeType="vnd.android.cursor.dir/postal-address_v2" />
+                <data android:mimeType="vnd.android.cursor.dir/postal-address" />
+                <data android:mimeType="vnd.android.cursor.dir/email_v2" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.GET_CONTENT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/phone_v2" />
+                <data android:mimeType="vnd.android.cursor.item/phone" />
+                <data android:mimeType="vnd.android.cursor.item/postal-address_v2" />
+                <data android:mimeType="vnd.android.cursor.item/postal-address" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.JOIN_CONTACT" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <!-- Backwards compatibility: somebody may have hard coded this activity name -->
+        <activity-alias android:name="ContactsListActivity"
+            android:targetActivity=".activities.PeopleActivity"
+        />
+
+        <!-- Backwards compatibility: "Contacts" from Honeycomb -->
+        <activity-alias android:name=".activities.ContactsFrontDoor"
+            android:targetActivity=".activities.PeopleActivity"
+            android:exported="true"
+        />
+
+        <!-- Backwards compatibility: "Contacts" from Gingerbread and earlier -->
+        <activity-alias android:name="DialtactsContactsEntryActivity"
+            android:targetActivity=".activities.PeopleActivity"
+            android:exported="true"
+        />
+
+        <!-- Used to set options -->
+        <activity
+            android:name=".common.preference.ContactsPreferenceActivity"
+            android:label="@string/activity_title_settings"
+            android:theme="@style/ContactsPreferencesTheme"
+            android:exported="false"/>
+
+        <activity android:name=".common.activity.LicenseActivity"
+            android:label="@string/activity_title_licenses"
+            android:theme="@style/ContactsPreferencesTheme"
+            android:exported="false" />
+
+        <!-- Used to filter contacts list by account -->
+        <activity
+            android:name=".common.list.AccountFilterActivity"
+            android:label="@string/activity_title_contacts_filter"
+            android:theme="@style/ContactListFilterTheme" />
+
+        <!-- Used to select display and sync groups -->
+        <activity
+            android:name=".common.list.CustomContactListFilterActivity"
+            android:label="@string/custom_list_filter"
+            android:theme="@style/ContactListFilterTheme" />
+
+        <activity
+            android:name=".common.activity.RequestPermissionsActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/PeopleTheme"
+            android:exported="false"/>
+
+        <activity
+            android:name=".common.activity.RequestDesiredPermissionsActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/PeopleTheme"
+            android:exported="false"/>
+
+        <activity
+            android:name=".common.activity.RequestImportVCardPermissionsActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/PeopleTheme"
+            android:exported="false"/>
+
+        <activity
+            android:name=".activities.ShowOrCreateActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@android:style/Theme.Material.Light.Dialog.NoActionBar">
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.SHOW_OR_CREATE_CONTACT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:scheme="mailto" />
+                <data android:scheme="tel" />
+            </intent-filter>
+        </activity>
+
+        <!-- Views the details of a single group -->
+        <activity android:name=".activities.GroupDetailActivity"
+            android:label=""
+            android:theme="@style/DetailActivityTheme"/>
+
+        <!--M: Create a new or edit an existing group -->
+        <activity
+            android:name=".activities.GroupEditorActivity"
+            android:theme="@style/EditorActivityTheme"
+            android:configChanges="mcc|mnc|locale"
+            android:windowSoftInputMode="adjustResize" />
+
+        <activity
+            android:name=".quickcontact.QuickContactActivity"
+            android:label="@string/quickContactActivityLabel"
+            android:theme="@style/Theme.QuickContact"
+            android:launchMode="singleTop"
+            android:excludeFromRecents="true"
+            android:taskAffinity=""
+            android:windowSoftInputMode="stateUnchanged">
+
+            <intent-filter>
+                <action android:name="com.android.contacts.action.QUICK_CONTACT" />
+                <action android:name="android.provider.action.QUICK_CONTACT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/raw_contact" />
+            </intent-filter>
+        </activity>
+
+        <receiver
+            android:name=".quickcontact.QuickContactBroadcastReceiver"
+            android:exported="false" />
+
+        <activity-alias android:name="ContactShortcut"
+            android:targetActivity=".activities.ContactSelectionActivity"
+            android:label="@string/shortcutContact"
+            android:icon="@drawable/logo_quick_contacts_color_44in48dp">
+
+            <intent-filter>
+                <action android:name="android.intent.action.CREATE_SHORTCUT" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+
+        </activity-alias>
+
+        <activity-alias android:name="alias.DialShortcut"
+            android:targetActivity=".activities.ContactSelectionActivity"
+            android:label="@string/shortcutDialContact"
+            android:icon="@drawable/logo_quick_contacts_dialer_color_44in48dp">
+
+            <intent-filter>
+                <action android:name="android.intent.action.CREATE_SHORTCUT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.CAR_MODE" />
+            </intent-filter>
+
+        </activity-alias>
+
+        <activity-alias android:name="alias.MessageShortcut"
+            android:targetActivity=".activities.ContactSelectionActivity"
+            android:label="@string/shortcutMessageContact"
+            android:icon="@drawable/logo_quick_contacts_mail_color_44in48dp">
+
+            <intent-filter>
+                <action android:name="android.intent.action.CREATE_SHORTCUT" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+
+        </activity-alias>
+
+        <!-- Confirm that a single detail will be added to an existing contact -->
+        <activity
+            android:name=".activities.ConfirmAddDetailActivity"
+            android:label="@string/activity_title_confirm_add_detail"
+            android:theme="@style/ConfirmAddDetailDialogTheme"
+            android:windowSoftInputMode="adjustResize"
+            android:exported="false"/>
+
+        <!-- M:Accounts changed prompt that can appear when creating a new contact. -->
+        <activity
+            android:name=".activities.ContactEditorAccountsChangedActivity"
+            android:theme="@style/ContactEditorAccountsChangedActivityTheme"
+            android:windowSoftInputMode="adjustResize"
+            android:configChanges="orientation|screenSize"
+            android:exported="false"/>
+
+        <!-- Edit or create a contact with only the most important fields displayed initially. -->
+        <activity
+            android:name=".activities.CompactContactEditorActivity"
+            android:label="@string/editContactActivityLabel"
+            android:theme="@style/EditorActivityTheme"
+            android:windowSoftInputMode="stateHidden|adjustResize">
+
+            <intent-filter android:label="@string/editContactDescription">
+                <action android:name="android.intent.action.EDIT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/raw_contact" />
+            </intent-filter>
+            <intent-filter android:label="@string/insertContactDescription">
+                <action android:name="android.intent.action.INSERT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.dir/person" />
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+                <data android:mimeType="vnd.android.cursor.dir/raw_contact" />
+            </intent-filter>
+        </activity>
+
+        <!-- M:Edit or create a contact with all fields displayed. -->
+        <activity
+            android:name=".activities.ContactEditorActivity"
+            android:label="@string/editContactActivityLabel"
+            android:theme="@style/EditorActivityTheme"
+            android:windowSoftInputMode="stateHidden|adjustResize"
+            android:exported="false">
+            android:configChanges="mcc|mnc">
+
+            <intent-filter android:label="@string/editContactDescription">
+                <action android:name="com.android.contacts.action.FULL_EDIT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/raw_contact" />
+            </intent-filter>
+            <intent-filter android:label="@string/insertContactDescription">
+                <action android:name="com.android.contacts.action.FULL_INSERT" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="vnd.android.cursor.dir/person" />
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+                <data android:mimeType="vnd.android.cursor.dir/raw_contact" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".common.test.FragmentTestActivity">
+            <intent-filter>
+                <category android:name="android.intent.category.TEST" />
+            </intent-filter>
+        </activity>
+
+        <!-- Stub service used to keep our process alive long enough for
+             background threads to finish their operations. -->
+        <service
+            android:name=".common.util.EmptyService"
+            android:exported="false" />
+
+        <!-- Service to save a contact -->
+        <service
+            android:name=".ContactSaveService"
+            android:exported="false" />
+
+        <!-- Attaches a photo to a contact. Started from external applications -->
+        <activity android:name=".activities.AttachPhotoActivity"
+            android:label="@string/attach_photo_dialog_title"
+            android:taskAffinity="">
+            <intent-filter>
+                <action android:name="android.intent.action.ATTACH_DATA" />
+                <data android:mimeType="image/*" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <!--M: vCard related -->
+        <activity android:name=".common.vcard.ImportVCardActivity"
+            android:label="@string/launcherActivityLabel"
+            android:configChanges="mcc|mnc|locale|orientation|screenSize|keyboardHidden|screenLayout"
+            android:theme="@style/BackgroundOnlyThemeForImportVCardActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <data android:mimeType="text/directory" />
+                <data android:mimeType="text/vcard" />
+                <data android:mimeType="text/x-vcard" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".common.vcard.NfcImportVCardActivity"
+            android:label="@string/launcherActivityLabel"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:theme="@style/BackgroundOnlyTheme">
+            <intent-filter>
+                <action android:name="android.nfc.action.NDEF_DISCOVERED" />
+                <data android:mimeType="text/vcard" />
+                <data android:mimeType="text/x-vcard" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name=".common.vcard.CancelActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/BackgroundOnlyTheme" />
+
+        <activity android:name=".common.vcard.SelectAccountActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/BackgroundOnlyTheme"
+            android:launchMode="singleTop" />
+
+        <activity android:name=".common.vcard.ExportVCardActivity"
+            android:label="@string/launcherActivityLabel"
+            android:theme="@style/BackgroundOnlyTheme" />
+
+        <activity android:name=".common.vcard.ShareVCardActivity"
+                  android:label="@string/launcherActivityLabel"
+                  android:theme="@style/BackgroundOnlyTheme" />
+
+        <service
+            android:name=".common.vcard.VCardService"
+            android:exported="false" />
+        <!-- end vCard related -->
+
+        <!-- Intercept Dialer Intents for devices without a phone.
+             This activity should have the same intent filters as the DialtactsActivity,
+             so that its capturing the same events. Omit android.intent.category.LAUNCHER, because
+             we don't want this to show up in the Launcher. The priorities of the intent-filters
+             are set lower, so that the user does not see a disambig dialog -->
+        <activity
+            android:name="com.android.contacts.NonPhoneActivity"
+            android:theme="@style/NonPhoneActivityTheme"
+            android:label="@string/launcherActivityLabel"
+            >
+            <intent-filter android:priority="-1">
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <category android:name="android.intent.category.BROWSABLE"/>
+            </intent-filter>
+            <intent-filter android:priority="-1">
+                <action android:name="android.intent.action.VIEW"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <category android:name="android.intent.category.BROWSABLE"/>
+                <data android:scheme="tel"/>
+            </intent-filter>
+            <intent-filter android:priority="-1">
+                <action android:name="android.intent.action.VIEW"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <category android:name="android.intent.category.BROWSABLE"/>
+                <data android:mimeType="vnd.android.cursor.dir/calls"/>
+            </intent-filter>
+        </activity>
+
+        <activity android:name="com.android.contacts.common.dialog.CallSubjectDialog"
+                  android:theme="@style/Theme.CallSubjectDialogTheme"
+                  android:windowSoftInputMode="stateVisible|adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW"/>
+            </intent-filter>
+        </activity>
+
+        <!-- Service that is exclusively for the Phone application that sends out a view
+             notification. This service might be removed in future versions of the app.
+
+             This is called explicitly by the phone app via package name and class.
+             (PhoneUtils.sendViewNotificationAsync()).  If this service moves, then phone
+             needs to be changed as well.
+        -->
+        <service android:name=".ViewNotificationService"
+                 android:permission="android.permission.WRITE_CONTACTS"
+                 android:exported="true">
+            <intent-filter>
+                <action android:name="com.android.contacts.VIEW_NOTIFICATION"/>
+                <data android:mimeType="vnd.android.cursor.item/contact"/>
+            </intent-filter>
+        </service>
+
+        <!-- Broadcast receiver that passively listens to location updates -->
+        <receiver android:name="com.android.contacts.common.location.CountryDetector$LocationChangedReceiver"/>
+
+        <!-- IntentService to update the user's current country -->
+        <service android:name="com.android.contacts.common.location.UpdateCountryService"
+            android:exported="false"/>
+
+        <provider
+            android:name="android.support.v4.content.FileProvider"
+            android:authorities="@string/contacts_file_provider_authority"
+            android:grantUriPermissions="true"
+            android:exported="false">
+            <meta-data
+                android:name="android.support.FILE_PROVIDER_PATHS"
+                android:resource="@xml/file_paths" />
+        </provider>
+
+        <meta-data android:name="android.nfc.disable_beam_default" android:value="true" />
+
+        <!-- The following lines are provided and maintained by Mediatek Inc. -->
+
+        <activity android:name="com.mediatek.contacts.detail.AssociationSimActivity"
+            android:label="@string/viewContactTitle"
+            android:theme="@style/ContactMultiChoiceTheme">
+
+            <intent-filter >
+                <action android:name="android.intent.action.VIEW" />
+                <data android:mimeType="vnd.android.cursor.item/person" />
+                <data android:mimeType="vnd.android.cursor.item/contact" />
+                <data android:mimeType="vnd.android.cursor.item/raw_contact" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:name="com.mediatek.contacts.list.ContactListMultiChoiceActivity"
+            android:clearTaskOnLaunch="true"
+            android:label="@string/contactsList"
+            android:launchMode="singleTop"
+            android:configChanges="mcc|mnc|keyboardHidden|screenSize"
+            android:theme="@style/ContactMultiChoiceTheme"
+            android:uiOptions="splitActionBarWhenNarrow">
+            <intent-filter >
+                <action android:name="android.intent.action.contacts.list.PICKMULTICONTACTS" />
+                <action android:name="android.intent.action.contacts.list.SHAREMULTICONTACTS" />
+                <action android:name="android.intent.action.contacts.list.PICKMULTIEMAILS" />
+                <action android:name="android.intent.action.contacts.list.PICKMULTIPHONES" />
+                <action android:name="android.intent.action.contacts.list.PICKMULTIDATAS" />
+                <action android:name="android.intent.action.contacts.list.DELETEMULTICONTACTS" />
+                <action android:name="android.intent.action.contacts.list.group.MOVEMULTICONTACTS" />
+                <action android:name="android.intent.action.contacts.list.group.ADDMULTICONTACTS" />
+                <action android:name="android.intent.action.contacts.list.PICKMULTIPHONEANDEMAILS" />
+                <action android:name="android.intent.action.contacts.list.group.MMSADDGROUPCONTACTS" />
+                <action android:name="android.intent.action.contacts.list.PICKMULTIPHONEANDIMSANDSIPCONTACTS" />
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:mimeType="vnd.android.cursor.dir/contact" />
+                <data android:mimeType="vnd.android.cursor.dir/person" />
+                <data android:mimeType="vnd.android.cursor.dir/phone_v2" />
+                <data android:mimeType="vnd.android.cursor.item/phone_v2" />
+                <data android:mimeType="vnd.android.cursor.dir/phone" />
+                <data android:mimeType="vnd.android.cursor.dir/postal-address_v2" />
+                <data android:mimeType="vnd.android.cursor.dir/postal-address" />
+                <data android:mimeType="vnd.android.cursor.dir/email_v2" />
+                <data android:mimeType="vnd.android.cursor.item/com.orangelabs.rcse.capabilities" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:configChanges="mcc|mnc|locale|orientation|keyboardHidden|screenSize"
+            android:label="@string/contactsList"
+            android:launchMode="singleTop"
+            android:name="com.mediatek.contacts.list.ContactGroupListActivity"
+            android:theme="@style/ContactMultiChoiceTheme" >
+            <intent-filter >
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:label="@string/contactsList"
+            android:launchMode="singleTask"
+            android:name="com.mediatek.contacts.list.service.MultiChoiceConfirmActivity"
+            android:theme="@style/BackgroundOnlyTheme" >
+            <intent-filter >
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <service
+            android:name="com.mediatek.contacts.list.service.MultiChoiceService"
+            android:exported="false" />
+
+        <service android:name="com.mediatek.contacts.simservice.SimProcessorService"/>
+
+        <activity
+            android:name="com.mediatek.contacts.activities.ContactImportExportActivity"
+            android:label="@string/import_export_title"
+            android:theme="@style/PeopleTheme"
+            android:configChanges="screenSize|orientation|keyboardHidden|screenLayout" >
+           <intent-filter>
+                <action android:name="android.intent.action.contacts.list.IMPORTEXPORTCONTACTS"/>
+                <category android:name="android.intent.category.DEFAULT" />
+           </intent-filter>
+        </activity>
+
+        <activity
+            android:name="com.mediatek.contacts.ShareContactViaSMSActivity"
+            android:exported="false"
+            android:icon="@drawable/mtk_ic_launcher_smsmms"
+            android:label="@string/call_sms"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:theme="@style/BackgroundOnlyTheme" >
+            <intent-filter >
+                <action android:name="android.intent.action.SEND" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="text/x-vcard" />
+            </intent-filter>
+        </activity>
+
+        <!-- M: Used by HotKnot share single contact -->
+        <activity android:name="com.mediatek.contacts.activities.HotKnotImportVCardActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:theme="@style/BackgroundOnlyTheme">
+            <intent-filter>
+                <action android:name="com.mediatek.hotknot.action.VCARD_DISCOVERD" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <!-- M: Group browse list activity. -->
+        <activity android:name="com.mediatek.contacts.activities.GroupBrowseActivity"
+            android:theme="@style/PeopleTheme"
+            android:label="@string/groupsLabel"/>
+
+        <activity android:name="com.mediatek.contacts.aas.AasTagActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden|screenLayout"
+            android:theme="@style/EditorActivityTheme"
+            android:uiOptions="splitActionBarWhenNarrow"
+            android:label="@string/aas_custom_title">
+            <intent-filter >
+                <action android:name="com.mediatek.contacts.action.EDIT_AAS"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+            </intent-filter>
+        </activity>
+
+    </application>
+</manifest>
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/quickcontact/QuickContactActivity.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/quickcontact/QuickContactActivity.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/quickcontact/QuickContactActivity.java	(revision 9196)
@@ -0,0 +1,3216 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.quickcontact;
+
+import android.accounts.Account;
+import android.animation.ArgbEvaluator;
+import android.animation.ObjectAnimator;
+import android.app.Activity;
+import android.app.Fragment;
+import android.app.LoaderManager.LoaderCallbacks;
+import android.app.SearchManager;
+import android.content.ActivityNotFoundException;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.Loader;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.ColorStateList;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffColorFilter;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Trace;
+import android.provider.CalendarContract;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds.Email;
+import android.provider.ContactsContract.CommonDataKinds.Event;
+import android.provider.ContactsContract.CommonDataKinds.GroupMembership;
+import android.provider.ContactsContract.CommonDataKinds.Identity;
+import android.provider.ContactsContract.CommonDataKinds.Im;
+import android.provider.ContactsContract.CommonDataKinds.Nickname;
+import android.provider.ContactsContract.CommonDataKinds.Note;
+import android.provider.ContactsContract.CommonDataKinds.Organization;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.Relation;
+import android.provider.ContactsContract.CommonDataKinds.SipAddress;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+import android.provider.ContactsContract.Contacts;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.Directory;
+import android.provider.ContactsContract.DisplayNameSources;
+import android.provider.ContactsContract.DataUsageFeedback;
+import android.provider.ContactsContract.Intents;
+import android.provider.ContactsContract.QuickContact;
+import android.provider.ContactsContract.RawContacts;
+import android.support.v4.content.ContextCompat;
+import android.support.v7.graphics.Palette;
+import android.support.v7.widget.CardView;
+import android.telecom.PhoneAccount;
+import android.telecom.TelecomManager;
+import android.text.BidiFormatter;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.TextDirectionHeuristics;
+import android.text.TextUtils;
+import android.view.ContextMenu;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnCreateContextMenuListener;
+import android.view.WindowManager;
+import android.view.accessibility.AccessibilityEvent;
+import android.widget.Button;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.LinearLayout;
+import android.widget.Toast;
+import android.widget.Toolbar;
+
+import com.android.contacts.ContactSaveService;
+import com.android.contacts.ContactsActivity;
+import com.android.contacts.ContactsApplication;
+import com.android.contacts.NfcHandler;
+import com.android.contacts.R;
+
+import com.android.contacts.activities.ContactEditorBaseActivity;
+import com.android.contacts.activities.PeopleActivity;
+import com.android.contacts.common.CallUtil;
+import com.android.contacts.common.ClipboardUtils;
+import com.android.contacts.common.Collapser;
+import com.android.contacts.common.ContactPhotoManager;
+import com.android.contacts.common.ContactsUtils;
+import com.android.contacts.common.activity.RequestDesiredPermissionsActivity;
+import com.android.contacts.common.activity.RequestPermissionsActivity;
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.common.compat.EventCompat;
+import com.android.contacts.common.compat.MultiWindowCompat;
+import com.android.contacts.common.dialog.CallSubjectDialog;
+import com.android.contacts.common.editor.SelectAccountDialogFragment;
+import com.android.contacts.common.interactions.TouchPointManager;
+import com.android.contacts.common.lettertiles.LetterTileDrawable;
+import com.android.contacts.common.list.ShortcutIntentBuilder;
+import com.android.contacts.common.list.ShortcutIntentBuilder.OnShortcutIntentCreatedListener;
+import com.android.contacts.common.logging.Logger;
+import com.android.contacts.common.logging.ScreenEvent.ScreenType;
+import com.android.contacts.common.model.AccountTypeManager;
+import com.android.contacts.common.model.Contact;
+import com.android.contacts.common.model.ContactLoader;
+import com.android.contacts.common.model.RawContact;
+import com.android.contacts.common.model.account.AccountType;
+import com.android.contacts.common.model.account.AccountWithDataSet;
+import com.android.contacts.common.model.dataitem.DataItem;
+import com.android.contacts.common.model.dataitem.DataKind;
+import com.android.contacts.common.model.dataitem.EmailDataItem;
+import com.android.contacts.common.model.dataitem.EventDataItem;
+import com.android.contacts.common.model.dataitem.GroupMembershipDataItem;
+import com.android.contacts.common.model.dataitem.ImDataItem;
+import com.android.contacts.common.model.dataitem.NicknameDataItem;
+import com.android.contacts.common.model.dataitem.NoteDataItem;
+import com.android.contacts.common.model.dataitem.OrganizationDataItem;
+import com.android.contacts.common.model.dataitem.PhoneDataItem;
+import com.android.contacts.common.model.dataitem.RelationDataItem;
+import com.android.contacts.common.model.dataitem.SipAddressDataItem;
+import com.android.contacts.common.model.dataitem.StructuredNameDataItem;
+import com.android.contacts.common.model.dataitem.StructuredPostalDataItem;
+import com.android.contacts.common.model.dataitem.WebsiteDataItem;
+import com.android.contacts.common.model.ValuesDelta;
+import com.android.contacts.common.util.Constants;
+import com.android.contacts.common.util.ImplicitIntentsUtil;
+import com.android.contacts.common.util.DateUtils;
+import com.android.contacts.common.util.MaterialColorMapUtils;
+import com.android.contacts.common.util.MaterialColorMapUtils.MaterialPalette;
+import com.android.contacts.common.util.UriUtils;
+import com.android.contacts.common.util.ViewUtil;
+import com.android.contacts.common.vcard.VCardCommonArguments;
+import com.android.contacts.detail.ContactDisplayUtils;
+import com.android.contacts.editor.AggregationSuggestionEngine;
+import com.android.contacts.editor.AggregationSuggestionEngine.Suggestion;
+import com.android.contacts.editor.ContactEditorFragment;
+import com.android.contacts.editor.EditorIntents;
+import com.android.contacts.interactions.CalendarInteractionsLoader;
+import com.android.contacts.interactions.CallLogInteractionsLoader;
+import com.android.contacts.interactions.ContactDeletionInteraction;
+import com.android.contacts.interactions.ContactInteraction;
+import com.android.contacts.interactions.JoinContactsDialogFragment;
+import com.android.contacts.interactions.JoinContactsDialogFragment.JoinContactsListener;
+import com.android.contacts.interactions.SmsInteractionsLoader;
+import com.android.contacts.quickcontact.ExpandingEntryCardView.Entry;
+import com.android.contacts.quickcontact.ExpandingEntryCardView.EntryContextMenuInfo;
+import com.android.contacts.quickcontact.ExpandingEntryCardView.EntryTag;
+import com.android.contacts.quickcontact.ExpandingEntryCardView.ExpandingEntryCardViewListener;
+import com.android.contacts.quickcontact.WebAddress.ParseException;
+import com.android.contacts.util.ImageViewDrawableSetter;
+import com.android.contacts.util.PhoneCapabilityTester;
+import com.android.contacts.util.SchedulingUtils;
+import com.android.contacts.util.StructuredPostalUtils;
+import com.android.contacts.widget.MultiShrinkScroller;
+import com.android.contacts.widget.MultiShrinkScroller.MultiShrinkScrollerListener;
+import com.android.contacts.widget.QuickContactImageView;
+import com.android.contactsbind.HelpUtils;
+
+import com.google.common.collect.Lists;
+import com.mediatek.contacts.ExtensionManager;
+import com.mediatek.contacts.GlobalEnv;
+import com.mediatek.contacts.quickcontact.QuickContactUtils;
+import com.mediatek.contacts.ContactsSystemProperties;
+import com.mediatek.contacts.model.dataitem.ImsCallDataItem;
+import com.mediatek.contacts.simcontact.SimCardUtils;
+import com.mediatek.contacts.util.AccountTypeUtils;
+import com.mediatek.contacts.util.Log;
+
+import java.lang.SecurityException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Mostly translucent {@link Activity} that shows QuickContact dialog. It loads
+ * data asynchronously, and then shows a popup with details centered around
+ * {@link Intent#getSourceBounds()}.
+ */
+public class QuickContactActivity extends ContactsActivity
+        implements AggregationSuggestionEngine.Listener, JoinContactsListener {
+
+    /**
+     * QuickContacts immediately takes up the full screen. All possible information is shown.
+     * This value for {@link android.provider.ContactsContract.QuickContact#EXTRA_MODE}
+     * should only be used by the Contacts app.
+     */
+    public static final int MODE_FULLY_EXPANDED = 4;
+
+    /** Used to pass the screen where the user came before launching this Activity. */
+    public static final String EXTRA_PREVIOUS_SCREEN_TYPE = "previous_screen_type";
+
+    private static final String TAG = "QuickContact";
+
+    private static final String KEY_THEME_COLOR = "theme_color";
+    private static final String KEY_IS_SUGGESTION_LIST_COLLAPSED = "is_suggestion_list_collapsed";
+    private static final String KEY_SELECTED_SUGGESTION_CONTACTS = "selected_suggestion_contacts";
+    private static final String KEY_PREVIOUS_CONTACT_ID = "previous_contact_id";
+    private static final String KEY_SUGGESTIONS_AUTO_SELECTED = "suggestions_auto_seleted";
+
+    private static final int ANIMATION_STATUS_BAR_COLOR_CHANGE_DURATION = 150;
+    private static final int REQUEST_CODE_CONTACT_EDITOR_ACTIVITY = 1;
+    private static final int SCRIM_COLOR = Color.argb(0xC8, 0, 0, 0);
+    private static final int REQUEST_CODE_CONTACT_SELECTION_ACTIVITY = 2;
+    private static final String MIMETYPE_SMS = "vnd.android-dir/mms-sms";
+
+    /** This is the Intent action to install a shortcut in the launcher. */
+    private static final String ACTION_INSTALL_SHORTCUT =
+            "com.android.launcher.action.INSTALL_SHORTCUT";
+
+    @SuppressWarnings("deprecation")
+    private static final String LEGACY_AUTHORITY = android.provider.Contacts.AUTHORITY;
+
+    private static final String MIMETYPE_GPLUS_PROFILE =
+            "vnd.android.cursor.item/vnd.googleplus.profile";
+    private static final String GPLUS_PROFILE_DATA_5_ADD_TO_CIRCLE = "addtocircle";
+    private static final String GPLUS_PROFILE_DATA_5_VIEW_PROFILE = "view";
+    private static final String MIMETYPE_HANGOUTS =
+            "vnd.android.cursor.item/vnd.googleplus.profile.comm";
+    private static final String HANGOUTS_DATA_5_VIDEO = "hangout";
+    private static final String HANGOUTS_DATA_5_MESSAGE = "conversation";
+    private static final String CALL_ORIGIN_QUICK_CONTACTS_ACTIVITY =
+            "com.android.contacts.quickcontact.QuickContactActivity";
+
+    /**
+     * The URI used to load the the Contact. Once the contact is loaded, use Contact#getLookupUri()
+     * instead of referencing this URI.
+     */
+    private Uri mLookupUri;
+    private String[] mExcludeMimes;
+    private int mExtraMode;
+    private String mExtraPrioritizedMimeType;
+    private int mStatusBarColor;
+    private boolean mHasAlreadyBeenOpened;
+    private boolean mOnlyOnePhoneNumber;
+    private boolean mOnlyOneEmail;
+
+    private QuickContactImageView mPhotoView;
+    private ExpandingEntryCardView mContactCard;
+    /// M:[for RCS-e] show Joyn Card(rcs-e plugin) under ContactCard.
+    private ExpandingEntryCardView mJoynCard;
+    private ExpandingEntryCardView mNoContactDetailsCard;
+    private ExpandingEntryCardView mRecentCard;
+    private ExpandingEntryCardView mAboutCard;
+
+    // Suggestion card.
+    private CardView mCollapsedSuggestionCardView;
+    private CardView mExpandSuggestionCardView;
+    private View mCollapasedSuggestionHeader;
+    private TextView mCollapsedSuggestionCardTitle;
+    private TextView mExpandSuggestionCardTitle;
+    private ImageView mSuggestionSummaryPhoto;
+    private TextView mSuggestionForName;
+    private TextView mSuggestionContactsNumber;
+    private LinearLayout mSuggestionList;
+    private Button mSuggestionsCancelButton;
+    private Button mSuggestionsLinkButton;
+    private boolean mIsSuggestionListCollapsed;
+    private boolean mSuggestionsShouldAutoSelected = true;
+    private long mPreviousContactId = 0;
+
+    private MultiShrinkScroller mScroller;
+    private SelectAccountDialogFragmentListener mSelectAccountFragmentListener;
+    private AsyncTask<Void, Void, Cp2DataCardModel> mEntriesAndActionsTask;
+    private AsyncTask<Void, Void, Void> mRecentDataTask;
+
+    private AggregationSuggestionEngine mAggregationSuggestionEngine;
+    private List<Suggestion> mSuggestions;
+
+    private TreeSet<Long> mSelectedAggregationIds = new TreeSet<>();
+    /**
+     * The last copy of Cp2DataCardModel that was passed to {@link #populateContactAndAboutCard}.
+     */
+    private Cp2DataCardModel mCachedCp2DataCardModel;
+    /**
+     *  This scrim's opacity is controlled in two different ways. 1) Before the initial entrance
+     *  animation finishes, the opacity is animated by a value animator. This is designed to
+     *  distract the user from the length of the initial loading time. 2) After the initial
+     *  entrance animation, the opacity is directly related to scroll position.
+     */
+    private ColorDrawable mWindowScrim;
+    private boolean mIsEntranceAnimationFinished;
+    private MaterialColorMapUtils mMaterialColorMapUtils;
+    private boolean mIsExitAnimationInProgress;
+    private boolean mHasComputedThemeColor;
+
+    /**
+     * Used to stop the ExpandingEntry cards from adjusting between an entry click and the intent
+     * being launched.
+     */
+    private boolean mHasIntentLaunched;
+
+    private Contact mContactData;
+    private ContactLoader mContactLoader;
+    private PorterDuffColorFilter mColorFilter;
+    private int mColorFilterColor;
+
+    private final ImageViewDrawableSetter mPhotoSetter = new ImageViewDrawableSetter();
+
+    /**
+     * {@link #LEADING_MIMETYPES} is used to sort MIME-types.
+     *
+     * <p>The MIME-types in {@link #LEADING_MIMETYPES} appear in the front of the dialog,
+     * in the order specified here.</p>
+     */
+    private static final List<String> LEADING_MIMETYPES = Lists.newArrayList(
+            Phone.CONTENT_ITEM_TYPE, SipAddress.CONTENT_ITEM_TYPE, Email.CONTENT_ITEM_TYPE,
+            StructuredPostal.CONTENT_ITEM_TYPE);
+
+    private static final List<String> SORTED_ABOUT_CARD_MIMETYPES = Lists.newArrayList(
+            Nickname.CONTENT_ITEM_TYPE,
+            // Phonetic name is inserted after nickname if it is available.
+            // No mimetype for phonetic name exists.
+            Website.CONTENT_ITEM_TYPE,
+            Organization.CONTENT_ITEM_TYPE,
+            Event.CONTENT_ITEM_TYPE,
+            Relation.CONTENT_ITEM_TYPE,
+            Im.CONTENT_ITEM_TYPE,
+            GroupMembership.CONTENT_ITEM_TYPE,
+            Identity.CONTENT_ITEM_TYPE,
+            Note.CONTENT_ITEM_TYPE);
+
+    private static final BidiFormatter sBidiFormatter = BidiFormatter.getInstance();
+
+    /** Id for the background contact loader */
+    private static final int LOADER_CONTACT_ID = 0;
+
+    private static final String KEY_LOADER_EXTRA_PHONES =
+            QuickContactActivity.class.getCanonicalName() + ".KEY_LOADER_EXTRA_PHONES";
+
+    /** Id for the background Sms Loader */
+    private static final int LOADER_SMS_ID = 1;
+    private static final int MAX_SMS_RETRIEVE = 3;
+
+    /** Id for the back Calendar Loader */
+    private static final int LOADER_CALENDAR_ID = 2;
+    private static final String KEY_LOADER_EXTRA_EMAILS =
+            QuickContactActivity.class.getCanonicalName() + ".KEY_LOADER_EXTRA_EMAILS";
+    private static final int MAX_PAST_CALENDAR_RETRIEVE = 3;
+    private static final int MAX_FUTURE_CALENDAR_RETRIEVE = 3;
+    private static final long PAST_MILLISECOND_TO_SEARCH_LOCAL_CALENDAR =
+            1L * 24L * 60L * 60L * 1000L /* 1 day */;
+    private static final long FUTURE_MILLISECOND_TO_SEARCH_LOCAL_CALENDAR =
+            7L * 24L * 60L * 60L * 1000L /* 7 days */;
+
+    /** Id for the background Call Log Loader */
+    private static final int LOADER_CALL_LOG_ID = 3;
+    private static final int MAX_CALL_LOG_RETRIEVE = 3;
+    private static final int MIN_NUM_CONTACT_ENTRIES_SHOWN = 3;
+    private static final int MIN_NUM_COLLAPSED_RECENT_ENTRIES_SHOWN = 3;
+    private static final int CARD_ENTRY_ID_EDIT_CONTACT = -2;
+
+
+    private static final int[] mRecentLoaderIds = new int[]{
+        LOADER_SMS_ID,
+        LOADER_CALENDAR_ID,
+        LOADER_CALL_LOG_ID};
+    /**
+     * ConcurrentHashMap constructor params: 4 is initial table size, 0.9f is
+     * load factor before resizing, 1 means we only expect a single thread to
+     * write to the map so make only a single shard
+     */
+    private Map<Integer, List<ContactInteraction>> mRecentLoaderResults =
+        new ConcurrentHashMap<>(4, 0.9f, 1);
+
+    private static final String FRAGMENT_TAG_SELECT_ACCOUNT = "select_account_fragment";
+
+    final OnClickListener mEntryClickHandler = new OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            final Object entryTagObject = v.getTag();
+            if (entryTagObject == null || !(entryTagObject instanceof EntryTag)) {
+                Log.w(TAG, "EntryTag was not used correctly");
+                return;
+            }
+            final EntryTag entryTag = (EntryTag) entryTagObject;
+            final Intent intent = entryTag.getIntent();
+            final int dataId = entryTag.getId();
+            Log.d(TAG, "[onClick]intent = " + intent + ",dataId = " + dataId);
+            if (dataId == CARD_ENTRY_ID_EDIT_CONTACT) {
+                editContact();
+                return;
+            }
+
+            // Pass the touch point through the intent for use in the InCallUI
+            if (Intent.ACTION_CALL.equals(intent.getAction())) {
+                if (TouchPointManager.getInstance().hasValidPoint()) {
+                    Bundle extras = new Bundle();
+                    extras.putParcelable(TouchPointManager.TOUCH_POINT,
+                            TouchPointManager.getInstance().getPoint());
+                    intent.putExtra(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS, extras);
+                }
+            }
+
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            mHasIntentLaunched = true;
+            try {
+                ImplicitIntentsUtil.startActivityInAppIfPossible(QuickContactActivity.this, intent);
+            } catch (SecurityException ex) {
+                Toast.makeText(QuickContactActivity.this, R.string.missing_app,
+                        Toast.LENGTH_SHORT).show();
+                Log.e(TAG, "QuickContacts does not have permission to launch "
+                        + intent);
+            } catch (ActivityNotFoundException ex) {
+                Toast.makeText(QuickContactActivity.this, R.string.missing_app,
+                        Toast.LENGTH_SHORT).show();
+            }
+
+            // Default to USAGE_TYPE_CALL. Usage is summed among all types for sorting each data id
+            // so the exact usage type is not necessary in all cases
+            String usageType = DataUsageFeedback.USAGE_TYPE_CALL;
+
+            final Uri intentUri = intent.getData();
+            if ((intentUri != null && intentUri.getScheme() != null &&
+                    intentUri.getScheme().equals(ContactsUtils.SCHEME_SMSTO)) ||
+                    (intent.getType() != null && intent.getType().equals(MIMETYPE_SMS))) {
+                usageType = DataUsageFeedback.USAGE_TYPE_SHORT_TEXT;
+            }
+
+            // Data IDs start at 1 so anything less is invalid
+            if (dataId > 0) {
+                final Uri dataUsageUri = DataUsageFeedback.FEEDBACK_URI.buildUpon()
+                        .appendPath(String.valueOf(dataId))
+                        .appendQueryParameter(DataUsageFeedback.USAGE_TYPE, usageType)
+                        .build();
+                try {
+                final boolean successful = getContentResolver().update(
+                        dataUsageUri, new ContentValues(), null, null) > 0;
+                if (!successful) {
+                    Log.w(TAG, "DataUsageFeedback increment failed");
+                }
+                } catch (SecurityException ex) {
+                    Log.w(TAG, "DataUsageFeedback increment failed", ex);
+                }
+            } else {
+                Log.w(TAG, "Invalid Data ID");
+            }
+        }
+    };
+
+    final ExpandingEntryCardViewListener mExpandingEntryCardViewListener
+            = new ExpandingEntryCardViewListener() {
+        @Override
+        public void onCollapse(int heightDelta) {
+            mScroller.prepareForShrinkingScrollChild(heightDelta);
+        }
+
+        @Override
+        public void onExpand() {
+            mScroller.setDisableTouchesForSuppressLayout(/* areTouchesDisabled = */ true);
+        }
+
+        @Override
+        public void onExpandDone() {
+            mScroller.setDisableTouchesForSuppressLayout(/* areTouchesDisabled = */ false);
+        }
+    };
+
+    @Override
+    public void onAggregationSuggestionChange() {
+        Log.d(TAG, "[onAggregationSuggestionChange]");
+        if (mAggregationSuggestionEngine == null) {
+            return;
+        }
+        mSuggestions = mAggregationSuggestionEngine.getSuggestions();
+        mCollapsedSuggestionCardView.setVisibility(View.GONE);
+        mExpandSuggestionCardView.setVisibility(View.GONE);
+        mSuggestionList.removeAllViews();
+
+        if (mContactData == null) {
+            return;
+        }
+
+        final String suggestionForName = mContactData.getDisplayName();
+        final int suggestionNumber = mSuggestions.size();
+        Log.d(TAG, "[onAggregationSuggestionChange] suggestionNumber=" + suggestionNumber
+                + ", mSelectedAggregationIds=" + mSelectedAggregationIds);
+        if (suggestionNumber <= 0) {
+            mSelectedAggregationIds.clear();
+            return;
+        }
+
+        ContactPhotoManager.DefaultImageRequest
+                request = new ContactPhotoManager.DefaultImageRequest(
+                suggestionForName, mContactData.getLookupKey(), ContactPhotoManager.TYPE_DEFAULT,
+                /* isCircular */ true );
+        final long photoId = mContactData.getPhotoId();
+        final byte[] photoBytes = mContactData.getThumbnailPhotoBinaryData();
+        if (photoBytes != null) {
+            ContactPhotoManager.getInstance(this).loadThumbnail(mSuggestionSummaryPhoto, photoId,
+                /* darkTheme */ false , /* isCircular */ true , request);
+        } else {
+            ContactPhotoManager.DEFAULT_AVATAR.applyDefaultImage(mSuggestionSummaryPhoto,
+                    -1, false, request);
+        }
+
+        final String suggestionTitle = getResources().getQuantityString(
+                R.plurals.quickcontact_suggestion_card_title, suggestionNumber, suggestionNumber);
+        mCollapsedSuggestionCardTitle.setText(suggestionTitle);
+        mExpandSuggestionCardTitle.setText(suggestionTitle);
+
+        mSuggestionForName.setText(suggestionForName);
+        final int linkedContactsNumber = mContactData.getRawContacts().size();
+        final String contactsInfo;
+        final String accountName = mContactData.getRawContacts().get(0).getAccountName();
+        if (linkedContactsNumber == 1 && accountName == null) {
+            mSuggestionContactsNumber.setVisibility(View.INVISIBLE);
+        }
+        if (linkedContactsNumber == 1 && accountName != null) {
+            contactsInfo = getResources().getString(R.string.contact_from_account_name,
+                    accountName);
+        } else {
+            contactsInfo = getResources().getString(
+                    R.string.quickcontact_contacts_number, linkedContactsNumber);
+        }
+        mSuggestionContactsNumber.setText(contactsInfo);
+
+        final Set<Long> suggestionContactIds = new HashSet<>();
+        for (Suggestion suggestion : mSuggestions) {
+            mSuggestionList.addView(inflateSuggestionListView(suggestion));
+            suggestionContactIds.add(suggestion.contactId);
+        }
+        Log.d(TAG, "[onAggregationSuggestionChange]suggestionContactIds=" + suggestionContactIds);
+
+        if (mIsSuggestionListCollapsed) {
+            collapseSuggestionList();
+        } else {
+            expandSuggestionList();
+        }
+
+        // Remove contact Ids that are not suggestions.
+        final Set<Long> selectedSuggestionIds = com.google.common.collect.Sets.intersection(
+                mSelectedAggregationIds, suggestionContactIds);
+        mSelectedAggregationIds = new TreeSet<>(selectedSuggestionIds);
+        Log.d(TAG, "[onAggregationSuggestionChange]"
+                + "mSelectedAggregationIds = " + mSelectedAggregationIds);
+        if (!mSelectedAggregationIds.isEmpty()) {
+            enableLinkButton();
+        }
+
+        /// M: ALPS02783465. not show duplicate contacts for sim contact.@{
+        if (mContactData != null && mContactData.getIndicate() > 0) {
+            Log.d(TAG, "[onAggregationSuggestionChange] sim disable duplicate card View");
+            mCollapasedSuggestionHeader.setVisibility(View.GONE);
+            mCollapsedSuggestionCardView.setVisibility(View.GONE);
+        }
+        /// @}
+    }
+
+    private void collapseSuggestionList() {
+        mCollapsedSuggestionCardView.setVisibility(View.VISIBLE);
+        mExpandSuggestionCardView.setVisibility(View.GONE);
+        mIsSuggestionListCollapsed = true;
+    }
+
+    private void expandSuggestionList() {
+        mCollapsedSuggestionCardView.setVisibility(View.GONE);
+        mExpandSuggestionCardView.setVisibility(View.VISIBLE);
+        mIsSuggestionListCollapsed = false;
+    }
+
+    private View inflateSuggestionListView(final Suggestion suggestion) {
+        final LayoutInflater layoutInflater = LayoutInflater.from(this);
+        final View suggestionView = layoutInflater.inflate(
+                R.layout.quickcontact_suggestion_contact_item, null);
+
+        ContactPhotoManager.DefaultImageRequest
+                request = new ContactPhotoManager.DefaultImageRequest(
+                suggestion.name, suggestion.lookupKey, ContactPhotoManager.TYPE_DEFAULT, /*
+                isCircular */ true);
+        final ImageView photo = (ImageView) suggestionView.findViewById(
+                R.id.aggregation_suggestion_photo);
+        if (suggestion.photo != null) {
+            ContactPhotoManager.getInstance(this).loadThumbnail(photo, suggestion.photoId,
+                   /* darkTheme */ false, /* isCircular */ true, request);
+        } else {
+            ContactPhotoManager.DEFAULT_AVATAR.applyDefaultImage(photo, -1, false, request);
+        }
+
+        final TextView name = (TextView) suggestionView.findViewById(R.id.aggregation_suggestion_name);
+        name.setText(suggestion.name);
+
+        final TextView accountNameView = (TextView) suggestionView.findViewById(
+                R.id.aggregation_suggestion_account_name);
+        final String accountName = suggestion.rawContacts.get(0).accountName;
+        if (!TextUtils.isEmpty(accountName)) {
+            accountNameView.setText(
+                    getResources().getString(R.string.contact_from_account_name, accountName));
+        } else {
+            accountNameView.setVisibility(View.INVISIBLE);
+        }
+
+        final CheckBox checkbox = (CheckBox) suggestionView.findViewById(R.id.suggestion_checkbox);
+        final int[][] stateSet = new int[][] {
+                new int[] { android.R.attr.state_checked },
+                new int[] { -android.R.attr.state_checked }
+        };
+        final int[] colors = new int[] { mColorFilterColor, mColorFilterColor };
+        if (suggestion != null && suggestion.name != null) {
+            checkbox.setContentDescription(suggestion.name + " " +
+                    getResources().getString(R.string.contact_from_account_name, accountName));
+        }
+        checkbox.setButtonTintList(new ColorStateList(stateSet, colors));
+        checkbox.setChecked(mSuggestionsShouldAutoSelected ||
+                mSelectedAggregationIds.contains(suggestion.contactId));
+        if (checkbox.isChecked()) {
+            mSelectedAggregationIds.add(suggestion.contactId);
+        }
+        checkbox.setTag(suggestion.contactId);
+        checkbox.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                final CheckBox checkBox = (CheckBox) v;
+                final Long contactId = (Long) checkBox.getTag();
+                if (mSelectedAggregationIds.contains(mContactData.getId())) {
+                    mSelectedAggregationIds.remove(mContactData.getId());
+                }
+                if (checkBox.isChecked()) {
+                    mSelectedAggregationIds.add(contactId);
+                    if (mSelectedAggregationIds.size() >= 1) {
+                        enableLinkButton();
+                    }
+                } else {
+                    mSelectedAggregationIds.remove(contactId);
+                    mSuggestionsShouldAutoSelected = false;
+                    if (mSelectedAggregationIds.isEmpty()) {
+                        disableLinkButton();
+                    }
+                }
+            }
+        });
+
+        return suggestionView;
+    }
+
+    private void enableLinkButton() {
+        mSuggestionsLinkButton.setClickable(true);
+        mSuggestionsLinkButton.getBackground().setColorFilter(mColorFilter);
+        mSuggestionsLinkButton.setTextColor(
+                ContextCompat.getColor(this, android.R.color.white));
+        mSuggestionsLinkButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                Log.d(TAG, "click link button, mContactData.getId()=" + mContactData.getId()
+                        + ", mSelectedAggregationIds=" + mSelectedAggregationIds);
+                // Join selected contacts.
+                if (!mSelectedAggregationIds.contains(mContactData.getId())) {
+                    mSelectedAggregationIds.add(mContactData.getId());
+                }
+                JoinContactsDialogFragment.start(
+                        QuickContactActivity.this, mSelectedAggregationIds);
+            }
+        });
+    }
+
+    @Override
+    public void onContactsJoined() {
+        disableLinkButton();
+    }
+
+    private void disableLinkButton() {
+        mSuggestionsLinkButton.setClickable(false);
+        mSuggestionsLinkButton.getBackground().setColorFilter(
+                ContextCompat.getColor(this, R.color.disabled_button_background),
+                PorterDuff.Mode.SRC_ATOP);
+        mSuggestionsLinkButton.setTextColor(
+                ContextCompat.getColor(this, R.color.disabled_button_text));
+    }
+
+    private interface ContextMenuIds {
+        static final int COPY_TEXT = 0;
+        static final int CLEAR_DEFAULT = 1;
+        static final int SET_DEFAULT = 2;
+        /// M: add ip call
+        static final int IP_CALL = 3;
+    }
+
+    private final OnCreateContextMenuListener mEntryContextMenuListener =
+            new OnCreateContextMenuListener() {
+        @Override
+        public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
+            if (menuInfo == null) {
+                return;
+            }
+            final EntryContextMenuInfo info = (EntryContextMenuInfo) menuInfo;
+            menu.setHeaderTitle(info.getCopyText());
+            /// M: add ip call
+            if (Phone.CONTENT_ITEM_TYPE.equals(info.getMimeType()) &&
+                    PhoneCapabilityTester.isPhone(ContactsApplication.getInstance())) {
+                menu.add(ContextMenu.NONE, ContextMenuIds.IP_CALL,
+                    ContextMenu.NONE, getString(R.string.contact_detail_ip_call));
+            }
+            menu.add(ContextMenu.NONE, ContextMenuIds.COPY_TEXT,
+                    ContextMenu.NONE, getString(R.string.copy_text));
+
+            // Don't allow setting or clearing of defaults for non-editable contacts
+            if (!isContactEditable()) {
+                return;
+            }
+
+            final String selectedMimeType = info.getMimeType();
+
+            // Defaults to true will only enable the detail to be copied to the clipboard.
+            boolean onlyOneOfMimeType = true;
+
+            // Only allow primary support for Phone and Email content types
+            if (Phone.CONTENT_ITEM_TYPE.equals(selectedMimeType)) {
+                onlyOneOfMimeType = mOnlyOnePhoneNumber;
+            } else if (Email.CONTENT_ITEM_TYPE.equals(selectedMimeType)) {
+                onlyOneOfMimeType = mOnlyOneEmail;
+            }
+
+            // Checking for previously set default
+            if (info.isSuperPrimary()) {
+                menu.add(ContextMenu.NONE, ContextMenuIds.CLEAR_DEFAULT,
+                        ContextMenu.NONE, getString(R.string.clear_default));
+            } else if (!onlyOneOfMimeType) {
+                menu.add(ContextMenu.NONE, ContextMenuIds.SET_DEFAULT,
+                        ContextMenu.NONE, getString(R.string.set_default));
+            }
+        }
+    };
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        EntryContextMenuInfo menuInfo;
+        try {
+            menuInfo = (EntryContextMenuInfo) item.getMenuInfo();
+        } catch (ClassCastException e) {
+            Log.e(TAG, "bad menuInfo", e);
+            return false;
+        }
+
+        switch (item.getItemId()) {
+            /// M: add ip call
+            case ContextMenuIds.IP_CALL:
+                QuickContactUtils.dialIpCall(this, menuInfo.getCopyText());
+                return true;
+            case ContextMenuIds.COPY_TEXT:
+                ClipboardUtils.copyText(this, menuInfo.getCopyLabel(), menuInfo.getCopyText(),
+                        true);
+                return true;
+            case ContextMenuIds.SET_DEFAULT:
+                final Intent setIntent = ContactSaveService.createSetSuperPrimaryIntent(this,
+                        menuInfo.getId());
+                this.startService(setIntent);
+                return true;
+            case ContextMenuIds.CLEAR_DEFAULT:
+                final Intent clearIntent = ContactSaveService.createClearPrimaryIntent(this,
+                        menuInfo.getId());
+                this.startService(clearIntent);
+                return true;
+            default:
+                throw new IllegalArgumentException("Unknown menu option " + item.getItemId());
+        }
+    }
+
+    /**
+     * Headless fragment used to handle account selection callbacks invoked from
+     * {@link DirectoryContactUtil}.
+     */
+    public static class SelectAccountDialogFragmentListener extends Fragment
+            implements SelectAccountDialogFragment.Listener {
+
+        private QuickContactActivity mQuickContactActivity;
+
+        public SelectAccountDialogFragmentListener() {}
+
+        @Override
+        public void onAccountChosen(AccountWithDataSet account, Bundle extraArgs) {
+            DirectoryContactUtil.createCopy(mQuickContactActivity.mContactData.getContentValues(),
+                    account, mQuickContactActivity);
+        }
+
+        @Override
+        public void onAccountSelectorCancelled() {}
+
+        /**
+         * Set the parent activity. Since rotation can cause this fragment to be used across
+         * more than one activity instance, we need to explicitly set this value instead
+         * of making this class non-static.
+         */
+        public void setQuickContactActivity(QuickContactActivity quickContactActivity) {
+            mQuickContactActivity = quickContactActivity;
+        }
+    }
+
+    final MultiShrinkScrollerListener mMultiShrinkScrollerListener
+            = new MultiShrinkScrollerListener() {
+        @Override
+        public void onScrolledOffBottom() {
+            finish();
+        }
+
+        @Override
+        public void onEnterFullscreen() {
+            updateStatusBarColor();
+        }
+
+        @Override
+        public void onExitFullscreen() {
+            updateStatusBarColor();
+        }
+
+        @Override
+        public void onStartScrollOffBottom() {
+            mIsExitAnimationInProgress = true;
+        }
+
+        @Override
+        public void onEntranceAnimationDone() {
+            mIsEntranceAnimationFinished = true;
+        }
+
+        @Override
+        public void onTransparentViewHeightChange(float ratio) {
+            if (mIsEntranceAnimationFinished) {
+                mWindowScrim.setAlpha((int) (0xFF * ratio));
+            }
+        }
+    };
+
+
+    /**
+     * Data items are compared to the same mimetype based off of three qualities:
+     * 1. Super primary
+     * 2. Primary
+     * 3. Times used
+     */
+    private final Comparator<DataItem> mWithinMimeTypeDataItemComparator =
+            new Comparator<DataItem>() {
+        @Override
+        public int compare(DataItem lhs, DataItem rhs) {
+            if (!lhs.getMimeType().equals(rhs.getMimeType())) {
+                Log.wtf(TAG, "Comparing DataItems with different mimetypes lhs.getMimeType(): " +
+                        lhs.getMimeType() + " rhs.getMimeType(): " + rhs.getMimeType());
+                return 0;
+            }
+
+            if (lhs.isSuperPrimary()) {
+                return -1;
+            } else if (rhs.isSuperPrimary()) {
+                return 1;
+            } else if (lhs.isPrimary() && !rhs.isPrimary()) {
+                return -1;
+            } else if (!lhs.isPrimary() && rhs.isPrimary()) {
+                return 1;
+            } else {
+                final int lhsTimesUsed =
+                        lhs.getTimesUsed() == null ? 0 : lhs.getTimesUsed();
+                final int rhsTimesUsed =
+                        rhs.getTimesUsed() == null ? 0 : rhs.getTimesUsed();
+
+                return rhsTimesUsed - lhsTimesUsed;
+            }
+        }
+    };
+
+    /**
+     * Sorts among different mimetypes based off:
+     * 1. Whether one of the mimetypes is the prioritized mimetype
+     * 2. Number of times used
+     * 3. Last time used
+     * 4. Statically defined
+     */
+    private final Comparator<List<DataItem>> mAmongstMimeTypeDataItemComparator =
+            new Comparator<List<DataItem>> () {
+        @Override
+        public int compare(List<DataItem> lhsList, List<DataItem> rhsList) {
+            final DataItem lhs = lhsList.get(0);
+            final DataItem rhs = rhsList.get(0);
+            final String lhsMimeType = lhs.getMimeType();
+            final String rhsMimeType = rhs.getMimeType();
+
+            // 1. Whether one of the mimetypes is the prioritized mimetype
+            if (!TextUtils.isEmpty(mExtraPrioritizedMimeType) && !lhsMimeType.equals(rhsMimeType)) {
+                if (rhsMimeType.equals(mExtraPrioritizedMimeType)) {
+                    return 1;
+                }
+                if (lhsMimeType.equals(mExtraPrioritizedMimeType)) {
+                    return -1;
+                }
+            }
+
+            // 2. Number of times used
+            final int lhsTimesUsed = lhs.getTimesUsed() == null ? 0 : lhs.getTimesUsed();
+            final int rhsTimesUsed = rhs.getTimesUsed() == null ? 0 : rhs.getTimesUsed();
+            final int timesUsedDifference = rhsTimesUsed - lhsTimesUsed;
+            if (timesUsedDifference != 0) {
+                return timesUsedDifference;
+            }
+
+            // 3. Last time used
+            final long lhsLastTimeUsed =
+                    lhs.getLastTimeUsed() == null ? 0 : lhs.getLastTimeUsed();
+            final long rhsLastTimeUsed =
+                    rhs.getLastTimeUsed() == null ? 0 : rhs.getLastTimeUsed();
+            final long lastTimeUsedDifference = rhsLastTimeUsed - lhsLastTimeUsed;
+            if (lastTimeUsedDifference > 0) {
+                return 1;
+            } else if (lastTimeUsedDifference < 0) {
+                return -1;
+            }
+
+            // 4. Resort to a statically defined mimetype order.
+            if (!lhsMimeType.equals(rhsMimeType)) {
+            for (String mimeType : LEADING_MIMETYPES) {
+                if (lhsMimeType.equals(mimeType)) {
+                    return -1;
+                } else if (rhsMimeType.equals(mimeType)) {
+                    return 1;
+                }
+            }
+            }
+            return 0;
+        }
+    };
+
+    @Override
+    public boolean dispatchTouchEvent(MotionEvent ev) {
+        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
+            TouchPointManager.getInstance().setPoint((int) ev.getRawX(), (int) ev.getRawY());
+        }
+        return super.dispatchTouchEvent(ev);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        Trace.beginSection("onCreate()");
+        super.onCreate(savedInstanceState);
+
+        if (RequestPermissionsActivity.startPermissionActivity(this) ||
+                RequestDesiredPermissionsActivity.startPermissionActivity(this)) {
+            return;
+        }
+
+        final int previousScreenType = getIntent().getIntExtra
+                (EXTRA_PREVIOUS_SCREEN_TYPE, ScreenType.UNKNOWN);
+        Logger.logScreenView(this, ScreenType.QUICK_CONTACT, previousScreenType);
+
+        if (CompatUtils.isLollipopCompatible()) {
+            getWindow().setStatusBarColor(Color.TRANSPARENT);
+        }
+
+        processIntent(getIntent());
+
+        // Show QuickContact in front of soft input
+         getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+
+        setContentView(R.layout.quickcontact_activity);
+
+        mMaterialColorMapUtils = new MaterialColorMapUtils(getResources());
+
+        mScroller = (MultiShrinkScroller) findViewById(R.id.multiscroller);
+
+        mContactCard = (ExpandingEntryCardView) findViewById(R.id.communication_card);
+        /// M: [for rcs-e]
+        mJoynCard = (ExpandingEntryCardView) ExtensionManager.getInstance()
+            .getViewCustomExtension().getQuickContactCardViewCustom().createCardView(
+                    (LinearLayout)findViewById(R.id.card_container),
+                    (View) mContactCard, mLookupUri, this);
+        mNoContactDetailsCard = (ExpandingEntryCardView) findViewById(R.id.no_contact_data_card);
+        mRecentCard = (ExpandingEntryCardView) findViewById(R.id.recent_card);
+        mAboutCard = (ExpandingEntryCardView) findViewById(R.id.about_card);
+
+        mCollapsedSuggestionCardView = (CardView) findViewById(R.id.collapsed_suggestion_card);
+        mExpandSuggestionCardView = (CardView) findViewById(R.id.expand_suggestion_card);
+        mCollapasedSuggestionHeader = findViewById(R.id.collapsed_suggestion_header);
+        mCollapsedSuggestionCardTitle = (TextView) findViewById(
+                R.id.collapsed_suggestion_card_title);
+        mExpandSuggestionCardTitle = (TextView) findViewById(R.id.expand_suggestion_card_title);
+        mSuggestionSummaryPhoto = (ImageView) findViewById(R.id.suggestion_icon);
+        mSuggestionForName = (TextView) findViewById(R.id.suggestion_for_name);
+        mSuggestionContactsNumber = (TextView) findViewById(R.id.suggestion_for_contacts_number);
+        mSuggestionList = (LinearLayout) findViewById(R.id.suggestion_list);
+        mSuggestionsCancelButton= (Button) findViewById(R.id.cancel_button);
+        mSuggestionsLinkButton = (Button) findViewById(R.id.link_button);
+        if (savedInstanceState != null) {
+            mIsSuggestionListCollapsed = savedInstanceState.getBoolean(
+                    KEY_IS_SUGGESTION_LIST_COLLAPSED, true);
+            mPreviousContactId = savedInstanceState.getLong(KEY_PREVIOUS_CONTACT_ID);
+            mSuggestionsShouldAutoSelected = savedInstanceState.getBoolean(
+                    KEY_SUGGESTIONS_AUTO_SELECTED, true);
+            mSelectedAggregationIds = (TreeSet<Long>)
+                    savedInstanceState.getSerializable(KEY_SELECTED_SUGGESTION_CONTACTS);
+        } else {
+            mIsSuggestionListCollapsed = true;
+            mSelectedAggregationIds.clear();
+        }
+        if (mSelectedAggregationIds.isEmpty()) {
+            disableLinkButton();
+        } else {
+            enableLinkButton();
+        }
+        mCollapasedSuggestionHeader.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                mCollapsedSuggestionCardView.setVisibility(View.GONE);
+                mExpandSuggestionCardView.setVisibility(View.VISIBLE);
+                mIsSuggestionListCollapsed = false;
+                mExpandSuggestionCardTitle.requestFocus();
+                mExpandSuggestionCardTitle.sendAccessibilityEvent(
+                        AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+            }
+        });
+
+        mSuggestionsCancelButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                mCollapsedSuggestionCardView.setVisibility(View.VISIBLE);
+                mExpandSuggestionCardView.setVisibility(View.GONE);
+                mIsSuggestionListCollapsed = true;
+            }
+        });
+
+        mNoContactDetailsCard.setOnClickListener(mEntryClickHandler);
+        mContactCard.setOnClickListener(mEntryClickHandler);
+        mContactCard.setExpandButtonText(
+        getResources().getString(R.string.expanding_entry_card_view_see_all));
+        mContactCard.setOnCreateContextMenuListener(mEntryContextMenuListener);
+
+        mRecentCard.setOnClickListener(mEntryClickHandler);
+        mRecentCard.setTitle(getResources().getString(R.string.recent_card_title));
+
+        mAboutCard.setOnClickListener(mEntryClickHandler);
+        mAboutCard.setOnCreateContextMenuListener(mEntryContextMenuListener);
+
+        mPhotoView = (QuickContactImageView) findViewById(R.id.photo);
+
+        //M:OP01 RCS will go to contact detail activity, update photo from rcs server.@{
+        ExtensionManager.getInstance().getRcsExtension()
+                .updateContactPhotoFromRcsServer(mLookupUri, mPhotoView, this);
+        /** @} */
+
+        final View transparentView = findViewById(R.id.transparent_view);
+        if (mScroller != null) {
+            transparentView.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mScroller.scrollOffBottom();
+                }
+            });
+        }
+
+        // Allow a shadow to be shown under the toolbar.
+        ViewUtil.addRectangularOutlineProvider(findViewById(R.id.toolbar_parent), getResources());
+
+        final Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        setActionBar(toolbar);
+        getActionBar().setTitle(null);
+        // Put a TextView with a known resource id into the ActionBar. This allows us to easily
+        // find the correct TextView location & size later.
+        toolbar.addView(getLayoutInflater().inflate(R.layout.quickcontact_title_placeholder, null));
+
+        mHasAlreadyBeenOpened = savedInstanceState != null;
+        mIsEntranceAnimationFinished = mHasAlreadyBeenOpened;
+        mWindowScrim = new ColorDrawable(SCRIM_COLOR);
+        mWindowScrim.setAlpha(0);
+        getWindow().setBackgroundDrawable(mWindowScrim);
+
+        mScroller.initialize(mMultiShrinkScrollerListener, mExtraMode == MODE_FULLY_EXPANDED,
+                /* maximumHeaderTextSize */ -1,
+                /* shouldUpdateNameViewHeight */ true);
+        // mScroller needs to perform asynchronous measurements after initalize(), therefore
+        // we can't mark this as GONE.
+        mScroller.setVisibility(View.INVISIBLE);
+
+        setHeaderNameText(R.string.missing_name);
+
+        mSelectAccountFragmentListener= (SelectAccountDialogFragmentListener) getFragmentManager()
+                .findFragmentByTag(FRAGMENT_TAG_SELECT_ACCOUNT);
+        if (mSelectAccountFragmentListener == null) {
+            mSelectAccountFragmentListener = new SelectAccountDialogFragmentListener();
+            getFragmentManager().beginTransaction().add(0, mSelectAccountFragmentListener,
+                    FRAGMENT_TAG_SELECT_ACCOUNT).commit();
+            mSelectAccountFragmentListener.setRetainInstance(true);
+        }
+        mSelectAccountFragmentListener.setQuickContactActivity(this);
+
+        SchedulingUtils.doOnPreDraw(mScroller, /* drawNextFrame = */ true,
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        if (!mHasAlreadyBeenOpened) {
+                            // The initial scrim opacity must match the scrim opacity that would be
+                            // achieved by scrolling to the starting position.
+                            final float alphaRatio = mExtraMode == MODE_FULLY_EXPANDED ?
+                                    1 : mScroller.getStartingTransparentHeightRatio();
+                            final int duration = getResources().getInteger(
+                                    android.R.integer.config_shortAnimTime);
+                            final int desiredAlpha = (int) (0xFF * alphaRatio);
+                            ObjectAnimator o = ObjectAnimator.ofInt(mWindowScrim, "alpha", 0,
+                                    desiredAlpha).setDuration(duration);
+
+                            o.start();
+                        }
+                    }
+                });
+
+        if (savedInstanceState != null) {
+            final int color = savedInstanceState.getInt(KEY_THEME_COLOR, 0);
+            SchedulingUtils.doOnPreDraw(mScroller, /* drawNextFrame = */ false,
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            // Need to wait for the pre draw before setting the initial scroll
+                            // value. Prior to pre draw all scroll values are invalid.
+                            if (mHasAlreadyBeenOpened) {
+                                mScroller.setVisibility(View.VISIBLE);
+                                mScroller.setScroll(mScroller.getScrollNeededToBeFullScreen());
+                            }
+                            // Need to wait for pre draw for setting the theme color. Setting the
+                            // header tint before the MultiShrinkScroller has been measured will
+                            // cause incorrect tinting calculations.
+                            if (color != 0) {
+                                setThemeColor(mMaterialColorMapUtils
+                                        .calculatePrimaryAndSecondaryColor(color));
+                            }
+                        }
+                    });
+        }
+        Trace.endSection();
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Log.d(TAG, "[onActivityResult] requestCode is " + requestCode
+                + ", resultCode is " + resultCode);
+        final boolean deletedOrSplit = requestCode == REQUEST_CODE_CONTACT_EDITOR_ACTIVITY &&
+                (resultCode == ContactDeletionInteraction.RESULT_CODE_DELETED ||
+                resultCode == ContactEditorBaseActivity.RESULT_CODE_SPLIT);
+        if (deletedOrSplit) {
+            finish();
+        } else if (requestCode == REQUEST_CODE_CONTACT_SELECTION_ACTIVITY &&
+                resultCode != RESULT_CANCELED) {
+            /* M: [Google Issue]ALPS03375904
+             * fix photo view display issue (tint and image blend together),
+             * needs to re-compute theme color @{ */
+            mHasComputedThemeColor = false;
+            /* @} */
+            processIntent(data);
+        }
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+        Log.d(TAG, "[onNewIntent]");
+        mHasAlreadyBeenOpened = true;
+        mIsEntranceAnimationFinished = true;
+        mHasComputedThemeColor = false;
+        processIntent(intent);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle savedInstanceState) {
+        super.onSaveInstanceState(savedInstanceState);
+        if (mColorFilter != null) {
+            savedInstanceState.putInt(KEY_THEME_COLOR, mColorFilterColor);
+        }
+        savedInstanceState.putBoolean(KEY_IS_SUGGESTION_LIST_COLLAPSED, mIsSuggestionListCollapsed);
+        savedInstanceState.putLong(KEY_PREVIOUS_CONTACT_ID, mPreviousContactId);
+        savedInstanceState.putBoolean(
+                KEY_SUGGESTIONS_AUTO_SELECTED, mSuggestionsShouldAutoSelected);
+        savedInstanceState.putSerializable(
+                KEY_SELECTED_SUGGESTION_CONTACTS, mSelectedAggregationIds);
+    }
+
+    private void processIntent(Intent intent) {
+        if (intent == null) {
+            Log.w(TAG, "[processIntent]intent is null,return!");
+            finish();
+            return;
+        }
+        Uri lookupUri = intent.getData();
+        Log.d(TAG, "The original uri from intent: " + lookupUri);
+
+        // Check to see whether it comes from the old version.
+        if (lookupUri != null && LEGACY_AUTHORITY.equals(lookupUri.getAuthority())) {
+            final long rawContactId = ContentUris.parseId(lookupUri);
+            lookupUri = RawContacts.getContactLookupUri(getContentResolver(),
+                    ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactId));
+            Log.d(TAG, "The uri from old version: " + lookupUri);
+        }
+        mExtraMode = getIntent().getIntExtra(QuickContact.EXTRA_MODE, QuickContact.MODE_LARGE);
+        if (isMultiWindowOnPhone()) {
+            mExtraMode = QuickContact.MODE_LARGE;
+        }
+        mExtraPrioritizedMimeType =
+                getIntent().getStringExtra(QuickContact.EXTRA_PRIORITIZED_MIMETYPE);
+        final Uri oldLookupUri = mLookupUri;
+
+        if (lookupUri == null) {
+            Log.w(TAG, "[processIntent]lookupUri is null,return!");
+            finish();
+            return;
+        }
+        mLookupUri = lookupUri;
+        Log.d(TAG, "[processIntent] original uri is oldLookupUri = " + oldLookupUri
+                + ", new uri from intent is mLookupUri = " + mLookupUri);
+        mExcludeMimes = intent.getStringArrayExtra(QuickContact.EXTRA_EXCLUDE_MIMES);
+        if (oldLookupUri == null) {
+            mContactLoader = (ContactLoader) getLoaderManager().initLoader(
+                    LOADER_CONTACT_ID, null, mLoaderContactCallbacks);
+        } else if (oldLookupUri != mLookupUri) {
+            // After copying a directory contact, the contact URI changes. Therefore,
+            // we need to reload the new contact.
+            destroyInteractionLoaders();
+            mContactLoader = (ContactLoader) (Loader<?>) getLoaderManager().getLoader(
+                    LOADER_CONTACT_ID);
+            mContactLoader.setLookupUri(mLookupUri);
+            mCachedCp2DataCardModel = null;
+        }
+        mContactLoader.forceLoad();
+
+        NfcHandler.register(this, mLookupUri);
+
+        // M: Add for presence @{
+        ExtensionManager.getInstance().getContactsCommonPresenceExtension().processIntent(intent);
+    }
+
+    private void destroyInteractionLoaders() {
+        for (int interactionLoaderId : mRecentLoaderIds) {
+            getLoaderManager().destroyLoader(interactionLoaderId);
+        }
+    }
+
+    private void runEntranceAnimation() {
+        if (mHasAlreadyBeenOpened) {
+            return;
+        }
+        mHasAlreadyBeenOpened = true;
+        mScroller.scrollUpForEntranceAnimation(/* scrollToCurrentPosition */ !isMultiWindowOnPhone()
+                && (mExtraMode != MODE_FULLY_EXPANDED));
+    }
+
+    private boolean isMultiWindowOnPhone() {
+        return MultiWindowCompat.isInMultiWindowMode(this) && PhoneCapabilityTester.isPhone(this);
+    }
+
+    /** Assign this string to the view if it is not empty. */
+    private void setHeaderNameText(int resId) {
+        if (mScroller != null) {
+            mScroller.setTitle(getText(resId) == null ? null : getText(resId).toString(),
+                    /* isPhoneNumber= */ false);
+        }
+    }
+
+    /** Assign this string to the view if it is not empty. */
+    private void setHeaderNameText(String value, boolean isPhoneNumber) {
+        if (!TextUtils.isEmpty(value)) {
+            if (mScroller != null) {
+                mScroller.setTitle(value, isPhoneNumber);
+            }
+        }
+    }
+
+    /**
+     * Check if the given MIME-type appears in the list of excluded MIME-types
+     * that the most-recent caller requested.
+     */
+    private boolean isMimeExcluded(String mimeType) {
+        if (mExcludeMimes == null) return false;
+        for (String excludedMime : mExcludeMimes) {
+            if (TextUtils.equals(excludedMime, mimeType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Handle the result from the ContactLoader
+     */
+    private void bindContactData(final Contact data) {
+        Log.d(TAG, "[bindContactData]");
+        Trace.beginSection("bindContactData");
+        mContactData = data;
+        invalidateOptionsMenu();
+
+        Trace.endSection();
+        Trace.beginSection("Set display photo & name");
+
+        mPhotoView.setIsBusiness(mContactData.isDisplayNameFromOrganization());
+        mPhotoSetter.setupContactPhoto(data, mPhotoView);
+        extractAndApplyTintFromPhotoViewAsynchronously();
+        final String displayName = ContactDisplayUtils.getDisplayName(this, data).toString();
+        setHeaderNameText(
+                displayName, mContactData.getDisplayNameSource() == DisplayNameSources.PHONE);
+        final String phoneticName = ContactDisplayUtils.getPhoneticName(this, data);
+        if (mScroller != null) {
+            // Show phonetic name only when it doesn't equal the display name.
+            if (!TextUtils.isEmpty(phoneticName) && !phoneticName.equals(displayName)) {
+                mScroller.setPhoneticName(phoneticName);
+            } else {
+                mScroller.setPhoneticNameGone();
+            }
+        }
+
+        Trace.endSection();
+
+        mEntriesAndActionsTask = new AsyncTask<Void, Void, Cp2DataCardModel>() {
+
+            @Override
+            protected Cp2DataCardModel doInBackground(
+                    Void... params) {
+                Log.d(TAG, "[Cp2DataCardModel] doInBackground");
+                return generateDataModelFromContact(data);
+            }
+
+            @Override
+            protected void onPostExecute(Cp2DataCardModel cardDataModel) {
+                super.onPostExecute(cardDataModel);
+                // Check that original AsyncTask parameters are still valid and the activity
+                // is still running before binding to UI. A new intent could invalidate
+                // the results, for example.
+                Log.d(TAG, "[Cp2DataCardModel] onPostExecute");
+                if (data == mContactData && !isCancelled()) {
+                    bindDataToCards(cardDataModel);
+                    showActivity();
+                ///M:[Google Issue][ALPS03391875] save DataModel event activity stopped @{
+                } else {
+                    Log.e(TAG, "[Cp2DataCardModel] Async task cancelled !!! isCancelled():" +
+                            isCancelled() + ", data:" + data + ", mContactData:" + mContactData);
+                    mCachedCp2DataCardModel = cardDataModel;
+                /// @}
+                }
+            }
+        };
+        mEntriesAndActionsTask.execute();
+        Log.d(TAG, "[bindContactData] mEntriesAndActionsTask.execute()");
+    }
+
+    private void bindDataToCards(Cp2DataCardModel cp2DataCardModel) {
+        startInteractionLoaders(cp2DataCardModel);
+        populateContactAndAboutCard(cp2DataCardModel, /* shouldAddPhoneticName */ true);
+        populateSuggestionCard();
+    }
+
+    private void startInteractionLoaders(Cp2DataCardModel cp2DataCardModel) {
+        final Map<String, List<DataItem>> dataItemsMap = cp2DataCardModel.dataItemsMap;
+        final List<DataItem> phoneDataItems = dataItemsMap.get(Phone.CONTENT_ITEM_TYPE);
+        if (phoneDataItems != null) {
+            /// M: Reset the value as the size may change,
+            //  otherwise when size > 1, the value will always be true.
+            mOnlyOnePhoneNumber = phoneDataItems.size() == 1 ? true : false;
+        }
+        String[] phoneNumbers = null;
+        if (phoneDataItems != null) {
+            phoneNumbers = new String[phoneDataItems.size()];
+            for (int i = 0; i < phoneDataItems.size(); ++i) {
+                phoneNumbers[i] = ((PhoneDataItem) phoneDataItems.get(i)).getNumber();
+            }
+        }
+        final Bundle phonesExtraBundle = new Bundle();
+        phonesExtraBundle.putStringArray(KEY_LOADER_EXTRA_PHONES, phoneNumbers);
+
+        Trace.beginSection("start sms loader");
+        getLoaderManager().initLoader(
+                LOADER_SMS_ID,
+                phonesExtraBundle,
+                mLoaderInteractionsCallbacks);
+        Trace.endSection();
+
+        Trace.beginSection("start call log loader");
+        getLoaderManager().initLoader(
+                LOADER_CALL_LOG_ID,
+                phonesExtraBundle,
+                mLoaderInteractionsCallbacks);
+        Trace.endSection();
+
+
+        Trace.beginSection("start calendar loader");
+        final List<DataItem> emailDataItems = dataItemsMap.get(Email.CONTENT_ITEM_TYPE);
+        if (emailDataItems != null) {
+            /// M: Reset the value as the size may change,
+            //  otherwise when size > 1, the value will always be true.
+            mOnlyOneEmail = emailDataItems.size() == 1 ? true : false;
+        }
+        String[] emailAddresses = null;
+        if (emailDataItems != null) {
+            emailAddresses = new String[emailDataItems.size()];
+            for (int i = 0; i < emailDataItems.size(); ++i) {
+                emailAddresses[i] = ((EmailDataItem) emailDataItems.get(i)).getAddress();
+            }
+        }
+        final Bundle emailsExtraBundle = new Bundle();
+        emailsExtraBundle.putStringArray(KEY_LOADER_EXTRA_EMAILS, emailAddresses);
+        getLoaderManager().initLoader(
+                LOADER_CALENDAR_ID,
+                emailsExtraBundle,
+                mLoaderInteractionsCallbacks);
+        Trace.endSection();
+    }
+
+    private void showActivity() {
+        Log.d(TAG, "[showActivity]");
+        if (mScroller != null) {
+            mScroller.setVisibility(View.VISIBLE);
+            SchedulingUtils.doOnPreDraw(mScroller, /* drawNextFrame = */ false,
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            runEntranceAnimation();
+                        }
+                    });
+        }
+    }
+
+    private List<List<Entry>> buildAboutCardEntries(Map<String, List<DataItem>> dataItemsMap) {
+        final List<List<Entry>> aboutCardEntries = new ArrayList<>();
+        for (String mimetype : SORTED_ABOUT_CARD_MIMETYPES) {
+            final List<DataItem> mimeTypeItems = dataItemsMap.get(mimetype);
+            if (mimeTypeItems == null) {
+                continue;
+            }
+            // Set aboutCardTitleOut = null, since SORTED_ABOUT_CARD_MIMETYPES doesn't contain
+            // the name mimetype.
+            final List<Entry> aboutEntries = dataItemsToEntries(mimeTypeItems,
+                    /* aboutCardTitleOut = */ null);
+            if (aboutEntries.size() > 0) {
+                aboutCardEntries.add(aboutEntries);
+            }
+        }
+        return aboutCardEntries;
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        // If returning from a launched activity, repopulate the contact and about card
+        if (mHasIntentLaunched) {
+            mHasIntentLaunched = false;
+            populateContactAndAboutCard(mCachedCp2DataCardModel, /* shouldAddPhoneticName */ false);
+        }
+
+        // When exiting the activity and resuming, we want to force a full reload of all the
+        // interaction data in case something changed in the background. On screen rotation,
+        // we don't need to do this. And, mCachedCp2DataCardModel will be null, so we won't.
+        if (mCachedCp2DataCardModel != null) {
+            destroyInteractionLoaders();
+            startInteractionLoaders(mCachedCp2DataCardModel);
+        }
+        ///M:[for rcs] update Rcs contact on the top left@{
+        ExtensionManager.getInstance().getRcsExtension()
+                .getQuickContactRcsScroller()
+                .updateRcsContact(mContactLoader.getLookupUri(), false);
+        ///@}
+    }
+
+    private void populateSuggestionCard() {
+        Log.d(TAG, "[populateSuggestionCard] mPreviousContactId = " + mPreviousContactId
+                + ", mContactData.getId()" + mContactData.getId());
+
+        // Initialize suggestion related view and data.
+        if (mPreviousContactId != mContactData.getId()) {
+            mCollapsedSuggestionCardView.setVisibility(View.GONE);
+            mExpandSuggestionCardView.setVisibility(View.GONE);
+            mIsSuggestionListCollapsed = true;
+            mSuggestionsShouldAutoSelected = true;
+            mSuggestionList.removeAllViews();
+        }
+
+        // Do not show the card when it's directory contact or invisible.
+        if (DirectoryContactUtil.isDirectoryContact(mContactData)
+                || InvisibleContactUtil.isInvisibleAndAddable(mContactData, this)) {
+            return;
+        }
+
+        if (mAggregationSuggestionEngine == null) {
+            mAggregationSuggestionEngine = new AggregationSuggestionEngine(this);
+            mAggregationSuggestionEngine.setListener(this);
+            mAggregationSuggestionEngine.setSuggestionsLimit(getResources().getInteger(
+                    R.integer.quickcontact_suggestions_limit));
+            mAggregationSuggestionEngine.start();
+        }
+
+        mAggregationSuggestionEngine.setContactId(mContactData.getId());
+        if (mPreviousContactId != 0
+                && mPreviousContactId != mContactData.getId()) {
+            // Clear selected Ids when listing suggestions for new contact Id.
+            mSelectedAggregationIds.clear();
+        }
+        mPreviousContactId = mContactData.getId();
+
+        // Trigger suggestion engine to compute suggestions.
+        if (mContactData.getId() <= 0) {
+            return;
+        }
+        final ContentValues values = new ContentValues();
+        values.put(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,
+                mContactData.getDisplayName());
+        values.put(ContactsContract.CommonDataKinds.StructuredName.PHONETIC_FAMILY_NAME,
+                mContactData.getPhoneticName());
+        mAggregationSuggestionEngine.onNameChange(ValuesDelta.fromBefore(values));
+    }
+
+    private void populateContactAndAboutCard(Cp2DataCardModel cp2DataCardModel,
+            boolean shouldAddPhoneticName) {
+        mCachedCp2DataCardModel = cp2DataCardModel;
+        if (mHasIntentLaunched || cp2DataCardModel == null) {
+            return;
+        }
+        Trace.beginSection("bind contact card");
+
+        final List<List<Entry>> contactCardEntries = cp2DataCardModel.contactCardEntries;
+        final List<List<Entry>> aboutCardEntries = cp2DataCardModel.aboutCardEntries;
+        final String customAboutCardName = cp2DataCardModel.customAboutCardName;
+
+        if (contactCardEntries.size() > 0) {
+            final boolean firstEntriesArePrioritizedMimeType =
+                    !TextUtils.isEmpty(mExtraPrioritizedMimeType) &&
+                    mCachedCp2DataCardModel.dataItemsMap.containsKey(mExtraPrioritizedMimeType) &&
+                    mCachedCp2DataCardModel.dataItemsMap.get(mExtraPrioritizedMimeType).size() != 0;
+            mContactCard.initialize(contactCardEntries,
+                    /* numInitialVisibleEntries = */ MIN_NUM_CONTACT_ENTRIES_SHOWN,
+                    /* isExpanded = */ mContactCard.isExpanded(),
+                    /* isAlwaysExpanded = */ false,
+                    mExpandingEntryCardViewListener,
+                    mScroller,
+                    firstEntriesArePrioritizedMimeType);
+            mContactCard.setVisibility(View.VISIBLE);
+        } else {
+            mContactCard.setVisibility(View.GONE);
+        }
+        Trace.endSection();
+
+        Trace.beginSection("bind about card");
+
+        // Phonetic name is not a data item, so the entry needs to be created separately
+        // But if mCachedCp2DataCardModel is passed to this method (e.g. returning from editor
+        // without saving any changes), then it should include phoneticName and the phoneticName
+        // shouldn't be changed. If this is the case, we shouldn't add it again. b/27459294
+        final String phoneticName = mContactData.getPhoneticName();
+        if (shouldAddPhoneticName && !TextUtils.isEmpty(phoneticName)) {
+            Entry phoneticEntry = new Entry(/* viewId = */ -1,
+                    /* icon = */ null,
+                    getResources().getString(R.string.name_phonetic),
+                    phoneticName,
+                    /* subHeaderIcon = */ null,
+                    /* text = */ null,
+                    /* textIcon = */ null,
+                    /* primaryContentDescription = */ null,
+                    /* intent = */ null,
+                    /* alternateIcon = */ null,
+                    /* alternateIntent = */ null,
+                    /* alternateContentDescription = */ null,
+                    /* shouldApplyColor = */ false,
+                    /* isEditable = */ false,
+                    /* EntryContextMenuInfo = */ new EntryContextMenuInfo(phoneticName,
+                            getResources().getString(R.string.name_phonetic),
+                            /* mimeType = */ null, /* id = */ -1, /* isPrimary = */ false),
+                    /* thirdIcon = */ null,
+                    /* thirdIntent = */ null,
+                    /* thirdContentDescription = */ null,
+                    /* thirdAction = */ Entry.ACTION_NONE,
+                    /* thirdExtras = */ null,
+                    /* iconResourceId = */  0);
+            List<Entry> phoneticList = new ArrayList<>();
+            phoneticList.add(phoneticEntry);
+            // Phonetic name comes after nickname. Check to see if the first entry type is nickname
+            if (aboutCardEntries.size() > 0 && aboutCardEntries.get(0).get(0).getHeader().equals(
+                    getResources().getString(R.string.header_nickname_entry))) {
+                aboutCardEntries.add(1, phoneticList);
+            } else {
+                aboutCardEntries.add(0, phoneticList);
+            }
+        }
+
+
+        /// M: Bug fix ALPS01775443, after deleted name in editor, need refresh about card.
+        mAboutCard.setTitle(customAboutCardName);
+
+        if (aboutCardEntries.size() > 0) {
+            mAboutCard.initialize(aboutCardEntries,
+                    /* numInitialVisibleEntries = */ 1,
+                    /* isExpanded = */ true,
+                    /* isAlwaysExpanded = */ true,
+                    mExpandingEntryCardViewListener,
+                    mScroller);
+        } else {
+            /// M: Bug fix ALPS01763309, after deleted all about card informations
+            //  in editor, need refresh about card. @{
+            mAboutCard.initialize(aboutCardEntries, 1, true, true,
+                    mExpandingEntryCardViewListener, mScroller);
+            mAboutCard.setVisibility(View.GONE);
+            /// @}
+        }
+
+        if (contactCardEntries.size() == 0 && aboutCardEntries.size() == 0) {
+            initializeNoContactDetailCard();
+        } else {
+            mNoContactDetailsCard.setVisibility(View.GONE);
+        }
+
+        // If the Recent card is already initialized (all recent data is loaded), show the About
+        // card if it has entries. Otherwise About card visibility will be set in bindRecentData()
+        if (isAllRecentDataLoaded() && aboutCardEntries.size() > 0) {
+            mAboutCard.setVisibility(View.VISIBLE);
+        }
+        Trace.endSection();
+    }
+
+    /**
+     * Create a card that shows "Add email" and "Add phone number" entries in grey.
+     */
+    private void initializeNoContactDetailCard() {
+        Log.d(TAG, "[initializeNoContactDetailCard]");
+        final Drawable phoneIcon = getResources().getDrawable(
+                R.drawable.ic_phone_24dp).mutate();
+        final Entry phonePromptEntry = new Entry(CARD_ENTRY_ID_EDIT_CONTACT,
+                phoneIcon, getString(R.string.quickcontact_add_phone_number),
+                /* subHeader = */ null, /* subHeaderIcon = */ null, /* text = */ null,
+                /* textIcon = */ null, /* primaryContentDescription = */ null,
+                getEditContactIntent(),
+                /* alternateIcon = */ null, /* alternateIntent = */ null,
+                /* alternateContentDescription = */ null, /* shouldApplyColor = */ true,
+                /* isEditable = */ false, /* EntryContextMenuInfo = */ null,
+                /* thirdIcon = */ null, /* thirdIntent = */ null,
+                /* thirdContentDescription = */ null,
+                /* thirdAction = */ Entry.ACTION_NONE,
+                /* thirdExtras = */ null,
+                R.drawable.ic_phone_24dp);
+
+        final Drawable emailIcon = getResources().getDrawable(
+                R.drawable.ic_email_24dp).mutate();
+        final Entry emailPromptEntry = new Entry(CARD_ENTRY_ID_EDIT_CONTACT,
+                emailIcon, getString(R.string.quickcontact_add_email), /* subHeader = */ null,
+                /* subHeaderIcon = */ null,
+                /* text = */ null, /* textIcon = */ null, /* primaryContentDescription = */ null,
+                getEditContactIntent(), /* alternateIcon = */ null,
+                /* alternateIntent = */ null, /* alternateContentDescription = */ null,
+                /* shouldApplyColor = */ true, /* isEditable = */ false,
+                /* EntryContextMenuInfo = */ null, /* thirdIcon = */ null,
+                /* thirdIntent = */ null, /* thirdContentDescription = */ null,
+                /* thirdAction = */ Entry.ACTION_NONE, /* thirdExtras = */ null,
+                R.drawable.ic_email_24dp);
+
+        final List<List<Entry>> promptEntries = new ArrayList<>();
+        promptEntries.add(new ArrayList<Entry>(1));
+        /// M: ALPS02782438.not support to show email for sim and Ruim type.@{
+        //promptEntries.add(new ArrayList<Entry>(1));
+        promptEntries.get(0).add(phonePromptEntry);
+        if (isSupportShowEmailData(mContactData)) {
+            promptEntries.add(new ArrayList<Entry>(1));
+            promptEntries.get(1).add(emailPromptEntry);
+        }
+        /// @}
+        final int subHeaderTextColor = getResources().getColor(
+                R.color.quickcontact_entry_sub_header_text_color);
+        final PorterDuffColorFilter greyColorFilter =
+                new PorterDuffColorFilter(subHeaderTextColor, PorterDuff.Mode.SRC_ATOP);
+        mNoContactDetailsCard.initialize(promptEntries, /*M: ALPS02782438.//2*/promptEntries.size(),
+                /* isExpanded = */ true,
+                /* isAlwaysExpanded = */ true, mExpandingEntryCardViewListener, mScroller);
+        mNoContactDetailsCard.setVisibility(View.VISIBLE);
+        mNoContactDetailsCard.setEntryHeaderColor(subHeaderTextColor);
+        mNoContactDetailsCard.setColorAndFilter(subHeaderTextColor, greyColorFilter);
+    }
+
+    /**
+     * Builds the {@link DataItem}s Map out of the Contact.
+     * @param data The contact to build the data from.
+     * @return A pair containing a list of data items sorted within mimetype and sorted
+     *  amongst mimetype. The map goes from mimetype string to the sorted list of data items within
+     *  mimetype
+     */
+    private Cp2DataCardModel generateDataModelFromContact(
+            Contact data) {
+        Trace.beginSection("Build data items map");
+        Log.d(TAG, "[generateDataModelFromContact] start contact: " + data);
+        final Map<String, List<DataItem>> dataItemsMap = new HashMap<>();
+
+        final ResolveCache cache = ResolveCache.getInstance(this);
+        for (RawContact rawContact : data.getRawContacts()) {
+            for (DataItem dataItem : rawContact.getDataItems()) {
+                dataItem.setRawContactId(rawContact.getId());
+
+                final String mimeType = dataItem.getMimeType();
+                if (mimeType == null) continue;
+
+                final AccountType accountType = rawContact.getAccountType(this);
+                final DataKind dataKind = AccountTypeManager.getInstance(this)
+                        .getKindOrFallback(accountType, mimeType);
+                if (dataKind == null) continue;
+
+                dataItem.setDataKind(dataKind);
+
+                final boolean hasData = !TextUtils.isEmpty(dataItem.buildDataString(this,
+                        dataKind));
+
+                if (isMimeExcluded(mimeType) || !hasData) continue;
+
+                List<DataItem> dataItemListByType = dataItemsMap.get(mimeType);
+                if (dataItemListByType == null) {
+                    dataItemListByType = new ArrayList<>();
+                    dataItemsMap.put(mimeType, dataItemListByType);
+                }
+                dataItemListByType.add(dataItem);
+            }
+        }
+        Trace.endSection();
+
+        Trace.beginSection("sort within mimetypes");
+        /*
+         * Sorting is a multi part step. The end result is to a have a sorted list of the most
+         * used data items, one per mimetype. Then, within each mimetype, the list of data items
+         * for that type is also sorted, based off of {super primary, primary, times used} in that
+         * order.
+         */
+        final List<List<DataItem>> dataItemsList = new ArrayList<>();
+        for (List<DataItem> mimeTypeDataItems : dataItemsMap.values()) {
+            // Remove duplicate data items
+            Collapser.collapseList(mimeTypeDataItems, this);
+            // Sort within mimetype
+            Collections.sort(mimeTypeDataItems, mWithinMimeTypeDataItemComparator);
+            // Add to the list of data item lists
+            dataItemsList.add(mimeTypeDataItems);
+        }
+        Trace.endSection();
+
+        Trace.beginSection("sort amongst mimetypes");
+        // Sort amongst mimetypes to bubble up the top data items for the contact card
+        Collections.sort(dataItemsList, mAmongstMimeTypeDataItemComparator);
+        Trace.endSection();
+
+        Trace.beginSection("cp2 data items to entries");
+
+        final List<List<Entry>> contactCardEntries = new ArrayList<>();
+        final List<List<Entry>> aboutCardEntries = buildAboutCardEntries(dataItemsMap);
+        final MutableString aboutCardName = new MutableString();
+
+        for (int i = 0; i < dataItemsList.size(); ++i) {
+            final List<DataItem> dataItemsByMimeType = dataItemsList.get(i);
+            final DataItem topDataItem = dataItemsByMimeType.get(0);
+            if (SORTED_ABOUT_CARD_MIMETYPES.contains(topDataItem.getMimeType())) {
+                // About card mimetypes are built in buildAboutCardEntries, skip here
+                continue;
+            } else {
+                List<Entry> contactEntries = dataItemsToEntries(dataItemsList.get(i),
+                        aboutCardName);
+                if (contactEntries.size() > 0) {
+                    contactCardEntries.add(contactEntries);
+                }
+            }
+        }
+
+        Trace.endSection();
+
+        final Cp2DataCardModel dataModel = new Cp2DataCardModel();
+        dataModel.customAboutCardName = aboutCardName.value;
+        dataModel.aboutCardEntries = aboutCardEntries;
+        dataModel.contactCardEntries = contactCardEntries;
+        dataModel.dataItemsMap = dataItemsMap;
+        Log.d(TAG, "[generateDataModelFromContact] end contact: " + data);
+        return dataModel;
+    }
+
+    /**
+     * Class used to hold the About card and Contact cards' data model that gets generated
+     * on a background thread. All data is from CP2.
+     */
+    private static class Cp2DataCardModel {
+        /**
+         * A map between a mimetype string and the corresponding list of data items. The data items
+         * are in sorted order using mWithinMimeTypeDataItemComparator.
+         */
+        public Map<String, List<DataItem>> dataItemsMap;
+        public List<List<Entry>> aboutCardEntries;
+        public List<List<Entry>> contactCardEntries;
+        public String customAboutCardName;
+    }
+
+    private static class MutableString {
+        public String value;
+    }
+
+    /**
+     * Converts a {@link DataItem} into an {@link ExpandingEntryCardView.Entry} for display.
+     * If the {@link ExpandingEntryCardView.Entry} has no visual elements, null is returned.
+     *
+     * This runs on a background thread. This is set as static to avoid accidentally adding
+     * additional dependencies on unsafe things (like the Activity).
+     *
+     * @param dataItem The {@link DataItem} to convert.
+     * @param secondDataItem A second {@link DataItem} to help build a full entry for some
+     *  mimetypes
+     * @return The {@link ExpandingEntryCardView.Entry}, or null if no visual elements are present.
+     */
+    private static Entry dataItemToEntry(DataItem dataItem, DataItem secondDataItem,
+            Context context, Contact contactData,
+            final MutableString aboutCardName) {
+        Log.d(TAG, "[dataItemToEntry] contact:" + contactData + " dataItem:" + dataItem.getClass());
+        Drawable icon = null;
+        String header = null;
+        String subHeader = null;
+        Drawable subHeaderIcon = null;
+        String text = null;
+        Drawable textIcon = null;
+        StringBuilder primaryContentDescription = new StringBuilder();
+        Spannable phoneContentDescription = null;
+        Spannable smsContentDescription = null;
+        Intent intent = null;
+        boolean shouldApplyColor = true;
+        Drawable alternateIcon = null;
+        Intent alternateIntent = null;
+        StringBuilder alternateContentDescription = new StringBuilder();
+        final boolean isEditable = false;
+        EntryContextMenuInfo entryContextMenuInfo = null;
+        Drawable thirdIcon = null;
+        Intent thirdIntent = null;
+        int thirdAction = Entry.ACTION_NONE;
+        String thirdContentDescription = null;
+        Bundle thirdExtras = null;
+        int iconResourceId = 0;
+
+        context = context.getApplicationContext();
+        final Resources res = context.getResources();
+        DataKind kind = dataItem.getDataKind();
+
+        QuickContactUtils.resetSipAddress();
+        /// M: Fix ALPS01995031
+        if (contactData == null) {
+            Log.w(TAG, "[dataItemToEntry] contact data is null.");
+            return null;
+        }
+        if (dataItem instanceof ImDataItem) {
+            final ImDataItem im = (ImDataItem) dataItem;
+            intent = ContactsUtils.buildImIntent(context, im).first;
+            final boolean isEmail = im.isCreatedFromEmail();
+            final int protocol;
+            if (!im.isProtocolValid()) {
+                protocol = Im.PROTOCOL_CUSTOM;
+            } else {
+                protocol = isEmail ? Im.PROTOCOL_GOOGLE_TALK : im.getProtocol();
+            }
+            if (protocol == Im.PROTOCOL_CUSTOM) {
+                // If the protocol is custom, display the "IM" entry header as well to distinguish
+                // this entry from other ones
+                header = res.getString(R.string.header_im_entry);
+                subHeader = Im.getProtocolLabel(res, protocol,
+                        im.getCustomProtocol()).toString();
+                text = im.getData();
+            } else {
+                header = Im.getProtocolLabel(res, protocol,
+                        im.getCustomProtocol()).toString();
+                subHeader = im.getData();
+            }
+            entryContextMenuInfo = new EntryContextMenuInfo(im.getData(), header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+        } else if (dataItem instanceof OrganizationDataItem) {
+            final OrganizationDataItem organization = (OrganizationDataItem) dataItem;
+            header = res.getString(R.string.header_organization_entry);
+            subHeader = organization.getCompany();
+            entryContextMenuInfo = new EntryContextMenuInfo(subHeader, header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+            text = organization.getTitle();
+        } else if (dataItem instanceof NicknameDataItem) {
+            final NicknameDataItem nickname = (NicknameDataItem) dataItem;
+            // Build nickname entries
+            final boolean isNameRawContact =
+                (contactData.getNameRawContactId() == dataItem.getRawContactId());
+
+            final boolean duplicatesTitle =
+                isNameRawContact
+                && contactData.getDisplayNameSource() == DisplayNameSources.NICKNAME;
+
+            if (!duplicatesTitle) {
+                header = res.getString(R.string.header_nickname_entry);
+                subHeader = nickname.getName();
+                entryContextMenuInfo = new EntryContextMenuInfo(subHeader, header,
+                        dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+            }
+        } else if (dataItem instanceof NoteDataItem) {
+            final NoteDataItem note = (NoteDataItem) dataItem;
+            header = res.getString(R.string.header_note_entry);
+            subHeader = note.getNote();
+            entryContextMenuInfo = new EntryContextMenuInfo(subHeader, header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+        } else if (dataItem instanceof WebsiteDataItem) {
+            final WebsiteDataItem website = (WebsiteDataItem) dataItem;
+            header = res.getString(R.string.header_website_entry);
+            subHeader = website.getUrl();
+            entryContextMenuInfo = new EntryContextMenuInfo(subHeader, header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+            try {
+                final WebAddress webAddress = new WebAddress(website.buildDataStringForDisplay
+                        (context, kind));
+                intent = new Intent(Intent.ACTION_VIEW, Uri.parse(webAddress.toString()));
+            } catch (final ParseException e) {
+                Log.e(TAG, "Couldn't parse website: " + website.buildDataStringForDisplay(
+                        context, kind));
+            }
+        } else if (dataItem instanceof EventDataItem) {
+            final EventDataItem event = (EventDataItem) dataItem;
+            final String dataString = event.buildDataStringForDisplay(context, kind);
+            final Calendar cal = DateUtils.parseDate(dataString, false);
+            if (cal != null) {
+                final Date nextAnniversary =
+                        DateUtils.getNextAnnualDate(cal);
+                final Uri.Builder builder = CalendarContract.CONTENT_URI.buildUpon();
+                builder.appendPath("time");
+                ContentUris.appendId(builder, nextAnniversary.getTime());
+                intent = new Intent(Intent.ACTION_VIEW).setData(builder.build());
+            }
+            header = res.getString(R.string.header_event_entry);
+            if (event.hasKindTypeColumn(kind)) {
+                subHeader = EventCompat.getTypeLabel(res, event.getKindTypeColumn(kind),
+                        event.getLabel()).toString();
+            }
+            text = DateUtils.formatDate(context, dataString);
+            entryContextMenuInfo = new EntryContextMenuInfo(text, header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+        } else if (dataItem instanceof RelationDataItem) {
+            final RelationDataItem relation = (RelationDataItem) dataItem;
+            final String dataString = relation.buildDataStringForDisplay(context, kind);
+            if (!TextUtils.isEmpty(dataString)) {
+                intent = new Intent(Intent.ACTION_SEARCH);
+                intent.putExtra(SearchManager.QUERY, dataString);
+                intent.setType(Contacts.CONTENT_TYPE);
+            }
+            header = res.getString(R.string.header_relation_entry);
+            subHeader = relation.getName();
+            entryContextMenuInfo = new EntryContextMenuInfo(subHeader, header,
+                    dataItem.getMimeType(), dataItem.getId(), dataItem.isSuperPrimary());
+            if (relation.hasKindTypeColumn(kind)) {
+                text = Relation.getTypeLabel(res,
+                        relation.getKindTypeColumn(kind),
+                        relation.getLabel()).toString();
+            }
+        } else if (dataItem instanceof PhoneDataItem) {
+            final PhoneDataItem phone = (PhoneDataItem) dataItem;
+            String phoneLabel = null;
+            if (!TextUtils.isEmpty(phone.getNumber())) {
+                primaryContentDescription.append(res.getString(R.string.call_other)).append(" ");
+                header = sBidiFormatter.unicodeWrap(phone.buildDataStringForDisplay(context, kind),
+                        TextDirectionHeuristics.LTR);
+                entryContextMenuInfo = new EntryContextMenuInfo(header,
+                        res.getString(R.string.phoneLabelsGroup), dataItem.getMimeType(),
+                        dataItem.getId(), dataItem.isSuperPrimary());
+                if (phone.hasKindTypeColumn(kind)) {
+                    final int kindTypeColumn = phone.getKindTypeColumn(kind);
+                    final String label = phone.getLabel();
+                    phoneLabel = label;
+                    if (kindTypeColumn == Phone.TYPE_CUSTOM && TextUtils.isEmpty(label)) {
+                        text = "";
+                    } else {
+                        text = Phone.getTypeLabel(res, kindTypeColumn, label).toString();
+                        ///M:[for AAS]show Primary Number/Additional Number@{
+                        int subId = contactData.getIndicate();
+                        subHeader = GlobalEnv.getAasExtension().getSubheaderString(
+                                subId, dataItem.getContentValues().getAsInteger(Data.DATA2));
+                        text = (String) GlobalEnv.getAasExtension().getTypeLabel(
+                                dataItem.getContentValues().getAsInteger(Data.DATA2),
+                                (CharSequence) dataItem.getContentValues().getAsString(Data.DATA3),
+                                (String) text, subId);
+                        ///@}
+                        phoneLabel= text;
+                        primaryContentDescription.append(text).append(" ");
+                    }
+
+                }
+                primaryContentDescription.append(header);
+                phoneContentDescription = com.android.contacts.common.util.ContactDisplayUtils
+                        .getTelephoneTtsSpannable(primaryContentDescription.toString(), header);
+                icon = res.getDrawable(R.drawable.ic_phone_24dp);
+                iconResourceId = R.drawable.ic_phone_24dp;
+                if (PhoneCapabilityTester.isPhone(context)) {
+                    intent = CallUtil.getCallIntent(phone.getNumber());
+                }
+                /// M: mtk add isSupportSms() method to enable Sms dynamically.@{
+                if (PhoneCapabilityTester.isSupportSms(context)) {
+                    alternateIntent = new Intent(Intent.ACTION_SENDTO,
+                            Uri.fromParts(ContactsUtils.SCHEME_SMSTO, phone.getNumber(), null));
+
+                    alternateIcon = res.getDrawable(R.drawable.ic_message_24dp_mirrored);
+                    alternateContentDescription.append(res.getString(R.string.sms_custom, header));
+                }
+                /// @}
+                smsContentDescription = com.android.contacts.common.util.ContactDisplayUtils
+                        .getTelephoneTtsSpannable(alternateContentDescription.toString(), header);
+                int videoCapability = CallUtil.getVideoCallingAvailability(context);
+                boolean isPresenceEnabled =
+                        (videoCapability & CallUtil.VIDEO_CALLING_PRESENCE) != 0;
+                boolean isVideoEnabled = (videoCapability & CallUtil.VIDEO_CALLING_ENABLED) != 0;
+                ///M: Video Entry @{
+                isVideoEnabled = ExtensionManager.getInstance().getOp01Extension()
+                        .isVideoButtonEnabled(isVideoEnabled, contactData.getLookupUri(), context);
+                ///@}
+
+                if (CallUtil.isCallWithSubjectSupported(context)) {
+                    thirdIcon = res.getDrawable(R.drawable.ic_call_note_white_24dp);
+                    thirdAction = Entry.ACTION_CALL_WITH_SUBJECT;
+                    thirdContentDescription =
+                            res.getString(R.string.call_with_a_note);
+
+                    // Create a bundle containing the data the call subject dialog requires.
+                    thirdExtras = new Bundle();
+                    thirdExtras.putLong(CallSubjectDialog.ARG_PHOTO_ID,
+                            contactData.getPhotoId());
+                    thirdExtras.putParcelable(CallSubjectDialog.ARG_PHOTO_URI,
+                            UriUtils.parseUriOrNull(contactData.getPhotoUri()));
+                    thirdExtras.putParcelable(CallSubjectDialog.ARG_CONTACT_URI,
+                            contactData.getLookupUri());
+                    thirdExtras.putString(CallSubjectDialog.ARG_NAME_OR_NUMBER,
+                            contactData.getDisplayName());
+                    thirdExtras.putBoolean(CallSubjectDialog.ARG_IS_BUSINESS, false);
+                    thirdExtras.putString(CallSubjectDialog.ARG_NUMBER,
+                            phone.getNumber());
+                    thirdExtras.putString(CallSubjectDialog.ARG_DISPLAY_NUMBER,
+                            phone.getFormattedPhoneNumber());
+                    thirdExtras.putString(CallSubjectDialog.ARG_NUMBER_LABEL,
+                            phoneLabel);
+                } else if (isVideoEnabled|| ExtensionManager.getInstance()
+                        .getContactsCommonPresenceExtension().isShowVideoIcon()) {
+                    // Check to ensure carrier presence indicates the number supports video calling.
+                    int carrierPresence = dataItem.getCarrierPresence();
+                    boolean isPresent = (carrierPresence & Phone.CARRIER_PRESENCE_VT_CAPABLE) != 0;
+
+                    if ((isPresenceEnabled && isPresent) || !isPresenceEnabled) {
+                        thirdIcon = res.getDrawable(R.drawable.ic_videocam);
+                        thirdAction = Entry.ACTION_INTENT;
+                        thirdIntent = CallUtil.getVideoCallIntent(phone.getNumber(),
+                                CALL_ORIGIN_QUICK_CONTACTS_ACTIVITY);
+                        thirdContentDescription =
+                                res.getString(R.string.description_video_call);
+                    }
+                }
+                ExtensionManager.getInstance().getContactsCommonPresenceExtension().
+                    setVideoIconAlpha(phone.getNumber(), thirdIcon);
+            }
+        } else if (dataItem instanceof EmailDataItem) {
+            final EmailDataItem email = (EmailDataItem) dataItem;
+            final String address = email.getData();
+            if (!TextUtils.isEmpty(address)) {
+                primaryContentDescription.append(res.getString(R.string.email_other)).append(" ");
+                final Uri mailUri = Uri.fromParts(ContactsUtils.SCHEME_MAILTO, address, null);
+                intent = new Intent(Intent.ACTION_SENDTO, mailUri);
+                header = email.getAddress();
+                entryContextMenuInfo = new EntryContextMenuInfo(header,
+                        res.getString(R.string.emailLabelsGroup), dataItem.getMimeType(),
+                        dataItem.getId(), dataItem.isSuperPrimary());
+                if (email.hasKindTypeColumn(kind)) {
+                    text = Email.getTypeLabel(res, email.getKindTypeColumn(kind),
+                            email.getLabel()).toString();
+                    primaryContentDescription.append(text).append(" ");
+                }
+                primaryContentDescription.append(header);
+                icon = res.getDrawable(R.drawable.ic_email_24dp);
+                iconResourceId = R.drawable.ic_email_24dp;
+            }
+        } else if (dataItem instanceof StructuredPostalDataItem) {
+            StructuredPostalDataItem postal = (StructuredPostalDataItem) dataItem;
+            final String postalAddress = postal.getFormattedAddress();
+            if (!TextUtils.isEmpty(postalAddress)) {
+                primaryContentDescription.append(res.getString(R.string.map_other)).append(" ");
+                intent = StructuredPostalUtils.getViewPostalAddressIntent(postalAddress);
+                header = postal.getFormattedAddress();
+                entryContextMenuInfo = new EntryContextMenuInfo(header,
+                        res.getString(R.string.postalLabelsGroup), dataItem.getMimeType(),
+                        dataItem.getId(), dataItem.isSuperPrimary());
+                if (postal.hasKindTypeColumn(kind)) {
+                    text = StructuredPostal.getTypeLabel(res,
+                            postal.getKindTypeColumn(kind), postal.getLabel()).toString();
+                    primaryContentDescription.append(text).append(" ");
+                }
+                primaryContentDescription.append(header);
+                alternateIntent =
+                        StructuredPostalUtils.getViewPostalAddressDirectionsIntent(postalAddress);
+                alternateIcon = res.getDrawable(R.drawable.ic_directions_24dp);
+                alternateContentDescription.append(res.getString(
+                        R.string.content_description_directions)).append(" ").append(header);
+                icon = res.getDrawable(R.drawable.ic_place_24dp);
+                iconResourceId = R.drawable.ic_place_24dp;
+            }
+        } else if (dataItem instanceof SipAddressDataItem) {
+            final SipAddressDataItem sip = (SipAddressDataItem) dataItem;
+            final String address = sip.getSipAddress();
+            if (!TextUtils.isEmpty(address)) {
+                QuickContactUtils.setSipAddress(address);
+                primaryContentDescription.append(res.getString(R.string.call_other)).append(
+                        " ");
+                if (PhoneCapabilityTester.isSipPhone(context)) {
+                    final Uri callUri = Uri.fromParts(PhoneAccount.SCHEME_SIP, address, null);
+                    intent = CallUtil.getCallIntent(callUri);
+                }
+                header = address;
+                entryContextMenuInfo = new EntryContextMenuInfo(header,
+                        res.getString(R.string.phoneLabelsGroup), dataItem.getMimeType(),
+                        dataItem.getId(), dataItem.isSuperPrimary());
+                if (sip.hasKindTypeColumn(kind)) {
+                    text = SipAddress.getTypeLabel(res,
+                            sip.getKindTypeColumn(kind), sip.getLabel()).toString();
+                    primaryContentDescription.append(text).append(" ");
+                }
+                primaryContentDescription.append(header);
+                icon = res.getDrawable(R.drawable.ic_dialer_sip_black_24dp);
+                iconResourceId = R.drawable.ic_dialer_sip_black_24dp;
+            }
+        } else if (dataItem instanceof StructuredNameDataItem) {
+            // If the name is already set and this is not the super primary value then leave the
+            // current value. This way we show the super primary value when we are able to.
+            if (dataItem.isSuperPrimary() || aboutCardName.value == null
+                    || aboutCardName.value.isEmpty()) {
+                final String givenName = ((StructuredNameDataItem) dataItem).getGivenName();
+                if (!TextUtils.isEmpty(givenName)) {
+                    aboutCardName.value = res.getString(R.string.about_card_title) +
+                            " " + givenName;
+                } else {
+                    aboutCardName.value = res.getString(R.string.about_card_title);
+                }
+            }
+        } else if (dataItem instanceof ImsCallDataItem) { // M: add IMS Call
+            if (ContactsSystemProperties.MTK_VOLTE_SUPPORT &&
+                    ContactsSystemProperties.MTK_IMS_SUPPORT) {
+                final ImsCallDataItem ims = (ImsCallDataItem) dataItem;
+                String imsUri = ims.getUrl();
+                if (!TextUtils.isEmpty(imsUri)) {
+                    String imsLabel = ims.getLabel();
+                    Log.d(TAG, "imsUri: " + imsUri + ", imsLabel: " + imsLabel);
+                    intent = CallUtil.getCallIntent(Uri.fromParts(PhoneAccount.SCHEME_TEL,
+                            imsUri, null), null, Constants.DIAL_NUMBER_INTENT_IMS);
+                    icon = res.getDrawable(R.drawable.ic_dialer_ims_black);
+                    text = res.getString(R.string.imsCallLabelsGroup);
+                    header = imsUri;
+                }
+            }
+        /// M: Group member ship.
+        } else if (dataItem instanceof GroupMembershipDataItem) {
+            final GroupMembershipDataItem groupDataItem = (GroupMembershipDataItem) dataItem;
+            String groupTitle = QuickContactUtils.getGroupTitle(contactData.getGroupMetaData(),
+                    groupDataItem.getGroupRowId());
+            if (!TextUtils.isEmpty(groupTitle)) {
+                header = res.getString(R.string.contact_detail_group_list_title);
+                subHeader = groupTitle;
+            }
+        } else {
+            // Custom DataItem
+            header = dataItem.buildDataStringForDisplay(context, kind);
+            text = kind.typeColumn;
+            intent = new Intent(Intent.ACTION_VIEW);
+            final Uri uri = ContentUris.withAppendedId(Data.CONTENT_URI, dataItem.getId());
+            intent.setDataAndType(uri, dataItem.getMimeType());
+
+            if (intent != null) {
+                final String mimetype = intent.getType();
+
+                // Build advanced entry for known 3p types. Otherwise default to ResolveCache icon.
+                switch (mimetype) {
+                    case MIMETYPE_GPLUS_PROFILE:
+                        // If a secondDataItem is available, use it to build an entry with
+                        // alternate actions
+                        if (secondDataItem != null) {
+                            icon = res.getDrawable(R.drawable.ic_google_plus_24dp);
+                            alternateIcon = res.getDrawable(R.drawable.ic_add_to_circles_black_24);
+                            final GPlusOrHangoutsDataItemModel itemModel =
+                                    new GPlusOrHangoutsDataItemModel(intent, alternateIntent,
+                                            dataItem, secondDataItem, alternateContentDescription,
+                                            header, text, context);
+
+                            populateGPlusOrHangoutsDataItemModel(itemModel);
+                            intent = itemModel.intent;
+                            alternateIntent = itemModel.alternateIntent;
+                            alternateContentDescription = itemModel.alternateContentDescription;
+                            header = itemModel.header;
+                            text = itemModel.text;
+                        } else {
+                            if (GPLUS_PROFILE_DATA_5_ADD_TO_CIRCLE.equals(
+                                    intent.getDataString())) {
+                                icon = res.getDrawable(R.drawable.ic_add_to_circles_black_24);
+                            } else {
+                                icon = res.getDrawable(R.drawable.ic_google_plus_24dp);
+                            }
+                        }
+                        break;
+                    case MIMETYPE_HANGOUTS:
+                        // If a secondDataItem is available, use it to build an entry with
+                        // alternate actions
+                        if (secondDataItem != null) {
+                            icon = res.getDrawable(R.drawable.ic_hangout_24dp);
+                            alternateIcon = res.getDrawable(R.drawable.ic_hangout_video_24dp);
+                            final GPlusOrHangoutsDataItemModel itemModel =
+                                    new GPlusOrHangoutsDataItemModel(intent, alternateIntent,
+                                            dataItem, secondDataItem, alternateContentDescription,
+                                            header, text, context);
+
+                            populateGPlusOrHangoutsDataItemModel(itemModel);
+                            intent = itemModel.intent;
+                            alternateIntent = itemModel.alternateIntent;
+                            alternateContentDescription = itemModel.alternateContentDescription;
+                            header = itemModel.header;
+                            text = itemModel.text;
+                        } else {
+                            if (HANGOUTS_DATA_5_VIDEO.equals(intent.getDataString())) {
+                                icon = res.getDrawable(R.drawable.ic_hangout_video_24dp);
+                            } else {
+                                icon = res.getDrawable(R.drawable.ic_hangout_24dp);
+                            }
+                        }
+                        break;
+                    default:
+                        entryContextMenuInfo = new EntryContextMenuInfo(header, mimetype,
+                                dataItem.getMimeType(), dataItem.getId(),
+                                dataItem.isSuperPrimary());
+                        icon = ResolveCache.getInstance(context).getIcon(
+                                dataItem.getMimeType(), intent);
+                        // Call mutate to create a new Drawable.ConstantState for color filtering
+                        if (icon != null) {
+                            icon.mutate();
+                        }
+                        shouldApplyColor = false;
+                }
+            }
+        }
+
+        if (intent != null) {
+            // Do not set the intent is there are no resolves
+            if (!PhoneCapabilityTester.isIntentRegistered(context, intent)) {
+                intent = null;
+            }
+        }
+
+        if (alternateIntent != null) {
+            // Do not set the alternate intent is there are no resolves
+            if (!PhoneCapabilityTester.isIntentRegistered(context, alternateIntent)) {
+                alternateIntent = null;
+            } else if (TextUtils.isEmpty(alternateContentDescription)) {
+                // Attempt to use package manager to find a suitable content description if needed
+                alternateContentDescription.append(getIntentResolveLabel(alternateIntent, context));
+            }
+        }
+
+        // If the Entry has no visual elements, return null
+        if (icon == null && TextUtils.isEmpty(header) && TextUtils.isEmpty(subHeader) &&
+                subHeaderIcon == null && TextUtils.isEmpty(text) && textIcon == null) {
+            Log.d(TAG, "[dataItemToEntry] has no visual elements");
+            return null;
+        }
+
+        // Ignore dataIds from the Me profile.
+        final int dataId = dataItem.getId() > Integer.MAX_VALUE ?
+                -1 : (int) dataItem.getId();
+        Log.d(TAG, "[dataItemToEntry] end ");
+        return new Entry(dataId, icon, header, subHeader, subHeaderIcon, text, textIcon,
+                phoneContentDescription == null
+                        ? new SpannableString(primaryContentDescription.toString())
+                        : phoneContentDescription,
+                intent, alternateIcon, alternateIntent,
+                smsContentDescription == null
+                        ? new SpannableString(alternateContentDescription.toString())
+                        : smsContentDescription,
+                shouldApplyColor, isEditable,
+                entryContextMenuInfo, thirdIcon, thirdIntent, thirdContentDescription, thirdAction,
+                thirdExtras, iconResourceId);
+
+        /* M: add sim icon & sim name @{
+        return new Entry(dataId, icon, header, subHeader, subHeaderIcon, text, textIcon, null, null,
+                new SpannableString(primaryContentDescription.toString()),
+                intent, alternateIcon, alternateIntent,
+                smsContentDescription == null
+                        ? new SpannableString(alternateContentDescription.toString())
+                        : smsContentDescription,
+                shouldApplyColor, isEditable,
+                entryContextMenuInfo, thirdIcon, thirdIntent, thirdContentDescription, thirdAction,
+                thirdExtras, iconResourceId);
+         @} */
+    }
+
+    private List<Entry> dataItemsToEntries(List<DataItem> dataItems,
+            MutableString aboutCardTitleOut) {
+        Log.d(TAG, "[dataItemsToEntries]");
+        // Hangouts and G+ use two data items to create one entry.
+        if (dataItems.get(0).getMimeType().equals(MIMETYPE_GPLUS_PROFILE) ||
+                dataItems.get(0).getMimeType().equals(MIMETYPE_HANGOUTS)) {
+            return gPlusOrHangoutsDataItemsToEntries(dataItems);
+        } else {
+            final List<Entry> entries = new ArrayList<>();
+            for (DataItem dataItem : dataItems) {
+                final Entry entry = dataItemToEntry(dataItem, /* secondDataItem = */ null,
+                        this, mContactData, aboutCardTitleOut);
+                if (entry != null) {
+                    entries.add(entry);
+                }
+            }
+            return entries;
+        }
+    }
+
+    /**
+     * G+ and Hangout entries are unique in that a single ExpandingEntryCardView.Entry consists
+     * of two data items. This method attempts to build each entry using the two data items if
+     * they are available. If there are more or less than two data items, a fall back is used
+     * and each data item gets its own entry.
+     */
+    private List<Entry> gPlusOrHangoutsDataItemsToEntries(List<DataItem> dataItems) {
+        Log.d(TAG, "[gPlusOrHangoutsDataItemsToEntries] start");
+        final List<Entry> entries = new ArrayList<>();
+        final Map<Long, List<DataItem>> buckets = new HashMap<>();
+        // Put the data items into buckets based on the raw contact id
+        for (DataItem dataItem : dataItems) {
+            List<DataItem> bucket = buckets.get(dataItem.getRawContactId());
+            if (bucket == null) {
+                bucket = new ArrayList<>();
+                buckets.put(dataItem.getRawContactId(), bucket);
+            }
+            bucket.add(dataItem);
+        }
+
+        // Use the buckets to build entries. If a bucket contains two data items, build the special
+        // entry, otherwise fall back to the normal entry.
+        for (List<DataItem> bucket : buckets.values()) {
+            if (bucket.size() == 2) {
+                // Use the pair to build an entry
+                final Entry entry = dataItemToEntry(bucket.get(0),
+                        /* secondDataItem = */ bucket.get(1), this, mContactData,
+                        /* aboutCardName = */ null);
+                if (entry != null) {
+                    entries.add(entry);
+                }
+            } else {
+                for (DataItem dataItem : bucket) {
+                    final Entry entry = dataItemToEntry(dataItem, /* secondDataItem = */ null,
+                            this, mContactData, /* aboutCardName = */ null);
+                    if (entry != null) {
+                        entries.add(entry);
+                    }
+                }
+            }
+        }
+        Log.d(TAG, "[gPlusOrHangoutsDataItemsToEntries] end");
+        return entries;
+    }
+
+    /**
+     * Used for statically passing around G+ or Hangouts data items and entry fields to
+     * populateGPlusOrHangoutsDataItemModel.
+     */
+    private static final class GPlusOrHangoutsDataItemModel {
+        public Intent intent;
+        public Intent alternateIntent;
+        public DataItem dataItem;
+        public DataItem secondDataItem;
+        public StringBuilder alternateContentDescription;
+        public String header;
+        public String text;
+        public Context context;
+
+        public GPlusOrHangoutsDataItemModel(Intent intent, Intent alternateIntent,
+                DataItem dataItem,
+                DataItem secondDataItem, StringBuilder alternateContentDescription, String header,
+                String text, Context context) {
+            this.intent = intent;
+            this.alternateIntent = alternateIntent;
+            this.dataItem = dataItem;
+            this.secondDataItem = secondDataItem;
+            this.alternateContentDescription = alternateContentDescription;
+            this.header = header;
+            this.text = text;
+            this.context = context;
+        }
+    }
+
+    private static void populateGPlusOrHangoutsDataItemModel(
+            GPlusOrHangoutsDataItemModel dataModel) {
+        final Intent secondIntent = new Intent(Intent.ACTION_VIEW);
+        secondIntent.setDataAndType(ContentUris.withAppendedId(Data.CONTENT_URI,
+                dataModel.secondDataItem.getId()), dataModel.secondDataItem.getMimeType());
+        // There is no guarantee the order the data items come in. Second
+        // data item does not necessarily mean it's the alternate.
+        // Hangouts video and Add to circles should be alternate. Swap if needed
+        if (HANGOUTS_DATA_5_VIDEO.equals(
+                dataModel.dataItem.getContentValues().getAsString(Data.DATA5)) ||
+                GPLUS_PROFILE_DATA_5_ADD_TO_CIRCLE.equals(
+                        dataModel.dataItem.getContentValues().getAsString(Data.DATA5))) {
+            dataModel.alternateIntent = dataModel.intent;
+            dataModel.alternateContentDescription = new StringBuilder(dataModel.header);
+
+            dataModel.intent = secondIntent;
+            dataModel.header = dataModel.secondDataItem.buildDataStringForDisplay(dataModel.context,
+                    dataModel.secondDataItem.getDataKind());
+            dataModel.text = dataModel.secondDataItem.getDataKind().typeColumn;
+        } else if (HANGOUTS_DATA_5_MESSAGE.equals(
+                dataModel.dataItem.getContentValues().getAsString(Data.DATA5)) ||
+                GPLUS_PROFILE_DATA_5_VIEW_PROFILE.equals(
+                        dataModel.dataItem.getContentValues().getAsString(Data.DATA5))) {
+            dataModel.alternateIntent = secondIntent;
+            dataModel.alternateContentDescription = new StringBuilder(
+                    dataModel.secondDataItem.buildDataStringForDisplay(dataModel.context,
+                            dataModel.secondDataItem.getDataKind()));
+        }
+    }
+
+    private static String getIntentResolveLabel(Intent intent, Context context) {
+        final List<ResolveInfo> matches = context.getPackageManager().queryIntentActivities(intent,
+                PackageManager.MATCH_DEFAULT_ONLY);
+
+        // Pick first match, otherwise best found
+        ResolveInfo bestResolve = null;
+        final int size = matches.size();
+        if (size == 1) {
+            bestResolve = matches.get(0);
+        } else if (size > 1) {
+            bestResolve = ResolveCache.getInstance(context).getBestResolve(intent, matches);
+        }
+
+        if (bestResolve == null) {
+            return null;
+        }
+
+        return String.valueOf(bestResolve.loadLabel(context.getPackageManager()));
+    }
+
+    /**
+     * Asynchronously extract the most vibrant color from the PhotoView. Once extracted,
+     * apply this tint to {@link MultiShrinkScroller}. This operation takes about 20-30ms
+     * on a Nexus 5.
+     */
+    private void extractAndApplyTintFromPhotoViewAsynchronously() {
+        if (mScroller == null) {
+            Log.d(TAG, "[extractAndApplyTintFromPhotoViewAsynchronously] mScroller=null");
+            return;
+        }
+        final Drawable imageViewDrawable = mPhotoView.getDrawable();
+        new AsyncTask<Void, Void, MaterialPalette>() {
+            @Override
+            protected MaterialPalette doInBackground(Void... params) {
+                Log.d(TAG, "[extractAndApplyTintFromPhotoViewAsynchronously] doInBackground start");
+                if (mContactData == null) {
+                    Log.w(TAG, "[doInBackground] mContactData is null...");
+                }
+
+                if (imageViewDrawable instanceof BitmapDrawable && mContactData != null
+                        && mContactData.getThumbnailPhotoBinaryData() != null
+                        && mContactData.getThumbnailPhotoBinaryData().length > 0) {
+                    // Perform the color analysis on the thumbnail instead of the full sized
+                    // image, so that our results will be as similar as possible to the Bugle
+                    // app.
+                    final Bitmap bitmap = BitmapFactory.decodeByteArray(
+                            mContactData.getThumbnailPhotoBinaryData(), 0,
+                            mContactData.getThumbnailPhotoBinaryData().length);
+                    try {
+                        final int primaryColor = colorFromBitmap(bitmap);
+                        if (primaryColor != 0) {
+                            return mMaterialColorMapUtils.calculatePrimaryAndSecondaryColor(
+                                    primaryColor);
+                        }
+                    } finally {
+                        bitmap.recycle();
+                    }
+                }
+                if (imageViewDrawable instanceof LetterTileDrawable) {
+                    final int primaryColor = ((LetterTileDrawable) imageViewDrawable).getColor();
+                    return mMaterialColorMapUtils.calculatePrimaryAndSecondaryColor(primaryColor);
+                }
+                Log.d(TAG, "[extractAndApplyTintFromPhotoViewAsynchronously] doInBackground end");
+                return MaterialColorMapUtils.getDefaultPrimaryAndSecondaryColors(getResources());
+            }
+
+            @Override
+            protected void onPostExecute(MaterialPalette palette) {
+                super.onPostExecute(palette);
+                Log.d(TAG, "extractAndApplyTintFromPhotoViewAsynchronously [onPostExecute]");
+                //M:OP01 RCS will get photo from rcs server, and refresh thumbnail Photo.@{
+                mHasComputedThemeColor = ExtensionManager.getInstance().getRcsExtension().
+                        needUpdateContactPhoto(imageViewDrawable instanceof LetterTileDrawable,
+                        mHasComputedThemeColor);
+                /** @} */
+                if (mHasComputedThemeColor) {
+                    // If we had previously computed a theme color from the contact photo,
+                    // then do not update the theme color. Changing the theme color several
+                    // seconds after QC has started, as a result of an updated/upgraded photo,
+                    // is a jarring experience. On the other hand, changing the theme color after
+                    // a rotation or onNewIntent() is perfectly fine.
+                    return;
+                }
+                // Check that the Photo has not changed. If it has changed, the new tint
+                // color needs to be extracted
+                if (imageViewDrawable == mPhotoView.getDrawable()) {
+                    Log.d(TAG, "[extractAndApplyTintFromPhotoViewAsynchronously] onPostExecute"
+                            + "to update color and photo in suggestion card");
+                    mHasComputedThemeColor = true;
+                    setThemeColor(palette);
+                    // update color and photo in suggestion card
+                    onAggregationSuggestionChange();
+                }
+            }
+        }.execute();
+        Log.d(TAG, "[extractAndApplyTintFromPhotoViewAsynchronously] execute()");
+    }
+
+    private void setThemeColor(MaterialPalette palette) {
+        // If the color is invalid, use the predefined default
+        mColorFilterColor = palette.mPrimaryColor;
+        mScroller.setHeaderTintColor(mColorFilterColor);
+        mStatusBarColor = palette.mSecondaryColor;
+        updateStatusBarColor();
+
+        mColorFilter =
+                new PorterDuffColorFilter(mColorFilterColor, PorterDuff.Mode.SRC_ATOP);
+        mContactCard.setColorAndFilter(mColorFilterColor, mColorFilter);
+        mRecentCard.setColorAndFilter(mColorFilterColor, mColorFilter);
+        mAboutCard.setColorAndFilter(mColorFilterColor, mColorFilter);
+        mSuggestionsCancelButton.setTextColor(mColorFilterColor);
+
+        /// M: [for RCS-e]
+        if (mJoynCard != null) {
+            mJoynCard.setColorAndFilter(mColorFilterColor, mColorFilter);
+        }
+    }
+
+    private void updateStatusBarColor() {
+        if (mScroller == null || !CompatUtils.isLollipopCompatible()) {
+            return;
+        }
+        final int desiredStatusBarColor;
+        // Only use a custom status bar color if QuickContacts touches the top of the viewport.
+        if (mScroller.getScrollNeededToBeFullScreen() <= 0) {
+            desiredStatusBarColor = mStatusBarColor;
+        } else {
+            desiredStatusBarColor = Color.TRANSPARENT;
+        }
+        // Animate to the new color.
+        final ObjectAnimator animation = ObjectAnimator.ofInt(getWindow(), "statusBarColor",
+                getWindow().getStatusBarColor(), desiredStatusBarColor);
+        animation.setDuration(ANIMATION_STATUS_BAR_COLOR_CHANGE_DURATION);
+        animation.setEvaluator(new ArgbEvaluator());
+        animation.start();
+    }
+
+    private int colorFromBitmap(Bitmap bitmap) {
+        // Author of Palette recommends using 24 colors when analyzing profile photos.
+        final int NUMBER_OF_PALETTE_COLORS = 24;
+        final Palette palette = Palette.generate(bitmap, NUMBER_OF_PALETTE_COLORS);
+        if (palette != null && palette.getVibrantSwatch() != null) {
+            return palette.getVibrantSwatch().getRgb();
+        }
+        return 0;
+    }
+
+    private List<Entry> contactInteractionsToEntries(List<ContactInteraction> interactions) {
+        final List<Entry> entries = new ArrayList<>();
+        for (ContactInteraction interaction : interactions) {
+            if (interaction == null) {
+                continue;
+            }
+            entries.add(new Entry(/* id = */ -1,
+                    interaction.getIcon(this),
+                    interaction.getViewHeader(this),
+                    interaction.getViewBody(this),
+                    interaction.getBodyIcon(this),
+                    interaction.getViewFooter(this),
+                    interaction.getFooterIcon(this),
+                    /* M: add sim icon @ { */
+                    interaction.getSimIcon(this),
+                    interaction.getSimName(this),
+                    /* @ } */
+                    interaction.getContentDescription(this),
+                    interaction.getIntent(),
+                    /* alternateIcon = */ null,
+                    /* alternateIntent = */ null,
+                    /* alternateContentDescription = */ null,
+                    /* shouldApplyColor = */ true,
+                    /* isEditable = */ false,
+                    /* EntryContextMenuInfo = */ null,
+                    /* thirdIcon = */ null,
+                    /* thirdIntent = */ null,
+                    /* thirdContentDescription = */ null,
+                    /* thirdAction = */ Entry.ACTION_NONE,
+                    /* thirdActionExtras = */ null,
+                    interaction.getIconResourceId()));
+        }
+        return entries;
+    }
+
+    private final LoaderCallbacks<Contact> mLoaderContactCallbacks =
+            new LoaderCallbacks<Contact>() {
+        @Override
+        public void onLoaderReset(Loader<Contact> loader) {
+            Log.d(TAG, "[onLoaderReset], mContactData been set null");
+            mContactData = null;
+        }
+
+        @Override
+        public void onLoadFinished(Loader<Contact> loader, Contact data) {
+            Trace.beginSection("onLoadFinished()");
+            try {
+
+                if (isFinishing()) {
+                    return;
+                }
+                if (data.isError()) {
+                    // This means either the contact is invalid or we had an
+                    // internal error such as an acore crash.
+                    Log.i(TAG, "Failed to load contact: " + ((ContactLoader)loader).getLookupUri());
+                    Toast.makeText(QuickContactActivity.this, R.string.invalidContactMessage,
+                            Toast.LENGTH_LONG).show();
+                    finish();
+                    return;
+                }
+                if (data.isNotFound()) {
+                    Log.i(TAG, "No contact found: " + ((ContactLoader)loader).getLookupUri());
+                    if (!ExtensionManager.getInstance().getContactsPickerExtension()
+                            .openAddProfileScreen(mLookupUri, QuickContactActivity.this)) {
+                        Toast.makeText(QuickContactActivity.this, R.string.invalidContactMessage,
+                                Toast.LENGTH_LONG).show();
+                    }
+                    finish();
+                    return;
+                }
+                Log.d(TAG, "onLoadFinished " + " | data.getContactId() : "
+                        + data.getContactId() + " | data.getUri() : " + data.getUri());
+
+                bindContactData(data);
+
+                ///M:[for rcs] update Rcs contact on the top left@{
+                ExtensionManager.getInstance().getRcsExtension()
+                        .getQuickContactRcsScroller()
+                        .updateRcsContact(mContactLoader.getLookupUri(), true);
+                Log.d(TAG, "onLoadFinished end");
+                ///@}
+            } finally {
+                Trace.endSection();
+            }
+        }
+
+        @Override
+        public Loader<Contact> onCreateLoader(int id, Bundle args) {
+            if (mLookupUri == null) {
+                Log.wtf(TAG, "Lookup uri wasn't initialized. Loader was started too early");
+            }
+            // Load all contact data. We need loadGroupMetaData=true to determine whether the
+            // contact is invisible. If it is, we need to display an "Add to Contacts" MenuItem.
+            return new ContactLoader(getApplicationContext(), mLookupUri,
+                    true /*loadGroupMetaData*/, false /*loadInvitableAccountTypes*/,
+                    true /*postViewNotification*/, true /*computeFormattedPhoneNumber*/);
+        }
+    };
+
+    @Override
+    public void onBackPressed() {
+        if (mScroller != null) {
+            if (!mIsExitAnimationInProgress) {
+                mScroller.scrollOffBottom();
+            }
+        } else {
+            super.onBackPressed();
+        }
+    }
+
+    @Override
+    public void finish() {
+        super.finish();
+
+        // override transitions to skip the standard window animations
+        overridePendingTransition(0, 0);
+    }
+
+    private final LoaderCallbacks<List<ContactInteraction>> mLoaderInteractionsCallbacks =
+            new LoaderCallbacks<List<ContactInteraction>>() {
+
+        @Override
+        public Loader<List<ContactInteraction>> onCreateLoader(int id, Bundle args) {
+            Loader<List<ContactInteraction>> loader = null;
+            switch (id) {
+                case LOADER_SMS_ID:
+                    loader = new SmsInteractionsLoader(
+                            QuickContactActivity.this,
+                            args.getStringArray(KEY_LOADER_EXTRA_PHONES),
+                            MAX_SMS_RETRIEVE);
+                    break;
+                case LOADER_CALENDAR_ID:
+                    final String[] emailsArray = args.getStringArray(KEY_LOADER_EXTRA_EMAILS);
+                    List<String> emailsList = null;
+                    if (emailsArray != null) {
+                        emailsList = Arrays.asList(args.getStringArray(KEY_LOADER_EXTRA_EMAILS));
+                    }
+                    loader = new CalendarInteractionsLoader(
+                            QuickContactActivity.this,
+                            emailsList,
+                            MAX_FUTURE_CALENDAR_RETRIEVE,
+                            MAX_PAST_CALENDAR_RETRIEVE,
+                            FUTURE_MILLISECOND_TO_SEARCH_LOCAL_CALENDAR,
+                            PAST_MILLISECOND_TO_SEARCH_LOCAL_CALENDAR);
+                    break;
+                case LOADER_CALL_LOG_ID:
+                    loader = new CallLogInteractionsLoader(
+                            QuickContactActivity.this,
+                            args.getStringArray(KEY_LOADER_EXTRA_PHONES),
+                            MAX_CALL_LOG_RETRIEVE);
+            }
+            return loader;
+        }
+
+        @Override
+        public void onLoadFinished(Loader<List<ContactInteraction>> loader,
+                List<ContactInteraction> data) {
+            mRecentLoaderResults.put(loader.getId(), data);
+
+            if (isAllRecentDataLoaded()) {
+                bindRecentData();
+            }
+        }
+
+        @Override
+        public void onLoaderReset(Loader<List<ContactInteraction>> loader) {
+            mRecentLoaderResults.remove(loader.getId());
+        }
+    };
+
+    private boolean isAllRecentDataLoaded() {
+        return mRecentLoaderResults.size() == mRecentLoaderIds.length;
+    }
+
+    private void bindRecentData() {
+        final List<ContactInteraction> allInteractions = new ArrayList<>();
+        final List<List<Entry>> interactionsWrapper = new ArrayList<>();
+
+        // Serialize mRecentLoaderResults into a single list. This should be done on the main
+        // thread to avoid races against mRecentLoaderResults edits.
+        for (List<ContactInteraction> loaderInteractions : mRecentLoaderResults.values()) {
+            allInteractions.addAll(loaderInteractions);
+        }
+
+        mRecentDataTask = new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(Void... params) {
+                Trace.beginSection("sort recent loader results");
+
+                // Sort the interactions by most recent
+                Collections.sort(allInteractions, new Comparator<ContactInteraction>() {
+                    @Override
+                    public int compare(ContactInteraction a, ContactInteraction b) {
+                        if (a == null && b == null) {
+                            return 0;
+                        }
+                        if (a == null) {
+                            return 1;
+                        }
+                        if (b == null) {
+                            return -1;
+                        }
+                        if (a.getInteractionDate() > b.getInteractionDate()) {
+                            return -1;
+                        }
+                        if (a.getInteractionDate() == b.getInteractionDate()) {
+                            return 0;
+                        }
+                        return 1;
+                    }
+                });
+
+                Trace.endSection();
+                Trace.beginSection("contactInteractionsToEntries");
+
+                // Wrap each interaction in its own list so that an icon is displayed for each entry
+                for (Entry contactInteraction : contactInteractionsToEntries(allInteractions)) {
+                    List<Entry> entryListWrapper = new ArrayList<>(1);
+                    entryListWrapper.add(contactInteraction);
+                    interactionsWrapper.add(entryListWrapper);
+                }
+
+                Trace.endSection();
+                Log.d(TAG, "[bindRecentData] doInBackground()");
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(Void aVoid) {
+                super.onPostExecute(aVoid);
+                Trace.beginSection("initialize recents card");
+
+                if (allInteractions.size() > 0) {
+                    mRecentCard.initialize(interactionsWrapper,
+                    /* numInitialVisibleEntries = */ MIN_NUM_COLLAPSED_RECENT_ENTRIES_SHOWN,
+                    /* isExpanded = */ mRecentCard.isExpanded(), /* isAlwaysExpanded = */ false,
+                            mExpandingEntryCardViewListener, mScroller);
+                    mRecentCard.setVisibility(View.VISIBLE);
+                } else {
+                    /// M: Fix ALPS01763309
+                    mRecentCard.setVisibility(View.GONE);
+                }
+
+                Trace.endSection();
+
+                // About card is initialized along with the contact card, but since it appears after
+                // the recent card in the UI, we hold off until making it visible until the recent
+                // card is also ready to avoid stuttering.
+                if (mAboutCard.shouldShow()) {
+                    mAboutCard.setVisibility(View.VISIBLE);
+                } else {
+                    mAboutCard.setVisibility(View.GONE);
+                }
+                mRecentDataTask = null;
+                Log.d(TAG, "[bindRecentData] onPostExecute(). size()=" + allInteractions.size());
+            }
+        };
+        mRecentDataTask.execute();
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+
+        if (mEntriesAndActionsTask != null) {
+            // Once the activity is stopped, we will no longer want to bind mEntriesAndActionsTask's
+            // results on the UI thread. In some circumstances Activities are killed without
+            // onStop() being called. This is not a problem, because in these circumstances
+            // the entire process will be killed.
+            mEntriesAndActionsTask.cancel(/* mayInterruptIfRunning = */ false);
+        }
+        if (mRecentDataTask != null) {
+            mRecentDataTask.cancel(/* mayInterruptIfRunning = */ false);
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (mAggregationSuggestionEngine != null) {
+            mAggregationSuggestionEngine.quit();
+        }
+        ///M: Video Entry @{
+        ExtensionManager.getInstance().getOp01Extension().resetVideoState();
+        ///@}
+    }
+
+    /**
+     * M: sdn contact isn't possible to edit.
+     * Returns true if it is possible to edit the current contact.
+     */
+    private boolean isContactEditable() {
+        return mContactData != null && !mContactData.isDirectoryEntry() &&
+            !mContactData.isSdnContacts();
+    }
+
+    /**
+     * Returns true if it is possible to share the current contact.
+     */
+    private boolean isContactShareable() {
+        return mContactData != null && !mContactData.isDirectoryEntry();
+    }
+
+    /// M: add isEditingUserProfile flag for user profile feature
+    private Intent getEditContactIntent() {
+        return EditorIntents.createCompactEditContactIntent(
+                mContactData.getLookupUri(),
+                mHasComputedThemeColor
+                        ? new MaterialPalette(mColorFilterColor, mStatusBarColor) : null,
+                mContactData.getPhotoId());
+    }
+
+    private void editContact() {
+        mHasIntentLaunched = true;
+        mContactLoader.cacheResult();
+        startActivityForResult(getEditContactIntent(), REQUEST_CODE_CONTACT_EDITOR_ACTIVITY);
+    }
+
+    private void deleteContact() {
+        final Uri contactUri = mContactData.getLookupUri();
+        ContactDeletionInteraction.start(this, contactUri, /* finishActivityWhenDone =*/ true);
+    }
+
+    private void toggleStar(MenuItem starredMenuItem) {
+        // Make sure there is a contact
+        if (mContactData != null) {
+            // Read the current starred value from the UI instead of using the last
+            // loaded state. This allows rapid tapping without writing the same
+            // value several times
+            final boolean isStarred = starredMenuItem.isChecked();
+
+            // To improve responsiveness, swap out the picture (and tag) in the UI already
+            ContactDisplayUtils.configureStarredMenuItem(starredMenuItem,
+                    mContactData.isDirectoryEntry(), mContactData.isUserProfile(),
+                    !isStarred);
+
+            // Now perform the real save
+            final Intent intent = ContactSaveService.createSetStarredIntent(
+                    QuickContactActivity.this, mContactData.getLookupUri(), !isStarred);
+            startService(intent);
+
+            final CharSequence accessibilityText = !isStarred
+                    ? getResources().getText(R.string.description_action_menu_add_star)
+                    : getResources().getText(R.string.description_action_menu_remove_star);
+            // Accessibility actions need to have an associated view. We can't access the MenuItem's
+            // underlying view, so put this accessibility action on the root view.
+            mScroller.announceForAccessibility(accessibilityText);
+        }
+    }
+    ///M:
+     /**
+     * Calls into the contacts provider to get a pre-authorized version of the given URI.
+     */
+    private Uri getPreAuthorizedUri(Uri uri) {
+        final Bundle uriBundle = new Bundle();
+        uriBundle.putParcelable(ContactsContract.Authorization.KEY_URI_TO_AUTHORIZE, uri);
+        final Bundle authResponse = getContentResolver().call(
+                ContactsContract.AUTHORITY_URI,
+                ContactsContract.Authorization.AUTHORIZATION_METHOD,
+                null,
+                uriBundle);
+        if (authResponse != null) {
+            return (Uri) authResponse.getParcelable(
+                    ContactsContract.Authorization.KEY_AUTHORIZED_URI);
+        } else {
+            return uri;
+        }
+    }
+
+    private void shareContact() {
+        Log.d(TAG, "[shareContact]");
+        final String lookupKey = mContactData.getLookupKey();
+        Uri shareUri = Uri.withAppendedPath(Contacts.CONTENT_VCARD_URI, lookupKey);
+        final Intent intent = new Intent(Intent.ACTION_SEND);
+        intent.setType(Contacts.CONTENT_VCARD_TYPE);
+        if (mContactData.isUserProfile()) {
+            // User is sharing the profile.  We don't want to force the receiver to have
+            // the highly-privileged READ_PROFILE permission, so we need to request a
+            // pre-authorized URI from the provider.
+            shareUri = getPreAuthorizedUri(shareUri);
+            /** M for ALPS01752410 @{*/
+            intent.putExtra("userProfile", "true");
+        } else {
+            intent.putExtra("contactId", String.valueOf(mContactData.getContactId()));
+            /** @} */
+        }
+        intent.putExtra(Intent.EXTRA_STREAM, shareUri);
+        /// M: Bug fix ALPS01749969, google default bug, need add the extra ARG_CALLING_ACTIVITY.
+        intent.putExtra(VCardCommonArguments.ARG_CALLING_ACTIVITY,
+                PeopleActivity.class.getName());
+
+        // Launch chooser to share contact via
+        final CharSequence chooseTitle = getText(R.string.share_via);
+        final Intent chooseIntent = Intent.createChooser(intent, chooseTitle);
+
+        try {
+            mHasIntentLaunched = true;
+            ImplicitIntentsUtil.startActivityOutsideApp(this, chooseIntent);
+        } catch (final ActivityNotFoundException ex) {
+            Toast.makeText(this, R.string.share_error, Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    /**
+     * Creates a launcher shortcut with the current contact.
+     */
+    private void createLauncherShortcutWithContact() {
+        final ShortcutIntentBuilder builder = new ShortcutIntentBuilder(this,
+                new OnShortcutIntentCreatedListener() {
+
+                    @Override
+                    public void onShortcutIntentCreated(Uri uri, Intent shortcutIntent) {
+                        // Broadcast the shortcutIntent to the launcher to create a
+                        // shortcut to this contact
+                        shortcutIntent.setAction(ACTION_INSTALL_SHORTCUT);
+                        QuickContactActivity.this.sendBroadcast(shortcutIntent);
+
+                        // Send a toast to give feedback to the user that a shortcut to this
+                        // contact was added to the launcher.
+                        final String displayName = shortcutIntent
+                                .getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
+                        final String toastMessage = TextUtils.isEmpty(displayName)
+                                ? getString(R.string.createContactShortcutSuccessful_NoName)
+                                : getString(R.string.createContactShortcutSuccessful, displayName);
+                        Toast.makeText(QuickContactActivity.this, toastMessage,
+                                Toast.LENGTH_SHORT).show();
+                    }
+
+                });
+        builder.createContactShortcutIntent(mContactData.getLookupUri());
+    }
+
+    private boolean isShortcutCreatable() {
+        if (mContactData == null || mContactData.isUserProfile() ||
+                mContactData.isDirectoryEntry()) {
+            return false;
+        }
+        final Intent createShortcutIntent = new Intent();
+        createShortcutIntent.setAction(ACTION_INSTALL_SHORTCUT);
+        final List<ResolveInfo> receivers = getPackageManager()
+                .queryBroadcastReceivers(createShortcutIntent, 0);
+        return receivers != null && receivers.size() > 0;
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        final MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.quickcontact, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        if (mContactData != null) {
+            final MenuItem starredMenuItem = menu.findItem(R.id.menu_star);
+            ContactDisplayUtils.configureStarredMenuItem(starredMenuItem,
+                    mContactData.isDirectoryEntry(), mContactData.isUserProfile(),
+                    mContactData.getStarred());
+
+            /// M: Disable sim contact star menu.
+            if (mContactData.getIndicate() > 0) {
+                starredMenuItem.setVisible(false);
+            }
+
+            final MenuItem editMenuItem = menu.findItem(R.id.menu_edit);
+
+            // Configure edit MenuItem
+            /// M: hide edit nenu if it is a sdn contact.
+            Log.d(TAG, "[onPrepareOptionsMenu] is sdn contact: " + mContactData.isSdnContacts());
+            if (mContactData.isSdnContacts()) {
+                editMenuItem.setVisible(false);
+            } else {
+                editMenuItem.setVisible(true);
+                editMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+                if (DirectoryContactUtil.isDirectoryContact(mContactData) ||
+                        InvisibleContactUtil.isInvisibleAndAddable(mContactData, this)) {
+                    editMenuItem.setIcon(R.drawable.ic_person_add_tinted_24dp);
+                    editMenuItem.setTitle(R.string.menu_add_contact);
+                } else if (isContactEditable()) {
+                    editMenuItem.setIcon(R.drawable.ic_create_24dp);
+                    editMenuItem.setTitle(R.string.menu_editContact);
+                } else {
+                    editMenuItem.setVisible(false);
+                }
+            }
+
+            final MenuItem deleteMenuItem = menu.findItem(R.id.menu_delete);
+            deleteMenuItem.setVisible(isContactEditable() && !mContactData.isUserProfile());
+
+            final MenuItem shareMenuItem = menu.findItem(R.id.menu_share);
+            shareMenuItem.setVisible(isContactShareable());
+
+            final MenuItem shortcutMenuItem = menu.findItem(R.id.menu_create_contact_shortcut);
+            /// M: hide the shortcut menu when it is sim contact.
+            if (mContactData != null && mContactData.getIndicate() >= 0) {
+                shortcutMenuItem.setVisible(false);
+                Log.d(TAG, "[[onPrepareOptionsMenu]] contact indicator: " +
+                        mContactData.getIndicate());
+            } else {
+                shortcutMenuItem.setVisible(isShortcutCreatable());
+            }
+            final MenuItem helpMenu = menu.findItem(R.id.menu_help);
+            helpMenu.setVisible(HelpUtils.isHelpAndFeedbackAvailable());
+            //M:OP01 RCS will add quick contact menu item @{
+            ExtensionManager.getInstance().getRcsExtension().
+                    addQuickContactMenuOptions(menu, mLookupUri, this);
+            /** @} */
+            Log.d(TAG, "[onPrepareOptionsMenu] return true");
+            return true;
+        }
+        Log.d(TAG, "[onPrepareOptionsMenu] return false");
+        return false;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        Log.d(TAG, "[onOptionsItemSelected] item = " + item.getTitle());
+        switch (item.getItemId()) {
+            case R.id.menu_star:
+                toggleStar(item);
+                return true;
+            case R.id.menu_edit:
+                if (DirectoryContactUtil.isDirectoryContact(mContactData)) {
+                    // This action is used to launch the contact selector, with the option of
+                    // creating a new contact. Creating a new contact is an INSERT, while selecting
+                    // an exisiting one is an edit. The fields in the edit screen will be
+                    // prepopulated with data.
+
+                    final Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT);
+                    intent.setType(Contacts.CONTENT_ITEM_TYPE);
+
+                    ArrayList<ContentValues> values = mContactData.getContentValues();
+
+                    // Only pre-fill the name field if the provided display name is an nickname
+                    // or better (e.g. structured name, nickname)
+                    if (mContactData.getDisplayNameSource() >= DisplayNameSources.NICKNAME) {
+                        intent.putExtra(Intents.Insert.NAME, mContactData.getDisplayName());
+                    } else if (mContactData.getDisplayNameSource()
+                            == DisplayNameSources.ORGANIZATION) {
+                        // This is probably an organization. Instead of copying the organization
+                        // name into a name entry, copy it into the organization entry. This
+                        // way we will still consider the contact an organization.
+                        final ContentValues organization = new ContentValues();
+                        organization.put(Organization.COMPANY, mContactData.getDisplayName());
+                        organization.put(Data.MIMETYPE, Organization.CONTENT_ITEM_TYPE);
+                        values.add(organization);
+                    }
+
+                    // Last time used and times used are aggregated values from the usage stat
+                    // table. They need to be removed from data values so the SQL table can insert
+                    // properly
+                    for (ContentValues value : values) {
+                        value.remove(Data.LAST_TIME_USED);
+                        value.remove(Data.TIMES_USED);
+                    }
+                    intent.putExtra(Intents.Insert.DATA, values);
+
+                    // If the contact can only export to the same account, add it to the intent.
+                    // Otherwise the ContactEditorFragment will show a dialog for selecting an
+                    // account.
+                    if (mContactData.getDirectoryExportSupport() ==
+                            Directory.EXPORT_SUPPORT_SAME_ACCOUNT_ONLY) {
+                        intent.putExtra(Intents.Insert.EXTRA_ACCOUNT,
+                                new Account(mContactData.getDirectoryAccountName(),
+                                        mContactData.getDirectoryAccountType()));
+                        intent.putExtra(Intents.Insert.EXTRA_DATA_SET,
+                                mContactData.getRawContacts().get(0).getDataSet());
+                    }
+
+                    // Add this flag to disable the delete menu option on directory contact joins
+                    // with local contacts. The delete option is ambiguous when joining contacts.
+                    intent.putExtra(ContactEditorFragment.INTENT_EXTRA_DISABLE_DELETE_MENU_OPTION,
+                            true);
+
+                    QuickContactUtils.addSipExtra(intent);
+                    startActivityForResult(intent, REQUEST_CODE_CONTACT_SELECTION_ACTIVITY);
+                } else if (InvisibleContactUtil.isInvisibleAndAddable(mContactData, this)) {
+                    InvisibleContactUtil.addToDefaultGroup(mContactData, this);
+                } else if (isContactEditable()) {
+                    editContact();
+                }
+                return true;
+            case R.id.menu_delete:
+                if (isContactEditable()) {
+                deleteContact();
+                }
+                return true;
+            case R.id.menu_share:
+                if (isContactShareable()) {
+                    shareContact();
+                }
+                return true;
+            case R.id.menu_create_contact_shortcut:
+                if (isShortcutCreatable()) {
+                createLauncherShortcutWithContact();
+                }
+                return true;
+            case R.id.menu_help:
+                HelpUtils.launchHelpAndFeedbackForContactScreen(this);
+                return true;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    /// M: ALPS02782438.not support to show email for sim,Ruim and Usim which not support email
+    /// field. @{
+    private boolean isSupportShowEmailData(Contact contactsData) {
+        Log.d(TAG, "[isSupportShowEmailData] data : " + contactsData);
+        if (contactsData == null) {
+            return false;
+        }
+        String accoutType = contactsData.getRawContacts().get(0).getAccountTypeString();
+        Log.d(TAG, "[isSupportShowEmailData] accoutType : " + accoutType);
+        if (AccountTypeUtils.ACCOUNT_TYPE_SIM.equals(accoutType) ||
+                AccountTypeUtils.ACCOUNT_TYPE_RUIM.equals(accoutType)) {
+            Log.i(TAG, "[isSupportShowEmailData] Ruim or sim not support email! ");
+            return false;
+        }
+        if (AccountTypeUtils.ACCOUNT_TYPE_USIM.equals(accoutType)) {
+            String accountName = contactsData.getRawContacts().get(0).getAccountName();
+            int subId = AccountTypeUtils.getSubIdBySimAccountName(getApplicationContext(),
+                    accountName);
+            int emailCount = SimCardUtils.getIccCardEmailCount(subId);
+            Log.d(TAG, "[isSupportShowEmailData] Usim type, accountName: " + accountName +
+                    ",subId: " + subId + ",emailCount: " + emailCount);
+            if (emailCount <= 0) {
+                Log.i(TAG, "[isSupportShowEmailData] Usim not support email field,remove it!!");
+                return false;
+            }
+        }
+        return true;
+    }
+    /// @}
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/widget/MultiShrinkScroller.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/widget/MultiShrinkScroller.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/src/com/android/contacts/widget/MultiShrinkScroller.java	(revision 9196)
@@ -0,0 +1,1404 @@
+package com.android.contacts.widget;
+
+import android.app.Activity;
+import com.android.contacts.R;
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.compat.EdgeEffectCompat;
+import com.android.contacts.quickcontact.ExpandingEntryCardView;
+import com.android.contacts.test.NeededForReflection;
+import com.android.contacts.util.SchedulingUtils;
+
+import android.animation.Animator;
+import android.animation.Animator.AnimatorListener;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
+import android.animation.ValueAnimator.AnimatorUpdateListener;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorMatrix;
+import android.graphics.ColorMatrixColorFilter;
+import android.graphics.drawable.GradientDrawable;
+import android.hardware.display.DisplayManager;
+import android.net.Uri;
+import android.os.Trace;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.animation.PathInterpolatorCompat;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewConfiguration;
+import android.view.animation.AnimationUtils;
+import android.view.animation.Interpolator;
+import android.widget.EdgeEffect;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.Scroller;
+import android.widget.ScrollView;
+import android.widget.TextView;
+import android.widget.Toolbar;
+
+import com.mediatek.contacts.ExtensionManager;
+
+/**
+ * A custom {@link ViewGroup} that operates similarly to a {@link ScrollView}, except with multiple
+ * subviews. These subviews are scrolled or shrinked one at a time, until each reaches their
+ * minimum or maximum value.
+ *
+ * MultiShrinkScroller is designed for a specific problem. As such, this class is designed to be
+ * used with a specific layout file: quickcontact_activity.xml. MultiShrinkScroller expects subviews
+ * with specific ID values.
+ *
+ * MultiShrinkScroller's code is heavily influenced by ScrollView. Nonetheless, several ScrollView
+ * features are missing. For example: handling of KEYCODES, OverScroll bounce and saving
+ * scroll state in savedInstanceState bundles.
+ *
+ * Before copying this approach to nested scrolling, consider whether something simpler & less
+ * customized will work for you. For example, see the re-usable StickyHeaderListView used by
+ * WifiSetupActivity (very nice). Alternatively, check out Google+'s cover photo scrolling or
+ * Android L's built in nested scrolling support. I thought I needed a more custom ViewGroup in
+ * order to track velocity, modify EdgeEffect color & perform the originally specified animations.
+ * As a result this ViewGroup has non-standard talkback and keyboard support.
+ */
+public class MultiShrinkScroller extends FrameLayout {
+
+    /**
+     * 1000 pixels per second. Ie, 1 pixel per millisecond.
+     */
+    private static final int PIXELS_PER_SECOND = 1000;
+
+    /**
+     * Length of the acceleration animations. This value was taken from ValueAnimator.java.
+     */
+    private static final int EXIT_FLING_ANIMATION_DURATION_MS = 250;
+
+    /**
+     * In portrait mode, the height:width ratio of the photo's starting height.
+     */
+    private static final float INTERMEDIATE_HEADER_HEIGHT_RATIO = 0.6f;
+
+    /**
+     * Color blending will only be performed on the contact photo once the toolbar is compressed
+     * to this ratio of its full height.
+     */
+    private static final float COLOR_BLENDING_START_RATIO = 0.5f;
+
+    private static final float SPRING_DAMPENING_FACTOR = 0.01f;
+
+    /**
+     * When displaying a letter tile drawable, this alpha value should be used at the intermediate
+     * toolbar height.
+     */
+    private static final float DESIRED_INTERMEDIATE_LETTER_TILE_ALPHA = 0.8f;
+
+    private float[] mLastEventPosition = { 0, 0 };
+    private VelocityTracker mVelocityTracker;
+    private boolean mIsBeingDragged = false;
+    private boolean mReceivedDown = false;
+    /**
+     * Did the current downwards fling/scroll-animation start while we were fullscreen?
+     */
+    private boolean mIsFullscreenDownwardsFling = false;
+
+    private ScrollView mScrollView;
+    private View mScrollViewChild;
+    private View mToolbar;
+    private QuickContactImageView mPhotoView;
+    private View mPhotoViewContainer;
+    private View mTransparentView;
+    private MultiShrinkScrollerListener mListener;
+    private TextView mLargeTextView;
+    private TextView mPhoneticNameView;
+    private View mTitleAndPhoneticNameView;
+    private View mPhotoTouchInterceptOverlay;
+    /** Contains desired size & vertical offset of the title, once the header is fully compressed */
+    private TextView mInvisiblePlaceholderTextView;
+    private View mTitleGradientView;
+    private View mActionBarGradientView;
+    private View mStartColumn;
+    private int mHeaderTintColor;
+    private int mMaximumHeaderHeight;
+    private int mMinimumHeaderHeight;
+    /**
+     * When the contact photo is tapped, it is resized to max size or this size. This value also
+     * sometimes represents the maximum achievable header size achieved by scrolling. To enforce
+     * this maximum in scrolling logic, always access this value via
+     * {@link #getMaximumScrollableHeaderHeight}.
+     */
+    private int mIntermediateHeaderHeight;
+    /**
+     * If true, regular scrolling can expand the header beyond mIntermediateHeaderHeight. The
+     * header, that contains the contact photo, can expand to a height equal its width.
+     */
+    private boolean mIsOpenContactSquare;
+    private int mMaximumHeaderTextSize;
+    private int mMaximumPhoneticNameViewHeight;
+    private int mMaximumFullNameViewHeight;
+    private int mCollapsedTitleBottomMargin;
+    private int mCollapsedTitleStartMargin;
+    private int mMinimumPortraitHeaderHeight;
+    private int mMaximumPortraitHeaderHeight;
+    /**
+     * True once the header has touched the top of the screen at least once.
+     */
+    private boolean mHasEverTouchedTheTop;
+    private boolean mIsTouchDisabledForDismissAnimation;
+    private boolean mIsTouchDisabledForSuppressLayout;
+
+    private final Scroller mScroller;
+    private final EdgeEffect mEdgeGlowBottom;
+    private final EdgeEffect mEdgeGlowTop;
+    private final int mTouchSlop;
+    private final int mMaximumVelocity;
+    private final int mMinimumVelocity;
+    private final int mDismissDistanceOnScroll;
+    private final int mDismissDistanceOnRelease;
+    private final int mSnapToTopSlopHeight;
+    private final int mTransparentStartHeight;
+    private final int mMaximumTitleMargin;
+    private final float mToolbarElevation;
+    /// M: bug fix for ALPS01768247
+    private boolean mIsTwoPanel;
+    private final float mLandscapePhotoRatio;
+    private final int mActionBarSize;
+
+    // Objects used to perform color filtering on the header. These are stored as fields for
+    // the sole purpose of avoiding "new" operations inside animation loops.
+    private final ColorMatrix mWhitenessColorMatrix = new ColorMatrix();
+    private final ColorMatrix mColorMatrix = new ColorMatrix();
+    private final float[] mAlphaMatrixValues = {
+            0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0,
+            0, 0, 0, 1, 0
+    };
+    private final ColorMatrix mMultiplyBlendMatrix = new ColorMatrix();
+    private final float[] mMultiplyBlendMatrixValues = {
+            0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0,
+            0, 0, 0, 1, 0
+    };
+
+    private final Interpolator mTextSizePathInterpolator =
+            PathInterpolatorCompat.create(0.16f, 0.4f, 0.2f, 1);
+
+    private final int[] mGradientColors = new int[] {0,0x88000000};
+    private GradientDrawable mTitleGradientDrawable = new GradientDrawable(
+            GradientDrawable.Orientation.TOP_BOTTOM, mGradientColors);
+    private GradientDrawable mActionBarGradientDrawable = new GradientDrawable(
+            GradientDrawable.Orientation.BOTTOM_TOP, mGradientColors);
+
+    public interface MultiShrinkScrollerListener {
+        void onScrolledOffBottom();
+
+        void onStartScrollOffBottom();
+
+        void onTransparentViewHeightChange(float ratio);
+
+        void onEntranceAnimationDone();
+
+        void onEnterFullscreen();
+
+        void onExitFullscreen();
+    }
+
+    private final AnimatorListener mSnapToBottomListener = new AnimatorListenerAdapter() {
+        @Override
+        public void onAnimationEnd(Animator animation) {
+            if (getScrollUntilOffBottom() > 0 && mListener != null) {
+                // Due to a rounding error, after the animation finished we haven't fully scrolled
+                // off the screen. Lie to the listener: tell it that we did scroll off the screen.
+                mListener.onScrolledOffBottom();
+                // No other messages need to be sent to the listener.
+                mListener = null;
+            }
+        }
+    };
+
+    /**
+     * Interpolator from android.support.v4.view.ViewPager. Snappier and more elastic feeling
+     * than the default interpolator.
+     */
+    private static final Interpolator sInterpolator = new Interpolator() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+
+    public MultiShrinkScroller(Context context) {
+        this(context, null);
+    }
+
+    public MultiShrinkScroller(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public MultiShrinkScroller(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        final ViewConfiguration configuration = ViewConfiguration.get(context);
+        setFocusable(false);
+        // Drawing must be enabled in order to support EdgeEffect
+        setWillNotDraw(/* willNotDraw = */ false);
+
+        mEdgeGlowBottom = new EdgeEffect(context);
+        mEdgeGlowTop = new EdgeEffect(context);
+        mScroller = new Scroller(context, sInterpolator);
+        mTouchSlop = configuration.getScaledTouchSlop();
+        mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
+        mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
+        mTransparentStartHeight = (int) getResources().getDimension(
+                R.dimen.quickcontact_starting_empty_height);
+        mToolbarElevation = getResources().getDimension(
+                R.dimen.quick_contact_toolbar_elevation);
+        mIsTwoPanel = getResources().getBoolean(R.bool.quickcontact_two_panel);
+        mMaximumTitleMargin = (int) getResources().getDimension(
+                R.dimen.quickcontact_title_initial_margin);
+
+        mDismissDistanceOnScroll = (int) getResources().getDimension(
+                R.dimen.quickcontact_dismiss_distance_on_scroll);
+        mDismissDistanceOnRelease = (int) getResources().getDimension(
+                R.dimen.quickcontact_dismiss_distance_on_release);
+        mSnapToTopSlopHeight = (int) getResources().getDimension(
+                R.dimen.quickcontact_snap_to_top_slop_height);
+
+        final TypedValue photoRatio = new TypedValue();
+        getResources().getValue(R.dimen.quickcontact_landscape_photo_ratio, photoRatio,
+                            /* resolveRefs = */ true);
+        mLandscapePhotoRatio = photoRatio.getFloat();
+
+        final TypedArray attributeArray = context.obtainStyledAttributes(
+                new int[]{android.R.attr.actionBarSize});
+        mActionBarSize = attributeArray.getDimensionPixelSize(0, 0);
+        mMinimumHeaderHeight = mActionBarSize;
+        // This value is approximately equal to the portrait ActionBar size. It isn't exactly the
+        // same, since the landscape and portrait ActionBar sizes can be different.
+        mMinimumPortraitHeaderHeight = mMinimumHeaderHeight;
+        attributeArray.recycle();
+    }
+
+    /**
+     * This method must be called inside the Activity's OnCreate.
+     */
+    public void initialize(MultiShrinkScrollerListener listener, boolean isOpenContactSquare,
+                final int maximumHeaderTextSize, final boolean shouldUpdateNameViewHeight) {
+        mScrollView = (ScrollView) findViewById(R.id.content_scroller);
+        mScrollViewChild = findViewById(R.id.card_container);
+        mToolbar = findViewById(R.id.toolbar_parent);
+        mPhotoViewContainer = findViewById(R.id.toolbar_parent);
+        mTransparentView = findViewById(R.id.transparent_view);
+        mLargeTextView = (TextView) findViewById(R.id.large_title);
+        mPhoneticNameView = (TextView) findViewById(R.id.phonetic_name);
+        mTitleAndPhoneticNameView = findViewById(R.id.title_and_phonetic_name);
+        mInvisiblePlaceholderTextView = (TextView) findViewById(R.id.placeholder_textview);
+        mStartColumn = findViewById(R.id.empty_start_column);
+        // Touching the empty space should close the card
+        if (mStartColumn != null) {
+            mStartColumn.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    scrollOffBottom();
+                }
+            });
+            findViewById(R.id.empty_end_column).setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    scrollOffBottom();
+                }
+            });
+        }
+        mListener = listener;
+        mIsOpenContactSquare = isOpenContactSquare;
+
+        mPhotoView = (QuickContactImageView) findViewById(R.id.photo);
+
+        mTitleGradientView = findViewById(R.id.title_gradient);
+        mTitleGradientView.setBackground(mTitleGradientDrawable);
+        mActionBarGradientView = findViewById(R.id.action_bar_gradient);
+        mActionBarGradientView.setBackground(mActionBarGradientDrawable);
+        mCollapsedTitleStartMargin = ((Toolbar) findViewById(R.id.toolbar)).getContentInsetStart();
+
+        mPhotoTouchInterceptOverlay = findViewById(R.id.photo_touch_intercept_overlay);
+        if (!mIsTwoPanel) {
+            mPhotoTouchInterceptOverlay.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    expandHeader();
+                }
+            });
+        }
+
+        SchedulingUtils.doOnPreDraw(this, /* drawNextFrame = */ false, new Runnable() {
+            @Override
+            public void run() {
+                /** M: Bug Fix for ALPS1747395 @{ */
+                if (getContext() == null) {
+                    return;
+                }
+                /** }@ */
+                /// M: bug fix for ALPS01768247
+                mIsTwoPanel = getResources().getBoolean(R.bool.quickcontact_two_panel);
+                if (!mIsTwoPanel) {
+                    // We never want the height of the photo view to exceed its width.
+                    mMaximumHeaderHeight = mPhotoViewContainer.getWidth();
+                    mIntermediateHeaderHeight = (int) (mMaximumHeaderHeight
+                            * INTERMEDIATE_HEADER_HEIGHT_RATIO);
+                }
+                mMaximumPortraitHeaderHeight = mIsTwoPanel ? getHeight()
+                        : mPhotoViewContainer.getWidth();
+                setHeaderHeight(getMaximumScrollableHeaderHeight());
+                if (shouldUpdateNameViewHeight) {
+                    mMaximumHeaderTextSize = mTitleAndPhoneticNameView.getHeight();
+                    mMaximumFullNameViewHeight = mLargeTextView.getHeight();
+                    // We cannot rely on mPhoneticNameView.getHeight() since it could be 0
+                    final int phoneticNameSize = getResources().getDimensionPixelSize(
+                            R.dimen.quickcontact_maximum_phonetic_name_size);
+                    final int fullNameSize = getResources().getDimensionPixelSize(
+                            R.dimen.quickcontact_maximum_title_size);
+                    mMaximumPhoneticNameViewHeight =
+                            mMaximumFullNameViewHeight * phoneticNameSize / fullNameSize;
+                }
+                if (maximumHeaderTextSize > 0) {
+                    mMaximumHeaderTextSize = maximumHeaderTextSize;
+                }
+                if (mIsTwoPanel) {
+                    mMaximumHeaderHeight = getHeight();
+                    mMinimumHeaderHeight = mMaximumHeaderHeight;
+                    mIntermediateHeaderHeight = mMaximumHeaderHeight;
+
+                    // Permanently set photo width and height.
+                    final ViewGroup.LayoutParams photoLayoutParams
+                            = mPhotoViewContainer.getLayoutParams();
+                    photoLayoutParams.height = mMaximumHeaderHeight;
+                    photoLayoutParams.width = (int) (mMaximumHeaderHeight * mLandscapePhotoRatio);
+                    mPhotoViewContainer.setLayoutParams(photoLayoutParams);
+
+                    // Permanently set title width and margin.
+                    final FrameLayout.LayoutParams largeTextLayoutParams
+                            = (FrameLayout.LayoutParams) mTitleAndPhoneticNameView
+                            .getLayoutParams();
+                    largeTextLayoutParams.width = photoLayoutParams.width -
+                            largeTextLayoutParams.leftMargin - largeTextLayoutParams.rightMargin;
+                    largeTextLayoutParams.gravity = Gravity.BOTTOM | Gravity.START;
+                    mTitleAndPhoneticNameView.setLayoutParams(largeTextLayoutParams);
+                } else {
+                    // Set the width of mLargeTextView as if it was nested inside
+                    // mPhotoViewContainer.
+                    mLargeTextView.setWidth(mPhotoViewContainer.getWidth()
+                            - 2 * mMaximumTitleMargin);
+                    mPhoneticNameView.setWidth(mPhotoViewContainer.getWidth()
+                            - 2 * mMaximumTitleMargin);
+                }
+
+                calculateCollapsedLargeTitlePadding();
+                updateHeaderTextSizeAndMargin();
+                configureGradientViewHeights();
+            }
+        });
+        ///M:[for rcs-e] show joyn icon on the top left@{
+        ExtensionManager.getInstance().getViewCustomExtension()
+        .getQuickContactScrollerCustom()
+        .createJoynIconView((FrameLayout) findViewById(R.id.placeholder_container),
+                mLargeTextView, ((Activity) getContext()).getIntent().getData());
+        ///@}
+        ///M:[for rcs] show Rcs icon on the top left@{
+        ExtensionManager.getInstance().getRcsExtension()
+                .getQuickContactRcsScroller()
+                .createRcsIconView(
+                    (FrameLayout) findViewById(R.id.placeholder_container),
+                    mLargeTextView,
+                    ((Activity) getContext()).getIntent().getData());
+        ///@}
+    }
+
+    private void configureGradientViewHeights() {
+        final FrameLayout.LayoutParams actionBarGradientLayoutParams
+                = (FrameLayout.LayoutParams) mActionBarGradientView.getLayoutParams();
+        actionBarGradientLayoutParams.height = mActionBarSize;
+        mActionBarGradientView.setLayoutParams(actionBarGradientLayoutParams);
+        final FrameLayout.LayoutParams titleGradientLayoutParams
+                = (FrameLayout.LayoutParams) mTitleGradientView.getLayoutParams();
+        final float TITLE_GRADIENT_SIZE_COEFFICIENT = 1.25f;
+        final FrameLayout.LayoutParams largeTextLayoutParms
+                = (FrameLayout.LayoutParams) mTitleAndPhoneticNameView.getLayoutParams();
+        titleGradientLayoutParams.height = (int) ((mMaximumHeaderTextSize
+                + largeTextLayoutParms.bottomMargin) * TITLE_GRADIENT_SIZE_COEFFICIENT);
+        mTitleGradientView.setLayoutParams(titleGradientLayoutParams);
+    }
+
+    public void setTitle(String title, boolean isPhoneNumber) {
+        mLargeTextView.setText(title);
+        // We have a phone number as "mLargeTextView" so make it always LTR.
+        if (isPhoneNumber) {
+            mLargeTextView.setTextDirection(View.TEXT_DIRECTION_LTR);
+        }
+        mPhotoTouchInterceptOverlay.setContentDescription(title);
+    }
+
+    public void setPhoneticName(String phoneticName) {
+        // Set phonetic name only when it was gone before or got changed.
+        if (mPhoneticNameView.getVisibility() == View.VISIBLE
+                && phoneticName.equals(mPhoneticNameView.getText())) {
+            return;
+        }
+        mPhoneticNameView.setText(phoneticName);
+        // Every time the phonetic name is changed, set mPhoneticNameView as visible,
+        // in case it just changed from Visibility=GONE.
+        mPhoneticNameView.setVisibility(View.VISIBLE);
+        // TODO try not using initialize() to refresh phonetic name view: b/27410518
+        initialize(mListener, mIsOpenContactSquare, /* maximumHeaderTextSize */
+                (mMaximumFullNameViewHeight + mMaximumPhoneticNameViewHeight),
+                /* shouldUpdateNameViewHeight */ false);
+    }
+
+    public void setPhoneticNameGone() {
+        // Remove phonetic name only when it was visible before.
+        if (mPhoneticNameView.getVisibility() == View.GONE) {
+            return;
+        }
+        mPhoneticNameView.setVisibility(View.GONE);
+        // Initialize to make Visibility work.
+        // TODO try not using initialize() to refresh phonetic name view: b/27410518
+        initialize(mListener, mIsOpenContactSquare,
+                /* maximumHeaderTextSize */ mMaximumFullNameViewHeight,
+                /* shouldUpdateNameViewHeight */ false);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent event) {
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(event);
+
+        // The only time we want to intercept touch events is when we are being dragged.
+        return shouldStartDrag(event);
+    }
+
+    private boolean shouldStartDrag(MotionEvent event) {
+        if (mIsTouchDisabledForDismissAnimation || mIsTouchDisabledForSuppressLayout) return false;
+
+
+        if (mIsBeingDragged) {
+            mIsBeingDragged = false;
+            return false;
+        }
+
+        switch (event.getAction()) {
+            // If we are in the middle of a fling and there is a down event, we'll steal it and
+            // start a drag.
+            case MotionEvent.ACTION_DOWN:
+                updateLastEventPosition(event);
+                if (!mScroller.isFinished()) {
+                    startDrag();
+                    return true;
+                } else {
+                    mReceivedDown = true;
+                }
+                break;
+
+            // Otherwise, we will start a drag if there is enough motion in the direction we are
+            // capable of scrolling.
+            case MotionEvent.ACTION_MOVE:
+                if (motionShouldStartDrag(event)) {
+                    updateLastEventPosition(event);
+                    startDrag();
+                    return true;
+                }
+                break;
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (mIsTouchDisabledForDismissAnimation || mIsTouchDisabledForSuppressLayout) return true;
+
+        final int action = event.getAction();
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(event);
+
+        if (!mIsBeingDragged) {
+            if (shouldStartDrag(event)) {
+                return true;
+            }
+
+            if (action == MotionEvent.ACTION_UP && mReceivedDown) {
+                mReceivedDown = false;
+                return performClick();
+            }
+            return true;
+        }
+
+        switch (action) {
+            case MotionEvent.ACTION_MOVE:
+                final float delta = updatePositionAndComputeDelta(event);
+                scrollTo(0, getScroll() + (int) delta);
+                mReceivedDown = false;
+
+                if (mIsBeingDragged) {
+                    final int distanceFromMaxScrolling = getMaximumScrollUpwards() - getScroll();
+                    if (delta > distanceFromMaxScrolling) {
+                        // The ScrollView is being pulled upwards while there is no more
+                        // content offscreen, and the view port is already fully expanded.
+                        EdgeEffectCompat.onPull(mEdgeGlowBottom, delta / getHeight(),
+                                1 - event.getX() / getWidth());
+                    }
+
+                    if (!mEdgeGlowBottom.isFinished()) {
+                        postInvalidateOnAnimation();
+                    }
+
+                    if (shouldDismissOnScroll()) {
+                        scrollOffBottom();
+                    }
+
+                }
+                break;
+
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL:
+                stopDrag(action == MotionEvent.ACTION_CANCEL);
+                mReceivedDown = false;
+                break;
+        }
+
+        return true;
+    }
+
+    public void setHeaderTintColor(int color) {
+        mHeaderTintColor = color;
+        updatePhotoTintAndDropShadow();
+        if (CompatUtils.isLollipopCompatible()) {
+            // Use the same amount of alpha on the new tint color as the previous tint color.
+            final int edgeEffectAlpha = Color.alpha(mEdgeGlowBottom.getColor());
+            mEdgeGlowBottom.setColor((color & 0xffffff) | Color.argb(edgeEffectAlpha, 0, 0, 0));
+            mEdgeGlowTop.setColor(mEdgeGlowBottom.getColor());
+        }
+    }
+
+    /**
+     * Expand to maximum size.
+     */
+    private void expandHeader() {
+        if (getHeaderHeight() != mMaximumHeaderHeight) {
+            final ObjectAnimator animator = ObjectAnimator.ofInt(this, "headerHeight",
+                    mMaximumHeaderHeight);
+            animator.setDuration(ExpandingEntryCardView.DURATION_EXPAND_ANIMATION_CHANGE_BOUNDS);
+            animator.start();
+            // Scroll nested scroll view to its top
+            if (mScrollView.getScrollY() != 0) {
+                ObjectAnimator.ofInt(mScrollView, "scrollY", -mScrollView.getScrollY()).start();
+            }
+        }
+    }
+
+    private void startDrag() {
+        mIsBeingDragged = true;
+        mScroller.abortAnimation();
+    }
+
+    private void stopDrag(boolean cancelled) {
+        mIsBeingDragged = false;
+        if (!cancelled && getChildCount() > 0) {
+            final float velocity = getCurrentVelocity();
+            if (velocity > mMinimumVelocity || velocity < -mMinimumVelocity) {
+                fling(-velocity);
+                onDragFinished(mScroller.getFinalY() - mScroller.getStartY());
+            } else {
+                onDragFinished(/* flingDelta = */ 0);
+            }
+        } else {
+            onDragFinished(/* flingDelta = */ 0);
+        }
+
+        if (mVelocityTracker != null) {
+            mVelocityTracker.recycle();
+            mVelocityTracker = null;
+        }
+
+        mEdgeGlowBottom.onRelease();
+    }
+
+    private void onDragFinished(int flingDelta) {
+        if (getTransparentViewHeight() <= 0) {
+            // Don't perform any snapping if quick contacts is full screen.
+            return;
+        }
+        if (!snapToTopOnDragFinished(flingDelta)) {
+            // The drag/fling won't result in the content at the top of the Window. Consider
+            // snapping the content to the bottom of the window.
+            snapToBottomOnDragFinished();
+        }
+    }
+
+    /**
+     * If needed, snap the subviews to the top of the Window.
+     *
+     * @return TRUE if QuickContacts will snap/fling to to top after this method call.
+     */
+    private boolean snapToTopOnDragFinished(int flingDelta) {
+        if (!mHasEverTouchedTheTop) {
+            // If the current fling is predicted to scroll past the top, then we don't need to snap
+            // to the top. However, if the fling only flings past the top by a tiny amount,
+            // it will look nicer to snap than to fling.
+            final float predictedScrollPastTop = getTransparentViewHeight() - flingDelta;
+            if (predictedScrollPastTop < -mSnapToTopSlopHeight) {
+                return false;
+            }
+
+            if (getTransparentViewHeight() <= mTransparentStartHeight) {
+                // We are above the starting scroll position so snap to the top.
+                mScroller.forceFinished(true);
+                smoothScrollBy(getTransparentViewHeight());
+                return true;
+            }
+            return false;
+        }
+        if (getTransparentViewHeight() < mDismissDistanceOnRelease) {
+            mScroller.forceFinished(true);
+            smoothScrollBy(getTransparentViewHeight());
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * If needed, scroll all the subviews off the bottom of the Window.
+     */
+    private void snapToBottomOnDragFinished() {
+        if (mHasEverTouchedTheTop) {
+            if (getTransparentViewHeight() > mDismissDistanceOnRelease) {
+                scrollOffBottom();
+            }
+            return;
+        }
+        if (getTransparentViewHeight() > mTransparentStartHeight) {
+            scrollOffBottom();
+        }
+    }
+
+    /**
+     * Returns TRUE if we have scrolled far QuickContacts far enough that we should dismiss it
+     * without waiting for the user to finish their drag.
+     */
+    private boolean shouldDismissOnScroll() {
+        return mHasEverTouchedTheTop && getTransparentViewHeight() > mDismissDistanceOnScroll;
+    }
+
+    /**
+     * Return ratio of non-transparent:viewgroup-height for this viewgroup at the starting position.
+     */
+    public float getStartingTransparentHeightRatio() {
+        return getTransparentHeightRatio(mTransparentStartHeight);
+    }
+
+    private float getTransparentHeightRatio(int transparentHeight) {
+        final float heightRatio = (float) transparentHeight / getHeight();
+        // Clamp between [0, 1] in case this is called before height is initialized.
+        return 1.0f - Math.max(Math.min(1.0f, heightRatio), 0f);
+    }
+
+    public void scrollOffBottom() {
+        mIsTouchDisabledForDismissAnimation = true;
+        final Interpolator interpolator = new AcceleratingFlingInterpolator(
+                EXIT_FLING_ANIMATION_DURATION_MS, getCurrentVelocity(),
+                getScrollUntilOffBottom());
+        mScroller.forceFinished(true);
+        ObjectAnimator translateAnimation = ObjectAnimator.ofInt(this, "scroll",
+                getScroll() - getScrollUntilOffBottom());
+        translateAnimation.setRepeatCount(0);
+        translateAnimation.setInterpolator(interpolator);
+        translateAnimation.setDuration(EXIT_FLING_ANIMATION_DURATION_MS);
+        translateAnimation.addListener(mSnapToBottomListener);
+        translateAnimation.start();
+        if (mListener != null) {
+            mListener.onStartScrollOffBottom();
+        }
+    }
+
+    /**
+     * @param scrollToCurrentPosition if true, will scroll from the bottom of the screen to the
+     * current position. Otherwise, will scroll from the bottom of the screen to the top of the
+     * screen.
+     */
+    public void scrollUpForEntranceAnimation(boolean scrollToCurrentPosition) {
+        final int currentPosition = getScroll();
+        final int bottomScrollPosition = currentPosition
+                - (getHeight() - getTransparentViewHeight()) + 1;
+        final Interpolator interpolator = AnimationUtils.loadInterpolator(getContext(),
+                android.R.interpolator.linear_out_slow_in);
+        final int desiredValue = currentPosition + (scrollToCurrentPosition ? currentPosition
+                : getTransparentViewHeight());
+        final ObjectAnimator animator = ObjectAnimator.ofInt(this, "scroll", bottomScrollPosition,
+                desiredValue);
+        animator.setInterpolator(interpolator);
+        animator.addUpdateListener(new AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator animation) {
+                if (animation.getAnimatedValue().equals(desiredValue) && mListener != null) {
+                    mListener.onEntranceAnimationDone();
+                }
+            }
+        });
+        animator.start();
+    }
+
+    @Override
+    public void scrollTo(int x, int y) {
+        final int delta = y - getScroll();
+        boolean wasFullscreen = getScrollNeededToBeFullScreen() <= 0;
+        if (delta > 0) {
+            scrollUp(delta);
+        } else {
+            scrollDown(delta);
+        }
+        updatePhotoTintAndDropShadow();
+        updateHeaderTextSizeAndMargin();
+        final boolean isFullscreen = getScrollNeededToBeFullScreen() <= 0;
+        mHasEverTouchedTheTop |= isFullscreen;
+        if (mListener != null) {
+            if (wasFullscreen && !isFullscreen) {
+                 mListener.onExitFullscreen();
+            } else if (!wasFullscreen && isFullscreen) {
+                mListener.onEnterFullscreen();
+            }
+            if (!isFullscreen || !wasFullscreen) {
+                mListener.onTransparentViewHeightChange(
+                        getTransparentHeightRatio(getTransparentViewHeight()));
+            }
+        }
+    }
+
+    /**
+     * Change the height of the header/toolbar. Do *not* use this outside animations. This was
+     * designed for use by {@link #prepareForShrinkingScrollChild}.
+     */
+    @NeededForReflection
+    public void setToolbarHeight(int delta) {
+        final ViewGroup.LayoutParams toolbarLayoutParams
+                = mToolbar.getLayoutParams();
+        toolbarLayoutParams.height = delta;
+        mToolbar.setLayoutParams(toolbarLayoutParams);
+
+        updatePhotoTintAndDropShadow();
+        updateHeaderTextSizeAndMargin();
+    }
+
+    @NeededForReflection
+    public int getToolbarHeight() {
+        return mToolbar.getLayoutParams().height;
+    }
+
+    /**
+     * Set the height of the toolbar and update its tint accordingly.
+     */
+    @NeededForReflection
+    public void setHeaderHeight(int height) {
+        final ViewGroup.LayoutParams toolbarLayoutParams
+                = mToolbar.getLayoutParams();
+        toolbarLayoutParams.height = height;
+        mToolbar.setLayoutParams(toolbarLayoutParams);
+        updatePhotoTintAndDropShadow();
+        updateHeaderTextSizeAndMargin();
+    }
+
+    @NeededForReflection
+    public int getHeaderHeight() {
+        return mToolbar.getLayoutParams().height;
+    }
+
+    @NeededForReflection
+    public void setScroll(int scroll) {
+        scrollTo(0, scroll);
+    }
+
+    /**
+     * Returns the total amount scrolled inside the nested ScrollView + the amount of shrinking
+     * performed on the ToolBar. This is the value inspected by animators.
+     */
+    @NeededForReflection
+    public int getScroll() {
+        return mTransparentStartHeight - getTransparentViewHeight()
+                + getMaximumScrollableHeaderHeight() - getToolbarHeight()
+                + mScrollView.getScrollY();
+    }
+
+    private int getMaximumScrollableHeaderHeight() {
+        return mIsOpenContactSquare ? mMaximumHeaderHeight : mIntermediateHeaderHeight;
+    }
+
+    /**
+     * A variant of {@link #getScroll} that pretends the header is never larger than
+     * than mIntermediateHeaderHeight. This function is sometimes needed when making scrolling
+     * decisions that will not change the header size (ie, snapping to the bottom or top).
+     *
+     * When mIsOpenContactSquare is true, this function considers mIntermediateHeaderHeight ==
+     * mMaximumHeaderHeight, since snapping decisions will be made relative the full header
+     * size when mIsOpenContactSquare = true.
+     *
+     * This value should never be used in conjunction with {@link #getScroll} values.
+     */
+    private int getScroll_ignoreOversizedHeaderForSnapping() {
+        return mTransparentStartHeight - getTransparentViewHeight()
+                + Math.max(getMaximumScrollableHeaderHeight() - getToolbarHeight(), 0)
+                + mScrollView.getScrollY();
+    }
+
+    /**
+     * Amount of transparent space above the header/toolbar.
+     */
+    public int getScrollNeededToBeFullScreen() {
+        return getTransparentViewHeight();
+    }
+
+    /**
+     * Return amount of scrolling needed in order for all the visible subviews to scroll off the
+     * bottom.
+     */
+    private int getScrollUntilOffBottom() {
+        return getHeight() + getScroll_ignoreOversizedHeaderForSnapping()
+                - mTransparentStartHeight;
+    }
+
+    @Override
+    public void computeScroll() {
+        if (mScroller.computeScrollOffset()) {
+            // Examine the fling results in order to activate EdgeEffect and halt flings.
+            final int oldScroll = getScroll();
+            scrollTo(0, mScroller.getCurrY());
+            final int delta = mScroller.getCurrY() - oldScroll;
+            final int distanceFromMaxScrolling = getMaximumScrollUpwards() - getScroll();
+            if (delta > distanceFromMaxScrolling && distanceFromMaxScrolling > 0) {
+                mEdgeGlowBottom.onAbsorb((int) mScroller.getCurrVelocity());
+            }
+            if (mIsFullscreenDownwardsFling && getTransparentViewHeight() > 0) {
+                // Halt the fling once QuickContact's top is on screen.
+                scrollTo(0, getScroll() + getTransparentViewHeight());
+                mEdgeGlowTop.onAbsorb((int) mScroller.getCurrVelocity());
+                mScroller.abortAnimation();
+                mIsFullscreenDownwardsFling = false;
+            }
+            if (!awakenScrollBars()) {
+                // Keep on drawing until the animation has finished.
+                postInvalidateOnAnimation();
+            }
+            if (mScroller.getCurrY() >= getMaximumScrollUpwards()) {
+                // Halt the fling once QuickContact's bottom is on screen.
+                mScroller.abortAnimation();
+                mIsFullscreenDownwardsFling = false;
+            }
+        }
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        super.draw(canvas);
+
+        final int width = getWidth() - getPaddingLeft() - getPaddingRight();
+        final int height = getHeight();
+
+        if (!mEdgeGlowBottom.isFinished()) {
+            final int restoreCount = canvas.save();
+
+            // Draw the EdgeEffect on the bottom of the Window (Or a little bit below the bottom
+            // of the Window if we start to scroll upwards while EdgeEffect is visible). This
+            // does not need to consider the case where this MultiShrinkScroller doesn't fill
+            // the Window, since the nested ScrollView should be set to fillViewport.
+            canvas.translate(-width + getPaddingLeft(),
+                    height + getMaximumScrollUpwards() - getScroll());
+
+            canvas.rotate(180, width, 0);
+            if (mIsTwoPanel) {
+                // Only show the EdgeEffect on the bottom of the ScrollView.
+                mEdgeGlowBottom.setSize(mScrollView.getWidth(), height);
+                if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
+                    canvas.translate(mPhotoViewContainer.getWidth(), 0);
+                }
+            } else {
+                mEdgeGlowBottom.setSize(width, height);
+            }
+            if (mEdgeGlowBottom.draw(canvas)) {
+                postInvalidateOnAnimation();
+            }
+            canvas.restoreToCount(restoreCount);
+        }
+
+        if (!mEdgeGlowTop.isFinished()) {
+            final int restoreCount = canvas.save();
+            if (mIsTwoPanel) {
+                mEdgeGlowTop.setSize(mScrollView.getWidth(), height);
+                if (getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                    canvas.translate(mPhotoViewContainer.getWidth(), 0);
+                }
+            } else {
+                mEdgeGlowTop.setSize(width, height);
+            }
+            if (mEdgeGlowTop.draw(canvas)) {
+                postInvalidateOnAnimation();
+            }
+            canvas.restoreToCount(restoreCount);
+        }
+    }
+
+    private float getCurrentVelocity() {
+        if (mVelocityTracker == null) {
+            return 0;
+        }
+        mVelocityTracker.computeCurrentVelocity(PIXELS_PER_SECOND, mMaximumVelocity);
+        return mVelocityTracker.getYVelocity();
+    }
+
+    private void fling(float velocity) {
+        // For reasons I do not understand, scrolling is less janky when maxY=Integer.MAX_VALUE
+        // then when maxY is set to an actual value.
+        mScroller.fling(0, getScroll(), 0, (int) velocity, 0, 0, -Integer.MAX_VALUE,
+                Integer.MAX_VALUE);
+        if (velocity < 0 && mTransparentView.getHeight() <= 0) {
+            mIsFullscreenDownwardsFling = true;
+        }
+        invalidate();
+    }
+
+    private int getMaximumScrollUpwards() {
+        if (!mIsTwoPanel) {
+            return mTransparentStartHeight
+                    // How much the Header view can compress
+                    + getMaximumScrollableHeaderHeight() - getFullyCompressedHeaderHeight()
+                    // How much the ScrollView can scroll. 0, if child is smaller than ScrollView.
+                    + Math.max(0, mScrollViewChild.getHeight() - getHeight()
+                    + getFullyCompressedHeaderHeight());
+        } else {
+            return mTransparentStartHeight
+                    // How much the ScrollView can scroll. 0, if child is smaller than ScrollView.
+                    + Math.max(0, mScrollViewChild.getHeight() - getHeight());
+        }
+    }
+
+    private int getTransparentViewHeight() {
+        return mTransparentView.getLayoutParams().height;
+    }
+
+    private void setTransparentViewHeight(int height) {
+        mTransparentView.getLayoutParams().height = height;
+        mTransparentView.setLayoutParams(mTransparentView.getLayoutParams());
+    }
+
+    private void scrollUp(int delta) {
+        if (getTransparentViewHeight() != 0) {
+            final int originalValue = getTransparentViewHeight();
+            setTransparentViewHeight(getTransparentViewHeight() - delta);
+            setTransparentViewHeight(Math.max(0, getTransparentViewHeight()));
+            delta -= originalValue - getTransparentViewHeight();
+        }
+        final ViewGroup.LayoutParams toolbarLayoutParams
+                = mToolbar.getLayoutParams();
+        if (toolbarLayoutParams.height > getFullyCompressedHeaderHeight()) {
+            final int originalValue = toolbarLayoutParams.height;
+            toolbarLayoutParams.height -= delta;
+            toolbarLayoutParams.height = Math.max(toolbarLayoutParams.height,
+                    getFullyCompressedHeaderHeight());
+            mToolbar.setLayoutParams(toolbarLayoutParams);
+            delta -= originalValue - toolbarLayoutParams.height;
+        }
+        mScrollView.scrollBy(0, delta);
+    }
+
+    /**
+     * Returns the minimum size that we want to compress the header to, given that we don't want to
+     * allow the the ScrollView to scroll unless there is new content off of the edge of ScrollView.
+     */
+    private int getFullyCompressedHeaderHeight() {
+        return Math.min(Math.max(mToolbar.getLayoutParams().height - getOverflowingChildViewSize(),
+                mMinimumHeaderHeight), getMaximumScrollableHeaderHeight());
+    }
+
+    /**
+     * Returns the amount of mScrollViewChild that doesn't fit inside its parent.
+     */
+    private int getOverflowingChildViewSize() {
+        final int usedScrollViewSpace = mScrollViewChild.getHeight();
+        return -getHeight() + usedScrollViewSpace + mToolbar.getLayoutParams().height;
+    }
+
+    private void scrollDown(int delta) {
+        if (mScrollView.getScrollY() > 0) {
+            final int originalValue = mScrollView.getScrollY();
+            mScrollView.scrollBy(0, delta);
+            delta -= mScrollView.getScrollY() - originalValue;
+        }
+        final ViewGroup.LayoutParams toolbarLayoutParams = mToolbar.getLayoutParams();
+        if (toolbarLayoutParams.height < getMaximumScrollableHeaderHeight()) {
+            final int originalValue = toolbarLayoutParams.height;
+            toolbarLayoutParams.height -= delta;
+            toolbarLayoutParams.height = Math.min(toolbarLayoutParams.height,
+                    getMaximumScrollableHeaderHeight());
+            mToolbar.setLayoutParams(toolbarLayoutParams);
+            delta -= originalValue - toolbarLayoutParams.height;
+        }
+        setTransparentViewHeight(getTransparentViewHeight() - delta);
+
+        if (getScrollUntilOffBottom() <= 0) {
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mListener != null) {
+                        mListener.onScrolledOffBottom();
+                        // No other messages need to be sent to the listener.
+                        mListener = null;
+                    }
+                }
+            });
+        }
+    }
+
+    /**
+     * Set the header size and padding, based on the current scroll position.
+     */
+    private void updateHeaderTextSizeAndMargin() {
+        if (mIsTwoPanel) {
+            // The text size stays at a constant size & location in two panel layouts.
+            return;
+        }
+
+        // The pivot point for scaling should be middle of the starting side.
+        if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
+            mTitleAndPhoneticNameView.setPivotX(mTitleAndPhoneticNameView.getWidth());
+        } else {
+            mTitleAndPhoneticNameView.setPivotX(0);
+        }
+        mTitleAndPhoneticNameView.setPivotY(mMaximumHeaderTextSize / 2);
+
+        final int toolbarHeight = mToolbar.getLayoutParams().height;
+        mPhotoTouchInterceptOverlay.setClickable(toolbarHeight != mMaximumHeaderHeight);
+
+        if (toolbarHeight >= mMaximumHeaderHeight) {
+            // Everything is full size when the header is fully expanded.
+            mTitleAndPhoneticNameView.setScaleX(1);
+            mTitleAndPhoneticNameView.setScaleY(1);
+            setInterpolatedTitleMargins(1);
+            return;
+        }
+
+        final float ratio = (toolbarHeight  - mMinimumHeaderHeight)
+                / (float)(mMaximumHeaderHeight - mMinimumHeaderHeight);
+        final float minimumSize = mInvisiblePlaceholderTextView.getHeight();
+        float bezierOutput = mTextSizePathInterpolator.getInterpolation(ratio);
+        float scale = (minimumSize + (mMaximumHeaderTextSize - minimumSize) * bezierOutput)
+                / mMaximumHeaderTextSize;
+
+        // Clamp to reasonable/finite values before passing into framework. The values
+        // can be wacky before the first pre-render.
+        bezierOutput = (float) Math.min(bezierOutput, 1.0f);
+        scale = (float) Math.min(scale, 1.0f);
+
+        mTitleAndPhoneticNameView.setScaleX(scale);
+        mTitleAndPhoneticNameView.setScaleY(scale);
+        setInterpolatedTitleMargins(bezierOutput);
+        ExtensionManager.getInstance().getViewCustomExtension().getQuickContactScrollerCustom()
+        .updateJoynIconView();
+        ///M:[for rcs] update Rcs icon on the top left@{
+        ExtensionManager.getInstance().getRcsExtension().getQuickContactRcsScroller()
+                .updateRcsIconView();
+        ///@}
+    }
+
+    /**
+     * Calculate the padding around mTitleAndPhoneticNameView so that it will look appropriate once it
+     * finishes moving into its target location/size.
+     */
+    private void calculateCollapsedLargeTitlePadding() {
+        int invisiblePlaceHolderLocation[] = new int[2];
+        int largeTextViewRectLocation[] = new int[2];
+        mInvisiblePlaceholderTextView.getLocationOnScreen(invisiblePlaceHolderLocation);
+        mToolbar.getLocationOnScreen(largeTextViewRectLocation);
+        // Distance between top of toolbar to the center of the target rectangle.
+        final int desiredTopToCenter = invisiblePlaceHolderLocation[1]
+                + mInvisiblePlaceholderTextView.getHeight() / 2
+                - largeTextViewRectLocation[1];
+        // Padding needed on the mTitleAndPhoneticNameView so that it has the same amount of
+        // padding as the target rectangle.
+        mCollapsedTitleBottomMargin =
+                desiredTopToCenter - mMaximumHeaderTextSize / 2;
+    }
+
+    /**
+     * Interpolate the title's margin size. When {@param x}=1, use the maximum title margins.
+     * When {@param x}=0, use the margin values taken from {@link #mInvisiblePlaceholderTextView}.
+     */
+    private void setInterpolatedTitleMargins(float x) {
+        final FrameLayout.LayoutParams titleLayoutParams
+                = (FrameLayout.LayoutParams) mTitleAndPhoneticNameView.getLayoutParams();
+        final LinearLayout.LayoutParams toolbarLayoutParams
+                = (LinearLayout.LayoutParams) mToolbar.getLayoutParams();
+
+        // Need to add more to margin start if there is a start column
+        int startColumnWidth = mStartColumn == null ? 0 : mStartColumn.getWidth();
+
+        titleLayoutParams.setMarginStart((int) (mCollapsedTitleStartMargin * (1 - x)
+                + mMaximumTitleMargin * x) + startColumnWidth);
+        // How offset the title should be from the bottom of the toolbar
+        final int pretendBottomMargin =  (int) (mCollapsedTitleBottomMargin * (1 - x)
+                + mMaximumTitleMargin * x) ;
+        // Calculate how offset the title should be from the top of the screen. Instead of
+        // calling mTitleAndPhoneticNameView.getHeight() use the mMaximumHeaderTextSize for this
+        // calculation. The getHeight() value acts unexpectedly when mTitleAndPhoneticNameView is
+        // partially clipped by its parent.
+        titleLayoutParams.topMargin = getTransparentViewHeight()
+                + toolbarLayoutParams.height - pretendBottomMargin
+                - mMaximumHeaderTextSize;
+        titleLayoutParams.bottomMargin = 0;
+        mTitleAndPhoneticNameView.setLayoutParams(titleLayoutParams);
+    }
+
+    private void updatePhotoTintAndDropShadow() {
+        // Let's keep an eye on how long this method takes to complete.
+        Trace.beginSection("updatePhotoTintAndDropShadow");
+
+        if (mIsTwoPanel && !mPhotoView.isBasedOffLetterTile()) {
+            // When in two panel mode, UX considers photo tinting unnecessary for non letter
+            // tile photos.
+            mTitleGradientDrawable.setAlpha(0xFF);
+            mActionBarGradientDrawable.setAlpha(0xFF);
+            return;
+        }
+
+        // We need to use toolbarLayoutParams to determine the height, since the layout
+        // params can be updated before the height change is reflected inside the View#getHeight().
+        final int toolbarHeight = getToolbarHeight();
+
+        if (toolbarHeight <= mMinimumHeaderHeight && !mIsTwoPanel) {
+            ViewCompat.setElevation(mPhotoViewContainer, mToolbarElevation);
+        } else {
+            ViewCompat.setElevation(mPhotoViewContainer, 0);
+        }
+
+        // Reuse an existing mColorFilter (to avoid GC pauses) to change the photo's tint.
+        mPhotoView.clearColorFilter();
+        mColorMatrix.reset();
+
+        final int gradientAlpha;
+        if (!mPhotoView.isBasedOffLetterTile()) {
+            // Constants and equations were arbitrarily picked to choose values for saturation,
+            // whiteness, tint and gradient alpha. There were four main objectives:
+            // 1) The transition period between the unmodified image and fully colored image should
+            //    be very short.
+            // 2) The tinting should be fully applied even before the background image is fully
+            //    faded out and desaturated. Why? A half tinted photo looks bad and results in
+            //    unappealing colors.
+            // 3) The function should have a derivative of 0 at ratio = 1 to avoid discontinuities.
+            // 4) The entire process should look awesome.
+            final float ratio = calculateHeightRatioToBlendingStartHeight(toolbarHeight);
+            final float alpha = 1.0f - (float) Math.min(Math.pow(ratio, 1.5f) * 2f, 1f);
+            final float tint = (float) Math.min(Math.pow(ratio, 1.5f) * 3f, 1f);
+            mColorMatrix.setSaturation(alpha);
+            mColorMatrix.postConcat(alphaMatrix(alpha, Color.WHITE));
+            mColorMatrix.postConcat(multiplyBlendMatrix(mHeaderTintColor, tint));
+            gradientAlpha = (int) (255 * alpha);
+        } else if (mIsTwoPanel) {
+            mColorMatrix.reset();
+            mColorMatrix.postConcat(alphaMatrix(DESIRED_INTERMEDIATE_LETTER_TILE_ALPHA,
+                    mHeaderTintColor));
+            gradientAlpha = 0;
+        } else {
+            // We want a function that has DESIRED_INTERMEDIATE_LETTER_TILE_ALPHA value
+            // at the intermediate position and uses TILE_EXPONENT. Finding an equation
+            // that satisfies this condition requires the following arithmetic.
+            final float ratio = calculateHeightRatioToFullyOpen(toolbarHeight);
+            final float intermediateRatio = calculateHeightRatioToFullyOpen((int)
+                    (mMaximumPortraitHeaderHeight * INTERMEDIATE_HEADER_HEIGHT_RATIO));
+            final float TILE_EXPONENT = 3f;
+            final float slowingFactor = (float) ((1 - intermediateRatio) / intermediateRatio
+                    / (1 - Math.pow(1 - DESIRED_INTERMEDIATE_LETTER_TILE_ALPHA, 1/TILE_EXPONENT)));
+            float linearBeforeIntermediate = Math.max(1 - (1 - ratio) / intermediateRatio
+                    / slowingFactor, 0);
+            float colorAlpha = 1 - (float) Math.pow(linearBeforeIntermediate, TILE_EXPONENT);
+            mColorMatrix.postConcat(alphaMatrix(colorAlpha, mHeaderTintColor));
+            gradientAlpha = 0;
+        }
+
+        // TODO: remove re-allocation of ColorMatrixColorFilter objects (b/17627000)
+        mPhotoView.setColorFilter(new ColorMatrixColorFilter(mColorMatrix));
+
+        // Tell the photo view what tint we are trying to achieve. Depending on the type of
+        // drawable used, the photo view may or may not use this tint.
+        mPhotoView.setTint(mHeaderTintColor);
+        mTitleGradientDrawable.setAlpha(gradientAlpha);
+        mActionBarGradientDrawable.setAlpha(gradientAlpha);
+
+        Trace.endSection();
+    }
+
+    private float calculateHeightRatioToFullyOpen(int height) {
+        return (height - mMinimumPortraitHeaderHeight)
+                / (float) (mMaximumPortraitHeaderHeight - mMinimumPortraitHeaderHeight);
+    }
+
+    private float calculateHeightRatioToBlendingStartHeight(int height) {
+        final float intermediateHeight = mMaximumPortraitHeaderHeight
+                * COLOR_BLENDING_START_RATIO;
+        final float interpolatingHeightRange = intermediateHeight - mMinimumPortraitHeaderHeight;
+        if (height > intermediateHeight) {
+            return 0;
+        }
+        return (intermediateHeight - height) / interpolatingHeightRange;
+    }
+
+    /**
+     * Simulates alpha blending an image with {@param color}.
+     */
+    private ColorMatrix alphaMatrix(float alpha, int color) {
+        mAlphaMatrixValues[0] = Color.red(color) * alpha / 255;
+        mAlphaMatrixValues[6] = Color.green(color) * alpha / 255;
+        mAlphaMatrixValues[12] = Color.blue(color) * alpha / 255;
+        mAlphaMatrixValues[4] = 255 * (1 - alpha);
+        mAlphaMatrixValues[9] = 255 * (1 - alpha);
+        mAlphaMatrixValues[14] = 255 * (1 - alpha);
+        mWhitenessColorMatrix.set(mAlphaMatrixValues);
+        return mWhitenessColorMatrix;
+    }
+
+    /**
+     * Simulates multiply blending an image with a single {@param color}.
+     *
+     * Multiply blending is [Sa * Da, Sc * Dc]. See {@link android.graphics.PorterDuff}.
+     */
+    private ColorMatrix multiplyBlendMatrix(int color, float alpha) {
+        mMultiplyBlendMatrixValues[0] = multiplyBlend(Color.red(color), alpha);
+        mMultiplyBlendMatrixValues[6] = multiplyBlend(Color.green(color), alpha);
+        mMultiplyBlendMatrixValues[12] = multiplyBlend(Color.blue(color), alpha);
+        mMultiplyBlendMatrix.set(mMultiplyBlendMatrixValues);
+        return mMultiplyBlendMatrix;
+    }
+
+    private float multiplyBlend(int color, float alpha) {
+        return color * alpha / 255.0f + (1 - alpha);
+    }
+
+    private void updateLastEventPosition(MotionEvent event) {
+        mLastEventPosition[0] = event.getX();
+        mLastEventPosition[1] = event.getY();
+    }
+
+    private boolean motionShouldStartDrag(MotionEvent event) {
+        final float deltaY = event.getY() - mLastEventPosition[1];
+        return deltaY > mTouchSlop || deltaY < -mTouchSlop;
+    }
+
+    private float updatePositionAndComputeDelta(MotionEvent event) {
+        final int VERTICAL = 1;
+        final float position = mLastEventPosition[VERTICAL];
+        updateLastEventPosition(event);
+        float elasticityFactor = 1;
+        if (position < mLastEventPosition[VERTICAL] && mHasEverTouchedTheTop) {
+            // As QuickContacts is dragged from the top of the window, its rate of movement will
+            // slow down in proportion to its distance from the top. This will feel springy.
+            elasticityFactor += mTransparentView.getHeight() * SPRING_DAMPENING_FACTOR;
+        }
+        return (position - mLastEventPosition[VERTICAL]) / elasticityFactor;
+    }
+
+    private void smoothScrollBy(int delta) {
+        if (delta == 0) {
+            // Delta=0 implies the code calling smoothScrollBy is sloppy. We should avoid doing
+            // this, since it prevents Views from being able to register any clicks for 250ms.
+            throw new IllegalArgumentException("Smooth scrolling by delta=0 is "
+                    + "pointless and harmful");
+        }
+        mScroller.startScroll(0, getScroll(), 0, delta);
+        invalidate();
+    }
+
+    /**
+     * Interpolator that enforces a specific starting velocity. This is useful to avoid a
+     * discontinuity between dragging speed and flinging speed.
+     *
+     * Similar to a {@link android.view.animation.AccelerateInterpolator} in the sense that
+     * getInterpolation() is a quadratic function.
+     */
+    private class AcceleratingFlingInterpolator implements Interpolator {
+
+        private final float mStartingSpeedPixelsPerFrame;
+        private final float mDurationMs;
+        private final int mPixelsDelta;
+        private final float mNumberFrames;
+
+        public AcceleratingFlingInterpolator(int durationMs, float startingSpeedPixelsPerSecond,
+                int pixelsDelta) {
+            mStartingSpeedPixelsPerFrame = startingSpeedPixelsPerSecond / getRefreshRate();
+            mDurationMs = durationMs;
+            mPixelsDelta = pixelsDelta;
+            mNumberFrames = mDurationMs / getFrameIntervalMs();
+        }
+
+        @Override
+        public float getInterpolation(float input) {
+            final float animationIntervalNumber = mNumberFrames * input;
+            final float linearDelta = (animationIntervalNumber * mStartingSpeedPixelsPerFrame)
+                    / mPixelsDelta;
+            // Add the results of a linear interpolator (with the initial speed) with the
+            // results of a AccelerateInterpolator.
+            if (mStartingSpeedPixelsPerFrame > 0) {
+                return Math.min(input * input + linearDelta, 1);
+            } else {
+                // Initial fling was in the wrong direction, make sure that the quadratic component
+                // grows faster in order to make up for this.
+                return Math.min(input * (input - linearDelta) + linearDelta, 1);
+            }
+        }
+
+        private float getRefreshRate() {
+            final DisplayManager displayManager = (DisplayManager) MultiShrinkScroller
+                    .this.getContext().getSystemService(Context.DISPLAY_SERVICE);
+            return displayManager.getDisplay(Display.DEFAULT_DISPLAY).getRefreshRate();
+        }
+
+        public long getFrameIntervalMs() {
+            return (long)(1000 / getRefreshRate());
+        }
+    }
+
+    /**
+     * Expand the header if the mScrollViewChild is about to shrink by enough to create new empty
+     * space at the bottom of this ViewGroup.
+     */
+    public void prepareForShrinkingScrollChild(int heightDelta) {
+        final int newEmptyScrollViewSpace = -getOverflowingChildViewSize() + heightDelta;
+        if (newEmptyScrollViewSpace > 0 && !mIsTwoPanel) {
+            final int newDesiredToolbarHeight = Math.min(getToolbarHeight()
+                    + newEmptyScrollViewSpace, getMaximumScrollableHeaderHeight());
+            ObjectAnimator.ofInt(this, "toolbarHeight", newDesiredToolbarHeight).setDuration(
+                    ExpandingEntryCardView.DURATION_COLLAPSE_ANIMATION_CHANGE_BOUNDS).start();
+        }
+    }
+
+    /**
+     * If {@param areTouchesDisabled} is TRUE, ignore all of the user's touches.
+     */
+    public void setDisableTouchesForSuppressLayout(boolean areTouchesDisabled) {
+        // The card expansion animation uses the Transition framework's ChangeBounds API. This
+        // invokes suppressLayout(true) on the MultiShrinkScroller. As a result, we need to avoid
+        // all layout changes during expansion in order to avoid weird layout artifacts.
+        mIsTouchDisabledForSuppressLayout = areTouchesDisabled;
+    }
+
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/res/values/colors.xml
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/res/values/colors.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/res/values/colors.xml	(revision 9196)
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+    <color name="quickcontact_name_detail_background">#66000000</color>
+    <color name="quickcontact_entry_sub_header_text_color">#737373</color>
+    <color name="quickcontact_entry_header_text_color">#202020</color>
+
+    <color name="background_social_updates">#ffeeeeee</color>
+
+    <!-- TODO: remove these colors once we delete the group code (b/16522929) -->
+    <color name="action_bar_background">#0288d1</color>
+    <color name="action_bar_background_highlight">#cecece</color>
+    <color name="action_bar_button_text_color">#FFFFFF</color>
+
+    <color name="actionbar_background_color">@color/primary_color</color>
+    <color name="actionbar_background_color_dark">@color/primary_color_dark</color>
+
+    <color name="contextual_selection_bar_color">#616161</color>
+    <!-- Color of the status bar above the contextual selection bar. -->
+    <color name="contextual_selection_bar_status_bar_color">#424242</color>
+
+    <color name="primary_color_dark">#0277bd</color>
+    <color name="primary_color">#0288d1</color>
+
+    <!-- Color of the selected tab underline -->
+    <color name="contacts_accent_color">#FFFFFF</color>
+
+    <color name="floating_action_button_icon_color">@color/contacts_accent_color</color>
+
+    <!-- Horizontal separator line should be 12% dark in the light theme. -->
+    <color name="divider_line_color_light">#e0e0e0</color>
+
+    <!-- Color of the text on an ExpandingEntryCard button -->
+    <color name="expanding_entry_card_button_text_color">@android:color/black</color>
+
+    <!-- Background color for an ExpandingEntryCard -->
+    <color name="expanding_entry_card_background_color">#ffffff</color>
+
+    <!-- Color of the margin for cards -->
+    <color name="card_margin_color">#f4f4f4</color>
+
+    <color name="call_arrow_green">#2aad6f</color>
+    <color name="call_arrow_red">#ff2e58</color>
+
+    <!-- Background color of pinned header items. -->
+    <color name="list_item_pinned_header_color">@color/background_primary</color>
+
+    <!-- Add for ICS -->
+    <color name="calllog_list_item_simname_font_color">#ffffffff</color>
+
+    <!-- Add for Phone Landscape UI -->
+    <color name="call_log_detail">#ff111c21</color>
+
+    <!-- M:MTK adds. Color of the Contact name be searched -->
+    <color name="contact_name_searched_color">#2EE4FF</color>
+
+    <!-- Color of the mime-type icons inside the editor. 50% black. -->
+    <color name="editor_icon_color">#7f7f7f</color>
+
+    <!-- Color of disabled text and unfocused hint text inside the contact editor. 25% black. -->
+    <color name="editor_disabled_text_color">#40000000</color>
+
+    <!-- Color of button background in compact photo picker. -->
+    <color name="google_grey_600">#757575</color>
+
+    <!-- Color of button text in compact photo picker, 85% white. -->
+    <color name="photo_action_button_color">#D9FFFFFF</color>
+
+    <!-- Color of text on disabled link contacts button, 25% black. -->
+    <color name="disabled_button_text">#40000000</color>
+
+    <!-- Color of background of disabled link contacts button, 15% black. -->
+    <color name="disabled_button_background">#26000000</color>
+</resources>
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/res/drawable/ic_call_detail_block.xml
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/res/drawable/ic_call_detail_block.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/res/drawable/ic_call_detail_block.xml	(revision 9196)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2015 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
+    android:src="@drawable/ic_block_24dp"
+    android:tint="@color/call_detail_footer_icon_tint" />
Index: vendor/branch/5058I_ALRU/packages/apps/Contacts/res/menu/quickcontact.xml
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Contacts/res/menu/quickcontact.xml	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Contacts/res/menu/quickcontact.xml	(revision 9196)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <!-- Icon and titles are set in code for menu_star and menu_edit -->
+
+    <item
+        android:id="@+id/menu_star"
+        android:showAsAction="always" />
+
+    <item
+        android:id="@+id/menu_edit"
+        android:title="@string/menu_editContact" />
+
+    <item
+        android:id="@+id/menu_delete"
+        android:title="@string/menu_deleteContact" />
+
+    <item
+        android:id="@+id/menu_share"
+        android:title="@string/menu_share"
+        android:alphabeticShortcut="s" />
+
+    <item
+        android:id="@+id/menu_create_contact_shortcut"
+        android:title="@string/menu_create_contact_shortcut" />
+
+    <item
+        android:id="@+id/menu_help"
+        android:title="@string/menu_help" />
+</menu>
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src-N/com/android/dialer/compat/BlockedNumbersSdkCompat.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src-N/com/android/dialer/compat/BlockedNumbersSdkCompat.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src-N/com/android/dialer/compat/BlockedNumbersSdkCompat.java	(revision 9196)
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.dialer.compat;
+
+import android.content.Context;
+import android.net.Uri;
+import android.provider.BlockedNumberContract;
+import android.provider.BlockedNumberContract.BlockedNumbers;
+
+public class BlockedNumbersSdkCompat {
+
+    public static final Uri CONTENT_URI = BlockedNumbers.CONTENT_URI;
+
+    public static final String _ID = BlockedNumbers.COLUMN_ID;
+
+    public static final String COLUMN_ORIGINAL_NUMBER = BlockedNumbers.COLUMN_ORIGINAL_NUMBER;
+
+    public static final String E164_NUMBER = BlockedNumbers.COLUMN_E164_NUMBER;
+
+    public static boolean canCurrentUserBlockNumbers(Context context) {
+        return BlockedNumberContract.canCurrentUserBlockNumbers(context);
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/compat/FilteredNumberCompat.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/compat/FilteredNumberCompat.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/compat/FilteredNumberCompat.java	(revision 9196)
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.dialer.compat;
+
+import com.google.common.base.MoreObjects;
+import com.google.common.base.Preconditions;
+
+import android.app.FragmentManager;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.UserManager;
+import android.preference.PreferenceManager;
+import android.support.annotation.Nullable;
+import android.telecom.TelecomManager;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+import com.android.contacts.common.compat.CompatUtils;
+import com.android.contacts.common.compat.TelecomManagerUtil;
+import com.android.contacts.common.testing.NeededForTesting;
+import com.android.dialer.DialerApplication;
+import com.android.dialer.database.FilteredNumberAsyncQueryHandler;
+import com.android.dialer.database.FilteredNumberAsyncQueryHandler.OnCheckBlockedListener;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumber;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberColumns;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberSources;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberTypes;
+import com.android.dialer.filterednumber.BlockNumberDialogFragment;
+import com.android.dialer.filterednumber.BlockNumberDialogFragment.Callback;
+import com.android.dialer.filterednumber.BlockedNumbersMigrator;
+import com.android.dialer.filterednumber.BlockedNumbersSettingsActivity;
+import com.android.dialer.filterednumber.MigrateBlockedNumbersDialogFragment;
+import com.android.dialerbind.ObjectFactory;
+
+import com.mediatek.dialer.compat.DialerCompatEx;
+import com.mediatek.dialer.ext.ExtensionManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Compatibility class to encapsulate logic to switch between call blocking using
+ * {@link com.android.dialer.database.FilteredNumberContract} and using
+ * {@link android.provider.BlockedNumberContract}. This class should be used rather than explicitly
+ * referencing columns from either contract class in situations where both blocking solutions may be
+ * used.
+ */
+public class FilteredNumberCompat {
+
+    private static final String TAG = "FilteredNumberCompat";
+
+    protected static final String HAS_MIGRATED_TO_NEW_BLOCKING_KEY = "migratedToNewBlocking";
+
+    private static Boolean isEnabledForTest;
+
+    private static Context contextForTest;
+
+    /**
+     * @return The column name for ID in the filtered number database.
+     */
+    public static String getIdColumnName() {
+        return useNewFiltering() ? BlockedNumbersSdkCompat._ID : FilteredNumberColumns._ID;
+    }
+
+    /**
+     * @return The column name for type in the filtered number database. Will be {@code null} for
+     * the framework blocking implementation.
+     */
+    @Nullable
+    public static String getTypeColumnName() {
+        return useNewFiltering() ? null : FilteredNumberColumns.TYPE;
+    }
+
+    /**
+     * @return The column name for source in the filtered number database. Will be {@code null} for
+     * the framework blocking implementation
+     */
+    @Nullable
+    public static String getSourceColumnName() {
+        return useNewFiltering() ? null : FilteredNumberColumns.SOURCE;
+    }
+
+    /**
+     * @return The column name for the original number in the filtered number database.
+     */
+    public static String getOriginalNumberColumnName() {
+        return useNewFiltering() ? BlockedNumbersSdkCompat.COLUMN_ORIGINAL_NUMBER
+                : FilteredNumberColumns.NUMBER;
+    }
+
+    /**
+     * @return The column name for country iso in the filtered number database. Will be {@code null}
+     * the framework blocking implementation
+     */
+    @Nullable
+    public static String getCountryIsoColumnName() {
+        return useNewFiltering() ? null : FilteredNumberColumns.COUNTRY_ISO;
+    }
+
+    /**
+     * @return The column name for the e164 formatted number in the filtered number database.
+     */
+    public static String getE164NumberColumnName() {
+        return useNewFiltering() ? BlockedNumbersSdkCompat.E164_NUMBER
+                : FilteredNumberColumns.NORMALIZED_NUMBER;
+    }
+
+    /**
+     * @return {@code true} if the current SDK version supports using new filtering, {@code false}
+     * otherwise.
+     */
+    public static boolean canUseNewFiltering() {
+        if (isEnabledForTest != null) {
+            return CompatUtils.isNCompatible() && isEnabledForTest;
+        }
+        return CompatUtils.isNCompatible() && ObjectFactory
+                .isNewBlockingEnabled(DialerApplication.getContext())
+                /**M:[portable]*/
+                && DialerCompatEx.isDefaultOrSystemDialer(DialerApplication.getContext());
+    }
+
+    /**
+     * @return {@code true} if the new filtering should be used, i.e. it's enabled and any necessary
+     * migration has been performed, {@code false} otherwise.
+     */
+    public static boolean useNewFiltering() {
+        return canUseNewFiltering() && hasMigratedToNewBlocking();
+    }
+
+    /**
+     * @return {@code true} if the user has migrated to use
+     * {@link android.provider.BlockedNumberContract} blocking, {@code false} otherwise.
+     */
+    public static boolean hasMigratedToNewBlocking() {
+        return PreferenceManager.getDefaultSharedPreferences(
+                /// M: Add for test.
+                MoreObjects.firstNonNull(contextForTest, DialerApplication.getContext()))
+                .getBoolean(HAS_MIGRATED_TO_NEW_BLOCKING_KEY, false);
+    }
+
+    /**
+     * Called to inform this class whether the user has fully migrated to use
+     * {@link android.provider.BlockedNumberContract} blocking or not.
+     *
+     * @param hasMigrated {@code true} if the user has migrated, {@code false} otherwise.
+     */
+    @NeededForTesting
+    public static void setHasMigratedToNewBlocking(boolean hasMigrated) {
+        PreferenceManager.getDefaultSharedPreferences(
+                MoreObjects.firstNonNull(contextForTest, DialerApplication.getContext())).edit()
+                .putBoolean(HAS_MIGRATED_TO_NEW_BLOCKING_KEY, hasMigrated).apply();
+    }
+
+    @NeededForTesting
+    public static void setIsEnabledForTest(Boolean isEnabled) {
+        isEnabledForTest = isEnabled;
+    }
+
+    @NeededForTesting
+    public static void setContextForTest(Context context) {
+        contextForTest = context;
+    }
+
+    /**
+     * Gets the content {@link Uri} for number filtering.
+     *
+     * @param id The optional id to append with the base content uri.
+     * @return The Uri for number filtering.
+     */
+    public static Uri getContentUri(@Nullable Integer id) {
+        if (id == null) {
+            return getBaseUri();
+        }
+        return ContentUris.withAppendedId(getBaseUri(), id);
+    }
+
+
+    private static Uri getBaseUri() {
+        return useNewFiltering() ? BlockedNumbersSdkCompat.CONTENT_URI : FilteredNumber.CONTENT_URI;
+    }
+
+    /**
+     * Removes any null column names from the given projection array. This method is intended to be
+     * used to strip out any column names that aren't available in every version of number blocking.
+     * Example:
+     * {@literal
+     *   getContext().getContentResolver().query(
+     *       someUri,
+     *       // Filtering ensures that no non-existant columns are queried
+     *       FilteredNumberCompat.filter(new String[] {FilteredNumberCompat.getIdColumnName(),
+     *           FilteredNumberCompat.getTypeColumnName()},
+     *       FilteredNumberCompat.getE164NumberColumnName() + " = ?",
+     *       new String[] {e164Number});
+     * }
+     *
+     * @param projection The projection array.
+     * @return The filtered projection array.
+     */
+    @Nullable
+    public static String[] filter(@Nullable String[] projection) {
+        if (projection == null) {
+            return null;
+        }
+        List<String> filtered = new ArrayList<>();
+        for (String column : projection) {
+            if (column != null) {
+                filtered.add(column);
+            }
+        }
+        return filtered.toArray(new String[filtered.size()]);
+    }
+
+    /**
+     * Creates a new {@link ContentValues} suitable for inserting in the filtered number table.
+     *
+     * @param number The unformatted number to insert.
+     * @param e164Number (optional) The number to insert formatted to E164 standard.
+     * @param countryIso (optional) The country iso to use to format the number.
+     * @return The ContentValues to insert.
+     * @throws NullPointerException If number is null.
+     */
+    public static ContentValues newBlockNumberContentValues(String number,
+            @Nullable String e164Number, @Nullable String countryIso) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(getOriginalNumberColumnName(), Preconditions.checkNotNull(number));
+        /// M: new filter also suport e164 number,so pass e164 format number to provider
+        // to avoid countryIso inconsistent problem. @{
+        if (e164Number == null) {
+            e164Number = PhoneNumberUtils.formatNumberToE164(number, countryIso);
+        }
+        contentValues.put(getE164NumberColumnName(), e164Number);
+        /// @}
+        if (!useNewFiltering()) {
+            contentValues.put(getCountryIsoColumnName(), countryIso);
+            contentValues.put(getTypeColumnName(), FilteredNumberTypes.BLOCKED_NUMBER);
+            contentValues.put(getSourceColumnName(), FilteredNumberSources.USER);
+        }
+        return contentValues;
+    }
+
+    /**
+     * Shows the flow of {@link android.app.DialogFragment}s for blocking or unblocking numbers.
+     *
+     * @param blockId The id into the blocked numbers database.
+     * @param number The number to block or unblock.
+     * @param countryIso The countryIso used to format the given number.
+     * @param displayNumber The form of the number to block, suitable for displaying.
+     * @param parentViewId The id for the containing view of the Dialog.
+     * @param fragmentManager The {@link FragmentManager} used to show fragments.
+     * @param callback (optional) The {@link Callback} to call when the block or unblock operation
+     * is complete.
+     */
+    public static void showBlockNumberDialogFlow(final ContentResolver contentResolver,
+            final Integer blockId, final String number, final String countryIso,
+            final String displayNumber, final Integer parentViewId,
+            final FragmentManager fragmentManager, @Nullable final Callback callback) {
+        Log.i(TAG, "showBlockNumberDialogFlow - start");
+        // If the user is blocking a number and isn't using the framework solution when they
+        // should be, show the migration dialog
+        if (shouldShowMigrationDialog(blockId == null)) {
+            Log.i(TAG, "showBlockNumberDialogFlow - showing migration dialog");
+            MigrateBlockedNumbersDialogFragment
+                    .newInstance(new BlockedNumbersMigrator(contentResolver), newMigrationListener(
+                            DialerApplication.getContext().getContentResolver(), number, countryIso,
+                            displayNumber, parentViewId, fragmentManager, callback))
+                    .show(fragmentManager, "MigrateBlockedNumbers");
+            return;
+        }
+        Log.i(TAG, "showBlockNumberDialogFlow - showing block number dialog");
+        BlockNumberDialogFragment
+                .show(blockId, number, countryIso, displayNumber, parentViewId, fragmentManager,
+                        callback);
+    }
+
+    private static boolean shouldShowMigrationDialog(boolean isBlocking) {
+        return isBlocking && canUseNewFiltering() && !hasMigratedToNewBlocking();
+    }
+
+    private static BlockedNumbersMigrator.Listener newMigrationListener(
+            final ContentResolver contentResolver, final String number, final String countryIso,
+            final String displayNumber, final Integer parentViewId,
+            final FragmentManager fragmentManager, @Nullable final Callback callback) {
+        return new BlockedNumbersMigrator.Listener() {
+            @Override
+            public void onComplete() {
+                Log.i(TAG, "showBlockNumberDialogFlow - listener showing block number dialog");
+                if (!hasMigratedToNewBlocking()) {
+                    Log.i(TAG, "showBlockNumberDialogFlow - migration failed");
+                    return;
+                }
+                /*
+                 * Edge case to cover here: if the user initiated the migration workflow with a
+                 * number that's already blocked in the framework, don't show the block number
+                 * dialog. Doing so would allow them to block the same number twice, causing a
+                 * crash.
+                 */
+                new FilteredNumberAsyncQueryHandler(contentResolver).isBlockedNumber(
+                        new OnCheckBlockedListener() {
+                            @Override
+                            public void onCheckComplete(Integer id) {
+                                if (id != null) {
+                                    Log.i(TAG,
+                                            "showBlockNumberDialogFlow - number already blocked");
+                                    return;
+                                }
+                                Log.i(TAG, "showBlockNumberDialogFlow - need to block number");
+                                BlockNumberDialogFragment
+                                        .show(null, number, countryIso, displayNumber, parentViewId,
+                                                fragmentManager, callback);
+                            }
+                        }, number, countryIso);
+            }
+        };
+    }
+
+    /**
+     * Creates the {@link Intent} which opens the blocked numbers management interface.
+     *
+     * @param context The {@link Context}.
+     * @return The intent.
+     */
+    public static Intent createManageBlockedNumbersIntent(Context context) {
+        if (canUseNewFiltering() && hasMigratedToNewBlocking()) {
+            return TelecomManagerUtil.createManageBlockedNumbersIntent(
+                    (TelecomManager) context.getSystemService(Context.TELECOM_SERVICE));
+        }
+        return new Intent(context, BlockedNumbersSettingsActivity.class);
+    }
+
+    /**
+     * Method used to determine if block operations are possible.
+     *
+     * @param context The {@link Context}.
+     * @return {@code true} if the app and user can block numbers, {@code false} otherwise.
+     */
+    public static boolean canAttemptBlockOperations(Context context) {
+        /// M: For OP01, do not use BlockedNumberProvider @{
+        if (!ExtensionManager.getInstance().getCallLogExtension()
+                .shouldUseBlockedNumberFeature()) {
+            return false;
+        }
+        /// @}
+        if (!CompatUtils.isNCompatible()) {
+            // Dialer blocking, must be primary user
+            return UserManagerCompat.isSystemUser(
+                    (UserManager) context.getSystemService(Context.USER_SERVICE));
+        }
+
+        // Great Wall blocking, must be primary user and the default or system dialer
+        // TODO(maxwelb): check that we're the default or system Dialer
+        return BlockedNumbersSdkCompat.canCurrentUserBlockNumbers(context);
+    }
+
+    /**
+     * Used to determine if the call blocking settings can be opened.
+     *
+     * @param context The {@link Context}.
+     * @return {@code true} if the current user can open the call blocking settings, {@code false}
+     * otherwise.
+     */
+    public static boolean canCurrentUserOpenBlockSettings(Context context) {
+        if (!CompatUtils.isNCompatible()) {
+            // Dialer blocking, must be primary user
+            return UserManagerCompat.isSystemUser(
+                    (UserManager) context.getSystemService(Context.USER_SERVICE));
+        }
+        // BlockedNumberContract blocking, verify through Contract API
+        return BlockedNumbersSdkCompat.canCurrentUserBlockNumbers(context);
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberAsyncQueryHandler.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberAsyncQueryHandler.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberAsyncQueryHandler.java	(revision 9196)
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.dialer.database;
+
+import android.content.AsyncQueryHandler;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabaseCorruptException;
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.telephony.PhoneNumberUtils;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.dialer.compat.FilteredNumberCompat;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumber;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberColumns;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberTypes;
+
+public class FilteredNumberAsyncQueryHandler extends AsyncQueryHandler {
+    private static final int NO_TOKEN = 0;
+    private static final String TAG = "FilteredNumberAsyncQueryHandler";
+
+    public FilteredNumberAsyncQueryHandler(ContentResolver cr) {
+        super(cr);
+    }
+
+    /**
+     * Methods for FilteredNumberAsyncQueryHandler result returns.
+     */
+    private static abstract class Listener {
+        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+        }
+        protected void onInsertComplete(int token, Object cookie, Uri uri) {
+        }
+        protected void onUpdateComplete(int token, Object cookie, int result) {
+        }
+        protected void onDeleteComplete(int token, Object cookie, int result) {
+        }
+    }
+
+    public interface OnCheckBlockedListener {
+        /**
+         * Invoked after querying if a number is blocked.
+         * @param id The ID of the row if blocked, null otherwise.
+         */
+        void onCheckComplete(Integer id);
+    }
+
+    public interface OnBlockNumberListener {
+        /**
+         * Invoked after inserting a blocked number.
+         * @param uri The uri of the newly created row.
+         */
+        void onBlockComplete(Uri uri);
+    }
+
+    public interface OnUnblockNumberListener {
+        /**
+         * Invoked after removing a blocked number
+         * @param rows The number of rows affected (expected value 1).
+         * @param values The deleted data (used for restoration).
+         */
+        void onUnblockComplete(int rows, ContentValues values);
+    }
+
+    public interface OnHasBlockedNumbersListener {
+        /**
+         * @param hasBlockedNumbers {@code true} if any blocked numbers are stored.
+         *     {@code false} otherwise.
+         */
+        void onHasBlockedNumbers(boolean hasBlockedNumbers);
+    }
+
+    @Override
+    protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+        if (cookie != null) {
+            ((Listener) cookie).onQueryComplete(token, cookie, cursor);
+        }
+    }
+
+    @Override
+    protected void onInsertComplete(int token, Object cookie, Uri uri) {
+        if (cookie != null) {
+            ((Listener) cookie).onInsertComplete(token, cookie, uri);
+        }
+    }
+
+    @Override
+    protected void onUpdateComplete(int token, Object cookie, int result) {
+        if (cookie != null) {
+            ((Listener) cookie).onUpdateComplete(token, cookie, result);
+        }
+    }
+
+    @Override
+    protected void onDeleteComplete(int token, Object cookie, int result) {
+        if (cookie != null) {
+            ((Listener) cookie).onDeleteComplete(token, cookie, result);
+        }
+    }
+
+    public final void incrementFilteredCount(Integer id) {
+        // No concept of counts with new filtering
+        if (FilteredNumberCompat.useNewFiltering()) {
+            return;
+        }
+        startUpdate(NO_TOKEN, null,
+                ContentUris.withAppendedId(FilteredNumber.CONTENT_URI_INCREMENT_FILTERED_COUNT, id),
+                null, null, null);
+    }
+
+    public void hasBlockedNumbers(final OnHasBlockedNumbersListener listener) {
+        startQuery(NO_TOKEN,
+                new Listener() {
+                    @Override
+                    protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+                        listener.onHasBlockedNumbers(cursor != null && cursor.getCount() > 0);
+                    }
+                },
+                FilteredNumberCompat.getContentUri(null),
+                new String[]{ FilteredNumberCompat.getIdColumnName() },
+                FilteredNumberCompat.useNewFiltering() ? null : FilteredNumberColumns.TYPE
+                        + "=" + FilteredNumberTypes.BLOCKED_NUMBER,
+                null,
+                null);
+    }
+
+    /**
+     * Check if this number has been blocked.
+     *
+     * @return {@code false} if the number was invalid and couldn't be checked,
+     *     {@code true} otherwise,
+     */
+    public boolean isBlockedNumber(
+            final OnCheckBlockedListener listener, String number, String countryIso) {
+        final String e164Number = PhoneNumberUtils.formatNumberToE164(number, countryIso);
+        if (TextUtils.isEmpty(e164Number)) {
+            return false;
+        }
+
+        startQuery(NO_TOKEN,
+                new Listener() {
+                    @Override
+                    protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+                        /*
+                         * In the frameworking blocking, numbers can be blocked in both e164 format
+                         * and not, resulting in multiple rows being returned for this query. For
+                         * example, both '16502530000' and '6502530000' can exist at the same time
+                         * and will be returned by this query.
+                         */
+                        if (cursor == null || cursor.getCount() == 0) {
+                            listener.onCheckComplete(null);
+                            return;
+                        }
+                        cursor.moveToFirst();
+                        // New filtering doesn't have a concept of type
+                        if (!FilteredNumberCompat.useNewFiltering()
+                                && cursor.getInt(cursor.getColumnIndex(FilteredNumberColumns.TYPE))
+                                != FilteredNumberTypes.BLOCKED_NUMBER) {
+                            listener.onCheckComplete(null);
+                            return;
+                        }
+                        listener.onCheckComplete(
+                                cursor.getInt(cursor.getColumnIndex(FilteredNumberColumns._ID)));
+                    }
+                },
+                FilteredNumberCompat.getContentUri(null),
+                FilteredNumberCompat.filter(new String[]{FilteredNumberCompat.getIdColumnName(),
+                        FilteredNumberCompat.getTypeColumnName()}),
+                FilteredNumberCompat.getE164NumberColumnName() + " = ?",
+                new String[]{e164Number},
+                null);
+
+        return true;
+    }
+
+    public void blockNumber(
+            final OnBlockNumberListener listener, String number, @Nullable String countryIso) {
+        blockNumber(listener, null, number, countryIso);
+    }
+
+    /**
+     * Add a number manually blocked by the user.
+     */
+    public void blockNumber(
+            final OnBlockNumberListener listener,
+            @Nullable String normalizedNumber,
+            String number,
+            @Nullable String countryIso) {
+        blockNumber(listener, FilteredNumberCompat.newBlockNumberContentValues(number,
+                normalizedNumber, countryIso));
+    }
+
+    /**
+     * Block a number with specified ContentValues. Can be manually added or a restored row
+     * from performing the 'undo' action after unblocking.
+     */
+    public void blockNumber(final OnBlockNumberListener listener, ContentValues values) {
+        startInsert(NO_TOKEN,
+                new Listener() {
+                    @Override
+                    public void onInsertComplete(int token, Object cookie, Uri uri) {
+                        if (listener != null ) {
+                            listener.onBlockComplete(uri);
+                        }
+                    }
+                }, FilteredNumberCompat.getContentUri(null), values);
+    }
+
+    /**
+     * Unblocks the number with the given id.
+     *
+     * @param listener (optional) The {@link OnUnblockNumberListener} called after the number is
+     * unblocked.
+     * @param id The id of the number to unblock.
+     */
+    public void unblock(@Nullable final OnUnblockNumberListener listener, Integer id) {
+        if (id == null) {
+            throw new IllegalArgumentException("Null id passed into unblock");
+        }
+        unblock(listener, FilteredNumberCompat.getContentUri(id));
+    }
+
+    /**
+     * Removes row from database.
+     * @param listener (optional) The {@link OnUnblockNumberListener} called after the number is
+     * unblocked.
+     * @param uri The uri of row to remove, from
+     * {@link FilteredNumberAsyncQueryHandler#blockNumber}.
+     */
+    public void unblock(@Nullable final OnUnblockNumberListener listener, final Uri uri) {
+        startQuery(NO_TOKEN, new Listener() {
+            @Override
+            public void onQueryComplete(int token, Object cookie, Cursor cursor) {
+                /** M:log the exception info.@{ */
+                if (cursor == null) {
+                    Log.i(TAG, "the query cursor is null.");
+                }
+                /**@}*/
+                int rowsReturned = cursor == null ? 0 : cursor.getCount();
+                if (rowsReturned != 1) {
+                    /**
+                     * M: should not throw exception here. because there is case that
+                     * the blocked number already be unblocked in other app.
+                     * that will cause here get nothing when do query.
+                    throw new SQLiteDatabaseCorruptException
+                            ("Returned " + rowsReturned + " rows for uri "
+                                    + uri + "where 1 expected.");
+                    */
+                    Log.i(TAG, "unblock, query blocked number failed, uri=" + uri);
+                    listener.onUnblockComplete(rowsReturned, new ContentValues());
+                    return;
+                }
+                cursor.moveToFirst();
+                final ContentValues values = new ContentValues();
+                DatabaseUtils.cursorRowToContentValues(cursor, values);
+                values.remove(FilteredNumberCompat.getIdColumnName());
+
+                startDelete(NO_TOKEN, new Listener() {
+                    @Override
+                    public void onDeleteComplete(int token, Object cookie, int result) {
+                        if (listener != null) {
+                            listener.onUnblockComplete(result, values);
+                        }
+                    }
+                }, uri, null, null);
+            }
+        }, uri, null, null, null, null);
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberContract.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberContract.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/FilteredNumberContract.java	(revision 9196)
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.dialer.database;
+
+import android.net.Uri;
+import android.provider.BaseColumns;
+
+import com.android.dialerbind.ObjectFactory;
+
+/**
+ * <p>
+ * The contract between the filtered number provider and applications. Contains
+ * definitions for the supported URIs and columns.
+ * Currently only accessible within Dialer.
+ * </p>
+ */
+public final class FilteredNumberContract {
+
+    /** The authority for the filtered numbers provider */
+    public static final String AUTHORITY = ObjectFactory.getFilteredNumberProviderAuthority();
+
+    /** A content:// style uri to the authority for the filtered numbers provider */
+    public static final Uri AUTHORITY_URI = Uri.parse("content://" + AUTHORITY);
+
+    /** The type of filtering to be applied, e.g. block the number or whitelist the number. */
+    public interface FilteredNumberTypes {
+        static final int UNDEFINED = 0;
+        /**
+         * Dialer will disconnect the call without sending the caller to voicemail.
+         */
+        static final int BLOCKED_NUMBER = 1;
+    }
+
+    /** The original source of the filtered number, e.g. the user manually added it. */
+    public interface FilteredNumberSources {
+        static final int UNDEFINED = 0;
+        /**
+         * The user manually added this number through Dialer (e.g. from the call log or InCallUI).
+         */
+        static final int USER = 1;
+    }
+
+    public interface FilteredNumberColumns {
+        // TYPE: INTEGER
+        static final String _ID = "_id";
+        /**
+         * Represents the number to be filtered, normalized to compare phone numbers for equality.
+         *
+         * TYPE: TEXT
+         */
+        static final String NORMALIZED_NUMBER = "normalized_number";
+        /**
+         * Represents the number to be filtered, for formatting and
+         * used with country iso for contact lookups.
+         *
+         * TYPE: TEXT
+         */
+        static final String NUMBER = "number";
+        /**
+         * The country code representing the country detected when
+         * the phone number was added to the database.
+         * Most numbers don't have the country code, so a best guess is provided by
+         * the country detector system. The country iso is also needed in order to format
+         * phone numbers correctly.
+         *
+         * TYPE: TEXT
+         */
+        static final String COUNTRY_ISO = "country_iso";
+        /**
+         * The number of times the number has been filtered by Dialer.
+         * When this number is incremented, LAST_TIME_FILTERED should also be updated to
+         * the current time.
+         *
+         * TYPE: INTEGER
+         */
+        static final String TIMES_FILTERED = "times_filtered";
+        /**
+         * Set to the current time when the phone number is filtered.
+         * When this is updated, TIMES_FILTERED should also be incremented.
+         *
+         * TYPE: LONG
+         */
+        static final String LAST_TIME_FILTERED = "last_time_filtered";
+        // TYPE: LONG
+        static final String CREATION_TIME = "creation_time";
+        /**
+         * Indicates the type of filtering to be applied.
+         *
+         * TYPE: INTEGER
+         * See {@link FilteredNumberTypes}
+         */
+        static final String TYPE = "type";
+        /**
+         * Integer representing the original source of the filtered number.
+         *
+         * TYPE: INTEGER
+         * See {@link FilteredNumberSources}
+         */
+        static final String SOURCE = "source";
+    }
+
+    /**
+     * <p>
+     * Constants for the table of filtered numbers.
+     * </p>
+     * <h3>Operations</h3>
+     * <dl>
+     * <dt><b>Insert</b></dt>
+     * <dd>Required fields: NUMBER, NORMALIZED_NUMBER, TYPE, SOURCE.
+     * A default value will be used for the other fields if left null.</dd>
+     * <dt><b>Update</b></dt>
+     * <dt><b>Delete</b></dt>
+     * <dt><b>Query</b></dt>
+     * <dd>{@link #CONTENT_URI} can be used for any query, append an ID to
+     * retrieve a specific filtered number entry.</dd>
+     * </dl>
+     */
+    public static class FilteredNumber implements BaseColumns {
+
+        public static final String FILTERED_NUMBERS_TABLE = "filtered_numbers_table";
+        public static final String FILTERED_NUMBERS_INCREMENT_FILTERED_COUNT =
+                "filtered_numbers_increment_filtered_count";
+
+        public static final Uri CONTENT_URI = Uri.withAppendedPath(
+                AUTHORITY_URI,
+                FILTERED_NUMBERS_TABLE);
+
+        public static final Uri CONTENT_URI_INCREMENT_FILTERED_COUNT = Uri.withAppendedPath(
+                AUTHORITY_URI,
+                FILTERED_NUMBERS_INCREMENT_FILTERED_COUNT);
+
+        /**
+         * This utility class cannot be instantiated.
+         */
+        private FilteredNumber () {}
+
+        /**
+         * The MIME type of {@link #CONTENT_URI} providing a directory of
+         * filtered numbers.
+         */
+        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/filtered_numbers_table";
+
+        /**
+         * The MIME type of a {@link #CONTENT_URI} single filtered number.
+         */
+        public static final String CONTENT_ITEM_TYPE =
+                "vnd.android.cursor.item/filtered_numbers_table";
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/callfiltering/BlockCheckerAdapter.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/callfiltering/BlockCheckerAdapter.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/callfiltering/BlockCheckerAdapter.java	(revision 9196)
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.server.telecom.callfiltering;
+
+import android.content.Context;
+
+import com.android.internal.telephony.BlockChecker;
+
+public class BlockCheckerAdapter {
+    public BlockCheckerAdapter() { }
+
+    public boolean isBlocked(Context context, String number) {
+        return BlockChecker.isBlocked(context, number);
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/settings/BlockNumberTaskFragment.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/settings/BlockNumberTaskFragment.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/services/Telecomm/src/com/android/server/telecom/settings/BlockNumberTaskFragment.java	(revision 9196)
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.server.telecom.settings;
+
+import android.annotation.Nullable;
+import android.app.Fragment;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.provider.BlockedNumberContract;
+import com.android.server.telecom.R;
+
+/**
+ * Retained fragment that runs an async task to add a blocked number.
+ *
+ * <p>We run the task inside a retained fragment so that if the screen orientation changed, the
+ * task does not get lost.
+ */
+public class BlockNumberTaskFragment extends Fragment {
+    @Nullable private BlockNumberTask mTask;
+    @Nullable Listener mListener;
+
+    /**
+     * Task to block a number.
+     */
+    private class BlockNumberTask extends AsyncTask<String, Void, Boolean> {
+        private String mNumber;
+
+        /**
+         * @return true if number was blocked; false if number is already blocked.
+         */
+        @Override
+        protected Boolean doInBackground(String... params) {
+            mNumber = params[0];
+            if (BlockedNumberContract.isBlocked(getContext(), mNumber)) {
+                return false;
+            } else {
+                ContentResolver contentResolver = getContext().getContentResolver();
+                ContentValues newValues = new ContentValues();
+                newValues.put(BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER,
+                        mNumber);
+                contentResolver.insert(BlockedNumberContract.BlockedNumbers.CONTENT_URI,
+                        newValues);
+                return true;
+            }
+        }
+
+        @Override
+        protected void onPostExecute(Boolean result) {
+            mTask = null;
+            if (mListener != null) {
+                mListener.onBlocked(mNumber, !result /* alreadyBlocked */);
+            }
+            mListener = null;
+        }
+    }
+
+    public interface Listener {
+        void onBlocked(String number, boolean alreadyBlocked);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    @Override
+    public void onDestroy() {
+        if (mTask != null) {
+            mTask.cancel(true /* mayInterruptIfRunning */);
+        }
+        super.onDestroy();
+    }
+
+    /**
+     * Runs an async task to write the number to the blocked numbers provider if it does not already
+     * exist.
+     *
+     * Triggers {@link Listener#onBlocked(String, boolean)} when task finishes to show proper UI.
+     */
+    public void blockIfNotAlreadyBlocked(String number, Listener listener) {
+        mListener = listener;
+        mTask = new BlockNumberTask();
+        mTask.execute(number);
+    }
+}
\ No newline at end of file
Index: vendor/branch/5058I_ALRU/frameworks/base/core/java/android/provider/BlockedNumberContract.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/base/core/java/android/provider/BlockedNumberContract.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/base/core/java/android/provider/BlockedNumberContract.java	(revision 9196)
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package android.provider;
+
+import android.annotation.WorkerThread;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Bundle;
+
+/**
+ * <p>
+ * The contract between the blockednumber provider and applications. Contains definitions for
+ * the supported URIs and columns.
+ * </p>
+ *
+ * <h3> Overview </h3>
+ * <p>
+ * The content provider exposes a table containing blocked numbers. The columns and URIs for
+ * accessing this table are defined by the {@link BlockedNumbers} class. Messages, and calls from
+ * blocked numbers are discarded by the platform. Notifications upon provider changes can be
+ * received using a {@link android.database.ContentObserver}.
+ * </p>
+ * <p>
+ * The platform will not block messages, and calls from emergency numbers as defined by
+ * {@link android.telephony.PhoneNumberUtils#isEmergencyNumber(String)}. If the user contacts
+ * emergency services, number blocking is disabled by the platform for a duration defined by
+ * {@link android.telephony.CarrierConfigManager#KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT}.
+ * </p>
+ *
+ * <h3> Permissions </h3>
+ * <p>
+ * Only the system, the default SMS application, and the default phone app
+ * (See {@link android.telecom.TelecomManager#getDefaultDialerPackage()}), and carrier apps
+ * (See {@link android.service.carrier.CarrierService}) can read, and write to the blockednumber
+ * provider. However, {@link #canCurrentUserBlockNumbers(Context)} can be accessed by any
+ * application.
+ * </p>
+ *
+ * <h3> Data </h3>
+ * <p>
+ * Other than regular phone numbers, the blocked number provider can also store addresses (such
+ * as email) from which a user can receive messages, and calls. The blocked numbers are stored
+ * in the {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column. A normalized version of phone
+ * numbers (if normalization is possible) is stored in {@link BlockedNumbers#COLUMN_E164_NUMBER}
+ * column. The platform blocks calls, and messages from an address if it is present in in the
+ * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column or if the E164 version of the address
+ * matches the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
+ * </p>
+ *
+ * <h3> Operations </h3>
+ * <dl>
+ * <dt><b>Insert</b></dt>
+ * <dd>
+ * <p>
+ * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} is a required column that needs to be populated.
+ * Apps can optionally provide the {@link BlockedNumbers#COLUMN_E164_NUMBER} which is the phone
+ * number's E164 representation. The provider automatically populates this column if the app does
+ * not provide it. Note that this column is not populated if normalization fails or if the address
+ * is not a phone number (eg: email).
+ * <p>
+ * Attempting to insert an existing blocked number (same
+ * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column) will result in replacing the existing
+ * blocked number.
+ * <p>
+ * Examples:
+ * <pre>
+ * ContentValues values = new ContentValues();
+ * values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
+ * Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
+ * </pre>
+ * <pre>
+ * ContentValues values = new ContentValues();
+ * values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
+ * values.put(BlockedNumbers.COLUMN_E164_NUMBER, "+11234567890");
+ * Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
+ * </pre>
+ * <pre>
+ * ContentValues values = new ContentValues();
+ * values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "12345@abdcde.com");
+ * Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
+ * </pre>
+ * </p>
+ * </dd>
+ * <dt><b>Update</b></dt>
+ * <dd>
+ * <p>
+ * Updates are not supported. Use Delete, and Insert instead.
+ * </p>
+ * </dd>
+ * <dt><b>Delete</b></dt>
+ * <dd>
+ * <p>
+ * Deletions can be performed as follows:
+ * <pre>
+ * ContentValues values = new ContentValues();
+ * values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
+ * Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
+ * getContentResolver().delete(uri, null, null);
+ * </pre>
+ * To check if a particular number is blocked, use the method
+ * {@link #isBlocked(Context, String)}.
+ * </p>
+ * </dd>
+ * <dt><b>Query</b></dt>
+ * <dd>
+ * <p>
+ * All blocked numbers can be enumerated as follows:
+ * <pre>
+ * Cursor c = getContentResolver().query(BlockedNumbers.CONTENT_URI,
+ *          new String[]{BlockedNumbers.COLUMN_ID, BlockedNumbers.COLUMN_ORIGINAL_NUMBER,
+ *          BlockedNumbers.COLUMN_E164_NUMBER}, null, null, null);
+ * </pre>
+ * </p>
+ * </dd>
+ * <dt><b>Unblock</b></dt>
+ * <dd>
+ * <p>
+ * Use the method {@link #unblock(Context, String)} to unblock numbers.
+ * </p>
+ * </dd>
+ *
+ * <h3> Multi-user </h3>
+ * <p>
+ * Apps must use the method {@link #canCurrentUserBlockNumbers(Context)} before performing any
+ * operation on the blocked number provider. If {@link #canCurrentUserBlockNumbers(Context)} returns
+ * {@code false}, all operations on the provider will fail with a {@link SecurityException}. The
+ * platform will block calls, and messages from numbers in the provider independent of the current
+ * user.
+ * </p>
+ */
+public class BlockedNumberContract {
+    private BlockedNumberContract() {
+    }
+
+    /** The authority for the blocked number provider */
+    public static final String AUTHORITY = "com.android.blockednumber";
+
+    /** A content:// style uri to the authority for the blocked number provider */
+    public static final Uri AUTHORITY_URI = Uri.parse("content://" + AUTHORITY);
+
+    /**
+     * Constants to interact with the blocked numbers list.
+     */
+    public static class BlockedNumbers {
+        private BlockedNumbers() {
+        }
+
+        /**
+         * Content URI for the blocked numbers.
+         * <h3> Supported operations </h3>
+         * <p> blocked
+         * <ul>
+         * <li> query
+         * <li> delete
+         * <li> insert
+         * </ul>
+         * <p> blocked/ID
+         * <ul>
+         * <li> query (selection is not supported)
+         * <li> delete (selection is not supported)
+         * </ul>
+         */
+        public static final Uri CONTENT_URI = Uri.withAppendedPath(AUTHORITY_URI, "blocked");
+
+        /**
+         * The MIME type of {@link #CONTENT_URI} itself providing a directory of blocked phone
+         * numbers.
+         */
+        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/blocked_number";
+
+        /**
+         * The MIME type of a blocked phone number under {@link #CONTENT_URI}.
+         */
+        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/blocked_number";
+
+        /**
+         * Auto-generated ID field which monotonically increases.
+         * <p>TYPE: long</p>
+         */
+        public static final String COLUMN_ID = "_id";
+
+        /**
+         * Phone number to block.
+         * <p>Must be specified in {@code insert}.
+         * <p>TYPE: String</p>
+         */
+        public static final String COLUMN_ORIGINAL_NUMBER = "original_number";
+
+        /**
+         * Phone number to block.  The system generates it from {@link #COLUMN_ORIGINAL_NUMBER}
+         * by removing all formatting characters.
+         * <p>Optional in {@code insert}.  When not specified, the system tries to generate it
+         * assuming the current country. (Which will still be null if the number is not valid.)
+         * <p>TYPE: String</p>
+         */
+        public static final String COLUMN_E164_NUMBER = "e164_number";
+    }
+
+    /** @hide */
+    public static final String METHOD_IS_BLOCKED = "is_blocked";
+
+    /** @hide */
+    public static final String METHOD_UNBLOCK= "unblock";
+
+    /** @hide */
+    public static final String RES_NUMBER_IS_BLOCKED = "blocked";
+
+    /** @hide */
+    public static final String RES_NUM_ROWS_DELETED = "num_deleted";
+
+    /** @hide */
+    public static final String METHOD_CAN_CURRENT_USER_BLOCK_NUMBERS =
+            "can_current_user_block_numbers";
+
+    /** @hide */
+    public static final String RES_CAN_BLOCK_NUMBERS = "can_block";
+
+    /**
+     * Returns whether a given number is in the blocked list.
+     *
+     * <p> This matches the {@code phoneNumber} against the
+     * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column, and the E164 representation of the
+     * {@code phoneNumber} with the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
+     *
+     * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
+     * context {@code context}, this method will throw a {@link SecurityException}.
+     *
+     * @return {@code true} if the {@code phoneNumber} is blocked.
+     */
+    @WorkerThread
+    public static boolean isBlocked(Context context, String phoneNumber) {
+        final Bundle res = context.getContentResolver().call(
+                AUTHORITY_URI, METHOD_IS_BLOCKED, phoneNumber, null);
+        return res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
+    }
+
+    /**
+     * Unblocks the {@code phoneNumber} if it is blocked.
+     *
+     * <p> This deletes all rows where the {@code phoneNumber} matches the
+     * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column or the E164 representation of the
+     * {@code phoneNumber} matches the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
+     *
+     * <p>To delete rows based on exact match with specific columns such as
+     * {@link BlockedNumbers#COLUMN_ID} use
+     * {@link android.content.ContentProvider#delete(Uri, String, String[])} with
+     * {@link BlockedNumbers#CONTENT_URI} URI.
+     *
+     * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
+     * context {@code context}, this method will throw a {@link SecurityException}.
+     *
+     * @return the number of rows deleted in the blocked number provider as a result of unblock.
+     */
+    @WorkerThread
+    public static int unblock(Context context, String phoneNumber) {
+        final Bundle res = context.getContentResolver().call(
+                AUTHORITY_URI, METHOD_UNBLOCK, phoneNumber, null);
+        return res.getInt(RES_NUM_ROWS_DELETED, 0);
+    }
+
+    /**
+     * Checks if blocking numbers is supported for the current user.
+     * <p> Typically, blocking numbers is only supported for one user at a time.
+     *
+     * @return {@code true} if the current user can block numbers.
+     */
+    public static boolean canCurrentUserBlockNumbers(Context context) {
+        final Bundle res = context.getContentResolver().call(
+                AUTHORITY_URI, METHOD_CAN_CURRENT_USER_BLOCK_NUMBERS, null, null);
+        return res != null && res.getBoolean(RES_CAN_BLOCK_NUMBERS, false);
+    }
+
+    /**
+     * <p>
+     * The contract between the blockednumber provider and the system.
+     * </p>
+     * <p>This is a wrapper over {@link BlockedNumberContract} that also manages the blocking
+     * behavior when the user contacts emergency services. See
+     * {@link #notifyEmergencyContact(Context)} for details. All methods are protected by
+     * {@link android.Manifest.permission#READ_BLOCKED_NUMBERS} and
+     * {@link android.Manifest.permission#WRITE_BLOCKED_NUMBERS} appropriately which ensure that
+     * only system can access the methods defined here.
+     * </p>
+     * @hide
+     */
+    public static class SystemContract {
+        /**
+         * A protected broadcast intent action for letting components with
+         * {@link android.Manifest.permission#READ_BLOCKED_NUMBERS} know that the block suppression
+         * status as returned by {@link #getBlockSuppressionStatus(Context)} has been updated.
+         */
+        public static final String ACTION_BLOCK_SUPPRESSION_STATE_CHANGED =
+                "android.provider.action.BLOCK_SUPPRESSION_STATE_CHANGED";
+
+        public static final String METHOD_NOTIFY_EMERGENCY_CONTACT = "notify_emergency_contact";
+
+        public static final String METHOD_END_BLOCK_SUPPRESSION = "end_block_suppression";
+
+        public static final String METHOD_SHOULD_SYSTEM_BLOCK_NUMBER = "should_system_block_number";
+
+        public static final String METHOD_GET_BLOCK_SUPPRESSION_STATUS =
+                "get_block_suppression_status";
+
+        public static final String RES_IS_BLOCKING_SUPPRESSED = "blocking_suppressed";
+
+        public static final String RES_BLOCKING_SUPPRESSED_UNTIL_TIMESTAMP =
+                "blocking_suppressed_until_timestamp";
+
+        /**
+         * Notifies the provider that emergency services were contacted by the user.
+         * <p> This results in {@link #shouldSystemBlockNumber} returning {@code false} independent
+         * of the contents of the provider for a duration defined by
+         * {@link android.telephony.CarrierConfigManager#KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT}
+         * the provider unless {@link #endBlockSuppression(Context)} is called.
+         */
+        public static void notifyEmergencyContact(Context context) {
+            context.getContentResolver().call(
+                    AUTHORITY_URI, METHOD_NOTIFY_EMERGENCY_CONTACT, null, null);
+        }
+
+        /**
+         * Notifies the provider to disable suppressing blocking. If emergency services were not
+         * contacted recently at all, calling this method is a no-op.
+         */
+        public static void endBlockSuppression(Context context) {
+            context.getContentResolver().call(
+                    AUTHORITY_URI, METHOD_END_BLOCK_SUPPRESSION, null, null);
+        }
+
+        /**
+         * Returns {@code true} if {@code phoneNumber} is blocked taking
+         * {@link #notifyEmergencyContact(Context)} into consideration. If emergency services have
+         * not been contacted recently, this method is equivalent to
+         * {@link #isBlocked(Context, String)}.
+         */
+        public static boolean shouldSystemBlockNumber(Context context, String phoneNumber) {
+            final Bundle res = context.getContentResolver().call(
+                    AUTHORITY_URI, METHOD_SHOULD_SYSTEM_BLOCK_NUMBER, phoneNumber, null);
+            return res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
+        }
+
+        /**
+         * Returns the current status of block suppression.
+         */
+        public static BlockSuppressionStatus getBlockSuppressionStatus(Context context) {
+            final Bundle res = context.getContentResolver().call(
+                    AUTHORITY_URI, METHOD_GET_BLOCK_SUPPRESSION_STATUS, null, null);
+            return new BlockSuppressionStatus(res.getBoolean(RES_IS_BLOCKING_SUPPRESSED, false),
+                    res.getLong(RES_BLOCKING_SUPPRESSED_UNTIL_TIMESTAMP, 0));
+        }
+
+        /**
+         * Represents the current status of {@link #shouldSystemBlockNumber(Context, String)}. If
+         * emergency services have been contacted recently, {@link #isSuppressed} is {@code true},
+         * and blocking is disabled until the timestamp {@link #untilTimestampMillis}.
+         */
+        public static class BlockSuppressionStatus {
+            public final boolean isSuppressed;
+            /**
+             * Timestamp in milliseconds from epoch.
+             */
+            public final long untilTimestampMillis;
+
+            public BlockSuppressionStatus(boolean isSuppressed, long untilTimestampMillis) {
+                this.isSuppressed = isSuppressed;
+                this.untilTimestampMillis = untilTimestampMillis;
+            }
+        }
+    }
+}
Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/BlockChecker.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/BlockChecker.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/BlockChecker.java	(revision 9196)
@@ -0,0 +1,40 @@
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.provider.BlockedNumberContract;
+import android.telephony.Rlog;
+
+/**
+ * {@hide} Checks for blocked phone numbers against {@link BlockedNumberContract}
+ */
+public class BlockChecker {
+    private static final String TAG = "BlockChecker";
+    private static final boolean VDBG = false; // STOPSHIP if true.
+
+    /**
+     * Returns {@code true} if {@code phoneNumber} is blocked.
+     * <p>
+     * This method catches all underlying exceptions to ensure that this method never throws any
+     * exception.
+     */
+    public static boolean isBlocked(Context context, String phoneNumber) {
+        boolean isBlocked = false;
+        long startTimeNano = System.nanoTime();
+
+        try {
+            if (BlockedNumberContract.SystemContract.shouldSystemBlockNumber(
+                    context, phoneNumber)) {
+                Rlog.d(TAG, phoneNumber + " is blocked.");
+                isBlocked = true;
+            }
+        } catch (Exception e) {
+            Rlog.e(TAG, "Exception checking for blocked number: " + e);
+        }
+
+        int durationMillis = (int) ((System.nanoTime() - startTimeNano) / 1000000);
+        if (durationMillis > 500 || VDBG) {
+            Rlog.d(TAG, "Blocked number lookup took: " + durationMillis + " ms.");
+        }
+        return isBlocked;
+    }
+}
Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java	(revision 9196)
@@ -0,0 +1,2213 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static android.service.carrier.CarrierMessagingService.RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE;
+import static android.telephony.TelephonyManager.PHONE_TYPE_CDMA;
+
+import android.app.Activity;
+import android.app.ActivityManagerNative;
+import android.app.AppOpsManager;
+import android.app.BroadcastOptions;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.PendingIntent.CanceledException;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.UserInfo;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.net.Uri;
+import android.os.storage.StorageManager;
+import android.os.AsyncResult;
+import android.os.Binder;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.IDeviceIdleController;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Sms.Intents;
+import android.service.carrier.CarrierMessagingService;
+import android.service.carrier.ICarrierMessagingCallback;
+import android.service.carrier.ICarrierMessagingService;
+import android.service.carrier.MessagePdu;
+import android.telephony.CarrierMessagingServiceManager;
+import android.telephony.Rlog;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.util.HexDump;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+// MTK-START
+import com.mediatek.common.MPlugin;
+
+// Concatenated feature
+import com.mediatek.common.sms.IConcatenatedSmsFwkExt;
+import com.mediatek.common.sms.TimerRecord;
+
+
+// Phone Privacy Lock
+import android.content.IntentFilter;
+import com.mediatek.internal.telephony.ppl.IPplSmsFilter;
+import com.mediatek.internal.telephony.ppl.PplSmsFilterExtension;
+
+import android.os.SystemProperties;
+// MTK-END
+
+/**
+ * This class broadcasts incoming SMS messages to interested apps after storing them in
+ * the SmsProvider "raw" table and ACKing them to the SMSC. After each message has been
+ * broadcast, its parts are removed from the raw table. If the device crashes after ACKing
+ * but before the broadcast completes, the pending messages will be rebroadcast on the next boot.
+ *
+ * <p>The state machine starts in {@link IdleState} state. When the {@link SMSDispatcher} receives a
+ * new SMS from the radio, it calls {@link #dispatchNormalMessage},
+ * which sends a message to the state machine, causing the wakelock to be acquired in
+ * {@link #haltedProcessMessage}, which transitions to {@link DeliveringState} state, where the message
+ * is saved to the raw table, then acknowledged via the {@link SMSDispatcher} which called us.
+ *
+ * <p>After saving the SMS, if the message is complete (either single-part or the final segment
+ * of a multi-part SMS), we broadcast the completed PDUs as an ordered broadcast, then transition to
+ * {@link WaitingState} state to wait for the broadcast to complete. When the local
+ * {@link BroadcastReceiver} is called with the result, it sends {@link #EVENT_BROADCAST_COMPLETE}
+ * to the state machine, causing us to either broadcast the next pending message (if one has
+ * arrived while waiting for the broadcast to complete), or to transition back to the halted state
+ * after all messages are processed. Then the wakelock is released and we wait for the next SMS.
+ */
+public abstract class InboundSmsHandler extends StateMachine {
+    protected static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true, logs user data
+
+    /** Query projection for checking for duplicate message segments. */
+    private static final String[] PDU_PROJECTION = {
+            "pdu"
+    };
+
+    /** Query projection for combining concatenated message segments. */
+    private static final String[] PDU_SEQUENCE_PORT_PROJECTION = {
+            "pdu",
+            "sequence",
+            "destination_port"
+    };
+
+    public static final int PDU_COLUMN = 0;
+    public static final int SEQUENCE_COLUMN = 1;
+    public static final int DESTINATION_PORT_COLUMN = 2;
+    public static final int DATE_COLUMN = 3;
+    public static final int REFERENCE_NUMBER_COLUMN = 4;
+    public static final int COUNT_COLUMN = 5;
+    public static final int ADDRESS_COLUMN = 6;
+    public static final int ID_COLUMN = 7;
+    public static final int MESSAGE_BODY_COLUMN = 8;
+    // MTK-START
+    public static final int SUB_ID_COLUMN = 9;
+    private static final boolean ENG = "eng".equals(Build.TYPE);
+    // MTK-END
+
+    public static final String SELECT_BY_ID = "_id=?";
+    // MTK-START
+    public static final String SELECT_BY_REFERENCE = "address=? AND reference_number=? AND " +
+            "count=? AND deleted=0 AND sub_id=?";
+    // MTK-END
+
+    /** New SMS received as an AsyncResult. */
+    public static final int EVENT_NEW_SMS = 1;
+
+    /** Message type containing a {@link InboundSmsTracker} ready to broadcast to listeners. */
+    public static final int EVENT_BROADCAST_SMS = 2;
+
+    /** Message from resultReceiver notifying {@link WaitingState} of a completed broadcast. */
+    private static final int EVENT_BROADCAST_COMPLETE = 3;
+
+    /** Sent on exit from {@link WaitingState} to return to idle after sending all broadcasts. */
+    private static final int EVENT_RETURN_TO_IDLE = 4;
+
+    /** Release wakelock after a short timeout when returning to idle state. */
+    private static final int EVENT_RELEASE_WAKELOCK = 5;
+
+    /** Sent by {@link SmsBroadcastUndelivered} after cleaning the raw table. */
+    public static final int EVENT_START_ACCEPTING_SMS = 6;
+
+    /** Update phone object */
+    private static final int EVENT_UPDATE_PHONE_OBJECT = 7;
+
+    /** New SMS received as an AsyncResult. */
+    public static final int EVENT_INJECT_SMS = 8;
+
+    /** Wakelock release delay when returning to idle state. */
+    private static final int WAKELOCK_TIMEOUT = 3000;
+
+    // The notitfication tag used when showing a notification. The combination of notification tag
+    // and notification id should be unique within the phone app.
+    private static final String NOTIFICATION_TAG = "InboundSmsHandler";
+    private static final int NOTIFICATION_ID_NEW_MESSAGE = 1;
+
+    /** URI for raw table of SMS provider. */
+    protected static final Uri sRawUri = Uri.withAppendedPath(Telephony.Sms.CONTENT_URI, "raw");
+    protected static final Uri sRawUriPermanentDelete =
+            Uri.withAppendedPath(Telephony.Sms.CONTENT_URI, "raw/permanentDelete");
+
+    protected final Context mContext;
+    private final ContentResolver mResolver;
+
+    /** Special handler for WAP push messages. */
+    private final WapPushOverSms mWapPush;
+
+    /** Wake lock to ensure device stays awake while dispatching the SMS intents. */
+    private final PowerManager.WakeLock mWakeLock;
+
+    /** DefaultState throws an exception or logs an error for unhandled message types. */
+    private final DefaultState mDefaultState = new DefaultState();
+
+    /** Startup state. Waiting for {@link SmsBroadcastUndelivered} to complete. */
+    private final StartupState mStartupState = new StartupState();
+
+    /** Idle state. Waiting for messages to process. */
+    private final IdleState mIdleState = new IdleState();
+
+    /** Delivering state. Saves the PDU in the raw table and acknowledges to SMSC. */
+    private final DeliveringState mDeliveringState = new DeliveringState();
+
+    /** Broadcasting state. Waits for current broadcast to complete before delivering next. */
+    private final WaitingState mWaitingState = new WaitingState();
+
+    /** Helper class to check whether storage is available for incoming messages. */
+    // MTK-START, change as public for GsmSmsDispatcher to use
+    public SmsStorageMonitor mStorageMonitor;
+    // MTK-END
+
+    private final boolean mSmsReceiveDisabled;
+
+    protected Phone mPhone;
+
+    protected CellBroadcastHandler mCellBroadcastHandler;
+
+    private UserManager mUserManager;
+
+    IDeviceIdleController mDeviceIdleController;
+
+    // Delete permanently from raw table
+    private final int DELETE_PERMANENTLY = 1;
+    // Only mark deleted, but keep in db for message de-duping
+    private final int MARK_DELETED = 2;
+
+
+    // MTK-START
+    /** sms database raw table locker */
+    protected Object mRawLock = new Object();
+
+    /** Concatenated SMS handler. A timer to show concatenated SMS or CT special requirement */
+    private IConcatenatedSmsFwkExt mConcatenatedSmsFwkExt = null;
+
+    /** Mobile manager service for phone privacy lock */
+    private IPplSmsFilter mPplSmsFilter = null;
+    // MTK-END
+
+
+    private static String ACTION_OPEN_SMS_APP =
+        "com.android.internal.telephony.OPEN_DEFAULT_SMS_APP";
+
+    /**
+     * Create a new SMS broadcast helper.
+     * @param name the class name for logging
+     * @param context the context of the phone app
+     * @param storageMonitor the SmsStorageMonitor to check for storage availability
+     */
+    protected InboundSmsHandler(String name, Context context, SmsStorageMonitor storageMonitor,
+            Phone phone, CellBroadcastHandler cellBroadcastHandler) {
+        super(name);
+
+        mContext = context;
+        mStorageMonitor = storageMonitor;
+        mPhone = phone;
+        mCellBroadcastHandler = cellBroadcastHandler;
+        mResolver = context.getContentResolver();
+        mWapPush = new WapPushOverSms(context);
+
+        boolean smsCapable = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_sms_capable);
+        mSmsReceiveDisabled = !TelephonyManager.from(mContext).getSmsReceiveCapableForPhone(
+                mPhone.getPhoneId(), smsCapable);
+
+        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, name);
+        mWakeLock.acquire();    // wake lock released after we enter idle state
+        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+        mDeviceIdleController = TelephonyComponentFactory.getInstance().getIDeviceIdleController();
+
+        addState(mDefaultState);
+        addState(mStartupState, mDefaultState);
+        addState(mIdleState, mDefaultState);
+        addState(mDeliveringState, mDefaultState);
+            addState(mWaitingState, mDeliveringState);
+
+        setInitialState(mStartupState);
+        if (DBG) log("created InboundSmsHandler");
+
+        // MTK-START
+        // Create concatenated class to handle MTK concatenated behavior
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            try {
+                mConcatenatedSmsFwkExt = MPlugin.createInstance(
+                        IConcatenatedSmsFwkExt.class.getName(), mContext);
+                if (mConcatenatedSmsFwkExt != null) {
+                    mConcatenatedSmsFwkExt.setPhoneId(mPhone.getPhoneId());
+                    String actualClassName = mConcatenatedSmsFwkExt.getClass().getName();
+                    log("initial IConcatenatedSmsFwkExt done, actual class name is " +
+                            actualClassName);
+                } else {
+                    log("FAIL! intial mConcatenatedSmsFwkExt");
+                }
+            } catch (RuntimeException e) {
+                loge("FAIL! No IConcatenatedSmsFwkExt");
+            }
+        }
+
+        mPplSmsFilter = new PplSmsFilterExtension(mContext);
+
+        if (SmsConstants.isPrivacyLockSupport()) {
+            // Register the Moms intent receiver;
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intents.PRIVACY_LOCK_SMS_RECEIVED_ACTION);
+            mContext.registerReceiver(mPhonePrivacyLockReceiver, filter);
+        }
+        // MTK-END
+    }
+
+    /**
+     * Tell the state machine to quit after processing all messages.
+     */
+    public void dispose() {
+        quit();
+    }
+
+    /**
+     * Update the phone object when it changes.
+     */
+    public void updatePhoneObject(Phone phone) {
+        sendMessage(EVENT_UPDATE_PHONE_OBJECT, phone);
+    }
+
+    /**
+     * Dispose of the WAP push object and release the wakelock.
+     */
+    @Override
+    protected void onQuitting() {
+        mWapPush.dispose();
+
+        while (mWakeLock.isHeld()) {
+            mWakeLock.release();
+        }
+
+        // MTK-START
+        // De-register the receiver from context
+        if (SmsConstants.isPrivacyLockSupport()) {
+            mContext.unregisterReceiver(mPhonePrivacyLockReceiver);
+        }
+        // MTK-END
+    }
+
+    // CAF_MSIM Is this used anywhere ? if not remove it
+    public Phone getPhone() {
+        return mPhone;
+    }
+
+    /**
+     * This parent state throws an exception (for debug builds) or prints an error for unhandled
+     * message types.
+     */
+    private class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case EVENT_UPDATE_PHONE_OBJECT: {
+                    onUpdatePhoneObject((Phone) msg.obj);
+                    break;
+                }
+                default: {
+                    String errorText = "processMessage: unhandled message type " + msg.what +
+                        " currState=" + getCurrentState().getName();
+                    if (Build.IS_DEBUGGABLE) {
+                        loge("---- Dumping InboundSmsHandler ----");
+                        loge("Total records=" + getLogRecCount());
+                        for (int i = Math.max(getLogRecSize() - 20, 0); i < getLogRecSize(); i++) {
+                            loge("Rec[%d]: %s\n" + i + getLogRec(i).toString());
+                        }
+                        loge("---- Dumped InboundSmsHandler ----");
+
+                        throw new RuntimeException(errorText);
+                    } else {
+                        loge(errorText);
+                    }
+                    break;
+                }
+            }
+            return HANDLED;
+        }
+    }
+
+    /**
+     * The Startup state waits for {@link SmsBroadcastUndelivered} to process the raw table and
+     * notify the state machine to broadcast any complete PDUs that might not have been broadcast.
+     */
+    private class StartupState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            log("StartupState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                case EVENT_INJECT_SMS:
+                case EVENT_BROADCAST_SMS:
+                // MTK-START
+                case IConcatenatedSmsFwkExt.EVENT_DISPATCH_CONCATE_SMS_SEGMENTS:
+                // MTK-END
+                    deferMessage(msg);
+                    return HANDLED;
+
+                case EVENT_START_ACCEPTING_SMS:
+                    transitionTo(mIdleState);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_RETURN_TO_IDLE:
+                case EVENT_RELEASE_WAKELOCK:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * In the idle state the wakelock is released until a new SM arrives, then we transition
+     * to Delivering mode to handle it, acquiring the wakelock on exit.
+     */
+    private class IdleState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("entering Idle state");
+            sendMessageDelayed(EVENT_RELEASE_WAKELOCK, WAKELOCK_TIMEOUT);
+        }
+
+        @Override
+        public void exit() {
+            mWakeLock.acquire();
+            if (DBG) log("acquired wakelock, leaving Idle state");
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            log("IdleState.processMessage:" + msg.what);
+            if (DBG) log("Idle state processing message type " + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                case EVENT_INJECT_SMS:
+                case EVENT_BROADCAST_SMS:
+                // MTK-START
+                case IConcatenatedSmsFwkExt.EVENT_DISPATCH_CONCATE_SMS_SEGMENTS:
+                // MTK-END
+                    deferMessage(msg);
+                    transitionTo(mDeliveringState);
+                    return HANDLED;
+
+                case EVENT_RELEASE_WAKELOCK:
+                    mWakeLock.release();
+                    if (DBG) {
+                        if (mWakeLock.isHeld()) {
+                            // this is okay as long as we call release() for every acquire()
+                            log("mWakeLock is still held after release");
+                        } else {
+                            log("mWakeLock released");
+                        }
+                    }
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // already in idle state; ignore
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_START_ACCEPTING_SMS:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * In the delivering state, the inbound SMS is processed and stored in the raw table.
+     * The message is acknowledged before we exit this state. If there is a message to broadcast,
+     * transition to {@link WaitingState} state to send the ordered broadcast and wait for the
+     * results. When all messages have been processed, the halting state will release the wakelock.
+     */
+    private class DeliveringState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("entering Delivering state");
+        }
+
+        @Override
+        public void exit() {
+            if (DBG) log("leaving Delivering state");
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            log("DeliveringState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                    // handle new SMS from RIL
+                    handleNewSms((AsyncResult) msg.obj);
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    return HANDLED;
+
+                case EVENT_INJECT_SMS:
+                    // handle new injected SMS
+                    handleInjectSms((AsyncResult) msg.obj);
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_SMS:
+                    // if any broadcasts were sent, transition to waiting state
+                    InboundSmsTracker inboundSmsTracker = (InboundSmsTracker) msg.obj;
+                    if (processMessagePart(inboundSmsTracker)) {
+                        transitionTo(mWaitingState);
+                    } else {
+                        // if event is sent from SmsBroadcastUndelivered.broadcastSms(), and
+                        // processMessagePart() returns false, the state machine will be stuck in
+                        // DeliveringState until next message is received. Send message to
+                        // transition to idle to avoid that so that wakelock can be released
+                        log("No broadcast sent on processing EVENT_BROADCAST_SMS in Delivering " +
+                                "state. Return to Idle state");
+                        sendMessage(EVENT_RETURN_TO_IDLE);
+                    }
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // return to idle after processing all other messages
+                    transitionTo(mIdleState);
+                    return HANDLED;
+
+                case EVENT_RELEASE_WAKELOCK:
+                    mWakeLock.release();    // decrement wakelock from previous entry to Idle
+                    if (!mWakeLock.isHeld()) {
+                        // wakelock should still be held until 3 seconds after we enter Idle
+                        loge("mWakeLock released while delivering/broadcasting!");
+                    }
+                    return HANDLED;
+
+                // MTK-START
+                case IConcatenatedSmsFwkExt.EVENT_DISPATCH_CONCATE_SMS_SEGMENTS:
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        if (dispatchConcateSmsParts((TimerRecord) msg.obj)) {
+                            transitionTo(mWaitingState);
+                        } else {
+                            //Error handle for dispatchConcateSmsParts, transition to Idle
+                            loge("Unexpected result for dispatching SMS segments");
+                            sendMessage(EVENT_RETURN_TO_IDLE);
+                        }
+                        return HANDLED;
+                    }
+                // MTK-END
+
+                // we shouldn't get this message type in this state, log error and halt.
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_START_ACCEPTING_SMS:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * The waiting state delegates handling of new SMS to parent {@link DeliveringState}, but
+     * defers handling of the {@link #EVENT_BROADCAST_SMS} phase until after the current
+     * result receiver sends {@link #EVENT_BROADCAST_COMPLETE}. Before transitioning to
+     * {@link DeliveringState}, {@link #EVENT_RETURN_TO_IDLE} is sent to transition to
+     * {@link IdleState} after any deferred {@link #EVENT_BROADCAST_SMS} messages are handled.
+     */
+    private class WaitingState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            log("WaitingState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_BROADCAST_SMS:
+                // MTK-START
+                case IConcatenatedSmsFwkExt.EVENT_DISPATCH_CONCATE_SMS_SEGMENTS:
+                // MTK-END
+                    // defer until the current broadcast completes
+                    deferMessage(msg);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                    // return to idle after handling all deferred messages
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    transitionTo(mDeliveringState);
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // not ready to return to idle; ignore
+                    return HANDLED;
+
+                default:
+                    // parent state handles the other message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    private void handleNewSms(AsyncResult ar) {
+        if (ar.exception != null) {
+            loge("Exception processing incoming SMS: " + ar.exception);
+            return;
+        }
+
+        int result;
+        try {
+            SmsMessage sms = (SmsMessage) ar.result;
+            result = dispatchMessage(sms.mWrappedSmsMessage);
+        } catch (RuntimeException ex) {
+            loge("Exception dispatching message", ex);
+            result = Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        // RESULT_OK means that the SMS will be acknowledged by special handling,
+        // e.g. for SMS-PP data download. Any other result, we should ack here.
+        if (result != Activity.RESULT_OK) {
+            boolean handled = (result == Intents.RESULT_SMS_HANDLED);
+            notifyAndAcknowledgeLastIncomingSms(handled, result, null);
+        }
+    }
+
+    /**
+     * This method is called when a new SMS PDU is injected into application framework.
+     * @param ar is the AsyncResult that has the SMS PDU to be injected.
+     */
+    private void handleInjectSms(AsyncResult ar) {
+        int result;
+        PendingIntent receivedIntent = null;
+        try {
+            receivedIntent = (PendingIntent) ar.userObj;
+            SmsMessage sms = (SmsMessage) ar.result;
+            if (sms == null) {
+              result = Intents.RESULT_SMS_GENERIC_ERROR;
+            } else {
+              result = dispatchMessage(sms.mWrappedSmsMessage);
+            }
+        } catch (RuntimeException ex) {
+            loge("Exception dispatching message", ex);
+            result = Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        if (receivedIntent != null) {
+            try {
+                receivedIntent.send(result);
+            } catch (CanceledException e) { }
+        }
+    }
+
+    /**
+     * Process an SMS message from the RIL, calling subclass methods to handle 3GPP and
+     * 3GPP2-specific message types.
+     *
+     * @param smsb the SmsMessageBase object from the RIL
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents},
+     *  or {@link Activity#RESULT_OK} for delayed acknowledgment to SMSC
+     */
+    private int dispatchMessage(SmsMessageBase smsb) {
+        // If sms is null, there was a parsing error.
+        if (smsb == null) {
+            loge("dispatchSmsMessage: message is null");
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        if (mSmsReceiveDisabled) {
+            // Device doesn't support receiving SMS,
+            log("Received short message on device which doesn't support "
+                    + "receiving SMS. Ignored.");
+            return Intents.RESULT_SMS_HANDLED;
+        }
+
+        // onlyCore indicates if the device is in cryptkeeper
+        boolean onlyCore = false;
+        try {
+            onlyCore = IPackageManager.Stub.asInterface(ServiceManager.getService("package")).
+                    isOnlyCoreApps();
+        } catch (RemoteException e) {
+        }
+        if (onlyCore) {
+            // Device is unable to receive SMS in encrypted state
+            log("Received a short message in encrypted state. Rejecting.");
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        return dispatchMessageRadioSpecific(smsb);
+    }
+
+    /**
+     * Process voicemail notification, SMS-PP data download, CDMA CMAS, CDMA WAP push, and other
+     * 3GPP/3GPP2-specific messages. Regular SMS messages are handled by calling the shared
+     * {@link #dispatchNormalMessage} from this class.
+     *
+     * @param smsb the SmsMessageBase object from the RIL
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents},
+     *  or {@link Activity#RESULT_OK} for delayed acknowledgment to SMSC
+     */
+    protected abstract int dispatchMessageRadioSpecific(SmsMessageBase smsb);
+
+    /**
+     * Send an acknowledge message to the SMSC.
+     * @param success indicates that last message was successfully received.
+     * @param result result code indicating any error
+     * @param response callback message sent when operation completes.
+     */
+    protected abstract void acknowledgeLastIncomingSms(boolean success,
+            int result, Message response);
+
+    /**
+     * Called when the phone changes the default method updates mPhone
+     * mStorageMonitor and mCellBroadcastHandler.updatePhoneObject.
+     * Override if different or other behavior is desired.
+     *
+     * @param phone
+     */
+    protected void onUpdatePhoneObject(Phone phone) {
+        mPhone = phone;
+        mStorageMonitor = mPhone.mSmsStorageMonitor;
+        log("onUpdatePhoneObject: phone=" + mPhone.getClass().getSimpleName());
+    }
+
+    /**
+     * Notify interested apps if the framework has rejected an incoming SMS,
+     * and send an acknowledge message to the network.
+     * @param success indicates that last message was successfully received.
+     * @param result result code indicating any error
+     * @param response callback message sent when operation completes.
+     */
+    private void notifyAndAcknowledgeLastIncomingSms(boolean success,
+            int result, Message response) {
+        if (!success) {
+            // broadcast SMS_REJECTED_ACTION intent
+            Intent intent = new Intent(Intents.SMS_REJECTED_ACTION);
+            intent.putExtra("result", result);
+            mContext.sendBroadcast(intent, android.Manifest.permission.RECEIVE_SMS);
+        }
+        acknowledgeLastIncomingSms(success, result, response);
+    }
+
+    /**
+     * Return true if this handler is for 3GPP2 messages; false for 3GPP format.
+     * @return true for the 3GPP2 handler; false for the 3GPP handler
+     */
+    protected abstract boolean is3gpp2();
+
+    /**
+     * Dispatch a normal incoming SMS. This is called from {@link #dispatchMessageRadioSpecific}
+     * if no format-specific handling was required. Saves the PDU to the SMS provider raw table,
+     * creates an {@link InboundSmsTracker}, then sends it to the state machine as an
+     * {@link #EVENT_BROADCAST_SMS}. Returns {@link Intents#RESULT_SMS_HANDLED} or an error value.
+     *
+     * @param sms the message to dispatch
+     * @return {@link Intents#RESULT_SMS_HANDLED} if the message was accepted, or an error status
+     */
+    protected int dispatchNormalMessage(SmsMessageBase sms) {
+        SmsHeader smsHeader = sms.getUserDataHeader();
+        InboundSmsTracker tracker;
+
+        if ((smsHeader == null) || (smsHeader.concatRef == null)) {
+            // Message is not concatenated.
+            int destPort = -1;
+            if (smsHeader != null && smsHeader.portAddrs != null) {
+                // The message was sent to a port.
+                destPort = smsHeader.portAddrs.destPort;
+                if (DBG) log("destination port: " + destPort);
+            }
+
+            // MTK-START
+            tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(
+                    mPhone.getSubId(), sms.getPdu(), sms.getTimestampMillis(), destPort, is3gpp2(),
+                    false, sms.getDisplayOriginatingAddress(), sms.getMessageBody());
+            // MTK-END
+        } else {
+            // Create a tracker for this message segment.
+            SmsHeader.ConcatRef concatRef = smsHeader.concatRef;
+            SmsHeader.PortAddrs portAddrs = smsHeader.portAddrs;
+            int destPort = (portAddrs != null ? portAddrs.destPort : -1);
+
+            // MTK-START
+            tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(
+                    mPhone.getSubId(), sms.getPdu(), sms.getTimestampMillis(), destPort, is3gpp2(),
+                    sms.getDisplayOriginatingAddress(), concatRef.refNumber, concatRef.seqNumber,
+                    concatRef.msgCount, false, sms.getMessageBody());
+            // MTK-END
+        }
+
+        if (VDBG) log("created tracker: " + tracker);
+
+        // de-duping is done only for text messages
+        // destPort = -1 indicates text messages, otherwise it's a data sms
+        return addTrackerToRawTableAndSendMessage(tracker,
+                tracker.getDestPort() == -1 /* de-dup if text message */);
+    }
+
+    /**
+     * Helper to add the tracker to the raw table and then send a message to broadcast it, if
+     * successful. Returns the SMS intent status to return to the SMSC.
+     * @param tracker the tracker to save to the raw table and then deliver
+     * @return {@link Intents#RESULT_SMS_HANDLED} or {@link Intents#RESULT_SMS_GENERIC_ERROR}
+     * or {@link Intents#RESULT_SMS_DUPLICATED}
+     */
+    protected int addTrackerToRawTableAndSendMessage(InboundSmsTracker tracker, boolean deDup) {
+        switch(addTrackerToRawTable(tracker, deDup)) {
+        case Intents.RESULT_SMS_HANDLED:
+            sendMessage(EVENT_BROADCAST_SMS, tracker);
+            return Intents.RESULT_SMS_HANDLED;
+
+        case Intents.RESULT_SMS_DUPLICATED:
+            return Intents.RESULT_SMS_HANDLED;
+
+        case Intents.RESULT_SMS_GENERIC_ERROR:
+        default:
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+    }
+
+    /**
+     * Process the inbound SMS segment. If the message is complete, send it as an ordered
+     * broadcast to interested receivers and return true. If the message is a segment of an
+     * incomplete multi-part SMS, return false.
+     * @param tracker the tracker containing the message segment to process
+     * @return true if an ordered broadcast was sent; false if waiting for more message segments
+     */
+    private boolean processMessagePart(InboundSmsTracker tracker) {
+        int messageCount = tracker.getMessageCount();
+        byte[][] pdus;
+        int destPort = tracker.getDestPort();
+
+        if (messageCount == 1) {
+            // single-part message
+            pdus = new byte[][]{tracker.getPdu()};
+        } else {
+
+            // MTK-START
+            // To lock the raw table of sms database
+            synchronized (mRawLock) {
+            // MTK-END
+                // multi-part message
+                Cursor cursor = null;
+                try {
+                    // used by several query selection arguments
+                    String address = tracker.getAddress();
+                    String refNumber = Integer.toString(tracker.getReferenceNumber());
+                    String count = Integer.toString(tracker.getMessageCount());
+                    // MTK-START
+                    String subId = Integer.toString(mPhone.getSubId());
+                    // MTK-END
+
+                    // query for all segments and broadcast message if we have all the parts
+                    // MTK-START
+                    String[] whereArgs = {address, refNumber, count, subId};
+                    // MTK-END
+                    cursor = mResolver.query(sRawUri, PDU_SEQUENCE_PORT_PROJECTION,
+                            SELECT_BY_REFERENCE, whereArgs, null);
+
+                    int cursorCount = cursor.getCount();
+                    if (cursorCount < messageCount) {
+                        // Wait for the other message parts to arrive. It's also possible for
+                        // the last segment to arrive before processing the EVENT_BROADCAST_SMS for
+                        // one of the earlier segments. In that case, the broadcast will be sent as
+                        // soon as all segments are in the table, and any later EVENT_BROADCAST_SMS
+                        // messages will get a row count of 0 and return.
+
+                        // MTK-START
+                        // Refresh the timer if receive another new concatenated segments but not
+                        // finish
+                        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                            if (tracker.getIndexOffset() == 1 && tracker.getDestPort() == -1) {
+                                if (ENG) {
+                                    log("ConcatenatedSmsFwkExt: refresh timer, ref = " +
+                                            tracker.getReferenceNumber());
+                                }
+                                TimerRecord record =
+                                        (TimerRecord)mConcatenatedSmsFwkExt.queryTimerRecord(
+                                        tracker.getAddress(), tracker.getReferenceNumber(),
+                                        tracker.getMessageCount());
+                                if (record == null) {
+                                    if (ENG) {
+                                        log("ConcatenatedSmsFwkExt: fail to " +
+                                                "get TimerRecord to refresh timer");
+                                    }
+                                } else {
+                                    mConcatenatedSmsFwkExt.refreshTimer(getHandler(), record);
+                                }
+                            }
+                        }
+                        // MTK-END
+                        return false;
+                    }
+
+                    // MTK-START
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        if (tracker.getIndexOffset() == 1 && tracker.getDestPort() == -1) {
+                            // cancel the timer, because all segments are in place
+                            if (ENG) {
+                                log("ConcatenatedSmsFwkExt: cancel timer, ref = " +
+                                        tracker.getReferenceNumber());
+                            }
+                            TimerRecord record =
+                                    (TimerRecord)mConcatenatedSmsFwkExt.queryTimerRecord(
+                                    tracker.getAddress(), tracker.getReferenceNumber(),
+                                    tracker.getMessageCount());
+                            if (record == null) {
+                                if (ENG) {
+                                    log("ConcatenatedSmsFwkExt: fail to " +
+                                            "get TimerRecord to cancel timer");
+                                }
+                            } else {
+                                mConcatenatedSmsFwkExt.cancelTimer(getHandler(), record);
+                            }
+                        }
+                    }
+                    // MTK-END
+
+                    // All the parts are in place, deal with them
+                    pdus = new byte[messageCount][];
+                    while (cursor.moveToNext()) {
+                        // subtract offset to convert sequence to 0-based array index
+                        int index = cursor.getInt(SEQUENCE_COLUMN) - tracker.getIndexOffset();
+
+                        pdus[index] = HexDump.hexStringToByteArray(cursor.getString(PDU_COLUMN));
+
+                        // Read the destination port from the first segment (needed for
+                        // CDMA WAP PDU).
+                        // It's not a bad idea to prefer the port from the first segment in other
+                        // cases.
+                        if (index == 0 && !cursor.isNull(DESTINATION_PORT_COLUMN)) {
+                            int port = cursor.getInt(DESTINATION_PORT_COLUMN);
+                            // strip format flags and convert to real port number, or -1
+                            port = InboundSmsTracker.getRealDestPort(port);
+                            if (port != -1) {
+                                destPort = port;
+                            }
+                        }
+                    }
+                } catch (SQLException e) {
+                    loge("Can't access multipart SMS database", e);
+                    return false;
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+            }
+        // MTK-START
+        }
+        // MTK-END
+
+        // Do not process null pdu(s). Check for that and return false in that case.
+        List<byte[]> pduList = Arrays.asList(pdus);
+        if (pduList.size() == 0 || pduList.contains(null)) {
+            loge("processMessagePart: returning false due to " +
+                    (pduList.size() == 0 ? "pduList.size() == 0" : "pduList.contains(null)"));
+            return false;
+        }
+
+        SmsBroadcastReceiver resultReceiver = new SmsBroadcastReceiver(tracker);
+
+        if (!mUserManager.isUserUnlocked()) {
+            return processMessagePartWithUserLocked(tracker, pdus, destPort, resultReceiver);
+        }
+
+        if (destPort == SmsHeader.PORT_WAP_PUSH) {
+            // Build up the data stream
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            for (byte[] pdu : pdus) {
+                // 3GPP needs to extract the User Data from the PDU; 3GPP2 has already done this
+                if (!tracker.is3gpp2()) {
+                    SmsMessage msg = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+                    if (msg != null) {
+                        pdu = msg.getUserData();
+                    } else {
+                        loge("processMessagePart: SmsMessage.createFromPdu returned null");
+                        return false;
+                    }
+                }
+                output.write(pdu, 0, pdu.length);
+            }
+
+            // MTK-START
+            int result;
+            // Put the extra information on bundle
+            if (SmsConstants.isWapPushSupport()) {
+                log("dispatch wap push pdu with addr & sc addr");
+                Bundle bundle = new Bundle();
+                if (!tracker.is3gpp2WapPdu()) {
+                    SmsMessage sms = SmsMessage.createFromPdu(pdus[0], tracker.getFormat());
+                    if (sms != null) {
+                        bundle.putString(Telephony.WapPush.ADDR, sms.getOriginatingAddress());
+                        String sca = sms.getServiceCenterAddress();
+                        if (sca == null) {
+                            /* null for app is not a item, it needs to transfer to empty string */
+                            sca = "";
+                        }
+                        bundle.putString(Telephony.WapPush.SERVICE_ADDR, sca);
+                    }
+                } else {
+                    //for CDMA, all info has been parsed into tracker before
+                    bundle.putString(Telephony.WapPush.ADDR, tracker.getAddress());
+                    bundle.putString(Telephony.WapPush.SERVICE_ADDR, "");
+                }
+
+                result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this,
+                        bundle);
+            } else {
+                //int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
+                log("dispatch wap push pdu");
+                result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
+            }
+            // MTK-END
+
+            if (DBG) log("dispatchWapPdu() returned " + result);
+            // result is Activity.RESULT_OK if an ordered broadcast was sent
+            if (result == Activity.RESULT_OK) {
+                return true;
+            } else {
+                deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(),
+                        MARK_DELETED);
+                return false;
+            }
+        }
+
+        if (BlockChecker.isBlocked(mContext, tracker.getAddress())) {
+            deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(),
+                    DELETE_PERMANENTLY);
+            return false;
+        }
+
+        boolean filterInvoked = filterSms(
+            pdus, destPort, tracker, resultReceiver, true /* userUnlocked */);
+
+
+        if (!filterInvoked) {
+            // MTK-START
+            dispatchSmsDeliveryIntent(pdus, tracker.getFormat(), destPort, resultReceiver,
+                    IConcatenatedSmsFwkExt.UPLOAD_FLAG_NONE);
+            // MTK-END
+        }
+
+        return true;
+    }
+
+    /**
+     * Processes the message part while the credential-encrypted storage is still locked.
+     *
+     * <p>If the message is a regular MMS, show a new message notification. If the message is a
+     * SMS, ask the carrier app to filter it and show the new message notification if the carrier
+     * app asks to keep the message.
+     *
+     * @return true if an ordered broadcast was sent to the carrier app; false otherwise.
+     */
+    private boolean processMessagePartWithUserLocked(InboundSmsTracker tracker,
+            byte[][] pdus, int destPort, SmsBroadcastReceiver resultReceiver) {
+        log("Credential-encrypted storage not available. Port: " + destPort);
+        if (destPort == SmsHeader.PORT_WAP_PUSH && mWapPush.isWapPushForMms(pdus[0], this)) {
+            showNewMessageNotification();
+            return false;
+        }
+        if (destPort == -1) {
+            // This is a regular SMS - hand it to the carrier or system app for filtering.
+            boolean filterInvoked = filterSms(
+                pdus, destPort, tracker, resultReceiver, false /* userUnlocked */);
+            if (filterInvoked) {
+                // filter invoked, wait for it to return the result.
+                return true;
+            } else {
+                // filter not invoked, show the notification and do nothing further.
+                showNewMessageNotification();
+                return false;
+            }
+        }
+        return false;
+    }
+
+    private void showNewMessageNotification() {
+        // Do not show the notification on non-FBE devices.
+        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
+            return;
+        }
+        log("Show new message notification.");
+        PendingIntent intent = PendingIntent.getBroadcast(
+            mContext,
+            0,
+            new Intent(ACTION_OPEN_SMS_APP),
+            PendingIntent.FLAG_ONE_SHOT);
+        Notification.Builder mBuilder = new Notification.Builder(mContext)
+                .setSmallIcon(com.android.internal.R.drawable.sym_action_chat)
+                .setAutoCancel(true)
+                .setVisibility(Notification.VISIBILITY_PUBLIC)
+                .setDefaults(Notification.DEFAULT_ALL)
+                .setContentTitle(mContext.getString(R.string.new_sms_notification_title))
+                .setContentText(mContext.getString(R.string.new_sms_notification_content))
+                .setContentIntent(intent);
+        NotificationManager mNotificationManager =
+            (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mNotificationManager.notify(
+                NOTIFICATION_TAG, NOTIFICATION_ID_NEW_MESSAGE, mBuilder.build());
+    }
+
+    static void cancelNewMessageNotification(Context context) {
+        NotificationManager mNotificationManager =
+            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        mNotificationManager.cancel(InboundSmsHandler.NOTIFICATION_TAG,
+            InboundSmsHandler.NOTIFICATION_ID_NEW_MESSAGE);
+    }
+
+    /**
+     * Filters the SMS.
+     *
+     * <p>currently 3 filters exists: the carrier package, the system package, and the
+     * VisualVoicemailSmsFilter.
+     *
+     * <p>The filtering process is:
+     *
+     * <p>If the carrier package exists, the SMS will be filtered with it first. If the carrier
+     * package did not drop the SMS, then the VisualVoicemailSmsFilter will filter it in the
+     * callback.
+     *
+     * <p>If the carrier package does not exists, we will let the VisualVoicemailSmsFilter filter
+     * it. If the SMS passed the filter, then we will try to find the system package to do the
+     * filtering.
+     *
+     * @return true if a filter is invoked and the SMS processing flow is diverted, false otherwise.
+     */
+    private boolean filterSms(byte[][] pdus, int destPort,
+        InboundSmsTracker tracker, SmsBroadcastReceiver resultReceiver, boolean userUnlocked) {
+        List<String> carrierPackages = null;
+        UiccCard card = UiccController.getInstance().getUiccCard(mPhone.getPhoneId());
+        if (card != null) {
+            carrierPackages = card.getCarrierPackageNamesForIntent(
+                    mContext.getPackageManager(),
+                    new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+        } else {
+            loge("UiccCard not initialized.");
+        }
+
+        if (carrierPackages != null && carrierPackages.size() == 1) {
+            log("Found carrier package.");
+            // MTK-START
+            CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, destPort,
+                    tracker.getFormat(), resultReceiver, IConcatenatedSmsFwkExt.UPLOAD_FLAG_NONE);
+            // MTK-END
+            CarrierSmsFilterCallback smsFilterCallback = new CarrierSmsFilterCallback(smsFilter,
+                    userUnlocked);
+            smsFilter.filterSms(carrierPackages.get(0), smsFilterCallback);
+            return true;
+        }
+
+        // It is possible that carrier app is not present as a CarrierPackage, but instead as a
+        // system app
+        List<String> systemPackages =
+                getSystemAppForIntent(new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+
+        if (systemPackages != null && systemPackages.size() == 1) {
+            log("Found system package.");
+            // MTK-START
+            CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, destPort,
+                    tracker.getFormat(), resultReceiver, IConcatenatedSmsFwkExt.UPLOAD_FLAG_NONE);
+            // MTK-END
+            CarrierSmsFilterCallback smsFilterCallback = new CarrierSmsFilterCallback(smsFilter,
+                    userUnlocked);
+            smsFilter.filterSms(systemPackages.get(0), smsFilterCallback);
+            return true;
+        }
+        logv("Unable to find carrier package: " + carrierPackages
+                + ", nor systemPackages: " + systemPackages);
+
+        if (VisualVoicemailSmsFilter.filter(
+                mContext, pdus, tracker.getFormat(), destPort, mPhone.getSubId())) {
+            log("Visual voicemail SMS dropped");
+            dropSms(resultReceiver);
+            return true;
+        }
+
+        return false;
+    }
+
+    private List<String> getSystemAppForIntent(Intent intent) {
+        List<String> packages = new ArrayList<String>();
+        PackageManager packageManager = mContext.getPackageManager();
+        List<ResolveInfo> receivers = packageManager.queryIntentServices(intent, 0);
+        String carrierFilterSmsPerm = "android.permission.CARRIER_FILTER_SMS";
+
+        for (ResolveInfo info : receivers) {
+            if (info.serviceInfo == null) {
+                loge("Can't get service information from " + info);
+                continue;
+            }
+            String packageName = info.serviceInfo.packageName;
+                if (packageManager.checkPermission(carrierFilterSmsPerm, packageName) ==
+                        packageManager.PERMISSION_GRANTED) {
+                    packages.add(packageName);
+                    if (DBG) log("getSystemAppForIntent: added package "+ packageName);
+                }
+        }
+        return packages;
+    }
+
+    /**
+     * Dispatch the intent with the specified permission, appOp, and result receiver, using
+     * this state machine's handler thread to run the result receiver.
+     *
+     * @param intent the intent to broadcast
+     * @param permission receivers are required to have this permission
+     * @param appOp app op that is being performed when dispatching to a receiver
+     * @param user user to deliver the intent to
+     */
+    public void dispatchIntent(Intent intent, String permission, int appOp,
+            Bundle opts, BroadcastReceiver resultReceiver, UserHandle user) {
+        intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
+        // MTK-START
+        intent.putExtra("rTime", System.currentTimeMillis());
+        // MTK-END
+        final String action = intent.getAction();
+        if (Intents.SMS_DELIVER_ACTION.equals(action)
+                || Intents.SMS_RECEIVED_ACTION.equals(action)
+                || Intents.WAP_PUSH_DELIVER_ACTION.equals(action)
+                || Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
+            // Some intents need to be delivered with high priority:
+            // SMS_DELIVER, SMS_RECEIVED, WAP_PUSH_DELIVER, WAP_PUSH_RECEIVED
+            // In some situations, like after boot up or system under load, normal
+            // intent delivery could take a long time.
+            // This flag should only be set for intents for visible, timely operations
+            // which is true for the intents above.
+            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        }
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+        if (user.equals(UserHandle.ALL)) {
+            // Get a list of currently started users.
+            int[] users = null;
+            try {
+                users = ActivityManagerNative.getDefault().getRunningUserIds();
+            } catch (RemoteException re) {
+            }
+            if (users == null) {
+                users = new int[] {user.getIdentifier()};
+            }
+            // Deliver the broadcast only to those running users that are permitted
+            // by user policy.
+            for (int i = users.length - 1; i >= 0; i--) {
+                UserHandle targetUser = new UserHandle(users[i]);
+                if (users[i] != UserHandle.USER_SYSTEM) {
+                    // Is the user not allowed to use SMS?
+                    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_SMS, targetUser)) {
+                        continue;
+                    }
+                    // Skip unknown users and managed profiles as well
+                    UserInfo info = mUserManager.getUserInfo(users[i]);
+                    if (info == null || info.isManagedProfile()) {
+                        continue;
+                    }
+                }
+                // Only pass in the resultReceiver when the USER_SYSTEM is processed.
+                mContext.sendOrderedBroadcastAsUser(intent, targetUser, permission, appOp, opts,
+                        users[i] == UserHandle.USER_SYSTEM ? resultReceiver : null,
+                        getHandler(), Activity.RESULT_OK, null, null);
+            }
+        } else {
+            mContext.sendOrderedBroadcastAsUser(intent, user, permission, appOp, opts,
+                    resultReceiver, getHandler(), Activity.RESULT_OK, null, null);
+        }
+    }
+
+    /**
+     * Helper for {@link SmsBroadcastUndelivered} to delete an old message in the raw table.
+     */
+    private void deleteFromRawTable(String deleteWhere, String[] deleteWhereArgs,
+                                    int deleteType) {
+        Uri uri = deleteType == DELETE_PERMANENTLY ? sRawUriPermanentDelete : sRawUri;
+        // MTK-START
+        if (deleteWhere == null && deleteWhereArgs == null) {
+            //the contentresolver design is to delete all in table in this case.
+            //in this case, means we don't want to delete anything, so return to avoid it
+            loge("No rows need be deleted from raw table!");
+            return;
+        }
+
+        synchronized (mRawLock) {
+        // MTK-END
+            int rows = mResolver.delete(uri, deleteWhere, deleteWhereArgs);
+            if (rows == 0) {
+                loge("No rows were deleted from raw table!");
+            } else if (DBG) {
+                log("Deleted " + rows + " rows from raw table.");
+            }
+        }
+    }
+
+    private Bundle handleSmsWhitelisting(ComponentName target) {
+        String pkgName;
+        String reason;
+        if (target != null) {
+            pkgName = target.getPackageName();
+            reason = "sms-app";
+        } else {
+            pkgName = mContext.getPackageName();
+            reason = "sms-broadcast";
+        }
+        try {
+            long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForSms(
+                    pkgName, 0, reason);
+            BroadcastOptions bopts = BroadcastOptions.makeBasic();
+            bopts.setTemporaryAppWhitelistDuration(duration);
+            return bopts.toBundle();
+        } catch (RemoteException e) {
+        }
+
+        return null;
+    }
+
+    /**
+     * Creates and dispatches the intent to the default SMS app or the appropriate port.
+     *
+     * @param pdus message pdus
+     * @param format the message format, typically "3gpp" or "3gpp2"
+     * @param destPort the destination port
+     * @param resultReceiver the receiver handling the delivery result
+     */
+    // MTK-START
+    private void dispatchSmsDeliveryIntent(byte[][] pdus, String format, int destPort,
+            BroadcastReceiver resultReceiver, int longSmsUploadFlag) {
+    // MTK-END
+        Intent intent = new Intent();
+        intent.putExtra("pdus", pdus);
+        intent.putExtra("format", format);
+
+        if (destPort == -1) {
+            intent.setAction(Intents.SMS_DELIVER_ACTION);
+            // Direct the intent to only the default SMS app. If we can't find a default SMS app
+            // then sent it to all broadcast receivers.
+            // We are deliberately delivering to the primary user's default SMS App.
+            ComponentName componentName = SmsApplication.getDefaultSmsApplication(mContext, true);
+            if (componentName != null) {
+                // Deliver SMS message only to this receiver.
+                intent.setComponent(componentName);
+                log("Delivering SMS to: " + componentName.getPackageName() +
+                    " " + componentName.getClassName());
+            } else {
+                intent.setComponent(null);
+            }
+
+            // TODO: Validate that this is the right place to store the SMS.
+            if (SmsManager.getDefault().getAutoPersisting()) {
+                final Uri uri = writeInboxMessage(intent);
+                if (uri != null) {
+                    // Pass this to SMS apps so that they know where it is stored
+                    intent.putExtra("uri", uri.toString());
+                }
+            }
+
+            // MTK-START
+            // To check if needs to add upload flag to app
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                int uploadFlag = longSmsUploadFlag;
+                // If someone already decide to use the spcified flag, it should not change it
+                if (uploadFlag == IConcatenatedSmsFwkExt.UPLOAD_FLAG_NONE) {
+                    // To check if needs to add upload flag to app
+                    uploadFlag = IConcatenatedSmsFwkExt.UPLOAD_FLAG_NEW;
+                    SmsMessage msg = SmsMessage.createFromPdu(pdus[0], format);
+                    if (msg != null) {
+                        SmsHeader udh = msg.getUserDataHeader();
+                        if (udh != null && udh.concatRef != null) {
+                            TimerRecord tr = new TimerRecord(msg.getOriginatingAddress(),
+                                    udh.concatRef.refNumber, udh.concatRef.msgCount, null);
+                            // MTK-START
+                            // To lock the raw table of sms database
+                            synchronized (mRawLock) {
+                                uploadFlag = mConcatenatedSmsFwkExt.getUploadFlag(tr);
+                            }
+                            // MTK-END
+                        }
+                    }
+                    if (ENG) {
+                        log("uploadFlag=" + uploadFlag);
+                    }
+                }
+
+                if (uploadFlag == IConcatenatedSmsFwkExt.UPLOAD_FLAG_UPDATE ||
+                        uploadFlag == IConcatenatedSmsFwkExt.UPLOAD_FLAG_NEW) {
+                    intent.putExtra(IConcatenatedSmsFwkExt.UPLOAD_FLAG_TAG, uploadFlag);
+                }
+            }
+
+            // If Phone Privacy Lock feature turns on,
+            // change and send mPhonePrivacyLockReceiver to check permission first
+            // mPhonePrivacyLockReceiver -> default sms application -> others
+            if (SmsConstants.isPrivacyLockSupport()) {
+                // Change action as "android.intent.action.MOMS_SMS_RECEIVED" to let
+                // Moms check first
+                intent.setAction(Intents.PRIVACY_LOCK_SMS_RECEIVED_ACTION);
+                intent.setComponent(null);
+            }
+            // MTK-END
+        } else {
+            intent.setAction(Intents.DATA_SMS_RECEIVED_ACTION);
+            Uri uri = Uri.parse("sms://localhost:" + destPort);
+            intent.setData(uri);
+            intent.setComponent(null);
+        }
+
+        Bundle options = handleSmsWhitelisting(intent.getComponent());
+        dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS,
+                AppOpsManager.OP_RECEIVE_SMS, options, resultReceiver, UserHandle.SYSTEM);
+    }
+
+    /**
+     * Function to check if message should be dropped because same message has already been
+     * received. In certain cases it checks for similar messages instead of exact same (cases where
+     * keeping both messages in db can cause ambiguity)
+     * @return true if duplicate exists, false otherwise
+     */
+    private boolean duplicateExists(InboundSmsTracker tracker) throws SQLException {
+        String address = tracker.getAddress();
+        // convert to strings for query
+        String refNumber = Integer.toString(tracker.getReferenceNumber());
+        String count = Integer.toString(tracker.getMessageCount());
+        // sequence numbers are 1-based except for CDMA WAP, which is 0-based
+        int sequence = tracker.getSequenceNumber();
+        String seqNumber = Integer.toString(sequence);
+        String date = Long.toString(tracker.getTimestamp());
+        String messageBody = tracker.getMessageBody();
+        String where;
+        if (tracker.getMessageCount() == 1) {
+            where = "address=? AND reference_number=? AND count=? AND sequence=? AND " +
+                    "date=? AND message_body=?";
+        } else {
+            // for multi-part messages, deduping should also be done against undeleted
+            // segments that can cause ambiguity when contacenating the segments, that is,
+            // segments with same address, reference_number, count and sequence
+            where = "address=? AND reference_number=? AND count=? AND sequence=? AND " +
+                    "((date=? AND message_body=?) OR deleted=0)";
+        }
+
+        Cursor cursor = null;
+        try {
+            // Check for duplicate message segments
+            cursor = mResolver.query(sRawUri, PDU_PROJECTION, where,
+                    new String[]{address, refNumber, count, seqNumber, date, messageBody},
+                    null);
+
+            // moveToNext() returns false if no duplicates were found
+            if (cursor != null && cursor.moveToNext()) {
+                loge("Discarding duplicate message segment, refNumber=" + refNumber
+                        + " seqNumber=" + seqNumber + " count=" + count);
+                if (VDBG) {
+                    loge("address=" + address + " date=" + date + " messageBody=" +
+                            messageBody);
+                }
+                String oldPduString = cursor.getString(PDU_COLUMN);
+                byte[] pdu = tracker.getPdu();
+                byte[] oldPdu = HexDump.hexStringToByteArray(oldPduString);
+                if (!Arrays.equals(oldPdu, tracker.getPdu())) {
+                    loge("Warning: dup message segment PDU of length " + pdu.length
+                            + " is different from existing PDU of length " + oldPdu.length);
+                }
+                return true;   // reject message
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Insert a message PDU into the raw table so we can acknowledge it immediately.
+     * If the device crashes before the broadcast to listeners completes, it will be delivered
+     * from the raw table on the next device boot. For single-part messages, the deleteWhere
+     * and deleteWhereArgs fields of the tracker will be set to delete the correct row after
+     * the ordered broadcast completes.
+     *
+     * @param tracker the tracker to add to the raw table
+     * @return true on success; false on failure to write to database
+     */
+    private int addTrackerToRawTable(InboundSmsTracker tracker, boolean deDup) {
+        String address = tracker.getAddress();
+        String refNumber = Integer.toString(tracker.getReferenceNumber());
+        String count = Integer.toString(tracker.getMessageCount());
+        // MTK-START
+        String subId = Integer.toString(mPhone.getSubId());
+        // To lock the raw table of sms database
+        synchronized (mRawLock) {
+        // MTK-END
+            if (deDup) {
+                // check for duplicate message segments
+                Cursor cursor = null;
+                try {
+                    // sequence numbers are 1-based except for CDMA WAP, which is 0-based
+                    int sequence = tracker.getSequenceNumber();
+
+                    // convert to strings for query
+                    String seqNumber = Integer.toString(sequence);
+                    String date = Long.toString(tracker.getTimestamp());
+                    String messageBody = tracker.getMessageBody();
+                    // MTK-START
+                    // Check for duplicate message segments
+                    cursor = mResolver.query(sRawUri, PDU_PROJECTION,
+                            "address=? AND reference_number=? AND count=? AND sequence=? AND date=? " +
+                                    "AND message_body=? AND sub_id=?",
+                            new String[]{address, refNumber, count, seqNumber, date, messageBody,
+                            subId}, null);
+                    // MTK-END
+
+                    // moveToNext() returns false if no duplicates were found
+                    if (cursor.moveToNext()) {
+                        loge("Discarding duplicate message segment, refNumber=" + refNumber
+                                + " seqNumber=" + seqNumber + " count=" + count);
+                        if (VDBG) {
+                            loge("address=" + address + " date=" + date + " messageBody=" +
+                                    messageBody);
+                        }
+                        String oldPduString = cursor.getString(PDU_COLUMN);
+                        byte[] pdu = tracker.getPdu();
+                        byte[] oldPdu = HexDump.hexStringToByteArray(oldPduString);
+                        if (!Arrays.equals(oldPdu, tracker.getPdu())) {
+                            loge("Warning: dup message segment PDU of length " + pdu.length
+                                    + " is different from existing PDU of length " + oldPdu.length);
+                        }
+                        return Intents.RESULT_SMS_DUPLICATED;   // reject message
+                    }
+                } catch (SQLException e) {
+                    loge("Can't access SMS database", e);
+                    return Intents.RESULT_SMS_GENERIC_ERROR;    // reject message
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+            } else {
+                logd("Skipped message de-duping logic");
+            }
+
+            // MTK-START
+            // check whether the message is the first segment of one
+            // concatenated sms
+            boolean isFirstSegment = false;
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                // check whether the message is the first segment of one
+                // concatenated sms
+                if (tracker.getReferenceNumber() != -1) {
+                    isFirstSegment = mConcatenatedSmsFwkExt.isFirstConcatenatedSegment(
+                            tracker.getAddress(), tracker.getReferenceNumber());
+                }
+            }
+            // MTK-END
+
+            ContentValues values = tracker.getContentValues();
+
+            if (VDBG) log("adding content values to raw table: " + values.toString());
+            Uri newUri = mResolver.insert(sRawUri, values);
+            if (DBG) log("URI of new row -> " + newUri);
+
+            // MTK-START
+            if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                // Not a CDMA-wap-push && not a data SMS && it is the first segment
+                if (tracker.getIndexOffset() == 1 && tracker.getDestPort() == -1 &&
+                        isFirstSegment == true) {
+                    if (ENG) {
+                        log("ConcatenatedSmsFwkExt: start a new timer, the first segment, ref = " +
+                                tracker.getReferenceNumber());
+                    }
+                    TimerRecord record = new TimerRecord(tracker.getAddress(),
+                            tracker.getReferenceNumber(), tracker.getMessageCount(), tracker);
+                    if (record == null) {
+                        if (ENG) {
+                            log("ConcatenatedSmsFwkExt: fail to new TimerRecord to start timer");
+                        }
+                    }
+                    mConcatenatedSmsFwkExt.startTimer(getHandler(), record);
+                }
+            }
+            // MTK-END
+
+            try {
+                long rowId = ContentUris.parseId(newUri);
+                if (tracker.getMessageCount() == 1) {
+                    // set the delete selection args for single-part message
+                    tracker.setDeleteWhere(SELECT_BY_ID, new String[]{Long.toString(rowId)});
+                } else {
+                    // set the delete selection args for multi-part message
+                    // MTK-START
+                    String[] deleteWhereArgs = {address, refNumber, count, subId};
+                    // MTK-END
+                    tracker.setDeleteWhere(SELECT_BY_REFERENCE, deleteWhereArgs);
+
+                }
+                return Intents.RESULT_SMS_HANDLED;
+            } catch (Exception e) {
+                loge("error parsing URI for new row: " + newUri, e);
+                return Intents.RESULT_SMS_GENERIC_ERROR;
+            }
+        }
+    }
+
+    /**
+     * Returns whether the default message format for the current radio technology is 3GPP2.
+     * @return true if the radio technology uses 3GPP2 format by default, false for 3GPP format
+     */
+    static boolean isCurrentFormat3gpp2() {
+        int activePhone = TelephonyManager.getDefault().getCurrentPhoneType();
+        return (PHONE_TYPE_CDMA == activePhone);
+    }
+
+    /**
+     * Handler for an {@link InboundSmsTracker} broadcast. Deletes PDUs from the raw table and
+     * logs the broadcast duration (as an error if the other receivers were especially slow).
+     */
+    private final class SmsBroadcastReceiver extends BroadcastReceiver {
+        private final String mDeleteWhere;
+        private final String[] mDeleteWhereArgs;
+        private long mBroadcastTimeNano;
+
+        SmsBroadcastReceiver(InboundSmsTracker tracker) {
+            mDeleteWhere = tracker.getDeleteWhere();
+            mDeleteWhereArgs = tracker.getDeleteWhereArgs();
+            mBroadcastTimeNano = System.nanoTime();
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intents.SMS_DELIVER_ACTION)) {
+                // Now dispatch the notification only intent
+                intent.setAction(Intents.SMS_RECEIVED_ACTION);
+                intent.setComponent(null);
+                // All running users will be notified of the received sms.
+                Bundle options = handleSmsWhitelisting(null);
+                dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS,
+                        AppOpsManager.OP_RECEIVE_SMS, options, this, UserHandle.ALL);
+            } else if (action.equals(Intents.WAP_PUSH_DELIVER_ACTION)) {
+                // Now dispatch the notification only intent
+                intent.setAction(Intents.WAP_PUSH_RECEIVED_ACTION);
+                intent.setComponent(null);
+                // Only the primary user will receive notification of incoming mms.
+                // That app will do the actual downloading of the mms.
+                Bundle options = null;
+                try {
+                    long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(
+                            mContext.getPackageName(), 0, "mms-broadcast");
+                    BroadcastOptions bopts = BroadcastOptions.makeBasic();
+                    bopts.setTemporaryAppWhitelistDuration(duration);
+                    options = bopts.toBundle();
+                } catch (RemoteException e) {
+                }
+
+                String mimeType = intent.getType();
+                dispatchIntent(intent, WapPushOverSms.getPermissionForType(mimeType),
+                        WapPushOverSms.getAppOpsPermissionForIntent(mimeType), options, this,
+                        UserHandle.SYSTEM);
+            // MTK-START
+            } else if (action.equals(
+                    Intents.PRIVACY_LOCK_SMS_RECEIVED_ACTION)) {
+                // All running users will be notified of the received sms.
+                Bundle options = handleSmsWhitelisting(null);
+                // If result code is RESULT_SMS_REJECT_BY_MOMS, it means that feature
+                // Phone Privacy Lock doesn't permits to disptch. Delete it from raw table.
+                // Otherwise, dispatch to default sms application first and follow google flow
+                int rc = getResultCode();
+                if (rc == Intents.RESULT_SMS_REJECT_BY_PPL) {
+                    log("[PPL] Reject by phone privacy lock and delete from raw table. Result code:"
+                            + rc);
+                    deleteFromRawTable(mDeleteWhere, mDeleteWhereArgs, MARK_DELETED);
+                    sendMessage(EVENT_BROADCAST_COMPLETE);
+                } else {
+                    if (ENG) {
+                        log("[PPL] Permit to dispatch, "
+                                + "send sms default application first. Result code:"
+                                + rc);
+                    }
+                    intent.setAction(Intents.SMS_DELIVER_ACTION);
+                    // Direct the intent to only the default SMS app. If we can't find a default
+                    // SMS app then sent it to all broadcast receivers.
+                    ComponentName componentName = SmsApplication.getDefaultSmsApplication(
+                            mContext, true);
+                    if (componentName != null) {
+                        // Deliver SMS message only to this receiver
+                        intent.setComponent(componentName);
+                        log("Delivering SMS to: " + componentName.getPackageName() +
+                                " " + componentName.getClassName());
+                    }
+                    dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS,
+                            AppOpsManager.OP_RECEIVE_SMS, options, this, UserHandle.OWNER);
+                }
+            // MTK-END
+            } else {
+                // Now that the intents have been deleted we can clean up the PDU data.
+                if (!Intents.DATA_SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.DATA_SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
+                    loge("unexpected BroadcastReceiver action: " + action);
+                }
+
+                int rc = getResultCode();
+                if ((rc != Activity.RESULT_OK) && (rc != Intents.RESULT_SMS_HANDLED)) {
+                    loge("a broadcast receiver set the result code to " + rc
+                            + ", deleting from raw table anyway!");
+                } else if (DBG) {
+                    log("successful broadcast, deleting from raw table.");
+                }
+
+                deleteFromRawTable(mDeleteWhere, mDeleteWhereArgs, MARK_DELETED);
+                sendMessage(EVENT_BROADCAST_COMPLETE);
+
+                int durationMillis = (int) ((System.nanoTime() - mBroadcastTimeNano) / 1000000);
+                if (durationMillis >= 5000) {
+                    loge("Slow ordered broadcast completion time: " + durationMillis + " ms");
+                } else if (DBG) {
+                    log("ordered broadcast completed in: " + durationMillis + " ms");
+                }
+            }
+        }
+    }
+
+    /**
+     * Asynchronously binds to the carrier messaging service, and filters out the message if
+     * instructed to do so by the carrier messaging service. A new instance must be used for every
+     * message.
+     */
+    private final class CarrierSmsFilter extends CarrierMessagingServiceManager {
+        private final byte[][] mPdus;
+        private final int mDestPort;
+        private final String mSmsFormat;
+        private final SmsBroadcastReceiver mSmsBroadcastReceiver;
+        // MTK-START
+        // Record the upload flag and callback to the dispatch dispatchSmsDeliveryIntent
+        private final int mUploadFlag;
+        // MTK-END
+        // Instantiated in filterSms.
+        private volatile CarrierSmsFilterCallback mSmsFilterCallback;
+
+        CarrierSmsFilter(byte[][] pdus, int destPort, String smsFormat,
+                SmsBroadcastReceiver smsBroadcastReceiver) {
+            // MTK-START
+            //mPdus = pdus;
+            //mDestPort = destPort;
+            //mSmsFormat = smsFormat;
+            //mSmsBroadcastReceiver = smsBroadcastReceiver;
+            this(pdus, destPort, smsFormat, smsBroadcastReceiver,
+                    IConcatenatedSmsFwkExt.UPLOAD_FLAG_NONE);
+            // MTK-END
+        }
+
+        // MTK-START
+        CarrierSmsFilter(byte[][] pdus, int destPort, String smsFormat,
+                SmsBroadcastReceiver smsBroadcastReceiver, int uploadFlag) {
+            mPdus = pdus;
+            mDestPort = destPort;
+            mSmsFormat = smsFormat;
+            mSmsBroadcastReceiver = smsBroadcastReceiver;
+            mUploadFlag = uploadFlag;
+        }
+        // MTK-END
+
+        /**
+         * Attempts to bind to a {@link ICarrierMessagingService}. Filtering is initiated
+         * asynchronously once the service is ready using {@link #onServiceReady}.
+         */
+        void filterSms(String carrierPackageName, CarrierSmsFilterCallback smsFilterCallback) {
+            mSmsFilterCallback = smsFilterCallback;
+            if (!bindToCarrierMessagingService(mContext, carrierPackageName)) {
+                loge("bindService() for carrier messaging service failed");
+                smsFilterCallback.onFilterComplete(CarrierMessagingService.RECEIVE_OPTIONS_DEFAULT);
+            } else {
+                logv("bindService() for carrier messaging service succeeded");
+            }
+        }
+
+        /**
+         * Invokes the {@code carrierMessagingService} to filter messages. The filtering result is
+         * delivered to {@code smsFilterCallback}.
+         */
+        @Override
+        protected void onServiceReady(ICarrierMessagingService carrierMessagingService) {
+            try {
+                carrierMessagingService.filterSms(
+                        new MessagePdu(Arrays.asList(mPdus)), mSmsFormat, mDestPort,
+                        mPhone.getSubId(), mSmsFilterCallback);
+            } catch (RemoteException e) {
+                loge("Exception filtering the SMS: " + e);
+                mSmsFilterCallback.onFilterComplete(
+                    CarrierMessagingService.RECEIVE_OPTIONS_DEFAULT);
+            }
+        }
+    }
+
+    /**
+     * A callback used to notify the platform of the carrier messaging app filtering result. Once
+     * the result is ready, the carrier messaging service connection is disposed.
+     */
+    private final class CarrierSmsFilterCallback extends ICarrierMessagingCallback.Stub {
+        private final CarrierSmsFilter mSmsFilter;
+        private final boolean mUserUnlocked;
+
+        CarrierSmsFilterCallback(CarrierSmsFilter smsFilter, boolean userUnlocked) {
+            mSmsFilter = smsFilter;
+            mUserUnlocked = userUnlocked;
+        }
+
+        /**
+         * This method should be called only once.
+         */
+        @Override
+        public void onFilterComplete(int result) {
+            mSmsFilter.disposeConnection(mContext);
+            // Calling identity was the CarrierMessagingService in this callback, change it back to
+            // ours. This is required for dropSms() and VisualVoicemailSmsFilter.filter().
+            long token = Binder.clearCallingIdentity();
+            try {
+                logv("onFilterComplete: result is " + result);
+                if ((result & CarrierMessagingService.RECEIVE_OPTIONS_DROP) == 0) {
+                    if (VisualVoicemailSmsFilter.filter(mContext, mSmsFilter.mPdus,
+                            mSmsFilter.mSmsFormat, mSmsFilter.mDestPort, mPhone.getSubId())) {
+                        log("Visual voicemail SMS dropped");
+                        dropSms(mSmsFilter.mSmsBroadcastReceiver);
+                        return;
+                    }
+
+                    if (mUserUnlocked) {
+                        // MTK-START
+                        dispatchSmsDeliveryIntent(mSmsFilter.mPdus, mSmsFilter.mSmsFormat,
+                            mSmsFilter.mDestPort, mSmsFilter.mSmsBroadcastReceiver,
+                            mSmsFilter.mUploadFlag);
+                        // MTK-END
+                    } else {
+                        // Don't do anything further, leave the message in the raw table if the
+                        // credential-encrypted storage is still locked and show the new message
+                        // notification if the message is visible to the user.
+                        if (!isSkipNotifyFlagSet(result)) {
+                            showNewMessageNotification();
+                        }
+                        sendMessage(EVENT_BROADCAST_COMPLETE);
+                    }
+                } else {
+                    // Drop this SMS.
+                    dropSms(mSmsFilter.mSmsBroadcastReceiver);
+                }
+            } finally {
+                // return back to the CarrierMessagingService, restore the calling identity.
+                Binder.restoreCallingIdentity(token);
+            }
+        }
+
+        @Override
+        public void onSendSmsComplete(int result, int messageRef) {
+            loge("Unexpected onSendSmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onSendMultipartSmsComplete(int result, int[] messageRefs) {
+            loge("Unexpected onSendMultipartSmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onSendMmsComplete(int result, byte[] sendConfPdu) {
+            loge("Unexpected onSendMmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onDownloadMmsComplete(int result) {
+            loge("Unexpected onDownloadMmsComplete call with result: " + result);
+        }
+    }
+
+    private void dropSms(SmsBroadcastReceiver receiver) {
+        // Needs phone package permissions.
+        deleteFromRawTable(receiver.mDeleteWhere, receiver.mDeleteWhereArgs, MARK_DELETED);
+        sendMessage(EVENT_BROADCAST_COMPLETE);
+    }
+
+    /** Checks whether the flag to skip new message notification is set in the bitmask returned
+     *  from the carrier app.
+     */
+    private boolean isSkipNotifyFlagSet(int callbackResult) {
+        return (callbackResult
+            & RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE) > 0;
+    }
+
+    /**
+     * Log with debug level.
+     * @param s the string to log
+     */
+    @Override
+    protected void log(String s) {
+        Rlog.d(getName(), s);
+    }
+
+    /**
+     * Log with error level.
+     * @param s the string to log
+     */
+    @Override
+    protected void loge(String s) {
+        Rlog.e(getName(), s);
+    }
+
+    /**
+     * Log with error level.
+     * @param s the string to log
+     * @param e is a Throwable which logs additional information.
+     */
+    @Override
+    protected void loge(String s, Throwable e) {
+        Rlog.e(getName(), s, e);
+    }
+
+    /**
+     * Store a received SMS into Telephony provider
+     *
+     * @param intent The intent containing the received SMS
+     * @return The URI of written message
+     */
+    private Uri writeInboxMessage(Intent intent) {
+        final SmsMessage[] messages = Telephony.Sms.Intents.getMessagesFromIntent(intent);
+        if (messages == null || messages.length < 1) {
+            loge("Failed to parse SMS pdu");
+            return null;
+        }
+        // Sometimes, SmsMessage.mWrappedSmsMessage is null causing NPE when we access
+        // the methods on it although the SmsMessage itself is not null. So do this check
+        // before we do anything on the parsed SmsMessages.
+        for (final SmsMessage sms : messages) {
+            try {
+                sms.getDisplayMessageBody();
+            } catch (NullPointerException e) {
+                loge("NPE inside SmsMessage");
+                return null;
+            }
+        }
+        final ContentValues values = parseSmsMessage(messages);
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            return mContext.getContentResolver().insert(Telephony.Sms.Inbox.CONTENT_URI, values);
+        } catch (Exception e) {
+            loge("Failed to persist inbox message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    /**
+     * Convert SmsMessage[] into SMS database schema columns
+     *
+     * @param msgs The SmsMessage array of the received SMS
+     * @return ContentValues representing the columns of parsed SMS
+     */
+    private static ContentValues parseSmsMessage(SmsMessage[] msgs) {
+        final SmsMessage sms = msgs[0];
+        final ContentValues values = new ContentValues();
+        values.put(Telephony.Sms.Inbox.ADDRESS, sms.getDisplayOriginatingAddress());
+        values.put(Telephony.Sms.Inbox.BODY, buildMessageBodyFromPdus(msgs));
+        values.put(Telephony.Sms.Inbox.DATE_SENT, sms.getTimestampMillis());
+        values.put(Telephony.Sms.Inbox.DATE, System.currentTimeMillis());
+        values.put(Telephony.Sms.Inbox.PROTOCOL, sms.getProtocolIdentifier());
+        values.put(Telephony.Sms.Inbox.SEEN, 0);
+        values.put(Telephony.Sms.Inbox.READ, 0);
+        final String subject = sms.getPseudoSubject();
+        if (!TextUtils.isEmpty(subject)) {
+            values.put(Telephony.Sms.Inbox.SUBJECT, subject);
+        }
+        values.put(Telephony.Sms.Inbox.REPLY_PATH_PRESENT, sms.isReplyPathPresent() ? 1 : 0);
+        values.put(Telephony.Sms.Inbox.SERVICE_CENTER, sms.getServiceCenterAddress());
+        return values;
+    }
+
+    /**
+     * Build up the SMS message body from the SmsMessage array of received SMS
+     *
+     * @param msgs The SmsMessage array of the received SMS
+     * @return The text message body
+     */
+    private static String buildMessageBodyFromPdus(SmsMessage[] msgs) {
+        if (msgs.length == 1) {
+            // There is only one part, so grab the body directly.
+            return replaceFormFeeds(msgs[0].getDisplayMessageBody());
+        } else {
+            // Build up the body from the parts.
+            StringBuilder body = new StringBuilder();
+            for (SmsMessage msg: msgs) {
+                // getDisplayMessageBody() can NPE if mWrappedMessage inside is null.
+                body.append(msg.getDisplayMessageBody());
+            }
+            return replaceFormFeeds(body.toString());
+        }
+    }
+
+    // Some providers send formfeeds in their messages. Convert those formfeeds to newlines.
+    private static String replaceFormFeeds(String s) {
+        return s == null ? "" : s.replace('\f', '\n');
+    }
+
+    @VisibleForTesting
+    public PowerManager.WakeLock getWakeLock() {
+        return mWakeLock;
+    }
+
+    @VisibleForTesting
+    public int getWakeLockTimeout() {
+        return WAKELOCK_TIMEOUT;
+    }
+
+    // MTK-START
+    protected boolean dispatchConcateSmsParts(TimerRecord record) {
+        boolean handled = false;
+
+        if (record == null) {
+            if (ENG) {
+                log("ConcatenatedSmsFwkExt: null TimerRecord in msg");
+            }
+            return false;
+        }
+        if (ENG) {
+            log("ConcatenatedSmsFwkExt: timer is expired, dispatch existed segments. refNumber = "
+                    + record.refNumber);
+        }
+
+        // create null tracker for FSM flow
+        //InboundSmsTracker smsTracker = new InboundSmsTracker(null, 0, -1, is3gpp2(), false, null);
+        InboundSmsTracker smsTracker = (InboundSmsTracker)record.mTracker;
+        SmsBroadcastReceiver receiver = new SmsBroadcastReceiver(smsTracker);
+
+        synchronized (mRawLock) {
+            byte[][] pdus = mConcatenatedSmsFwkExt.queryExistedSegments(record);
+
+            // Do not process null pdu(s). Check for that and return false in that case.
+            List<byte[]> pduList = Arrays.asList(pdus);
+            if (pduList.size() == 0 || pduList.contains(null)) {
+                loge("dispatchConcateSmsParts: returning false due to " +
+                        (pduList.size() == 0 ? "pduList.size() == 0" : "pduList.contains(null)"));
+                return false;
+            }
+
+            // Check user unlock
+            if (!mUserManager.isUserUnlocked()) {
+                log("dispatchConcateSmsParts: device is still locked so delete segment(s), ref = "
+                        + record.refNumber);
+                mConcatenatedSmsFwkExt.deleteExistedSegments(record);
+                return processMessagePartWithUserLocked(smsTracker, pdus, -1, receiver);
+            }
+
+            // Check block number
+            if (BlockChecker.isBlocked(mContext, smsTracker.getAddress())) {
+                log("dispatchConcateSmsParts: block phone number, number = "
+                        + smsTracker.getAddress());
+                mConcatenatedSmsFwkExt.deleteExistedSegments(record);
+                deleteFromRawTable(smsTracker.getDeleteWhere(), smsTracker.getDeleteWhereArgs(),
+                        DELETE_PERMANENTLY);
+                return false;
+            }
+            if (pdus != null && pdus.length > 0) {
+                int flag = mConcatenatedSmsFwkExt.getUploadFlag(record);
+                if (flag == IConcatenatedSmsFwkExt.UPLOAD_FLAG_UPDATE ||
+                        flag == IConcatenatedSmsFwkExt.UPLOAD_FLAG_NEW) {
+                    mConcatenatedSmsFwkExt.setUploadFlag(record);
+
+                    List<String> carrierPackages = null;
+                    UiccCard card = UiccController.getInstance().getUiccCard(mPhone.getPhoneId());
+                    if (card != null) {
+                        carrierPackages = card.getCarrierPackageNamesForIntent(
+                                mContext.getPackageManager(),
+                                new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+                    } else {
+                        loge("UiccCard not initialized.");
+                    }
+
+                    List<String> systemPackages =
+                            getSystemAppForIntent(
+                            new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+
+                    if (carrierPackages != null && carrierPackages.size() == 1) {
+                        log("Found carrier package.");
+                        CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, -1,
+                                smsTracker.getFormat(), receiver, flag);
+                        CarrierSmsFilterCallback smsFilterCallback =
+                                new CarrierSmsFilterCallback(smsFilter, true);
+                        smsFilter.filterSms(carrierPackages.get(0), smsFilterCallback);
+                    } else if (systemPackages != null && systemPackages.size() == 1) {
+                        log("Found system package.");
+                        CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, -1,
+                                smsTracker.getFormat(), receiver, flag);
+                        CarrierSmsFilterCallback smsFilterCallback =
+                                new CarrierSmsFilterCallback(smsFilter, true);
+                        smsFilter.filterSms(systemPackages.get(0), smsFilterCallback);
+                    } else {
+                        logv("Unable to find carrier package: " + carrierPackages
+                                + ", nor systemPackages: " + systemPackages);
+                        dispatchSmsDeliveryIntent(pdus, smsTracker.getFormat(), -1,
+                                receiver, flag);
+                    }
+                    handled = true;
+                } else {
+                    if (ENG) {
+                        log("ConcatenatedSmsFwkExt: invalid upload flag");
+                    }
+                }
+            } else {
+                if (ENG) {
+                    log("ConcatenatedSmsFwkExt: no pdus to be dispatched");
+                }
+            }
+            if (ENG) {
+                log("ConcatenatedSmsFwkExt: delete segment(s), tracker = " +
+                        (InboundSmsTracker)record.mTracker);
+            }
+            mConcatenatedSmsFwkExt.deleteExistedSegments(record);
+        }
+
+        return handled;
+    }
+
+    /**
+     * Phone Privacy Lock intent handler.
+     * To handle the intent that send from sms finite state machine.
+     */
+    private BroadcastReceiver mPhonePrivacyLockReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+
+            String intentFormat = intent.getStringExtra("format");
+
+            int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                    SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            if (ENG) {
+                log("[Moms] intentFormat =" + intentFormat + ", subId=" + subId);
+            }
+
+            if (subId == mPhone.getSubId() &&
+                    ((is3gpp2() && (intentFormat.compareTo(SmsConstants.FORMAT_3GPP2) == 0)) ||
+                    (!is3gpp2() && (intentFormat.compareTo(SmsConstants.FORMAT_3GPP) == 0)))) {
+                if (intent.getAction().equals(Intents.PRIVACY_LOCK_SMS_RECEIVED_ACTION) &&
+                        phonePrivacyLockCheck(intent) != PackageManager.PERMISSION_GRANTED) {
+                    // Not permit to send to rest app
+                    setResultCode(Intents.RESULT_SMS_REJECT_BY_PPL);
+                }
+                else {
+                    // Set to result to the resultReceiver
+                    // Permit to send to rest app including default sms application
+                    setResultCode(Intents.RESULT_SMS_ACCEPT_BY_PPL);
+                }
+            }
+        }
+    };
+
+    /**
+     * Phone Privacy Lock check if this MT sms has permission to dispatch
+     */
+    protected int phonePrivacyLockCheck(Intent intent) {
+        int checkResult = PackageManager.PERMISSION_GRANTED;
+
+        if (SmsConstants.isPrivacyLockSupport()) {
+            /* CTA-level3 for phone privacy lock */
+            if (SmsConstants.isPrivacyLockSupport()) {
+                if (checkResult == PackageManager.PERMISSION_GRANTED) {
+
+                    Bundle pplData = new Bundle();
+                    Object[] messages = (Object[]) intent.getExtra("pdus");
+                    byte[][] pdus = new byte[messages.length][];
+                    for (int i = 0; i < messages.length; i++) {
+                        pdus[i] = (byte[]) messages[i];
+                    }
+
+                    pplData.putSerializable(mPplSmsFilter.KEY_PDUS, pdus);
+                    pplData.putString(mPplSmsFilter.KEY_FORMAT,
+                            (String) intent.getExtra("format"));
+                    pplData.putInt(mPplSmsFilter.KEY_SUB_ID, mPhone.getSubId());
+                    pplData.putInt(mPplSmsFilter.KEY_SMS_TYPE, 0);
+
+                    boolean pplResult = false;
+                    pplResult = mPplSmsFilter.pplFilter(pplData);
+                    if (ENG) {
+                        log("[Moms] Phone privacy check end, Need to filter(result) = "
+                                + pplResult);
+                    }
+                    if (pplResult == true) {
+                        checkResult = PackageManager.PERMISSION_DENIED;
+                    }
+                }
+            }
+        }
+
+        return checkResult;
+    }
+    // MTK-END
+
+    /**
+     * Handler for the broadcast sent when the new message notification is clicked. It launches the
+     * default SMS app.
+     */
+    private static class NewMessageNotificationActionReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (ACTION_OPEN_SMS_APP.equals(intent.getAction())) {
+                context.startActivity(context.getPackageManager().getLaunchIntentForPackage(
+                    Telephony.Sms.getDefaultSmsPackage(context)));
+            }
+        }
+    }
+
+    /**
+     * Registers the broadcast receiver to launch the default SMS app when the user clicks the
+     * new message notification.
+     */
+    static void registerNewMessageNotificationActionHandler(Context context) {
+        IntentFilter userFilter = new IntentFilter();
+        userFilter.addAction(ACTION_OPEN_SMS_APP);
+        context.registerReceiver(new NewMessageNotificationActionReceiver(), userFilter);
+    }
+}
Index: vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/WapPushOverSms.java
===================================================================
--- vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/WapPushOverSms.java	(revision 0)
+++ vendor/branch/5058I_ALRU/frameworks/opt/telephony/src/java/com/android/internal/telephony/WapPushOverSms.java	(revision 9196)
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.google.android.mms.pdu.PduHeaders.MESSAGE_TYPE_DELIVERY_IND;
+import static com.google.android.mms.pdu.PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND;
+import static com.google.android.mms.pdu.PduHeaders.MESSAGE_TYPE_READ_ORIG_IND;
+import android.app.Activity;
+import android.app.AppOpsManager;
+import android.app.BroadcastOptions;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SqliteWrapper;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.IDeviceIdleController;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Sms.Intents;
+import android.telephony.Rlog;
+import android.telephony.SmsManager;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+import com.android.internal.telephony.uicc.IccUtils;
+
+import java.util.HashMap;
+
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.DeliveryInd;
+import com.google.android.mms.pdu.GenericPdu;
+import com.google.android.mms.pdu.NotificationInd;
+import com.google.android.mms.pdu.PduHeaders;
+import com.google.android.mms.pdu.PduParser;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.ReadOrigInd;
+
+/**
+ * WAP push handler class.
+ *
+ * @hide
+ */
+public class WapPushOverSms implements ServiceConnection {
+    private static final String TAG = "WAP PUSH";
+    private static final boolean DBG = true;
+
+    private final Context mContext;
+    private IDeviceIdleController mDeviceIdleController;
+
+    private String mWapPushManagerPackage;
+
+    /** Assigned from ServiceConnection callback on main threaad. */
+    private volatile IWapPushManager mWapPushManager;
+
+    /** Broadcast receiver that binds to WapPushManager when the user unlocks the phone for the
+     *  first time after reboot and the credential-encrypted storage is available.
+     */
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, Intent intent) {
+            Rlog.d(TAG, "Received broadcast " + intent.getAction());
+            if (Intent.ACTION_USER_UNLOCKED.equals(intent.getAction())) {
+                new BindServiceThread(mContext).start();
+            }
+        }
+    };
+
+    private class BindServiceThread extends Thread {
+        private final Context context;
+
+        private BindServiceThread(Context context) {
+            this.context = context;
+        }
+
+        @Override
+        public void run() {
+            bindWapPushManagerService(context);
+        }
+    }
+
+    private void bindWapPushManagerService(Context context) {
+        Intent intent = new Intent(IWapPushManager.class.getName());
+        ComponentName comp = intent.resolveSystemService(context.getPackageManager(), 0);
+        intent.setComponent(comp);
+        if (comp == null || !context.bindService(intent, this, Context.BIND_AUTO_CREATE)) {
+            Rlog.e(TAG, "bindService() for wappush manager failed");
+        } else {
+            synchronized (this) {
+                mWapPushManagerPackage = comp.getPackageName();
+            }
+            if (DBG) Rlog.v(TAG, "bindService() for wappush manager succeeded");
+        }
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        mWapPushManager = IWapPushManager.Stub.asInterface(service);
+        if (DBG) Rlog.v(TAG, "wappush manager connected to " + hashCode());
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        mWapPushManager = null;
+        if (DBG) Rlog.v(TAG, "wappush manager disconnected.");
+    }
+
+    public WapPushOverSms(Context context) {
+        mContext = context;
+        mDeviceIdleController = TelephonyComponentFactory.getInstance().getIDeviceIdleController();
+
+        UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+
+        if (userManager.isUserUnlocked()) {
+            bindWapPushManagerService(mContext);
+        } else {
+            IntentFilter userFilter = new IntentFilter();
+            userFilter.addAction(Intent.ACTION_USER_UNLOCKED);
+            context.registerReceiver(mBroadcastReceiver, userFilter);
+        }
+    }
+
+    public void dispose() {
+        if (mWapPushManager != null) {
+            if (DBG) Rlog.v(TAG, "dispose: unbind wappush manager");
+            mContext.unbindService(this);
+        } else {
+            Rlog.e(TAG, "dispose: not bound to a wappush manager");
+        }
+    }
+
+    /**
+     * Decodes the wap push pdu. The decoded result is wrapped inside the {@link DecodedResult}
+     * object. The caller of this method should check {@link DecodedResult#statusCode} for the
+     * decoding status. It  can have the following values.
+     *
+     * Activity.RESULT_OK - the wap push pdu is successfully decoded and should be further processed
+     * Intents.RESULT_SMS_HANDLED - the wap push pdu should be ignored.
+     * Intents.RESULT_SMS_GENERIC_ERROR - the pdu is invalid.
+     */
+    private DecodedResult decodeWapPdu(byte[] pdu, InboundSmsHandler handler) {
+        DecodedResult result = new DecodedResult();
+        if (DBG) Rlog.d(TAG, "Rx: " + IccUtils.bytesToHexString(pdu));
+
+        try {
+            int index = 0;
+            int transactionId = pdu[index++] & 0xFF;
+            int pduType = pdu[index++] & 0xFF;
+
+            // Should we "abort" if no subId for now just no supplying extra param below
+            int phoneId = handler.getPhone().getPhoneId();
+
+            if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH) &&
+                    (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
+                index = mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_valid_wappush_index);
+                if (index != -1) {
+                    transactionId = pdu[index++] & 0xff;
+                    pduType = pdu[index++] & 0xff;
+                    if (DBG)
+                        Rlog.d(TAG, "index = " + index + " PDU Type = " + pduType +
+                                " transactionID = " + transactionId);
+
+                    // recheck wap push pduType
+                    if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH)
+                            && (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
+                        if (DBG) Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
+                        result.statusCode = Intents.RESULT_SMS_HANDLED;
+                        return result;
+                    }
+                } else {
+                    if (DBG) Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
+                    result.statusCode = Intents.RESULT_SMS_HANDLED;
+                    return result;
+                }
+            }
+
+            WspTypeDecoder pduDecoder =
+                    TelephonyComponentFactory.getInstance().makeWspTypeDecoder(pdu);
+
+            /**
+             * Parse HeaderLen(unsigned integer).
+             * From wap-230-wsp-20010705-a section 8.1.2
+             * The maximum size of a uintvar is 32 bits.
+             * So it will be encoded in no more than 5 octets.
+             */
+            if (pduDecoder.decodeUintvarInteger(index) == false) {
+                if (DBG) Rlog.w(TAG, "Received PDU. Header Length error.");
+                result.statusCode = Intents.RESULT_SMS_GENERIC_ERROR;
+                return result;
+            }
+            int headerLength = (int) pduDecoder.getValue32();
+            index += pduDecoder.getDecodedDataLength();
+
+            int headerStartIndex = index;
+
+            /**
+             * Parse Content-Type.
+             * From wap-230-wsp-20010705-a section 8.4.2.24
+             *
+             * Content-type-value = Constrained-media | Content-general-form
+             * Content-general-form = Value-length Media-type
+             * Media-type = (Well-known-media | Extension-Media) *(Parameter)
+             * Value-length = Short-length | (Length-quote Length)
+             * Short-length = <Any octet 0-30>   (octet <= WAP_PDU_SHORT_LENGTH_MAX)
+             * Length-quote = <Octet 31>         (WAP_PDU_LENGTH_QUOTE)
+             * Length = Uintvar-integer
+             */
+            if (pduDecoder.decodeContentType(index) == false) {
+                if (DBG) Rlog.w(TAG, "Received PDU. Header Content-Type error.");
+                result.statusCode = Intents.RESULT_SMS_GENERIC_ERROR;
+                return result;
+            }
+
+            String mimeType = pduDecoder.getValueString();
+            long binaryContentType = pduDecoder.getValue32();
+            index += pduDecoder.getDecodedDataLength();
+
+            byte[] header = new byte[headerLength];
+            System.arraycopy(pdu, headerStartIndex, header, 0, header.length);
+            // MTK-START
+            pduDecoder.decodeHeaders(index, headerLength - index + headerStartIndex);
+            // MTK-END
+
+            byte[] intentData;
+
+            if (mimeType != null && mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO)) {
+                intentData = pdu;
+            } else {
+                int dataIndex = headerStartIndex + headerLength;
+                intentData = new byte[pdu.length - dataIndex];
+                System.arraycopy(pdu, dataIndex, intentData, 0, intentData.length);
+            }
+
+            int[] subIds = SubscriptionManager.getSubId(phoneId);
+            int subId = (subIds != null) && (subIds.length > 0) ? subIds[0]
+                    : SmsManager.getDefaultSmsSubscriptionId();
+
+            // Continue if PDU parsing fails: the default messaging app may successfully parse the
+            // same PDU.
+            GenericPdu parsedPdu = null;
+            try {
+                parsedPdu = new PduParser(intentData, shouldParseContentDisposition(subId)).parse();
+            } catch (Exception e) {
+                Rlog.e(TAG, "Unable to parse PDU: " + e.toString());
+            }
+
+            if (parsedPdu != null && parsedPdu.getMessageType() == MESSAGE_TYPE_NOTIFICATION_IND) {
+                final NotificationInd nInd = (NotificationInd) parsedPdu;
+                if (nInd.getFrom() != null
+                        && BlockChecker.isBlocked(mContext, nInd.getFrom().getString())) {
+                    result.statusCode = Intents.RESULT_SMS_HANDLED;
+                    return result;
+                }
+            }
+
+            /**
+             * Seek for application ID field in WSP header.
+             * If application ID is found, WapPushManager substitute the message
+             * processing. Since WapPushManager is optional module, if WapPushManager
+             * is not found, legacy message processing will be continued.
+             */
+            if (pduDecoder.seekXWapApplicationId(index, index + headerLength - 1)) {
+                index = (int) pduDecoder.getValue32();
+                pduDecoder.decodeXWapApplicationId(index);
+                String wapAppId = pduDecoder.getValueString();
+                if (wapAppId == null) {
+                    wapAppId = Integer.toString((int) pduDecoder.getValue32());
+                }
+                result.wapAppId = wapAppId;
+                String contentType = ((mimeType == null) ?
+                        Long.toString(binaryContentType) : mimeType);
+                result.contentType = contentType;
+                if (DBG) Rlog.v(TAG, "appid found: " + wapAppId + ":" + contentType);
+            }
+
+            result.subId = subId;
+            result.phoneId = phoneId;
+            result.parsedPdu = parsedPdu;
+            result.mimeType = mimeType;
+            result.transactionId = transactionId;
+            result.pduType = pduType;
+            result.header = header;
+            result.intentData = intentData;
+            result.contentTypeParameters = pduDecoder.getContentParameters();
+            result.statusCode = Activity.RESULT_OK;
+            result.headerList = pduDecoder.getHeaders();
+        } catch (ArrayIndexOutOfBoundsException aie) {
+            // 0-byte WAP PDU or other unexpected WAP PDU contents can easily throw this;
+            // log exception string without stack trace and return false.
+            Rlog.e(TAG, "ignoring dispatchWapPdu() array index exception: " + aie);
+            result.statusCode = Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+        return result;
+    }
+
+    /**
+     * Dispatches inbound messages that are in the WAP PDU format. See
+     * wap-230-wsp-20010705-a section 8 for details on the WAP PDU format.
+     *
+     * @param pdu The WAP PDU, made up of one or more SMS PDUs
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents}, or
+     *         {@link Activity#RESULT_OK} if the message has been broadcast
+     *         to applications
+     */
+    public int dispatchWapPdu(byte[] pdu, BroadcastReceiver receiver, InboundSmsHandler handler) {
+        DecodedResult result = decodeWapPdu(pdu, handler);
+        if (result.statusCode != Activity.RESULT_OK) {
+            return result.statusCode;
+        }
+
+        if (SmsManager.getDefault().getAutoPersisting()) {
+            // Store the wap push data in telephony
+            writeInboxMessage(result.subId, result.parsedPdu);
+        }
+
+        /**
+         * If the pdu has application ID, WapPushManager substitute the message
+         * processing. Since WapPushManager is optional module, if WapPushManager
+         * is not found, legacy message processing will be continued.
+         */
+        if (result.wapAppId != null) {
+            try {
+                boolean processFurther = true;
+                IWapPushManager wapPushMan = mWapPushManager;
+
+                if (wapPushMan == null) {
+                    if (DBG) Rlog.w(TAG, "wap push manager not found!");
+                } else {
+                    synchronized (this) {
+                        mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(
+                                mWapPushManagerPackage, 0, "mms-mgr");
+                    }
+
+                    Intent intent = new Intent();
+                    intent.putExtra("transactionId", result.transactionId);
+                    intent.putExtra("pduType", result.pduType);
+                    intent.putExtra("header", result.header);
+                    intent.putExtra("data", result.intentData);
+                    intent.putExtra("contentTypeParameters", result.contentTypeParameters);
+                    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, result.phoneId);
+                    // MTK-START
+                    intent.putExtra("wspHeaders", result.headerList);
+
+                    if (bundle != null) {
+                        Rlog.d(TAG, "put addr info into intent 1");
+                        intent.putExtra(Telephony.WapPush.ADDR, bundle.getString(
+                                Telephony.WapPush.ADDR));
+                        intent.putExtra(Telephony.WapPush.SERVICE_ADDR, bundle.getString(
+                                Telephony.WapPush.SERVICE_ADDR));
+                    }
+                    // MTK-END
+
+                    int procRet = wapPushMan.processMessage(
+                        result.wapAppId, result.contentType, intent);
+                    if (DBG) Rlog.v(TAG, "procRet:" + procRet);
+                    if ((procRet & WapPushManagerParams.MESSAGE_HANDLED) > 0
+                            && (procRet & WapPushManagerParams.FURTHER_PROCESSING) == 0) {
+                        processFurther = false;
+                    }
+                }
+                if (!processFurther) {
+                    return Intents.RESULT_SMS_HANDLED;
+                }
+            } catch (RemoteException e) {
+                if (DBG) Rlog.w(TAG, "remote func failed...");
+            }
+        }
+        if (DBG) Rlog.v(TAG, "fall back to existing handler");
+
+        if (result.mimeType == null) {
+            if (DBG) Rlog.w(TAG, "Header Content-Type error.");
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        Intent intent = new Intent(Intents.WAP_PUSH_DELIVER_ACTION);
+        intent.setType(result.mimeType);
+        intent.putExtra("transactionId", result.transactionId);
+        intent.putExtra("pduType", result.pduType);
+        intent.putExtra("header", result.header);
+        intent.putExtra("data", result.intentData);
+        intent.putExtra("contentTypeParameters", result.contentTypeParameters);
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, result.phoneId);
+        // MTK-START
+        intent.putExtra("wspHeaders", result.headerList);
+
+        if (bundle != null) {
+            Rlog.d(TAG, "put addr info into intent 2");
+            intent.putExtra(Telephony.WapPush.ADDR, bundle.getString(Telephony.WapPush.ADDR));
+            intent.putExtra(Telephony.WapPush.SERVICE_ADDR, bundle.getString(
+                    Telephony.WapPush.SERVICE_ADDR));
+        }
+        // MTK-END
+
+        // Direct the intent to only the default MMS app. If we can't find a default MMS app
+        // then sent it to all broadcast receivers.
+        ComponentName componentName = SmsApplication.getDefaultMmsApplication(mContext, true);
+        Bundle options = null;
+        if (componentName != null) {
+            // Deliver MMS message only to this receiver
+            intent.setComponent(componentName);
+            if (DBG) Rlog.v(TAG, "Delivering MMS to: " + componentName.getPackageName() +
+                    " " + componentName.getClassName());
+            try {
+                long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(
+                        componentName.getPackageName(), 0, "mms-app");
+                BroadcastOptions bopts = BroadcastOptions.makeBasic();
+                bopts.setTemporaryAppWhitelistDuration(duration);
+                options = bopts.toBundle();
+            } catch (RemoteException e) {
+            }
+        }
+
+        handler.dispatchIntent(intent, getPermissionForType(result.mimeType),
+                getAppOpsPermissionForIntent(result.mimeType), options, receiver,
+                UserHandle.SYSTEM);
+        return Activity.RESULT_OK;
+    }
+
+    /**
+     * Check whether the pdu is a MMS WAP push pdu that should be dispatched to the SMS app.
+     */
+    public boolean isWapPushForMms(byte[] pdu, InboundSmsHandler handler) {
+        DecodedResult result = decodeWapPdu(pdu, handler);
+        return result.statusCode == Activity.RESULT_OK
+            && WspTypeDecoder.CONTENT_TYPE_B_MMS.equals(result.mimeType);
+    }
+
+    private static boolean shouldParseContentDisposition(int subId) {
+        return SmsManager
+                .getSmsManagerForSubscriptionId(subId)
+                .getCarrierConfigValues()
+                .getBoolean(SmsManager.MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION, true);
+    }
+
+    private void writeInboxMessage(int subId, GenericPdu pdu) {
+        if (pdu == null) {
+            Rlog.e(TAG, "Invalid PUSH PDU");
+        }
+        final PduPersister persister = PduPersister.getPduPersister(mContext);
+        final int type = pdu.getMessageType();
+        try {
+            switch (type) {
+                case MESSAGE_TYPE_DELIVERY_IND:
+                case MESSAGE_TYPE_READ_ORIG_IND: {
+                    final long threadId = getDeliveryOrReadReportThreadId(mContext, pdu);
+                    if (threadId == -1) {
+                        // The associated SendReq isn't found, therefore skip
+                        // processing this PDU.
+                        Rlog.e(TAG, "Failed to find delivery or read report's thread id");
+                        break;
+                    }
+                    final Uri uri = persister.persist(
+                            pdu,
+                            Telephony.Mms.Inbox.CONTENT_URI,
+                            true/*createThreadId*/,
+                            true/*groupMmsEnabled*/,
+                            null/*preOpenedFiles*/);
+                    if (uri == null) {
+                        Rlog.e(TAG, "Failed to persist delivery or read report");
+                        break;
+                    }
+                    // Update thread ID for ReadOrigInd & DeliveryInd.
+                    final ContentValues values = new ContentValues(1);
+                    values.put(Telephony.Mms.THREAD_ID, threadId);
+                    if (SqliteWrapper.update(
+                            mContext,
+                            mContext.getContentResolver(),
+                            uri,
+                            values,
+                            null/*where*/,
+                            null/*selectionArgs*/) != 1) {
+                        Rlog.e(TAG, "Failed to update delivery or read report thread id");
+                    }
+                    break;
+                }
+                case MESSAGE_TYPE_NOTIFICATION_IND: {
+                    final NotificationInd nInd = (NotificationInd) pdu;
+
+                    Bundle configs = SmsManager.getSmsManagerForSubscriptionId(subId)
+                            .getCarrierConfigValues();
+                    if (configs != null && configs.getBoolean(
+                        SmsManager.MMS_CONFIG_APPEND_TRANSACTION_ID, false)) {
+                        final byte [] contentLocation = nInd.getContentLocation();
+                        if ('=' == contentLocation[contentLocation.length - 1]) {
+                            byte [] transactionId = nInd.getTransactionId();
+                            byte [] contentLocationWithId = new byte [contentLocation.length
+                                    + transactionId.length];
+                            System.arraycopy(contentLocation, 0, contentLocationWithId,
+                                    0, contentLocation.length);
+                            System.arraycopy(transactionId, 0, contentLocationWithId,
+                                    contentLocation.length, transactionId.length);
+                            nInd.setContentLocation(contentLocationWithId);
+                        }
+                    }
+                    if (!isDuplicateNotification(mContext, nInd)) {
+                        final Uri uri = persister.persist(
+                                pdu,
+                                Telephony.Mms.Inbox.CONTENT_URI,
+                                true/*createThreadId*/,
+                                true/*groupMmsEnabled*/,
+                                null/*preOpenedFiles*/);
+                        if (uri == null) {
+                            Rlog.e(TAG, "Failed to save MMS WAP push notification ind");
+                        }
+                    } else {
+                        Rlog.d(TAG, "Skip storing duplicate MMS WAP push notification ind: "
+                                + new String(nInd.getContentLocation()));
+                    }
+                    break;
+                }
+                default:
+                    Log.e(TAG, "Received unrecognized WAP Push PDU.");
+            }
+        } catch (MmsException e) {
+            Log.e(TAG, "Failed to save MMS WAP push data: type=" + type, e);
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Unexpected RuntimeException in persisting MMS WAP push data", e);
+        }
+
+    }
+
+    private static final String THREAD_ID_SELECTION =
+            Telephony.Mms.MESSAGE_ID + "=? AND " + Telephony.Mms.MESSAGE_TYPE + "=?";
+
+    private static long getDeliveryOrReadReportThreadId(Context context, GenericPdu pdu) {
+        String messageId;
+        if (pdu instanceof DeliveryInd) {
+            messageId = new String(((DeliveryInd) pdu).getMessageId());
+        } else if (pdu instanceof ReadOrigInd) {
+            messageId = new String(((ReadOrigInd) pdu).getMessageId());
+        } else {
+            Rlog.e(TAG, "WAP Push data is neither delivery or read report type: "
+                    + pdu.getClass().getCanonicalName());
+            return -1L;
+        }
+        Cursor cursor = null;
+        try {
+            cursor = SqliteWrapper.query(
+                    context,
+                    context.getContentResolver(),
+                    Telephony.Mms.CONTENT_URI,
+                    new String[]{ Telephony.Mms.THREAD_ID },
+                    THREAD_ID_SELECTION,
+                    new String[]{
+                            DatabaseUtils.sqlEscapeString(messageId),
+                            Integer.toString(PduHeaders.MESSAGE_TYPE_SEND_REQ)
+                    },
+                    null/*sortOrder*/);
+            if (cursor != null && cursor.moveToFirst()) {
+                return cursor.getLong(0);
+            }
+        } catch (SQLiteException e) {
+            Rlog.e(TAG, "Failed to query delivery or read report thread id", e);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return -1L;
+    }
+
+    private static final String LOCATION_SELECTION =
+            Telephony.Mms.MESSAGE_TYPE + "=? AND " + Telephony.Mms.CONTENT_LOCATION + " =?";
+
+    private static boolean isDuplicateNotification(Context context, NotificationInd nInd) {
+        final byte[] rawLocation = nInd.getContentLocation();
+        if (rawLocation != null) {
+            String location = new String(rawLocation);
+            String[] selectionArgs = new String[] { location };
+            Cursor cursor = null;
+            try {
+                cursor = SqliteWrapper.query(
+                        context,
+                        context.getContentResolver(),
+                        Telephony.Mms.CONTENT_URI,
+                        new String[]{Telephony.Mms._ID},
+                        LOCATION_SELECTION,
+                        new String[]{
+                                Integer.toString(PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND),
+                                new String(rawLocation)
+                        },
+                        null/*sortOrder*/);
+                if (cursor != null && cursor.getCount() > 0) {
+                    // We already received the same notification before.
+                    return true;
+                }
+            } catch (SQLiteException e) {
+                Rlog.e(TAG, "failed to query existing notification ind", e);
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+        return false;
+    }
+
+    public static String getPermissionForType(String mimeType) {
+        String permission;
+        if (WspTypeDecoder.CONTENT_TYPE_B_MMS.equals(mimeType)) {
+            permission = android.Manifest.permission.RECEIVE_MMS;
+        } else {
+            permission = android.Manifest.permission.RECEIVE_WAP_PUSH;
+        }
+        return permission;
+    }
+
+    public static int getAppOpsPermissionForIntent(String mimeType) {
+        int appOp;
+        if (WspTypeDecoder.CONTENT_TYPE_B_MMS.equals(mimeType)) {
+            appOp = AppOpsManager.OP_RECEIVE_MMS;
+        } else {
+            appOp = AppOpsManager.OP_RECEIVE_WAP_PUSH;
+        }
+        return appOp;
+    }
+
+    /**
+     * Place holder for decoded Wap pdu data.
+     */
+    private final class DecodedResult {
+        String mimeType;
+        String contentType;
+        int transactionId;
+        int pduType;
+        int phoneId;
+        int subId;
+        byte[] header;
+        String wapAppId;
+        byte[] intentData;
+        HashMap<String, String> contentTypeParameters;
+        GenericPdu parsedPdu;
+        int statusCode;
+        // MTK-START
+        HashMap<String, String> headerList;
+        // MTK-END
+    }
+
+    // MTK-START
+    /*
+     * Add for wappush to get address and service address.
+     * Address and service address will be stored in bundle
+     * dispatchWapPdu(byte[] pdu, Bundle extra) will be called by framework
+     */
+    private Bundle bundle;
+    public int dispatchWapPdu(byte[] pdu,  BroadcastReceiver receiver, InboundSmsHandler handler,
+            Bundle extra) {
+        if (DBG) Rlog.i(TAG, "dispathchWapPdu!"
+            + extra.getString(Telephony.WapPush.ADDR) + " "
+            + extra.getString(Telephony.WapPush.SERVICE_ADDR));
+
+        bundle = extra;
+        return dispatchWapPdu(pdu, receiver, handler);
+    }
+    // MTK-END
+}
