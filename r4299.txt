Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/dialpad/LatinSmartDialMap.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/dialpad/LatinSmartDialMap.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/dialpad/LatinSmartDialMap.java	(revision 4299)
@@ -0,0 +1,481 @@
+package com.android.dialer.dialpad;
+
+public class LatinSmartDialMap implements SmartDialMap {
+
+    private static final char[] LATIN_LETTERS_TO_DIGITS = {
+        '2', '2', '2', // A,B,C -> 2
+        '3', '3', '3', // D,E,F -> 3
+        '4', '4', '4', // G,H,I -> 4
+        '5', '5', '5', // J,K,L -> 5
+        '6', '6', '6', // M,N,O -> 6
+        '7', '7', '7', '7', // P,Q,R,S -> 7
+        '8', '8', '8', // T,U,V -> 8
+        '9', '9', '9', '9' // W,X,Y,Z -> 9
+    };
+
+    @Override
+    public boolean isValidDialpadAlphabeticChar(char ch) {
+        return (ch >= 'a' && ch <= 'z');
+    }
+
+    @Override
+    public boolean isValidDialpadNumericChar(char ch) {
+        return (ch >= '0' && ch <= '9');
+    }
+
+    @Override
+    public boolean isValidDialpadCharacter(char ch) {
+        return (isValidDialpadAlphabeticChar(ch) || isValidDialpadNumericChar(ch));
+    }
+
+    /*
+     * The switch statement in this function was generated using the python code:
+     * from unidecode import unidecode
+     * for i in range(192, 564):
+     *     char = unichr(i)
+     *     decoded = unidecode(char)
+     *     # Unicode characters that decompose into multiple characters i.e.
+     *     #  into ss are not supported for now
+     *     if (len(decoded) == 1 and decoded.isalpha()):
+     *         print "case '" + char + "': return '" + unidecode(char) +  "';"
+     *
+     * This gives us a way to map characters containing accents/diacritics to their
+     * alphabetic equivalents. The unidecode library can be found at:
+     * http://pypi.python.org/pypi/Unidecode/0.04.1
+     *
+     * Also remaps all upper case latin characters to their lower case equivalents.
+     */
+    @Override
+    public char normalizeCharacter(char ch) {
+        switch (ch) {
+            case 'À': return 'a';
+            case 'Á': return 'a';
+            case 'Â': return 'a';
+            case 'Ã': return 'a';
+            case 'Ä': return 'a';
+            case 'Å': return 'a';
+            case 'Ç': return 'c';
+            case 'È': return 'e';
+            case 'É': return 'e';
+            case 'Ê': return 'e';
+            case 'Ë': return 'e';
+            case 'Ì': return 'i';
+            case 'Í': return 'i';
+            case 'Î': return 'i';
+            case 'Ï': return 'i';
+            case 'Ð': return 'd';
+            case 'Ñ': return 'n';
+            case 'Ò': return 'o';
+            case 'Ó': return 'o';
+            case 'Ô': return 'o';
+            case 'Õ': return 'o';
+            case 'Ö': return 'o';
+            case '×': return 'x';
+            case 'Ø': return 'o';
+            case 'Ù': return 'u';
+            case 'Ú': return 'u';
+            case 'Û': return 'u';
+            case 'Ü': return 'u';
+            case 'Ý': return 'u';
+            case 'à': return 'a';
+            case 'á': return 'a';
+            case 'â': return 'a';
+            case 'ã': return 'a';
+            case 'ä': return 'a';
+            case 'å': return 'a';
+            case 'ç': return 'c';
+            case 'è': return 'e';
+            case 'é': return 'e';
+            case 'ê': return 'e';
+            case 'ë': return 'e';
+            case 'ì': return 'i';
+            case 'í': return 'i';
+            case 'î': return 'i';
+            case 'ï': return 'i';
+            case 'ð': return 'd';
+            case 'ñ': return 'n';
+            case 'ò': return 'o';
+            case 'ó': return 'o';
+            case 'ô': return 'o';
+            case 'õ': return 'o';
+            case 'ö': return 'o';
+            case 'ø': return 'o';
+            case 'ù': return 'u';
+            case 'ú': return 'u';
+            case 'û': return 'u';
+            case 'ü': return 'u';
+            case 'ý': return 'y';
+            case 'ÿ': return 'y';
+            case 'Ā': return 'a';
+            case 'ā': return 'a';
+            case 'Ă': return 'a';
+            case 'ă': return 'a';
+            case 'Ą': return 'a';
+            case 'ą': return 'a';
+            case 'Ć': return 'c';
+            case 'ć': return 'c';
+            case 'Ĉ': return 'c';
+            case 'ĉ': return 'c';
+            case 'Ċ': return 'c';
+            case 'ċ': return 'c';
+            case 'Č': return 'c';
+            case 'č': return 'c';
+            case 'Ď': return 'd';
+            case 'ď': return 'd';
+            case 'Đ': return 'd';
+            case 'đ': return 'd';
+            case 'Ē': return 'e';
+            case 'ē': return 'e';
+            case 'Ĕ': return 'e';
+            case 'ĕ': return 'e';
+            case 'Ė': return 'e';
+            case 'ė': return 'e';
+            case 'Ę': return 'e';
+            case 'ę': return 'e';
+            case 'Ě': return 'e';
+            case 'ě': return 'e';
+            case 'Ĝ': return 'g';
+            case 'ĝ': return 'g';
+            case 'Ğ': return 'g';
+            case 'ğ': return 'g';
+            case 'Ġ': return 'g';
+            case 'ġ': return 'g';
+            case 'Ģ': return 'g';
+            case 'ģ': return 'g';
+            case 'Ĥ': return 'h';
+            case 'ĥ': return 'h';
+            case 'Ħ': return 'h';
+            case 'ħ': return 'h';
+            case 'Ĩ': return 'i';
+            case 'ĩ': return 'i';
+            case 'Ī': return 'i';
+            case 'ī': return 'i';
+            case 'Ĭ': return 'i';
+            case 'ĭ': return 'i';
+            case 'Į': return 'i';
+            case 'į': return 'i';
+            case 'İ': return 'i';
+            case 'ı': return 'i';
+            case 'Ĵ': return 'j';
+            case 'ĵ': return 'j';
+            case 'Ķ': return 'k';
+            case 'ķ': return 'k';
+            case 'ĸ': return 'k';
+            case 'Ĺ': return 'l';
+            case 'ĺ': return 'l';
+            case 'Ļ': return 'l';
+            case 'ļ': return 'l';
+            case 'Ľ': return 'l';
+            case 'ľ': return 'l';
+            case 'Ŀ': return 'l';
+            case 'ŀ': return 'l';
+            case 'Ł': return 'l';
+            case 'ł': return 'l';
+            case 'Ń': return 'n';
+            case 'ń': return 'n';
+            case 'Ņ': return 'n';
+            case 'ņ': return 'n';
+            case 'Ň': return 'n';
+            case 'ň': return 'n';
+            case 'Ō': return 'o';
+            case 'ō': return 'o';
+            case 'Ŏ': return 'o';
+            case 'ŏ': return 'o';
+            case 'Ő': return 'o';
+            case 'ő': return 'o';
+            case 'Ŕ': return 'r';
+            case 'ŕ': return 'r';
+            case 'Ŗ': return 'r';
+            case 'ŗ': return 'r';
+            case 'Ř': return 'r';
+            case 'ř': return 'r';
+            case 'Ś': return 's';
+            case 'ś': return 's';
+            case 'Ŝ': return 's';
+            case 'ŝ': return 's';
+            case 'Ş': return 's';
+            case 'ş': return 's';
+            case 'Š': return 's';
+            case 'š': return 's';
+            case 'Ţ': return 't';
+            case 'ţ': return 't';
+            case 'Ť': return 't';
+            case 'ť': return 't';
+            case 'Ŧ': return 't';
+            case 'ŧ': return 't';
+            case 'Ũ': return 'u';
+            case 'ũ': return 'u';
+            case 'Ū': return 'u';
+            case 'ū': return 'u';
+            case 'Ŭ': return 'u';
+            case 'ŭ': return 'u';
+            case 'Ů': return 'u';
+            case 'ů': return 'u';
+            case 'Ű': return 'u';
+            case 'ű': return 'u';
+            case 'Ų': return 'u';
+            case 'ų': return 'u';
+            case 'Ŵ': return 'w';
+            case 'ŵ': return 'w';
+            case 'Ŷ': return 'y';
+            case 'ŷ': return 'y';
+            case 'Ÿ': return 'y';
+            case 'Ź': return 'z';
+            case 'ź': return 'z';
+            case 'Ż': return 'z';
+            case 'ż': return 'z';
+            case 'Ž': return 'z';
+            case 'ž': return 'z';
+            case 'ſ': return 's';
+            case 'ƀ': return 'b';
+            case 'Ɓ': return 'b';
+            case 'Ƃ': return 'b';
+            case 'ƃ': return 'b';
+            case 'Ɔ': return 'o';
+            case 'Ƈ': return 'c';
+            case 'ƈ': return 'c';
+            case 'Ɖ': return 'd';
+            case 'Ɗ': return 'd';
+            case 'Ƌ': return 'd';
+            case 'ƌ': return 'd';
+            case 'ƍ': return 'd';
+            case 'Ɛ': return 'e';
+            case 'Ƒ': return 'f';
+            case 'ƒ': return 'f';
+            case 'Ɠ': return 'g';
+            case 'Ɣ': return 'g';
+            case 'Ɩ': return 'i';
+            case 'Ɨ': return 'i';
+            case 'Ƙ': return 'k';
+            case 'ƙ': return 'k';
+            case 'ƚ': return 'l';
+            case 'ƛ': return 'l';
+            case 'Ɯ': return 'w';
+            case 'Ɲ': return 'n';
+            case 'ƞ': return 'n';
+            case 'Ɵ': return 'o';
+            case 'Ơ': return 'o';
+            case 'ơ': return 'o';
+            case 'Ƥ': return 'p';
+            case 'ƥ': return 'p';
+            case 'ƫ': return 't';
+            case 'Ƭ': return 't';
+            case 'ƭ': return 't';
+            case 'Ʈ': return 't';
+            case 'Ư': return 'u';
+            case 'ư': return 'u';
+            case 'Ʊ': return 'y';
+            case 'Ʋ': return 'v';
+            case 'Ƴ': return 'y';
+            case 'ƴ': return 'y';
+            case 'Ƶ': return 'z';
+            case 'ƶ': return 'z';
+            case 'ƿ': return 'w';
+            case 'Ǎ': return 'a';
+            case 'ǎ': return 'a';
+            case 'Ǐ': return 'i';
+            case 'ǐ': return 'i';
+            case 'Ǒ': return 'o';
+            case 'ǒ': return 'o';
+            case 'Ǔ': return 'u';
+            case 'ǔ': return 'u';
+            case 'Ǖ': return 'u';
+            case 'ǖ': return 'u';
+            case 'Ǘ': return 'u';
+            case 'ǘ': return 'u';
+            case 'Ǚ': return 'u';
+            case 'ǚ': return 'u';
+            case 'Ǜ': return 'u';
+            case 'ǜ': return 'u';
+            case 'Ǟ': return 'a';
+            case 'ǟ': return 'a';
+            case 'Ǡ': return 'a';
+            case 'ǡ': return 'a';
+            case 'Ǥ': return 'g';
+            case 'ǥ': return 'g';
+            case 'Ǧ': return 'g';
+            case 'ǧ': return 'g';
+            case 'Ǩ': return 'k';
+            case 'ǩ': return 'k';
+            case 'Ǫ': return 'o';
+            case 'ǫ': return 'o';
+            case 'Ǭ': return 'o';
+            case 'ǭ': return 'o';
+            case 'ǰ': return 'j';
+            case 'ǲ': return 'd';
+            case 'Ǵ': return 'g';
+            case 'ǵ': return 'g';
+            case 'Ƿ': return 'w';
+            case 'Ǹ': return 'n';
+            case 'ǹ': return 'n';
+            case 'Ǻ': return 'a';
+            case 'ǻ': return 'a';
+            case 'Ǿ': return 'o';
+            case 'ǿ': return 'o';
+            case 'Ȁ': return 'a';
+            case 'ȁ': return 'a';
+            case 'Ȃ': return 'a';
+            case 'ȃ': return 'a';
+            case 'Ȅ': return 'e';
+            case 'ȅ': return 'e';
+            case 'Ȇ': return 'e';
+            case 'ȇ': return 'e';
+            case 'Ȉ': return 'i';
+            case 'ȉ': return 'i';
+            case 'Ȋ': return 'i';
+            case 'ȋ': return 'i';
+            case 'Ȍ': return 'o';
+            case 'ȍ': return 'o';
+            case 'Ȏ': return 'o';
+            case 'ȏ': return 'o';
+            case 'Ȑ': return 'r';
+            case 'ȑ': return 'r';
+            case 'Ȓ': return 'r';
+            case 'ȓ': return 'r';
+            case 'Ȕ': return 'u';
+            case 'ȕ': return 'u';
+            case 'Ȗ': return 'u';
+            case 'ȗ': return 'u';
+            case 'Ș': return 's';
+            case 'ș': return 's';
+            case 'Ț': return 't';
+            case 'ț': return 't';
+            case 'Ȝ': return 'y';
+            case 'ȝ': return 'y';
+            case 'Ȟ': return 'h';
+            case 'ȟ': return 'h';
+            case 'Ȥ': return 'z';
+            case 'ȥ': return 'z';
+            case 'Ȧ': return 'a';
+            case 'ȧ': return 'a';
+            case 'Ȩ': return 'e';
+            case 'ȩ': return 'e';
+            case 'Ȫ': return 'o';
+            case 'ȫ': return 'o';
+            case 'Ȭ': return 'o';
+            case 'ȭ': return 'o';
+            case 'Ȯ': return 'o';
+            case 'ȯ': return 'o';
+            case 'Ȱ': return 'o';
+            case 'ȱ': return 'o';
+            case 'Ȳ': return 'y';
+            case 'ȳ': return 'y';
+            case 'A': return 'a';
+            case 'B': return 'b';
+            case 'C': return 'c';
+            case 'D': return 'd';
+            case 'E': return 'e';
+            case 'F': return 'f';
+            case 'G': return 'g';
+            case 'H': return 'h';
+            case 'I': return 'i';
+            case 'J': return 'j';
+            case 'K': return 'k';
+            case 'L': return 'l';
+            case 'M': return 'm';
+            case 'N': return 'n';
+            case 'O': return 'o';
+            case 'P': return 'p';
+            case 'Q': return 'q';
+            case 'R': return 'r';
+            case 'S': return 's';
+            case 'T': return 't';
+            case 'U': return 'u';
+            case 'V': return 'v';
+            case 'W': return 'w';
+            case 'X': return 'x';
+            case 'Y': return 'y';
+            case 'Z': return 'z';
+			
+			/*Begin, by mzj for smart_dial_sort_order*/
+            case 'А': return 'a';
+            case 'а': return 'a';
+            case 'Б': return 'b';
+            case 'б': return 'b';
+            case 'В': return 'b';
+            case 'в': return 'b';
+            case 'Г': return 'c';
+            case 'г': return 'c';
+            case 'Д': return 'd';
+            case 'д': return 'd';
+            case 'Е': return 'e';
+            case 'е': return 'e';
+            case 'Ж': return 'e';
+            case 'ж': return 'e';
+            case 'З': return 'f';
+            case 'з': return 'f';
+            case 'И': return 'g';
+            case 'и': return 'g';
+            case 'Й': return 'h';
+            case 'й': return 'h';
+            case 'К': return 'h';
+            case 'к': return 'h';
+            case 'Л': return 'i';
+            case 'л': return 'i';
+            case 'М': return 'j';
+            case 'м': return 'j';
+            case 'Н': return 'k';
+            case 'н': return 'k';
+            case 'О': return 'k';
+            case 'о': return 'k';
+            case 'П': return 'l';
+            case 'п': return 'l';
+            case 'Р': return 'm';
+            case 'р': return 'm';
+            case 'С': return 'n';
+            case 'с': return 'n';
+            case 'Т': return 'n';
+            case 'т': return 'n';
+            case 'У': return 'o';
+            case 'у': return 'o';
+            case 'Ф': return 'p';
+            case 'ф': return 'p';
+            case 'Х': return 'q';
+            case 'х': return 'q';
+            case 'Ц': return 'r';
+            case 'ц': return 'r';
+            case 'Ч': return 's';
+            case 'ч': return 's';
+            case 'Ш': return 't';
+            case 'ш': return 't';
+            case 'Щ': return 'u';
+            case 'щ': return 'u';
+            case 'Ъ': return 'u';
+            case 'ъ': return 'u';
+            case 'Ы': return 'v';
+            case 'ы': return 'v';
+            case 'Ь': return 'w';
+            case 'ь': return 'w';
+            case 'Э': return 'x';
+            case 'э': return 'x';
+            case 'Ю': return 'y';
+            case 'ю': return 'y';
+            case 'Я': return 'z';
+            case 'я': return 'z';
+            /*End, by mzj for smart_dial_sort_order*/
+			
+            default:
+                return ch;
+        }
+    }
+
+    @Override
+    public byte getDialpadIndex(char ch) {
+        if (ch >= '0' && ch <= '9') {
+            return (byte) (ch - '0');
+        } else if (ch >= 'a' && ch <= 'z') {
+            return (byte) (LATIN_LETTERS_TO_DIGITS[ch - 'a'] - '0');
+        } else {
+            return -1;
+        }
+    }
+
+    @Override
+    public char getDialpadNumericCharacter(char ch) {
+        if (ch >= 'a' && ch <= 'z') {
+            return LATIN_LETTERS_TO_DIGITS[ch - 'a'];
+        }
+        return ch;
+    }
+
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/settings/DisplayOptionsSettingsFragment.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/settings/DisplayOptionsSettingsFragment.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/settings/DisplayOptionsSettingsFragment.java	(revision 4299)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.dialer.settings;
+
+import android.os.Bundle;
+import android.preference.PreferenceFragment;
+
+import com.android.dialer.R;
+
+import java.util.Locale;
+import com.android.contacts.common.preference.SmartDialSortPreference;
+import android.preference.Preference;
+
+public class DisplayOptionsSettingsFragment extends PreferenceFragment {
+
+	/*Begin, by fu.zhang for smart_dial_sort*/
+	private String mlang = null ; 
+    /*End, by mzj for smart_dial_sort*/
+	
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.display_options_settings);
+		
+		/* Begin, by fu.zhang for smart_dial_sort*/
+        //PreferenceCategory displayCategory = (PreferenceCategory) findPreference(CATEGORY_DISPLAY_KEY);
+        mlang = Locale.getDefault().getLanguage();
+        Preference smartDialSortOrder = findPreference("smartDialSortOrder");
+		if(null == smartDialSortOrder){
+			smartDialSortOrder = new SmartDialSortPreference(this.getActivity());
+			smartDialSortOrder.setKey("smartDialSortOrder");
+			smartDialSortOrder.setTitle(R.string.smart_dial_sort_ellipsize);
+			getPreferenceScreen().addPreference(smartDialSortOrder);
+       }
+       /* End, by mzj for smart_dial_sort*/
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/DialerDatabaseHelper.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/DialerDatabaseHelper.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/Dialer/src/com/android/dialer/database/DialerDatabaseHelper.java	(revision 4299)
@@ -0,0 +1,1225 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.database;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteStatement;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.provider.BaseColumns;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.Contacts;
+import android.provider.ContactsContract.Data;
+import android.provider.ContactsContract.Directory;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.contacts.common.util.PermissionsUtil;
+import com.android.contacts.common.util.StopWatch;
+import com.android.dialer.database.FilteredNumberContract.FilteredNumberColumns;
+import com.android.dialer.database.VoicemailArchiveContract.VoicemailArchive;
+import com.android.dialer.R;
+import com.android.dialer.dialpad.SmartDialNameMatcher;
+import com.android.dialer.dialpad.SmartDialPrefix;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import android.provider.Settings;
+
+import java.util.Locale;
+/**
+ * Database helper for smart dial. Designed as a singleton to make sure there is
+ * only one access point to the database. Provides methods to maintain, update,
+ * and query the database.
+ */
+public class DialerDatabaseHelper extends SQLiteOpenHelper {
+    private static final String TAG = "DialerDatabaseHelper";
+    private static final boolean DEBUG = false;
+    private boolean mIsTestInstance = false;
+
+    private static DialerDatabaseHelper sSingleton = null;
+
+    private static final Object mLock = new Object();
+    private static final AtomicBoolean sInUpdate = new AtomicBoolean(false);
+    private final Context mContext;
+	
+	/*Begin, by mzj for smart_dial_sort*/
+    private int mSmartDialSortOrder = -1;
+    private final static int SORT_IN_RUSSIAN = 1;
+    private final static int SORT_IN_ENGLISH = 2;
+    private final static String SMART_DIAL_SORT_ORDER = "smart_dial_sort_order";
+    /*End, by mzj for smart_dial_sort*/
+
+    /**
+     * SmartDial DB version ranges:
+     * <pre>
+     *   0-98   KitKat
+     * </pre>
+     */
+    public static final int DATABASE_VERSION = 10;
+    public static final String DATABASE_NAME = "dialer.db";
+
+    /**
+     * Saves the last update time of smart dial databases to shared preferences.
+     */
+    private static final String DATABASE_LAST_CREATED_SHARED_PREF = "com.android.dialer";
+    private static final String LAST_UPDATED_MILLIS = "last_updated_millis";
+    private static final String DATABASE_VERSION_PROPERTY = "database_version";
+
+    private static final int MAX_ENTRIES = 20;
+
+    public interface Tables {
+        /** Saves a list of numbers to be blocked.*/
+        static final String FILTERED_NUMBER_TABLE = "filtered_numbers_table";
+        /** Saves the necessary smart dial information of all contacts. */
+        static final String SMARTDIAL_TABLE = "smartdial_table";
+        /** Saves all possible prefixes to refer to a contacts.*/
+        static final String PREFIX_TABLE = "prefix_table";
+        /** Saves all archived voicemail information. */
+        static final String VOICEMAIL_ARCHIVE_TABLE = "voicemail_archive_table";
+        /** Database properties for internal use */
+        static final String PROPERTIES = "properties";
+    }
+
+    public static final Uri SMART_DIAL_UPDATED_URI =
+            Uri.parse("content://com.android.dialer/smart_dial_updated");
+
+    public interface SmartDialDbColumns {
+        static final String _ID = "id";
+        static final String DATA_ID = "data_id";
+        static final String NUMBER = "phone_number";
+        static final String CONTACT_ID = "contact_id";
+        static final String LOOKUP_KEY = "lookup_key";
+        static final String DISPLAY_NAME_PRIMARY = "display_name";
+        static final String PHOTO_ID = "photo_id";
+        static final String LAST_TIME_USED = "last_time_used";
+        static final String TIMES_USED = "times_used";
+        static final String STARRED = "starred";
+        static final String IS_SUPER_PRIMARY = "is_super_primary";
+        static final String IN_VISIBLE_GROUP = "in_visible_group";
+        static final String IS_PRIMARY = "is_primary";
+        static final String CARRIER_PRESENCE = "carrier_presence";
+        static final String LAST_SMARTDIAL_UPDATE_TIME = "last_smartdial_update_time";
+		static final String LAUNGAGE = "laungage";//add, by mzj for smart_dial_sort_order
+    }
+
+    public static interface PrefixColumns extends BaseColumns {
+        static final String PREFIX = "prefix";
+        static final String CONTACT_ID = "contact_id";
+    }
+
+    public interface PropertiesColumns {
+        String PROPERTY_KEY = "property_key";
+        String PROPERTY_VALUE = "property_value";
+    }
+
+    /** Query options for querying the contact database.*/
+    public static interface PhoneQuery {
+       static final Uri URI = Phone.CONTENT_URI.buildUpon().
+               appendQueryParameter(ContactsContract.DIRECTORY_PARAM_KEY,
+                       String.valueOf(Directory.DEFAULT)).
+               appendQueryParameter(ContactsContract.REMOVE_DUPLICATE_ENTRIES, "true").
+               build();
+
+       static final String[] PROJECTION = new String[] {
+            Phone._ID,                          // 0
+            Phone.TYPE,                         // 1
+            Phone.LABEL,                        // 2
+            Phone.NUMBER,                       // 3
+            Phone.CONTACT_ID,                   // 4
+            Phone.LOOKUP_KEY,                   // 5
+            Phone.DISPLAY_NAME_PRIMARY,         // 6
+            Phone.PHOTO_ID,                     // 7
+            Data.LAST_TIME_USED,                // 8
+            Data.TIMES_USED,                    // 9
+            Contacts.STARRED,                   // 10
+            Data.IS_SUPER_PRIMARY,              // 11
+            Contacts.IN_VISIBLE_GROUP,          // 12
+            Data.IS_PRIMARY,                    // 13
+            Data.CARRIER_PRESENCE,              // 14
+        };
+
+        static final int PHONE_ID = 0;
+        static final int PHONE_TYPE = 1;
+        static final int PHONE_LABEL = 2;
+        static final int PHONE_NUMBER = 3;
+        static final int PHONE_CONTACT_ID = 4;
+        static final int PHONE_LOOKUP_KEY = 5;
+        static final int PHONE_DISPLAY_NAME = 6;
+        static final int PHONE_PHOTO_ID = 7;
+        static final int PHONE_LAST_TIME_USED = 8;
+        static final int PHONE_TIMES_USED = 9;
+        static final int PHONE_STARRED = 10;
+        static final int PHONE_IS_SUPER_PRIMARY = 11;
+        static final int PHONE_IN_VISIBLE_GROUP = 12;
+        static final int PHONE_IS_PRIMARY = 13;
+        static final int PHONE_CARRIER_PRESENCE = 14;
+		
+		static final int PHONE_IS_LAUNGAGE = 15;//add by mzj for smart_dial_sort_order
+
+        /** Selects only rows that have been updated after a certain time stamp.*/
+        static final String SELECT_UPDATED_CLAUSE =
+                Phone.CONTACT_LAST_UPDATED_TIMESTAMP + " > ?";
+
+        /** Ignores contacts that have an unreasonably long lookup key. These are likely to be
+         * the result of multiple (> 50) merged raw contacts, and are likely to cause
+         * OutOfMemoryExceptions within SQLite, or cause memory allocation problems later on
+         * when iterating through the cursor set (see b/13133579)
+         */
+        static final String SELECT_IGNORE_LOOKUP_KEY_TOO_LONG_CLAUSE =
+                "length(" + Phone.LOOKUP_KEY + ") < 1000";
+
+        static final String SELECTION = SELECT_UPDATED_CLAUSE + " AND " +
+                SELECT_IGNORE_LOOKUP_KEY_TOO_LONG_CLAUSE;
+    }
+
+    /**
+     * Query for all contacts that have been updated since the last time the smart dial database
+     * was updated.
+     */
+    public static interface UpdatedContactQuery {
+        static final Uri URI = ContactsContract.Contacts.CONTENT_URI;
+
+        static final String[] PROJECTION = new String[] {
+                ContactsContract.Contacts._ID  // 0
+        };
+
+        static final int UPDATED_CONTACT_ID = 0;
+
+        static final String SELECT_UPDATED_CLAUSE =
+                ContactsContract.Contacts.CONTACT_LAST_UPDATED_TIMESTAMP + " > ?";
+    }
+
+    /** Query options for querying the deleted contact database.*/
+    public static interface DeleteContactQuery {
+       static final Uri URI = ContactsContract.DeletedContacts.CONTENT_URI;
+
+       static final String[] PROJECTION = new String[] {
+            ContactsContract.DeletedContacts.CONTACT_ID,                          // 0
+            ContactsContract.DeletedContacts.CONTACT_DELETED_TIMESTAMP,           // 1
+        };
+
+        static final int DELETED_CONTACT_ID = 0;
+        static final int DELECTED_TIMESTAMP = 1;
+
+        /** Selects only rows that have been deleted after a certain time stamp.*/
+        public static final String SELECT_UPDATED_CLAUSE =
+                ContactsContract.DeletedContacts.CONTACT_DELETED_TIMESTAMP + " > ?";
+    }
+
+    /**
+     * Gets the sorting order for the smartdial table. This computes a SQL "ORDER BY" argument by
+     * composing contact status and recent contact details together.
+     */
+    private static interface SmartDialSortingOrder {
+        /** Current contacts - those contacted within the last 3 days (in milliseconds) */
+        static final long LAST_TIME_USED_CURRENT_MS = 3L * 24 * 60 * 60 * 1000;
+        /** Recent contacts - those contacted within the last 30 days (in milliseconds) */
+        static final long LAST_TIME_USED_RECENT_MS = 30L * 24 * 60 * 60 * 1000;
+
+        /** Time since last contact. */
+        static final String TIME_SINCE_LAST_USED_MS = "( ?1 - " +
+                Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.LAST_TIME_USED + ")";
+
+        /** Contacts that have been used in the past 3 days rank higher than contacts that have
+         * been used in the past 30 days, which rank higher than contacts that have not been used
+         * in recent 30 days.
+         */
+        static final String SORT_BY_DATA_USAGE =
+                "(CASE WHEN " + TIME_SINCE_LAST_USED_MS + " < " + LAST_TIME_USED_CURRENT_MS +
+                " THEN 0 " +
+                " WHEN " + TIME_SINCE_LAST_USED_MS + " < " + LAST_TIME_USED_RECENT_MS +
+                " THEN 1 " +
+                " ELSE 2 END)";
+
+        /** This sort order is similar to that used by the ContactsProvider when returning a list
+         * of frequently called contacts.
+         */
+        static final String SORT_ORDER =
+				Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.LAUNGAGE + " DESC, "
+				+ Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.STARRED + " DESC, "
+				+ Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IS_SUPER_PRIMARY + " DESC, "
+				+ SORT_BY_DATA_USAGE + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.TIMES_USED + " DESC, "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IN_VISIBLE_GROUP + " DESC, "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.CONTACT_ID + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IS_PRIMARY + " DESC";
+
+        static final String SORT_ORDER_ASC =
+				Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.LAUNGAGE + " ASC, "
+				+ Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.STARRED + " DESC, "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IS_SUPER_PRIMARY + " DESC, "
+                + SORT_BY_DATA_USAGE + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.TIMES_USED + " DESC, "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IN_VISIBLE_GROUP + " DESC, "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.CONTACT_ID + ", "
+                + Tables.SMARTDIAL_TABLE + "." + SmartDialDbColumns.IS_PRIMARY + " DESC";
+    }
+
+    /**
+     * Simple data format for a contact, containing only information needed for showing up in
+     * smart dial interface.
+     */
+    public static class ContactNumber {
+        public final long id;
+        public final long dataId;
+        public final String displayName;
+        public final String phoneNumber;
+        public final String lookupKey;
+        public final long photoId;
+        public final int carrierPresence;
+
+        public ContactNumber(long id, long dataID, String displayName, String phoneNumber,
+                String lookupKey, long photoId, int carrierPresence) {
+            this.dataId = dataID;
+            this.id = id;
+            this.displayName = displayName;
+            this.phoneNumber = phoneNumber;
+            this.lookupKey = lookupKey;
+            this.photoId = photoId;
+            this.carrierPresence = carrierPresence;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hashCode(id, dataId, displayName, phoneNumber, lookupKey, photoId,
+                    carrierPresence);
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object instanceof ContactNumber) {
+                final ContactNumber that = (ContactNumber) object;
+                return Objects.equal(this.id, that.id)
+                        && Objects.equal(this.dataId, that.dataId)
+                        && Objects.equal(this.displayName, that.displayName)
+                        && Objects.equal(this.phoneNumber, that.phoneNumber)
+                        && Objects.equal(this.lookupKey, that.lookupKey)
+                        && Objects.equal(this.photoId, that.photoId)
+                        && Objects.equal(this.carrierPresence, that.carrierPresence);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Data format for finding duplicated contacts.
+     */
+    private class ContactMatch {
+        private final String lookupKey;
+        private final long id;
+
+        public ContactMatch(String lookupKey, long id) {
+            this.lookupKey = lookupKey;
+            this.id = id;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hashCode(lookupKey, id);
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object instanceof ContactMatch) {
+                final ContactMatch that = (ContactMatch) object;
+                return Objects.equal(this.lookupKey, that.lookupKey)
+                        && Objects.equal(this.id, that.id);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Access function to get the singleton instance of DialerDatabaseHelper.
+     */
+    public static synchronized DialerDatabaseHelper getInstance(Context context) {
+        if (DEBUG) {
+            Log.v(TAG, "Getting Instance");
+        }
+        if (sSingleton == null) {
+            // Use application context instead of activity context because this is a singleton,
+            // and we don't want to leak the activity if the activity is not running but the
+            // dialer database helper is still doing work.
+            sSingleton = new DialerDatabaseHelper(context.getApplicationContext(),
+                    DATABASE_NAME);
+        }
+        return sSingleton;
+    }
+
+    /**
+     * Returns a new instance for unit tests. The database will be created in memory.
+     */
+    @VisibleForTesting
+    static DialerDatabaseHelper getNewInstanceForTest(Context context) {
+        return new DialerDatabaseHelper(context, null, true);
+    }
+
+    protected DialerDatabaseHelper(Context context, String databaseName, boolean isTestInstance) {
+        this(context, databaseName, DATABASE_VERSION);
+        mIsTestInstance = isTestInstance;
+    }
+
+    protected DialerDatabaseHelper(Context context, String databaseName) {
+        this(context, databaseName, DATABASE_VERSION);
+    }
+
+    protected DialerDatabaseHelper(Context context, String databaseName, int dbVersion) {
+        super(context, databaseName, null, dbVersion);
+        mContext = Preconditions.checkNotNull(context, "Context must not be null");
+    }
+
+    /**
+     * Creates tables in the database when database is created for the first time.
+     *
+     * @param db The database.
+     */
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        setupTables(db);
+    }
+
+    private void setupTables(SQLiteDatabase db) {
+        dropTables(db);
+        db.execSQL("CREATE TABLE " + Tables.SMARTDIAL_TABLE + " ("
+                + SmartDialDbColumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + SmartDialDbColumns.DATA_ID + " INTEGER, "
+                + SmartDialDbColumns.NUMBER + " TEXT,"
+                + SmartDialDbColumns.CONTACT_ID + " INTEGER,"
+                + SmartDialDbColumns.LOOKUP_KEY + " TEXT,"
+                + SmartDialDbColumns.DISPLAY_NAME_PRIMARY + " TEXT, "
+                + SmartDialDbColumns.PHOTO_ID + " INTEGER, "
+                + SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME + " LONG, "
+				+ SmartDialDbColumns.LAUNGAGE + " TEXT, "
+                + SmartDialDbColumns.LAST_TIME_USED + " LONG, "
+                + SmartDialDbColumns.TIMES_USED + " INTEGER, "
+                + SmartDialDbColumns.STARRED + " INTEGER, "
+                + SmartDialDbColumns.IS_SUPER_PRIMARY + " INTEGER, "
+                + SmartDialDbColumns.IN_VISIBLE_GROUP + " INTEGER, "
+                + SmartDialDbColumns.IS_PRIMARY + " INTEGER, "
+                + SmartDialDbColumns.CARRIER_PRESENCE + " INTEGER NOT NULL DEFAULT 0"
+                + ");");
+
+        db.execSQL("CREATE TABLE " + Tables.PREFIX_TABLE + " ("
+                + PrefixColumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + PrefixColumns.PREFIX + " TEXT COLLATE NOCASE, "
+                + PrefixColumns.CONTACT_ID + " INTEGER"
+                + ");");
+
+        db.execSQL("CREATE TABLE " + Tables.PROPERTIES + " ("
+                + PropertiesColumns.PROPERTY_KEY + " TEXT PRIMARY KEY, "
+                + PropertiesColumns.PROPERTY_VALUE + " TEXT "
+                + ");");
+
+        // This will need to also be updated in setupTablesForFilteredNumberTest and onUpgrade.
+        // Hardcoded so we know on glance what columns are updated in setupTables,
+        // and to be able to guarantee the state of the DB at each upgrade step.
+        db.execSQL("CREATE TABLE " + Tables.FILTERED_NUMBER_TABLE + " ("
+                + FilteredNumberColumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + FilteredNumberColumns.NORMALIZED_NUMBER + " TEXT UNIQUE,"
+                + FilteredNumberColumns.NUMBER + " TEXT,"
+                + FilteredNumberColumns.COUNTRY_ISO + " TEXT,"
+                + FilteredNumberColumns.TIMES_FILTERED + " INTEGER,"
+                + FilteredNumberColumns.LAST_TIME_FILTERED + " LONG,"
+                + FilteredNumberColumns.CREATION_TIME + " LONG,"
+                + FilteredNumberColumns.TYPE + " INTEGER,"
+                + FilteredNumberColumns.SOURCE + " INTEGER"
+                + ");");
+
+        createVoicemailArchiveTable(db);
+        setProperty(db, DATABASE_VERSION_PROPERTY, String.valueOf(DATABASE_VERSION));
+        if (!mIsTestInstance) {
+            resetSmartDialLastUpdatedTime();
+        }
+    }
+
+    public void dropTables(SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.PREFIX_TABLE);
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.SMARTDIAL_TABLE);
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.PROPERTIES);
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.FILTERED_NUMBER_TABLE);
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.VOICEMAIL_ARCHIVE_TABLE);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldNumber, int newNumber) {
+        // Disregard the old version and new versions provided by SQLiteOpenHelper, we will read
+        // our own from the database.
+
+        int oldVersion;
+
+        oldVersion = getPropertyAsInt(db, DATABASE_VERSION_PROPERTY, 0);
+
+        if (oldVersion == 0) {
+            Log.e(TAG, "Malformed database version..recreating database");
+        }
+
+        if (oldVersion < 4) {
+            setupTables(db);
+            return;
+        }
+
+        if (oldVersion < 7) {
+            db.execSQL("DROP TABLE IF EXISTS " + Tables.FILTERED_NUMBER_TABLE);
+            db.execSQL("CREATE TABLE " + Tables.FILTERED_NUMBER_TABLE + " ("
+                    + FilteredNumberColumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                    + FilteredNumberColumns.NORMALIZED_NUMBER + " TEXT UNIQUE,"
+                    + FilteredNumberColumns.NUMBER + " TEXT,"
+                    + FilteredNumberColumns.COUNTRY_ISO + " TEXT,"
+                    + FilteredNumberColumns.TIMES_FILTERED + " INTEGER,"
+                    + FilteredNumberColumns.LAST_TIME_FILTERED + " LONG,"
+                    + FilteredNumberColumns.CREATION_TIME + " LONG,"
+                    + FilteredNumberColumns.TYPE + " INTEGER,"
+                    + FilteredNumberColumns.SOURCE + " INTEGER"
+                    + ");");
+            oldVersion = 7;
+        }
+
+        if (oldVersion < 8) {
+            upgradeToVersion8(db);
+            oldVersion = 8;
+        }
+
+        if (oldVersion < 9) {
+            db.execSQL("DROP TABLE IF EXISTS " + Tables.VOICEMAIL_ARCHIVE_TABLE);
+            createVoicemailArchiveTable(db);
+            oldVersion = 9;
+        }
+
+        if (oldVersion != DATABASE_VERSION) {
+            throw new IllegalStateException(
+                    "error upgrading the database to version " + DATABASE_VERSION);
+        }
+
+        setProperty(db, DATABASE_VERSION_PROPERTY, String.valueOf(DATABASE_VERSION));
+    }
+
+    public void upgradeToVersion8(SQLiteDatabase db) {
+        db.execSQL("ALTER TABLE smartdial_table ADD carrier_presence INTEGER NOT NULL DEFAULT 0");
+    }
+
+    /**
+     * Stores a key-value pair in the {@link Tables#PROPERTIES} table.
+     */
+    public void setProperty(String key, String value) {
+        setProperty(getWritableDatabase(), key, value);
+    }
+
+    public void setProperty(SQLiteDatabase db, String key, String value) {
+        final ContentValues values = new ContentValues();
+        values.put(PropertiesColumns.PROPERTY_KEY, key);
+        values.put(PropertiesColumns.PROPERTY_VALUE, value);
+        db.replace(Tables.PROPERTIES, null, values);
+    }
+
+    /**
+     * Returns the value from the {@link Tables#PROPERTIES} table.
+     */
+    public String getProperty(String key, String defaultValue) {
+        return getProperty(getReadableDatabase(), key, defaultValue);
+    }
+
+    public String getProperty(SQLiteDatabase db, String key, String defaultValue) {
+        try {
+            String value = null;
+            final Cursor cursor = db.query(Tables.PROPERTIES,
+                    new String[] {PropertiesColumns.PROPERTY_VALUE},
+                            PropertiesColumns.PROPERTY_KEY + "=?",
+                    new String[] {key}, null, null, null);
+            if (cursor != null) {
+                try {
+                    if (cursor.moveToFirst()) {
+                        value = cursor.getString(0);
+                    }
+                } finally {
+                    cursor.close();
+                }
+            }
+            return value != null ? value : defaultValue;
+        } catch (SQLiteException e) {
+            return defaultValue;
+        }
+    }
+
+    public int getPropertyAsInt(SQLiteDatabase db, String key, int defaultValue) {
+        final String stored = getProperty(db, key, "");
+        try {
+            return Integer.parseInt(stored);
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
+    }
+
+    private void resetSmartDialLastUpdatedTime() {
+        final SharedPreferences databaseLastUpdateSharedPref = mContext.getSharedPreferences(
+                DATABASE_LAST_CREATED_SHARED_PREF, Context.MODE_PRIVATE);
+        final SharedPreferences.Editor editor = databaseLastUpdateSharedPref.edit();
+        editor.putLong(LAST_UPDATED_MILLIS, 0);
+        editor.commit();
+    }
+
+    /**
+     * Starts the database upgrade process in the background.
+     */
+    public void startSmartDialUpdateThread() {
+        if (PermissionsUtil.hasContactsPermissions(mContext)) {
+            new SmartDialUpdateAsyncTask().execute();
+        }
+    }
+
+    private class SmartDialUpdateAsyncTask extends AsyncTask {
+        @Override
+        protected Object doInBackground(Object[] objects) {
+            if (DEBUG) {
+                Log.v(TAG, "Updating database");
+            }
+            updateSmartDialDatabase();
+            return null;
+        }
+
+        @Override
+        protected void onCancelled() {
+            if (DEBUG) {
+                Log.v(TAG, "Updating Cancelled");
+            }
+            super.onCancelled();
+        }
+
+        @Override
+        protected void onPostExecute(Object o) {
+            if (DEBUG) {
+                Log.v(TAG, "Updating Finished");
+            }
+            super.onPostExecute(o);
+        }
+    }
+    /**
+     * Removes rows in the smartdial database that matches the contacts that have been deleted
+     * by other apps since last update.
+     *
+     * @param db Database to operate on.
+     * @param deletedContactCursor Cursor containing rows of deleted contacts
+     */
+    @VisibleForTesting
+    void removeDeletedContacts(SQLiteDatabase db, Cursor deletedContactCursor) {
+        if (deletedContactCursor == null) {
+            return;
+        }
+
+        db.beginTransaction();
+        try {
+            while (deletedContactCursor.moveToNext()) {
+                final Long deleteContactId =
+                        deletedContactCursor.getLong(DeleteContactQuery.DELETED_CONTACT_ID);
+                db.delete(Tables.SMARTDIAL_TABLE,
+                        SmartDialDbColumns.CONTACT_ID + "=" + deleteContactId, null);
+                db.delete(Tables.PREFIX_TABLE,
+                        PrefixColumns.CONTACT_ID + "=" + deleteContactId, null);
+            }
+
+            db.setTransactionSuccessful();
+        } finally {
+            deletedContactCursor.close();
+            db.endTransaction();
+        }
+    }
+
+    private Cursor getDeletedContactCursor(String lastUpdateMillis) {
+        return mContext.getContentResolver().query(
+                DeleteContactQuery.URI,
+                DeleteContactQuery.PROJECTION,
+                DeleteContactQuery.SELECT_UPDATED_CLAUSE,
+                new String[] {lastUpdateMillis},
+                null);
+    }
+
+    /**
+     * Removes potentially corrupted entries in the database. These contacts may be added before
+     * the previous instance of the dialer was destroyed for some reason. For data integrity, we
+     * delete all of them.
+
+     * @param db Database pointer to the dialer database.
+     * @param last_update_time Time stamp of last successful update of the dialer database.
+     */
+    private void removePotentiallyCorruptedContacts(SQLiteDatabase db, String last_update_time) {
+        db.delete(Tables.PREFIX_TABLE,
+                PrefixColumns.CONTACT_ID + " IN " +
+                "(SELECT " + SmartDialDbColumns.CONTACT_ID + " FROM " + Tables.SMARTDIAL_TABLE +
+                " WHERE " + SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME + " > " +
+                last_update_time + ")",
+                null);
+        db.delete(Tables.SMARTDIAL_TABLE,
+                SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME + " > " + last_update_time, null);
+    }
+
+    /**
+     * All columns excluding MIME_TYPE, _DATA, ARCHIVED, SERVER_ID, are the same as
+     *  the columns in the {@link android.provider.CallLog.Calls} table.
+     *
+     *  @param db Database pointer to the dialer database.
+     */
+    private void createVoicemailArchiveTable(SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE " + Tables.VOICEMAIL_ARCHIVE_TABLE + " ("
+                + VoicemailArchive._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + VoicemailArchive.NUMBER + " TEXT,"
+                + VoicemailArchive.DATE + " LONG,"
+                + VoicemailArchive.DURATION + " LONG,"
+                + VoicemailArchive.MIME_TYPE + " TEXT,"
+                + VoicemailArchive.COUNTRY_ISO + " TEXT,"
+                + VoicemailArchive._DATA + " TEXT,"
+                + VoicemailArchive.GEOCODED_LOCATION + " TEXT,"
+                + VoicemailArchive.CACHED_NAME + " TEXT,"
+                + VoicemailArchive.CACHED_NUMBER_TYPE + " INTEGER,"
+                + VoicemailArchive.CACHED_NUMBER_LABEL + " TEXT,"
+                + VoicemailArchive.CACHED_LOOKUP_URI + " TEXT,"
+                + VoicemailArchive.CACHED_MATCHED_NUMBER + " TEXT,"
+                + VoicemailArchive.CACHED_NORMALIZED_NUMBER + " TEXT,"
+                + VoicemailArchive.CACHED_PHOTO_ID + " LONG,"
+                + VoicemailArchive.CACHED_FORMATTED_NUMBER + " TEXT,"
+                + VoicemailArchive.ARCHIVED + " INTEGER,"
+                + VoicemailArchive.NUMBER_PRESENTATION + " INTEGER,"
+                + VoicemailArchive.ACCOUNT_COMPONENT_NAME + " TEXT,"
+                + VoicemailArchive.ACCOUNT_ID + " TEXT,"
+                + VoicemailArchive.FEATURES + " INTEGER,"
+                + VoicemailArchive.SERVER_ID + " INTEGER,"
+                + VoicemailArchive.TRANSCRIPTION + " TEXT,"
+                + VoicemailArchive.CACHED_PHOTO_URI + " TEXT"
+                + ");");
+    }
+
+    /**
+     * Removes all entries in the smartdial contact database.
+     */
+    @VisibleForTesting
+    void removeAllContacts(SQLiteDatabase db) {
+        db.delete(Tables.SMARTDIAL_TABLE, null, null);
+        db.delete(Tables.PREFIX_TABLE, null, null);
+    }
+
+    /**
+     * Counts number of rows of the prefix table.
+     */
+    @VisibleForTesting
+    int countPrefixTableRows(SQLiteDatabase db) {
+        return (int)DatabaseUtils.longForQuery(db, "SELECT COUNT(1) FROM " + Tables.PREFIX_TABLE,
+                null);
+    }
+
+    /**
+     * Removes rows in the smartdial database that matches updated contacts.
+     *
+     * @param db Database pointer to the smartdial database
+     * @param updatedContactCursor Cursor pointing to the list of recently updated contacts.
+     */
+    @VisibleForTesting
+    void removeUpdatedContacts(SQLiteDatabase db, Cursor updatedContactCursor) {
+        db.beginTransaction();
+        try {
+            updatedContactCursor.moveToPosition(-1);
+            while (updatedContactCursor.moveToNext()) {
+                final Long contactId =
+                        updatedContactCursor.getLong(UpdatedContactQuery.UPDATED_CONTACT_ID);
+
+                db.delete(Tables.SMARTDIAL_TABLE, SmartDialDbColumns.CONTACT_ID + "=" +
+                        contactId, null);
+                db.delete(Tables.PREFIX_TABLE, PrefixColumns.CONTACT_ID + "=" +
+                        contactId, null);
+            }
+
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Inserts updated contacts as rows to the smartdial table.
+     *
+     * @param db Database pointer to the smartdial database.
+     * @param updatedContactCursor Cursor pointing to the list of recently updated contacts.
+     * @param currentMillis Current time to be recorded in the smartdial table as update timestamp.
+     */
+    @VisibleForTesting
+    protected void insertUpdatedContactsAndNumberPrefix(SQLiteDatabase db,
+            Cursor updatedContactCursor, Long currentMillis) {
+        db.beginTransaction();
+        try {
+            final String sqlInsert = "INSERT INTO " + Tables.SMARTDIAL_TABLE + " (" +
+                    SmartDialDbColumns.DATA_ID + ", " +
+                    SmartDialDbColumns.NUMBER + ", " +
+                    SmartDialDbColumns.CONTACT_ID + ", " +
+                    SmartDialDbColumns.LOOKUP_KEY + ", " +
+                    SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", " +
+                    SmartDialDbColumns.PHOTO_ID + ", " +
+                    SmartDialDbColumns.LAST_TIME_USED + ", " +
+                    SmartDialDbColumns.TIMES_USED + ", " +
+                    SmartDialDbColumns.STARRED + ", " +
+                    SmartDialDbColumns.IS_SUPER_PRIMARY + ", " +
+                    SmartDialDbColumns.IN_VISIBLE_GROUP+ ", " +
+                    SmartDialDbColumns.IS_PRIMARY + ", " +
+                    SmartDialDbColumns.CARRIER_PRESENCE + ", " +
+                    SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME +", "+
+                    SmartDialDbColumns.LAUNGAGE + ") " +
+                    " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
+            final SQLiteStatement insert = db.compileStatement(sqlInsert);
+
+            final String numberSqlInsert = "INSERT INTO " + Tables.PREFIX_TABLE + " (" +
+                    PrefixColumns.CONTACT_ID + ", " +
+                    PrefixColumns.PREFIX  + ") " +
+                    " VALUES (?, ?)";
+            final SQLiteStatement numberInsert = db.compileStatement(numberSqlInsert);
+
+            updatedContactCursor.moveToPosition(-1);
+            while (updatedContactCursor.moveToNext()) {
+                insert.clearBindings();
+
+                // Handle string columns which can possibly be null first. In the case of certain
+                // null columns (due to malformed rows possibly inserted by third-party apps
+                // or sync adapters), skip the phone number row.
+                final String number = updatedContactCursor.getString(PhoneQuery.PHONE_NUMBER);
+                if (TextUtils.isEmpty(number)) {
+                    continue;
+                } else {
+                    insert.bindString(2, number);
+                }
+
+                final String lookupKey = updatedContactCursor.getString(
+                        PhoneQuery.PHONE_LOOKUP_KEY);
+                if (TextUtils.isEmpty(lookupKey)) {
+                    continue;
+                } else {
+                    insert.bindString(4, lookupKey);
+                }
+
+                final String displayName = updatedContactCursor.getString(
+                        PhoneQuery.PHONE_DISPLAY_NAME);
+				
+				//add by mzj for smart_dial_sort_order begin
+                final String mlang = Locale.getDefault().getLanguage();
+				//add by mzj for smart_dial_sort_order end
+				
+                if (displayName == null) {
+                    insert.bindString(5, mContext.getResources().getString(R.string.missing_name));
+					insert.bindString(14, mlang);
+                } else {
+                    insert.bindString(5, displayName);
+				//add by mzj for smart_dial_sort_order begin
+					int length = displayName.length();
+                    char ch;
+                    for (int i = 0; i < length; i++) {
+                        ch = displayName.charAt(i);
+                        if((ch >= 'А' && ch <= 'Я') || (ch >= 'а' && ch <= 'я')){
+                            insert.bindString(14, "ru");
+                            break;
+                        }else if((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')){
+                            insert.bindString(14, "en");
+                            break;
+                        }else{
+                            insert.bindString(14, mlang);
+                        }
+                    }
+                }
+				//add by mzj for smart_dial_sort_order end
+                insert.bindLong(1, updatedContactCursor.getLong(PhoneQuery.PHONE_ID));
+                insert.bindLong(3, updatedContactCursor.getLong(PhoneQuery.PHONE_CONTACT_ID));
+                insert.bindLong(6, updatedContactCursor.getLong(PhoneQuery.PHONE_PHOTO_ID));
+                insert.bindLong(7, updatedContactCursor.getLong(PhoneQuery.PHONE_LAST_TIME_USED));
+                insert.bindLong(8, updatedContactCursor.getInt(PhoneQuery.PHONE_TIMES_USED));
+                insert.bindLong(9, updatedContactCursor.getInt(PhoneQuery.PHONE_STARRED));
+                insert.bindLong(10, updatedContactCursor.getInt(PhoneQuery.PHONE_IS_SUPER_PRIMARY));
+                insert.bindLong(11, updatedContactCursor.getInt(PhoneQuery.PHONE_IN_VISIBLE_GROUP));
+                insert.bindLong(12, updatedContactCursor.getInt(PhoneQuery.PHONE_IS_PRIMARY));
+                insert.bindLong(13, updatedContactCursor.getInt(PhoneQuery.PHONE_CARRIER_PRESENCE));
+                insert.bindLong(14, currentMillis);
+                insert.executeInsert();
+                final String contactPhoneNumber =
+                        updatedContactCursor.getString(PhoneQuery.PHONE_NUMBER);
+                final ArrayList<String> numberPrefixes =
+                        SmartDialPrefix.parseToNumberTokens(contactPhoneNumber);
+
+                for (String numberPrefix : numberPrefixes) {
+                    numberInsert.bindLong(1, updatedContactCursor.getLong(
+                            PhoneQuery.PHONE_CONTACT_ID));
+                    numberInsert.bindString(2, numberPrefix);
+                    numberInsert.executeInsert();
+                    numberInsert.clearBindings();
+                }
+            }
+
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Inserts prefixes of contact names to the prefix table.
+     *
+     * @param db Database pointer to the smartdial database.
+     * @param nameCursor Cursor pointing to the list of distinct updated contacts.
+     */
+    @VisibleForTesting
+    void insertNamePrefixes(SQLiteDatabase db, Cursor nameCursor) {
+        final int columnIndexName = nameCursor.getColumnIndex(
+                SmartDialDbColumns.DISPLAY_NAME_PRIMARY);
+        final int columnIndexContactId = nameCursor.getColumnIndex(SmartDialDbColumns.CONTACT_ID);
+
+        db.beginTransaction();
+        try {
+            final String sqlInsert = "INSERT INTO " + Tables.PREFIX_TABLE + " (" +
+                    PrefixColumns.CONTACT_ID + ", " +
+                    PrefixColumns.PREFIX  + ") " +
+                    " VALUES (?, ?)";
+            final SQLiteStatement insert = db.compileStatement(sqlInsert);
+
+            while (nameCursor.moveToNext()) {
+                /** Computes a list of prefixes of a given contact name. */
+                final ArrayList<String> namePrefixes =
+                        SmartDialPrefix.generateNamePrefixes(nameCursor.getString(columnIndexName));
+
+                for (String namePrefix : namePrefixes) {
+                    insert.bindLong(1, nameCursor.getLong(columnIndexContactId));
+                    insert.bindString(2, namePrefix);
+                    insert.executeInsert();
+                    insert.clearBindings();
+                }
+            }
+
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Updates the smart dial and prefix database.
+     * This method queries the Delta API to get changed contacts since last update, and updates the
+     * records in smartdial database and prefix database accordingly.
+     * It also queries the deleted contact database to remove newly deleted contacts since last
+     * update.
+     */
+    public void updateSmartDialDatabase() {
+        final SQLiteDatabase db = getWritableDatabase();
+
+        synchronized(mLock) {
+            if (DEBUG) {
+                Log.v(TAG, "Starting to update database");
+            }
+            final StopWatch stopWatch = DEBUG ? StopWatch.start("Updating databases") : null;
+
+            /** Gets the last update time on the database. */
+            final SharedPreferences databaseLastUpdateSharedPref = mContext.getSharedPreferences(
+                    DATABASE_LAST_CREATED_SHARED_PREF, Context.MODE_PRIVATE);
+            final String lastUpdateMillis = String.valueOf(
+                    databaseLastUpdateSharedPref.getLong(LAST_UPDATED_MILLIS, 0));
+
+            if (DEBUG) {
+                Log.v(TAG, "Last updated at " + lastUpdateMillis);
+            }
+
+            /** Sets the time after querying the database as the current update time. */
+            final Long currentMillis = System.currentTimeMillis();
+
+            if (DEBUG) {
+                stopWatch.lap("Queried the Contacts database");
+            }
+
+            /** Prevents the app from reading the dialer database when updating. */
+            sInUpdate.getAndSet(true);
+
+            /** Removes contacts that have been deleted. */
+            removeDeletedContacts(db, getDeletedContactCursor(lastUpdateMillis));
+            removePotentiallyCorruptedContacts(db, lastUpdateMillis);
+
+            if (DEBUG) {
+                stopWatch.lap("Finished deleting deleted entries");
+            }
+
+            /** If the database did not exist before, jump through deletion as there is nothing
+             * to delete.
+             */
+            if (!lastUpdateMillis.equals("0")) {
+                /** Removes contacts that have been updated. Updated contact information will be
+                 * inserted later. Note that this has to use a separate result set from
+                 * updatePhoneCursor, since it is possible for a contact to be updated (e.g.
+                 * phone number deleted), but have no results show up in updatedPhoneCursor (since
+                 * all of its phone numbers have been deleted).
+                 */
+                final Cursor updatedContactCursor = mContext.getContentResolver().query(
+                        UpdatedContactQuery.URI,
+                        UpdatedContactQuery.PROJECTION,
+                        UpdatedContactQuery.SELECT_UPDATED_CLAUSE,
+                        new String[] {lastUpdateMillis},
+                        null
+                        );
+                if (updatedContactCursor == null) {
+                    Log.e(TAG, "SmartDial query received null for cursor");
+                    return;
+                }
+                try {
+                    removeUpdatedContacts(db, updatedContactCursor);
+                } finally {
+                    updatedContactCursor.close();
+                }
+                if (DEBUG) {
+                    stopWatch.lap("Finished deleting entries belonging to updated contacts");
+                }
+            }
+
+            /** Queries the contact database to get all phone numbers that have been updated since the last
+             * update time.
+             */
+            final Cursor updatedPhoneCursor = mContext.getContentResolver().query(PhoneQuery.URI,
+                    PhoneQuery.PROJECTION, PhoneQuery.SELECTION,
+                    new String[]{lastUpdateMillis}, null);
+            if (updatedPhoneCursor == null) {
+                Log.e(TAG, "SmartDial query received null for cursor");
+                return;
+            }
+
+            try {
+                /** Inserts recently updated phone numbers to the smartdial database.*/
+                insertUpdatedContactsAndNumberPrefix(db, updatedPhoneCursor, currentMillis);
+                if (DEBUG) {
+                    stopWatch.lap("Finished building the smart dial table");
+                }
+            } finally {
+                updatedPhoneCursor.close();
+            }
+
+            /** Gets a list of distinct contacts which have been updated, and adds the name prefixes
+             * of these contacts to the prefix table.
+             */
+            final Cursor nameCursor = db.rawQuery(
+                    "SELECT DISTINCT " +
+                    SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", " + SmartDialDbColumns.CONTACT_ID +
+                    " FROM " + Tables.SMARTDIAL_TABLE +
+                    " WHERE " + SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME +
+                    " = " + Long.toString(currentMillis),
+                    new String[] {});
+            if (nameCursor != null) {
+                try {
+                    if (DEBUG) {
+                        stopWatch.lap("Queried the smart dial table for contact names");
+                    }
+
+                    /** Inserts prefixes of names into the prefix table.*/
+                    insertNamePrefixes(db, nameCursor);
+                    if (DEBUG) {
+                        stopWatch.lap("Finished building the name prefix table");
+                    }
+                } finally {
+                    nameCursor.close();
+                }
+            }
+
+            /** Creates index on contact_id for fast JOIN operation. */
+            db.execSQL("CREATE INDEX IF NOT EXISTS smartdial_contact_id_index ON " +
+                    Tables.SMARTDIAL_TABLE + " (" + SmartDialDbColumns.CONTACT_ID  + ");");
+            /** Creates index on last_smartdial_update_time for fast SELECT operation. */
+            db.execSQL("CREATE INDEX IF NOT EXISTS smartdial_last_update_index ON " +
+                    Tables.SMARTDIAL_TABLE + " (" +
+                    SmartDialDbColumns.LAST_SMARTDIAL_UPDATE_TIME + ");");
+            /** Creates index on sorting fields for fast sort operation. */
+            db.execSQL("CREATE INDEX IF NOT EXISTS smartdial_sort_index ON " +
+                    Tables.SMARTDIAL_TABLE + " (" +
+                    SmartDialDbColumns.STARRED + ", " +
+                    SmartDialDbColumns.IS_SUPER_PRIMARY + ", " +
+                    SmartDialDbColumns.LAST_TIME_USED + ", " +
+                    SmartDialDbColumns.TIMES_USED + ", " +
+                    SmartDialDbColumns.IN_VISIBLE_GROUP +  ", " +
+                    SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", " +
+                    SmartDialDbColumns.CONTACT_ID + ", " +
+                    SmartDialDbColumns.IS_PRIMARY +
+                    ");");
+            /** Creates index on prefix for fast SELECT operation. */
+            db.execSQL("CREATE INDEX IF NOT EXISTS nameprefix_index ON " +
+                    Tables.PREFIX_TABLE + " (" + PrefixColumns.PREFIX + ");");
+            /** Creates index on contact_id for fast JOIN operation. */
+            db.execSQL("CREATE INDEX IF NOT EXISTS nameprefix_contact_id_index ON " +
+                    Tables.PREFIX_TABLE + " (" + PrefixColumns.CONTACT_ID + ");");
+
+            if (DEBUG) {
+                stopWatch.lap(TAG + "Finished recreating index");
+            }
+
+            /** Updates the database index statistics.*/
+            db.execSQL("ANALYZE " + Tables.SMARTDIAL_TABLE);
+            db.execSQL("ANALYZE " + Tables.PREFIX_TABLE);
+            db.execSQL("ANALYZE smartdial_contact_id_index");
+            db.execSQL("ANALYZE smartdial_last_update_index");
+            db.execSQL("ANALYZE nameprefix_index");
+            db.execSQL("ANALYZE nameprefix_contact_id_index");
+            if (DEBUG) {
+                stopWatch.stopAndLog(TAG + "Finished updating index stats", 0);
+            }
+
+            sInUpdate.getAndSet(false);
+
+            final SharedPreferences.Editor editor = databaseLastUpdateSharedPref.edit();
+            editor.putLong(LAST_UPDATED_MILLIS, currentMillis);
+            editor.commit();
+
+            // Notify content observers that smart dial database has been updated.
+            mContext.getContentResolver().notifyChange(SMART_DIAL_UPDATED_URI, null, false);
+        }
+    }
+
+    /**
+     * Returns a list of candidate contacts where the query is a prefix of the dialpad index of
+     * the contact's name or phone number.
+     *
+     * @param query The prefix of a contact's dialpad index.
+     * @return A list of top candidate contacts that will be suggested to user to match their input.
+     */
+    public ArrayList<ContactNumber>  getLooseMatches(String query,
+            SmartDialNameMatcher nameMatcher) {
+        final boolean inUpdate = sInUpdate.get();
+        if (inUpdate) {
+            return Lists.newArrayList();
+        }
+
+        final SQLiteDatabase db = getReadableDatabase();
+
+        /** Uses SQL query wildcard '%' to represent prefix matching.*/
+        final String looseQuery = query + "%";
+
+        final ArrayList<ContactNumber> result = Lists.newArrayList();
+
+        final StopWatch stopWatch = DEBUG ? StopWatch.start(":Name Prefix query") : null;
+
+        final String currentTimeStamp = Long.toString(System.currentTimeMillis());
+		
+		/*Begin, by mzj for smart_dial_sort_order*/
+        String orderBy = SmartDialSortingOrder.SORT_ORDER ;
+        mSmartDialSortOrder = Settings.System.getInt(mContext.getContentResolver(), SMART_DIAL_SORT_ORDER,SORT_IN_RUSSIAN);
+        if(mSmartDialSortOrder == SORT_IN_ENGLISH){
+            orderBy = SmartDialSortingOrder.SORT_ORDER_ASC;
+        }
+        /*End, by mzj for smart_dial_sort_order*/
+
+        /** Queries the database to find contacts that have an index matching the query prefix. */
+        final Cursor cursor = db.rawQuery("SELECT " +
+                SmartDialDbColumns.DATA_ID + ", " +
+                SmartDialDbColumns.DISPLAY_NAME_PRIMARY + ", " +
+                SmartDialDbColumns.PHOTO_ID + ", " +
+                SmartDialDbColumns.NUMBER + ", " +
+                SmartDialDbColumns.CONTACT_ID + ", " +
+                SmartDialDbColumns.LOOKUP_KEY + ", " +
+                SmartDialDbColumns.CARRIER_PRESENCE +
+                " FROM " + Tables.SMARTDIAL_TABLE + " WHERE " +
+                SmartDialDbColumns.CONTACT_ID + " IN " +
+                    " (SELECT " + PrefixColumns.CONTACT_ID +
+                    " FROM " + Tables.PREFIX_TABLE +
+                    " WHERE " + Tables.PREFIX_TABLE + "." + PrefixColumns.PREFIX +
+                    " LIKE '" + looseQuery + "')" +
+                " ORDER BY " + orderBy,
+                new String[] {currentTimeStamp});
+        if (cursor == null) {
+            return result;
+        }
+        try {
+            if (DEBUG) {
+                stopWatch.lap("Prefix query completed");
+            }
+
+            /** Gets the column ID from the cursor.*/
+            final int columnDataId = 0;
+            final int columnDisplayNamePrimary = 1;
+            final int columnPhotoId = 2;
+            final int columnNumber = 3;
+            final int columnId = 4;
+            final int columnLookupKey = 5;
+            final int columnCarrierPresence = 6;
+            if (DEBUG) {
+                stopWatch.lap("Found column IDs");
+            }
+
+            final Set<ContactMatch> duplicates = new HashSet<ContactMatch>();
+            int counter = 0;
+            if (DEBUG) {
+                stopWatch.lap("Moved cursor to start");
+            }
+            /** Iterates the cursor to find top contact suggestions without duplication.*/
+            while ((cursor.moveToNext()) && (counter < MAX_ENTRIES)) {
+                final long dataID = cursor.getLong(columnDataId);
+                final String displayName = cursor.getString(columnDisplayNamePrimary);
+                final String phoneNumber = cursor.getString(columnNumber);
+                final long id = cursor.getLong(columnId);
+                final long photoId = cursor.getLong(columnPhotoId);
+                final String lookupKey = cursor.getString(columnLookupKey);
+                final int carrierPresence = cursor.getInt(columnCarrierPresence);
+
+                /** If a contact already exists and another phone number of the contact is being
+                 * processed, skip the second instance.
+                 */
+                final ContactMatch contactMatch = new ContactMatch(lookupKey, id);
+                if (duplicates.contains(contactMatch)) {
+                    continue;
+                }
+
+                /**
+                 * If the contact has either the name or number that matches the query, add to the
+                 * result.
+                 */
+                final boolean nameMatches = nameMatcher.matches(displayName);
+                final boolean numberMatches =
+                        (nameMatcher.matchesNumber(phoneNumber, query) != null);
+                if (nameMatches || numberMatches) {
+                    /** If a contact has not been added, add it to the result and the hash set.*/
+                    duplicates.add(contactMatch);
+                    result.add(new ContactNumber(id, dataID, displayName, phoneNumber, lookupKey,
+                            photoId, carrierPresence));
+                    counter++;
+                    if (DEBUG) {
+                        stopWatch.lap("Added one result: Name: " + displayName);
+                    }
+                }
+            }
+
+            if (DEBUG) {
+                stopWatch.stopAndLog(TAG + "Finished loading cursor", 0);
+            }
+        } finally {
+            cursor.close();
+        }
+        return result;
+    }
+}
Index: vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/SmartDialSortPreference.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/SmartDialSortPreference.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/SmartDialSortPreference.java	(revision 4299)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.contacts.common.preference;
+
+import java.util.Locale;
+
+import com.android.contacts.common.R;
+import com.android.contacts.common.preference.ContactsPreferences;
+
+import android.app.AlertDialog.Builder;
+import android.content.Context;
+import android.preference.ListPreference;
+import android.provider.ContactsContract;
+import android.util.AttributeSet;
+
+public class SmartDialSortPreference extends ListPreference{
+
+    private Context mContext;
+    private ContactsPreferences mPreferences;
+
+
+    public SmartDialSortPreference(Context context) {
+        super(context);
+        prepare();
+    }
+
+    public SmartDialSortPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        prepare();
+    }
+
+    private void prepare() {
+        mContext = getContext();
+        mPreferences =new ContactsPreferences(mContext);
+        setEntries(new String[]{
+                mContext.getString(R.string.sort_in_English),
+                mContext.getString(R.string.sort_in_Russian),
+        });
+        setEntryValues(new String[]{
+                String.valueOf(ContactsPreferences.SORT_IN_ENGLISH),
+                String.valueOf(ContactsPreferences.SORT_IN_RUSSIAN),
+        });
+        setValue(String.valueOf(mPreferences.getSmartDialSortOrder()));
+    }
+
+    @Override
+    public CharSequence getSummary() {
+        switch (mPreferences.getSmartDialSortOrder()) {
+            case ContactsPreferences.SORT_IN_ENGLISH:
+                return mContext.getString(R.string.sort_in_English);
+            case ContactsPreferences.SORT_IN_RUSSIAN:
+                return mContext.getString(R.string.sort_in_Russian);
+        }
+        return null;
+    }
+
+    @Override
+    protected boolean shouldPersist() {
+        return false;   // This preference takes care of its own storage
+    }
+
+    @Override
+    protected boolean persistString(String value) {
+        int newValue = Integer.parseInt(value);
+        if (newValue != mPreferences.getSmartDialSortOrder()) {
+            mPreferences.setSmartDialSortOrder(newValue);
+            notifyChanged();
+        }
+        return true;
+    }
+
+    @Override
+    // UX recommendation is not to show cancel button on such lists.
+    protected void onPrepareDialogBuilder(Builder builder) {
+        super.onPrepareDialogBuilder(builder);
+        builder.setNegativeButton(null, null);
+    }
+
+}
\ No newline at end of file
Index: vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/ContactsPreferences.java
===================================================================
--- vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/ContactsPreferences.java	(revision 0)
+++ vendor/branch/5058I_ALRU/packages/apps/ContactsCommon/src/com/android/contacts/common/preference/ContactsPreferences.java	(revision 4299)
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.common.preference;
+
+import android.accounts.Account;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.preference.PreferenceManager;
+import android.provider.ContactsContract;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
+import android.text.TextUtils;
+
+import com.android.contacts.common.R;
+import com.android.contacts.common.model.account.AccountWithDataSet;
+import com.android.contacts.common.model.account.GoogleAccountType;
+import com.android.contacts.common.model.AccountTypeManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Manages user preferences for contacts.
+ */
+public class ContactsPreferences implements OnSharedPreferenceChangeListener {
+
+    /**
+     * The value for the DISPLAY_ORDER key to show the given name first.
+     */
+    public static final int DISPLAY_ORDER_PRIMARY = 1;
+
+    /**
+     * The value for the DISPLAY_ORDER key to show the family name first.
+     */
+    public static final int DISPLAY_ORDER_ALTERNATIVE = 2;
+
+    public static final String DISPLAY_ORDER_KEY = "android.contacts.DISPLAY_ORDER";
+
+    /**
+     * The value for the SORT_ORDER key corresponding to sort by given name first.
+     */
+    public static final int SORT_ORDER_PRIMARY = 1;
+
+    public static final String SORT_ORDER_KEY = "android.contacts.SORT_ORDER";
+
+    /**
+     * The value for the SORT_ORDER key corresponding to sort by family name first.
+     */
+    public static final int SORT_ORDER_ALTERNATIVE = 2;
+
+    public static final String PREF_DISPLAY_ONLY_PHONES = "only_phones";
+
+    public static final boolean PREF_DISPLAY_ONLY_PHONES_DEFAULT = false;
+
+    public static final String DO_NOT_SYNC_CONTACT_METADATA_MSG = "Do not sync metadata";
+
+    public static final String CONTACT_METADATA_AUTHORITY = "com.android.contacts.metadata";
+
+    public static final String SHOULD_CLEAR_METADATA_BEFORE_SYNCING =
+            "should_clear_metadata_before_syncing";
+
+    public static final String ONLY_CLEAR_DONOT_SYNC = "only_clear_donot_sync";
+    /**
+     * Value to use when a preference is unassigned and needs to be read from the shared preferences
+     */
+    private static final int PREFERENCE_UNASSIGNED = -1;
+
+    private final Context mContext;
+    private int mSortOrder = PREFERENCE_UNASSIGNED;
+    private int mDisplayOrder = PREFERENCE_UNASSIGNED;
+    private String mDefaultAccount = null;
+    private ChangeListener mListener = null;
+    private Handler mHandler;
+    private final SharedPreferences mPreferences;
+	
+	//add by mzj for smart_dial start 
+	private int mSmartDialSortOrder = -1;
+    public final static int SORT_IN_RUSSIAN = 1;
+    public final static int SORT_IN_ENGLISH = 2;
+    public final static String SMART_DIAL_SORT_ORDER = "smart_dial_sort_order";
+	//add by mzj for smart_dial end 
+	
+    private String mDefaultAccountKey;
+    private String mDefaultAccountSavedKey;
+
+    public ContactsPreferences(Context context) {
+        mContext = context;
+        mHandler = new Handler();
+        mPreferences = mContext.getSharedPreferences(context.getPackageName(),
+                Context.MODE_PRIVATE);
+        mDefaultAccountKey = mContext.getResources().getString(
+                R.string.contact_editor_default_account_key);
+        mDefaultAccountSavedKey = mContext.getResources().getString(
+                R.string.contact_editor_anything_saved_key);
+        maybeMigrateSystemSettings();
+    }
+
+    public boolean isSortOrderUserChangeable() {
+        return mContext.getResources().getBoolean(R.bool.config_sort_order_user_changeable);
+    }
+
+    public int getDefaultSortOrder() {
+        if (mContext.getResources().getBoolean(R.bool.config_default_sort_order_primary)) {
+            return SORT_ORDER_PRIMARY;
+        } else {
+            return SORT_ORDER_ALTERNATIVE;
+        }
+    }
+
+    public int getSortOrder() {
+		/*
+        if (!isSortOrderUserChangeable()) {
+            return getDefaultSortOrder();
+        }*/
+        if (mSortOrder == PREFERENCE_UNASSIGNED) {
+            mSortOrder = mPreferences.getInt(SORT_ORDER_KEY, getDefaultSortOrder());
+        }
+        return mSortOrder;
+    }
+
+    public void setSortOrder(int sortOrder) {
+        mSortOrder = sortOrder;
+        final Editor editor = mPreferences.edit();
+        editor.putInt(SORT_ORDER_KEY, sortOrder);
+        editor.commit();
+    }
+
+	/* Begin, by mzj for smart_dial*/
+    public void setSmartDialSortOrder(int smartdialsortOrder) {
+        mSmartDialSortOrder = smartdialsortOrder;
+        Settings.System.putInt(mContext.getContentResolver(),
+            SMART_DIAL_SORT_ORDER, smartdialsortOrder);
+    }
+
+    public int getSmartDialSortOrder() {
+        mSmartDialSortOrder = Settings.System.getInt(mContext.getContentResolver(), SMART_DIAL_SORT_ORDER,SORT_IN_RUSSIAN);
+        return mSmartDialSortOrder;
+    }
+    /*End, by mzj for smart_dial*/
+	
+	
+    public boolean isDisplayOrderUserChangeable() {
+        return mContext.getResources().getBoolean(R.bool.config_display_order_user_changeable);
+    }
+	
+    public int getDefaultDisplayOrder() {
+        if (mContext.getResources().getBoolean(R.bool.config_default_display_order_primary)) {
+            return DISPLAY_ORDER_PRIMARY;
+        } else {
+            return DISPLAY_ORDER_ALTERNATIVE;
+        }
+    }
+
+    public int getDisplayOrder() {
+        if (!isDisplayOrderUserChangeable()) {
+            return getDefaultDisplayOrder();
+        }
+        if (mDisplayOrder == PREFERENCE_UNASSIGNED) {
+            mDisplayOrder = mPreferences.getInt(DISPLAY_ORDER_KEY, getDefaultDisplayOrder());
+        }
+        return mDisplayOrder;
+    }
+
+    public void setDisplayOrder(int displayOrder) {
+        mDisplayOrder = displayOrder;
+        final Editor editor = mPreferences.edit();
+        editor.putInt(DISPLAY_ORDER_KEY, displayOrder);
+        editor.commit();
+    }
+
+    public boolean isDefaultAccountUserChangeable() {
+        return mContext.getResources().getBoolean(R.bool.config_default_account_user_changeable);
+    }
+
+    public String getDefaultAccount() {
+        if (!isDefaultAccountUserChangeable()) {
+            return mDefaultAccount;
+        }
+        if (TextUtils.isEmpty(mDefaultAccount)) {
+            final String accountString = mPreferences
+                    .getString(mDefaultAccountKey, mDefaultAccount);
+            if (!TextUtils.isEmpty(accountString)) {
+                final AccountWithDataSet accountWithDataSet = AccountWithDataSet.unstringify(
+                        accountString);
+                mDefaultAccount = accountWithDataSet.name;
+            }
+        }
+        return mDefaultAccount;
+    }
+
+    public void setDefaultAccount(AccountWithDataSet accountWithDataSet) {
+        mDefaultAccount = accountWithDataSet == null ? null : accountWithDataSet.name;
+        final Editor editor = mPreferences.edit();
+        if (TextUtils.isEmpty(mDefaultAccount)) {
+            editor.remove(mDefaultAccountKey);
+        } else {
+            editor.putString(mDefaultAccountKey, accountWithDataSet.stringify());
+        }
+        editor.putBoolean(mDefaultAccountSavedKey, true);
+        editor.commit();
+    }
+
+    public String getContactMetadataSyncAccountName() {
+        final Account syncAccount = getContactMetadataSyncAccount();
+        return syncAccount == null ? DO_NOT_SYNC_CONTACT_METADATA_MSG : syncAccount.name;
+    }
+
+    public void setContactMetadataSyncAccount(AccountWithDataSet accountWithDataSet) {
+        final String mContactMetadataSyncAccount =
+                accountWithDataSet == null ? null : accountWithDataSet.name;
+        requestMetadataSyncForAccount(mContactMetadataSyncAccount);
+    }
+
+    private Account getContactMetadataSyncAccount() {
+        for (Account account : getFocusGoogleAccounts()) {
+            if (ContentResolver.getIsSyncable(account, CONTACT_METADATA_AUTHORITY) == 1
+                    && ContentResolver.getSyncAutomatically(account, CONTACT_METADATA_AUTHORITY)) {
+                return account;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Turn on contact metadata sync for this {@param accountName} and turn off automatic sync
+     * for other accounts. If accountName is null, then turn off automatic sync for all accounts.
+     */
+    private void requestMetadataSyncForAccount(String accountName) {
+        for (Account account : getFocusGoogleAccounts()) {
+            if (!TextUtils.isEmpty(accountName) && accountName.equals(account.name)) {
+                // Request sync.
+                final Bundle b = new Bundle();
+                b.putBoolean(SHOULD_CLEAR_METADATA_BEFORE_SYNCING, true);
+                b.putBoolean(ONLY_CLEAR_DONOT_SYNC, false);
+                b.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
+                b.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
+                ContentResolver.requestSync(account, CONTACT_METADATA_AUTHORITY, b);
+
+                ContentResolver.setSyncAutomatically(account, CONTACT_METADATA_AUTHORITY, true);
+            } else if (ContentResolver.getSyncAutomatically(account, CONTACT_METADATA_AUTHORITY)) {
+                // Turn off automatic sync for previous sync account.
+                ContentResolver.setSyncAutomatically(account, CONTACT_METADATA_AUTHORITY, false);
+                if (TextUtils.isEmpty(accountName)) {
+                    // Request sync to clear old data.
+                    final Bundle b = new Bundle();
+                    b.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
+                    b.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
+                    b.putBoolean(SHOULD_CLEAR_METADATA_BEFORE_SYNCING, true);
+                    b.putBoolean(ONLY_CLEAR_DONOT_SYNC, true);
+                    ContentResolver.requestSync(account, CONTACT_METADATA_AUTHORITY, b);
+                }
+            }
+        }
+    }
+
+    /**
+     * @return google accounts with "com.google" account type and null data set.
+     */
+    private List<Account> getFocusGoogleAccounts() {
+        List<Account> focusGoogleAccounts = new ArrayList<Account>();
+        final AccountTypeManager accountTypeManager = AccountTypeManager.getInstance(mContext);
+        List<AccountWithDataSet> accounts = accountTypeManager.getAccounts(true);
+        for (AccountWithDataSet account : accounts) {
+            if (GoogleAccountType.ACCOUNT_TYPE.equals(account.type) && account.dataSet == null) {
+                focusGoogleAccounts.add(account.getAccountOrNull());
+            }
+        }
+        return focusGoogleAccounts;
+    }
+
+    public void registerChangeListener(ChangeListener listener) {
+        if (mListener != null) unregisterChangeListener();
+
+        mListener = listener;
+
+        // Reset preferences to "unknown" because they may have changed while the
+        // listener was unregistered.
+        mDisplayOrder = PREFERENCE_UNASSIGNED;
+        mSortOrder = PREFERENCE_UNASSIGNED;
+        mDefaultAccount = null;
+
+        mPreferences.registerOnSharedPreferenceChangeListener(this);
+    }
+
+    public void unregisterChangeListener() {
+        if (mListener != null) {
+            mListener = null;
+        }
+
+        mPreferences.unregisterOnSharedPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, final String key) {
+        // This notification is not sent on the Ui thread. Use the previously created Handler
+        // to switch to the Ui thread
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                refreshValue(key);
+            }
+        });
+    }
+
+    /**
+     * Forces the value for the given key to be looked up from shared preferences and notifies
+     * the registered {@link ChangeListener}
+     *
+     * @param key the {@link SharedPreferences} key to look up
+     */
+    public void refreshValue(String key) {
+        if (DISPLAY_ORDER_KEY.equals(key)) {
+            mDisplayOrder = PREFERENCE_UNASSIGNED;
+            mDisplayOrder = getDisplayOrder();
+        } else if (SORT_ORDER_KEY.equals(key)) {
+            mSortOrder = PREFERENCE_UNASSIGNED;
+            mSortOrder = getSortOrder();
+        } else if (mDefaultAccountKey.equals(key)) {
+            mDefaultAccount = null;
+            mDefaultAccount = getDefaultAccount();
+        }
+        if (mListener != null) mListener.onChange();
+    }
+
+    public interface ChangeListener {
+        void onChange();
+    }
+
+    /**
+     * If there are currently no preferences (which means this is the first time we are run),
+     * For sort order and display order, check to see if there are any preferences stored in
+     * system settings (pre-L) which can be copied into our own SharedPreferences.
+     * For default account setting, check to see if there are any preferences stored in the previous
+     * SharedPreferences which can be copied into current SharedPreferences.
+     */
+    private void maybeMigrateSystemSettings() {
+        if (!mPreferences.contains(SORT_ORDER_KEY)) {
+            int sortOrder = getDefaultSortOrder();
+            try {
+                 sortOrder = Settings.System.getInt(mContext.getContentResolver(),
+                        SORT_ORDER_KEY);
+            } catch (SettingNotFoundException e) {
+            }
+            setSortOrder(sortOrder);
+        }
+
+        if (!mPreferences.contains(DISPLAY_ORDER_KEY)) {
+            int displayOrder = getDefaultDisplayOrder();
+            try {
+                displayOrder = Settings.System.getInt(mContext.getContentResolver(),
+                        DISPLAY_ORDER_KEY);
+            } catch (SettingNotFoundException e) {
+            }
+            setDisplayOrder(displayOrder);
+        }
+
+        if (!mPreferences.contains(mDefaultAccountKey)) {
+            final SharedPreferences previousPrefs =
+                    PreferenceManager.getDefaultSharedPreferences(mContext);
+            final String defaultAccount = previousPrefs.getString(mDefaultAccountKey, null);
+            if (!TextUtils.isEmpty(defaultAccount)) {
+                final AccountWithDataSet accountWithDataSet = AccountWithDataSet.unstringify(
+                        defaultAccount);
+                setDefaultAccount(accountWithDataSet);
+            }
+        }
+    }
+}
